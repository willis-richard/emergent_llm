"""
Generated LLM strategies for social dilemma games.

This file contains strategy classes generated by LLMs for game theory experiments.
Each strategy is a callable class that implements a specific approach to the game.

Generated with:
- Provider: Anthropic
- Model: claude-sonnet-4-0
- Game: CollectiveRiskDescription
"""

from emergent_llm.players.base_player import BaseStrategy
from emergent_llm.games import PublicGoodsDescription, CollectiveRiskDescription
from emergent_llm.common.actions import Action, C, D
from emergent_llm.common.history import PlayerHistory
import numpy as np
from numpy.typing import NDArray
import math
import random



class Strategy_COOPERATIVE_1(BaseStrategy):
    """
    Adaptive Threshold Guardian: A cooperative strategy that prioritizes collective welfare
    while maintaining resilience against exploitation. Starts cooperative, adapts based on
    threshold achievement, and includes self-correction mechanisms.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        if current_round == r:
            recent_cooperation_rate = self._get_recent_cooperation_rate(history)
            threshold_rate = m / n * 0.8
            if recent_cooperation_rate >= threshold_rate:
                return Action.C
            else:
                return Action.D
        else:
            last_round_idx = history.round_number - 1
            cooperators_last_round = self._count_cooperators_last_round(history, last_round_idx)
            my_last_action = history.my_actions[last_round_idx]
            if cooperators_last_round >= m:
                return Action.C
            else:
                deficit = m - cooperators_last_round
                if deficit == 1 and (not my_last_action):
                    return Action.C
                elif deficit <= 2:
                    return Action.C
                else:
                    return Action.D

    def _count_cooperators_last_round(self, history: PlayerHistory, round_idx: int) -> int:
        """Count total cooperators (including myself) in the specified round."""
        opponent_cooperators = sum(history.opponent_actions[round_idx])
        my_cooperation = 1 if history.my_actions[round_idx] else 0
        return int(opponent_cooperators + my_cooperation)

    def _get_recent_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate cooperation rate over the last 3 rounds (or all available rounds if fewer)."""
        n = self.game_description.n_players
        rounds_to_check = min(3, history.round_number)
        if rounds_to_check == 0:
            return 0.0
        total_cooperators = 0
        for i in range(rounds_to_check):
            round_idx = history.round_number - 1 - i
            total_cooperators += self._count_cooperators_last_round(history, round_idx)
        return total_cooperators / (rounds_to_check * n)

class Strategy_AGGRESSIVE_1(BaseStrategy):
    """
    Exploitative Threshold Rider: An aggressive strategy that maximizes free-riding
    while strategically cooperating only when necessary to maintain the threshold.
    Always defects in first and last rounds, and exploits cooperative players.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        last_round_idx = history.round_number - 1
        observed_cooperators = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            observed_cooperators += 1
        m = self.game_description.m
        if observed_cooperators >= m:
            return Action.D
        my_cooperation_rate = sum(history.my_actions) / len(history.my_actions)
        cooperative_trend = self._calculate_cooperation_trend(history)
        rounds_remaining = self.game_description.n_rounds - current_round
        if observed_cooperators == m - 1:
            if cooperative_trend > 0.6 and rounds_remaining > 3:
                return Action.C
            else:
                return Action.D
        elif observed_cooperators == m - 2:
            if my_cooperation_rate < 0.3:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _calculate_cooperation_trend(self, history: PlayerHistory) -> float:
        """Calculate cooperation trend to exploit cooperative players"""
        if history.round_number < 3:
            return 0.4
        total_players = self.game_description.n_players
        recent_rounds = min(3, history.round_number)
        recent_cooperation = 0
        for i in range(recent_rounds):
            round_idx = history.round_number - 1 - i
            round_cooperators = sum(history.opponent_actions[round_idx])
            if history.my_actions[round_idx]:
                round_cooperators += 1
            recent_cooperation += round_cooperators / total_players
        recent_cooperation_rate = recent_cooperation / recent_rounds
        if history.round_number >= 6:
            early_cooperation = 0
            for i in range(3):
                round_cooperators = sum(history.opponent_actions[i])
                if history.my_actions[i]:
                    round_cooperators += 1
                early_cooperation += round_cooperators / total_players
            early_cooperation_rate = early_cooperation / 3
            if recent_cooperation_rate > early_cooperation_rate:
                return recent_cooperation_rate
            else:
                return 0.4
        else:
            return recent_cooperation_rate

class Strategy_COOPERATIVE_2(BaseStrategy):
    """
    Adaptive Collective Guardian: A cooperative strategy that prioritizes collective welfare
    while maintaining resilience against exploitation. Adapts cooperation based on group
    performance and cooperation trends.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.consecutive_failures = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        m = self.game_description.m
        n_players = self.game_description.n_players
        if current_round == n_rounds:
            estimated_cooperators = self._estimate_cooperators_this_round(history)
            if estimated_cooperators >= m - 1:
                return Action.C
            else:
                return Action.D
        recent_success_rate = self._calculate_recent_success_rate(history)
        cooperation_trend = self._analyze_cooperation_trend(history)
        if recent_success_rate >= 0.7 and cooperation_trend >= 0:
            return Action.C
        elif recent_success_rate >= 0.4:
            cooperation_probability = 0.6 + recent_success_rate * 0.4
            if random.random() < cooperation_probability:
                return Action.C
            else:
                return Action.D
        elif self.consecutive_failures >= 3:
            self.consecutive_failures = 0
            return Action.C
        else:
            estimated_cooperators = self._estimate_cooperators_this_round(history)
            if estimated_cooperators >= m - 1:
                return Action.C
            else:
                return Action.D

    def _calculate_recent_success_rate(self, history: PlayerHistory) -> float:
        """Calculate success rate over recent rounds."""
        current_round = history.round_number
        recent_rounds = min(5, current_round)
        if recent_rounds == 0:
            return 1.0
        successes = 0
        m = self.game_description.m
        for round_idx in range(max(0, current_round - recent_rounds), current_round):
            my_action = history.my_actions[round_idx]
            opponent_cooperators = sum(history.opponent_actions[round_idx])
            total_cooperators = int(my_action) + opponent_cooperators
            if total_cooperators >= m:
                successes += 1
        if current_round > 0:
            last_round_idx = current_round - 1
            my_last_action = history.my_actions[last_round_idx]
            last_opponent_cooperators = sum(history.opponent_actions[last_round_idx])
            last_total_cooperators = int(my_last_action) + last_opponent_cooperators
            if last_total_cooperators < m:
                self.consecutive_failures += 1
            else:
                self.consecutive_failures = 0
        return successes / recent_rounds

    def _analyze_cooperation_trend(self, history: PlayerHistory) -> float:
        """Analyze trend in cooperation rates."""
        current_round = history.round_number
        if current_round <= 3:
            return 0.0
        recent_start = max(0, current_round - 3)
        recent_cooperation = 0
        recent_count = 0
        for round_idx in range(recent_start, current_round):
            my_action = history.my_actions[round_idx]
            opponent_cooperators = sum(history.opponent_actions[round_idx])
            total_cooperators = int(my_action) + opponent_cooperators
            recent_cooperation += total_cooperators / self.game_description.n_players
            recent_count += 1
        if recent_count > 0:
            recent_cooperation /= recent_count
        earlier_start = max(0, current_round - 6)
        earlier_end = max(0, current_round - 3)
        earlier_cooperation = 0
        earlier_count = 0
        for round_idx in range(earlier_start, earlier_end):
            my_action = history.my_actions[round_idx]
            opponent_cooperators = sum(history.opponent_actions[round_idx])
            total_cooperators = int(my_action) + opponent_cooperators
            earlier_cooperation += total_cooperators / self.game_description.n_players
            earlier_count += 1
        if earlier_count > 0:
            earlier_cooperation /= earlier_count
        else:
            return 0.0
        return recent_cooperation - earlier_cooperation

    def _estimate_cooperators_this_round(self, history: PlayerHistory) -> float:
        """Estimate number of cooperators for this round."""
        current_round = history.round_number
        n_opponents = self.game_description.n_players - 1
        if current_round == 0:
            return n_opponents * 0.8
        consistent_cooperators = 0
        occasional_cooperators = 0
        for opponent_idx in range(n_opponents):
            cooperations = sum(history.opponent_actions[:current_round, opponent_idx])
            cooperation_rate = cooperations / current_round
            if cooperation_rate >= 0.7:
                consistent_cooperators += 1
            elif cooperation_rate >= 0.3:
                occasional_cooperators += 1
        estimated = consistent_cooperators + occasional_cooperators * 0.5
        return estimated

class Strategy_COOPERATIVE_3(BaseStrategy):
    """
    Adaptive Threshold Guardian: A cooperative strategy that prioritizes collective welfare
    while being resilient against exploitation. It maintains cooperation when possible but
    adapts intelligently to behavior patterns, using threshold-aware decisions and
    context-sensitive adaptation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self.window_size = min(5, max(1, self.r // 3))
        self.trust_threshold = 0.6

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.r:
            recent_cooperation_rate = self._calculate_recent_cooperation(history)
            if recent_cooperation_rate >= (self.m - 1) / self.n:
                return Action.C
            else:
                return Action.D
        else:
            estimated_cooperators = self._estimate_cooperators(history)
            if self._last_round_threshold_met(history):
                if estimated_cooperators >= self.m - 1:
                    return Action.C
                elif estimated_cooperators >= self.m - 2:
                    return Action.C
                else:
                    return Action.D
            elif estimated_cooperators >= self.m - 1:
                return Action.C
            elif current_round <= self.r / 2:
                return Action.C
            else:
                return Action.D

    def _estimate_cooperators(self, history: PlayerHistory) -> int:
        """Estimate how many opponents will cooperate based on recent patterns."""
        estimated_cooperators = 0
        current_round = history.round_number
        for player_idx in range(self.n - 1):
            recent_coop_rate = self._cooperation_rate(history, player_idx, max(0, current_round - self.window_size), current_round - 1)
            if recent_coop_rate >= self.trust_threshold:
                estimated_cooperators += 1
        return estimated_cooperators

    def _cooperation_rate(self, history: PlayerHistory, player_idx: int, start_round: int, end_round: int) -> float:
        """Calculate cooperation rate for a player over specified rounds."""
        if end_round < start_round or start_round < 0:
            return 0.0
        cooperations = 0
        total_rounds = 0
        for round_idx in range(start_round, min(end_round + 1, history.round_number)):
            if history.opponent_actions[round_idx, player_idx]:
                cooperations += 1
            total_rounds += 1
        return cooperations / total_rounds if total_rounds > 0 else 0.0

    def _calculate_recent_cooperation(self, history: PlayerHistory) -> float:
        """Calculate overall recent cooperation rate across all players."""
        current_round = history.round_number
        total_cooperators = 0
        total_decisions = 0
        window_start = max(0, current_round - self.window_size)
        for round_idx in range(window_start, current_round):
            round_cooperators = sum(history.opponent_actions[round_idx]) + (1 if history.my_actions[round_idx] else 0)
            total_cooperators += round_cooperators
            total_decisions += self.n
        return total_cooperators / total_decisions if total_decisions > 0 else 0.0

    def _last_round_threshold_met(self, history: PlayerHistory) -> bool:
        """Check if the threshold was met in the most recent round."""
        if history.round_number == 0:
            return False
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            cooperators_last_round += 1
        return cooperators_last_round >= self.m

class Strategy_COOPERATIVE_4(BaseStrategy):
    """
    Threshold-Aware Conditional Cooperator: A cooperative strategy that balances
    collective benefit with protection against exploitation by monitoring cooperation
    rates and threshold proximity while maintaining cooperative signals.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        threshold = self.game_description.m
        if current_round == total_rounds:
            return Action.C
        rounds_to_check = min(3, history.round_number)
        recent_cooperators = 0
        total_opportunities = 0
        for i in range(rounds_to_check):
            round_idx = history.round_number - 1 - i
            if round_idx >= 0:
                cooperators_in_round = sum(history.opponent_actions[round_idx])
                if history.my_actions[round_idx]:
                    cooperators_in_round += 1
                recent_cooperators += cooperators_in_round
                total_opportunities += n_players
        recent_cooperation_rate = recent_cooperators / total_opportunities if total_opportunities > 0 else 0
        last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
        if history.my_actions[history.round_number - 1]:
            last_round_cooperators += 1
        target_rate = threshold / n_players + 0.1
        if recent_cooperation_rate >= target_rate:
            return Action.C
        elif last_round_cooperators >= threshold - 1:
            return Action.C
        elif recent_cooperation_rate < 0.3:
            if current_round % 3 == 1:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_5(BaseStrategy):
    """
    Adaptive Trust Builder: A cooperative strategy that builds trust gradually,
    rewards cooperation, but maintains safeguards against exploitation.
    Balances collective welfare with rational protection against free-riders.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        prev_round_idx = history.round_number - 1
        prev_cooperators = int(sum(history.opponent_actions[prev_round_idx]))
        if history.my_actions[prev_round_idx]:
            prev_cooperators += 1
        coop_rate = prev_cooperators / n
        if current_round == r:
            total_cooperators = 0
            total_possible = 0
            for round_idx in range(history.round_number):
                round_cooperators = int(sum(history.opponent_actions[round_idx]))
                if history.my_actions[round_idx]:
                    round_cooperators += 1
                total_cooperators += round_cooperators
                total_possible += n
            avg_coop_rate = total_cooperators / total_possible if total_possible > 0 else 0
            if avg_coop_rate >= 0.5:
                if prev_cooperators >= m - 1:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
        if prev_cooperators >= m + 1:
            return Action.C
        elif prev_cooperators == m:
            return Action.C
        elif prev_cooperators == m - 1:
            return Action.C
        elif coop_rate >= 0.4:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_6(BaseStrategy):
    """
    Adaptive Threshold Guardian: A cooperative strategy that prioritizes collective welfare
    while being resilient to exploitation. Maintains cooperation when beneficial and adapts
    to ensure the cooperation threshold is met through forgiveness mechanisms and trend analysis.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.forgiveness_rounds = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        if current_round == r:
            expected_cooperators = self._estimate_cooperators(history)
            if expected_cooperators >= m - 1:
                return Action.C
            else:
                return Action.D
        if current_round == r - 1:
            if current_round >= 3:
                recent_cooperation = self._get_recent_cooperation_rate(history, 3)
                if recent_cooperation >= m / n:
                    return Action.C
            return Action.C
        last_round_cooperators = self._count_cooperators_last_round(history)
        others_cooperation_rate = self._get_others_cooperation_rate(history)
        if self.forgiveness_rounds > 0:
            self.forgiveness_rounds -= 1
            return Action.C
        if last_round_cooperators >= m:
            return Action.C
        elif last_round_cooperators == m - 1:
            return Action.C
        else:
            if last_round_cooperators < m - 1:
                self.forgiveness_rounds = min(2, r - current_round)
            if others_cooperation_rate > 0.4:
                return Action.C
            else:
                if current_round > 3:
                    stable_cooperators = self._count_stable_cooperators(history)
                    if stable_cooperators >= m - 1:
                        return Action.C
                if current_round >= 3:
                    trend_improving = self._is_cooperation_trend_improving(history)
                    if trend_improving:
                        return Action.C
                if n <= 4 or m >= n - 1:
                    return Action.C
                return Action.D

    def _count_cooperators_last_round(self, history: PlayerHistory) -> int:
        """Count cooperators (including self) in the most recent round."""
        if history.round_number == 0:
            return 0
        last_round_idx = history.round_number - 1
        opponent_cooperators = int(np.sum(history.opponent_actions[last_round_idx]))
        my_cooperation = int(history.my_actions[last_round_idx])
        return opponent_cooperators + my_cooperation

    def _get_others_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate average cooperation rate of other players."""
        if history.round_number == 0:
            return 0.0
        total_others_actions = history.opponent_actions.size
        if total_others_actions == 0:
            return 0.0
        total_cooperations = int(np.sum(history.opponent_actions))
        return total_cooperations / total_others_actions

    def _get_recent_cooperation_rate(self, history: PlayerHistory, rounds: int) -> float:
        """Calculate cooperation rate over the last 'rounds' rounds for all players."""
        if history.round_number == 0:
            return 0.0
        start_round = max(0, history.round_number - rounds)
        my_cooperations = int(np.sum(history.my_actions[start_round:]))
        others_cooperations = int(np.sum(history.opponent_actions[start_round:]))
        total_actions = (history.round_number - start_round) * self.game_description.n_players
        if total_actions == 0:
            return 0.0
        return (my_cooperations + others_cooperations) / total_actions

    def _count_stable_cooperators(self, history: PlayerHistory) -> int:
        """Count players who cooperated in >= 80% of rounds."""
        if history.round_number == 0:
            return 0
        threshold = 0.8
        stable_count = 0
        my_rate = np.sum(history.my_actions) / history.round_number
        if my_rate >= threshold:
            stable_count += 1
        for player_idx in range(history.opponent_actions.shape[1]):
            player_cooperations = np.sum(history.opponent_actions[:, player_idx])
            player_rate = player_cooperations / history.round_number
            if player_rate >= threshold:
                stable_count += 1
        return stable_count

    def _is_cooperation_trend_improving(self, history: PlayerHistory) -> bool:
        """Check if cooperation trend is improving over last 3 rounds."""
        if history.round_number < 3:
            return False
        recent_rate = self._get_recent_cooperation_rate(history, 3)
        if history.round_number >= 6:
            start_prev = max(0, history.round_number - 6)
            end_prev = history.round_number - 3
            prev_my_cooperations = int(np.sum(history.my_actions[start_prev:end_prev]))
            prev_others_cooperations = int(np.sum(history.opponent_actions[start_prev:end_prev]))
            prev_total_actions = 3 * self.game_description.n_players
            prev_rate = (prev_my_cooperations + prev_others_cooperations) / prev_total_actions
            return recent_rate > prev_rate
        return recent_rate > 0.5

    def _estimate_cooperators(self, history: PlayerHistory) -> int:
        """Estimate expected cooperators in the next round based on recent behavior."""
        if history.round_number == 0:
            return self.game_description.n_players
        last_round_cooperators = self._count_cooperators_last_round(history)
        if history.round_number >= 3:
            if self._is_cooperation_trend_improving(history):
                return min(self.game_description.n_players, last_round_cooperators + 1)
        return last_round_cooperators

class Strategy_COOPERATIVE_7(BaseStrategy):
    """
    Threshold-Aware Conditional Cooperator: A strategy that balances collective welfare
    with protection against exploitation through adaptive cooperation based on threshold
    dynamics and cooperation trends.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        if current_round == r:
            return self._final_round_decision(history)
        last_round_idx = history.round_number - 1
        last_cooperators = self._count_total_cooperators(history, last_round_idx)
        avg_cooperation_rate = self._calculate_avg_cooperation_rate(history)
        if last_cooperators >= m + 1:
            return Action.C
        elif last_cooperators == m:
            if avg_cooperation_rate >= m / n * 0.8:
                return Action.C
            else:
                return Action.D
        elif last_cooperators == m - 1:
            if self._cooperation_trend_positive(history, window=3):
                return Action.C
            else:
                return Action.D
        elif self._recent_cooperation_surge(history, threshold=0.3):
            return Action.C
        else:
            return Action.D

    def _final_round_decision(self, history: PlayerHistory) -> Action:
        """Conditional cooperation in the final round."""
        n = self.game_description.n_players
        m = self.game_description.m
        avg_cooperation_rate = self._calculate_avg_cooperation_rate(history)
        last_round_idx = history.round_number - 1
        last_cooperators = self._count_total_cooperators(history, last_round_idx)
        if avg_cooperation_rate >= 0.6 and last_cooperators >= m - 1:
            return Action.C
        else:
            return Action.D

    def _count_total_cooperators(self, history: PlayerHistory, round_idx: int) -> int:
        """Count total cooperators (including self) in a given round."""
        opponent_cooperators = int(np.sum(history.opponent_actions[round_idx]))
        my_cooperation = int(history.my_actions[round_idx])
        return opponent_cooperators + my_cooperation

    def _calculate_avg_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate average cooperation rate across all rounds and players."""
        n = self.game_description.n_players
        total_cooperations = 0
        total_decisions = 0
        for round_idx in range(history.round_number):
            total_cooperations += self._count_total_cooperators(history, round_idx)
            total_decisions += n
        return total_cooperations / total_decisions if total_decisions > 0 else 0.0

    def _cooperation_trend_positive(self, history: PlayerHistory, window: int) -> bool:
        """Check if cooperation trend is positive over the specified window."""
        n = self.game_description.n_players
        m = self.game_description.m
        rounds_available = history.round_number
        actual_window = min(window, rounds_available)
        if actual_window < 2:
            return False
        recent_rates = []
        for i in range(actual_window):
            round_idx = rounds_available - 1 - i
            cooperators = self._count_total_cooperators(history, round_idx)
            rate = cooperators / n
            recent_rates.append(rate)
        recent_rates.reverse()
        threshold_rate = m / n
        if recent_rates[-1] >= threshold_rate * 0.8:
            return True
        if len(recent_rates) >= 2 and recent_rates[-1] > recent_rates[0]:
            return True
        return False

    def _recent_cooperation_surge(self, history: PlayerHistory, threshold: float) -> bool:
        """Detect if there's been a recent surge in cooperation."""
        n = self.game_description.n_players
        rounds_available = history.round_number
        if rounds_available < 2:
            return False
        recent_idx = rounds_available - 1
        previous_idx = rounds_available - 2
        recent_rate = self._count_total_cooperators(history, recent_idx) / n
        previous_rate = self._count_total_cooperators(history, previous_idx) / n
        return recent_rate - previous_rate >= threshold

class Strategy_COOPERATIVE_8(BaseStrategy):
    """
    Adaptive Threshold Guardian Strategy
    
    Prioritizes collective welfare while being resilient to defection. Maintains cooperation
    when possible but adapts intelligently to ensure the threshold is met. Always cooperates
    in round 1, then adapts based on previous cooperation levels, and uses historical data
    for final round decisions.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        if current_round < r:
            last_round_idx = history.round_number - 1
            opponent_cooperators = sum(history.opponent_actions[last_round_idx])
            my_last_action = history.my_actions[last_round_idx]
            total_cooperators = opponent_cooperators + (1 if my_last_action else 0)
            if total_cooperators >= m:
                return Action.C
            elif total_cooperators == m - 1:
                return Action.C
            else:
                return Action.D
        else:
            total_rounds_completed = history.round_number
            total_cooperations = 0
            for round_idx in range(total_rounds_completed):
                opponent_cooperators = sum(history.opponent_actions[round_idx])
                my_cooperation = 1 if history.my_actions[round_idx] else 0
                total_cooperations += opponent_cooperators + my_cooperation
            total_possible_cooperations = total_rounds_completed * n
            avg_cooperation_rate = total_cooperations / total_possible_cooperations
            threshold_rate = m / n
            if avg_cooperation_rate >= threshold_rate:
                return Action.C
            else:
                return Action.D

class Strategy_COOPERATIVE_9(BaseStrategy):
    """
    Adaptive Trust Builder: A cooperative strategy that starts optimistically and builds trust
    while being resilient to occasional defections. Uses threshold-based cooperation with
    forgiveness mechanisms and protection against exploitation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        prev_round_idx = history.round_number - 1
        prev_opponent_cooperators = sum(history.opponent_actions[prev_round_idx])
        my_prev_action = history.my_actions[prev_round_idx]
        prev_total_cooperators = prev_opponent_cooperators + (1 if my_prev_action else 0)
        cooperation_rate = prev_total_cooperators / n
        if current_round == r:
            return Action.C if cooperation_rate >= 0.6 else Action.D
        if history.round_number >= 3:
            recent_cooperation = []
            for i in range(3):
                round_idx = history.round_number - 1 - i
                opp_coop = sum(history.opponent_actions[round_idx])
                my_coop = 1 if history.my_actions[round_idx] else 0
                total_coop = opp_coop + my_coop
                recent_cooperation.append(total_coop)
            if all((coop < m - 1 for coop in recent_cooperation)) and cooperation_rate < 0.3:
                return Action.C if prev_total_cooperators >= m - 1 else Action.D
        if prev_total_cooperators >= m - 1:
            return Action.C
        if cooperation_rate >= 0.5:
            return Action.C
        if history.round_number >= 2:
            trend_round_idx = history.round_number - 2
            trend_opp_cooperators = sum(history.opponent_actions[trend_round_idx])
            my_trend_action = history.my_actions[trend_round_idx]
            trend_total_cooperators = trend_opp_cooperators + (1 if my_trend_action else 0)
            if prev_total_cooperators > trend_total_cooperators:
                return Action.C
        return Action.D

class Strategy_COOPERATIVE_10(BaseStrategy):
    """
    Cooperative Threshold Guardian: A strategy that balances trust-building with pragmatic
    risk management. Starts cooperative, rewards successful cooperation, and adapts based
    on group dynamics and threshold proximity.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        last_round_idx = history.round_number - 1
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        my_last_action = history.my_actions[last_round_idx]
        total_cooperators = opponent_cooperators + (1 if my_last_action else 0)
        if current_round == r:
            rounds_to_check = min(3, history.round_number)
            recent_cooperation = 0
            for i in range(rounds_to_check):
                round_idx = last_round_idx - i
                if round_idx >= 0:
                    round_cooperators = sum(history.opponent_actions[round_idx])
                    round_cooperators += 1 if history.my_actions[round_idx] else 0
                    recent_cooperation += round_cooperators
            avg_recent_cooperation = recent_cooperation / rounds_to_check
            if total_cooperators >= m:
                return Action.C
            elif avg_recent_cooperation >= m - 1:
                return Action.C
            else:
                return Action.D
        if total_cooperators >= m:
            return Action.C
        elif my_last_action:
            if total_cooperators >= m - 1:
                return Action.C
            else:
                return Action.D
        elif total_cooperators >= m - 2:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_11(BaseStrategy):
    """
    Optimistic Threshold Guardian: A cooperative strategy that prioritizes collective welfare
    while maintaining resilience against defection. Always cooperates on first round,
    estimates cooperators to make strategic decisions, and adapts behavior based on
    cooperation trends and game phase.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self.trust_threshold = 0.6

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_num = history.round_number + 1
        if round_num == self.r:
            return self._cooperate_if_viable(history)
        cooperation_threshold = max(self.m, int(self.n * 0.4))
        expected_cooperators = self._estimate_cooperators(history)
        if expected_cooperators >= cooperation_threshold:
            return Action.C
        else:
            return self._evaluate_conditional_cooperation(history, expected_cooperators, round_num)

    def _estimate_cooperators(self, history: PlayerHistory) -> float:
        """Estimate number of cooperators for the next round"""
        if history.round_number == 0:
            return self.n * 0.7
        consistent_cooperators = 0
        for player_idx in range(self.n - 1):
            player_actions = history.opponent_actions[:, player_idx]
            coop_rate = np.mean(player_actions)
            if coop_rate > 0.7:
                consistent_cooperators += 1
        recent_rounds = min(3, history.round_number)
        recent_cooperation = 0
        for round_idx in range(history.round_number - recent_rounds, history.round_number):
            recent_cooperation += np.sum(history.opponent_actions[round_idx])
        trend_cooperators = recent_cooperation / recent_rounds if recent_rounds > 0 else 0
        base_estimate = max(consistent_cooperators, trend_cooperators * 0.8)
        return base_estimate + 1

    def _evaluate_conditional_cooperation(self, history: PlayerHistory, expected_cooperators: float, round_num: int) -> Action:
        """Evaluate whether to cooperate when threshold might not be met"""
        if expected_cooperators >= self.m - 1:
            return Action.C
        if self._high_trust_situation(history) and self.r - round_num > 3:
            return Action.C
        if self._detect_mass_defection(history):
            if expected_cooperators >= self.m - 1:
                return Action.C
            else:
                return Action.D
        game_phase = round_num / self.r
        if game_phase <= 0.33:
            if expected_cooperators >= self.m * 0.8:
                return Action.C
        elif game_phase <= 0.67:
            if expected_cooperators >= self.m * 0.9:
                return Action.C
        elif expected_cooperators >= self.m - 0.5:
            return Action.C
        return Action.D

    def _cooperate_if_viable(self, history: PlayerHistory) -> Action:
        """Final round decision logic"""
        expected_cooperators = self._estimate_cooperators(history) - 1
        if expected_cooperators >= self.m - 1:
            return Action.C
        elif expected_cooperators >= self.m - 2 and self._high_trust_situation(history):
            return Action.C
        else:
            return Action.D

    def _high_trust_situation(self, history: PlayerHistory) -> bool:
        """Determine if we're in a high-trust situation"""
        if history.round_number < 2:
            return True
        recent_rounds = min(3, history.round_number)
        recent_cooperation = 0
        total_decisions = 0
        for round_idx in range(history.round_number - recent_rounds, history.round_number):
            recent_cooperation += np.sum(history.opponent_actions[round_idx])
            total_decisions += self.n - 1
        cooperation_rate = recent_cooperation / total_decisions if total_decisions > 0 else 0
        return cooperation_rate > self.trust_threshold

    def _detect_mass_defection(self, history: PlayerHistory) -> bool:
        """Detect if we're in a mass defection scenario"""
        if history.round_number < 3:
            return False
        recent_rounds = min(3, history.round_number)
        total_cooperation = 0
        total_decisions = 0
        for round_idx in range(history.round_number - recent_rounds, history.round_number):
            total_cooperation += np.sum(history.opponent_actions[round_idx])
            total_decisions += self.n - 1
        cooperation_rate = total_cooperation / total_decisions if total_decisions > 0 else 0
        return cooperation_rate < 0.2

class Strategy_COOPERATIVE_12(BaseStrategy):
    """
    Trust-Building Collective Guardian: A cooperative strategy that prioritizes collective welfare
    while being resilient to exploitation. It aims to establish and maintain cooperation through
    trust-building, forgiveness, and strategic adaptation based on cooperation trends and threshold awareness.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        last_round_idx = history.round_number - 1
        last_round_cooperators = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            last_round_cooperators += 1
        cooperation_rate = last_round_cooperators / n
        threshold_rate = m / n
        if current_round == r:
            start_idx = max(0, history.round_number - 3)
            total_cooperators = 0
            total_possible = 0
            for round_idx in range(start_idx, history.round_number):
                round_cooperators = sum(history.opponent_actions[round_idx])
                if history.my_actions[round_idx]:
                    round_cooperators += 1
                total_cooperators += round_cooperators
                total_possible += n
            if total_possible > 0 and total_cooperators / total_possible >= 0.7:
                return Action.C
        if cooperation_rate >= threshold_rate:
            return Action.C
        if cooperation_rate >= threshold_rate - 0.1:
            return Action.C
        if last_round_cooperators >= m - 1:
            return Action.C
        if self._is_cooperation_trend_improving(history):
            return Action.C
        return Action.D

    def _is_cooperation_trend_improving(self, history: PlayerHistory) -> bool:
        """Check if cooperation trend is improving or stable over recent rounds."""
        n = self.game_description.n_players
        rounds_to_check = min(3, history.round_number)
        if rounds_to_check < 2:
            return True
        cooperation_rates = []
        for i in range(rounds_to_check):
            round_idx = history.round_number - rounds_to_check + i
            cooperators = sum(history.opponent_actions[round_idx])
            if history.my_actions[round_idx]:
                cooperators += 1
            cooperation_rates.append(cooperators / n)
        if len(cooperation_rates) >= 2:
            recent_rate = cooperation_rates[-1]
            earlier_rate = cooperation_rates[0]
            if recent_rate >= earlier_rate - 0.05:
                return True
        return False

class Strategy_COOPERATIVE_13(BaseStrategy):
    """
    Adaptive Threshold Guardian - A cooperative strategy that prioritizes collective welfare
    while being resilient to exploitation. It maintains cooperation when beneficial while
    protecting against free-riders through measured responses based on threshold awareness
    and trend analysis.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        if current_round == r:
            if history.round_number >= 2:
                recent_cooperators = 0
                for round_idx in range(max(0, history.round_number - 2), history.round_number):
                    recent_cooperators += sum(history.opponent_actions[round_idx])
                    if history.my_actions[round_idx]:
                        recent_cooperators += 1
                recent_cooperation_rate = recent_cooperators / (2 * n)
                if recent_cooperation_rate >= 0.6:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.C
        last_round_idx = history.round_number - 1
        last_round_cooperators = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            last_round_cooperators += 1
        if last_round_cooperators >= m:
            if last_round_cooperators >= m + 1:
                return Action.C
            else:
                return Action.C
        elif history.round_number >= 3:
            total_cooperators = 0
            rounds_to_check = min(3, history.round_number)
            for i in range(rounds_to_check):
                round_idx = history.round_number - 1 - i
                round_cooperators = sum(history.opponent_actions[round_idx])
                if history.my_actions[round_idx]:
                    round_cooperators += 1
                total_cooperators += round_cooperators
            cooperation_trend = total_cooperators / rounds_to_check
            if cooperation_trend > m - 1:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_14(BaseStrategy):
    """
    Adaptive Trust Builder - A cooperative strategy that starts optimistically,
    learns from group behavior, and maintains cooperative momentum when possible
    while protecting against systematic exploitation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_num = history.round_number + 1
        if round_num == self.r:
            return self._final_round_decision(history)
        return self._adaptive_decision(history)

    def _adaptive_decision(self, history: PlayerHistory) -> Action:
        rounds_played = history.round_number
        total_cooperators = 0
        for round_idx in range(rounds_played):
            if history.my_actions[round_idx]:
                total_cooperators += 1
            total_cooperators += sum(history.opponent_actions[round_idx])
        cooperation_rate = total_cooperators / (self.n * rounds_played)
        recent_trend = self._calculate_trend(history)
        if self.n == self.m + 1:
            if cooperation_rate >= 0.5:
                return Action.C
            elif recent_trend > 0.2:
                return Action.C
            else:
                return Action.D
        min_threshold = self.m / self.n
        if cooperation_rate >= min_threshold + 0.1:
            return Action.C
        elif cooperation_rate >= (self.m - 1) / self.n and recent_trend > -0.1:
            return Action.C
        elif cooperation_rate >= max(0, (self.m - 2) / self.n) and recent_trend > 0.2:
            return Action.C
        elif rounds_played <= 3 and cooperation_rate == 0:
            return Action.C
        else:
            return Action.D

    def _calculate_trend(self, history: PlayerHistory) -> float:
        rounds_played = history.round_number
        if rounds_played < 3:
            return 0.0
        recent_rounds = min(3, rounds_played)
        recent_cooperators = 0
        for i in range(recent_rounds):
            round_idx = rounds_played - 1 - i
            if history.my_actions[round_idx]:
                recent_cooperators += 1
            recent_cooperators += sum(history.opponent_actions[round_idx])
        recent_rate = recent_cooperators / (self.n * recent_rounds)
        if rounds_played <= 3:
            return 0.0
        earlier_rounds = rounds_played - recent_rounds
        earlier_cooperators = 0
        for round_idx in range(earlier_rounds):
            if history.my_actions[round_idx]:
                earlier_cooperators += 1
            earlier_cooperators += sum(history.opponent_actions[round_idx])
        if earlier_rounds == 0:
            return 0.0
        earlier_rate = earlier_cooperators / (self.n * earlier_rounds)
        return recent_rate - earlier_rate

    def _final_round_decision(self, history: PlayerHistory) -> Action:
        rounds_played = history.round_number
        rounds_with_threshold = 0
        for round_idx in range(rounds_played):
            cooperators_in_round = sum(history.opponent_actions[round_idx])
            if history.my_actions[round_idx]:
                cooperators_in_round += 1
            if cooperators_in_round >= self.m:
                rounds_with_threshold += 1
        threshold_rate = rounds_with_threshold / rounds_played
        if threshold_rate >= 0.8:
            return Action.C
        recent_rounds = min(3, rounds_played)
        recent_cooperators = 0
        for i in range(recent_rounds):
            round_idx = rounds_played - 1 - i
            if history.my_actions[round_idx]:
                recent_cooperators += 1
            recent_cooperators += sum(history.opponent_actions[round_idx])
        recent_rate = recent_cooperators / (self.n * recent_rounds)
        if recent_rate >= (self.m + 1) / self.n:
            return Action.C
        return Action.D

class Strategy_COOPERATIVE_15(BaseStrategy):
    """
    Threshold Guardian strategy: Prioritizes collective welfare while maintaining resilience against exploitation.
    Aims to establish and maintain cooperation when feasible, while protecting against unsustainable cooperation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        my_last_action = history.my_actions[history.round_number - 1]
        opponent_cooperators_last = sum(history.opponent_actions[history.round_number - 1])
        cooperators_last_round = opponent_cooperators_last + (1 if my_last_action else 0)
        if cooperators_last_round >= m:
            return Action.C
        if cooperators_last_round >= m - 2 and current_round <= r * 0.8:
            return Action.C
        total_opponent_actions = len(history.opponent_actions) * (n - 1)
        if total_opponent_actions > 0:
            total_opponent_cooperations = sum((sum(round_actions) for round_actions in history.opponent_actions))
            others_avg_cooperation = total_opponent_cooperations / total_opponent_actions
        else:
            others_avg_cooperation = 0
        if others_avg_cooperation >= 0.4 and current_round <= r * 0.9:
            return Action.C
        if current_round > r * 0.9:
            recent_rounds = min(3, history.round_number)
            recent_opponent_cooperations = 0
            recent_total = 0
            for i in range(recent_rounds):
                round_idx = history.round_number - 1 - i
                recent_opponent_cooperations += sum(history.opponent_actions[round_idx])
                recent_total += n - 1
            if recent_total > 0:
                recent_cooperation_rate = recent_opponent_cooperations / recent_total
                expected_cooperators = recent_cooperation_rate * (n - 1)
                if expected_cooperators >= m - 1:
                    return Action.C
        my_total_cooperations = sum(history.my_actions)
        my_cooperation_rate = my_total_cooperations / history.round_number if history.round_number > 0 else 0
        if my_cooperation_rate > 0.7 and others_avg_cooperation < 0.3:
            if others_avg_cooperation < 0.5:
                return Action.D
        consecutive_failures = 0
        for i in range(min(3, history.round_number)):
            round_idx = history.round_number - 1 - i
            my_action_in_round = history.my_actions[round_idx]
            opponent_cooperators_in_round = sum(history.opponent_actions[round_idx])
            total_cooperators_in_round = opponent_cooperators_in_round + (1 if my_action_in_round else 0)
            if total_cooperators_in_round < m:
                consecutive_failures += 1
            else:
                break
        if consecutive_failures >= 3 and others_avg_cooperation < 0.5:
            return Action.D
        return Action.D

class Strategy_COOPERATIVE_16(BaseStrategy):
    """
    Threshold Guardian with Forgiveness: Prioritizes collective success while being resilient 
    to occasional defections. Cooperates by default but monitors group commitment to threshold achievement.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        last_round_cooperators = int(sum(history.opponent_actions[history.round_number - 1])) + int(history.my_actions[history.round_number - 1])
        recent_cooperation_rate = last_round_cooperators / n
        if len(history.my_actions) >= 6:
            recent_rounds = []
            for i in range(-3, 0):
                round_cooperators = int(sum(history.opponent_actions[i])) + int(history.my_actions[i])
                recent_rounds.append(round_cooperators / n)
            recent_avg = sum(recent_rounds) / len(recent_rounds)
            previous_rounds = []
            for i in range(-6, -3):
                round_cooperators = int(sum(history.opponent_actions[i])) + int(history.my_actions[i])
                previous_rounds.append(round_cooperators / n)
            previous_avg = sum(previous_rounds) / len(previous_rounds)
            trend_positive = recent_avg >= previous_avg
        else:
            trend_positive = recent_cooperation_rate >= 0.5
        threshold_achievable = last_round_cooperators >= m - 1
        if n <= 4:
            base_forgiveness = 0.3
        else:
            base_forgiveness = 0.4
        forgiveness_threshold = max(base_forgiveness, (m - 1) / n)
        high_threshold_game = m / n > 0.7
        if current_round == r:
            all_cooperators = []
            for round_idx in range(len(history.my_actions)):
                round_cooperators = int(sum(history.opponent_actions[round_idx])) + int(history.my_actions[round_idx])
                all_cooperators.append(round_cooperators / n)
            overall_cooperation_rate = sum(all_cooperators) / len(all_cooperators)
            if last_round_cooperators >= m - 1 or overall_cooperation_rate >= m / n:
                return Action.C
            else:
                last_round_total_cooperators = int(sum(history.opponent_actions[history.round_number - 1])) + int(history.my_actions[history.round_number - 1])
                if last_round_total_cooperators > n / 2:
                    return Action.C
                else:
                    return Action.D
        if high_threshold_game:
            if len(history.my_actions) >= 2:
                consecutive_low = True
                for i in range(-2, 0):
                    round_cooperators = int(sum(history.opponent_actions[i])) + int(history.my_actions[i])
                    if round_cooperators / n >= 0.2:
                        consecutive_low = False
                        break
                if consecutive_low:
                    return Action.D
        if trend_positive and threshold_achievable or recent_cooperation_rate >= forgiveness_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_17(BaseStrategy):
    """
    Adaptive Threshold Guardian: A cooperative strategy that prioritizes collective welfare
    while being resilient to exploitation. Uses weighted cooperation rate tracking and
    adaptive decision making to establish and maintain cooperation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        cooperation_rate = self._calculate_cooperation_rate(history)
        expected_cooperators = cooperation_rate * (self.n - 1) + 1
        if expected_cooperators >= self.m:
            return Action.C
        rounds_remaining = self.r - current_round + 1
        if rounds_remaining > 2 and cooperation_rate > 0.3:
            return Action.C
        if current_round == self.r:
            last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
            if history.my_actions[history.round_number - 1]:
                last_round_cooperators += 1
            if last_round_cooperators >= self.m - 2:
                return Action.C
        if self._successful_cooperation_streak(history) >= 2:
            return Action.C
        return Action.D

    def _calculate_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate weighted cooperation rate over recent rounds."""
        weights = [0.5, 0.3, 0.2]
        recent_rounds = min(3, history.round_number)
        cooperation_rate = 0.0
        total_weight = 0.0
        for i in range(recent_rounds):
            round_idx = history.round_number - 1 - i
            round_cooperators = sum(history.opponent_actions[round_idx])
            round_coop_rate = round_cooperators / (self.n - 1)
            weight = weights[i] if i < len(weights) else 0.1
            cooperation_rate += round_coop_rate * weight
            total_weight += weight
        if total_weight > 0:
            cooperation_rate = cooperation_rate / total_weight
        return cooperation_rate

    def _successful_cooperation_streak(self, history: PlayerHistory) -> int:
        """Count consecutive rounds from the end where threshold was met."""
        streak = 0
        for i in range(min(history.round_number, 3)):
            round_idx = history.round_number - 1 - i
            opponent_cooperators = sum(history.opponent_actions[round_idx])
            my_cooperation = 1 if history.my_actions[round_idx] else 0
            total_cooperators = opponent_cooperators + my_cooperation
            if total_cooperators >= self.m:
                streak += 1
            else:
                break
        return streak

class Strategy_COOPERATIVE_18(BaseStrategy):
    """
    Adaptive Trust Builder: A cooperative strategy that builds trust scores for each player
    and cooperates when the expected number of cooperators meets the threshold, with
    safeguards against exploitation and mechanisms for coalition maintenance.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.trust_scores = [0.7] * (game_description.n_players - 1)
        self.consecutive_failures = 0
        self.last_cooperation_attempt = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.last_cooperation_attempt = True
            return Action.C
        current_round = history.round_number + 1
        if history.round_number > 0:
            last_round_actions = history.opponent_actions[history.round_number - 1]
            for i in range(len(self.trust_scores)):
                cooperated = last_round_actions[i]
                self.trust_scores[i] = 0.8 * self.trust_scores[i] + 0.2 * (1.0 if cooperated else 0.0)
        if history.round_number > 0:
            last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
            if self.last_cooperation_attempt:
                last_round_cooperators += 1
            if last_round_cooperators >= self.game_description.m:
                self.consecutive_failures = 0
            else:
                self.consecutive_failures += 1
        if self.consecutive_failures >= 3:
            recent_successes = 0
            for round_idx in range(max(0, history.round_number - 2), history.round_number):
                round_cooperators = sum(history.opponent_actions[round_idx])
                if history.my_actions[round_idx]:
                    round_cooperators += 1
                if round_cooperators >= self.game_description.m:
                    recent_successes += 1
            if recent_successes < 2:
                self.last_cooperation_attempt = False
                return Action.D
        expected_cooperators = 1 + sum(self.trust_scores)
        if current_round == self.game_description.n_rounds:
            if history.round_number > 0:
                last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
                if history.my_actions[history.round_number - 1] and last_round_cooperators >= self.game_description.m - 1:
                    self.last_cooperation_attempt = True
                    return Action.C
            self.last_cooperation_attempt = False
            return Action.D
        early_rounds_threshold = min(5, self.game_description.n_rounds // 3)
        if current_round <= early_rounds_threshold:
            if expected_cooperators >= self.game_description.m - 1:
                self.last_cooperation_attempt = True
                return Action.C
        if expected_cooperators >= self.game_description.m:
            self.last_cooperation_attempt = True
            return Action.C
        if history.round_number > 0:
            last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
            if self.last_cooperation_attempt:
                last_round_cooperators += 1
            if last_round_cooperators < self.game_description.m and last_round_cooperators >= self.game_description.m - 2:
                self.last_cooperation_attempt = True
                return Action.C
        if history.round_number > 0:
            last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
            if self.last_cooperation_attempt:
                last_round_cooperators += 1
            if last_round_cooperators == self.game_description.m:
                if random.random() < 0.9:
                    self.last_cooperation_attempt = True
                    return Action.C
        if history.round_number > 1:
            prev_cooperators = sum(history.opponent_actions[history.round_number - 2])
            last_cooperators = sum(history.opponent_actions[history.round_number - 1])
            if history.my_actions[history.round_number - 2]:
                prev_cooperators += 1
            if history.my_actions[history.round_number - 1]:
                last_cooperators += 1
            if last_cooperators > prev_cooperators:
                self.last_cooperation_attempt = True
                return Action.C
        decision = self._conditional_cooperate(current_round)
        self.last_cooperation_attempt = decision == Action.C
        return decision

    def _conditional_cooperate(self, current_round):
        highly_trusted = sum((1 for score in self.trust_scores if score > 0.8))
        somewhat_trusted = sum((1 for score in self.trust_scores if score > 0.6))
        if highly_trusted >= self.game_description.m - 1:
            return Action.C
        if somewhat_trusted >= self.game_description.m - 1 and current_round <= self.game_description.n_rounds // 2:
            return Action.C
        forgiveness_prob = 0.3 * (self.game_description.n_rounds - current_round) / self.game_description.n_rounds
        if random.random() < forgiveness_prob:
            return Action.C
        return Action.D

class Strategy_COOPERATIVE_19(BaseStrategy):
    """
    Adaptive Trust Builder: A cooperative strategy that starts optimistically and adapts based on 
    community behavior. It prioritizes collective welfare while being resilient to exploitation,
    using threshold awareness and recovery mechanisms to rebuild cooperation when possible.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        prev_round_idx = history.round_number - 1
        opponent_cooperators = sum(history.opponent_actions[prev_round_idx])
        my_prev_cooperated = history.my_actions[prev_round_idx]
        prev_cooperators = opponent_cooperators + (1 if my_prev_cooperated else 0)
        if current_round == r:
            if prev_cooperators >= m:
                return Action.C
            if self._cooperation_trend_positive(history):
                return Action.C
            return Action.D
        if prev_cooperators >= m:
            return Action.C
        if not my_prev_cooperated:
            return Action.C
        failed_rounds = self._count_consecutive_failures(history)
        if failed_rounds == 1:
            return Action.C
        if failed_rounds == 2:
            if prev_cooperators >= m - 2:
                return Action.C
            return Action.D
        if failed_rounds >= 3:
            if prev_cooperators >= m - 1:
                return Action.C
            return Action.D
        return Action.C

    def _cooperation_trend_positive(self, history: PlayerHistory) -> bool:
        """Check if cooperation trend is positive over last 3 rounds."""
        if history.round_number < 3:
            return False
        n = self.game_description.n_players
        cooperators_history = []
        for i in range(max(0, history.round_number - 3), history.round_number):
            opponent_cooperators = sum(history.opponent_actions[i])
            my_cooperated = history.my_actions[i]
            total_cooperators = opponent_cooperators + (1 if my_cooperated else 0)
            cooperators_history.append(total_cooperators)
        if len(cooperators_history) < 3:
            return False
        return cooperators_history[-1] > cooperators_history[0]

    def _count_consecutive_failures(self, history: PlayerHistory) -> int:
        """Count consecutive rounds where threshold was not met, starting from most recent."""
        m = self.game_description.m
        failures = 0
        for i in range(history.round_number - 1, -1, -1):
            opponent_cooperators = sum(history.opponent_actions[i])
            my_cooperated = history.my_actions[i]
            total_cooperators = opponent_cooperators + (1 if my_cooperated else 0)
            if total_cooperators < m:
                failures += 1
            else:
                break
        return failures

class Strategy_COOPERATIVE_20(BaseStrategy):
    """
    Threshold-Aware Cooperative Leader strategy that maintains consistent cooperation
    while being aware of group dynamics and threshold requirements.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        if current_round == r:
            return self._handle_final_round(history)
        return self._main_strategy(history)

    def _handle_final_round(self, history: PlayerHistory) -> Action:
        """Handle the final round decision."""
        cooperators_last_round = self._count_cooperators_last_round(history)
        m = self.game_description.m
        if cooperators_last_round >= m:
            return Action.C
        elif cooperators_last_round >= m - 2:
            return Action.C
        else:
            return Action.C

    def _main_strategy(self, history: PlayerHistory) -> Action:
        """Main strategy for rounds 2 to r-1."""
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        cooperators_last_round = self._count_cooperators_last_round(history)
        avg_cooperation_rate = self._calculate_avg_cooperation_rate(history)
        if cooperators_last_round >= m:
            if avg_cooperation_rate >= 0.6:
                return Action.C
            else:
                return Action.C
        elif cooperators_last_round >= m - 2:
            return Action.C
        elif avg_cooperation_rate >= 0.4:
            return Action.C
        elif current_round <= r // 2:
            return Action.C
        elif cooperators_last_round >= m // 2:
            return Action.C
        else:
            return Action.C

    def _count_cooperators_last_round(self, history: PlayerHistory) -> int:
        """Count cooperators in the most recent round."""
        last_round_idx = history.round_number - 1
        my_cooperation = 1 if history.my_actions[last_round_idx] else 0
        opponent_cooperations = sum(history.opponent_actions[last_round_idx])
        return my_cooperation + opponent_cooperations

    def _calculate_avg_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate average cooperation rate across all previous rounds."""
        n = self.game_description.n_players
        rounds_completed = history.round_number
        if rounds_completed == 0:
            return 0.0
        total_cooperations = 0
        total_cooperations += sum(history.my_actions)
        for round_idx in range(rounds_completed):
            total_cooperations += sum(history.opponent_actions[round_idx])
        total_possible = rounds_completed * n
        return total_cooperations / total_possible if total_possible > 0 else 0.0

class Strategy_COOPERATIVE_21(BaseStrategy):
    """
    Adaptive Threshold Guardian - A cooperative strategy that prioritizes collective welfare
    while maintaining strategic awareness. Acts as a threshold guardian to ensure the
    cooperation threshold is met while adapting to observed opponent behavior.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.C
        last_round_cooperators = int(sum(history.opponent_actions[history.round_number - 1]))
        if history.my_actions[history.round_number - 1]:
            last_round_cooperators += 1
        cooperation_rate = last_round_cooperators / self.n
        coop_prob = 1.0
        threshold_rate_with_buffer = self.m / self.n + 0.1
        if cooperation_rate >= threshold_rate_with_buffer:
            coop_prob = 1.0
        elif cooperation_rate >= (self.m - 1) / self.n:
            coop_prob = 1.0
        elif cooperation_rate < 0.3:
            if current_round <= self.r / 3:
                coop_prob = 1.0
            else:
                coop_prob = 0.7
        else:
            coop_prob = 0.95
        if random.random() < coop_prob:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_22(BaseStrategy):
    """
    Adaptive Threshold Guardian: A cooperative strategy that prioritizes collective welfare
    while being resilient to defection attempts. Starts cooperative, forgives near-misses,
    but defects when cooperation consistently fails.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        m = self.game_description.m
        prev_round_idx = history.round_number - 1
        prev_cooperators = sum(history.opponent_actions[prev_round_idx]) + int(history.my_actions[prev_round_idx])
        if current_round == total_rounds:
            if prev_cooperators >= m:
                return Action.C
            elif prev_cooperators == m - 1:
                return Action.C
            else:
                return Action.D
        if prev_cooperators >= m:
            return Action.C
        if prev_cooperators == m - 1:
            return Action.C
        if current_round >= 3:
            two_rounds_ago_idx = history.round_number - 2
            two_rounds_ago_cooperators = sum(history.opponent_actions[two_rounds_ago_idx]) + int(history.my_actions[two_rounds_ago_idx])
            if two_rounds_ago_cooperators >= m and prev_cooperators < m - 1:
                return Action.C
        return Action.D

class Strategy_COOPERATIVE_23(BaseStrategy):
    """
    Optimistic Threshold Guardian: A cooperative strategy that aims to ensure the threshold 
    is met while encouraging others to cooperate through consistent, predictable behavior.
    Uses conditional cooperation with safety margins and recovery-oriented decision making.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_num = history.round_number
        n_rounds = self.game_description.n_rounds
        m = self.game_description.m
        prev_cooperators = sum(history.opponent_actions[round_num - 1]) + int(history.my_actions[round_num - 1])
        if prev_cooperators >= m:
            return Action.C
        if prev_cooperators >= m - 2:
            return Action.C
        if prev_cooperators >= max(1, m // 2):
            return Action.C
        if round_num <= 3:
            if prev_cooperators > 1:
                return Action.C
        if round_num >= int(0.75 * n_rounds):
            recent_rounds = min(3, round_num)
            for i in range(recent_rounds):
                past_round_idx = round_num - 1 - i
                past_cooperators = sum(history.opponent_actions[past_round_idx]) + int(history.my_actions[past_round_idx])
                if past_cooperators >= m - 1:
                    return Action.C
        return Action.D

class Strategy_COOPERATIVE_24(BaseStrategy):
    """
    Trust-Building Collective Guardian: A cooperative strategy that prioritizes collective welfare 
    while being resilient to exploitation. Starts with cooperation, adapts based on threshold 
    achievement and cooperation rates, with safeguards against systematic free-riding.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        k = self.game_description.k
        current_round = history.round_number + 1
        last_round_idx = history.round_number - 1
        cooperators_last_round = int(history.my_actions[last_round_idx]) + sum(history.opponent_actions[last_round_idx])
        my_coop_rate = sum(history.my_actions) / len(history.my_actions)
        others_coop_rates = []
        for player_idx in range(n - 1):
            player_coops = sum(history.opponent_actions[:, player_idx])
            coop_rate = player_coops / history.round_number
            others_coop_rates.append(coop_rate)
        cooperative_players = sum((1 for rate in others_coop_rates if rate >= 0.5))
        if current_round == r:
            successful_rounds = 0
            for round_idx in range(history.round_number):
                round_cooperators = int(history.my_actions[round_idx]) + sum(history.opponent_actions[round_idx])
                if round_cooperators >= m:
                    successful_rounds += 1
            historical_success_rate = successful_rounds / history.round_number
            if cooperative_players >= m - 1 or historical_success_rate >= 0.6:
                return Action.C
            else:
                return Action.D
        if cooperators_last_round >= m:
            return Action.C
        elif cooperators_last_round == m - 1:
            i_defected_last_round = not history.my_actions[last_round_idx]
            if i_defected_last_round or cooperative_players >= (n - 1) // 2:
                return Action.C
            else:
                return Action.D
        else:
            coop_threshold = 0.7
            cooperative_threshold = 0.4
            if n <= 4:
                cooperative_threshold = 0.4
                coop_threshold = 0.6
            if m >= 0.8 * n:
                cooperative_threshold = 0.4
                coop_threshold = 0.6
            if k <= 1.5:
                cooperative_threshold = 0.6
                coop_threshold = 0.8
            required_cooperative_players = max(1, int(cooperative_threshold * (n - 1)))
            if my_coop_rate > coop_threshold and cooperative_players >= required_cooperative_players:
                return Action.C
            else:
                return Action.D

class Strategy_COOPERATIVE_25(BaseStrategy):
    """
    Adaptive Threshold Cooperation Strategy: Cooperates when expected number of other 
    cooperators meets threshold (m-1), with leadership bonus for near-threshold situations
    and exponentially weighted moving average for player behavior prediction.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.cooperation_probs = {}
        self.alpha = 0.4

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            for i in range(self.game_description.n_players - 1):
                self.cooperation_probs[i] = 0.7
            return Action.C
        self._update_cooperation_probabilities(history)
        expected_others_coop = sum(self.cooperation_probs.values())
        threshold = self.game_description.m - 1
        leadership_bonus = expected_others_coop >= threshold - 0.3
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            adjusted_threshold = threshold + 0.2
            if expected_others_coop >= adjusted_threshold:
                return Action.C
            else:
                return Action.D
        if expected_others_coop >= threshold or leadership_bonus:
            return Action.C
        else:
            return Action.D

    def _update_cooperation_probabilities(self, history: PlayerHistory):
        """Update cooperation probabilities using exponentially weighted moving average."""
        n_rounds = history.round_number
        n_opponents = self.game_description.n_players - 1
        for opponent_idx in range(n_opponents):
            if n_rounds <= 3:
                recent_weight = min(0.2 * n_rounds, 0.6)
                initial_weight = 1 - recent_weight
                recent_cooperations = sum(history.opponent_actions[:n_rounds, opponent_idx])
                recent_rate = recent_cooperations / n_rounds if n_rounds > 0 else 0
                self.cooperation_probs[opponent_idx] = recent_weight * recent_rate + initial_weight * 0.7
            else:
                recent_actions = history.opponent_actions[n_rounds - 3:n_rounds, opponent_idx]
                recent_rate = sum(recent_actions) / 3
                historical_cooperations = sum(history.opponent_actions[:n_rounds, opponent_idx])
                historical_rate = historical_cooperations / n_rounds
                self.cooperation_probs[opponent_idx] = self.alpha * recent_rate + (1 - self.alpha) * historical_rate

class Strategy_COOPERATIVE_26(BaseStrategy):
    """
    Adaptive Threshold Guardian strategy for Collective Risk Dilemma.
    Prioritizes collective welfare by ensuring cooperation threshold is met consistently
    while maintaining resilience against exploitation through adaptive cooperation rates.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        last_round_idx = history.round_number - 1
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        my_last_action = history.my_actions[last_round_idx]
        coop_last = opponent_cooperators + (1 if my_last_action else 0)
        if current_round == r:
            rounds_to_check = min(3, history.round_number)
            total_cooperation = 0
            total_possible = 0
            for i in range(rounds_to_check):
                round_idx = history.round_number - 1 - i
                round_cooperators = sum(history.opponent_actions[round_idx]) + (1 if history.my_actions[round_idx] else 0)
                total_cooperation += round_cooperators
                total_possible += n
            recent_cooperation_rate = total_cooperation / total_possible if total_possible > 0 else 0
            if recent_cooperation_rate >= m / n:
                return Action.C
            else:
                return Action.C
        need = max(0, m - coop_last)
        if coop_last >= m:
            return Action.C
        elif need <= 2:
            return Action.C
        elif need <= n // 2:
            if random.random() < 0.8:
                return Action.C
            else:
                return Action.D
        elif random.random() < 0.4:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_27(BaseStrategy):
    """
    Adaptive Threshold Guardian: A cooperative strategy that prioritizes achieving the collective 
    threshold while using adaptive learning to optimize cooperation based on opponent behavior patterns.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        if n == 2 and m == 2:
            if current_round == r:
                opponent_coop_rate = np.mean(history.opponent_actions[:, 0])
                return Action.C if opponent_coop_rate > 0.8 else Action.D
            return Action.C
        n_opponents = n - 1
        coop_rates = np.zeros(n_opponents)
        reciprocity_scores = np.zeros(n_opponents)
        recent_trends = np.zeros(n_opponents)
        for j in range(n_opponents):
            coop_rates[j] = np.mean(history.opponent_actions[:, j])
            if current_round > 2:
                my_prev_coops = history.my_actions[:-1]
                their_responses = history.opponent_actions[1:, j]
                if np.sum(my_prev_coops) > 0:
                    reciprocity_scores[j] = np.mean(their_responses[my_prev_coops])
            if current_round > 4:
                recent_rounds = min(3, current_round - 1)
                recent_coop_rate = np.mean(history.opponent_actions[-recent_rounds:, j])
                early_coop_rate = np.mean(history.opponent_actions[:-recent_rounds, j])
                if recent_coop_rate > early_coop_rate + 0.1:
                    recent_trends[j] = 1
                elif recent_coop_rate < early_coop_rate - 0.1:
                    recent_trends[j] = -1
        predicted_cooperators = 0
        for j in range(n_opponents):
            base_prob = coop_rates[j]
            if recent_trends[j] == 1:
                base_prob *= 1.2
            elif recent_trends[j] == -1:
                base_prob *= 0.8
            if current_round > 1 and history.my_actions[-1]:
                base_prob += reciprocity_scores[j] * 0.3
            predicted_cooperators += min(1.0, max(0.0, base_prob))
        threshold_adjustment = 1.0
        if m >= n * 0.8:
            threshold_adjustment = 1.2
        elif m <= n / 3:
            threshold_adjustment = 0.9
        my_recent_coop_rate = np.mean(history.my_actions[-min(3, len(history.my_actions)):])
        opponents_mostly_cooperative = np.mean(coop_rates) > 0.6
        if current_round <= r / 3:
            return Action.C
        elif current_round == r:
            if predicted_cooperators >= m:
                return Action.C if opponents_mostly_cooperative else Action.D
            elif predicted_cooperators + 1 >= m:
                return Action.C
            else:
                return Action.C if predicted_cooperators >= m * 0.8 else Action.D
        elif predicted_cooperators >= m:
            if my_recent_coop_rate > 0.7:
                return Action.C if random.random() < 0.8 * threshold_adjustment else Action.D
            else:
                return Action.C
        elif predicted_cooperators + 1 >= m:
            return Action.C
        elif predicted_cooperators >= m * 0.7:
            return Action.C
        else:
            return Action.C if random.random() < 0.6 * threshold_adjustment else Action.D

class Strategy_COOPERATIVE_28(BaseStrategy):
    """
    Adaptive Threshold Guardian: A cooperative strategy that prioritizes collective welfare
    while adapting to opponent behavior patterns. Maintains just enough cooperation to
    secure collective benefits while being resilient to exploitation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self.strategic_defections = 0
        self.consecutive_failures = 0
        self.max_allowed_defections = max(1, int((self.n_rounds - 2) * 0.2))

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.n_rounds:
            return self._final_round_decision(history)
        return self._adaptive_decision(history)

    def _adaptive_decision(self, history: PlayerHistory) -> Action:
        last_round_idx = history.round_number - 1
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        my_last_action = history.my_actions[last_round_idx]
        total_cooperators = opponent_cooperators + (1 if my_last_action else 0)
        success_rate = self._calculate_success_rate(history)
        if total_cooperators >= self.m + 1:
            if self.strategic_defections < self.max_allowed_defections:
                self.strategic_defections += 1
                return Action.D
            else:
                return Action.C
        elif total_cooperators == self.m:
            self.consecutive_failures = 0
            return Action.C
        elif total_cooperators == self.m - 1:
            self.consecutive_failures = 0
            return Action.C
        else:
            self.consecutive_failures += 1
            if self.consecutive_failures < 3:
                return Action.C
            else:
                recent_coop_rate = self._get_recent_cooperation_rate(history, 2)
                if recent_coop_rate < 0.3:
                    if self.consecutive_failures <= 5:
                        return Action.C
                    else:
                        return Action.D
                else:
                    return Action.D

    def _final_round_decision(self, history: PlayerHistory) -> Action:
        success_rate = self._calculate_success_rate(history)
        if success_rate > 0.5:
            return Action.C
        elif success_rate < 0.3:
            return Action.D
        else:
            return Action.C

    def _calculate_success_rate(self, history: PlayerHistory) -> float:
        if history.round_number == 0:
            return 1.0
        successes = 0
        for round_idx in range(history.round_number):
            opponent_cooperators = sum(history.opponent_actions[round_idx])
            my_action = history.my_actions[round_idx]
            total_cooperators = opponent_cooperators + (1 if my_action else 0)
            if total_cooperators >= self.m:
                successes += 1
        return successes / history.round_number

    def _get_recent_cooperation_rate(self, history: PlayerHistory, rounds_back: int) -> float:
        if history.round_number == 0:
            return 1.0
        start_round = max(0, history.round_number - rounds_back)
        total_players = self.n_players
        total_decisions = 0
        total_cooperations = 0
        for round_idx in range(start_round, history.round_number):
            opponent_cooperators = sum(history.opponent_actions[round_idx])
            total_cooperations += opponent_cooperators
            if history.my_actions[round_idx]:
                total_cooperations += 1
            total_decisions += total_players
        if total_decisions == 0:
            return 1.0
        return total_cooperations / total_decisions

class Strategy_COOPERATIVE_29(BaseStrategy):
    """
    Adaptive Threshold Guardian: A cooperative strategy that prioritizes collective welfare
    while being resilient to exploitation. Maintains cooperation when possible, encourages
    defectors through strategic signaling, and protects against catastrophic failure.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        last_round_idx = history.round_number - 1
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        my_last_action = history.my_actions[last_round_idx]
        cooperators_last_round = opponent_cooperators + (1 if my_last_action else 0)
        if current_round == r:
            return Action.C
        defectors_last_round = n - cooperators_last_round
        rounds_remaining = r - current_round
        if n <= 4:
            cooperation_rate = cooperators_last_round / n
            if cooperation_rate < 0.5:
                if rounds_remaining >= 3:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.C
        if m > n / 2:
            cooperation_rate = cooperators_last_round / n
            threshold_rate = m / n
            if cooperation_rate < threshold_rate - 0.2:
                if rounds_remaining >= 3:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.C
        if cooperators_last_round >= m:
            return Action.C
        elif cooperators_last_round == m - 1:
            return Action.C
        elif cooperators_last_round >= max(2, m - 2):
            return Action.C
        elif rounds_remaining >= 3:
            if r > 10 and cooperators_last_round < m - 2:
                if rounds_remaining % 2 == 1:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_30(BaseStrategy):
    """
    Adaptive Community Builder - A cooperative strategy that prioritizes collective welfare
    while maintaining resilience against exploitation through adaptive mechanisms.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        last_round_idx = history.round_number - 1
        last_round_cooperators = sum(history.opponent_actions[last_round_idx]) + (1 if history.my_actions[last_round_idx] else 0)
        if current_round == self.n_rounds:
            if last_round_cooperators >= self.m:
                return Action.C
            elif self._cooperation_failing_recently(history):
                return Action.D
            else:
                return Action.C
        if last_round_cooperators >= self.m:
            return Action.C
        if last_round_cooperators >= self.m - 1:
            return Action.C
        trend = self._calculate_cooperation_trend(history)
        if trend > 0:
            return Action.C
        consecutive_failures = self._count_consecutive_failures(history)
        if consecutive_failures >= 2 and trend < 0:
            if last_round_cooperators == self.m - 1:
                return Action.C
            return Action.D
        return Action.C

    def _count_cooperators_in_round(self, history: PlayerHistory, round_idx: int) -> int:
        """Count total cooperators (including self) in a specific round."""
        if round_idx < 0 or round_idx >= history.round_number:
            return 0
        opponent_coop = sum(history.opponent_actions[round_idx])
        my_coop = 1 if history.my_actions[round_idx] else 0
        return opponent_coop + my_coop

    def _calculate_cooperation_trend(self, history: PlayerHistory) -> float:
        """Calculate cooperation trend over the last 3 rounds (or available rounds)."""
        rounds_to_check = min(3, history.round_number)
        if rounds_to_check < 2:
            return 0
        cooperator_counts = []
        for i in range(rounds_to_check):
            round_idx = history.round_number - 1 - i
            count = self._count_cooperators_in_round(history, round_idx)
            cooperator_counts.append(count)
        cooperator_counts.reverse()
        if len(cooperator_counts) >= 2:
            return cooperator_counts[-1] - cooperator_counts[0]
        return 0

    def _count_consecutive_failures(self, history: PlayerHistory) -> int:
        """Count consecutive rounds where cooperation threshold was not met."""
        consecutive = 0
        for i in range(history.round_number):
            round_idx = history.round_number - 1 - i
            cooperators = self._count_cooperators_in_round(history, round_idx)
            if cooperators < self.m:
                consecutive += 1
            else:
                break
        return consecutive

    def _cooperation_failing_recently(self, history: PlayerHistory) -> bool:
        """Check if cooperation has failed in the last 2 rounds."""
        if history.round_number < 2:
            return False
        for i in range(2):
            round_idx = history.round_number - 1 - i
            cooperators = self._count_cooperators_in_round(history, round_idx)
            if cooperators >= self.m:
                return False
        return True

class Strategy_COOPERATIVE_31(BaseStrategy):
    """
    Adaptive Trust Builder: A cooperative strategy that balances optimistic cooperation 
    with strategic adaptation based on community behavior and threshold proximity.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        if current_round == r:
            success_count = 0
            for round_idx in range(history.round_number):
                cooperators = sum(history.opponent_actions[round_idx]) + int(history.my_actions[round_idx])
                if cooperators >= m:
                    success_count += 1
            success_rate = success_count / history.round_number if history.round_number > 0 else 0
            return Action.C if success_rate >= 0.6 else Action.D
        prev_round_idx = history.round_number - 1
        prev_cooperators = sum(history.opponent_actions[prev_round_idx]) + int(history.my_actions[prev_round_idx])
        ccr = prev_cooperators / n
        trend = self._analyze_trend(history, n, m)
        if prev_cooperators >= m:
            if ccr >= 0.6:
                return Action.C
            elif ccr >= 0.4:
                return Action.C if random.random() < 0.8 else Action.D
            else:
                return Action.C if random.random() < 0.6 else Action.D
        elif prev_cooperators >= m - 2:
            prob = 0.9
            return Action.C if random.random() < prob else Action.D
        elif trend == 'increasing':
            return Action.C if random.random() < 0.7 else Action.D
        elif trend == 'stable' and ccr >= 0.3:
            return Action.C if random.random() < 0.5 else Action.D
        else:
            return Action.C if random.random() < 0.3 else Action.D

    def _analyze_trend(self, history: PlayerHistory, n: int, m: int) -> str:
        """Analyze cooperation trend over the last few rounds."""
        round_count = history.round_number
        if round_count < 2:
            return 'stable'
        window = min(3, round_count)
        cooperation_rates = []
        for i in range(round_count - window, round_count):
            cooperators = sum(history.opponent_actions[i]) + int(history.my_actions[i])
            cooperation_rates.append(cooperators / n)
        if len(cooperation_rates) < 2:
            return 'stable'
        recent_rate = cooperation_rates[-1]
        older_rate = cooperation_rates[0]
        if recent_rate > older_rate + 0.1:
            return 'increasing'
        elif recent_rate < older_rate - 0.1:
            return 'decreasing'
        else:
            return 'stable'

class Strategy_COOPERATIVE_32(BaseStrategy):
    """
    Adaptive Trust Builder: A cooperative strategy that prioritizes collective welfare while being
    resilient to exploitation. Starts cooperatively, builds trust through reciprocity, and adapts
    to group dynamics while maintaining a cooperative orientation. Cooperates when estimated
    probability of reaching threshold is  50%, based on historical cooperation rate, recent trends,
    and reciprocity factors.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_number = history.round_number
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        if round_number == r - 1:
            return self._endgame_logic(history)
        prob_threshold_met = self._estimate_cooperation_probability(history)
        if prob_threshold_met >= 0.5:
            return Action.C
        else:
            return self._conditional_cooperate(history)

    def _estimate_cooperation_probability(self, history):
        """Estimate probability of reaching cooperation threshold based on three factors."""
        historical_rate = self._get_historical_cooperation_rate(history)
        recent_trend = self._get_recent_trend(history)
        reciprocity = self._get_reciprocity_factor(history)
        prob_estimate = (historical_rate + recent_trend + reciprocity) / 3
        return max(0, min(1, prob_estimate))

    def _get_historical_cooperation_rate(self, history):
        """Calculate overall cooperation rate of all players in previous rounds."""
        if history.round_number == 0:
            return 0.5
        total_cooperations = 0
        total_decisions = 0
        total_cooperations += sum(history.my_actions)
        total_decisions += len(history.my_actions)
        for round_idx in range(history.round_number):
            total_cooperations += sum(history.opponent_actions[round_idx])
            total_decisions += len(history.opponent_actions[round_idx])
        return total_cooperations / total_decisions if total_decisions > 0 else 0.5

    def _get_recent_trend(self, history):
        """Calculate cooperation trend in last 3 rounds vs overall average."""
        if history.round_number < 3:
            return 0
        historical_rate = self._get_historical_cooperation_rate(history)
        recent_cooperations = 0
        recent_decisions = 0
        start_round = max(0, history.round_number - 3)
        for round_idx in range(start_round, history.round_number):
            if round_idx < len(history.my_actions):
                recent_cooperations += history.my_actions[round_idx]
                recent_decisions += 1
            if round_idx < len(history.opponent_actions):
                recent_cooperations += sum(history.opponent_actions[round_idx])
                recent_decisions += len(history.opponent_actions[round_idx])
        recent_rate = recent_cooperations / recent_decisions if recent_decisions > 0 else historical_rate
        return recent_rate - historical_rate

    def _get_reciprocity_factor(self, history):
        """Calculate reciprocity factor based on mutual cooperation patterns."""
        if history.round_number == 0:
            return 0.5
        my_cooperations = sum(history.my_actions)
        if my_cooperations == 0:
            return 0.5
        reciprocal_cooperations = 0
        for round_idx in range(history.round_number):
            if history.my_actions[round_idx]:
                opponent_cooperators = sum(history.opponent_actions[round_idx])
                if opponent_cooperators > 0:
                    reciprocal_cooperations += 1
        return reciprocal_cooperations / my_cooperations

    def _conditional_cooperate(self, history):
        """Apply conditional cooperation logic when probability estimate is low."""
        m = self.game_description.m
        if history.round_number > 0:
            last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
            if history.my_actions[history.round_number - 1]:
                last_round_cooperators += 1
            if last_round_cooperators >= m - 1:
                return Action.C
        my_coop_rate = sum(history.my_actions) / len(history.my_actions)
        group_coop_rate = self._get_historical_cooperation_rate(history)
        if my_coop_rate > group_coop_rate + 0.1:
            return Action.D
        return Action.C

    def _endgame_logic(self, history):
        """Apply endgame logic for the final round."""
        group_coop_rate = self._get_historical_cooperation_rate(history)
        my_coop_rate = sum(history.my_actions) / len(history.my_actions)
        if group_coop_rate > 0.6:
            return Action.C
        if my_coop_rate > group_coop_rate + 0.15:
            return Action.D
        last_round_cooperators = 0
        if history.round_number > 0:
            last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
            if history.my_actions[history.round_number - 1]:
                last_round_cooperators += 1
        expected_cooperators = max(last_round_cooperators, int(group_coop_rate * self.game_description.n_players))
        return Action.C if expected_cooperators >= self.game_description.m - 1 else Action.D

class Strategy_COOPERATIVE_33(BaseStrategy):
    """
    Optimistic Guardian Strategy: Balances cooperative intent with prudent risk management.
    Aims to achieve collective success while protecting against exploitation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        last_round_idx = history.round_number - 1
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        my_last_action = history.my_actions[last_round_idx]
        total_cooperators = opponent_cooperators + (1 if my_last_action else 0)
        cooperation_rate = total_cooperators / n
        if current_round == r:
            if cooperation_rate >= (m - 1) / n:
                return Action.C
            else:
                return Action.D
        threshold_rate = m / n
        if cooperation_rate >= threshold_rate + 0.1:
            return Action.C
        elif cooperation_rate >= (m - 1) / n:
            return Action.C
        elif total_cooperators >= m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_34(BaseStrategy):
    """
    Adaptive Threshold Guardian: A cooperative strategy that prioritizes collective welfare
    while maintaining resilience against exploitation. Starts cooperatively and uses
    adaptive decision-making based on cooperation trends and threshold analysis.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        my_last_action = history.my_actions[-1]
        opponent_last_actions = history.opponent_actions[-1]
        previous_cooperators = int(my_last_action) + sum(opponent_last_actions)
        if current_round == r:
            if previous_cooperators >= m:
                return Action.C
            else:
                total_cooperation = 0
                total_possible = 0
                for round_idx in range(history.round_number):
                    round_cooperation = int(history.my_actions[round_idx]) + sum(history.opponent_actions[round_idx])
                    total_cooperation += round_cooperation
                    total_possible += n
                average_cooperation = total_cooperation / total_possible if total_possible > 0 else 0
                if average_cooperation >= (m - 0.5) / n:
                    return Action.C
                else:
                    return Action.D
        cooperation_trend = self._calculate_trend(history)
        if previous_cooperators >= m + 1:
            return Action.C
        elif previous_cooperators == m:
            return Action.C
        elif previous_cooperators == m - 1:
            return Action.C
        elif cooperation_trend > 0 and previous_cooperators >= m - 2:
            return Action.C
        elif n <= 4:
            consecutive_failures = self._count_consecutive_failures(history)
            if consecutive_failures < 2:
                return Action.C
            else:
                return Action.D
        elif m >= n - 1:
            consecutive_failures = self._count_consecutive_failures(history)
            if consecutive_failures < 3:
                return Action.C
            else:
                return Action.D
        elif r > 10:
            if self._is_recovery_period(history):
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _calculate_trend(self, history: PlayerHistory) -> float:
        """Calculate cooperation trend over the last 3 rounds (or available rounds)."""
        rounds_to_check = min(3, history.round_number)
        if rounds_to_check < 2:
            return 0
        cooperations = []
        for i in range(rounds_to_check):
            round_idx = history.round_number - 1 - i
            my_action = int(history.my_actions[round_idx])
            opponent_actions = sum(history.opponent_actions[round_idx])
            total_cooperation = my_action + opponent_actions
            cooperations.append(total_cooperation)
        cooperations.reverse()
        if len(cooperations) >= 2:
            return cooperations[-1] - cooperations[0]
        return 0

    def _count_consecutive_failures(self, history: PlayerHistory) -> int:
        """Count how many consecutive rounds the threshold was not met."""
        m = self.game_description.m
        consecutive_failures = 0
        for i in range(history.round_number):
            round_idx = history.round_number - 1 - i
            my_action = int(history.my_actions[round_idx])
            opponent_actions = sum(history.opponent_actions[round_idx])
            total_cooperation = my_action + opponent_actions
            if total_cooperation < m:
                consecutive_failures += 1
            else:
                break
        return consecutive_failures

    def _is_recovery_period(self, history: PlayerHistory) -> bool:
        """Check if we're in a potential recovery period after punishment."""
        if history.round_number < 4:
            return False
        m = self.game_description.m
        recent_cooperations = []
        for i in range(min(4, history.round_number)):
            round_idx = history.round_number - 1 - i
            my_action = int(history.my_actions[round_idx])
            opponent_actions = sum(history.opponent_actions[round_idx])
            total_cooperation = my_action + opponent_actions
            recent_cooperations.append(total_cooperation)
        recent_cooperations.reverse()
        if len(recent_cooperations) >= 3:
            early_avg = sum(recent_cooperations[:2]) / 2
            recent_avg = sum(recent_cooperations[-2:]) / 2
            return recent_avg > early_avg and recent_avg >= m - 1
        return False

class Strategy_COOPERATIVE_35(BaseStrategy):
    """
    Adaptive Threshold Cooperation with Trust Building strategy.
    
    Starts cooperatively, then adapts based on threshold viability, momentum,
    and recovery attempts. Balances cooperative ideals with practical considerations.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        m = self.game_description.m
        prev_round_idx = history.round_number - 1
        opponent_cooperators = sum(history.opponent_actions[prev_round_idx])
        my_prev_action = history.my_actions[prev_round_idx]
        total_prev_cooperators = opponent_cooperators + (1 if my_prev_action else 0)
        if current_round == total_rounds:
            if opponent_cooperators >= m - 1:
                rounds_to_check = min(3, history.round_number)
                start_idx = history.round_number - rounds_to_check
                total_cooperations = 0
                total_possible = 0
                for i in range(start_idx, history.round_number):
                    round_cooperators = sum(history.opponent_actions[i]) + (1 if history.my_actions[i] else 0)
                    total_cooperations += round_cooperators
                    total_possible += self.game_description.n_players
                coop_rate = total_cooperations / total_possible if total_possible > 0 else 0
                if coop_rate >= 0.5:
                    return Action.C
            return Action.D
        if opponent_cooperators >= m - 1:
            return Action.C
        if history.round_number >= 2:
            prev_prev_idx = history.round_number - 2
            prev_prev_opponent_cooperators = sum(history.opponent_actions[prev_prev_idx])
            prev_prev_my_action = history.my_actions[prev_prev_idx]
            prev_prev_total_cooperators = prev_prev_opponent_cooperators + (1 if prev_prev_my_action else 0)
            if total_prev_cooperators > prev_prev_total_cooperators:
                return Action.C
        consecutive_below = 0
        for i in range(history.round_number - 1, -1, -1):
            round_cooperators = sum(history.opponent_actions[i]) + (1 if history.my_actions[i] else 0)
            if round_cooperators < m:
                consecutive_below += 1
            else:
                break
        if consecutive_below < 2:
            return Action.C
        return Action.D

class Strategy_COOPERATIVE_36(BaseStrategy):
    """
    Adaptive Threshold Guardian: A cooperative strategy that prioritizes collective welfare
    while being resilient to exploitation. Maintains cooperation when threshold is met
    and adapts based on group cooperation patterns.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        last_round_cooperators = sum(history.opponent_actions[history.round_number - 1]) + int(history.my_actions[history.round_number - 1])
        total_actions = history.round_number * n
        total_cooperations = sum((sum(round_actions) for round_actions in history.opponent_actions)) + sum(history.my_actions)
        total_cooperation_rate = total_cooperations / total_actions if total_actions > 0 else 0
        if current_round == r:
            recent_rounds = min(3, history.round_number)
            threshold_successes = 0
            for i in range(recent_rounds):
                round_idx = history.round_number - 1 - i
                round_cooperators = sum(history.opponent_actions[round_idx]) + int(history.my_actions[round_idx])
                if round_cooperators >= m:
                    threshold_successes += 1
            recent_threshold_success_rate = threshold_successes / recent_rounds if recent_rounds > 0 else 0
            if total_cooperation_rate >= 0.5 and recent_threshold_success_rate >= 0.7:
                return Action.C
            else:
                return Action.C if random.random() < 0.6 else Action.D
        if last_round_cooperators >= m:
            if total_cooperation_rate >= 0.6:
                return Action.C
            else:
                return Action.C if random.random() < 0.8 else Action.D
        elif last_round_cooperators >= m - 2:
            return Action.C
        else:
            return Action.C if random.random() < 0.9 else Action.D

class Strategy_COOPERATIVE_37(BaseStrategy):
    """
    Optimistic Threshold Guardian: A cooperative strategy that prioritizes collective welfare
    while maintaining vigilance against free-riding. Always cooperates initially, then
    adapts based on threshold achievement and cooperation trends with built-in recovery
    mechanisms for coordination failures.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.consecutive_successes = 0
        self.consecutive_failures = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.consecutive_successes = 0
            self.consecutive_failures = 0
            return Action.C
        current_round = history.round_number + 1
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        prev_round_idx = history.round_number - 1
        opponent_cooperators = sum(history.opponent_actions[prev_round_idx])
        my_prev_action = 1 if history.my_actions[prev_round_idx] else 0
        prev_cooperators = opponent_cooperators + my_prev_action
        if prev_cooperators >= m:
            self.consecutive_successes += 1
            self.consecutive_failures = 0
        else:
            self.consecutive_failures += 1
            self.consecutive_successes = 0
        if self.consecutive_failures >= 2:
            return self._apply_recovery_protocol(current_round, history)
        if prev_cooperators >= m:
            return Action.C
        if prev_cooperators == m - 1:
            return Action.C
        if prev_cooperators >= m // 2:
            return Action.C
        if current_round <= r // 2:
            return Action.C
        else:
            return self._apply_endgame_logic(current_round, history)

    def _apply_recovery_protocol(self, current_round: int, history: PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        m = self.game_description.m
        rounds_to_check = min(3, history.round_number)
        recent_cooperators = []
        for i in range(rounds_to_check):
            round_idx = history.round_number - 1 - i
            opponent_cooperators = sum(history.opponent_actions[round_idx])
            my_action = 1 if history.my_actions[round_idx] else 0
            total_cooperators = opponent_cooperators + my_action
            recent_cooperators.append(total_cooperators)
        recent_avg = sum(recent_cooperators) / len(recent_cooperators)
        if recent_avg > m / 3:
            return Action.C
        if current_round <= r * 0.7:
            if random.random() < 0.7:
                return Action.C
            else:
                return Action.D
        else:
            return self._apply_endgame_logic(current_round, history)

    def _apply_endgame_logic(self, current_round: int, history: PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        m = self.game_description.m
        rounds_remaining = r - current_round + 1
        prev_round_idx = history.round_number - 1
        opponent_cooperators = sum(history.opponent_actions[prev_round_idx])
        my_prev_action = 1 if history.my_actions[prev_round_idx] else 0
        prev_cooperators = opponent_cooperators + my_prev_action
        if prev_cooperators >= m - 2:
            return Action.C
        if prev_cooperators < m // 3:
            if rounds_remaining > 3:
                return Action.C
            else:
                return Action.D
        return Action.C

class Strategy_COOPERATIVE_38(BaseStrategy):
    """
    Adaptive Threshold Guardian: A cooperative strategy that prioritizes collective welfare
    while being resilient to exploitation. Maintains cooperation when possible but includes
    safeguards against consistent defectors.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        if current_round == r:
            return Action.C
        last_round_idx = history.round_number - 1
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        my_last_action = history.my_actions[last_round_idx]
        cooperators_last_round = opponent_cooperators + (1 if my_last_action else 0)
        coop_rate = cooperators_last_round / n
        if cooperators_last_round >= m + 1:
            return Action.C
        if cooperators_last_round == m:
            return Action.C
        if cooperators_last_round == m - 1:
            return Action.C
        if cooperators_last_round < m - 1:
            if coop_rate > 0.3:
                return Action.C
            elif random.random() < 0.2:
                return Action.C
            else:
                return Action.D
        return Action.C

class Strategy_COOPERATIVE_39(BaseStrategy):
    """
    Optimistic Threshold Guardian Strategy for Collective Risk Dilemma.
    
    This strategy starts optimistically, monitors cooperation thresholds closely,
    and uses graduated responses to encourage collective success while being
    resilient to defection.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        last_round_idx = history.round_number - 1
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        my_last_action = history.my_actions[last_round_idx]
        total_cooperators = opponent_cooperators + (1 if my_last_action else 0)
        if current_round == r:
            if total_cooperators >= m - 1:
                return Action.C
            elif total_cooperators >= m // 2:
                return Action.C
            else:
                return Action.D
        if total_cooperators >= m:
            return Action.C
        elif total_cooperators >= m - 2:
            return Action.C
        elif total_cooperators >= m // 2:
            if my_last_action:
                return Action.D
            else:
                return Action.C
        elif total_cooperators == 0:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_40(BaseStrategy):
    """
    Adaptive Threshold Keeper: A cooperative strategy that prioritizes collective welfare
    while being resilient to defection. Always cooperates in round 1, then uses threshold
    security, trend analysis, and risk assessment to maintain minimum viable cooperation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        last_round_idx = history.round_number - 1
        last_round_cooperators = int(history.my_actions[last_round_idx]) + sum(history.opponent_actions[last_round_idx])
        my_last_action = history.my_actions[last_round_idx]
        if last_round_cooperators < self.m:
            return Action.C
        if last_round_cooperators == self.m:
            return Action.C
        recent_rounds = min(3, history.round_number)
        cooperation_trend = self._analyze_trend(history, recent_rounds)
        if current_round == self.r:
            if last_round_cooperators >= self.m + 2:
                return Action.D
            else:
                return Action.C
        if last_round_cooperators >= self.m + 2:
            if cooperation_trend in ['stable', 'increasing']:
                if my_last_action:
                    return Action.D
            return Action.C
        return Action.C

    def _analyze_trend(self, history: PlayerHistory, num_rounds: int) -> str:
        """Analyze cooperation trend over recent rounds."""
        cooperator_counts = []
        for i in range(num_rounds):
            round_idx = history.round_number - 1 - i
            if round_idx >= 0:
                cooperators = int(history.my_actions[round_idx]) + sum(history.opponent_actions[round_idx])
                cooperator_counts.append(cooperators)
        if len(cooperator_counts) < 2:
            return 'stable'
        differences = []
        for i in range(len(cooperator_counts) - 1):
            differences.append(cooperator_counts[i] - cooperator_counts[i + 1])
        avg_change = sum(differences) / len(differences)
        if avg_change > 0.5:
            return 'increasing'
        elif avg_change < -0.5:
            return 'decreasing'
        else:
            return 'stable'

class Strategy_COOPERATIVE_41(BaseStrategy):
    """
    Conditional Altruist with Safety Net: A cooperative strategy that prioritizes collective welfare
    while maintaining rational self-interest through adaptive safety mechanisms.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.m = game_description.m
        self.k = game_description.k
        self.r = game_description.n_rounds
        self.trust_score = 0.7
        self.safety_threshold = (self.m - 1) / self.n

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.r:
            recent_coop_rate = self._get_cooperation_rate(history, min(2, history.round_number))
            if recent_coop_rate >= self.m / self.n + 0.1:
                return Action.C
            else:
                return Action.D
        look_back = min(3, history.round_number)
        recent_coop_rate = self._get_cooperation_rate(history, look_back)
        if recent_coop_rate < self.safety_threshold:
            return Action.D
        rounds_met_threshold = self._count_threshold_met(history, look_back)
        self.trust_score = 0.3 * self.trust_score + 0.7 * (rounds_met_threshold / look_back)
        expected_cooperators = self.trust_score * (self.n - 1) + 1
        if expected_cooperators >= self.m:
            return Action.C
        else:
            return Action.D

    def _get_cooperation_rate(self, history: PlayerHistory, num_rounds: int) -> float:
        """Calculate cooperation rate over the last num_rounds rounds."""
        if num_rounds == 0:
            return 0.0
        start_round = max(0, history.round_number - num_rounds)
        total_cooperators = 0
        total_decisions = 0
        for round_idx in range(start_round, history.round_number):
            cooperators_this_round = int(np.sum(history.opponent_actions[round_idx]))
            if history.my_actions[round_idx]:
                cooperators_this_round += 1
            total_cooperators += cooperators_this_round
            total_decisions += self.n
        return total_cooperators / total_decisions if total_decisions > 0 else 0.0

    def _count_threshold_met(self, history: PlayerHistory, num_rounds: int) -> int:
        """Count how many of the last num_rounds rounds met the cooperation threshold."""
        if num_rounds == 0:
            return 0
        start_round = max(0, history.round_number - num_rounds)
        count = 0
        for round_idx in range(start_round, history.round_number):
            cooperators = int(np.sum(history.opponent_actions[round_idx]))
            if history.my_actions[round_idx]:
                cooperators += 1
            if cooperators >= self.m:
                count += 1
        return count

class Strategy_COOPERATIVE_42(BaseStrategy):
    """
    Adaptive Threshold Guardian: A cooperative strategy that maintains cooperation 
    around the critical threshold while being resilient to exploitation and 
    providing recovery mechanisms after cooperation collapse.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.consecutive_failures = 0
        self.forgiveness_count = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.consecutive_failures = 0
            self.forgiveness_count = 0
            return Action.C
        round_number = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        m = self.game_description.m
        prev_round_idx = history.round_number - 1
        my_prev_action = history.my_actions[prev_round_idx]
        opponent_cooperators = sum(history.opponent_actions[prev_round_idx])
        total_cooperators = opponent_cooperators + (1 if my_prev_action else 0)
        if round_number == n_rounds:
            if total_cooperators >= m - 1:
                return Action.C
            else:
                return Action.D
        if total_cooperators >= m - 1:
            self.consecutive_failures = 0
            return Action.C
        elif total_cooperators == m - 2:
            recent_forgiveness = self._count_forgiveness_in_last_5_rounds(history)
            self.consecutive_failures = 0
            if recent_forgiveness <= 2:
                self.forgiveness_count += 1
                return Action.C
            else:
                return Action.D
        else:
            self.consecutive_failures += 1
            if self.consecutive_failures >= 3 and round_number % 3 == 1:
                return Action.C
            else:
                return Action.D

    def _count_forgiveness_in_last_5_rounds(self, history: PlayerHistory) -> int:
        """Count how many times we showed forgiveness in the last 5 rounds."""
        count = 0
        start_round = max(0, history.round_number - 5)
        m = self.game_description.m
        for round_idx in range(start_round, history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_cooperators = sum(history.opponent_actions[round_idx])
            total_cooperators_without_me = opponent_cooperators
            if my_action and total_cooperators_without_me == m - 2:
                count += 1
        return count

class Strategy_COOPERATIVE_43(BaseStrategy):
    """
    Threshold Guardian: A cooperative strategy that prioritizes achieving the collective benefit
    while being resilient against defection. Leads by example with adaptive resilience,
    maintaining high cooperation rates while monitoring group dynamics to ensure threshold success.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.cooperation_probability = 0.9
        self.safety_buffer = 1
        self.trust_level = 0.8
        self.defection_streak = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_number = history.round_number
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        m = self.game_description.m
        prev_round_idx = round_number - 1
        prev_cooperators = sum(history.opponent_actions[prev_round_idx]) + int(history.my_actions[prev_round_idx])
        threshold_met = prev_cooperators >= m
        if threshold_met:
            self.trust_level = min(1.0, self.trust_level + 0.1)
            self.defection_streak = 0
        else:
            self.trust_level = max(0.3, self.trust_level - 0.2)
            self.defection_streak += 1
        recent_rounds = min(3, round_number)
        total_cooperators = 0
        for i in range(recent_rounds):
            round_idx = round_number - 1 - i
            round_cooperators = sum(history.opponent_actions[round_idx]) + int(history.my_actions[round_idx])
            weight = 1.0 / (i + 1)
            total_cooperators += round_cooperators * weight
        weight_sum = sum((1.0 / (i + 1) for i in range(recent_rounds)))
        avg_cooperators = total_cooperators / weight_sum
        expected_cooperators = avg_cooperators * self.trust_level + n_players * 0.3 * (1 - self.trust_level)
        expected_others = expected_cooperators - 1
        current_round = round_number + 1
        if expected_others < m - 1:
            return Action.C
        if expected_others < m + self.safety_buffer - 1:
            return Action.C
        if self.defection_streak >= 2:
            return Action.C
        if current_round >= n_rounds - 1:
            return Action.C
        surplus = expected_others - (m + self.safety_buffer - 1)
        if surplus > 0:
            defect_prob = min(0.3, surplus * 0.1)
            if random.random() < defect_prob:
                return Action.D
        return Action.C

class Strategy_COOPERATIVE_44(BaseStrategy):
    """
    Adaptive Threshold Guardian: A cooperative strategy that prioritizes collective welfare
    while being robust against exploitation. It predicts opponent behavior to determine
    if the cooperation threshold is likely to be met, includes forgiveness mechanisms
    to escape defection equilibria, and adapts based on recent opponent behavior patterns.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.forgiveness_counter = 0
        self.last_round_cooperators = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        m = self.game_description.m
        if history.round_number > 0:
            self.last_round_cooperators = int(sum(history.opponent_actions[history.round_number - 1]))
            if history.my_actions[history.round_number - 1]:
                self.last_round_cooperators += 1
        if current_round == n_rounds:
            expected_cooperators = self._predict_cooperators(history)
            if expected_cooperators >= m - 1:
                return Action.C
            else:
                return Action.D
        expected_cooperators = self._predict_cooperators(history)
        if expected_cooperators >= m - 1:
            return Action.C
        elif self._should_forgive(current_round):
            self.forgiveness_counter += 1
            return Action.C
        else:
            return Action.D

    def _predict_cooperators(self, history: PlayerHistory) -> float:
        """Predict number of cooperators based on opponent behavior patterns."""
        predicted = 0.0
        n_opponents = self.game_description.n_players - 1
        for opponent_idx in range(n_opponents):
            cooperation_rate = self._calculate_cooperation_rate(history, opponent_idx)
            recent_rate = self._cooperation_rate_last_3_rounds(history, opponent_idx)
            recent_weight = 0.7
            overall_weight = 0.3
            weighted_rate = recent_weight * recent_rate + overall_weight * cooperation_rate
            if weighted_rate > 0.6:
                predicted += 1.0
            elif weighted_rate > 0.3:
                predicted += 0.5
        return predicted

    def _calculate_cooperation_rate(self, history: PlayerHistory, opponent_idx: int) -> float:
        """Calculate overall cooperation rate for an opponent."""
        if history.round_number == 0:
            return 0.5
        opponent_actions = history.opponent_actions[:history.round_number, opponent_idx]
        return float(sum(opponent_actions)) / len(opponent_actions)

    def _cooperation_rate_last_3_rounds(self, history: PlayerHistory, opponent_idx: int) -> float:
        """Calculate cooperation rate for last 3 rounds."""
        if history.round_number == 0:
            return 0.5
        start_idx = max(0, history.round_number - 3)
        recent_actions = history.opponent_actions[start_idx:history.round_number, opponent_idx]
        if len(recent_actions) == 0:
            return 0.5
        return float(sum(recent_actions)) / len(recent_actions)

    def _should_forgive(self, current_round: int) -> bool:
        """Determine if we should forgive and cooperate despite low expected cooperation."""
        if self.forgiveness_counter == 0 and current_round % 4 == 0:
            return True
        if self.last_round_cooperators == 0 and current_round % 3 == 0:
            return True
        return False

class Strategy_COOPERATIVE_45(BaseStrategy):
    """
    Adaptive Threshold Guardian: A cooperative strategy that balances trust-building 
    with strategic protection across three phases - Trust Building, Adaptive Cooperation, 
    and Final Push. Uses exponentially weighted moving averages to predict cooperation 
    and maintains resilience against exploitation while prioritizing collective welfare.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.m = game_description.m
        self.r = game_description.n_rounds
        self.k = game_description.k
        self.trust_phase_end = max(3, int(0.2 * self.r))
        self.final_phase_start = max(self.r - int(0.1 * self.r), self.r - 2)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round <= self.trust_phase_end:
            return Action.C
        if current_round >= self.final_phase_start:
            threshold = self.m - 1 if current_round == self.r else self.m
            predicted_cooperators = self._predict_cooperation(history)
            return Action.C
        predicted_cooperators = self._predict_cooperation(history)
        cooperation_rate = self._get_recent_cooperation_rate(history)
        if cooperation_rate < 0.4:
            return Action.C
        return Action.C if predicted_cooperators >= self.m else Action.D

    def _predict_cooperation(self, history: PlayerHistory) -> float:
        """Predict number of cooperators using exponentially weighted moving average."""
        if history.round_number == 0:
            return int(0.6 * self.n)
        decay = 0.7
        weighted_sum = 0.0
        weight_sum = 0.0
        rounds_to_consider = min(5, history.round_number)
        for i in range(rounds_to_consider):
            round_idx = history.round_number - 1 - i
            my_cooperation = 1 if history.my_actions[round_idx] else 0
            opponent_cooperation = sum(history.opponent_actions[round_idx])
            total_cooperators = my_cooperation + opponent_cooperation
            weight = decay ** i
            weighted_sum += total_cooperators * weight
            weight_sum += weight
        if weight_sum > 0:
            return weighted_sum / weight_sum
        else:
            return int(0.6 * self.n)

    def _get_recent_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate cooperation rate from recent rounds."""
        if history.round_number == 0:
            return 0.6
        rounds_to_consider = min(3, history.round_number)
        total_cooperators = 0
        total_possible = 0
        for i in range(rounds_to_consider):
            round_idx = history.round_number - 1 - i
            my_cooperation = 1 if history.my_actions[round_idx] else 0
            opponent_cooperation = sum(history.opponent_actions[round_idx])
            total_cooperators += my_cooperation + opponent_cooperation
            total_possible += self.n
        return total_cooperators / total_possible if total_possible > 0 else 0.6

class Strategy_COOPERATIVE_46(BaseStrategy):
    """
    Threshold-Aware Cooperative Leader strategy for Collective Risk Dilemma.
    
    This strategy prioritizes collective welfare while being strategically aware of threshold dynamics.
    It aims to establish and maintain cooperation by taking leadership when needed while being
    responsive to others' cooperative efforts. The strategy cooperates when the threshold is met
    or close to being met, provides leadership when cooperation is declining but salvageable,
    and only defects when cooperation has clearly collapsed.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.consecutive_failures = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.consecutive_failures = 0
            return Action.C
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        m = self.game_description.m
        current_round = history.round_number + 1
        last_round_idx = history.round_number - 1
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        my_last_action = history.my_actions[last_round_idx]
        cooperators_last_round = opponent_cooperators + (1 if my_last_action else 0)
        if current_round == n_rounds:
            if cooperators_last_round >= m:
                return Action.C
            elif cooperators_last_round >= m - 1:
                return Action.C
            else:
                return Action.D
        if cooperators_last_round >= m:
            self.consecutive_failures = 0
            return Action.C
        elif cooperators_last_round == m - 1:
            self.consecutive_failures = 0
            return Action.C
        elif cooperators_last_round >= m - 2 and self.consecutive_failures <= 1:
            return Action.C
        elif self._is_positive_trend(history):
            self.consecutive_failures = 0
            return Action.C
        else:
            self.consecutive_failures += 1
            if self.consecutive_failures >= 3:
                return Action.D
            else:
                return Action.C

    def _is_positive_trend(self, history: PlayerHistory) -> bool:
        """Check if cooperation is showing a positive trend in recent rounds."""
        if history.round_number < 2:
            return False
        last_round_idx = history.round_number - 1
        prev_round_idx = history.round_number - 2
        last_opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        prev_opponent_cooperators = sum(history.opponent_actions[prev_round_idx])
        last_my_action = history.my_actions[last_round_idx]
        prev_my_action = history.my_actions[prev_round_idx]
        last_total = last_opponent_cooperators + (1 if last_my_action else 0)
        prev_total = prev_opponent_cooperators + (1 if prev_my_action else 0)
        return last_total > prev_total

class Strategy_COOPERATIVE_47(BaseStrategy):
    """
    Adaptive Trust Builder: A cooperative strategy that prioritizes collective welfare while maintaining 
    resilience against exploitation. Cooperates based on expected number of cooperators meeting the 
    threshold, with optimistic assumptions and trust-building behaviors.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        coop_probs = []
        for opponent_idx in range(self.n_players - 1):
            lookback_rounds = min(3, history.round_number)
            if lookback_rounds == 0:
                prob = 0.7
            else:
                recent_cooperations = 0
                for round_idx in range(history.round_number - lookback_rounds, history.round_number):
                    if history.opponent_actions[round_idx, opponent_idx]:
                        recent_cooperations += 1
                prob = recent_cooperations / lookback_rounds
                if history.round_number > 0:
                    prev_round_idx = history.round_number - 1
                    prev_cooperators = sum(history.opponent_actions[prev_round_idx]) + (1 if history.my_actions[prev_round_idx] else 0)
                    if prev_cooperators < self.m and history.opponent_actions[prev_round_idx, opponent_idx]:
                        prob = min(1.0, prob + 0.1)
            coop_probs.append(prob)
        expected_cooperators = 1 + sum(coop_probs)
        if expected_cooperators >= self.m + 0.5:
            return Action.C
        elif expected_cooperators < self.m - 0.5:
            return Action.D
        else:
            if self._is_cooperation_trending_up(history):
                return Action.C
            if current_round <= 0.7 * self.n_rounds:
                return Action.C
            return Action.C

    def _is_cooperation_trending_up(self, history: PlayerHistory) -> bool:
        """Check if cooperation trend is increasing over the last 3 rounds."""
        if history.round_number < 3:
            return True
        recent_coop_counts = []
        for round_idx in range(max(0, history.round_number - 3), history.round_number):
            opponent_coops = sum(history.opponent_actions[round_idx])
            my_coop = 1 if history.my_actions[round_idx] else 0
            total_coops = opponent_coops + my_coop
            recent_coop_counts.append(total_coops)
        if len(recent_coop_counts) < 2:
            return True
        return recent_coop_counts[-1] >= recent_coop_counts[0]

class Strategy_COOPERATIVE_48(BaseStrategy):
    """
    Conditional Cooperator with Trust Building: Starts with cooperation, then cooperates 
    based on collective cooperation rates and trends, with forgiveness mechanisms.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        if current_round == r:
            if history.round_number > 0:
                last_round_cooperators = sum(history.opponent_actions[history.round_number - 1]) + (1 if history.my_actions[history.round_number - 1] else 0)
                cooperation_rate = last_round_cooperators / n
                threshold = max(0, (m - 2) / n)
                return Action.C if cooperation_rate >= threshold else Action.D
            return Action.C
        if history.round_number > 0:
            last_round_cooperators = sum(history.opponent_actions[history.round_number - 1]) + (1 if history.my_actions[history.round_number - 1] else 0)
            cooperation_rate = last_round_cooperators / n
            threshold_safety = (m - 1) / n
            if cooperation_rate >= threshold_safety:
                return Action.C
            else:
                if history.round_number > 1:
                    two_rounds_ago_cooperators = sum(history.opponent_actions[history.round_number - 2]) + (1 if history.my_actions[history.round_number - 2] else 0)
                    prev_cooperation_rate = two_rounds_ago_cooperators / n
                    if cooperation_rate > prev_cooperation_rate:
                        return Action.C
                return Action.D
        return Action.C

class Strategy_COOPERATIVE_49(BaseStrategy):
    """
    Adaptive Trust Builder - A cooperative strategy that builds trust through adaptive learning
    and maintains cooperation while protecting against exploitation in collective risk dilemmas.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self.trust_scores = np.full(self.n_players - 1, 0.5)
        self.decay_factor = 0.8

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if history.round_number > 0:
            last_round_actions = history.opponent_actions[history.round_number - 1]
            for i in range(len(self.trust_scores)):
                if last_round_actions[i]:
                    self.trust_scores[i] = self.trust_scores[i] * self.decay_factor + (1 - self.decay_factor) * 1.0
                else:
                    self.trust_scores[i] = self.trust_scores[i] * self.decay_factor + (1 - self.decay_factor) * 0.0
        if current_round == self.n_rounds:
            return Action.C
        expected_cooperators = 1 + np.sum(self.trust_scores)
        if expected_cooperators >= self.m - 1:
            return Action.C
        elif np.mean(self.trust_scores) > 0.3:
            return Action.C
        elif current_round <= self.n_rounds // 3:
            return Action.C
        else:
            rounds_since_threshold = self._rounds_since_threshold_met(history)
            if rounds_since_threshold <= 2:
                return Action.C
            else:
                return Action.C

    def _rounds_since_threshold_met(self, history: PlayerHistory) -> int:
        """Calculate rounds since threshold was last met."""
        rounds_since = float('inf')
        for round_idx in range(history.round_number - 1, -1, -1):
            my_action = 1 if history.my_actions[round_idx] else 0
            opponent_cooperators = np.sum(history.opponent_actions[round_idx])
            total_cooperators = my_action + opponent_cooperators
            if total_cooperators >= self.m:
                rounds_since = history.round_number - 1 - round_idx
                break
        return int(rounds_since) if rounds_since != float('inf') else 999

class Strategy_COOPERATIVE_50(BaseStrategy):
    """
    Generous Threshold Guardian: A cooperative strategy that prioritizes collective welfare
    while being resilient to occasional defections. Aims to maintain cooperation when the
    threshold is achievable while protecting against systematic exploitation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        k = self.game_description.k
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        last_round_idx = history.round_number - 1
        my_last_action = history.my_actions[last_round_idx]
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        total_cooperators = opponent_cooperators + (1 if my_last_action else 0)
        cooperation_rate = total_cooperators / n
        threshold_met_last_round = total_cooperators >= m
        if current_round == r:
            rounds_to_check = min(3, history.round_number)
            recent_cooperation_sum = 0
            for i in range(rounds_to_check):
                round_idx = history.round_number - 1 - i
                my_action = history.my_actions[round_idx]
                opp_cooperators = sum(history.opponent_actions[round_idx])
                round_cooperators = opp_cooperators + (1 if my_action else 0)
                recent_cooperation_sum += round_cooperators / n
            recent_cooperation_trend = recent_cooperation_sum / rounds_to_check
            threshold_successes = 0
            for round_idx in range(history.round_number):
                my_action = history.my_actions[round_idx]
                opp_cooperators = sum(history.opponent_actions[round_idx])
                round_cooperators = opp_cooperators + (1 if my_action else 0)
                if round_cooperators >= m:
                    threshold_successes += 1
            threshold_success_rate = threshold_successes / history.round_number
            if threshold_success_rate >= 0.6:
                return Action.C
            elif recent_cooperation_trend >= (m + 1) / n:
                return Action.C
            elif recent_cooperation_trend >= 0.5:
                return Action.C
            else:
                return Action.D
        is_small_group = n <= 4
        is_high_threshold = m > 0.75 * n
        is_low_reward = k <= 1.5
        if threshold_met_last_round:
            if cooperation_rate >= 0.7:
                return Action.C
            elif cooperation_rate >= m / n:
                return Action.C
            else:
                return Action.C
        elif cooperation_rate >= 0.8:
            return Action.C
        elif cooperation_rate >= (m - 1) / n:
            return Action.C
        elif cooperation_rate >= 0.3:
            if is_small_group and cooperation_rate >= 0.25:
                return Action.C
            elif is_high_threshold and cooperation_rate >= 0.4:
                return Action.C
            else:
                return Action.D
        elif is_small_group and cooperation_rate >= 0.25:
            return Action.C
        elif is_high_threshold and cooperation_rate >= 0.4:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_51(BaseStrategy):
    """
    Threshold-Aware Reciprocal Cooperation (TARC) Strategy.
    
    Prioritizes collective welfare while being resilient to exploitation.
    Starts cooperatively and maintains cooperation when group reciprocates,
    with graduated responses to declining cooperation and forgiveness mechanisms.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.r:
            return self._final_round_decision(history)
        prev_round_idx = history.round_number - 1
        prev_cooperators = sum(history.opponent_actions[prev_round_idx]) + int(history.my_actions[prev_round_idx])
        cooperation_rate = prev_cooperators / self.n
        cooperation_threshold_high = 0.6
        cooperation_threshold_low = 0.3
        if self.n <= 4:
            cooperation_threshold_high -= 0.1
            cooperation_threshold_low -= 0.1
        if self.m / self.n > 0.7:
            cooperation_threshold_low = 0.2
        if prev_cooperators >= self.m:
            return Action.C
        elif prev_cooperators >= self.m - 1:
            return Action.C
        elif prev_cooperators >= max(2, self.m - 2):
            return Action.C
        elif cooperation_rate < cooperation_threshold_low and current_round > 4:
            if current_round % 3 == 0 or current_round % 4 == 0:
                recent_trend = self._get_cooperation_trend(history, 3)
                if recent_trend > cooperation_rate:
                    return Action.C
            return Action.D
        else:
            return Action.C

    def _final_round_decision(self, history: PlayerHistory) -> Action:
        """Decision logic for the final round."""
        rounds_to_check = min(3, history.round_number)
        total_cooperators = 0
        total_possible = 0
        for i in range(rounds_to_check):
            round_idx = history.round_number - 1 - i
            cooperators_in_round = sum(history.opponent_actions[round_idx]) + int(history.my_actions[round_idx])
            total_cooperators += cooperators_in_round
            total_possible += self.n
        avg_cooperation_rate = total_cooperators / total_possible if total_possible > 0 else 0
        threshold_rate = self.m / self.n
        if avg_cooperation_rate >= threshold_rate:
            return Action.C
        else:
            return Action.D

    def _get_cooperation_trend(self, history: PlayerHistory, rounds_back: int) -> float:
        """Calculate average cooperation rate over the last few rounds."""
        rounds_to_check = min(rounds_back, history.round_number)
        if rounds_to_check == 0:
            return 0.0
        total_cooperators = 0
        for i in range(rounds_to_check):
            round_idx = history.round_number - 1 - i
            cooperators_in_round = sum(history.opponent_actions[round_idx]) + int(history.my_actions[round_idx])
            total_cooperators += cooperators_in_round
        return total_cooperators / (rounds_to_check * self.n)

class Strategy_COOPERATIVE_52(BaseStrategy):
    """
    Adaptive Trust Builder: A cooperative strategy that builds trust early, adapts to group cooperation patterns,
    and maintains cooperative stance throughout the game to help achieve collective success.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.reset_chance_used = {}

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        total_rounds = self.game_description.n_rounds
        current_round = history.round_number + 1
        trust_building_end = max(1, int(total_rounds * 0.2))
        endgame_start = int(total_rounds * 0.9)
        if current_round <= trust_building_end:
            return Action.C
        if current_round >= endgame_start:
            return Action.C
        prev_round_idx = history.round_number - 1
        prev_cooperators = int(sum(history.opponent_actions[prev_round_idx])) + int(history.my_actions[prev_round_idx])
        if prev_cooperators >= m - 1:
            return Action.C
        if self._threshold_met_last_n_rounds(history, 3) >= 3:
            return Action.C
        if not self._threshold_met_in_round(history, prev_round_idx):
            reset_key = prev_round_idx
            if reset_key not in self.reset_chance_used:
                self.reset_chance_used[reset_key] = True
                return Action.C
        consecutive_failures = self._count_consecutive_threshold_failures(history)
        if consecutive_failures >= 3 and consecutive_failures % 3 == 0:
            return Action.C
        return Action.C

    def _threshold_met_in_round(self, history: PlayerHistory, round_idx: int) -> bool:
        """Check if threshold was met in a specific round."""
        if round_idx < 0 or round_idx >= history.round_number:
            return False
        cooperators = int(sum(history.opponent_actions[round_idx])) + int(history.my_actions[round_idx])
        return cooperators >= self.game_description.m

    def _threshold_met_last_n_rounds(self, history: PlayerHistory, n: int) -> int:
        """Count how many of the last n rounds had threshold met."""
        count = 0
        start_idx = max(0, history.round_number - n)
        for round_idx in range(start_idx, history.round_number):
            if self._threshold_met_in_round(history, round_idx):
                count += 1
        return count

    def _count_consecutive_threshold_failures(self, history: PlayerHistory) -> int:
        """Count consecutive rounds where threshold was not met, starting from most recent."""
        count = 0
        for round_idx in range(history.round_number - 1, -1, -1):
            if not self._threshold_met_in_round(history, round_idx):
                count += 1
            else:
                break
        return count

class Strategy_COOPERATIVE_53(BaseStrategy):
    """
    Optimistic Threshold Guardian: A cooperative strategy that aims to ensure the cooperation 
    threshold is met while being resilient against exploitation. Always cooperates when 
    needed for threshold, occasionally defects when safe.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.trust_scores = None
        self.threshold_buffer = 1
        self.decay = 0.7

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            n_players = self.game_description.n_players
            self.trust_scores = [1.0] * (n_players - 1)
            return Action.C
        current_round = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        m = self.game_description.m
        expected_coop = 0
        for player_idx in range(len(self.trust_scores)):
            player_actions = history.opponent_actions[:, player_idx]
            cooperation_rate = np.mean(player_actions.astype(float))
            self.trust_scores[player_idx] = self.decay * self.trust_scores[player_idx] + (1 - self.decay) * cooperation_rate
            if self.trust_scores[player_idx] > 0.6:
                expected_coop += 1
        if current_round == n_rounds:
            if expected_coop < m - 1:
                return Action.C
            elif expected_coop >= m + 2:
                return Action.D
            else:
                return Action.C
        elif expected_coop < m - 1:
            return Action.C
        elif expected_coop >= m + self.threshold_buffer:
            if random.random() < 0.3:
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

class Strategy_COOPERATIVE_54(BaseStrategy):
    """
    Graduated Reciprocal Cooperation (GRC) Strategy
    
    Prioritizes collective welfare while maintaining resilience against exploitation.
    Uses adaptive cooperation based on threshold assessment and cooperation trends.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_num = history.round_number
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        last_round_opponents = history.opponent_actions[round_num - 1]
        cooperators_last_round = int(sum(last_round_opponents))
        if history.my_actions[round_num - 1]:
            total_cooperators_last_round = cooperators_last_round + 1
        else:
            total_cooperators_last_round = cooperators_last_round
        if round_num == r - 1:
            if cooperators_last_round >= m - 1:
                return Action.C
            elif cooperators_last_round >= m // 2:
                my_total_payoff = sum(history.my_payoffs)
                avg_expected = round_num * (1 + self.game_description.k / 2)
                if my_total_payoff < avg_expected:
                    return Action.C
            return Action.D
        if total_cooperators_last_round >= m:
            return Action.C
        cooperation_ratio = cooperators_last_round / (n - 1) if n > 1 else 0
        if cooperation_ratio >= 0.6:
            return Action.C
        elif cooperation_ratio >= 0.4:
            if self._cooperation_trend_improving(history):
                return Action.C
            else:
                return Action.D
        if round_num % 3 == 0 and (not history.my_actions[round_num - 1]):
            if cooperators_last_round >= m // 2:
                return Action.C
        return Action.D

    def _cooperation_trend_improving(self, history: PlayerHistory) -> bool:
        """Check if cooperation trend is improving over last few rounds."""
        round_num = history.round_number
        n = self.game_description.n_players
        if round_num < 3:
            return True
        recent_rounds = min(3, round_num)
        cooperation_rates = []
        for i in range(recent_rounds):
            round_idx = round_num - 1 - i
            cooperators = sum(history.opponent_actions[round_idx])
            rate = cooperators / (n - 1) if n > 1 else 0
            cooperation_rates.append(rate)
        if len(cooperation_rates) >= 2:
            return cooperation_rates[0] >= cooperation_rates[-1]
        return True

class Strategy_COOPERATIVE_55(BaseStrategy):
    """
    Cautious Catalyst: A cooperative strategy that acts as a catalyst for cooperation
    while protecting against exploitation. Starts cooperatively, helps reach threshold,
    and adapts based on group cooperation trends.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        last_round_idx = history.round_number - 1
        cooperators_last_round = int(sum(history.opponent_actions[last_round_idx])) + int(history.my_actions[last_round_idx])
        if current_round == r:
            rounds_to_check = min(3, history.round_number)
            total_cooperators = 0
            total_possible = 0
            for i in range(rounds_to_check):
                round_idx = history.round_number - 1 - i
                round_cooperators = int(sum(history.opponent_actions[round_idx])) + int(history.my_actions[round_idx])
                total_cooperators += round_cooperators
                total_possible += n
            recent_cooperation_rate = total_cooperators / total_possible if total_possible > 0 else 0
            if recent_cooperation_rate >= 0.6 and cooperators_last_round >= m - 1:
                return Action.C
            elif cooperators_last_round >= m:
                return Action.C
            else:
                return Action.D
        if cooperators_last_round >= m:
            return Action.C
        elif cooperators_last_round >= m - 1:
            return Action.C
        elif cooperators_last_round >= max(2, m // 2):
            cooperation_trend = 0
            if history.round_number >= 3:
                recent_rounds = min(2, history.round_number - 1)
                earlier_rounds = min(1, history.round_number - recent_rounds - 1)
                if recent_rounds > 0 and earlier_rounds > 0:
                    recent_cooperators = 0
                    for i in range(recent_rounds):
                        round_idx = history.round_number - 1 - i
                        round_cooperators = int(sum(history.opponent_actions[round_idx])) + int(history.my_actions[round_idx])
                        recent_cooperators += round_cooperators
                    recent_avg = recent_cooperators / recent_rounds
                    earlier_cooperators = 0
                    for i in range(earlier_rounds):
                        round_idx = history.round_number - 1 - recent_rounds - i
                        round_cooperators = int(sum(history.opponent_actions[round_idx])) + int(history.my_actions[round_idx])
                        earlier_cooperators += round_cooperators
                    earlier_avg = earlier_cooperators / earlier_rounds
                    cooperation_trend = recent_avg - earlier_avg
            if cooperation_trend >= 0:
                return Action.C
            else:
                return Action.D
        elif current_round % 3 == 0:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_56(BaseStrategy):
    """
    Adaptive Trust Builder: A cooperative strategy that prioritizes collective welfare
    while maintaining resilience against exploitation. Uses a three-factor decision
    system based on recent cooperation rates, threshold proximity, and cooperation trends.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self.cooperation_threshold = 0.5 if self.n <= 4 else 0.6
        if self.m > self.n / 2:
            self.recent_weight = 0.3
            self.threshold_weight = 0.5
            self.trend_weight = 0.2
        else:
            self.recent_weight = 0.4
            self.threshold_weight = 0.4
            self.trend_weight = 0.2

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.r:
            return self._final_round_decision(history)
        if self._should_enter_recovery_mode(history):
            return self._recovery_mode_decision(history)
        return self._adaptive_cooperation_decision(history)

    def _final_round_decision(self, history: PlayerHistory) -> Action:
        """Final round: Conditional cooperation based on previous round performance"""
        if history.round_number == 0:
            return Action.C
        last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
        if last_round_cooperators >= self.m - 1:
            return Action.C
        if last_round_cooperators >= self.m - 2:
            return Action.C
        return Action.D

    def _adaptive_cooperation_decision(self, history: PlayerHistory) -> Action:
        """Main decision logic using three-factor system"""
        last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
        recent_cooperation_rate = last_round_cooperators / (self.n - 1)
        threshold_proximity_factor = self._calculate_threshold_proximity(last_round_cooperators)
        trend_factor = self._calculate_trend_factor(history)
        cooperation_score = self.recent_weight * recent_cooperation_rate + self.threshold_weight * threshold_proximity_factor + self.trend_weight * trend_factor
        return Action.C if cooperation_score >= self.cooperation_threshold else Action.D

    def _calculate_threshold_proximity(self, last_round_cooperators: int) -> float:
        """Calculate how close we are to the cooperation threshold"""
        if last_round_cooperators >= self.m - 1:
            return 1.0
        elif last_round_cooperators >= self.m - 2:
            return 0.7
        else:
            return last_round_cooperators / max(1, self.m - 1)

    def _calculate_trend_factor(self, history: PlayerHistory) -> float:
        """Calculate cooperation trend factor"""
        if history.round_number < 2:
            return 0.5
        current_cooperators = sum(history.opponent_actions[history.round_number - 1])
        previous_cooperators = sum(history.opponent_actions[history.round_number - 2])
        recent_trend = current_cooperators - previous_cooperators
        if recent_trend > 0:
            return 1.0
        elif recent_trend == 0:
            return 0.5
        else:
            return 0.0

    def _should_enter_recovery_mode(self, history: PlayerHistory) -> bool:
        """Check if we should enter recovery mode due to low cooperation"""
        current_round = history.round_number + 1
        if current_round <= 3 or current_round > self.r // 2:
            return False
        consecutive_low_rounds = 0
        start_check = max(0, history.round_number - 3)
        for round_idx in range(start_check, history.round_number):
            cooperators = sum(history.opponent_actions[round_idx])
            cooperation_rate = cooperators / (self.n - 1)
            if cooperation_rate < 0.2:
                consecutive_low_rounds += 1
            else:
                consecutive_low_rounds = 0
        return consecutive_low_rounds >= 3

    def _recovery_mode_decision(self, history: PlayerHistory) -> Action:
        """Recovery mode: only cooperate if  m-1 others cooperated last round"""
        last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
        return Action.C if last_round_cooperators >= self.m - 1 else Action.D

class Strategy_COOPERATIVE_57(BaseStrategy):
    """
    Optimistic Threshold Guardian: A cooperative strategy that balances cooperation 
    with strategic awareness of the collective risk structure. Maintains trust scores 
    for each player and makes decisions based on predicted likelihood of reaching 
    the minimum threshold, with forgiveness mechanisms and adaptive caution.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.trust_scores = np.ones(game_description.n_players - 1)
        self.consecutive_failures = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if history.round_number > 0:
            self._update_trust_scores(history.opponent_actions[history.round_number - 1])
            self._update_failure_count(history)
        if current_round == self.game_description.n_rounds:
            predicted_cooperators = self._count_likely_cooperators(threshold=0.6)
            if predicted_cooperators >= self.game_description.m:
                return Action.C
            else:
                return Action.D
        if self.consecutive_failures >= 2:
            predicted_cooperators = self._count_likely_cooperators(threshold=0.7)
            if predicted_cooperators >= self.game_description.m:
                self.consecutive_failures = 0
                return Action.C
            else:
                return Action.D
        else:
            predicted_cooperators = self._count_likely_cooperators(threshold=0.5)
            if predicted_cooperators >= self.game_description.m + 1:
                return Action.C
            elif predicted_cooperators >= self.game_description.m:
                return Action.C
            elif random.random() < 0.3:
                return Action.C
            else:
                return Action.D

    def _update_trust_scores(self, opponent_actions):
        """Update trust scores based on opponent actions in the previous round."""
        for i in range(len(self.trust_scores)):
            if opponent_actions[i]:
                self.trust_scores[i] = min(1.0, self.trust_scores[i] + 0.1)
            else:
                self.trust_scores[i] = max(0.0, self.trust_scores[i] - 0.15)

    def _update_failure_count(self, history):
        """Update consecutive failures count based on whether threshold was met."""
        last_round_idx = history.round_number - 1
        my_action = history.my_actions[last_round_idx]
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        total_cooperators = opponent_cooperators + (1 if my_action else 0)
        if total_cooperators < self.game_description.m:
            self.consecutive_failures += 1
        else:
            self.consecutive_failures = 0

    def _count_likely_cooperators(self, threshold):
        """Count how many players (including self) are likely to cooperate."""
        likely_cooperators = 1
        for trust_score in self.trust_scores:
            if trust_score >= threshold:
                likely_cooperators += 1
        return likely_cooperators

class Strategy_COOPERATIVE_58(BaseStrategy):
    """
    Adaptive Trust Builder strategy for Collective Risk Dilemma.
    
    This cooperative strategy balances trust-building with risk management:
    - Starts with cooperation to signal intent
    - Uses threshold-based decisions in core rounds
    - Applies forgiveness mechanisms to prevent breakdown
    - Manages endgame strategically
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_num = history.round_number + 1
        last_cooperators = self._count_cooperators_last_round(history)
        if round_num <= 3:
            if last_cooperators >= self.m - 1:
                return Action.C
            else:
                return Action.D
        if round_num >= self.r - 1:
            if round_num == self.r:
                return Action.C if last_cooperators >= self.m else Action.D
            else:
                avg_coop_rate = self._average_cooperation_rate(history)
                return Action.C if avg_coop_rate >= 0.35 else Action.D
        threshold = max(self.m, int(math.ceil(self.n * 0.4)))
        recent_coop = self._sum_cooperators_last_n_rounds(history, 3)
        if last_cooperators >= threshold:
            return Action.C
        elif last_cooperators >= self.m - 1:
            return Action.C
        elif recent_coop >= self.m * 2:
            return Action.C
        else:
            return Action.D

    def _count_cooperators_last_round(self, history: PlayerHistory) -> int:
        """Count total cooperators (including self) in the most recent round."""
        last_round_idx = history.round_number - 1
        opponent_cooperators = int(sum(history.opponent_actions[last_round_idx]))
        self_cooperated = int(history.my_actions[last_round_idx])
        return opponent_cooperators + self_cooperated

    def _average_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate average cooperation rate across all previous rounds."""
        total_cooperators = 0
        total_possible = 0
        for round_idx in range(history.round_number):
            round_cooperators = int(sum(history.opponent_actions[round_idx])) + int(history.my_actions[round_idx])
            total_cooperators += round_cooperators
            total_possible += self.n
        return total_cooperators / total_possible if total_possible > 0 else 0.0

    def _sum_cooperators_last_n_rounds(self, history: PlayerHistory, n: int) -> int:
        """Sum total cooperators over the last n rounds."""
        total_cooperators = 0
        start_round = max(0, history.round_number - n)
        for round_idx in range(start_round, history.round_number):
            round_cooperators = int(sum(history.opponent_actions[round_idx])) + int(history.my_actions[round_idx])
            total_cooperators += round_cooperators
        return total_cooperators

class Strategy_COOPERATIVE_59(BaseStrategy):
    """
    Adaptive Threshold Guardian: A cooperative strategy that prioritizes achieving collective benefit
    while being resilient to defections. Adapts based on cooperation patterns and maintains trust levels.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_num = history.round_number + 1
        total_cooperators_history = []
        for round_idx in range(history.round_number):
            cooperators = int(history.my_actions[round_idx]) + sum(history.opponent_actions[round_idx])
            total_cooperators_history.append(cooperators)
        recent_window = min(3, len(total_cooperators_history))
        recent_cooperators = sum(total_cooperators_history[-recent_window:]) / recent_window if recent_window > 0 else 0
        threshold_successes = sum((1 for count in total_cooperators_history if count >= self.m))
        threshold_success_rate = threshold_successes / len(total_cooperators_history) if total_cooperators_history else 0
        if threshold_success_rate >= 0.8 and recent_cooperators >= self.m:
            trust_level = 'HIGH'
        elif threshold_success_rate >= 0.5 and recent_cooperators >= self.m - 1:
            trust_level = 'MEDIUM'
        else:
            trust_level = 'LOW'
        if round_num >= self.r - 1:
            if trust_level == 'HIGH':
                return Action.C
            else:
                return Action.D
        if trust_level == 'HIGH':
            return Action.C
        elif trust_level == 'MEDIUM':
            if round_num > 0.9 * self.r and recent_cooperators < self.m:
                return Action.D
            else:
                return Action.C
        elif recent_cooperators >= self.m - 2 and round_num <= 0.8 * self.r:
            return Action.C
        else:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_60(BaseStrategy):
    """
    Adaptive Trust Builder: A cooperative strategy that prioritizes collective welfare
    while being adaptive to group cooperation levels. Starts with cooperation to build
    trust, uses threshold-based decisions with forgiveness, and protects against
    systematic exploitation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.currently_defecting = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.currently_defecting = False
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        round_num = history.round_number + 1
        last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
        if history.my_actions[history.round_number - 1]:
            last_round_cooperators += 1
        coop_rate = last_round_cooperators / n
        threshold_rate = m / n
        if round_num == r:
            success_count = 0
            for round_idx in range(history.round_number):
                round_cooperators = sum(history.opponent_actions[round_idx])
                if history.my_actions[round_idx]:
                    round_cooperators += 1
                if round_cooperators >= m:
                    success_count += 1
            success_rate = success_count / history.round_number if history.round_number > 0 else 0
            return Action.C if success_rate >= 0.7 else Action.D
        if coop_rate >= threshold_rate:
            self.currently_defecting = False
            return Action.C
        if coop_rate >= 0.5:
            self.currently_defecting = False
            return Action.C
        missed_rounds = 0
        for round_idx in range(history.round_number - 1, -1, -1):
            round_cooperators = sum(history.opponent_actions[round_idx])
            if history.my_actions[round_idx]:
                round_cooperators += 1
            if round_cooperators < m:
                missed_rounds += 1
            else:
                break
        if missed_rounds <= 2:
            self.currently_defecting = False
            return Action.C
        if self.currently_defecting and coop_rate >= 0.6:
            self.currently_defecting = False
            return Action.C
        self.currently_defecting = True
        return Action.D

class Strategy_COOPERATIVE_61(BaseStrategy):
    """
    Adaptive Trust Builder: A cooperative strategy that prioritizes collective welfare
    while maintaining resilience against exploitation. Features cooperative opening,
    adaptive cooperation based on threshold safety and momentum, and end-game cooperation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_num = history.round_number + 1
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        if round_num <= 2:
            return Action.C
        if round_num >= r - 1:
            return Action.C
        prev_round_idx = history.round_number - 1
        cooperators_last_round = int(sum(history.opponent_actions[prev_round_idx])) + int(history.my_actions[prev_round_idx])
        my_last_action = history.my_actions[prev_round_idx]
        if cooperators_last_round >= m:
            return Action.C
        if cooperators_last_round == m - 1:
            return Action.C
        majority_threshold = int(math.ceil(n / 2))
        if cooperators_last_round >= majority_threshold:
            return Action.C
        consecutive_failures = self._count_consecutive_failed_thresholds(history)
        if consecutive_failures >= 2 and (not my_last_action):
            return Action.C
        if cooperators_last_round <= m - 2 and cooperators_last_round < majority_threshold and my_last_action:
            return Action.D
        return Action.C

    def _count_consecutive_failed_thresholds(self, history: PlayerHistory) -> int:
        """Count consecutive rounds where threshold m was not met, looking backwards from most recent."""
        m = self.game_description.m
        consecutive_failures = 0
        for round_idx in range(history.round_number - 1, -1, -1):
            cooperators_in_round = int(sum(history.opponent_actions[round_idx])) + int(history.my_actions[round_idx])
            if cooperators_in_round < m:
                consecutive_failures += 1
            else:
                break
        return consecutive_failures

class Strategy_COOPERATIVE_62(BaseStrategy):
    """
    Adaptive Threshold Guardian: A cooperative strategy that prioritizes collective welfare
    while maintaining smart risk management. Starts optimistically, adapts based on trends,
    and protects against exploitation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_num = history.round_number + 1
        prev_round_idx = history.round_number - 1
        prev_cooperators = sum(history.opponent_actions[prev_round_idx]) + (1 if history.my_actions[prev_round_idx] else 0)
        if prev_cooperators >= self.m:
            return Action.C
        if prev_cooperators == self.m - 1:
            return Action.C
        if round_num >= 3:
            recent_cooperation_rates = []
            start_idx = max(0, round_num - 4)
            for i in range(start_idx, round_num - 1):
                round_cooperators = sum(history.opponent_actions[i]) + (1 if history.my_actions[i] else 0)
                recent_cooperation_rates.append(round_cooperators / self.n)
            if len(recent_cooperation_rates) >= 2:
                trend = recent_cooperation_rates[-1] - recent_cooperation_rates[0]
                if trend >= 0 and recent_cooperation_rates[-1] >= (self.m - 1) / self.n:
                    return Action.C
        reliable_cooperators = 0
        rounds_played = history.round_number
        for player_idx in range(self.n - 1):
            cooperation_count = sum(history.opponent_actions[:rounds_played, player_idx])
            cooperation_rate = cooperation_count / rounds_played
            if cooperation_rate >= 0.5:
                reliable_cooperators += 1
        if reliable_cooperators + 1 >= self.m:
            return Action.C
        if round_num == self.r:
            successful_rounds = 0
            for i in range(rounds_played):
                round_cooperators = sum(history.opponent_actions[i]) + (1 if history.my_actions[i] else 0)
                if round_cooperators >= self.m:
                    successful_rounds += 1
            success_rate = successful_rounds / rounds_played
            if success_rate >= 0.6:
                return Action.C
        return Action.D

class Strategy_COOPERATIVE_63(BaseStrategy):
    """
    Adaptive Threshold Guardian strategy for Collective Risk Dilemma.
    
    This strategy prioritizes collective welfare while maintaining resilience against exploitation.
    It aims to establish and maintain cooperation by being a reliable contributor while encouraging
    others to join the cooperative effort through threshold-aware decision making.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_number = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        m = self.game_description.m
        last_round_idx = history.round_number - 1
        cooperators_last_round = int(sum(history.opponent_actions[last_round_idx]))
        if history.my_actions[last_round_idx]:
            cooperators_last_round += 1
        if round_number == n_rounds:
            if cooperators_last_round >= m - 1:
                return Action.C
            else:
                total_cooperation = 0
                total_possible = 0
                for r in range(history.round_number):
                    round_cooperators = int(sum(history.opponent_actions[r]))
                    if history.my_actions[r]:
                        round_cooperators += 1
                    total_cooperation += round_cooperators
                    total_possible += self.game_description.n_players
                overall_cooperation_rate = total_cooperation / total_possible if total_possible > 0 else 0
                return Action.C if overall_cooperation_rate >= 0.4 else Action.D
        if cooperators_last_round >= m:
            return Action.C
        elif cooperators_last_round == m - 1:
            return Action.C
        elif cooperators_last_round >= m / 2:
            return Action.C
        elif cooperators_last_round < m / 2 and cooperators_last_round > 0:
            if self._trend_improving(history) or round_number <= n_rounds / 3:
                return Action.C
            else:
                return Action.D
        elif round_number <= 3:
            return Action.C
        else:
            return Action.D

    def _trend_improving(self, history: PlayerHistory) -> bool:
        """Evaluate if cooperation trend is improving."""
        rounds_observed = history.round_number
        if rounds_observed < 3:
            return True
        recent_cooperation = 0
        for i in range(max(0, rounds_observed - 3), rounds_observed):
            round_cooperators = int(sum(history.opponent_actions[i]))
            if history.my_actions[i]:
                round_cooperators += 1
            recent_cooperation += round_cooperators
        recent_avg = recent_cooperation / min(3, rounds_observed)
        if rounds_observed < 6:
            return True
        earlier_cooperation = 0
        earlier_count = 0
        for i in range(max(0, rounds_observed - 6), rounds_observed - 3):
            round_cooperators = int(sum(history.opponent_actions[i]))
            if history.my_actions[i]:
                round_cooperators += 1
            earlier_cooperation += round_cooperators
            earlier_count += 1
        if earlier_count == 0:
            return True
        earlier_avg = earlier_cooperation / earlier_count
        return recent_avg > earlier_avg

class Strategy_COOPERATIVE_64(BaseStrategy):
    """
    Optimistic Threshold Guardian: A cooperative strategy that builds trust through 
    consistent early cooperation and maintains cooperation based on group dynamics 
    and threshold monitoring. Focuses on collective benefit while adapting to 
    cooperation patterns.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        if current_round <= 3:
            return Action.C
        if current_round > 0.8 * r:
            return Action.C
        recent_rounds = min(3, history.round_number)
        total_cooperations = 0
        rounds_above_threshold = 0
        for round_idx in range(history.round_number - recent_rounds, history.round_number):
            if history.my_actions[round_idx]:
                total_cooperations += 1
            round_cooperations = sum(history.opponent_actions[round_idx])
            total_cooperations += round_cooperations
            total_round_cooperations = int(history.my_actions[round_idx]) + round_cooperations
            if total_round_cooperations >= m:
                rounds_above_threshold += 1
        cooperation_rate = total_cooperations / (n * recent_rounds)
        threshold_success_rate = rounds_above_threshold / recent_rounds
        if cooperation_rate >= 0.6:
            return Action.C
        elif cooperation_rate >= 0.4 and threshold_success_rate >= 0.5:
            return Action.C
        elif cooperation_rate < 0.3:
            return Action.C
        else:
            last_round_cooperations = sum(history.opponent_actions[history.round_number - 1])
            if last_round_cooperations >= m - 1:
                return Action.C
            else:
                return Action.C

class Strategy_AGGRESSIVE_2(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Predatory Threshold"
    
    Maximizes personal payoff by exploiting cooperative opponents while minimizing personal risk.
    Always defects unless cooperation is absolutely necessary to trigger the reward.
    Monitors other players' cooperation patterns to identify when exactly m-1 others are likely 
    to cooperate, then only cooperates when it can be the decisive m-th cooperator.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        if current_round <= 3:
            return Action.D

        def count_cooperators_last_round():
            if history.round_number == 0:
                return 0
            return int(np.sum(history.opponent_actions[history.round_number - 1]))

        def count_consistent_cooperators(k_rounds=3):
            if history.round_number < k_rounds:
                k_rounds = history.round_number
            if k_rounds == 0:
                return 0
            recent_actions = history.opponent_actions[-k_rounds:]
            cooperation_counts = np.sum(recent_actions, axis=0)
            return int(np.sum(cooperation_counts >= k_rounds - 1))

        def get_opponent_cooperation_rates():
            if history.round_number == 0:
                return np.zeros(n - 1)
            return np.mean(history.opponent_actions, axis=0)
        if current_round >= r - 1:
            cooperators_last_round = count_cooperators_last_round()
            if current_round == r - 1:
                if cooperators_last_round >= m - 1:
                    return Action.D
                elif cooperators_last_round == m - 2:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
        cooperators_last_round = count_cooperators_last_round()
        if cooperators_last_round >= m - 1:
            return Action.D
        elif cooperators_last_round == m - 2:
            consistent_cooperators = count_consistent_cooperators(3)
            if consistent_cooperators >= m - 1:
                return Action.C
            else:
                return Action.D
        else:
            if history.round_number >= 3:
                recent_rounds = min(3, history.round_number)
                recent_cooperators = []
                for i in range(recent_rounds):
                    round_cooperators = int(np.sum(history.opponent_actions[history.round_number - 1 - i]))
                    recent_cooperators.append(round_cooperators)
                avg_recent_cooperators = np.mean(recent_cooperators)
                if avg_recent_cooperators < m - 2 and n <= 4:
                    if (current_round * 17 + history.round_number * 13) % 4 == 0:
                        return Action.C
            return Action.D

class Strategy_AGGRESSIVE_3(BaseStrategy):
    """
    Threshold Exploiter: An aggressive strategy that maximizes individual payoffs by exploiting 
    the collective risk structure. Defects by default and only cooperates strategically when 
    predicted to be the decisive m-th cooperator, while exploiting others' cooperation patterns.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        recent_rounds = min(3, history.round_number)
        recent_cooperators = 0
        for i in range(max(0, history.round_number - recent_rounds), history.round_number):
            recent_cooperators += sum(history.opponent_actions[i])
            if history.my_actions[i]:
                recent_cooperators += 1
        cooperation_rate = recent_cooperators / (self.n * recent_rounds) if recent_rounds > 0 else 0
        if cooperation_rate > self.m / self.n + 0.2:
            return Action.D
        if history.round_number > 0:
            last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
            if last_round_cooperators >= self.m:
                return Action.D
        predicted_cooperators = self._predict_current_round_cooperators(history, current_round)
        if predicted_cooperators == self.m - 1:
            if self.r - current_round > 2:
                return Action.C
            else:
                return Action.D
        return Action.D

    def _predict_current_round_cooperators(self, history: PlayerHistory, current_round: int) -> int:
        """Predict how many opponents will cooperate this round based on their recent behavior."""
        prediction = 0
        lookback = min(3, history.round_number)
        for player_idx in range(self.n - 1):
            if lookback == 0:
                if random.random() < 0.3:
                    prediction += 1
                continue
            recent_cooperations = 0
            for round_idx in range(max(0, history.round_number - lookback), history.round_number):
                if history.opponent_actions[round_idx, player_idx]:
                    recent_cooperations += 1
            recent_coop_rate = recent_cooperations / lookback
            end_game_factor = max(0.3, 1 - (self.r - current_round) / self.r)
            adjusted_coop_rate = recent_coop_rate * end_game_factor
            if adjusted_coop_rate > 0.5:
                prediction += 1
        return prediction

class Strategy_AGGRESSIVE_4(BaseStrategy):
    """
    Exploitative Threshold Hunter: An aggressive strategy that maximizes personal payoffs
    by exploiting cooperative players while minimizing personal risk. Free rides when others
    cooperate and only contributes when absolutely necessary to maintain threshold.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        m = self.game_description.m
        cooperators_last_round = int(sum(history.opponent_actions[history.round_number - 1]))
        if history.my_actions[history.round_number - 1]:
            cooperators_last_round += 1
        if current_round == n_rounds:
            return Action.D
        if current_round == n_rounds - 1:
            return Action.D
        if cooperators_last_round >= m:
            return Action.D
        elif cooperators_last_round == m - 1:
            if history.my_actions[history.round_number - 1]:
                return Action.D
            else:
                return Action.C
        else:
            if history.round_number >= 2:
                cooperators_two_rounds_ago = int(sum(history.opponent_actions[history.round_number - 2]))
                if history.my_actions[history.round_number - 2]:
                    cooperators_two_rounds_ago += 1
                if cooperators_last_round < cooperators_two_rounds_ago - 2 and (not history.my_actions[history.round_number - 1]):
                    if cooperators_last_round <= m - 2:
                        return Action.D
                    else:
                        return Action.C
            return Action.D

class Strategy_AGGRESSIVE_5(BaseStrategy):
    """
    Opportunistic Free-Rider: An aggressive strategy that maximizes personal payoff by exploiting 
    cooperative behavior from others while minimizing personal contributions. Defects by default 
    but strategically cooperates only when absolutely necessary to secure personal benefits.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        if current_round == r:
            return Action.D
        if history.round_number > 0:
            cooperators_last_round = int(sum(history.opponent_actions[history.round_number - 1]))
            if history.my_actions[history.round_number - 1]:
                cooperators_last_round += 1
        else:
            cooperators_last_round = 0
        rounds_remaining = r - current_round
        if cooperators_last_round >= m:
            return Action.D
        if cooperators_last_round == m - 1:
            if rounds_remaining >= 2:
                return Action.C
            else:
                return Action.D
        if cooperators_last_round < m - 1:
            if rounds_remaining >= 3 and cooperators_last_round >= max(1, m // 2):
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_6(BaseStrategy):
    """
    Opportunistic Exploiter: An aggressive strategy that maximizes personal payoff by 
    exploiting cooperative players while minimizing personal risk. Defects in first 
    and last rounds, alternates between cooperation and defection based on how close 
    the cooperation threshold was met in the previous round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        last_round_idx = history.round_number - 1
        cooperators_last_round = int(sum(history.opponent_actions[last_round_idx]))
        if history.my_actions[last_round_idx]:
            cooperators_last_round += 1
        m = self.game_description.m
        if cooperators_last_round >= m:
            if cooperators_last_round >= m + 2:
                return Action.D
            else:
                my_previous_action = history.my_actions[last_round_idx]
                if my_previous_action:
                    return Action.D
                else:
                    return Action.C
        elif cooperators_last_round == m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_7(BaseStrategy):
    """
    Threshold Exploiter: An aggressive strategy that maximizes personal payoff by exploiting
    the collective risk structure. Free-rides on others' cooperation while maintaining just
    enough cooperation to avoid total collapse.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.n_rounds:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        coop_counts = []
        for round_idx in range(history.round_number):
            my_coop = 1 if history.my_actions[round_idx] else 0
            opponent_coop = sum(history.opponent_actions[round_idx])
            total_coop = my_coop + opponent_coop
            coop_counts.append(total_coop)
        avg_coop = sum(coop_counts) / len(coop_counts)
        last_round_coop = coop_counts[-1] if coop_counts else 0
        crisis_mode = False
        if len(coop_counts) >= 2:
            if coop_counts[-1] < self.m and coop_counts[-2] < self.m:
                crisis_mode = True
        learning_detected = False
        if len(coop_counts) >= 3:
            recent_avg = sum(coop_counts[-3:]) / 3
            early_avg = sum(coop_counts[:-3]) / len(coop_counts[:-3]) if len(coop_counts) > 3 else recent_avg
            if early_avg > 0 and recent_avg < early_avg * 0.5:
                learning_detected = True
        if crisis_mode:
            current_opponent_coop = sum(history.opponent_actions[-1]) if history.round_number > 0 else 0
            if current_opponent_coop == self.m - 1:
                return Action.C
            else:
                return Action.D
        if learning_detected:
            if random.random() < 0.4:
                return Action.C
            else:
                return Action.D
        if avg_coop >= self.m + 2:
            if random.random() < 0.95:
                return Action.D
            else:
                return Action.C
        elif avg_coop >= self.m + 1:
            return Action.D
        elif avg_coop >= self.m:
            if random.random() < 0.8:
                return Action.D
            else:
                return Action.C
        elif last_round_coop < self.m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_8(BaseStrategy):
    """
    Exploit-First Dominance: An aggressive strategy that maximizes personal payoff
    by exploiting cooperative opponents while minimizing vulnerability to other
    aggressive players. Defects first to signal dominance, then conditionally
    exploits surplus cooperation while contributing only when absolutely necessary.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        if current_round == r:
            return Action.D
        cooperators_last_round = int(sum(history.opponent_actions[history.round_number - 1]))
        if history.my_actions[history.round_number - 1]:
            cooperators_last_round += 1
        total_cooperators_so_far = 0
        for round_idx in range(history.round_number):
            round_cooperators = int(sum(history.opponent_actions[round_idx]))
            if history.my_actions[round_idx]:
                round_cooperators += 1
            total_cooperators_so_far += round_cooperators
        avg_cooperation_rate = total_cooperators_so_far / (history.round_number * n)
        if current_round == r - 1:
            cooperation_trend = 0
            if history.round_number >= 2:
                cooperators_two_rounds_ago = int(sum(history.opponent_actions[history.round_number - 2]))
                if history.my_actions[history.round_number - 2]:
                    cooperators_two_rounds_ago += 1
                cooperation_trend = cooperators_last_round - cooperators_two_rounds_ago
            if cooperators_last_round >= m and cooperation_trend >= 0:
                return Action.D
            elif cooperators_last_round == m - 1:
                return Action.C
            else:
                return Action.D
        if cooperators_last_round >= m + 1:
            return Action.D
        elif cooperators_last_round == m:
            if avg_cooperation_rate > 0.6:
                return Action.D
            else:
                return Action.C
        elif cooperators_last_round == m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_9(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Threshold Predator"
    
    This strategy operates on maximum exploitation with minimal contribution.
    It aggressively free-rides whenever possible while strategically cooperating 
    only when absolutely necessary to unlock rewards.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self.opponent_cooperation_rates = [0.0] * (self.n - 1)
        self.opponent_types = ['unknown'] * (self.n - 1)
        self.total_rounds_observed = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        self._update_opponent_modeling(history)
        if current_round <= 1:
            return self._early_round_strategy(history)
        elif current_round > self.r * 0.8:
            return self._endgame_strategy(history)
        else:
            return self._core_strategy(history)

    def _update_opponent_modeling(self, history: PlayerHistory):
        """Update opponent cooperation rates and classify opponent types."""
        rounds_observed = history.round_number
        self.total_rounds_observed = rounds_observed
        for opponent_idx in range(self.n - 1):
            cooperations = sum(history.opponent_actions[:rounds_observed, opponent_idx])
            self.opponent_cooperation_rates[opponent_idx] = cooperations / rounds_observed
            coop_rate = self.opponent_cooperation_rates[opponent_idx]
            if coop_rate > 0.7:
                self.opponent_types[opponent_idx] = 'reliable'
            elif coop_rate < 0.3:
                self.opponent_types[opponent_idx] = 'defector'
            else:
                self.opponent_types[opponent_idx] = 'conditional'

    def _predict_cooperators_this_round(self, history: PlayerHistory):
        """Predict how many opponents will cooperate this round."""
        if self.total_rounds_observed == 0:
            return 0
        predicted = 0
        for opponent_idx in range(self.n - 1):
            opponent_type = self.opponent_types[opponent_idx]
            coop_rate = self.opponent_cooperation_rates[opponent_idx]
            if opponent_type == 'reliable':
                predicted += 1 if coop_rate > 0.6 else 0
            elif opponent_type == 'defector':
                predicted += 1 if coop_rate > 0.4 else 0
            elif self.total_rounds_observed >= 3:
                recent_coop = sum(history.opponent_actions[-3:, opponent_idx])
                predicted += 1 if recent_coop >= 2 else 0
            else:
                predicted += 1 if coop_rate > 0.5 else 0
        return predicted

    def _early_round_strategy(self, history: PlayerHistory):
        """Strategy for early rounds (2-4): Test opponents and establish dominance."""
        predicted_cooperators = self._predict_cooperators_this_round(history)
        if predicted_cooperators == self.m - 1:
            return Action.C
        else:
            return Action.D

    def _core_strategy(self, history: PlayerHistory):
        """Core aggressive strategy: Calculated free-riding with threshold manipulation."""
        predicted_cooperators = self._predict_cooperators_this_round(history)
        if predicted_cooperators >= self.m:
            return Action.D
        elif predicted_cooperators == self.m - 1:
            reliable_count = sum((1 for t in self.opponent_types if t == 'reliable'))
            if reliable_count >= self.m:
                return Action.D if random.random() < 0.3 else Action.C
            else:
                return Action.C
        elif predicted_cooperators >= self.m - 2 and self.total_rounds_observed > 5:
            return Action.C if random.random() < 0.2 else Action.D
        else:
            return Action.D

    def _endgame_strategy(self, history: PlayerHistory):
        """End game strategy: Maximum exploitation as reputation concerns vanish."""
        predicted_cooperators = self._predict_cooperators_this_round(history)
        if predicted_cooperators >= self.m + 1:
            return Action.D
        elif predicted_cooperators == self.m:
            return Action.D
        elif predicted_cooperators == self.m - 1:
            reliable_count = sum((1 for t in self.opponent_types if t == 'reliable'))
            if reliable_count >= self.m - 1:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_10(BaseStrategy):
    """
    Ruthless Opportunist: An aggressive strategy that maximizes personal payoff by exploiting 
    cooperative players while minimizing personal risk. Operates in three phases: early exploitation,
    strategic calculation, and endgame defection.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        last_round_idx = history.round_number - 1
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        my_last_action = history.my_actions[last_round_idx]
        total_cooperators_last_round = opponent_cooperators + (1 if my_last_action else 0)
        if current_round <= 0.3 * r:
            return Action.D
        elif current_round <= 0.8 * r:
            if total_cooperators_last_round >= m:
                return Action.D
            elif opponent_cooperators >= m - 2:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_11(BaseStrategy):
    """
    Opportunistic Exploiter - An aggressive strategy that prioritizes maximum individual payoff
    by exploiting cooperative behavior from others while minimizing personal contribution.
    Free-rides whenever possible and only cooperates when absolutely necessary.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        rounds_remaining = self.n_rounds - current_round + 1
        if current_round == self.n_rounds:
            return Action.D
        expected_cooperators = self._estimate_cooperators_this_round(history, rounds_remaining)
        if expected_cooperators >= self.m:
            return Action.D
        elif expected_cooperators >= self.m - 1:
            personal_coop_rate = self._get_personal_cooperation_rate(history)
            if rounds_remaining <= 2 or personal_coop_rate < 0.3:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _estimate_cooperators_this_round(self, history: PlayerHistory, rounds_remaining: int) -> float:
        """Estimate how many opponents will cooperate this round"""
        base_estimate = 0.0
        n_opponents = self.n_players - 1
        consecutive_failures = self._count_consecutive_failures(history)
        for opponent_idx in range(n_opponents):
            recent_coop_rate = self._get_recent_cooperation_rate(history, opponent_idx, 3)
            overall_coop_rate = self._get_overall_cooperation_rate(history, opponent_idx)
            weighted_rate = 0.7 * recent_coop_rate + 0.3 * overall_coop_rate
            if rounds_remaining <= 2:
                weighted_rate *= 0.6
            if consecutive_failures >= 2:
                weighted_rate *= 1.3
            weighted_rate = min(1.0, weighted_rate)
            base_estimate += weighted_rate
        return base_estimate

    def _get_recent_cooperation_rate(self, history: PlayerHistory, opponent_idx: int, window: int) -> float:
        """Get cooperation rate for an opponent over the last 'window' rounds"""
        if history.round_number == 0:
            return 0.0
        start_round = max(0, history.round_number - window)
        recent_actions = history.opponent_actions[start_round:history.round_number, opponent_idx]
        if len(recent_actions) == 0:
            return 0.0
        return float(np.mean(recent_actions))

    def _get_overall_cooperation_rate(self, history: PlayerHistory, opponent_idx: int) -> float:
        """Get overall cooperation rate for an opponent"""
        if history.round_number == 0:
            return 0.0
        all_actions = history.opponent_actions[:history.round_number, opponent_idx]
        return float(np.mean(all_actions))

    def _get_personal_cooperation_rate(self, history: PlayerHistory) -> float:
        """Get my own cooperation rate so far"""
        if history.round_number == 0:
            return 0.0
        return float(np.mean(history.my_actions))

    def _count_consecutive_failures(self, history: PlayerHistory) -> int:
        """Count how many consecutive recent rounds failed to meet threshold"""
        consecutive_failures = 0
        for round_idx in range(history.round_number - 1, -1, -1):
            opponent_cooperators = int(np.sum(history.opponent_actions[round_idx]))
            my_cooperation = int(history.my_actions[round_idx])
            total_cooperators = opponent_cooperators + my_cooperation
            if total_cooperators < self.m:
                consecutive_failures += 1
            else:
                break
        return consecutive_failures

class Strategy_AGGRESSIVE_12(BaseStrategy):
    """
    Predatory Threshold Exploiter: An aggressive strategy that minimizes cooperation while maximizing exploitation of others' cooperation.
    Only cooperates when necessary to enable future exploitation opportunities.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self.opponent_coop_counts = [0] * (self.n_players - 1)
        self.reliable_cooperators = set()

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number
        if current_round > 0:
            last_round_actions = history.opponent_actions[current_round - 1]
            for i, cooperated in enumerate(last_round_actions):
                if cooperated:
                    self.opponent_coop_counts[i] += 1
        self.reliable_cooperators = set()
        for i in range(self.n_players - 1):
            cooperation_rate = self.opponent_coop_counts[i] / current_round
            if cooperation_rate > 0.6:
                self.reliable_cooperators.add(i)
        if current_round >= self.n_rounds - 1:
            return Action.D
        last_cooperators = sum(history.opponent_actions[current_round - 1])
        if len(self.reliable_cooperators) >= self.m:
            return Action.D
        elif len(self.reliable_cooperators) == self.m - 1:
            remaining_rounds = self.n_rounds - current_round
            if remaining_rounds * self.k > 1:
                return Action.C
            else:
                return Action.D
        elif last_cooperators >= self.m:
            return Action.D
        elif last_cooperators == self.m - 1:
            return Action.C
        elif current_round % 4 == 0 and last_cooperators < self.m - 2:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_13(BaseStrategy):
    """
    Opportunistic Exploiter: An aggressive strategy that maximizes personal payoff by exploiting 
    cooperative players while minimizing personal risk. Defects whenever possible and only 
    cooperates when collective failure is imminent.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.cooperation_threshold = max(1, game_description.m - 2)
        self.trust_decay = 0.8
        self.exploitation_bonus = 0
        self.consecutive_failures = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.consecutive_failures = 0
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            cooperators_last_round += 1
        threshold_met_last_round = cooperators_last_round >= self.game_description.m
        if not threshold_met_last_round:
            self.consecutive_failures += 1
        else:
            self.consecutive_failures = 0
        if cooperators_last_round >= self.game_description.m + 1:
            self.exploitation_bonus += self.game_description.k
            return Action.D
        if cooperators_last_round < self.game_description.m:
            if self.consecutive_failures <= 2:
                return Action.D
            else:
                return Action.C
        if cooperators_last_round <= self.cooperation_threshold:
            if cooperators_last_round == self.game_description.m - 1 and random.random() < 0.3:
                return Action.D
            else:
                return Action.C
        return Action.D

class Strategy_AGGRESSIVE_14(BaseStrategy):
    """
    Predatory Opportunist: An aggressive strategy that maximizes personal gain while minimizing risk.
    
    Always defects in first and final rounds. In middle rounds, exploits others' cooperation
    by free-riding when threshold is met, only cooperates when pivotal (prev_coop = m-1),
    and defects when cooperation cascade is detected.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        prev_round_idx = history.round_number - 1
        prev_cooperators = int(sum(history.opponent_actions[prev_round_idx]))
        if history.my_actions[prev_round_idx]:
            prev_cooperators += 1
        cooperation_rate = prev_cooperators / self.game_description.n_players
        threshold_rate = self.game_description.m / self.game_description.n_players
        if cooperation_rate < threshold_rate:
            return Action.D
        if prev_cooperators >= self.game_description.m:
            return Action.D
        if prev_cooperators == self.game_description.m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_15(BaseStrategy):
    """
    Exploit-First Predator: An aggressive strategy that prioritizes maximum personal payoff 
    extraction while minimizing risk exposure. Defaults to defection and only cooperates 
    when absolutely necessary to avoid disaster.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        last_round_cooperators = int(sum(history.opponent_actions[history.round_number - 1]))
        if current_round == self.r - 1:
            if history.round_number >= 3:
                recent_avg_cooperators = sum((sum(history.opponent_actions[i]) for i in range(max(0, history.round_number - 3), history.round_number))) / min(3, history.round_number)
                if recent_avg_cooperators >= self.m:
                    return Action.D
            if last_round_cooperators >= self.m - 1:
                return Action.D
            else:
                return Action.C
        cooperation_threshold = self.m
        if last_round_cooperators >= cooperation_threshold + 2:
            return Action.D
        elif last_round_cooperators == cooperation_threshold + 1:
            return Action.D
        elif last_round_cooperators == cooperation_threshold:
            return Action.D
        elif last_round_cooperators == cooperation_threshold - 1:
            if self._detect_stable_cooperator_pattern(history):
                return Action.D
            else:
                return Action.C
        elif current_round <= self.r // 3:
            return Action.D
        elif self._detect_cascading_failure(history):
            return Action.C
        else:
            risk_tolerance = max(0.3, (self.r - current_round) / self.r)
            expected_cooperators = self._predict_cooperators_next_round(history)
            if expected_cooperators >= self.m - 1:
                return Action.D
            else:
                return Action.C

    def _detect_stable_cooperator_pattern(self, history: PlayerHistory) -> bool:
        """Detect if there are consistent cooperators we can exploit."""
        if history.round_number < 2:
            return False
        stable_cooperators = 0
        lookback = min(3, history.round_number)
        for player in range(self.n - 1):
            recent_cooperations = sum((history.opponent_actions[i, player] for i in range(history.round_number - lookback, history.round_number)))
            if recent_cooperations >= lookback * 0.7:
                stable_cooperators += 1
        return stable_cooperators >= 2

    def _detect_cascading_failure(self, history: PlayerHistory) -> bool:
        """Detect if cooperation rates are dangerously low for multiple rounds."""
        if history.round_number < 2:
            return False
        recent_rounds = min(2, history.round_number)
        low_cooperation_rounds = 0
        for i in range(history.round_number - recent_rounds, history.round_number):
            cooperators = sum(history.opponent_actions[i])
            cooperation_rate = cooperators / (self.n - 1)
            if cooperation_rate < 0.4:
                low_cooperation_rounds += 1
        return low_cooperation_rounds >= 2

    def _predict_cooperators_next_round(self, history: PlayerHistory) -> float:
        """Predict number of cooperators in next round based on recent trends."""
        if history.round_number == 0:
            return (self.n - 1) * 0.5
        lookback = min(3, history.round_number)
        recent_avg = sum((sum(history.opponent_actions[i]) for i in range(history.round_number - lookback, history.round_number))) / lookback
        return max(0, recent_avg * 0.9)

class Strategy_AGGRESSIVE_16(BaseStrategy):
    """
    Opportunistic Exploiter: An aggressive strategy that maximizes personal payoffs by exploiting 
    cooperative players while minimizing personal risk. Defects early to gather information, 
    strategically assesses cooperation patterns in the penultimate round, and always defects 
    in the final round for maximum exploitation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        m = self.game_description.m
        if current_round <= total_rounds - 2:
            return Action.D
        elif current_round == total_rounds - 1:
            cooperation_rates = []
            n_opponents = self.game_description.n_players - 1
            for opponent_idx in range(n_opponents):
                opponent_actions = history.opponent_actions[:, opponent_idx]
                cooperation_rate = float(np.sum(opponent_actions)) / len(opponent_actions)
                cooperation_rates.append(cooperation_rate)
            reliable_cooperators = sum((1 for rate in cooperation_rates if rate > 0.7))
            conditional_cooperators = sum((1 for rate in cooperation_rates if 0.3 <= rate <= 0.7))
            if reliable_cooperators >= m:
                return Action.D
            elif reliable_cooperators + conditional_cooperators >= m:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_17(BaseStrategy):
    """
    Predatory Opportunist: An aggressive strategy that exploits cooperative players while minimizing
    own cooperation. Uses deceptive opening, exploitative core phase with brinkmanship tactics,
    and ruthless endgame extraction.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        last_round_idx = history.round_number - 1
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        my_last_action = history.my_actions[last_round_idx]
        cooperation_count_last_round = opponent_cooperators + (1 if my_last_action else 0)
        my_cooperations = sum(history.my_actions)
        my_cooperation_rate = my_cooperations / history.round_number
        if current_round == r:
            return Action.D
        if current_round == r - 1:
            if cooperation_count_last_round >= m:
                return Action.D
            elif cooperation_count_last_round == m - 1:
                recent_defections = 0
                if history.round_number >= 1 and (not history.my_actions[-1]):
                    recent_defections += 1
                if history.round_number >= 2 and (not history.my_actions[-2]):
                    recent_defections += 1
                if recent_defections >= 2:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.C
        if cooperation_count_last_round >= m + 2:
            return Action.D
        elif cooperation_count_last_round == m + 1:
            if my_cooperation_rate < 0.3:
                return Action.D
            else:
                return Action.C
        elif cooperation_count_last_round == m:
            if my_last_action:
                return Action.D
            else:
                reliable_cooperators = 0
                rounds_to_check = min(3, history.round_number)
                for player_idx in range(n - 1):
                    cooperated_all = True
                    for round_back in range(rounds_to_check):
                        round_idx = history.round_number - 1 - round_back
                        if not history.opponent_actions[round_idx, player_idx]:
                            cooperated_all = False
                            break
                    if cooperated_all:
                        reliable_cooperators += 1
                if reliable_cooperators >= m:
                    return Action.D
                else:
                    return Action.C
        elif cooperation_count_last_round == m - 1:
            if current_round <= r // 2:
                return Action.C
            else:
                consecutive_low = 0
                for round_back in range(min(history.round_number, 5)):
                    round_idx = history.round_number - 1 - round_back
                    round_cooperators = sum(history.opponent_actions[round_idx]) + (1 if history.my_actions[round_idx] else 0)
                    if round_cooperators < m:
                        consecutive_low += 1
                    else:
                        break
                if consecutive_low >= 2:
                    return Action.C
                else:
                    return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_18(BaseStrategy):
    """
    Aggressive Exploitation Maximizer - Maximizes personal payoffs by exploiting cooperative players
    while minimizing personal risk. Defaults to defection and only cooperates when absolutely
    necessary to secure the collective threshold.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.m = game_description.m
        self.k = game_description.k
        self.total_rounds = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.total_rounds:
            return Action.D
        coop_rates = self._calculate_cooperation_rates(history)
        expected_cooperators = self._estimate_cooperators_this_round(history, coop_rates, current_round)
        if expected_cooperators >= self.m:
            return Action.D
        if expected_cooperators >= self.m - 1:
            if self._is_likely_decisive(expected_cooperators, current_round):
                return Action.C
            else:
                return Action.D
        if current_round > self.total_rounds * 0.8:
            if expected_cooperators >= self.m - 2:
                return Action.C
        return Action.D

    def _calculate_cooperation_rates(self, history):
        """Calculate cooperation rate for each opponent"""
        rounds_played = history.round_number
        coop_rates = []
        for player_idx in range(self.n - 1):
            cooperations = sum(history.opponent_actions[:rounds_played, player_idx])
            rate = cooperations / rounds_played if rounds_played > 0 else 0
            coop_rates.append(rate)
        return coop_rates

    def _estimate_cooperators_this_round(self, history, coop_rates, current_round):
        """Estimate how many opponents will cooperate this round"""
        rounds_played = history.round_number
        expected_cooperators = 0
        for i, base_rate in enumerate(coop_rates):
            recent_start = max(0, rounds_played - 3)
            if rounds_played > recent_start:
                recent_cooperations = sum(history.opponent_actions[recent_start:rounds_played, i])
                recent_rate = recent_cooperations / (rounds_played - recent_start)
                adjusted_rate = 0.3 * base_rate + 0.7 * recent_rate
            else:
                adjusted_rate = base_rate
            if rounds_played >= 2:
                early_cooperations = sum(history.opponent_actions[:rounds_played // 2, i])
                late_cooperations = sum(history.opponent_actions[rounds_played // 2:rounds_played, i])
                early_rounds = rounds_played // 2
                late_rounds = rounds_played - early_rounds
                if early_rounds > 0 and late_rounds > 0:
                    early_rate = early_cooperations / early_rounds
                    late_rate = late_cooperations / late_rounds
                    trend = late_rate - early_rate
                    adjusted_rate = max(0, min(1, adjusted_rate + 0.2 * trend))
            if current_round > self.total_rounds * 0.8:
                adjusted_rate *= 1.1
            expected_cooperators += adjusted_rate
        return expected_cooperators

    def _is_likely_decisive(self, expected_cooperators, current_round):
        """Determine if cooperation is likely to be decisive"""
        if expected_cooperators >= self.m - 1.2 and expected_cooperators <= self.m - 0.8:
            if 0.3 * self.total_rounds <= current_round <= 0.8 * self.total_rounds:
                return True
            elif current_round <= 0.3 * self.total_rounds:
                return expected_cooperators >= self.m - 1.1
        return False

class Strategy_AGGRESSIVE_19(BaseStrategy):
    """
    Aggressive Threshold Exploiter Strategy: Maximizes personal payoffs by exploiting the threshold structure,
    defaulting to defection and only cooperating when pivotal to reaching the threshold.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        if current_round == r:
            return Action.D
        last_round_idx = history.round_number - 1
        cooperators_last_round = int(sum(history.opponent_actions[last_round_idx]))
        if history.my_actions[last_round_idx]:
            cooperators_last_round += 1
        threshold_likely_met = cooperators_last_round >= m
        if threshold_likely_met:
            return Action.D
        else:
            total_rounds_played = history.round_number
            total_cooperations = 0
            total_possible = 0
            for round_idx in range(total_rounds_played):
                if history.my_actions[round_idx]:
                    total_cooperations += 1
                total_cooperations += int(sum(history.opponent_actions[round_idx]))
                total_possible += n
            historical_cooperation_rate = total_cooperations / total_possible if total_possible > 0 else 0
            if historical_cooperation_rate > m / n + 0.1:
                return Action.D
            else:
                estimated_other_cooperators = (n - 1) * historical_cooperation_rate
                if estimated_other_cooperators >= m - 1:
                    return Action.C
                else:
                    return Action.D

class Strategy_AGGRESSIVE_20(BaseStrategy):
    """
    Opportunistic Exploiter: An aggressive strategy that maximizes individual payoff 
    by exploiting cooperative opponents while minimizing personal risk. Cooperates 
    only when absolutely necessary to trigger collective reward thresholds.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self.phase1_end = max(1, self.r // 3)
        self.phase2_end = max(2, 2 * self.r // 3)
        self.opponent_cooperation_rates = [0.0] * (self.n - 1)
        self.opponent_types = ['unknown'] * (self.n - 1)
        self.punish_opponents = [False] * (self.n - 1)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        self._update_opponent_tracking(history)
        if current_round <= self.phase1_end:
            return Action.D
        if current_round == self.r:
            return Action.D
        if history.round_number > 0:
            last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
            if history.my_actions[history.round_number - 1]:
                total_cooperators = last_round_cooperators + 1
            else:
                total_cooperators = last_round_cooperators
        else:
            last_round_cooperators = 0
            total_cooperators = 0
        if current_round <= self.phase2_end:
            return self._phase2_decision(history, last_round_cooperators, current_round)
        return self._phase3_decision(history, last_round_cooperators, current_round)

    def _update_opponent_tracking(self, history: PlayerHistory):
        """Update opponent cooperation rates and classifications"""
        if history.round_number == 0:
            return
        for i in range(self.n - 1):
            cooperations = sum(history.opponent_actions[:, i])
            self.opponent_cooperation_rates[i] = cooperations / history.round_number
            coop_rate = self.opponent_cooperation_rates[i]
            if coop_rate > 0.6:
                self.opponent_types[i] = 'sucker'
            elif coop_rate < 0.2:
                self.opponent_types[i] = 'defector'
            else:
                self.opponent_types[i] = 'tft'
            if history.round_number >= 2:
                if history.opponent_actions[history.round_number - 2, i] and (not history.opponent_actions[history.round_number - 1, i]):
                    self.punish_opponents[i] = True

    def _phase2_decision(self, history: PlayerHistory, last_round_cooperators: int, current_round: int) -> Action:
        """Phase 2: Strategic monitoring with conditional cooperation"""
        if last_round_cooperators == self.m - 1:
            rounds_remaining = self.r - current_round + 1
            if rounds_remaining > 3:
                return Action.C
        return Action.D

    def _phase3_decision(self, history: PlayerHistory, last_round_cooperators: int, current_round: int) -> Action:
        """Phase 3: Endgame exploitation with minimum necessary cooperation"""
        rounds_remaining = self.r - current_round + 1
        if rounds_remaining == 2:
            if last_round_cooperators == self.m - 1:
                return Action.C
            return Action.D
        if last_round_cooperators == self.m - 1:
            cooperation_cost = 1
            expected_benefit = self.k * min(rounds_remaining, 3)
            if expected_benefit > cooperation_cost:
                return Action.C
        if self._should_trigger_threshold(history, last_round_cooperators, rounds_remaining):
            return Action.C
        return Action.D

    def _should_trigger_threshold(self, history: PlayerHistory, cooperators: int, rounds_remaining: int) -> bool:
        """Determine if it's beneficial to trigger the threshold"""
        if rounds_remaining < 2:
            return False
        if cooperators >= self.m:
            return False
        if cooperators != self.m - 1:
            return False
        future_benefit = self.k * rounds_remaining
        cooperation_cost = rounds_remaining
        return future_benefit > cooperation_cost

    def _count_sucker_opponents(self) -> int:
        """Count opponents classified as 'suckers' (high cooperators)"""
        return sum((1 for opp_type in self.opponent_types if opp_type == 'sucker'))

class Strategy_AGGRESSIVE_21(BaseStrategy):
    """
    Predatory Threshold Exploitation: An aggressive strategy that minimizes personal contributions
    while maximizing rewards from others' cooperation through strategic free-riding and brinkmanship.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        exploration_end = max(1, int(0.2 * r))
        exploitation_end = max(exploration_end + 1, int(0.8 * r))
        if history.round_number > 0:
            last_round_cooperators = int(sum(history.opponent_actions[history.round_number - 1]))
            if history.my_actions[history.round_number - 1]:
                last_round_cooperators += 1
        else:
            last_round_cooperators = 0
        if current_round <= exploration_end:
            if current_round == 1:
                return Action.D
            elif last_round_cooperators >= m:
                return Action.D
            else:
                return Action.D
        elif current_round > exploitation_end:
            if current_round == r:
                return Action.D
            else:
                rounds_remaining = r - current_round
                if last_round_cooperators >= m + rounds_remaining:
                    return Action.D
                elif last_round_cooperators >= m:
                    return Action.D
                else:
                    return Action.D
        else:
            cooperators_trend = 'stable'
            if history.round_number >= 3:
                recent_cooperators = []
                for i in range(max(0, history.round_number - 3), history.round_number):
                    round_cooperators = int(sum(history.opponent_actions[i]))
                    if history.my_actions[i]:
                        round_cooperators += 1
                    recent_cooperators.append(round_cooperators)
                if len(recent_cooperators) >= 2:
                    if recent_cooperators[-1] < recent_cooperators[-2]:
                        cooperators_trend = 'declining'
                    elif recent_cooperators[-1] > recent_cooperators[-2]:
                        cooperators_trend = 'increasing'
            if last_round_cooperators >= m + 1:
                return Action.D
            elif last_round_cooperators == m:
                return Action.D
            elif last_round_cooperators == m - 1:
                if cooperators_trend == 'declining':
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.D

class Strategy_AGGRESSIVE_22(BaseStrategy):
    """
    Aggressive "Exploit-First Punisher" strategy that maximizes individual payoffs by 
    exploiting cooperative opponents while only cooperating when absolutely necessary 
    for threshold achievement.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.m = game_description.m
        self.k = game_description.k
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        predicted_cooperators = self._predict_cooperation(history)
        if predicted_cooperators >= self.m:
            return Action.D
        if predicted_cooperators == self.m - 1:
            rounds_remaining = self.r - current_round
            if rounds_remaining > 1:
                return Action.C
            else:
                return Action.D
        return Action.D

    def _predict_cooperation(self, history: PlayerHistory) -> int:
        """Predict number of opponents who will cooperate this round."""
        if history.round_number == 0:
            return max(1, self.m // 2)
        recent_rounds = min(3, history.round_number)
        total_recent_cooperation = 0
        for i in range(recent_rounds):
            round_idx = history.round_number - 1 - i
            round_cooperators = sum(history.opponent_actions[round_idx])
            weight = 1.0 / (i + 1)
            total_recent_cooperation += round_cooperators * weight
        total_weight = sum((1.0 / (i + 1) for i in range(recent_rounds)))
        avg_cooperation = total_recent_cooperation / total_weight
        predicted = int(avg_cooperation * 0.9)
        if history.round_number >= 2:
            reliable_count = 0
            for player in range(self.n - 1):
                cooperation_rate = sum(history.opponent_actions[:, player]) / history.round_number
                if cooperation_rate >= 0.7:
                    reliable_count += 1
            predicted = max(predicted, reliable_count)
        return max(0, min(self.n - 1, predicted))

class Strategy_AGGRESSIVE_23(BaseStrategy):
    """
    Opportunistic Exploiter: An aggressive strategy that maximizes personal payoffs 
    by exploiting cooperative opponents while minimizing personal risk. Defects as 
    much as possible while still benefiting from others reaching the cooperation threshold.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round <= 2:
            return Action.D
        if current_round >= self.r - 1:
            return Action.D
        likely_cooperators = 0
        for opponent_idx in range(self.n - 1):
            cooperation_rate = sum(history.opponent_actions[:, opponent_idx]) / history.round_number
            if cooperation_rate >= 0.8:
                likely_cooperators += 1
            elif cooperation_rate >= 0.4:
                if history.opponent_actions[history.round_number - 1, opponent_idx]:
                    likely_cooperators += 1
        if likely_cooperators >= self.m:
            return Action.D
        elif likely_cooperators == self.m - 1:
            if random.random() < 0.3:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_24(BaseStrategy):
    """
    Aggressive "Dominant Exploiter" strategy that ruthlessly free-rides on others' cooperation
    while only cooperating when absolutely critical to prevent total collective failure.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        if current_round == r:
            return Action.D
        last_round_idx = history.round_number - 1
        cooperative_count = int(sum(history.opponent_actions[last_round_idx]))
        if history.my_actions[last_round_idx]:
            cooperative_count += 1
        projected_cooperators = self._estimate_next_round_cooperators(history)
        if projected_cooperators >= m + 2:
            return Action.D
        elif projected_cooperators >= m:
            return Action.D
        elif projected_cooperators == m - 1:
            return Action.C
        else:
            return Action.D

    def _estimate_next_round_cooperators(self, history: PlayerHistory) -> int:
        """Estimate how many players will cooperate next round using pessimistic model."""
        n = self.game_description.n_players
        recent_cooperators = 0
        rounds_to_check = min(2, history.round_number)
        for player_idx in range(n - 1):
            cooperation_count = 0
            for round_back in range(rounds_to_check):
                round_idx = history.round_number - 1 - round_back
                if history.opponent_actions[round_idx, player_idx]:
                    cooperation_count += 1
            if cooperation_count >= rounds_to_check // 2 + 1:
                recent_cooperators += 1
        estimated = int(recent_cooperators * 0.8)
        return estimated

class Strategy_AGGRESSIVE_25(BaseStrategy):
    """
    Exploitative Threshold Hunter: An aggressive strategy that maximizes personal gain 
    by free-riding on cooperative players while only contributing when necessary to 
    secure collective benefits with high confidence.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self.opponent_types = ['unknown'] * (self.n - 1)
        self.betrayal_count = [0] * (self.n - 1)
        self.punishment_rounds = [0] * (self.n - 1)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == 2:
            round1_cooperators = sum(history.opponent_actions[0])
            if round1_cooperators == self.m - 1:
                return Action.C
            else:
                return Action.D
        self._update_opponent_types(history)
        if current_round >= self.r - 1:
            if current_round == self.r:
                return Action.D
            else:
                likely_cooperators = self._estimate_cooperators(history)
                if likely_cooperators == self.m - 1:
                    return Action.C
                return Action.D
        if self._check_consecutive_failures(history) >= 3:
            return Action.D
        likely_cooperators = self._estimate_cooperators(history)
        if likely_cooperators >= self.m:
            return Action.D
        elif likely_cooperators == self.m - 1:
            confidence = self._calculate_cooperation_confidence(history)
            if confidence > 0.7:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _update_opponent_types(self, history):
        """Update classification of each opponent based on their behavior."""
        n_rounds = history.round_number
        for i in range(self.n - 1):
            cooperations = sum(history.opponent_actions[:n_rounds, i])
            coop_rate = cooperations / n_rounds
            if coop_rate >= 0.75:
                self.opponent_types[i] = 'consistent_cooperator'
            elif coop_rate <= 0.25:
                self.opponent_types[i] = 'aggressive_defector'
            elif self._is_conditional_cooperator(history, i):
                self.opponent_types[i] = 'conditional_cooperator'
            else:
                self.opponent_types[i] = 'unpredictable'

    def _is_conditional_cooperator(self, history, opponent_idx):
        """Check if opponent appears to be a conditional cooperator."""
        if history.round_number < 3:
            return False
        correlations = 0
        for round_idx in range(1, history.round_number):
            prev_round_cooperators = sum(history.opponent_actions[round_idx - 1])
            prev_round_cooperators += int(history.my_actions[round_idx - 1])
            prev_threshold_met = prev_round_cooperators >= self.m
            current_cooperated = history.opponent_actions[round_idx, opponent_idx]
            if prev_threshold_met and (not current_cooperated) or (not prev_threshold_met and current_cooperated):
                correlations += 1
        return correlations >= (history.round_number - 1) * 0.6

    def _estimate_cooperators(self, history):
        """Estimate how many opponents will cooperate in the next round."""
        expected_cooperators = 0.0
        for i in range(self.n - 1):
            if self.opponent_types[i] == 'consistent_cooperator':
                expected_cooperators += 0.9
            elif self.opponent_types[i] == 'conditional_cooperator':
                if history.round_number > 0:
                    last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
                    last_round_cooperators += int(history.my_actions[history.round_number - 1])
                    if last_round_cooperators >= self.m:
                        expected_cooperators += 0.3
                    else:
                        expected_cooperators += 0.7
                else:
                    expected_cooperators += 0.5
            elif self.opponent_types[i] == 'aggressive_defector':
                expected_cooperators += 0.1
            else:
                expected_cooperators += 0.4
        return int(round(expected_cooperators))

    def _calculate_cooperation_confidence(self, history):
        """Calculate confidence that others will cooperate as expected."""
        if history.round_number < 2:
            return 0.5
        recent_rounds = min(3, history.round_number)
        accurate_predictions = 0
        for i in range(recent_rounds):
            round_idx = history.round_number - 1 - i
            actual_cooperators = sum(history.opponent_actions[round_idx])
            temp_history_round = history.round_number - 1 - i
            if temp_history_round > 0:
                consistent_cooperators = sum((1 for j in range(self.n - 1) if sum(history.opponent_actions[:temp_history_round, j]) / temp_history_round >= 0.6))
                predicted = consistent_cooperators
                if abs(predicted - actual_cooperators) <= 1:
                    accurate_predictions += 1
        return accurate_predictions / recent_rounds if recent_rounds > 0 else 0.5

    def _check_consecutive_failures(self, history):
        """Check how many consecutive rounds the threshold has failed."""
        if history.round_number < 1:
            return 0
        consecutive_failures = 0
        for i in range(history.round_number - 1, -1, -1):
            total_cooperators = sum(history.opponent_actions[i]) + int(history.my_actions[i])
            if total_cooperators < self.m:
                consecutive_failures += 1
            else:
                break
        return consecutive_failures

class Strategy_AGGRESSIVE_26(BaseStrategy):
    """
    Exploitation Maximizer: An aggressive strategy that defects in round 1 and final round,
    while strategically exploiting cooperative opponents by free-riding when the threshold
    is likely to be met, and occasionally cooperating to manipulate the threshold for future exploitation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.n_rounds:
            return Action.D
        return self._exploitation_decision(history)

    def _exploitation_decision(self, history: PlayerHistory) -> Action:
        current_round = history.round_number + 1
        rounds_remaining = self.n_rounds - current_round
        if current_round > 3:
            recent_rounds = min(3, history.round_number)
            total_cooperators = 0
            for round_idx in range(history.round_number - recent_rounds, history.round_number):
                total_cooperators += sum(history.opponent_actions[round_idx])
            if total_cooperators == 0:
                return Action.D
        predicted_cooperators = self._predict_next_round_cooperators(history)
        if predicted_cooperators >= self.m:
            return Action.D
        if predicted_cooperators == self.m - 1 and rounds_remaining > 3:
            return Action.C
        if rounds_remaining > 5:
            threshold_missed = 0
            check_rounds = min(2, history.round_number)
            for round_idx in range(history.round_number - check_rounds, history.round_number):
                cooperators = sum(history.opponent_actions[round_idx])
                if history.my_actions[round_idx]:
                    cooperators += 1
                if cooperators < self.m:
                    threshold_missed += 1
            if threshold_missed == check_rounds and random.random() < 0.3:
                return Action.C
        return Action.D

    def _predict_next_round_cooperators(self, history: PlayerHistory) -> float:
        predicted_count = 0.0
        for player_idx in range(self.n_players - 1):
            cooperation_rate = self._get_cooperation_rate(history, player_idx)
            recent_trend = self._analyze_recent_trend(history, player_idx)
            if cooperation_rate > 0.6 and recent_trend != 'declining':
                predicted_count += 1.0
            elif cooperation_rate > 0.3:
                if self._was_threshold_met_last_round(history):
                    predicted_count += 0.7
                else:
                    predicted_count += cooperation_rate * 0.5
            else:
                predicted_count += cooperation_rate * 0.3
        return predicted_count

    def _get_cooperation_rate(self, history: PlayerHistory, player_idx: int) -> float:
        if history.round_number == 0:
            return 0.5
        cooperations = sum(history.opponent_actions[:history.round_number, player_idx])
        return cooperations / history.round_number

    def _analyze_recent_trend(self, history: PlayerHistory, player_idx: int) -> str:
        if history.round_number < 3:
            return 'neutral'
        recent_rounds = min(3, history.round_number)
        recent_actions = history.opponent_actions[history.round_number - recent_rounds:history.round_number, player_idx]
        cooperations_recent = sum(recent_actions)
        if cooperations_recent == 0:
            return 'declining'
        elif cooperations_recent == recent_rounds:
            return 'increasing'
        else:
            if recent_rounds >= 2:
                first_half = sum(recent_actions[:recent_rounds // 2])
                second_half = sum(recent_actions[recent_rounds // 2:])
                if second_half > first_half:
                    return 'increasing'
                elif second_half < first_half:
                    return 'declining'
            return 'neutral'

    def _was_threshold_met_last_round(self, history: PlayerHistory) -> bool:
        if history.round_number == 0:
            return False
        last_round_idx = history.round_number - 1
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        my_cooperation = 1 if history.my_actions[last_round_idx] else 0
        total_cooperators = opponent_cooperators + my_cooperation
        return total_cooperators >= self.m

class Strategy_AGGRESSIVE_27(BaseStrategy):
    """
    Predatory Free-Rider: An aggressive strategy that exploits cooperative players while
    contributing minimally to maintain collective benefits only when strategically necessary.
    
    Operates in three phases:
    1. Initial exploitation (first 3 rounds) - always defect to establish dominance
    2. Adaptive predation (middle rounds) - free-ride when possible, cooperate only when pivotal
    3. Endgame exploitation (last 2 rounds) - maximize extraction, always defect in final round
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self.threshold_failed_count = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if history.round_number > 0:
            last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
            if int(history.my_actions[history.round_number - 1]) == 1:
                last_round_cooperators += 1
            if last_round_cooperators < self.m:
                self.threshold_failed_count += 1
        if self.threshold_failed_count >= 2:
            return Action.D
        if current_round <= min(3, self.r - 2):
            return Action.D
        cooperators_last_round = sum(history.opponent_actions[history.round_number - 1])
        if int(history.my_actions[history.round_number - 1]) == 1:
            cooperators_last_round += 1
        total_cooperators = 0
        for round_idx in range(history.round_number):
            round_cooperators = sum(history.opponent_actions[round_idx])
            if int(history.my_actions[round_idx]) == 1:
                round_cooperators += 1
            total_cooperators += round_cooperators
        avg_cooperation_rate = total_cooperators / (history.round_number * self.n)
        if current_round >= self.r - 1:
            if current_round == self.r:
                return Action.D
            my_total_payoff = sum(history.my_payoffs)
            if cooperators_last_round >= self.m and my_total_payoff < self.n * self.k:
                return Action.D
            elif cooperators_last_round == self.m - 1:
                return Action.C
            else:
                return Action.D
        if cooperators_last_round >= self.m:
            return Action.D
        elif cooperators_last_round == self.m - 1:
            if avg_cooperation_rate > 0.4:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_28(BaseStrategy):
    """
    Ruthless Exploiter: An aggressive strategy that maximizes personal payoffs by exploiting 
    cooperative players while minimizing personal risk. Defects aggressively in early and 
    late phases, only cooperating tactically in the middle phase when absolutely necessary 
    to maintain the cooperation threshold.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        m = self.game_description.m
        k = self.game_description.k
        total_rounds = self.game_description.n_rounds
        if history is None:
            return Action.D
        round_num = history.round_number + 1
        if round_num == total_rounds:
            return Action.D
        phase1_end = total_rounds // 3
        phase2_end = 2 * total_rounds // 3
        prev_round_idx = history.round_number - 1
        my_prev_action = history.my_actions[prev_round_idx]
        opponent_prev_actions = history.opponent_actions[prev_round_idx]
        prev_coop_count = int(my_prev_action) + int(sum(opponent_prev_actions))
        if round_num <= phase1_end:
            return Action.D
        elif round_num > phase2_end:
            if round_num == total_rounds - 1 and prev_coop_count <= m - 2:
                return Action.C
            else:
                return Action.D
        elif prev_coop_count == m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_29(BaseStrategy):
    """
    Exploit-First Dominance: Aggressively exploit others by defecting early, 
    then strategically cooperate only when pivotal in later rounds to maximize individual payoff.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n = self.game_description.n_players
        m = self.game_description.m
        total_rounds = self.game_description.n_rounds
        current_round = history.round_number + 1
        if current_round <= 0.6 * total_rounds:
            return Action.D
        if current_round == total_rounds:
            return Action.D
        expected_cooperators = self._predict_others_cooperation(history, n, total_rounds)
        if expected_cooperators == m - 1:
            return Action.C
        elif expected_cooperators >= m:
            return Action.D
        else:
            return Action.D

    def _predict_others_cooperation(self, history: PlayerHistory, n: int, total_rounds: int) -> int:
        """Predict how many opponents will cooperate in the next round."""
        current_round = history.round_number + 1
        rounds_to_check = min(3, history.round_number)
        if rounds_to_check == 0:
            recent_cooperation_rate = 0.0
        else:
            recent_rounds_start = max(0, history.round_number - rounds_to_check)
            recent_cooperations = 0
            for r in range(recent_rounds_start, history.round_number):
                recent_cooperations += sum(history.opponent_actions[r])
            recent_cooperation_rate = recent_cooperations / (rounds_to_check * (n - 1))
        if history.round_number == 0:
            overall_cooperation_rate = 0.0
        else:
            total_cooperations = 0
            for r in range(history.round_number):
                total_cooperations += sum(history.opponent_actions[r])
            overall_cooperation_rate = total_cooperations / (history.round_number * (n - 1))
        desperation_factor = current_round / total_rounds
        expected_rate = (recent_cooperation_rate * 0.7 + overall_cooperation_rate * 0.3) * (1 + desperation_factor)
        expected_cooperators = int(expected_rate * (n - 1))
        return max(0, min(n - 1, expected_cooperators))

class Strategy_AGGRESSIVE_30(BaseStrategy):
    """
    Exploit-First Dominance: Aggressive strategy that defaults to defection, 
    exploiting cooperative players while only cooperating when absolutely 
    necessary to prevent collective failure in late rounds.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        remaining_rounds = r - current_round
        if remaining_rounds == 0:
            return Action.D
        if remaining_rounds > 2:
            return Action.D
        predicted_cooperators = self._predict_cooperators(history)
        if predicted_cooperators < m - 1:
            return Action.D
        elif predicted_cooperators >= m:
            return Action.D
        elif remaining_rounds >= 1:
            return Action.C
        else:
            return Action.D

    def _predict_cooperators(self, history: PlayerHistory) -> int:
        """Predict how many opponents will cooperate this round based on their patterns."""
        if history.round_number == 0:
            return max(1, self.game_description.m // 2)
        n_opponents = self.game_description.n_players - 1
        cooperation_predictions = 0
        for opponent_idx in range(n_opponents):
            recent_rounds = min(3, history.round_number)
            recent_actions = history.opponent_actions[-recent_rounds:, opponent_idx]
            cooperation_rate = float(sum(recent_actions)) / len(recent_actions)
            if history.round_number > 0:
                last_action = history.opponent_actions[-1, opponent_idx]
                if last_action:
                    cooperation_rate = min(1.0, cooperation_rate + 0.3)
                else:
                    cooperation_rate = max(0.0, cooperation_rate - 0.2)
            if cooperation_rate > 0.5:
                cooperation_predictions += 1
        return cooperation_predictions

class Strategy_AGGRESSIVE_31(BaseStrategy):
    """
    Aggressive "Exploitative Threshold Hunter" strategy that maximizes personal payoffs
    by free-riding when possible and minimizing cooperation costs. Always defects in
    intelligence gathering phase, exploitation phase, and endgame.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round <= 2:
            return Action.D
        if current_round > self.n_rounds - 2:
            return Action.D
        last_round_idx = history.round_number - 1
        cooperators_last_round = int(sum(history.opponent_actions[last_round_idx]))
        predicted_cooperators = self._estimate_cooperators(history)
        return Action.D

    def _estimate_cooperators(self, history: PlayerHistory) -> int:
        """Estimate number of cooperators this round based on opponent patterns."""
        n_rounds_played = history.round_number
        predicted_cooperators = 0
        for opponent_idx in range(self.n_players - 1):
            cooperations = sum(history.opponent_actions[:n_rounds_played, opponent_idx])
            cooperation_rate = cooperations / n_rounds_played
            if cooperation_rate > 0.6:
                predicted_cooperators += 1
            elif cooperation_rate > 0.3:
                recent_rounds = min(3, n_rounds_played)
                recent_cooperations = sum(history.opponent_actions[-recent_rounds:, opponent_idx])
                if recent_cooperations >= recent_rounds * 0.5:
                    predicted_cooperators += 1
        return predicted_cooperators

class Strategy_AGGRESSIVE_32(BaseStrategy):
    """
    Exploitation Maximizer: An aggressive strategy that maximizes personal payoffs by 
    exploiting cooperative players while minimizing personal risk. Uses three phases:
    early aggression for information gathering, mid-game conditional cooperation with
    exploitation bias, and endgame maximum exploitation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self.phase1_end = max(1, self.r // 3)
        self.phase2_end = max(2, 2 * self.r // 3)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round <= self.phase1_end:
            return Action.D
        if current_round == self.r:
            return Action.D
        last_round_idx = history.round_number - 1
        last_round_cooperators = int(sum(history.opponent_actions[last_round_idx]))
        cooperation_rate = last_round_cooperators / (self.n - 1)
        my_expected_cooperators = cooperation_rate * (self.n - 1)
        if current_round <= self.phase2_end:
            return self._phase2_decision(my_expected_cooperators, cooperation_rate)
        return self._phase3_decision(history, current_round, my_expected_cooperators)

    def _phase2_decision(self, my_expected_cooperators: float, cooperation_rate: float) -> Action:
        """Phase 2: Conditional cooperation with exploitation bias"""
        if my_expected_cooperators >= self.m:
            return Action.D
        elif abs(my_expected_cooperators - (self.m - 1)) < 0.5:
            if cooperation_rate > 0.7:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _phase3_decision(self, history: PlayerHistory, current_round: int, my_expected_cooperators: float) -> Action:
        """Phase 3: Maximum aggression with strategic cooperation"""
        cooperators_needed = self.m - my_expected_cooperators
        rounds_remaining = self.r - current_round
        if cooperators_needed <= 1 and rounds_remaining > 2:
            return Action.D
        elif cooperators_needed >= (self.n - 1) / 2:
            return Action.D
        elif self._am_i_pivotal(my_expected_cooperators):
            if self._expected_future_payoff_if_cooperate(rounds_remaining) > 1:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _am_i_pivotal(self, expected_cooperators: float) -> bool:
        """Check if I'm pivotal for reaching the threshold"""
        return abs(expected_cooperators - (self.m - 1)) < 0.5

    def _expected_future_payoff_if_cooperate(self, rounds_remaining: int) -> float:
        """Calculate expected future payoff if cooperating now"""
        success_probability = 0.8
        return self.k * rounds_remaining * success_probability

class Strategy_AGGRESSIVE_33(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Threshold Predator"
    
    Maximizes payoff by free-riding whenever possible, only cooperating when
    absolutely necessary to maintain collective benefit. Always defects in
    final rounds and uses minimal intervention during threshold crises.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        m = self.game_description.m
        current_round = history.round_number + 1
        if current_round == n_rounds:
            return Action.D
        last_round_cooperators = int(sum(history.opponent_actions[history.round_number - 1]))
        if history.my_actions[history.round_number - 1]:
            last_round_cooperators += 1
        if current_round == n_rounds - 1:
            total_cooperation = 0
            for round_idx in range(history.round_number):
                round_cooperators = int(sum(history.opponent_actions[round_idx]))
                if history.my_actions[round_idx]:
                    round_cooperators += 1
                total_cooperation += round_cooperators
            avg_cooperation = total_cooperation / history.round_number
            if avg_cooperation >= m:
                return Action.D
            elif last_round_cooperators == m - 2:
                return Action.C
            else:
                return Action.D
        elif last_round_cooperators == m - 1:
            if random.random() < 0.3:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_34(BaseStrategy):
    """
    Ruthless Exploiter - An aggressive strategy that maximizes personal payoff through 
    strategic exploitation while maintaining minimal cooperation only when absolutely necessary.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.consecutive_failures = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
        if history.my_actions[history.round_number - 1]:
            last_round_cooperators += 1
        threshold_safety = last_round_cooperators - m
        if last_round_cooperators < m:
            self.consecutive_failures += 1
        else:
            self.consecutive_failures = 0
        endgame_threshold = max(3, int(0.2 * r))
        if current_round > r - endgame_threshold:
            return Action.D
        if threshold_safety > 2:
            return Action.D
        elif threshold_safety >= 1:
            if history.my_actions[history.round_number - 1]:
                return Action.D
            else:
                return Action.D if random.random() < 0.8 else Action.C
        elif threshold_safety >= 0:
            if current_round > r * 0.7:
                return Action.D
            else:
                return Action.C if random.random() < 0.3 else Action.D
        elif self.consecutive_failures < 2:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_35(BaseStrategy):
    """
    Predatory Threshold Exploiter: An aggressive strategy that maximizes personal payoff
    by exploiting collective cooperation while minimizing personal contribution. Defaults
    to defection and only cooperates when absolutely necessary to secure collective rewards.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        if current_round == r:
            return Action.D
        last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
        my_recent_defections = 0
        for i in range(min(3, history.round_number)):
            round_idx = history.round_number - 1 - i
            if not history.my_actions[round_idx]:
                my_recent_defections += 1
            else:
                break
        if last_round_cooperators >= m - 1:
            return Action.D
        if last_round_cooperators == m - 2 and my_recent_defections >= 3 and (current_round < r):
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_36(BaseStrategy):
    """
    Predatory Threshold Hunter: An aggressive strategy that maximizes personal gain through 
    strategic parasitism. Always defects in first and final rounds, and adaptively exploits 
    cooperation patterns in between to secure collective rewards while minimizing contributions.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        m = self.game_description.m
        if current_round == n_rounds:
            return Action.D
        last_round_idx = history.round_number - 1
        cooperators_last_round = int(sum(history.opponent_actions[last_round_idx]))
        if history.my_actions[last_round_idx]:
            cooperators_last_round += 1
        gap = m - cooperators_last_round
        if cooperators_last_round >= m:
            if cooperators_last_round >= m + 2:
                return Action.D
            else:
                return Action.C
        elif gap == 1:
            if current_round < 0.7 * n_rounds:
                return Action.C
            else:
                return Action.D
        elif gap == 2:
            if cooperators_last_round > m / 2:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_37(BaseStrategy):
    """
    Aggressive "Exploit and Abandon" strategy that never cooperates.
    
    This strategy maximizes personal payoffs by exploiting cooperative players
    while minimizing personal contributions. It always defects across all rounds
    to achieve maximum free-rider benefits when others cooperate.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_38(BaseStrategy):
    """
    Aggressive Threshold Exploiter: Maximizes personal payoff by exploiting the collective risk structure.
    Defaults to defection and only cooperates when strategically forced to avoid threshold failure.
    Uses phase-based aggression that increases toward the endgame.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        rounds_remaining = self.r - current_round + 1
        window = min(3, history.round_number)
        recent_coop_sum = 0
        for i in range(max(0, history.round_number - window), history.round_number):
            recent_coop_sum += sum(history.opponent_actions[i])
        recent_cooperation_rate = recent_coop_sum / (window * (self.n - 1)) if window > 0 else 0
        expected_cooperators = self._predict_cooperators(history)
        if current_round <= self.r / 4:
            if recent_cooperation_rate >= self.m / self.n + 0.2:
                return Action.D
            else:
                return Action.D
        elif current_round <= 3 * self.r / 4:
            if expected_cooperators >= self.m + 1:
                return Action.D
            elif expected_cooperators == self.m:
                return Action.D
            elif expected_cooperators == self.m - 1:
                if random.random() < 0.3:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.C
        else:
            aggression_multiplier = rounds_remaining / (self.r / 4) if self.r > 0 else 1
            if expected_cooperators >= self.m + aggression_multiplier:
                return Action.D
            elif expected_cooperators >= self.m:
                return Action.D
            elif expected_cooperators >= self.m - 1:
                if random.random() < 0.4:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.C
        if current_round == self.r:
            if expected_cooperators >= self.m + 1:
                return Action.D
            elif expected_cooperators >= self.m:
                return Action.D
            else:
                return Action.C

    def _predict_cooperators(self, history: PlayerHistory) -> int:
        """Predict how many opponents will cooperate based on recent patterns."""
        if history.round_number == 0:
            return 0
        total_weight = 0
        weighted_cooperators = 0
        for i in range(history.round_number):
            weight = (i + 1) / history.round_number
            cooperators_in_round = sum(history.opponent_actions[i])
            weighted_cooperators += weight * cooperators_in_round
            total_weight += weight
        avg_cooperators = weighted_cooperators / total_weight if total_weight > 0 else 0
        return max(0, int(avg_cooperators - 0.2))

class Strategy_AGGRESSIVE_39(BaseStrategy):
    """
    Aggressive "Threshold Exploiter" strategy that maximizes individual payoff by 
    free-riding on others' cooperation while only cooperating when absolutely necessary.
    Always defects in first and last rounds, and exploits threshold mechanics.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        total_cooperations = 0
        total_opportunities = 0
        for round_idx in range(history.round_number):
            round_cooperators = sum(history.opponent_actions[round_idx])
            total_cooperations += round_cooperators
            total_opportunities += self.n - 1
        if total_opportunities > 0:
            avg_cooperation_rate = total_cooperations / total_opportunities
        else:
            avg_cooperation_rate = 0.0
        expected_cooperators = (self.n - 1) * avg_cooperation_rate
        if expected_cooperators >= self.m:
            return Action.D
        elif expected_cooperators >= self.m - 1:
            late_game_threshold = self.r * 0.7
            if self.k > 2 or current_round > late_game_threshold:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_40(BaseStrategy):
    """
    Exploitative Threshold Rider - An aggressive strategy that maximizes personal payoff
    by exploiting cooperative players while minimizing personal risk. Defects in early
    rounds to gather information, then adapts based on cooperation patterns to free-ride
    whenever possible.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == 2:
            return Action.D
        if current_round >= self.r - 1:
            return Action.D
        last_round_idx = history.round_number - 1
        cooperators_last_round = int(sum(history.opponent_actions[last_round_idx]))
        if history.my_actions[last_round_idx]:
            cooperators_last_round += 1
        total_cooperators = 0
        for round_idx in range(history.round_number):
            round_cooperators = int(sum(history.opponent_actions[round_idx]))
            if history.my_actions[round_idx]:
                round_cooperators += 1
            total_cooperators += round_cooperators
        avg_cooperation_rate = total_cooperators / (history.round_number * self.n)
        if cooperators_last_round >= self.m:
            return Action.D
        elif cooperators_last_round == self.m - 1:
            if avg_cooperation_rate > 0.6:
                return Action.D
            else:
                return Action.C
        elif avg_cooperation_rate > 0.5 and cooperators_last_round >= self.m - 2:
            return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_41(BaseStrategy):
    """
    Predatory Threshold Exploiter: An aggressive strategy that maximizes personal gain 
    by exploiting cooperative players while minimizing personal risk. Always defects 
    in first and last rounds, and exploits others' cooperation in between.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.safety_margin = 0.1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        if current_round == r:
            return Action.D
        others_coop_rate = self._calculate_others_average_cooperation(history)
        expected_other_cooperators = (n - 1) * others_coop_rate
        if self._detect_mass_punishment(history) and current_round <= r - 3:
            recent_failures = self._count_recent_failures(history)
            if recent_failures > 0.3 * history.round_number:
                return Action.C
        if expected_other_cooperators < m - 1 + self.safety_margin:
            return Action.D
        else:
            return Action.D

    def _calculate_others_average_cooperation(self, history: PlayerHistory) -> float:
        """Calculate average cooperation rate of other players across all rounds."""
        if history.round_number == 0:
            return 0.5
        total_cooperations = 0
        total_decisions = 0
        for round_idx in range(history.round_number):
            cooperations_this_round = sum(history.opponent_actions[round_idx])
            total_cooperations += cooperations_this_round
            total_decisions += len(history.opponent_actions[round_idx])
        if total_decisions == 0:
            return 0.5
        return total_cooperations / total_decisions

    def _detect_mass_punishment(self, history: PlayerHistory) -> bool:
        """Detect if others are coordinating punishment against defectors."""
        if history.round_number < 2:
            return False
        recent_rounds = min(2, history.round_number)
        recent_coop_rates = []
        for i in range(recent_rounds):
            round_idx = history.round_number - 1 - i
            cooperations = sum(history.opponent_actions[round_idx])
            rate = cooperations / len(history.opponent_actions[round_idx])
            recent_coop_rates.append(rate)
        if len(recent_coop_rates) >= 2:
            return recent_coop_rates[0] < recent_coop_rates[1] - 0.3
        return False

    def _count_recent_failures(self, history: PlayerHistory) -> float:
        """Count the proportion of recent rounds where threshold was not met."""
        if history.round_number == 0:
            return 0.0
        failures = 0
        for round_idx in range(history.round_number):
            cooperators = sum(history.opponent_actions[round_idx])
            if history.my_actions[round_idx]:
                cooperators += 1
            if cooperators < self.game_description.m:
                failures += 1
        return failures / history.round_number

class Strategy_AGGRESSIVE_42(BaseStrategy):
    """
    Exploitative Threshold Rider: An aggressive strategy that maximizes personal payoff 
    by free-riding on others' cooperation while only cooperating when strategically 
    necessary to be the decisive vote that pushes the group over the threshold.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        player_types = self._classify_opponents(history)
        expected_cooperators = self._estimate_cooperators(history, player_types)
        if expected_cooperators == self.m - 1:
            rounds_remaining = self.r - current_round
            if self.k > 1 and rounds_remaining > 2:
                return Action.C
            else:
                return Action.D
        if expected_cooperators >= self.m:
            return Action.D
        if expected_cooperators < self.m - 1:
            if self._should_test_cooperation(history):
                return Action.C
            return Action.D
        return Action.D

    def _classify_opponents(self, history):
        """Classify each opponent as sucker, reciprocator, or fellow aggressor."""
        player_types = []
        n_rounds = history.round_number
        for player_idx in range(self.n - 1):
            player_actions = history.opponent_actions[:n_rounds, player_idx]
            cooperation_rate = sum(player_actions) / n_rounds if n_rounds > 0 else 0
            if cooperation_rate >= 0.8:
                player_types.append('sucker')
            elif cooperation_rate <= 0.2:
                player_types.append('fellow_aggressor')
            else:
                player_types.append('reciprocator')
        return player_types

    def _estimate_cooperators(self, history, player_types):
        """Estimate how many opponents will cooperate this round."""
        expected = 0
        n_rounds = history.round_number
        if n_rounds > 0:
            total_cooperations = 0
            total_actions = 0
            for round_idx in range(n_rounds):
                total_cooperations += sum(history.opponent_actions[round_idx])
                total_actions += self.n - 1
            group_cooperation_rate = total_cooperations / total_actions if total_actions > 0 else 0
        else:
            group_cooperation_rate = 0.5
        for player_type in player_types:
            if player_type == 'sucker':
                expected += 0.9
            elif player_type == 'reciprocator':
                expected += group_cooperation_rate * 0.8
            elif player_type == 'fellow_aggressor':
                expected += 0.1
        return round(expected)

    def _should_test_cooperation(self, history):
        """Decide whether to test cooperation when threshold consistently fails."""
        n_rounds = history.round_number
        if n_rounds < 3:
            return False
        recent_failures = 0
        rounds_to_check = min(5, n_rounds)
        for round_idx in range(n_rounds - rounds_to_check, n_rounds):
            cooperators = sum(history.opponent_actions[round_idx])
            if history.my_actions[round_idx]:
                cooperators += 1
            if cooperators < self.m:
                recent_failures += 1
        if recent_failures >= rounds_to_check * 0.8:
            current_round = history.round_number + 1
            return current_round % 5 == 0
        return False

class Strategy_AGGRESSIVE_43(BaseStrategy):
    """
    Exploitation Maximizer: An aggressive strategy that maximizes personal payoffs by 
    exploiting cooperative players while minimizing personal risk. Always defects in 
    first and last rounds, and adaptively defects in middle rounds based on cooperation 
    patterns to maximize free-riding opportunities.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round >= self.r - 1:
            return Action.D
        total_actions = history.round_number * (self.n - 1)
        total_cooperations = int(np.sum(history.opponent_actions))
        cooperation_rate = total_cooperations / total_actions if total_actions > 0 else 0
        if cooperation_rate >= (self.m + 2) / self.n:
            return Action.D
        elif cooperation_rate >= (self.m - 0.5) / self.n:
            expected_cooperators = cooperation_rate * (self.n - 1)
            if expected_cooperators >= self.m:
                return Action.D
            else:
                return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_44(BaseStrategy):
    """
    AGGRESSIVE STRATEGY: "EXPLOITATION MAXIMIZER"
    
    Maximizes personal gain by exploiting cooperative players while minimizing personal risk.
    Always aims to be among the defectors when exactly m players cooperate to get maximum
    payoff (1 + k). Uses opponent classification and dynamic defection calculation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        reliable_cooperators = 0
        conditional_cooperators = 0
        total_conditional_coop_rate = 0.0
        for opponent in range(self.n - 1):
            opponent_history = history.opponent_actions[:, opponent]
            coop_rate = np.mean(opponent_history)
            if coop_rate > 0.7:
                reliable_cooperators += 1
            elif coop_rate >= 0.3:
                conditional_cooperators += 1
                total_conditional_coop_rate += coop_rate
        avg_conditional_rate = total_conditional_coop_rate / conditional_cooperators if conditional_cooperators > 0 else 0
        expected_cooperators = reliable_cooperators + conditional_cooperators * avg_conditional_rate
        last_round_cooperators = 0
        if history.round_number > 0:
            last_round_cooperators = int(np.sum(history.opponent_actions[history.round_number - 1]))
            if history.my_actions[history.round_number - 1]:
                last_round_cooperators += 1
        if expected_cooperators >= self.m + 1:
            return Action.D
        if expected_cooperators >= self.m:
            if last_round_cooperators == self.m:
                return Action.D
            else:
                return Action.D
        if expected_cooperators >= self.m - 1:
            consecutive_threshold_rounds = 0
            for i in range(min(3, history.round_number)):
                round_idx = history.round_number - 1 - i
                if round_idx < 0:
                    break
                round_cooperators = int(np.sum(history.opponent_actions[round_idx]))
                if history.my_actions[round_idx]:
                    round_cooperators += 1
                if round_cooperators >= self.m - 1:
                    consecutive_threshold_rounds += 1
                else:
                    break
            if consecutive_threshold_rounds >= 2:
                return Action.C
            else:
                return Action.D
        if current_round == self.r - 1:
            if expected_cooperators < self.m - 1:
                return Action.C
            else:
                return Action.D
        return Action.C

class Strategy_AGGRESSIVE_45(BaseStrategy):
    """
    Aggressive "Exploit and Abandon" strategy that maximizes personal payoffs by 
    defecting while others cooperate, with minimal cooperation only in round r-1 
    under very specific conditions, and always defecting in the final round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n = self.game_description.n_players
        m = self.game_description.m
        k = self.game_description.k
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        if current_round == r:
            return Action.D
        if current_round <= r - 2:
            return Action.D
        if current_round == r - 1:
            if history.round_number > 0:
                total_cooperators_per_round = []
                for round_idx in range(history.round_number):
                    my_coop = 1 if history.my_actions[round_idx] else 0
                    opponent_coop = int(sum(history.opponent_actions[round_idx]))
                    total_cooperators_per_round.append(my_coop + opponent_coop)
                successful_rounds = sum((1 for coop_count in total_cooperators_per_round if coop_count >= m))
                success_rate = successful_rounds / len(total_cooperators_per_round)
                avg_cooperators = sum(total_cooperators_per_round) / len(total_cooperators_per_round)
                if success_rate >= 0.7 and avg_cooperators >= m + 1 and (k > 1.5):
                    return Action.C
        return Action.D

class Strategy_AGGRESSIVE_46(BaseStrategy):
    """
    Predatory Opportunist: An aggressive strategy that exploits cooperative players
    while minimizing personal risk. Maximizes free-riding opportunities and only
    cooperates when absolutely necessary to secure group rewards.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        k = self.game_description.k
        current_round = history.round_number + 1
        cooperation_counts = []
        for round_idx in range(history.round_number):
            count = sum(history.opponent_actions[round_idx]) + (1 if history.my_actions[round_idx] else 0)
            cooperation_counts.append(count)
        reliable_cooperators = 0
        if history.round_number >= 2:
            for player_idx in range(n - 1):
                cooperation_rate = sum(history.opponent_actions[:, player_idx]) / history.round_number
                if cooperation_rate > 0.7:
                    reliable_cooperators += 1
        last_round_cooperators = 0
        if history.round_number > 0:
            last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
            if history.my_actions[history.round_number - 1]:
                last_round_cooperators += 1
        if current_round >= r - 1:
            if current_round == r:
                if last_round_cooperators >= m:
                    return Action.D
                elif last_round_cooperators == m - 1:
                    if history.round_number >= 2:
                        recent_stability = 0
                        stable_rounds = 0
                        for i in range(max(0, history.round_number - 2), history.round_number):
                            round_cooperators = sum(history.opponent_actions[i]) + (1 if history.my_actions[i] else 0)
                            if round_cooperators >= m - 1:
                                stable_rounds += 1
                        if stable_rounds >= 2:
                            recent_stability = stable_rounds / min(2, history.round_number)
                        if recent_stability > 0.8:
                            return Action.C
                    return Action.D
                else:
                    return Action.D
            elif reliable_cooperators >= m:
                return Action.D
            elif reliable_cooperators == m - 1:
                return Action.C
            else:
                return Action.D
        if current_round <= r - 2:
            willing_cooperators = 0
            if history.round_number >= 2:
                for player_idx in range(n - 1):
                    recent_cooperations = sum(history.opponent_actions[max(0, history.round_number - 2):, player_idx])
                    if recent_cooperations >= 1:
                        willing_cooperators += 1
            else:
                willing_cooperators = reliable_cooperators
            if willing_cooperators >= m:
                return Action.D
            elif willing_cooperators == m - 1:
                if current_round <= r // 2:
                    return Action.D
                else:
                    return Action.C
            else:
                if history.round_number > 0 and last_round_cooperators >= m - 1 and (cooperation_counts[-1] < m):
                    return Action.D
                if n <= 4 and m == n - 1:
                    if willing_cooperators >= m - 2:
                        return Action.C
                if m >= n - 1:
                    if current_round > r // 3 and willing_cooperators >= m - 2:
                        return Action.C
                if k <= 1.5:
                    return Action.D
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_47(BaseStrategy):
    """
    Predatory Threshold Exploiter: An aggressive strategy that maximizes exploitation 
    while maintaining minimal cooperation to avoid collective collapse. Operates through
    three phases: early exploitation, strategic manipulation, and endgame extraction.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self.rounds_since_last_cooperation = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.rounds_since_last_cooperation = 0
            return Action.D
        current_round = history.round_number + 1
        cooperators_last_round = int(sum(history.opponent_actions[history.round_number - 1]))
        if history.my_actions[history.round_number - 1]:
            cooperators_last_round += 1
            self.rounds_since_last_cooperation = 0
        else:
            self.rounds_since_last_cooperation += 1
        phase1_end = self.r // 3
        phase2_end = 2 * self.r // 3
        if current_round <= phase1_end:
            return Action.D
        elif current_round > phase2_end:
            rounds_remaining = self.r - current_round + 1
            if rounds_remaining <= 2:
                return Action.D
            elif cooperators_last_round >= self.m:
                return Action.D
            elif cooperators_last_round == self.m - 1:
                my_total_payoff = sum(history.my_payoffs)
                avg_expected = current_round * (1 + self.k * 0.5)
                if my_total_payoff < avg_expected:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
        else:
            if history.round_number >= 3:
                recent_rounds = min(3, history.round_number)
                total_recent_actions = 0
                total_recent_cooperations = 0
                for round_idx in range(history.round_number - recent_rounds, history.round_number):
                    total_recent_actions += len(history.opponent_actions[round_idx])
                    total_recent_cooperations += sum(history.opponent_actions[round_idx])
                if total_recent_actions > 0:
                    avg_cooperation_rate = total_recent_cooperations / total_recent_actions
                    if avg_cooperation_rate < 0.3:
                        observed_coop_rate = cooperators_last_round / self.n
                        cooperate_prob = max(0.1, self.m / self.n - observed_coop_rate + 0.05)
                        if random.random() < cooperate_prob:
                            return Action.C
            if cooperators_last_round >= self.m - 1:
                return Action.D
            elif cooperators_last_round == self.m - 2:
                if self.rounds_since_last_cooperation > 3:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D

class Strategy_AGGRESSIVE_48(BaseStrategy):
    """
    Aggressive Opportunistic Exploiter strategy that maximizes individual payoffs by exploiting 
    cooperative players while minimizing personal risk. Defects when others cooperate to reach 
    threshold, uses brinkmanship tactics, and employs endgame exploitation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.m = game_description.m
        self.k = game_description.k
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        last_round_idx = history.round_number - 1
        opponent_cooperators = int(sum(history.opponent_actions[last_round_idx]))
        my_last_action = history.my_actions[last_round_idx]
        total_cooperators_last_round = opponent_cooperators + (1 if my_last_action else 0)
        if total_cooperators_last_round >= self.m:
            return Action.D
        elif total_cooperators_last_round == self.m - 1:
            if self.k >= 2.5:
                return Action.C
            else:
                return Action.D
        else:
            remaining_rounds = self.r - current_round
            if remaining_rounds <= 2 and total_cooperators_last_round >= self.m - 2:
                return Action.C
            else:
                return Action.D

class Strategy_AGGRESSIVE_49(BaseStrategy):
    """
    Aggressive Exploitation Maximizer strategy that attempts to free-ride on others' cooperation
    while minimizing own cooperation. Uses opponent categorization and threshold manipulation
    to maximize personal payoffs in the Collective Risk Dilemma.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self.opponent_types = ['UNKNOWN'] * (self.n - 1)
        self.cooperation_rates = [0.5] * (self.n - 1)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        self._update_opponent_analysis(history)
        if current_round == self.r:
            return Action.D
        expected_cooperators = self._estimate_cooperators(history, current_round)
        if expected_cooperators > self.m:
            return Action.D
        elif expected_cooperators == self.m:
            return Action.D
        elif expected_cooperators == self.m - 1:
            if self._can_manipulate_others(history, current_round):
                return Action.D
            else:
                return Action.C
        else:
            remaining_rounds = self.r - current_round
            if remaining_rounds < 3 and self._no_hope_of_threshold(history):
                return Action.D
            else:
                return Action.C

    def _update_opponent_analysis(self, history: PlayerHistory):
        """Update opponent categorization and cooperation rates"""
        if history.round_number == 0:
            return
        for i in range(self.n - 1):
            cooperations = sum(history.opponent_actions[:history.round_number, i])
            self.cooperation_rates[i] = cooperations / history.round_number
            if self.cooperation_rates[i] > 0.7:
                self.opponent_types[i] = 'RELIABLE_COOPERATOR'
            elif self.cooperation_rates[i] > 0.4:
                self.opponent_types[i] = 'CONDITIONAL_COOPERATOR'
            else:
                self.opponent_types[i] = 'DEFECTOR'

    def _estimate_cooperators(self, history: PlayerHistory, current_round: int):
        """Estimate number of cooperators for the current round"""
        cooperators = 0.0
        for i in range(self.n - 1):
            if self.opponent_types[i] == 'RELIABLE_COOPERATOR':
                cooperators += 1.0
            elif self.opponent_types[i] == 'CONDITIONAL_COOPERATOR':
                recent_rounds = min(3, history.round_number)
                if recent_rounds > 0:
                    start_idx = max(0, history.round_number - recent_rounds)
                    recent_cooperations = sum(history.opponent_actions[start_idx:history.round_number, i])
                    if recent_cooperations >= recent_rounds * 0.6:
                        cooperators += 0.8
                    else:
                        cooperators += 0.3
                else:
                    cooperators += 0.5
        return int(cooperators)

    def _can_manipulate_others(self, history: PlayerHistory, current_round: int):
        """Check if we can potentially manipulate others to cooperate"""
        conditional_count = sum((1 for t in self.opponent_types if t == 'CONDITIONAL_COOPERATOR'))
        reliable_count = sum((1 for t in self.opponent_types if t == 'RELIABLE_COOPERATOR'))
        return reliable_count > 0 and conditional_count > 0

    def _no_hope_of_threshold(self, history: PlayerHistory):
        """Check if threshold is likely impossible to achieve"""
        failures = 0
        rounds_to_check = min(3, history.round_number)
        for round_idx in range(history.round_number - rounds_to_check, history.round_number):
            if round_idx >= 0:
                total_cooperators = sum(history.opponent_actions[round_idx]) + int(history.my_actions[round_idx])
                if total_cooperators < self.m:
                    failures += 1
        reliable_cooperators = sum((1 for t in self.opponent_types if t == 'RELIABLE_COOPERATOR'))
        return failures >= rounds_to_check and reliable_cooperators < self.m - 1

class Strategy_AGGRESSIVE_50(BaseStrategy):
    """
    Aggressive "Exploit and Abandon" strategy that seeks to free-ride on others' cooperation
    while minimizing its own contributions. Always defects in first and last rounds,
    and uses conditional exploitation in between based on cooperation thresholds.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        m = self.game_description.m
        cooperators_last_round = sum(history.opponent_actions[history.round_number - 1])
        if history.my_actions[history.round_number - 1]:
            cooperators_last_round += 1
        my_defections_so_far = sum((not action for action in history.my_actions))
        defection_rate = my_defections_so_far / history.round_number
        if current_round == n_rounds:
            return Action.D
        if current_round == n_rounds - 1:
            if cooperators_last_round >= m:
                return Action.D
            elif cooperators_last_round == m - 1:
                return Action.C
            else:
                return Action.D
        if cooperators_last_round >= m:
            if cooperators_last_round >= m + 2:
                return Action.D
            elif cooperators_last_round == m or cooperators_last_round == m + 1:
                if defection_rate < 0.7:
                    return Action.D
                else:
                    return Action.C
        else:
            cooperators_needed = m - cooperators_last_round
            if cooperators_needed <= 2 and current_round <= n_rounds / 2:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_51(BaseStrategy):
    """
    Predatory Free-Rider strategy: Aggressively exploits cooperative players while 
    minimizing personal risk. Defects by default but contributes strategically only 
    when threshold is at serious risk. Designed to maximize free-riding opportunities.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.threshold_margin = 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        return self._strategic_decision(history)

    def _strategic_decision(self, history: PlayerHistory) -> Action:
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            cooperators_last_round += 1
        predicted_cooperators = self._predict_cooperation_patterns(history)
        if predicted_cooperators < self.game_description.m - self.threshold_margin:
            return Action.C
        elif predicted_cooperators >= self.game_description.m:
            return Action.D
        else:
            average_cooperation_rate = self._calculate_average_cooperation_rate(history)
            if average_cooperation_rate > 0.6:
                return Action.D
            else:
                return Action.C

    def _predict_cooperation_patterns(self, history: PlayerHistory) -> float:
        """Predict how many players will cooperate this round based on historical patterns."""
        n_opponents = self.game_description.n_players - 1
        predicted_cooperators = 0.0
        for opponent_idx in range(n_opponents):
            opponent_history = history.opponent_actions[:, opponent_idx]
            cooperation_rate = sum(opponent_history) / len(opponent_history)
            if cooperation_rate >= 0.8:
                predicted_cooperators += 1.0
            elif cooperation_rate >= 0.4:
                predicted_cooperators += 0.3
            else:
                predicted_cooperators += 0.1
        return predicted_cooperators

    def _calculate_average_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate overall cooperation rate across all players and rounds."""
        total_decisions = 0
        total_cooperations = 0
        for round_idx in range(history.round_number):
            total_decisions += self.game_description.n_players - 1
            total_cooperations += sum(history.opponent_actions[round_idx])
        total_decisions += history.round_number
        total_cooperations += sum(history.my_actions)
        return total_cooperations / total_decisions if total_decisions > 0 else 0.0

class Strategy_AGGRESSIVE_52(BaseStrategy):
    """
    Aggressive "Exploit and Abandon" strategy that maximizes personal payoffs by exploiting 
    cooperative players while minimizing personal risk. Always defects in first and last rounds,
    and free-rides whenever the cooperation threshold can be met without contributing.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.cooperation_rates = {}
        self.reliable_cooperators = set()
        self.swing_players = set()
        self.reliable_defectors = set()

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_num = history.round_number + 1
        if round_num == self.game_description.n_rounds:
            return Action.D
        self._update_opponent_analysis(history)
        expected_cooperators = self._estimate_cooperators(history)
        if expected_cooperators >= self.game_description.m:
            return Action.D
        elif expected_cooperators == self.game_description.m - 1:
            confidence = self._calculate_confidence(history)
            if confidence > 0.8 and self.game_description.k > 1.5:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _update_opponent_analysis(self, history):
        """Update tracking of opponent cooperation patterns."""
        n_opponents = self.game_description.n_players - 1
        rounds_completed = history.round_number
        for opponent_idx in range(n_opponents):
            cooperations = sum(history.opponent_actions[:rounds_completed, opponent_idx])
            coop_rate = cooperations / rounds_completed
            self.cooperation_rates[opponent_idx] = coop_rate
            if coop_rate > 0.7:
                self.reliable_cooperators.add(opponent_idx)
                self.swing_players.discard(opponent_idx)
                self.reliable_defectors.discard(opponent_idx)
            elif coop_rate < 0.3:
                self.reliable_defectors.add(opponent_idx)
                self.swing_players.discard(opponent_idx)
                self.reliable_cooperators.discard(opponent_idx)
            else:
                self.swing_players.add(opponent_idx)
                self.reliable_cooperators.discard(opponent_idx)
                self.reliable_defectors.discard(opponent_idx)

    def _estimate_cooperators(self, history):
        """Estimate how many opponents will cooperate this round."""
        reliable_count = len(self.reliable_cooperators)
        swing_coop_rate = 0.4
        swing_count = len(self.swing_players) * swing_coop_rate
        if history.round_number >= 2:
            last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
            if last_round_cooperators == self.game_description.n_players - 1:
                swing_count *= 0.7
        return reliable_count + swing_count

    def _calculate_confidence(self, history):
        """Calculate confidence level in cooperation estimates."""
        if history.round_number < 2:
            return 0.5
        reliable_ratio = len(self.reliable_cooperators) / (self.game_description.n_players - 1)
        base_confidence = 0.3 + reliable_ratio * 0.5
        if history.round_number >= 3:
            recent_rounds = min(3, history.round_number)
            recent_cooperators = []
            for r in range(history.round_number - recent_rounds, history.round_number):
                recent_cooperators.append(sum(history.opponent_actions[r]))
            if len(set(recent_cooperators)) <= 1:
                base_confidence += 0.2
        return min(1.0, base_confidence)

class Strategy_AGGRESSIVE_53(BaseStrategy):
    """
    Aggressive "Exploit-Then-Punish" Strategy that maximizes exploitation with strategic punishment.
    Defects heavily in early and late game, only cooperates when pivotal for threshold achievement.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        m = self.game_description.m
        if current_round <= n_rounds // 2:
            return Action.D
        if current_round > n_rounds - 2:
            return Action.D
        last_round_idx = history.round_number - 1
        n_cooperators_last = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            n_cooperators_last += 1
        if n_cooperators_last == m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_54(BaseStrategy):
    """
    Opportunistic Exploiter: An aggressive strategy that maximizes personal payoffs by exploiting 
    cooperative players while minimizing personal risk. Defects aggressively, free-rides when possible,
    and only cooperates when absolutely necessary to maintain exploitation opportunities.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.successful_free_rides = 0
        self.has_cooperated = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        rounds_remaining = self.game_description.n_rounds - current_round + 1
        if rounds_remaining <= 2:
            return Action.D
        last_round_idx = history.round_number - 1
        cooperation_count = int(sum(history.opponent_actions[last_round_idx]))
        if history.my_actions[last_round_idx]:
            cooperation_count += 1
        if not history.my_actions[last_round_idx] and cooperation_count >= self.game_description.m:
            self.successful_free_rides += 1
        if any(history.my_actions):
            self.has_cooperated = True
        if cooperation_count >= self.game_description.m:
            return Action.D
        elif cooperation_count == self.game_description.m - 1:
            if self._has_been_consistently_exploited(history) and self._risk_of_collapse_high(history):
                return Action.C
            else:
                return Action.D
        elif self.successful_free_rides >= 3:
            return Action.D
        else:
            return Action.C

    def _has_been_consistently_exploited(self, history: PlayerHistory) -> bool:
        """Check if I've been exploited (cooperated while others defected) recently."""
        if history.round_number < 2:
            return False
        exploited_count = 0
        for round_idx in range(max(0, history.round_number - 2), history.round_number):
            if history.my_actions[round_idx]:
                opponent_cooperators = sum(history.opponent_actions[round_idx])
                total_cooperators = opponent_cooperators + 1
                if total_cooperators < self.game_description.m:
                    exploited_count += 1
        return exploited_count >= 1

    def _risk_of_collapse_high(self, history: PlayerHistory) -> bool:
        """Assess if the cooperation system is at high risk of complete collapse."""
        if history.round_number < 3:
            return False
        failed_rounds = 0
        for round_idx in range(max(0, history.round_number - 3), history.round_number):
            total_cooperators = sum(history.opponent_actions[round_idx])
            if history.my_actions[round_idx]:
                total_cooperators += 1
            if total_cooperators < self.game_description.m:
                failed_rounds += 1
        return failed_rounds >= 2

class Strategy_AGGRESSIVE_55(BaseStrategy):
    """
    Exploitation Maximizer: An aggressive strategy that maximizes personal payoff by exploiting
    cooperative players while minimizing own contributions. Defects in round 1 and final round,
    uses adaptive exploitation in between based on opponent cooperation patterns.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        if current_round == 2:
            cooperators_last_round = sum(history.opponent_actions[0])
            if cooperators_last_round >= self.m:
                defect_probability = 0.9
            else:
                defect_probability = 0.7
            return Action.D if random.random() < defect_probability else Action.C
        else:
            rounds_to_check = min(3, history.round_number)
            start_round = history.round_number - rounds_to_check
            total_cooperators = 0
            for round_idx in range(start_round, history.round_number):
                total_cooperators += sum(history.opponent_actions[round_idx])
            recent_cooperation_rate = total_cooperators / (rounds_to_check * (self.n - 1))
            projected_cooperators = recent_cooperation_rate * (self.n - 1)
            if history.round_number >= 3:
                consistent_cooperators = 0
                for player_idx in range(self.n - 1):
                    cooperation_count = sum(history.opponent_actions[:history.round_number, player_idx])
                    cooperation_rate = cooperation_count / history.round_number
                    if cooperation_rate > 0.7:
                        consistent_cooperators += 1
                minimum_additional_needed = max(0, self.m - consistent_cooperators)
                swing_players = self.n - 1 - consistent_cooperators
                if minimum_additional_needed <= swing_players * 0.5:
                    return Action.D
            if projected_cooperators >= self.m + 1:
                return Action.D
            elif projected_cooperators >= self.m - 0.5:
                return Action.D if random.random() < 0.8 else Action.C
            else:
                return Action.D if random.random() < 0.3 else Action.C

class Strategy_AGGRESSIVE_56(BaseStrategy):
    """
    Opportunistic Exploiter - An aggressive strategy that maximizes exploitation with minimal contribution.
    Always defects first round, then free-rides when threshold is secure, cooperates only when 
    threshold is at risk (m-1 cooperators), and always defects in final 2 rounds.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round > self.game_description.n_rounds - 2:
            return Action.D
        last_round_index = history.round_number - 1
        last_round_cooperators = int(sum(history.opponent_actions[last_round_index]))
        if history.my_actions[last_round_index]:
            last_round_cooperators += 1
        if last_round_cooperators >= self.game_description.m:
            return Action.D
        elif last_round_cooperators == self.game_description.m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_57(BaseStrategy):
    """
    Opportunistic Exploiter: An aggressive strategy that maximizes free-riding while
    strategically cooperating only when necessary to secure collective rewards.
    
    Core approach: Defect by default, but cooperate when exactly m-1 others cooperated
    in the previous round to become the decisive player and secure the reward.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        prev_round_idx = history.round_number - 1
        prev_opponent_cooperators = sum(history.opponent_actions[prev_round_idx])
        prev_my_cooperation = history.my_actions[prev_round_idx]
        prev_total_cooperators = prev_opponent_cooperators + (1 if prev_my_cooperation else 0)
        if current_round == r:
            if prev_total_cooperators == m - 1:
                return Action.C
            else:
                return Action.D
        if current_round == r - 1:
            if prev_total_cooperators >= m:
                return Action.D
            elif prev_total_cooperators == m - 1:
                return Action.C
            else:
                return Action.D
        if prev_total_cooperators == m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_58(BaseStrategy):
    """
    Exploitative Threshold Rider: An aggressive strategy that minimizes personal contributions 
    while maximizing the probability of receiving rewards from others' cooperation.
    Exploits the collective risk structure by free-riding when possible and only cooperating
    when absolutely necessary to secure rewards.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n = self.game_description.n_players
        m = self.game_description.m
        k = self.game_description.k
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx]) + int(history.my_actions[last_round_idx])
        if current_round == r:
            return self._exploit_final_round(history, n, m)
        if cooperators_last_round >= m:
            return Action.D
        if cooperators_last_round == m - 1:
            if self._others_likely_to_cooperate(history) < 1:
                return Action.C
            else:
                return Action.D
        return Action.D

    def _exploit_final_round(self, history: PlayerHistory, n: int, m: int) -> Action:
        """Maximum exploitation logic for the final round"""
        last_round_idx = history.round_number - 1
        desperate_cooperators = self._count_consistent_cooperators(history)
        if desperate_cooperators >= m:
            return Action.D
        if desperate_cooperators == m - 1:
            if self._expected_other_cooperators(history) == 0:
                return Action.C
            else:
                return Action.D
        return Action.D

    def _others_likely_to_cooperate(self, history: PlayerHistory) -> int:
        """Estimate how many others are likely to cooperate next round"""
        if history.round_number < 2:
            return 0
        likely_cooperators = 0
        recent_rounds = min(3, history.round_number)
        for player_idx in range(self.game_description.n_players - 1):
            recent_cooperation_rate = 0
            for round_idx in range(history.round_number - recent_rounds, history.round_number):
                if history.opponent_actions[round_idx, player_idx]:
                    recent_cooperation_rate += 1
            recent_cooperation_rate /= recent_rounds
            if recent_cooperation_rate > 0.5:
                likely_cooperators += 1
        return likely_cooperators

    def _count_consistent_cooperators(self, history: PlayerHistory) -> int:
        """Count players who have been cooperating consistently"""
        if history.round_number < 2:
            return 0
        consistent_cooperators = 0
        recent_rounds = min(3, history.round_number)
        for player_idx in range(self.game_description.n_players - 1):
            cooperation_count = 0
            for round_idx in range(history.round_number - recent_rounds, history.round_number):
                if history.opponent_actions[round_idx, player_idx]:
                    cooperation_count += 1
            if cooperation_count >= max(1, int(recent_rounds * 0.67)):
                consistent_cooperators += 1
        return consistent_cooperators

    def _expected_other_cooperators(self, history: PlayerHistory) -> int:
        """Estimate expected cooperators in final round excluding myself"""
        if history.round_number < 1:
            return 0
        expected = 0
        last_round_idx = history.round_number - 1
        for player_idx in range(self.game_description.n_players - 1):
            if history.opponent_actions[last_round_idx, player_idx]:
                expected += 1
        return expected

class Strategy_AGGRESSIVE_59(BaseStrategy):
    """
    Exploitative Threshold Hunter: An aggressive strategy that maximizes personal payoff
    by free-riding whenever possible while only cooperating when absolutely necessary
    to secure the threshold bonus.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.coop_probabilities = [0.5] * (game_description.n_players - 1)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        previous_round = history.round_number - 1
        for j in range(len(self.coop_probabilities)):
            if history.opponent_actions[previous_round, j]:
                self.coop_probabilities[j] = min(1.0, self.coop_probabilities[j] + 0.3)
            else:
                self.coop_probabilities[j] = max(0.0, self.coop_probabilities[j] - 0.2)
        expected_cooperators = sum(self.coop_probabilities)
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        m = self.game_description.m
        n_rounds = self.game_description.n_rounds
        if expected_cooperators >= m:
            return Action.D
        elif expected_cooperators >= m - 1:
            high_confidence_estimate = expected_cooperators + 0.1
            if high_confidence_estimate >= m:
                return Action.D
            else:
                return Action.C
        else:
            rounds_remaining = n_rounds - current_round
            if expected_cooperators >= m - 2 and rounds_remaining > 3:
                return Action.C
            else:
                return Action.D

class Strategy_AGGRESSIVE_60(BaseStrategy):
    """
    Aggressive "Threshold Exploiter" Strategy that minimizes personal contributions
    while maximizing rewards from others' cooperation by exploiting the threshold structure.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.m = game_description.m
        self.k = game_description.k
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        my_last_action = history.my_actions[-1]
        opponent_cooperators = sum(history.opponent_actions[-1])
        total_cooperators = opponent_cooperators + (1 if my_last_action else 0)
        if current_round <= 0.7 * self.r:
            return self._exploit_early_phase(total_cooperators)
        else:
            return self._exploit_endgame(current_round, history, total_cooperators)

    def _exploit_early_phase(self, cooperators_last_round):
        if cooperators_last_round >= self.m:
            return Action.D
        if cooperators_last_round < self.m - 2:
            return Action.D
        if cooperators_last_round == self.m - 1:
            return Action.C
        return Action.D

    def _exploit_endgame(self, current_round, history, cooperators_last_round):
        rounds_left = self.r - current_round + 1
        lookback = min(5, history.round_number)
        recent_cooperation_rate = self._calculate_recent_cooperation(history, lookback)
        if recent_cooperation_rate > self.m / self.n + 0.1:
            return Action.D
        if rounds_left <= 2:
            if cooperators_last_round < self.m - 1:
                return Action.C
        return Action.D

    def _calculate_recent_cooperation(self, history, lookback):
        if lookback <= 0 or history.round_number <= 0:
            return 0.0
        start_round = max(0, history.round_number - lookback)
        total_decisions = 0
        total_cooperations = 0
        for round_idx in range(start_round, history.round_number):
            opponent_cooperations = sum(history.opponent_actions[round_idx])
            my_cooperation = 1 if history.my_actions[round_idx] else 0
            total_decisions += self.n
            total_cooperations += opponent_cooperations + my_cooperation
        if total_decisions == 0:
            return 0.0
        return total_cooperations / total_decisions

class Strategy_AGGRESSIVE_61(BaseStrategy):
    """
    Exploitative Threshold Hunter: An aggressive strategy that maximizes personal payoff
    by exploiting others' cooperation while minimizing personal risk. Defects by default
    and only cooperates when absolutely necessary to secure collective benefits.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == 2:
            return Action.D
        if current_round >= self.r - 1:
            return self._endgame_strategy(history, current_round)
        return self._adaptive_exploitation(history, current_round)

    def _calculate_cooperation_rate(self, actions, rounds_back=2):
        """Calculate cooperation rate over the last N rounds."""
        if len(actions) == 0:
            return 0.0
        start_round = max(0, len(actions) - rounds_back)
        recent_actions = actions[start_round:]
        if len(recent_actions) == 0:
            return 0.0
        total_cooperations = 0
        total_decisions = 0
        for round_actions in recent_actions:
            total_cooperations += sum(round_actions)
            total_decisions += len(round_actions)
        return total_cooperations / total_decisions if total_decisions > 0 else 0.0

    def _get_recent_cooperation_rate(self, history, rounds_back=2):
        """Get cooperation rate of opponents in recent rounds."""
        if history.round_number == 0:
            return 0.0
        start_round = max(0, history.round_number - rounds_back)
        recent_opponent_actions = history.opponent_actions[start_round:]
        return self._calculate_cooperation_rate(recent_opponent_actions, rounds_back)

    def _adaptive_exploitation(self, history, current_round):
        """Adaptive exploitation engine for middle rounds."""
        recent_cooperation_rate = self._get_recent_cooperation_rate(history)
        threshold_rate = self.m / self.n
        high_threshold_rate = (self.m + 1) / self.n
        low_threshold_rate = (self.m - 1) / self.n
        if recent_cooperation_rate >= high_threshold_rate:
            return Action.D
        elif recent_cooperation_rate >= threshold_rate:
            if current_round <= self.r / 2:
                return Action.D
            else:
                return Action.C
        elif recent_cooperation_rate >= low_threshold_rate:
            return Action.C
        else:
            return Action.D

    def _endgame_strategy(self, history, current_round):
        """Endgame exploitation for final rounds."""
        if current_round == self.r:
            return Action.D
        cooperation_momentum = self._get_recent_cooperation_rate(history, 3)
        total_historical_cooperation = sum((sum(round_actions) for round_actions in history.opponent_actions))
        expected_historical_cooperation = self.m * (history.round_number - 1)
        threshold_rate = self.m / self.n
        if cooperation_momentum >= threshold_rate and total_historical_cooperation >= expected_historical_cooperation:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_62(BaseStrategy):
    """
    Exploitative Threshold Rider: An aggressive strategy that maximizes free-riding 
    opportunities while providing minimal cooperation only when necessary to prevent 
    system collapse. Defects in first and last rounds, exploits successful cooperation 
    by others, and uses strategic punishment and emergency cooperation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        if current_round == r:
            return Action.D
        prev_round_idx = history.round_number - 1
        opponent_cooperators = sum(history.opponent_actions[prev_round_idx])
        my_prev_action = history.my_actions[prev_round_idx]
        total_cooperators = opponent_cooperators + (1 if my_prev_action else 0)
        if total_cooperators >= m:
            return Action.D
        elif total_cooperators == m - 1:
            if my_prev_action:
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

class Strategy_AGGRESSIVE_63(BaseStrategy):
    """
    Exploitation Maximizer: An aggressive strategy that maximizes personal payoffs by exploiting 
    cooperative opponents while minimizing personal risk. Only cooperates when pivotal or in 
    early rounds for intelligence gathering, then heavily exploits in middle rounds and 
    extracts maximum value in endgame.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round <= min(3, self.r // 4):
            return Action.C
        elif current_round > self.r - max(2, self.r // 5):
            remaining_rounds = self.r - current_round + 1
            if remaining_rounds <= 1:
                return Action.D
            else:
                estimated_cooperators = self._predict_cooperators(history)
                future_value = remaining_rounds * self.k
                if estimated_cooperators == self.m - 1 and future_value > 1:
                    return Action.C
                else:
                    return Action.D
        else:
            estimated_cooperators = self._predict_cooperators(history)
            if estimated_cooperators == self.m - 1:
                return Action.C
            elif estimated_cooperators >= self.m:
                return Action.D
            elif self._threshold_consistently_failing(history):
                return Action.D
            elif estimated_cooperators >= self.m - 2 and self._can_influence_threshold(history):
                return Action.C
            else:
                return Action.D

    def _predict_cooperators(self, history: PlayerHistory) -> int:
        """Predict how many opponents will cooperate this round"""
        if history.round_number == 0:
            return self.n // 2
        recent_rounds = min(3, history.round_number)
        start_idx = max(0, history.round_number - recent_rounds)
        recent_cooperation = 0
        total_observations = 0
        for round_idx in range(start_idx, history.round_number):
            round_cooperators = sum(history.opponent_actions[round_idx])
            recent_cooperation += round_cooperators
            total_observations += self.n - 1
        if total_observations == 0:
            cooperation_rate = 0.5
        else:
            cooperation_rate = recent_cooperation / total_observations
        decay_factor = 0.9 ** (history.round_number / self.r)
        predicted_rate = cooperation_rate * decay_factor
        return int(predicted_rate * (self.n - 1))

    def _threshold_consistently_failing(self, history: PlayerHistory) -> bool:
        """Check if threshold has been failing for recent rounds"""
        if history.round_number < 2:
            return False
        failures = 0
        check_rounds = min(2, history.round_number)
        for i in range(check_rounds):
            round_idx = history.round_number - 1 - i
            cooperators = sum(history.opponent_actions[round_idx])
            if history.my_actions[round_idx]:
                cooperators += 1
            if cooperators < self.m:
                failures += 1
        return failures >= 2

    def _can_influence_threshold(self, history: PlayerHistory) -> bool:
        """Check if there are potentially influenceable players"""
        if history.round_number == 0:
            return True
        recent_rounds = min(2, history.round_number)
        follower_count = 0
        for player_idx in range(self.n - 1):
            cooperations = 0
            for round_idx in range(max(0, history.round_number - recent_rounds), history.round_number):
                if history.opponent_actions[round_idx, player_idx]:
                    cooperations += 1
            if cooperations > 0:
                follower_count += 1
        return follower_count >= self.m - 1

class Strategy_AGGRESSIVE_64(BaseStrategy):
    """
    Exploitative Threshold Hunter - An aggressive strategy that maximizes personal payoffs
    by free-riding on cooperative players while only cooperating when absolutely necessary
    to secure the collective bonus.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        cooperators_last_round = int(sum(history.opponent_actions[history.round_number - 1]))
        rounds_to_check = min(3, history.round_number)
        persistent_cooperators = 0
        for player_idx in range(self.game_description.n_players - 1):
            cooperation_count = 0
            for round_idx in range(history.round_number - rounds_to_check, history.round_number):
                if history.opponent_actions[round_idx, player_idx]:
                    cooperation_count += 1
            if cooperation_count >= max(1, int(rounds_to_check * 0.67)):
                persistent_cooperators += 1
        estimated_cooperators = max(0, int(persistent_cooperators * 0.7) - 1)
        if history.round_number >= 3:
            total_cooperation_rate = 0
            for round_idx in range(history.round_number):
                round_cooperators = sum(history.opponent_actions[round_idx])
                total_cooperation_rate += round_cooperators / (self.game_description.n_players - 1)
            avg_cooperation_rate = total_cooperation_rate / history.round_number
            if avg_cooperation_rate < 0.4:
                return Action.D
        if estimated_cooperators >= self.game_description.m:
            return Action.D
        elif estimated_cooperators == self.game_description.m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_65(BaseStrategy):
    """
    Trust-Building Threshold Guardian: A cooperative strategy that prioritizes collective welfare
    while maintaining strategic awareness. Always cooperates in round 1, then uses adaptive
    cooperation based on threshold proximity, cooperation rates, and remaining rounds.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx]) + int(history.my_actions[last_round_idx])
        cooperation_rate = cooperators_last_round / n
        recent_rounds = min(3, history.round_number)
        my_recent_cooperations = sum(history.my_actions[-recent_rounds:])
        my_recent_cooperation = my_recent_cooperations / recent_rounds
        rounds_remaining = r - current_round + 1
        if cooperation_rate >= m / n:
            return Action.C
        if cooperation_rate >= (m - 1) / n and my_recent_cooperation >= 0.67:
            return Action.C
        if rounds_remaining <= 3:
            if cooperation_rate >= 0.4:
                return Action.C
        if cooperation_rate < 0.3 and current_round % 3 == 1:
            return Action.C
        if current_round == r:
            total_cooperations = sum(history.my_actions) + sum((sum(history.opponent_actions[i]) for i in range(history.round_number)))
            total_actions = n * history.round_number
            overall_cooperation_rate = total_cooperations / total_actions
            if cooperators_last_round >= m - 1 or overall_cooperation_rate >= 0.5:
                return Action.C
        return Action.D

class Strategy_COOPERATIVE_66(BaseStrategy):
    """
    Generous Threshold Guardian: A cooperative strategy that prioritizes collective welfare
    while maintaining smart cooperation. Aims to ensure the threshold is met consistently
    while protecting against exploitation through adaptive threshold monitoring and
    trend-based decision making.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx]) + int(history.my_actions[last_round_idx])
        recent_rounds = min(3, history.round_number)
        total_cooperators = 0
        total_possible = 0
        for i in range(recent_rounds):
            round_idx = history.round_number - 1 - i
            round_cooperators = sum(history.opponent_actions[round_idx]) + int(history.my_actions[round_idx])
            total_cooperators += round_cooperators
            total_possible += n
        avg_cooperation_rate = total_cooperators / total_possible if total_possible > 0 else 0
        if current_round == r:
            game_cooperators = 0
            game_possible = 0
            for i in range(history.round_number):
                round_cooperators = sum(history.opponent_actions[i]) + int(history.my_actions[i])
                game_cooperators += round_cooperators
                game_possible += n
            overall_cooperation_rate = game_cooperators / game_possible if game_possible > 0 else 0
            return Action.C if overall_cooperation_rate >= m / n else Action.D
        if avg_cooperation_rate >= (m + 1) / n:
            return Action.C
        elif avg_cooperation_rate >= (m - 0.5) / n:
            deficit = m - cooperators_last_round
            if deficit <= 0:
                return Action.C
            else:
                cooperation_probability = min(0.8, 0.4 + deficit * 0.2)
                return Action.C if random.random() < cooperation_probability else Action.D
        elif cooperators_last_round >= m - 1:
            return Action.C
        elif cooperators_last_round == 0 and current_round < r:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_67(BaseStrategy):
    """
    Adaptive Trust Builder: A cooperative strategy that defaults to cooperation while
    adaptively responding to group cooperation levels. Maintains cooperation when the
    threshold is met or close to being met, but protects against systematic exploitation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self.tolerance_margin = max(1, int(self.m * 0.2))
        self.abandonment_threshold = max(1, int(self.m * 0.5))

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_number = history.round_number + 1
        prev_round_idx = history.round_number - 1
        my_prev_action = history.my_actions[prev_round_idx]
        opponent_cooperators = sum(history.opponent_actions[prev_round_idx])
        total_cooperators = opponent_cooperators + (1 if my_prev_action else 0)
        if round_number <= 3:
            early_threshold = max(1, self.m - 2)
            if total_cooperators >= early_threshold:
                return Action.C
            elif total_cooperators < self.abandonment_threshold:
                return Action.D
            else:
                return Action.C
        if total_cooperators >= self.m:
            return Action.C
        elif total_cooperators >= self.m - self.tolerance_margin:
            return Action.C
        elif total_cooperators < self.abandonment_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_68(BaseStrategy):
    """
    Adaptive Threshold Guardian - A cooperative strategy that aims to maximize collective welfare
    while ensuring the critical threshold is consistently met. Maintains high cooperation rates
    with adaptive mechanisms to handle free-riding and build trust over time.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.trust_scores = [1.0] * (game_description.n_players - 1)
        self.my_cooperation_streak = 0
        self.threshold_failures = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.my_cooperation_streak = 1
            return Action.C
        current_round = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        m = self.game_description.m
        if current_round == n_rounds:
            return Action.C
        last_round_idx = history.round_number - 1
        my_last_action = history.my_actions[last_round_idx]
        opponents_last_actions = history.opponent_actions[last_round_idx]
        cooperators_last_round = int(my_last_action) + int(sum(opponents_last_actions))
        cooperation_buffer = cooperators_last_round - m
        if my_last_action:
            self.my_cooperation_streak += 1
        else:
            self.my_cooperation_streak = 0
        if cooperation_buffer < 0:
            self.threshold_failures += 1
        self._update_trust_scores(history)
        if cooperation_buffer >= 2:
            if self.my_cooperation_streak < 3:
                return Action.C
            elif random.random() < 0.1:
                self.my_cooperation_streak = 0
                return Action.D
            else:
                return Action.C
        elif cooperation_buffer >= 0:
            return Action.C
        elif self.threshold_failures >= 2:
            return Action.C
        else:
            return Action.C

    def _update_trust_scores(self, history: PlayerHistory):
        """Update trust scores based on recent cooperation patterns"""
        if history.round_number < 2:
            return
        recent_rounds = min(3, history.round_number)
        for opponent_idx in range(len(self.trust_scores)):
            recent_cooperations = 0
            for round_idx in range(history.round_number - recent_rounds, history.round_number):
                if history.opponent_actions[round_idx, opponent_idx]:
                    recent_cooperations += 1
            recent_coop_rate = recent_cooperations / recent_rounds
            self.trust_scores[opponent_idx] = 0.7 * self.trust_scores[opponent_idx] + 0.3 * recent_coop_rate

class Strategy_COOPERATIVE_69(BaseStrategy):
    """
    Adaptive Threshold Guardian: A cooperative strategy that prioritizes collective welfare
    while being resilient to exploitation. Uses threshold-based cooperation with trust
    building, forgiveness mechanisms, and adaptive responses to different environments.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self.forgiveness_used = []

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.forgiveness_used = [False] * self.r
            return Action.C
        current_round = history.round_number + 1
        if current_round == 2:
            if self._any_cooperated_last_round(history):
                return Action.C
            else:
                return Action.D
        elif current_round == 3:
            if self._average_cooperation_rate(history, history.round_number) >= 0.3:
                return Action.C
            else:
                return Action.D
        elif current_round == self.r:
            cooperators_last = self._cooperators_last_round(history)
            if cooperators_last >= self.m and self._expected_same_group_cooperates(history):
                return Action.C
            else:
                return Action.D
        elif current_round == self.r - 1:
            expected_coop = self._calculate_expected_cooperators(history)
            recent_rate = self._recent_cooperation_rate(history, 3)
            if expected_coop >= self.m and recent_rate >= 0.4:
                return Action.C
            else:
                return Action.D
        else:
            expected_coop = self._calculate_expected_cooperators(history)
            recent_rate = self._recent_cooperation_rate(history, 3)
            if recent_rate < 0.2:
                if self._cooperators_last_round(history) >= self.m - 1:
                    return Action.C
                else:
                    return Action.D
            elif recent_rate > 0.8:
                return Action.C
            elif expected_coop >= self.m:
                return Action.C
            elif expected_coop == self.m - 1 and self._can_use_forgiveness(current_round):
                self.forgiveness_used[current_round - 1] = True
                return Action.C
            else:
                return Action.D

    def _any_cooperated_last_round(self, history: PlayerHistory) -> bool:
        """Check if any opponent cooperated in the last round"""
        last_round_idx = history.round_number - 1
        return np.any(history.opponent_actions[last_round_idx])

    def _cooperators_last_round(self, history: PlayerHistory) -> int:
        """Count cooperators (including self) in the last round"""
        last_round_idx = history.round_number - 1
        opponent_cooperators = np.sum(history.opponent_actions[last_round_idx])
        my_cooperation = 1 if history.my_actions[last_round_idx] else 0
        return int(opponent_cooperators + my_cooperation)

    def _average_cooperation_rate(self, history: PlayerHistory, rounds: int) -> float:
        """Calculate average cooperation rate across all players for given number of rounds"""
        if rounds == 0:
            return 0.0
        total_cooperations = 0
        total_decisions = 0
        for r in range(min(rounds, history.round_number)):
            total_cooperations += 1 if history.my_actions[r] else 0
            total_decisions += 1
            total_cooperations += np.sum(history.opponent_actions[r])
            total_decisions += len(history.opponent_actions[r])
        return total_cooperations / total_decisions if total_decisions > 0 else 0.0

    def _recent_cooperation_rate(self, history: PlayerHistory, window: int) -> float:
        """Calculate cooperation rate in the last 'window' rounds"""
        rounds_to_check = min(window, history.round_number)
        if rounds_to_check == 0:
            return 0.0
        total_cooperations = 0
        total_decisions = 0
        start_idx = max(0, history.round_number - rounds_to_check)
        for r in range(start_idx, history.round_number):
            total_cooperations += 1 if history.my_actions[r] else 0
            total_decisions += 1
            total_cooperations += np.sum(history.opponent_actions[r])
            total_decisions += len(history.opponent_actions[r])
        return total_cooperations / total_decisions if total_decisions > 0 else 0.0

    def _calculate_expected_cooperators(self, history: PlayerHistory) -> float:
        """Calculate expected number of cooperators including self"""
        expected = 1.0
        n_opponents = len(history.opponent_actions[0])
        window = min(5, history.round_number)
        if window == 0:
            return expected + n_opponents * 0.5
        start_idx = max(0, history.round_number - window)
        for opponent_idx in range(n_opponents):
            cooperations = 0
            for r in range(start_idx, history.round_number):
                if history.opponent_actions[r][opponent_idx]:
                    cooperations += 1
            p_cooperate = cooperations / window
            expected += p_cooperate
        return expected

    def _expected_same_group_cooperates(self, history: PlayerHistory) -> bool:
        """Check if we expect the same group that cooperated last round to cooperate again"""
        if history.round_number == 0:
            return False
        last_round_idx = history.round_number - 1
        last_cooperators = []
        if history.my_actions[last_round_idx]:
            last_cooperators.append(-1)
        for i, cooperated in enumerate(history.opponent_actions[last_round_idx]):
            if cooperated:
                last_cooperators.append(i)
        if len(last_cooperators) < self.m:
            return False
        window = min(3, history.round_number)
        if window <= 1:
            return True
        start_idx = max(0, history.round_number - window)
        expected_to_continue = 0
        for player_id in last_cooperators:
            if player_id == -1:
                expected_to_continue += 1
            else:
                cooperations = 0
                for r in range(start_idx, history.round_number):
                    if history.opponent_actions[r][player_id]:
                        cooperations += 1
                p_cooperate = cooperations / window
                if p_cooperate >= 0.6:
                    expected_to_continue += 1
        return expected_to_continue >= self.m

    def _can_use_forgiveness(self, current_round: int) -> bool:
        """Check if forgiveness can be used in current round"""
        start_check = max(0, current_round - 4)
        end_check = current_round - 1
        for r in range(start_check, min(end_check, len(self.forgiveness_used))):
            if r >= 0 and self.forgiveness_used[r]:
                return False
        return True

class Strategy_COOPERATIVE_70(BaseStrategy):
    """
    Adaptive Trust Builder: A cooperative strategy that prioritizes collective success while being responsive to group dynamics.
    Always cooperates in first and last rounds, and adapts cooperation based on previous round's cooperation rates and threshold proximity.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        if current_round == r:
            return Action.C
        prev_round_idx = history.round_number - 1
        my_prev_action = history.my_actions[prev_round_idx]
        opponent_cooperators = sum(history.opponent_actions[prev_round_idx])
        total_prev_cooperators = int(opponent_cooperators) + (1 if my_prev_action else 0)
        if total_prev_cooperators == m - 1 or total_prev_cooperators == m:
            return Action.C
        elif total_prev_cooperators >= m + 1:
            return Action.C
        elif total_prev_cooperators < m - 1:
            return Action.C
        else:
            return Action.C

class Strategy_COOPERATIVE_71(BaseStrategy):
    """
    Adaptive Threshold Guardian: A cooperative strategy that prioritizes collective welfare
    while maintaining resilience against exploitation. Always cooperates initially,
    supports threshold achievement, and includes forgiveness mechanisms for temporary
    cooperation breakdowns.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        m = self.game_description.m
        if current_round == n_rounds:
            last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
            if history.my_actions[history.round_number - 1]:
                last_round_cooperators += 1
            total_cooperators = 0
            total_decisions = 0
            for round_idx in range(history.round_number):
                round_cooperators = sum(history.opponent_actions[round_idx])
                if history.my_actions[round_idx]:
                    round_cooperators += 1
                total_cooperators += round_cooperators
                total_decisions += self.game_description.n_players
            avg_cooperation_rate = total_cooperators / total_decisions if total_decisions > 0 else 0
            if last_round_cooperators >= m - 1 or avg_cooperation_rate >= 0.4:
                return Action.C
            else:
                return Action.D
        last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
        if history.my_actions[history.round_number - 1]:
            last_round_cooperators += 1
        if last_round_cooperators >= m:
            return Action.C
        if last_round_cooperators == m - 1:
            return Action.C
        if last_round_cooperators >= m // 2:
            return Action.C
        consecutive_failures = 0
        for round_idx in range(history.round_number - 1, -1, -1):
            round_cooperators = sum(history.opponent_actions[round_idx])
            if history.my_actions[round_idx]:
                round_cooperators += 1
            if round_cooperators < m:
                consecutive_failures += 1
            else:
                break
        if consecutive_failures <= 2:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_72(BaseStrategy):
    """
    Graduated Reciprocal Cooperation (GRC) strategy for Collective Risk Dilemma.
    
    Starts optimistically, adapts expectations based on group cooperation levels,
    includes forgiveness mechanisms, and maintains cooperative orientation while
    being threshold-aware for efficient collective outcomes.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.cooperation_score = 1.0
        self.forgiveness_counter = 0
        self.last_round_cooperators = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        if history.round_number > 0:
            last_round_my_action = history.my_actions[history.round_number - 1]
            last_round_opponent_cooperators = sum(history.opponent_actions[history.round_number - 1])
            self.last_round_cooperators = int(last_round_my_action) + int(last_round_opponent_cooperators)
        if current_round == r:
            if self.cooperation_score >= 0.4:
                return Action.C
            else:
                return Action.D
        else:
            if history.round_number > 0:
                cooperation_rate = self.last_round_cooperators / n
                self.cooperation_score = 0.7 * self.cooperation_score + 0.3 * cooperation_rate
            expected_others_cooperating = (n - 1) * self.cooperation_score
            expected_total_cooperating = expected_others_cooperating + 1
            if expected_total_cooperating >= m:
                self.forgiveness_counter = 0
                return Action.C
            elif self.cooperation_score >= 0.3 and self.forgiveness_counter < 2:
                self.forgiveness_counter += 1
                return Action.C
            else:
                return Action.D

class Strategy_COOPERATIVE_73(BaseStrategy):
    """
    Adaptive Collective Guardian - A cooperative strategy that prioritizes collective welfare
    while being adaptive to opponent behavior patterns. Always cooperates first, then uses
    threshold awareness and historical learning to maintain cooperation when possible.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        total_cooperators = 0
        for round_idx in range(history.round_number):
            round_cooperators = sum(history.opponent_actions[round_idx]) + (1 if history.my_actions[round_idx] else 0)
            total_cooperators += round_cooperators
        cooperation_history_rate = total_cooperators / (history.round_number * n)
        recent_cooperation = 0
        if history.round_number >= 1:
            last_round_cooperators = sum(history.opponent_actions[history.round_number - 1]) + (1 if history.my_actions[history.round_number - 1] else 0)
            recent_cooperation = last_round_cooperators
            if history.round_number >= 2:
                second_last_cooperators = sum(history.opponent_actions[history.round_number - 2]) + (1 if history.my_actions[history.round_number - 2] else 0)
                recent_cooperation += second_last_cooperators
                recent_cooperation = recent_cooperation / 2
        if current_round == r:
            successful_rounds = 0
            rounds_to_check = min(3, history.round_number)
            for i in range(rounds_to_check):
                round_idx = history.round_number - 1 - i
                round_cooperators = sum(history.opponent_actions[round_idx]) + (1 if history.my_actions[round_idx] else 0)
                if round_cooperators >= m:
                    successful_rounds += 1
            recent_success_rate = successful_rounds / rounds_to_check if rounds_to_check > 0 else 0
            if cooperation_history_rate >= m / n * 0.7:
                return Action.C
            elif recent_success_rate >= 0.5:
                return Action.C
            else:
                return Action.C if random.random() < 0.6 else Action.D
        if cooperation_history_rate >= m / n * 0.8:
            return Action.C
        elif recent_cooperation >= m - 1:
            return Action.C
        elif recent_cooperation >= m / 2:
            if history.round_number >= 2:
                prev_round_coop = sum(history.opponent_actions[history.round_number - 1]) + (1 if history.my_actions[history.round_number - 1] else 0)
                if history.round_number >= 3:
                    prev_prev_coop = sum(history.opponent_actions[history.round_number - 2]) + (1 if history.my_actions[history.round_number - 2] else 0)
                    cooperation_trend = prev_round_coop - prev_prev_coop
                else:
                    cooperation_trend = 0
            else:
                cooperation_trend = 0
            if cooperation_trend >= 0:
                return Action.C
            else:
                return Action.C if random.random() < 0.7 else Action.D
        elif cooperation_history_rate >= m / n * 0.5:
            return Action.C if random.random() < 0.6 else Action.D
        else:
            return Action.C if random.random() < 0.3 else Action.D

class Strategy_COOPERATIVE_74(BaseStrategy):
    """
    Adaptive Trust Builder: A cooperative strategy that builds trust through initial cooperation,
    adapts to community cooperation levels using threshold-based decisions, and maintains
    hope for collective success while being responsive to mixed-motive environments.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.m = game_description.m
        self.r = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == 2:
            return Action.C
        if current_round == self.r:
            return self._final_round_decision(history)
        return self._main_strategy_decision(history)

    def _main_strategy_decision(self, history: PlayerHistory) -> Action:
        recent_cooperation_rate = self._calculate_recent_cooperation(history, 3)
        base_threshold = max(0.4, self.m / self.n - 0.1)
        if self.m == self.n - 1:
            base_threshold = 0.7
        elif self.m / self.n < 0.3:
            base_threshold = max(0.3, self.m / self.n)
        cooperation_threshold = base_threshold
        if self._near_threshold_situation(history):
            cooperation_threshold -= 0.1
        if self._consecutive_failures(history):
            cooperation_threshold -= 0.2
        if recent_cooperation_rate >= cooperation_threshold:
            return Action.C
        elif recent_cooperation_rate >= cooperation_threshold - 0.2:
            return Action.C if random.random() < 0.7 else Action.D
        else:
            return Action.C if random.random() < 0.2 else Action.D

    def _final_round_decision(self, history: PlayerHistory) -> Action:
        threshold_met_count = 0
        for round_idx in range(history.round_number):
            cooperators = sum(history.opponent_actions[round_idx]) + (1 if history.my_actions[round_idx] else 0)
            if cooperators >= self.m:
                threshold_met_count += 1
        if threshold_met_count / history.round_number >= 0.6:
            return Action.C
        if self._positive_trend(history):
            return Action.C
        return Action.C if random.random() < 0.4 else Action.D

    def _calculate_recent_cooperation(self, history: PlayerHistory, lookback: int) -> float:
        """Calculate cooperation rate in the last 'lookback' rounds"""
        if history.round_number == 0:
            return 0.0
        start_round = max(0, history.round_number - lookback)
        total_cooperators = 0
        total_possible = 0
        for round_idx in range(start_round, history.round_number):
            cooperators = sum(history.opponent_actions[round_idx]) + (1 if history.my_actions[round_idx] else 0)
            total_cooperators += cooperators
            total_possible += self.n
        return total_cooperators / total_possible if total_possible > 0 else 0.0

    def _near_threshold_situation(self, history: PlayerHistory) -> bool:
        """Check if community is consistently close to threshold"""
        if history.round_number < 2:
            return False
        close_count = 0
        for round_idx in range(max(0, history.round_number - 3), history.round_number):
            cooperators = sum(history.opponent_actions[round_idx]) + (1 if history.my_actions[round_idx] else 0)
            if abs(cooperators - self.m) <= 2:
                close_count += 1
        return close_count >= 2

    def _consecutive_failures(self, history: PlayerHistory) -> bool:
        """Check if threshold hasn't been met for 3+ consecutive rounds"""
        if history.round_number < 3:
            return False
        consecutive_failures = 0
        for round_idx in range(history.round_number - 1, -1, -1):
            cooperators = sum(history.opponent_actions[round_idx]) + (1 if history.my_actions[round_idx] else 0)
            if cooperators < self.m:
                consecutive_failures += 1
            else:
                break
        return consecutive_failures >= 3

    def _positive_trend(self, history: PlayerHistory) -> bool:
        """Check if cooperation trend is positive (last 3 rounds > previous 3 rounds)"""
        if history.round_number < 6:
            return False
        last_3_coop = 0
        for round_idx in range(history.round_number - 3, history.round_number):
            cooperators = sum(history.opponent_actions[round_idx]) + (1 if history.my_actions[round_idx] else 0)
            last_3_coop += cooperators
        prev_3_coop = 0
        for round_idx in range(history.round_number - 6, history.round_number - 3):
            cooperators = sum(history.opponent_actions[round_idx]) + (1 if history.my_actions[round_idx] else 0)
            prev_3_coop += cooperators
        return last_3_coop > prev_3_coop

class Strategy_COOPERATIVE_75(BaseStrategy):
    """
    Adaptive Threshold Guardian: A cooperative strategy that prioritizes collective welfare
    while being robust against exploitation. Ensures the cooperation threshold is met by
    adapting cooperation based on recent group behavior and maintaining safety margins.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.m = game_description.m
        self.k = game_description.k
        self.r = game_description.n_rounds
        self.safety_margin = 1
        self.group_cooperation_rate = 0.8

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_num = history.round_number
        recent_cooperators = self._count_cooperators_last_round(history)
        expected_cooperators = self._estimate_cooperators_this_round(history)
        if expected_cooperators < self.m:
            return Action.C
        if expected_cooperators <= self.m + self.safety_margin:
            return Action.C
        if recent_cooperators >= self.m + 2:
            if self.group_cooperation_rate > 0.7:
                return Action.C
            elif random.random() < 0.2:
                return Action.D
            else:
                return Action.C
        return Action.C

    def _count_cooperators_last_round(self, history: PlayerHistory) -> int:
        """Count cooperators in the most recent round."""
        if history.round_number == 0:
            return 0
        last_round_idx = history.round_number - 1
        opponent_cooperators = int(np.sum(history.opponent_actions[last_round_idx]))
        my_cooperation = int(history.my_actions[last_round_idx])
        return opponent_cooperators + my_cooperation

    def _estimate_cooperators_this_round(self, history: PlayerHistory) -> int:
        """Estimate number of cooperators for this round using weighted average."""
        if history.round_number == 0:
            return int(self.group_cooperation_rate * self.n)
        weight_current = 0.6
        weight_previous = 0.4
        cooperators_last = self._count_cooperators_last_round(history)
        if history.round_number > 1:
            two_rounds_ago_idx = history.round_number - 2
            opponent_cooperators_two = int(np.sum(history.opponent_actions[two_rounds_ago_idx]))
            my_cooperation_two = int(history.my_actions[two_rounds_ago_idx])
            cooperators_two_ago = opponent_cooperators_two + my_cooperation_two
            recent_rate = (cooperators_last * weight_current + cooperators_two_ago * weight_previous) / self.n
        else:
            recent_rate = cooperators_last / self.n
        self.group_cooperation_rate = recent_rate
        return int(math.floor(recent_rate * self.n))

class Strategy_COOPERATIVE_76(BaseStrategy):
    """
    Threshold-Aware Conditional Cooperator: A cooperative strategy that leads by example,
    rewards collective success, and uses adaptive cooperation with threshold awareness,
    forgiveness, and recovery assistance to maximize collective welfare.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_number = history.round_number + 1
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        cooperators_last_round = sum(history.opponent_actions[history.round_number - 1]) + int(history.my_actions[history.round_number - 1])
        my_cooperation_rate = sum(history.my_actions) / len(history.my_actions)
        others_total_actions = history.opponent_actions.size
        others_cooperations = np.sum(history.opponent_actions)
        others_avg_cooperation = others_cooperations / others_total_actions if others_total_actions > 0 else 0
        if round_number == r:
            successful_rounds = 0
            for past_round in range(history.round_number):
                past_cooperators = sum(history.opponent_actions[past_round]) + int(history.my_actions[past_round])
                if past_cooperators >= m:
                    successful_rounds += 1
            success_rate = successful_rounds / history.round_number
            if success_rate > 0.5 or others_avg_cooperation > 0.6:
                return Action.C
            else:
                return Action.D
        if cooperators_last_round >= m:
            return Action.C
        if others_avg_cooperation >= (m - 1) / n:
            return Action.C
        if cooperators_last_round >= m - 2 and my_cooperation_rate > 0.6:
            return Action.C
        if round_number % 3 == 0:
            return Action.C
        return Action.D

class Strategy_COOPERATIVE_77(BaseStrategy):
    """
    Threshold-Aware Conditional Cooperator: A cooperative strategy that starts with cooperation
    and maintains it when the threshold is likely to be met, with forgiveness mechanisms for recovery.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.used_recovery_attempts = 0
        self.safety_margin = 0.5
        self.forgiveness_threshold = 1
        self.max_recovery_attempts = 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_number = history.round_number + 1
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        lookback_window = min(3, history.round_number)
        cooperation_rate = self._calculate_recent_cooperation_rate(history, lookback_window)
        projected_cooperators = cooperation_rate * n
        if projected_cooperators >= m + self.safety_margin:
            return Action.C
        elif projected_cooperators >= m - self.forgiveness_threshold:
            return Action.C
        elif self._show_forgiveness_signal(round_number, r):
            return Action.C
        else:
            return Action.D

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory, window: int) -> float:
        """Calculate cooperation rate over recent rounds."""
        if history.round_number == 0:
            return 0.0
        start_idx = max(0, history.round_number - window)
        total_cooperations = 0.0
        total_possible = 0.0
        for round_idx in range(start_idx, history.round_number):
            if history.my_actions[round_idx]:
                total_cooperations += 1.0
            total_possible += 1.0
            total_cooperations += sum(history.opponent_actions[round_idx])
            total_possible += len(history.opponent_actions[round_idx])
        if total_possible == 0:
            return 0.0
        return total_cooperations / total_possible

    def _show_forgiveness_signal(self, round_number: int, total_rounds: int) -> bool:
        """Determine if we should show forgiveness and try to recover cooperation."""
        if self.used_recovery_attempts >= self.max_recovery_attempts:
            return False
        if round_number >= total_rounds - 1:
            return False
        remaining_rounds = total_rounds - round_number
        recovery_interval = max(3, remaining_rounds // 4)
        if round_number % recovery_interval == 0:
            self.used_recovery_attempts += 1
            return True
        return False

class Strategy_COOPERATIVE_78(BaseStrategy):
    """
    Conditional Cooperation with Trust Building strategy for Collective Risk Dilemma.
    
    Cooperates in first round to signal intent, then uses conditional cooperation
    based on cooperation momentum and threshold likelihood. Includes forgiveness
    mechanism and maintains cooperation even in final rounds when feasible.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        last_round_idx = history.round_number - 1
        opponent_cooperators_last = sum(history.opponent_actions[last_round_idx])
        my_last_action = history.my_actions[last_round_idx]
        cooperators_last_round = opponent_cooperators_last + (1 if my_last_action else 0)
        total_opponent_cooperations = sum((sum(history.opponent_actions[i]) for i in range(history.round_number)))
        total_my_cooperations = sum(history.my_actions)
        total_cooperations = total_opponent_cooperations + total_my_cooperations
        total_possible = history.round_number * n
        cooperation_rate = total_cooperations / total_possible if total_possible > 0 else 0
        if current_round == r:
            return Action.C if cooperators_last_round >= 2 else Action.D
        if cooperators_last_round == 0:
            return Action.D
        if cooperators_last_round >= m - 1:
            return Action.C
        elif cooperation_rate >= 0.6 and cooperators_last_round >= m - 2:
            return Action.C
        elif current_round <= r // 2:
            return Action.C
        else:
            return Action.C if cooperators_last_round >= m // 2 else Action.D

class Strategy_COOPERATIVE_79(BaseStrategy):
    """
    Graduated Trust Builder: A cooperative strategy that builds trust gradually while maintaining
    protection against exploitation. Uses adaptive cooperation thresholds based on recent group
    behavior with probabilistic responses and forgiveness mechanisms.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        if current_round == r:
            if current_round >= 3:
                recent_rounds = min(2, history.round_number)
                start_idx = history.round_number - recent_rounds
                total_cooperators = 0
                for round_idx in range(start_idx, history.round_number):
                    my_cooperation = 1 if history.my_actions[round_idx] else 0
                    opponent_cooperators = sum(history.opponent_actions[round_idx])
                    total_cooperators += my_cooperation + opponent_cooperators
                recent_cooperation_rate = total_cooperators / (n * recent_rounds)
                if recent_cooperation_rate >= 0.6:
                    return Action.C
                else:
                    return Action.C if random.random() < 0.5 else Action.D
            else:
                return Action.C if random.random() < 0.5 else Action.D
        cooperation_threshold = max(0.6, (m - 1) / n + 0.1)
        recent_window = min(3, current_round - 1)
        start_idx = max(0, history.round_number - recent_window)
        total_cooperators = 0
        total_decisions = 0
        for round_idx in range(start_idx, history.round_number):
            my_cooperation = 1 if history.my_actions[round_idx] else 0
            opponent_cooperators = sum(history.opponent_actions[round_idx])
            total_cooperators += my_cooperation + opponent_cooperators
            total_decisions += n
        recent_cooperation_rate = total_cooperators / total_decisions if total_decisions > 0 else 0
        if recent_cooperation_rate >= cooperation_threshold:
            return Action.C
        elif recent_cooperation_rate >= 0.3:
            return Action.C if random.random() < 0.7 else Action.D
        else:
            return Action.C if random.random() < 0.3 else Action.D

class Strategy_COOPERATIVE_80(BaseStrategy):
    """
    Adaptive Trust Builder: A cooperative strategy that builds trust early, 
    adapts based on group cooperation patterns, and maintains collective focus 
    throughout the game while being resilient to exploitation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self.trust_building_rounds = max(1, int(self.r * 0.2))
        self.endgame_rounds = max(1, int(self.r * 0.2))
        self.window_size = min(5, self.r // 4)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round <= self.trust_building_rounds:
            return Action.C
        elif current_round > self.r - self.endgame_rounds:
            group_cooperation_estimate = self._calculate_recent_cooperation_rate(history, min(self.window_size, history.round_number))
            cooperation_probability = min(0.9, group_cooperation_estimate + 0.2)
            return Action.C if random.random() < cooperation_probability else Action.D
        else:
            window_size = min(self.window_size, history.round_number)
            recent_cooperation_rate = self._calculate_recent_cooperation_rate(history, window_size)
            expected_other_cooperators = (self.n - 1) * recent_cooperation_rate
            if expected_other_cooperators >= self.m - 1:
                return Action.C
            elif expected_other_cooperators >= self.m - 2 and recent_cooperation_rate > 0.3:
                return Action.C if random.random() < 0.7 else Action.D
            else:
                return Action.C if random.random() < 0.2 else Action.D

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory, window_size: int) -> float:
        """Calculate the cooperation rate over the most recent window_size rounds."""
        if history.round_number == 0:
            return 0.5
        start_round = max(0, history.round_number - window_size)
        recent_rounds = history.opponent_actions[start_round:history.round_number]
        if len(recent_rounds) == 0:
            return 0.5
        total_actions = recent_rounds.size
        total_cooperations = np.sum(recent_rounds)
        return total_cooperations / total_actions if total_actions > 0 else 0.5

class Strategy_COOPERATIVE_81(BaseStrategy):
    """
    Conditional Trust Builder: A cooperative strategy that starts with trust,
    adapts to group behavior, and focuses on building sustainable cooperation.
    Uses threshold-based decisions with forgiveness and long-term perspective.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        k = self.game_description.k
        current_round = history.round_number + 1
        last_round_idx = history.round_number - 1
        opponent_cooperators_last = sum(history.opponent_actions[last_round_idx])
        my_last_action = history.my_actions[last_round_idx]
        cooperators_last_round = opponent_cooperators_last + (1 if my_last_action else 0)
        my_cooperations = sum(history.my_actions)
        my_cooperation_rate = my_cooperations / history.round_number
        if current_round == r:
            total_cooperators = 0
            for round_idx in range(history.round_number):
                round_cooperators = sum(history.opponent_actions[round_idx]) + (1 if history.my_actions[round_idx] else 0)
                total_cooperators += round_cooperators
            overall_cooperation_rate = total_cooperators / (n * history.round_number)
            if overall_cooperation_rate >= 0.4:
                return Action.C
            else:
                return Action.D
        small_group_adjustment = 0
        if n <= 4:
            small_group_adjustment = 1
        high_threshold_game = m >= n * 0.8
        low_reward_game = k <= 1.5
        if cooperators_last_round >= m:
            return Action.C
        elif cooperators_last_round >= m - 1:
            return Action.C
        elif my_cooperation_rate > 0.6 and cooperators_last_round >= max(m - 2, 1):
            return Action.C
        elif cooperators_last_round < max(m - 2, 1):
            if high_threshold_game:
                total_cooperators_so_far = 0
                for round_idx in range(history.round_number):
                    round_cooperators = sum(history.opponent_actions[round_idx]) + (1 if history.my_actions[round_idx] else 0)
                    total_cooperators_so_far += round_cooperators
                group_cooperation_rate = total_cooperators_so_far / (n * history.round_number)
                if group_cooperation_rate >= 0.3:
                    return Action.C
            if small_group_adjustment > 0:
                if cooperators_last_round >= max(m - 2 - small_group_adjustment, 1):
                    return Action.C
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_82(BaseStrategy):
    """
    Progressive Trust Builder: An adaptive cooperative strategy that starts with strong cooperation
    and adapts based on community behavior patterns, always seeking to rebuild cooperative equilibria.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        last_round_idx = history.round_number - 1
        cooperators_last_round = int(sum(history.opponent_actions[last_round_idx])) + int(history.my_actions[last_round_idx])
        cooperation_rate = cooperators_last_round / n
        recent_threshold_met = cooperators_last_round >= m
        if current_round == r:
            if cooperation_rate >= (m - 1) / n:
                return Action.C
            else:
                return Action.D
        if cooperation_rate >= 0.7:
            return Action.C
        elif cooperation_rate >= m / n and recent_threshold_met:
            return Action.C
        elif cooperation_rate >= (m - 1) / n:
            return Action.C
        elif cooperation_rate >= 0.3:
            if history.round_number >= 2:
                prev_round_idx = history.round_number - 2
                prev_cooperators = int(sum(history.opponent_actions[prev_round_idx])) + int(history.my_actions[prev_round_idx])
                previous_cooperation_rate = prev_cooperators / n
                trend = cooperation_rate - previous_cooperation_rate
                if trend >= 0:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_83(BaseStrategy):
    """
    Graduated Reciprocal Cooperation (GRC) Strategy
    
    A cooperative strategy that builds trust, adapts to cooperation levels,
    and protects against exploitation while aiming for collective optimal outcomes.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        last_round_cooperators = int(sum(history.opponent_actions[history.round_number - 1]))
        if history.my_actions[history.round_number - 1]:
            last_round_cooperators += 1
        coop_rate = last_round_cooperators / n
        if current_round <= 3:
            return Action.C if coop_rate >= 0.5 else Action.D
        if current_round >= r - 1:
            if current_round == r:
                return Action.C
            else:
                return Action.C if coop_rate >= m / n else Action.D
        threshold_rate = m / n
        if coop_rate >= threshold_rate + 0.1:
            return Action.C
        elif coop_rate >= (m - 1) / n:
            return Action.C if random.random() < 0.8 else Action.D
        else:
            return Action.D

class Strategy_COOPERATIVE_84(BaseStrategy):
    """
    Adaptive Trust Builder: A cooperative strategy that prioritizes establishing and maintaining 
    cooperation while being resilient to exploitation. Balances trust-building with prudent 
    risk management by monitoring recent cooperation patterns and adapting decisions based on 
    whether the minimum threshold is likely to be reached.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.recent_window_size = min(5, max(1, game_description.n_rounds // 3))
        self.trust_threshold = 0.6
        self.minimum_cooperators_rate = game_description.m / game_description.n_players

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if current_round == total_rounds:
            recent_coop_rate = self._get_recent_cooperation_rate(history)
            if recent_coop_rate >= self.minimum_cooperators_rate * 0.8:
                return Action.C
            else:
                return Action.D
        else:
            recent_coop_rate = self._get_recent_cooperation_rate(history)
            if recent_coop_rate >= self.minimum_cooperators_rate:
                return Action.C
            elif recent_coop_rate >= self.minimum_cooperators_rate * 0.7:
                return Action.C
            elif recent_coop_rate < self.minimum_cooperators_rate * 0.5:
                return Action.D
            else:
                optimism_factor = (total_rounds - current_round) / total_rounds
                if random.random() < optimism_factor * self.trust_threshold:
                    return Action.C
                else:
                    return Action.D

    def _get_recent_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate cooperation rate over recent rounds including both self and opponents."""
        rounds_completed = history.round_number
        window_size = min(self.recent_window_size, rounds_completed)
        if window_size == 0:
            return 0.0
        start_round = max(0, rounds_completed - window_size)
        total_cooperations = 0
        total_decisions = 0
        for round_idx in range(start_round, rounds_completed):
            if history.my_actions[round_idx]:
                total_cooperations += 1
            total_decisions += 1
            for opponent_idx in range(self.game_description.n_players - 1):
                if history.opponent_actions[round_idx, opponent_idx]:
                    total_cooperations += 1
                total_decisions += 1
        return total_cooperations / total_decisions if total_decisions > 0 else 0.0

class Strategy_COOPERATIVE_85(BaseStrategy):
    """
    Adaptive Threshold Guardian: A cooperative strategy that prioritizes collective welfare
    while being resilient to exploitation. Maintains cooperation when the group achieves
    the threshold, adapts to opponent behavior patterns, and includes forgiveness mechanisms.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.cooperation_streak = 0
        self.last_round_cooperators = 0
        self.exploitation_detector = 0
        self.forgiveness_credit = 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            if self.last_round_cooperators >= self.game_description.m:
                return Action.C
            else:
                return Action.D
        last_round_idx = history.round_number - 1
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        my_last_action = history.my_actions[last_round_idx]
        self.last_round_cooperators = opponent_cooperators + (1 if my_last_action else 0)
        if self.last_round_cooperators >= self.game_description.m:
            self.exploitation_detector = max(0, self.exploitation_detector - 1)
            self.cooperation_streak += 1
        else:
            self.exploitation_detector += 1
            self.cooperation_streak = 0
        if self.last_round_cooperators >= self.game_description.m:
            action = Action.C
        elif self.last_round_cooperators >= self.game_description.m - 1:
            action = Action.C
        elif self.exploitation_detector <= 2 and self.forgiveness_credit > 0:
            self.forgiveness_credit -= 1
            action = Action.C
        elif self.cooperation_streak >= 3:
            action = Action.C
        else:
            action = Action.D
        if self.cooperation_streak >= 4:
            self.forgiveness_credit = min(2, self.forgiveness_credit + 1)
        return action

class Strategy_COOPERATIVE_86(BaseStrategy):
    """
    Adaptive Threshold Guardian: A cooperative strategy that prioritizes collective welfare 
    while being resilient to exploitation. Always cooperates in round 1, then uses adaptive
    cooperation based on previous round cooperation levels, and applies conditional cooperation
    in the final round based on overall cooperation history.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        if current_round == r:
            total_cooperators = 0
            total_possible = 0
            for round_idx in range(history.round_number):
                if history.my_actions[round_idx]:
                    total_cooperators += 1
                total_cooperators += sum(history.opponent_actions[round_idx])
                total_possible += n
            avg_cooperation = total_cooperators / total_possible if total_possible > 0 else 0
            if avg_cooperation >= m / n:
                return Action.C
            else:
                return Action.D
        last_round_idx = history.round_number - 1
        last_round_cooperators = 0
        if history.my_actions[last_round_idx]:
            last_round_cooperators += 1
        last_round_cooperators += sum(history.opponent_actions[last_round_idx])
        if last_round_cooperators >= m:
            return Action.C
        if last_round_cooperators == m - 1:
            return Action.C
        return Action.D

class Strategy_COOPERATIVE_87(BaseStrategy):
    """
    Graduated Reciprocal Cooperation strategy for Collective Risk Dilemma.
    Prioritizes collective welfare while maintaining resilience against exploitation.
    Uses threshold awareness and graduated responses based on group cooperation levels.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx]) + int(history.my_actions[last_round_idx])
        cooperation_rate = cooperators_last_round / n
        threshold_rate = m / n
        if current_round == r:
            rounds_to_check = min(3, history.round_number)
            recent_cooperators = 0
            recent_total = 0
            for i in range(rounds_to_check):
                round_idx = history.round_number - 1 - i
                cooperators_in_round = sum(history.opponent_actions[round_idx]) + int(history.my_actions[round_idx])
                recent_cooperators += cooperators_in_round
                recent_total += n
            recent_cooperation_rate = recent_cooperators / recent_total
            if recent_cooperation_rate >= threshold_rate:
                return Action.C
            else:
                return Action.D
        if cooperation_rate >= threshold_rate:
            return Action.C
        elif cooperation_rate >= threshold_rate - 0.1:
            return Action.C
        elif cooperation_rate >= 0.3:
            if history.my_actions[last_round_idx]:
                return Action.C
            else:
                return Action.C if random.random() < 0.3 else Action.D
        else:
            return Action.C if random.random() < 0.2 else Action.D

class Strategy_COOPERATIVE_88(BaseStrategy):
    """
    Adaptive Threshold Guardian: A cooperative strategy that prioritizes collective welfare
    while maintaining resilience against exploitation. It starts generously, responds to 
    group dynamics, and protects the collective threshold through adaptive decision-making.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.m = game_description.m
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        last_round_idx = history.round_number - 1
        last_round_cooperators = int(sum(history.opponent_actions[last_round_idx])) + int(history.my_actions[last_round_idx])
        last_cooperation_rate = last_round_cooperators / self.n
        if current_round == self.r:
            if history.round_number >= 3:
                recent_cooperators = []
                for i in range(3):
                    round_idx = history.round_number - 1 - i
                    if round_idx >= 0:
                        round_cooperators = int(sum(history.opponent_actions[round_idx])) + int(history.my_actions[round_idx])
                        recent_cooperators.append(round_cooperators)
                recent_avg_rate = sum(recent_cooperators) / (len(recent_cooperators) * self.n)
                threshold_rate = self.m / self.n
                if recent_avg_rate >= threshold_rate or last_round_cooperators >= self.m - 1:
                    return Action.C
            return Action.D
        if last_round_cooperators >= self.m:
            return Action.C
        if last_round_cooperators == self.m - 1 and (not history.my_actions[last_round_idx]):
            return Action.C
        if last_cooperation_rate >= 0.6:
            return Action.C
        rounds_since_good_cooperation = 0
        threshold_rate = self.m / self.n
        for i in range(history.round_number):
            round_idx = history.round_number - 1 - i
            round_cooperators = int(sum(history.opponent_actions[round_idx])) + int(history.my_actions[round_idx])
            coop_rate = round_cooperators / self.n
            if coop_rate >= threshold_rate:
                break
            rounds_since_good_cooperation += 1
        if rounds_since_good_cooperation >= 3:
            return Action.C
        return Action.D

class Strategy_COOPERATIVE_89(BaseStrategy):
    """
    Threshold Guardian with Forgiveness: A cooperative strategy that starts with unconditional
    cooperation, monitors group cooperation relative to the threshold, implements forgiveness
    for temporary defection, and adapts behavior in the final round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        last_round_idx = history.round_number - 1
        my_last_action = history.my_actions[last_round_idx]
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        total_cooperators = opponent_cooperators + (1 if my_last_action else 0)
        coop_rate = total_cooperators / n
        threshold_rate = m / n
        if current_round == r:
            return Action.C if coop_rate >= threshold_rate else Action.D
        if coop_rate >= threshold_rate + 0.1:
            return Action.C
        elif coop_rate >= threshold_rate - 0.1:
            return Action.C
        else:
            consecutive_low = self._count_consecutive_low_cooperation(history, threshold_rate)
            return Action.D if consecutive_low >= 2 else Action.C

    def _count_consecutive_low_cooperation(self, history: PlayerHistory, threshold_rate: float) -> int:
        """Count consecutive rounds of low cooperation, working backwards from most recent."""
        n = self.game_description.n_players
        count = 0
        for round_idx in range(history.round_number - 1, -1, -1):
            my_action = history.my_actions[round_idx]
            opponent_cooperators = sum(history.opponent_actions[round_idx])
            total_cooperators = opponent_cooperators + (1 if my_action else 0)
            coop_rate = total_cooperators / n
            if coop_rate < threshold_rate - 0.1:
                count += 1
            else:
                break
        return count

class Strategy_COOPERATIVE_90(BaseStrategy):
    """
    Adaptive Threshold Guardian: A cooperative strategy that prioritizes collective welfare
    while being robust against exploitation. Maintains cooperation when feasible and only
    defects when cooperation appears unsustainable or when defection won't harm the
    collective threshold.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        threshold_met_count = 0
        for round_idx in range(history.round_number):
            my_cooperation = int(history.my_actions[round_idx])
            opponent_cooperators = int(np.sum(history.opponent_actions[round_idx]))
            total_cooperators = my_cooperation + opponent_cooperators
            if total_cooperators >= m:
                threshold_met_count += 1
        cooperation_trend = threshold_met_count / history.round_number if history.round_number > 0 else 0
        my_last_action = int(history.my_actions[history.round_number - 1])
        recent_opponent_cooperators = int(np.sum(history.opponent_actions[history.round_number - 1]))
        recent_cooperators = my_last_action + recent_opponent_cooperators
        is_small_group = n <= 4
        is_high_threshold = m > n / 2
        is_low_rounds = r <= 5
        if current_round == r:
            if recent_cooperators >= m:
                if cooperation_trend >= 0.5:
                    return Action.C
                else:
                    return Action.D
            elif recent_cooperators == m - 1:
                return Action.C
            else:
                return Action.D
        if cooperation_trend >= 0.6:
            return Action.C
        elif recent_cooperators >= m + 1:
            safe_margin_threshold = m + 2 if is_small_group else m + 1
            if recent_cooperators >= safe_margin_threshold:
                if is_high_threshold:
                    if cooperation_trend >= 0.7 and current_round % 3 == 0:
                        return Action.D
                elif is_low_rounds:
                    if cooperation_trend >= 0.6 and current_round % 4 == 0:
                        return Action.D
                elif cooperation_trend >= 0.4 and current_round % 3 == 0:
                    return Action.D
            return Action.C
        elif recent_cooperators == m:
            return Action.C
        elif recent_cooperators == m - 1:
            return Action.C
        else:
            recovery_threshold = 0.3
            if is_high_threshold:
                recovery_threshold = 0.4
            if cooperation_trend >= recovery_threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COOPERATIVE_91(BaseStrategy):
    """
    Adaptive Threshold Cooperation Strategy (ATCS)
    
    This strategy balances cooperative intent with adaptive learning, aiming to achieve 
    collective success while protecting against exploitation. It starts optimistically 
    but learns from group behavior to maintain efficiency.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        total_cooperators = 0.0
        weighted_total = 0.0
        for round_idx in range(history.round_number):
            rounds_ago = history.round_number - round_idx
            weight = 0.8 ** (rounds_ago - 1)
            my_cooperated = history.my_actions[round_idx]
            opponent_cooperators = sum(history.opponent_actions[round_idx])
            cooperators_in_round = int(my_cooperated) + opponent_cooperators
            total_cooperators += cooperators_in_round * weight
            weighted_total += weight
        base_cooperation_rate = total_cooperators / (weighted_total * n)
        trend = 'stable'
        if history.round_number >= 3:
            recent_rates = []
            for i in range(max(0, history.round_number - 3), history.round_number):
                my_cooperated = int(history.my_actions[i])
                opponent_cooperators = sum(history.opponent_actions[i])
                rate = (my_cooperated + opponent_cooperators) / n
                recent_rates.append(rate)
            if recent_rates[-1] > recent_rates[0] + 0.1:
                trend = 'increasing'
            elif abs(recent_rates[-1] - recent_rates[0]) <= 0.1:
                trend = 'stable'
            else:
                trend = 'decreasing'
        if trend == 'increasing':
            confidence_factor = 1.1
        elif trend == 'stable' and base_cooperation_rate >= m / n:
            confidence_factor = 1.0
        elif trend == 'decreasing':
            confidence_factor = 0.9
        else:
            confidence_factor = 0.85
        predicted_cooperators = base_cooperation_rate * n * confidence_factor
        if current_round == r:
            threshold_for_decision = m + 1
        else:
            threshold_for_decision = m
        if current_round <= 3:
            last_round_idx = history.round_number - 1
            my_cooperated = int(history.my_actions[last_round_idx])
            opponent_cooperators = sum(history.opponent_actions[last_round_idx])
            last_round_cooperators = my_cooperated + opponent_cooperators
            if last_round_cooperators >= m:
                return Action.C
            else:
                cooperation_prob = max(0.3, m / n)
                if random.random() < cooperation_prob:
                    return Action.C
                else:
                    return Action.D
        if predicted_cooperators >= threshold_for_decision:
            return Action.C
        elif abs(predicted_cooperators - m) <= 0.5:
            if random.random() < 0.2:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COOPERATIVE_92(BaseStrategy):
    """
    Adaptive Trust Builder strategy for Collective Risk Dilemma.
    Prioritizes collective welfare while maintaining resilience against exploitation.
    Starts cooperative and adapts based on observed patterns and threshold achievement.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.r:
            return self._final_round_decision(history)
        return self._adaptive_decision(history)

    def _final_round_decision(self, history: PlayerHistory) -> Action:
        """Final round conditional cooperation logic."""
        last_round_idx = history.round_number - 1
        cooperation_count_last_round = sum(history.opponent_actions[last_round_idx]) + int(history.my_actions[last_round_idx])
        successful_rounds = 0
        for round_idx in range(history.round_number):
            round_cooperators = sum(history.opponent_actions[round_idx]) + int(history.my_actions[round_idx])
            if round_cooperators >= self.m:
                successful_rounds += 1
        historical_success_rate = successful_rounds / history.round_number if history.round_number > 0 else 0
        if cooperation_count_last_round >= self.m - 1 or historical_success_rate >= 0.6:
            return Action.C
        else:
            return Action.D

    def _adaptive_decision(self, history: PlayerHistory) -> Action:
        """Adaptive trust building for rounds 2 to r-1."""
        last_round_idx = history.round_number - 1
        cooperation_count = sum(history.opponent_actions[last_round_idx]) + int(history.my_actions[last_round_idx])
        threshold_met_last_round = cooperation_count >= self.m
        estimated_cooperators = self._estimate_likely_cooperators(history)
        if estimated_cooperators + 1 >= self.m:
            return Action.C
        elif cooperation_count >= self.m // 2 and threshold_met_last_round:
            return Action.C
        else:
            return Action.D

    def _estimate_likely_cooperators(self, history: PlayerHistory) -> int:
        """Estimate how many other players are likely to cooperate this round."""
        likely_cooperators = 0.0
        last_round_idx = history.round_number - 1
        last_round_cooperation_count = sum(history.opponent_actions[last_round_idx]) + int(history.my_actions[last_round_idx])
        for player_idx in range(self.n - 1):
            cooperation_rate = self._get_cooperation_rate(history, player_idx)
            cooperated_last_round = bool(history.opponent_actions[last_round_idx, player_idx])
            recent_trend = self._get_recent_cooperation_trend(history, player_idx)
            if cooperation_rate > 0.7:
                likely_cooperators += 1.0
            elif cooperated_last_round and recent_trend > 0:
                likely_cooperators += 0.7
            elif last_round_cooperation_count >= self.m - 2 and cooperated_last_round:
                likely_cooperators += 0.8
        return int(likely_cooperators)

    def _get_cooperation_rate(self, history: PlayerHistory, player_idx: int) -> float:
        """Calculate cooperation rate for a specific opponent."""
        if history.round_number == 0:
            return 0.0
        cooperations = sum(history.opponent_actions[:history.round_number, player_idx])
        return cooperations / history.round_number

    def _get_recent_cooperation_trend(self, history: PlayerHistory, player_idx: int) -> float:
        """Calculate recent cooperation trend for a specific opponent."""
        if history.round_number < 2:
            return 0.0
        look_back = min(3, history.round_number)
        recent_actions = history.opponent_actions[history.round_number - look_back:history.round_number, player_idx]
        if len(recent_actions) < 2:
            return 0.0
        mid_point = len(recent_actions) // 2
        if mid_point == 0:
            return 0.0
        earlier_rate = sum(recent_actions[:mid_point]) / mid_point
        later_rate = sum(recent_actions[mid_point:]) / (len(recent_actions) - mid_point)
        return later_rate - earlier_rate

class Strategy_COOPERATIVE_93(BaseStrategy):
    """
    Adaptive Threshold Guardian - A cooperative strategy that prioritizes collective welfare
    while being resilient to exploitation. Uses safety net principle, trend analysis,
    and generosity buffer to maintain cooperation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        prev_round_idx = history.round_number - 1
        cooperation_count = int(sum(history.opponent_actions[prev_round_idx])) + int(history.my_actions[prev_round_idx])
        cooperation_rate = cooperation_count / self.n
        my_cooperations = sum(history.my_actions)
        my_cooperation_rate = my_cooperations / history.round_number if history.round_number > 0 else 1.0
        if cooperation_count == self.m - 1:
            return Action.C
        threshold_rate = self.m / self.n
        if cooperation_rate >= threshold_rate + 0.1:
            return Action.C
        if cooperation_rate >= (self.m - 1) / self.n:
            return Action.C
        if self._recent_trend_is_improving(history):
            return Action.C
        if my_cooperation_rate > 0.7 and cooperation_rate < 0.3 and (current_round < self.r - 2):
            return Action.D
        return Action.C

    def _recent_trend_is_improving(self, history: PlayerHistory) -> bool:
        """Check if cooperation trend is improving in recent rounds"""
        round_num = history.round_number
        if round_num <= 3:
            return True
        cooperation_counts = []
        for i in range(max(0, round_num - 3), round_num):
            count = int(sum(history.opponent_actions[i])) + int(history.my_actions[i])
            cooperation_counts.append(count)
        if len(cooperation_counts) >= 3:
            return cooperation_counts[-1] > cooperation_counts[0] or cooperation_counts[-1] >= self.m - 1
        return True

class Strategy_COOPERATIVE_94(BaseStrategy):
    """
    Graduated Reciprocal Trust Builder - A cooperative strategy that builds trust through 
    initial cooperation, uses threshold-based reciprocal responses, and includes forgiveness 
    mechanisms to prevent permanent defection cycles.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == 2:
            return Action.C
        last_round_idx = history.round_number - 1
        last_round_cooperators = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            total_cooperators = last_round_cooperators + 1
        else:
            total_cooperators = last_round_cooperators
        cooperation_rate = total_cooperators / self.game_description.n_players
        if current_round == self.game_description.n_rounds:
            threshold_met = cooperation_rate >= self.game_description.m / self.game_description.n_players
            return Action.C if threshold_met else Action.D
        threshold = (self.game_description.m - 1) / self.game_description.n_players
        if cooperation_rate >= threshold:
            return Action.C
        elif random.random() < 0.3:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_95(BaseStrategy):
    """
    Adaptive Threshold Guardian: A cooperative strategy that prioritizes collective welfare
    while maintaining resilience against exploitation. Guards the cooperation threshold
    by adapting to group cooperation patterns and maintaining cooperation when critical.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        my_last_action = Action.C if history.my_actions[-1] else Action.D
        last_round_cooperators = int(sum(history.opponent_actions[-1])) + (1 if history.my_actions[-1] else 0)
        rounds_to_check = min(3, history.round_number)
        recent_cooperators = 0
        for i in range(rounds_to_check):
            round_idx = -(i + 1)
            round_coop = int(sum(history.opponent_actions[round_idx])) + (1 if history.my_actions[round_idx] else 0)
            recent_cooperators += round_coop
        avg_recent_cooperation = recent_cooperators / (rounds_to_check * n)
        threshold_buffer = last_round_cooperators - m
        if last_round_cooperators <= m + 1:
            return Action.C
        if avg_recent_cooperation < (m + 2) / n:
            return Action.C
        if current_round > r - 3:
            return Action.C
        if threshold_buffer <= 2:
            return Action.C
        if my_last_action == Action.D and last_round_cooperators < n * 0.7:
            return Action.C
        if threshold_buffer >= 3 and avg_recent_cooperation > 0.8:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_96(BaseStrategy):
    """
    Optimistic Threshold Guardian: A cooperative strategy that prioritizes collective welfare
    while maintaining resilience against exploitation. Uses adaptive cooperation based on
    threshold achievement rates, cooperation trends, and strategic timing.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        rounds_threshold_met = 0
        for round_idx in range(history.round_number):
            cooperators_in_round = sum(history.opponent_actions[round_idx]) + (1 if history.my_actions[round_idx] else 0)
            if cooperators_in_round >= m:
                rounds_threshold_met += 1
        threshold_rate = rounds_threshold_met / history.round_number
        recent_cooperators = sum(history.opponent_actions[history.round_number - 1])
        if history.my_actions[history.round_number - 1]:
            recent_cooperators += 1
        if history.round_number >= 2:
            total_previous_cooperators = 0
            for round_idx in range(history.round_number - 1):
                round_cooperators = sum(history.opponent_actions[round_idx]) + (1 if history.my_actions[round_idx] else 0)
                total_previous_cooperators += round_cooperators
            avg_cooperators_previous = total_previous_cooperators / (history.round_number - 1)
            cooperation_trend = recent_cooperators - avg_cooperators_previous
        else:
            cooperation_trend = 0
        consecutive_failures = 0
        for round_idx in range(history.round_number - 1, -1, -1):
            cooperators_in_round = sum(history.opponent_actions[round_idx]) + (1 if history.my_actions[round_idx] else 0)
            if cooperators_in_round < m:
                consecutive_failures += 1
            else:
                break
        if threshold_rate >= 0.6 or recent_cooperators >= m - 1:
            return Action.C
        if cooperation_trend > 0 and recent_cooperators >= m - 2:
            return Action.C
        if current_round >= 0.8 * r and recent_cooperators >= m - 2:
            return Action.C
        if consecutive_failures >= 2 and recent_cooperators >= max(0, m - 3):
            return Action.C
        if current_round <= 3 and recent_cooperators > max(0, m - 3):
            return Action.C
        return Action.D

class Strategy_COOPERATIVE_97(BaseStrategy):
    """
    Threshold Guardian with Forgiveness: A cooperative strategy that prioritizes achieving 
    the collective threshold while maintaining resilience against occasional defections.
    Balances cooperative intent with strategic adaptation to ensure group success.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        if current_round == r:
            return Action.C
        if current_round == 2:
            cooperators_last_round = sum(history.opponent_actions[0]) + (1 if history.my_actions[0] else 0)
            return Action.C
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx]) + (1 if history.my_actions[last_round_idx] else 0)
        rounds_to_check = min(3, history.round_number)
        successful_rounds = 0
        for i in range(rounds_to_check):
            round_idx = history.round_number - 1 - i
            cooperators_in_round = sum(history.opponent_actions[round_idx]) + (1 if history.my_actions[round_idx] else 0)
            if cooperators_in_round >= m:
                successful_rounds += 1
        recent_success_rate = successful_rounds / rounds_to_check
        if recent_success_rate >= 0.67:
            return Action.C
        elif cooperators_last_round >= m - 1:
            return Action.C
        elif cooperators_last_round < m - 2:
            rounds_to_check_self = min(2, history.round_number)
            my_recent_cooperations = 0
            for i in range(rounds_to_check_self):
                round_idx = history.round_number - 1 - i
                if history.my_actions[round_idx]:
                    my_recent_cooperations += 1
            return Action.C
        else:
            return Action.C

class Strategy_COOPERATIVE_98(BaseStrategy):
    """
    Adaptive Trust Builder: A cooperative strategy that balances cooperation with strategic awareness
    of collective risk dynamics. Starts cooperative, adapts based on group cooperation rates,
    and maintains trust-building behavior while protecting against systematic exploitation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self.trust_threshold = self.m / self.n
        if self.m / self.n > 0.8:
            self.adjusted_trust_threshold = self.trust_threshold * 0.8
        else:
            self.adjusted_trust_threshold = self.trust_threshold

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        last_round_idx = history.round_number - 1
        last_round_cooperators = int(sum(history.opponent_actions[last_round_idx]))
        if history.my_actions[last_round_idx]:
            last_round_cooperators += 1
        cooperation_rate = last_round_cooperators / self.n
        if current_round == self.r:
            rounds_to_check = min(3, history.round_number)
            total_cooperators = 0
            for i in range(rounds_to_check):
                round_idx = history.round_number - 1 - i
                round_cooperators = int(sum(history.opponent_actions[round_idx]))
                if history.my_actions[round_idx]:
                    round_cooperators += 1
                total_cooperators += round_cooperators
            recent_cooperation_rate = total_cooperators / (self.n * rounds_to_check)
            if recent_cooperation_rate >= self.adjusted_trust_threshold:
                return Action.C
            elif recent_cooperation_rate >= self.adjusted_trust_threshold * 0.5:
                return Action.C
            else:
                return Action.D
        if self.n <= 3:
            if cooperation_rate >= 0.5:
                return Action.C
            elif last_round_cooperators == self.m - 1:
                return Action.C
            else:
                return Action.C
        if cooperation_rate >= self.adjusted_trust_threshold:
            return Action.C
        elif cooperation_rate >= self.adjusted_trust_threshold * 0.75:
            return Action.C
        elif last_round_cooperators == self.m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_99(BaseStrategy):
    """
    Threshold Guardian with Forgiveness: A cooperative strategy that tracks cooperation patterns
    to determine when the threshold is likely to be met, with built-in forgiveness mechanisms
    to recover from coordination failures and avoid exploitation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.m = game_description.m
        self.punishment_rounds_left = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if self.punishment_rounds_left > 0:
            self.punishment_rounds_left -= 1
            return Action.D
        recent_window = min(3, history.round_number)
        total_recent_cooperators = 0
        for i in range(history.round_number - recent_window, history.round_number):
            cooperators_in_round = sum(history.opponent_actions[i]) + (1 if history.my_actions[i] else 0)
            total_recent_cooperators += cooperators_in_round
        avg_cooperators = total_recent_cooperators / recent_window
        times_exploited = 0
        check_window = min(3, history.round_number)
        for i in range(history.round_number - check_window, history.round_number):
            if history.my_actions[i]:
                total_cooperators = sum(history.opponent_actions[i]) + 1
                if total_cooperators < self.m:
                    times_exploited += 1
        consecutive_failures = 0
        for i in range(history.round_number - 1, -1, -1):
            total_cooperators = sum(history.opponent_actions[i]) + (1 if history.my_actions[i] else 0)
            if total_cooperators < self.m:
                consecutive_failures += 1
            else:
                break
        if avg_cooperators >= self.m:
            return Action.C
        elif avg_cooperators >= self.m - 1:
            if times_exploited < 2:
                return Action.C
            else:
                return Action.D
        elif consecutive_failures >= 3:
            self.punishment_rounds_left = 1
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_100(BaseStrategy):
    """
    Adaptive Threshold Guardian: A cooperative strategy that starts optimistically,
    adapts based on group cooperation levels, and maintains commitment to collective welfare.
    Cooperates when threshold is achievable, defects strategically to signal when it's not.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        if current_round == r:
            return Action.C
        cooperation_counts = []
        for round_idx in range(history.round_number):
            my_cooperation = 1 if history.my_actions[round_idx] else 0
            opponent_cooperation = sum(history.opponent_actions[round_idx])
            total_cooperation = my_cooperation + opponent_cooperation
            cooperation_counts.append(total_cooperation)
        recent_rounds = min(3, len(cooperation_counts))
        if recent_rounds > 0:
            recent_cooperation_avg = sum(cooperation_counts[-recent_rounds:]) / (recent_rounds * n)
        else:
            recent_cooperation_avg = 0
        trend = 0
        if recent_rounds >= 2:
            mid_point = recent_rounds // 2
            if mid_point > 0:
                early_avg = sum(cooperation_counts[-recent_rounds:-recent_rounds + mid_point]) / (mid_point * n)
                late_avg = sum(cooperation_counts[-recent_rounds + mid_point:]) / ((recent_rounds - mid_point) * n)
                trend = late_avg - early_avg
        consistent_cooperators = 0
        if history.round_number > 0:
            for player_idx in range(n - 1):
                cooperation_rate = sum(history.opponent_actions[:, player_idx]) / history.round_number
                if cooperation_rate >= 0.8:
                    consistent_cooperators += 1
        threshold_ratio = m / n
        near_threshold_ratio = (m - 1) / n
        if recent_cooperation_avg >= threshold_ratio:
            return Action.C
        elif recent_cooperation_avg >= near_threshold_ratio and trend >= 0:
            return Action.C
        elif consistent_cooperators >= m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_101(BaseStrategy):
    """
    Adaptive Trust Builder: A cooperative strategy that builds trust while being resilient to moderate defection.
    
    Uses a three-tier trust system based on historical cooperation rates:
    - High trust (80%): Always cooperate
    - Medium trust (50-79%): Cooperate if close to threshold (m-1 cooperators last round)
    - Low trust (<50%): Cooperate only if threshold was met (m cooperators last round)
    
    Always starts cooperatively and has special logic for the final round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        if current_round == r:
            cooperation_rate = self._calculate_historical_cooperation_rate(history)
            return Action.C if cooperation_rate >= 0.6 else Action.D
        cooperation_rate = self._calculate_historical_cooperation_rate(history)
        last_round_cooperators = self._count_last_round_cooperators(history)
        if cooperation_rate >= 0.8:
            return Action.C
        elif cooperation_rate >= 0.5:
            return Action.C if last_round_cooperators >= m - 1 else Action.D
        else:
            return Action.C if last_round_cooperators >= m else Action.D

    def _calculate_historical_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate the overall cooperation rate across all players and rounds."""
        if history.round_number == 0:
            return 0.0
        total_cooperations = 0
        total_decisions = 0
        total_cooperations += sum(history.my_actions)
        total_decisions += len(history.my_actions)
        for round_idx in range(history.round_number):
            total_cooperations += sum(history.opponent_actions[round_idx])
            total_decisions += len(history.opponent_actions[round_idx])
        return total_cooperations / total_decisions if total_decisions > 0 else 0.0

    def _count_last_round_cooperators(self, history: PlayerHistory) -> int:
        """Count the number of cooperators (including self) in the most recent round."""
        if history.round_number == 0:
            return 0
        last_round_idx = history.round_number - 1
        cooperators = int(history.my_actions[last_round_idx])
        cooperators += sum(history.opponent_actions[last_round_idx])
        return cooperators

class Strategy_COOPERATIVE_102(BaseStrategy):
    """
    Adaptive Threshold Guardian: A cooperative strategy that prioritizes collective welfare
    while maintaining resilience against exploitation. Always cooperates in first and last
    rounds, and adapts to group cooperation dynamics in between.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.C
        last_round_idx = history.round_number - 1
        cooperators_last_round = int(sum(history.opponent_actions[last_round_idx]))
        if history.my_actions[last_round_idx]:
            cooperators_last_round += 1
        n = self.game_description.n_players
        m = self.game_description.m
        cooperation_rate = cooperators_last_round / n
        if cooperation_rate >= m / n:
            return Action.C
        elif cooperation_rate >= 0.6:
            return Action.C
        elif cooperators_last_round == m - 1:
            return Action.C
        elif cooperation_rate < 0.3:
            if cooperators_last_round > 0:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_103(BaseStrategy):
    """
    Graduated Trust Builder (GTB): A cooperative strategy that builds trust initially,
    adapts based on collective behavior, and maintains cooperation when the community
    demonstrates commitment to the common good.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        current_round = history.round_number + 1
        if current_round <= r // 3:
            return Action.C
        if current_round > r - 2:
            total_cooperation_decisions = 0
            total_decisions = 0
            for round_idx in range(history.round_number):
                if history.my_actions[round_idx]:
                    total_cooperation_decisions += 1
                total_decisions += 1
                total_cooperation_decisions += int(sum(history.opponent_actions[round_idx]))
                total_decisions += n - 1
            avg_cooperation_rate = total_cooperation_decisions / total_decisions
            if avg_cooperation_rate >= m / n:
                return Action.C
            else:
                return Action.D
        last_round_idx = history.round_number - 1
        cooperators_last_round = 1 if history.my_actions[last_round_idx] else 0
        cooperators_last_round += int(sum(history.opponent_actions[last_round_idx]))
        if cooperators_last_round >= m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_104(BaseStrategy):
    """
    Adaptive Trust Builder: A cooperative strategy that starts with trust, adapts to group cooperation levels,
    and maintains hope for collective success. Uses dynamic thresholds based on recent cooperation rates
    to balance collective welfare with pragmatic adaptation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.C
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            cooperators_last_round += 1
        cooperation_rate = cooperators_last_round / self.game_description.n_players
        threshold_rate = self.game_description.m / self.game_description.n_players
        if cooperation_rate >= 0.7:
            return Action.C
        elif cooperation_rate >= threshold_rate:
            return Action.C
        elif cooperation_rate >= 0.3:
            if cooperators_last_round >= self.game_description.m - 1:
                return Action.C
            else:
                return Action.C if random.random() < 0.7 else Action.D
        else:
            return Action.C if random.random() < 0.4 else Action.D

class Strategy_COOPERATIVE_105(BaseStrategy):
    """
    Adaptive Threshold Cooperation: A cooperative strategy that balances collective welfare 
    with strategic awareness. Cooperates by default but adapts based on opponent cooperation 
    patterns and threshold proximity.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        recent_coop_rate = self._calculate_recent_cooperation_rate(history, 2)
        historical_coop_rate = self._calculate_historical_cooperation_rate(history)
        last_round_cooperators = self._count_last_round_cooperators(history)
        threshold_gap = m - last_round_cooperators - 1
        if current_round == r:
            if historical_coop_rate >= 0.25 or last_round_cooperators >= m - 1:
                return Action.C
            else:
                return Action.D
        if recent_coop_rate >= 0.4 or historical_coop_rate >= 0.35 or (threshold_gap <= 2 and historical_coop_rate >= 0.2):
            return Action.C
        elif historical_coop_rate < 0.15 and recent_coop_rate < 0.2:
            return Action.D
        else:
            return Action.C

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory, lookback_rounds: int) -> float:
        """Calculate cooperation rate over the last few rounds."""
        rounds_completed = history.round_number
        start_round = max(0, rounds_completed - lookback_rounds)
        if start_round >= rounds_completed:
            return 0.0
        total_cooperators = 0
        total_possible = 0
        for round_idx in range(start_round, rounds_completed):
            cooperators = sum(history.opponent_actions[round_idx])
            if history.my_actions[round_idx]:
                cooperators += 1
            total_cooperators += cooperators
            total_possible += self.game_description.n_players
        return total_cooperators / total_possible if total_possible > 0 else 0.0

    def _calculate_historical_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate overall cooperation rate across all completed rounds."""
        rounds_completed = history.round_number
        if rounds_completed == 0:
            return 0.0
        total_cooperators = 0
        total_possible = rounds_completed * self.game_description.n_players
        for round_idx in range(rounds_completed):
            cooperators = sum(history.opponent_actions[round_idx])
            if history.my_actions[round_idx]:
                cooperators += 1
            total_cooperators += cooperators
        return total_cooperators / total_possible

    def _count_last_round_cooperators(self, history: PlayerHistory) -> int:
        """Count cooperators (excluding self) in the most recent round."""
        if history.round_number == 0:
            return 0
        last_round_idx = history.round_number - 1
        return sum(history.opponent_actions[last_round_idx])

class Strategy_COOPERATIVE_106(BaseStrategy):
    """
    Adaptive Threshold Cooperation with Forgiveness (ATCF)
    
    A cooperative strategy that aims to achieve and maintain the cooperation threshold
    while being resilient against exploitation. Uses trend analysis, graduated responses,
    and forgiveness mechanisms to balance cooperation with protection against free-riders.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.m = game_description.m
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.r:
            return self._final_round_decision(history)
        return self._regular_round_decision(history)

    def _final_round_decision(self, history: PlayerHistory) -> Action:
        """Generous cooperation in the final round"""
        recent_rounds = min(3, history.round_number)
        cooperators_recent = self._average_cooperators(history, recent_rounds)
        if cooperators_recent >= self.m - 0.5:
            return Action.C
        elif cooperators_recent >= 1:
            return Action.C if random.random() < 0.4 else Action.D
        else:
            return Action.D

    def _regular_round_decision(self, history: PlayerHistory) -> Action:
        """Main decision logic for rounds 2 to r-1"""
        cooperators_last = self._count_cooperators_last_round(history)
        cooperators_trend = self._average_cooperators(history, min(3, history.round_number))
        my_cooperation_rate = self._my_cooperation_rate(history)
        if cooperators_last >= self.m:
            if cooperators_trend >= self.m + 1:
                return Action.C
            else:
                return Action.C if random.random() < 0.9 else Action.D
        elif cooperators_last >= self.m - 1:
            return Action.C
        elif cooperators_last >= max(2, self.m // 2):
            if my_cooperation_rate > 0.6:
                return Action.C
            else:
                return Action.C
        elif cooperators_last > 0:
            return Action.C if random.random() < 0.3 else Action.D
        else:
            return Action.C if random.random() < 0.05 else Action.D

    def _count_cooperators_last_round(self, history: PlayerHistory) -> int:
        """Count cooperators (including self) in the most recent round"""
        if history.round_number == 0:
            return 0
        last_round_idx = history.round_number - 1
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        my_cooperation = 1 if history.my_actions[last_round_idx] else 0
        return int(opponent_cooperators + my_cooperation)

    def _average_cooperators(self, history: PlayerHistory, num_rounds: int) -> float:
        """Calculate average number of cooperators over the last num_rounds"""
        if history.round_number == 0:
            return 0.0
        start_idx = max(0, history.round_number - num_rounds)
        total_cooperators = 0.0
        rounds_counted = 0
        for round_idx in range(start_idx, history.round_number):
            opponent_cooperators = sum(history.opponent_actions[round_idx])
            my_cooperation = 1 if history.my_actions[round_idx] else 0
            total_cooperators += opponent_cooperators + my_cooperation
            rounds_counted += 1
        return total_cooperators / rounds_counted if rounds_counted > 0 else 0.0

    def _my_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate my cooperation rate so far"""
        if history.round_number == 0:
            return 1.0
        cooperations = sum(history.my_actions)
        return cooperations / history.round_number

class Strategy_COOPERATIVE_107(BaseStrategy):
    """
    Conditional Threshold Cooperation Strategy
    
    A cooperative strategy that adapts based on group cooperation rates while maintaining
    a bias toward cooperation. Prioritizes achieving the minimum threshold for collective
    benefit while protecting against systematic exploitation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        my_last_action = history.my_actions[-1]
        opponent_last_actions = history.opponent_actions[-1]
        cooperators_last_round = int(my_last_action) + sum(opponent_last_actions)
        total_my_cooperations = sum(history.my_actions)
        total_opponent_cooperations = sum((sum(round_actions) for round_actions in history.opponent_actions))
        total_cooperators = total_my_cooperations + total_opponent_cooperations
        cooperation_rate = total_cooperators / (history.round_number * n)
        if cooperation_rate >= 0.6:
            return Action.C
        elif cooperation_rate >= 0.4:
            return self._conditional_cooperate(history, n, m)
        else:
            return self._defensive_cooperate(history, n, m, r, current_round)

    def _conditional_cooperate(self, history: PlayerHistory, n: int, m: int) -> Action:
        my_last_action = history.my_actions[-1]
        opponent_last_actions = history.opponent_actions[-1]
        cooperators_last_round = int(my_last_action) + sum(opponent_last_actions)
        if cooperators_last_round >= m:
            return Action.C
        if cooperators_last_round >= m - 2:
            return Action.C
        rounds_to_check = min(3, history.round_number)
        recent_cooperations = 0
        for i in range(rounds_to_check):
            round_idx = history.round_number - 1 - i
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            recent_cooperations += int(my_action) + sum(opponent_actions)
        recent_cooperation_rate = recent_cooperations / (rounds_to_check * n)
        threshold_rate = m / n
        if recent_cooperation_rate >= threshold_rate:
            return Action.C
        else:
            return Action.D

    def _defensive_cooperate(self, history: PlayerHistory, n: int, m: int, r: int, current_round: int) -> Action:
        my_last_action = history.my_actions[-1]
        opponent_last_actions = history.opponent_actions[-1]
        cooperators_last_round = int(my_last_action) + sum(opponent_last_actions)
        if cooperators_last_round >= m - 1:
            return Action.C
        if current_round > r * 0.7:
            if cooperators_last_round >= m - 2:
                return Action.C
            else:
                return Action.D
        if cooperators_last_round >= m / 2:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_108(BaseStrategy):
    """
    Adaptive Trust Builder: A cooperative strategy that starts with trust, adapts to group behavior,
    and maintains cooperative momentum while being resilient to exploitation. Uses threshold-based
    decision making with historical learning and calculated forgiveness.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        last_round_idx = history.round_number - 1
        cooperators_last_round = int(history.my_actions[last_round_idx]) + sum(history.opponent_actions[last_round_idx])
        total_cooperators_so_far = sum(history.my_actions) + np.sum(history.opponent_actions)
        total_decisions_so_far = history.round_number * self.n
        average_cooperation_rate = total_cooperators_so_far / total_decisions_so_far
        if current_round == self.r:
            if average_cooperation_rate >= 0.3 or cooperators_last_round >= self.m:
                return Action.C
            else:
                return Action.D
        if cooperators_last_round >= self.m:
            return Action.C
        elif cooperators_last_round >= self.m - 1:
            return Action.C
        elif average_cooperation_rate >= 0.4:
            return Action.C
        elif random.random() < 0.2:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_109(BaseStrategy):
    """
    Adaptive Threshold Guardian: A cooperative strategy that starts generous,
    monitors threshold achievement, and adapts based on group cooperation trends
    while maintaining resilience against exploitation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_num = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        m = self.game_description.m
        if round_num == n_rounds:
            return self._final_round_decision(history)
        return self._adaptive_decision(history)

    def _count_cooperators_in_round(self, history: PlayerHistory, round_idx: int) -> int:
        """Count total cooperators (including self) in a specific round (0-indexed)."""
        if round_idx >= history.round_number:
            return 0
        opponent_cooperators = int(sum(history.opponent_actions[round_idx]))
        self_cooperated = int(history.my_actions[round_idx])
        return opponent_cooperators + self_cooperated

    def _adaptive_decision(self, history: PlayerHistory) -> Action:
        """Decision logic for rounds 2 to r-1."""
        m = self.game_description.m
        last_round_idx = history.round_number - 1
        cooperators_last_round = self._count_cooperators_in_round(history, last_round_idx)
        cooperation_deficit = max(0, m - cooperators_last_round)
        recent_rounds = min(3, history.round_number)
        total_recent_cooperators = 0
        for i in range(recent_rounds):
            round_idx = history.round_number - 1 - i
            total_recent_cooperators += self._count_cooperators_in_round(history, round_idx)
        avg_recent_cooperation = total_recent_cooperators / recent_rounds if recent_rounds > 0 else 0
        cooperation_trend = avg_recent_cooperation - cooperators_last_round
        if cooperators_last_round >= m:
            if cooperation_trend >= -0.5:
                return Action.C
            else:
                return Action.C
        elif cooperation_deficit <= 2:
            return Action.C
        elif cooperation_deficit > 2 and avg_recent_cooperation < m / 2:
            if random.random() < 0.3:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C

    def _final_round_decision(self, history: PlayerHistory) -> Action:
        """Decision logic for the final round."""
        m = self.game_description.m
        last_round_idx = history.round_number - 1
        cooperators_last_round = self._count_cooperators_in_round(history, last_round_idx)
        total_cooperators = 0
        for round_idx in range(history.round_number):
            total_cooperators += self._count_cooperators_in_round(history, round_idx)
        avg_cooperation_overall = total_cooperators / history.round_number if history.round_number > 0 else 0
        if cooperators_last_round >= m:
            return Action.C
        elif avg_cooperation_overall >= m * 0.8:
            return Action.C
        elif cooperators_last_round >= m - 2:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_110(BaseStrategy):
    """
    Optimistic Threshold Guardian: A cooperative strategy that defaults to cooperation
    while being sensitive to threshold dynamics and maintaining cooperative identity.
    Always cooperates in first and last rounds, and uses trend analysis and threshold
    proximity to guide decisions in middle rounds.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        final_round = self.game_description.n_rounds
        m = self.game_description.m
        n = self.game_description.n_players
        if current_round == final_round:
            return Action.C
        last_round_idx = history.round_number - 1
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        my_last_action = history.my_actions[last_round_idx]
        total_cooperators_last_round = opponent_cooperators + (1 if my_last_action else 0)
        if total_cooperators_last_round >= m:
            return Action.C
        if total_cooperators_last_round >= m - 1:
            return Action.C
        recent_rounds = min(3, history.round_number)
        total_recent_cooperators = 0
        for i in range(recent_rounds):
            round_idx = history.round_number - 1 - i
            round_opponent_cooperators = sum(history.opponent_actions[round_idx])
            round_my_action = history.my_actions[round_idx]
            round_total_cooperators = round_opponent_cooperators + (1 if round_my_action else 0)
            total_recent_cooperators += round_total_cooperators
        recent_cooperation_trend = total_recent_cooperators / (recent_rounds * n)
        if recent_cooperation_trend > 0.3:
            return Action.C
        my_cooperations = sum(history.my_actions)
        my_cooperation_rate = my_cooperations / history.round_number
        if my_cooperation_rate > 0.7:
            return Action.C
        return Action.C

class Strategy_COOPERATIVE_111(BaseStrategy):
    """
    Adaptive Threshold Guardian: A cooperative strategy that prioritizes collective welfare
    while being resilient to defection. Makes decisions based on expected cooperator counts
    using adaptive learning and trend analysis of opponent behavior.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self.optimism_factor = 0.1
        self.trend_weight = 0.2
        self.endgame_optimism = 0.2

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        expected_cooperators = self._calculate_expected_cooperators(history)
        expected_cooperators += self.optimism_factor
        if current_round >= self.r - 1:
            expected_cooperators += self.endgame_optimism
        if expected_cooperators >= self.m - 1:
            return Action.C
        else:
            return Action.D

    def _calculate_expected_cooperators(self, history: PlayerHistory) -> float:
        """Calculate expected number of cooperators among opponents."""
        current_round = history.round_number
        recent_window = min(5, max(1, self.r // 4))
        expected_cooperators = 0.0
        for opponent_idx in range(self.n - 1):
            recent_coop_rate = self._calculate_recent_cooperation_rate(history, opponent_idx, current_round, recent_window)
            trend_adjustment = self._calculate_trend(history, opponent_idx, current_round, recent_window)
            reliability = recent_coop_rate + trend_adjustment
            reliability = max(0.0, min(1.0, reliability))
            expected_cooperators += reliability
        return expected_cooperators

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory, opponent_idx: int, current_round: int, window: int) -> float:
        """Calculate cooperation rate for an opponent in recent rounds."""
        start_round = max(0, current_round - window)
        end_round = current_round
        if start_round >= end_round:
            return 0.5
        cooperations = 0
        total_rounds = 0
        for round_idx in range(start_round, end_round):
            if history.opponent_actions[round_idx, opponent_idx]:
                cooperations += 1
            total_rounds += 1
        return cooperations / total_rounds if total_rounds > 0 else 0.5

    def _calculate_trend(self, history: PlayerHistory, opponent_idx: int, current_round: int, window: int) -> float:
        """Calculate trend adjustment based on recent vs earlier cooperation."""
        if current_round < 3:
            return 0.0
        recent_start = max(0, current_round - 3)
        recent_cooperations = 0
        recent_total = 0
        for round_idx in range(recent_start, current_round):
            if history.opponent_actions[round_idx, opponent_idx]:
                recent_cooperations += 1
            recent_total += 1
        recent_rate = recent_cooperations / recent_total if recent_total > 0 else 0.5
        earlier_end = max(0, current_round - 3)
        earlier_start = max(0, current_round - 6)
        if earlier_start >= earlier_end:
            return 0.0
        earlier_cooperations = 0
        earlier_total = 0
        for round_idx in range(earlier_start, earlier_end):
            if history.opponent_actions[round_idx, opponent_idx]:
                earlier_cooperations += 1
            earlier_total += 1
        earlier_rate = earlier_cooperations / earlier_total if earlier_total > 0 else 0.5
        trend = (recent_rate - earlier_rate) * self.trend_weight
        return max(-0.2, min(0.2, trend))

class Strategy_COOPERATIVE_112(BaseStrategy):
    """
    Adaptive Trust Builder: A cooperative strategy that prioritizes collective welfare
    while maintaining resilience against exploitation. Uses threshold awareness,
    trend sensitivity, and forgiveness mechanisms to build and maintain cooperation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.r:
            return self._last_round_decision(history)
        return self._adaptive_cooperation_decision(history)

    def _last_round_decision(self, history: PlayerHistory) -> Action:
        """Decision logic for the final round."""
        cooperation_rate_recent = self._get_recent_cooperation_rate(history, 3)
        threshold_rate = self.m / self.n
        near_threshold_rate = (self.m - 1) / self.n
        if cooperation_rate_recent >= threshold_rate:
            return Action.C
        elif cooperation_rate_recent >= near_threshold_rate:
            return Action.C
        else:
            return Action.D

    def _adaptive_cooperation_decision(self, history: PlayerHistory) -> Action:
        """Adaptive cooperation logic for rounds 2 to r-1."""
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx]) + int(history.my_actions[last_round_idx])
        cooperation_rate = cooperators_last_round / self.n
        recent_trend = self._get_recent_cooperation_rate(history, 3)
        threshold_rate = self.m / self.n
        near_threshold_rate = (self.m - 1) / self.n
        adjusted_threshold = self._get_adjusted_threshold()
        if cooperation_rate >= threshold_rate:
            return Action.C
        elif cooperation_rate >= near_threshold_rate and self._is_trend_increasing(history):
            return Action.C
        elif cooperation_rate >= 0.4 and history.my_actions[last_round_idx]:
            return Action.C
        else:
            return Action.D

    def _get_recent_cooperation_rate(self, history: PlayerHistory, window: int) -> float:
        """Calculate average cooperation rate over the last 'window' rounds."""
        rounds_completed = history.round_number
        start_idx = max(0, rounds_completed - window)
        total_cooperation = 0
        total_observations = 0
        for round_idx in range(start_idx, rounds_completed):
            round_cooperators = sum(history.opponent_actions[round_idx]) + int(history.my_actions[round_idx])
            total_cooperation += round_cooperators
            total_observations += self.n
        if total_observations == 0:
            return 0.0
        return total_cooperation / total_observations

    def _is_trend_increasing(self, history: PlayerHistory) -> bool:
        """Check if cooperation trend is increasing over the last 3 rounds."""
        rounds_completed = history.round_number
        if rounds_completed < 2:
            return True
        recent_rate = self._get_recent_cooperation_rate(history, 2)
        earlier_rate = self._get_recent_cooperation_rate(history, min(4, rounds_completed)) if rounds_completed > 2 else recent_rate
        return recent_rate >= earlier_rate

    def _get_adjusted_threshold(self) -> float:
        """Apply edge case adjustments to cooperation threshold."""
        base_threshold = self.m / self.n
        if self.n <= 4:
            base_threshold = min(1.0, base_threshold * 1.1)
        if self.m > 0.7 * self.n:
            base_threshold = base_threshold * 0.9
        if self.k < 1.5:
            base_threshold = min(1.0, base_threshold * 1.05)
        return base_threshold

class Strategy_COOPERATIVE_113(BaseStrategy):
    """
    Adaptive Threshold Guardian: A cooperative strategy that prioritizes collective welfare
    while being resilient to exploitation. Uses a three-tier decision system to maintain
    cooperation when possible and adapt to ensure the critical threshold is met.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        k = self.game_description.k
        r = self.game_description.n_rounds
        round_num = history.round_number + 1
        last_round_idx = history.round_number - 1
        my_last_action = history.my_actions[last_round_idx]
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        coop_count = int(opponent_cooperators) + int(my_last_action)
        coop_rate = coop_count / n
        if round_num == r:
            recent_coop_rate = self._calculate_recent_cooperation_rate(history, 3)
            return Action.C if recent_coop_rate > 0.6 else Action.D
        if coop_count >= m + 1:
            return Action.C
        if coop_count < m - 1:
            threshold = 0.35 if k < 1.5 else 0.3
            threshold = 0.2 if n <= 4 else threshold
            threshold = 0.15 if m > 0.7 * n else threshold
            return Action.C if coop_rate >= threshold else Action.D
        if coop_count in [m - 1, m]:
            return Action.C
        return Action.C

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory, num_rounds: int) -> float:
        """Calculate cooperation rate over the last num_rounds rounds."""
        total_rounds = history.round_number
        start_round = max(0, total_rounds - num_rounds)
        total_cooperators = 0
        total_players = 0
        for round_idx in range(start_round, total_rounds):
            my_action = history.my_actions[round_idx]
            opponent_cooperators = sum(history.opponent_actions[round_idx])
            round_cooperators = int(opponent_cooperators) + int(my_action)
            total_cooperators += round_cooperators
            total_players += self.game_description.n_players
        return total_cooperators / total_players if total_players > 0 else 0.0

class Strategy_COOPERATIVE_114(BaseStrategy):
    """
    Adaptive Threshold Guardian strategy for Collective Risk Dilemma.
    
    Prioritizes collective welfare while maintaining resilience against exploitation.
    Operates on cooperative leadership with adaptive protection - actively working 
    to achieve cooperation threshold while adapting to observed opponent behavior patterns.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.r:
            return self._final_round_decision(history)
        else:
            return self._adaptive_phase_decision(history)

    def _adaptive_phase_decision(self, history: PlayerHistory) -> Action:
        total_cooperations = 0
        total_possible = 0
        for round_idx in range(history.round_number):
            if history.my_actions[round_idx]:
                total_cooperations += 1
            total_possible += 1
            opponent_coops_this_round = sum(history.opponent_actions[round_idx])
            total_cooperations += opponent_coops_this_round
            total_possible += len(history.opponent_actions[round_idx])
        historical_coop_rate = total_cooperations / total_possible
        expected_cooperators_this_round = historical_coop_rate * self.n
        if expected_cooperators_this_round >= self.m:
            return Action.C
        elif expected_cooperators_this_round >= self.m - 1:
            return Action.C
        else:
            rounds_since_threshold_met = self._count_rounds_since_last_success(history)
            if rounds_since_threshold_met <= 2:
                return Action.C
            else:
                return Action.D

    def _final_round_decision(self, history: PlayerHistory) -> Action:
        recent_success_rate = self._calculate_recent_success_rate(history)
        if recent_success_rate >= 0.5:
            return Action.C
        else:
            return Action.D

    def _count_rounds_since_last_success(self, history: PlayerHistory) -> int:
        """Count rounds since threshold was last met, starting from most recent."""
        rounds_since = 0
        for round_idx in range(history.round_number - 1, -1, -1):
            cooperators = 0
            if history.my_actions[round_idx]:
                cooperators += 1
            cooperators += sum(history.opponent_actions[round_idx])
            if cooperators >= self.m:
                break
            else:
                rounds_since += 1
        return rounds_since

    def _calculate_recent_success_rate(self, history: PlayerHistory) -> float:
        """Calculate success rate in last 3 rounds (or fewer if game is shorter)."""
        recent_rounds = min(3, history.round_number)
        if recent_rounds == 0:
            return 0.0
        successful_rounds = 0
        start_idx = max(0, history.round_number - recent_rounds)
        for round_idx in range(start_idx, history.round_number):
            cooperators = 0
            if history.my_actions[round_idx]:
                cooperators += 1
            cooperators += sum(history.opponent_actions[round_idx])
            if cooperators >= self.m:
                successful_rounds += 1
        return successful_rounds / recent_rounds

class Strategy_COOPERATIVE_115(BaseStrategy):
    """
    Optimistic Threshold Guardian: A cooperative strategy that prioritizes collective welfare
    while being pragmatic about threshold requirements. Always cooperates in round 1, then
    uses adaptive cooperation based on cooperation trends and threshold likelihood.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        rounds_to_check = min(3, history.round_number)
        start_round = max(0, history.round_number - rounds_to_check)
        recent_cooperation_counts = []
        for round_idx in range(start_round, history.round_number):
            cooperators_in_round = sum(history.opponent_actions[round_idx])
            if history.my_actions[round_idx]:
                cooperators_in_round += 1
            recent_cooperation_counts.append(cooperators_in_round)
        if recent_cooperation_counts:
            recent_cooperation_rate = sum(recent_cooperation_counts) / (len(recent_cooperation_counts) * n)
        else:
            recent_cooperation_rate = 0.5
        expected_cooperators = recent_cooperation_rate * (n - 1)
        if expected_cooperators >= m - 1:
            return Action.C
        elif expected_cooperators >= m - 2:
            return Action.C
        else:
            if history.round_number >= 2:
                earlier_rounds = min(2, max(1, history.round_number - 3))
                earlier_start = max(0, start_round - earlier_rounds)
                earlier_cooperation_counts = []
                for round_idx in range(earlier_start, start_round):
                    if round_idx >= 0:
                        cooperators_in_round = sum(history.opponent_actions[round_idx])
                        if history.my_actions[round_idx]:
                            cooperators_in_round += 1
                        earlier_cooperation_counts.append(cooperators_in_round)
                if earlier_cooperation_counts:
                    earlier_cooperation_rate = sum(earlier_cooperation_counts) / (len(earlier_cooperation_counts) * n)
                    if recent_cooperation_rate > earlier_cooperation_rate:
                        return Action.C
            return Action.C

class Strategy_COOPERATIVE_116(BaseStrategy):
    """
    Adaptive Threshold Guardian: A cooperative strategy that prioritizes collective welfare
    while maintaining resilience against exploitation. Cooperates by default and uses
    multiple pathways to maintain cooperation even after temporary failures.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        prev_round_idx = history.round_number - 1
        my_prev_action = history.my_actions[prev_round_idx]
        opponent_prev_actions = history.opponent_actions[prev_round_idx]
        prev_cooperators = int(my_prev_action) + sum(opponent_prev_actions)
        if prev_cooperators >= m:
            return Action.C
        if prev_cooperators == m - 1:
            return Action.C
        total_rounds_played = history.round_number
        failed_rounds = 0
        for round_idx in range(total_rounds_played):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            cooperators = int(my_action) + sum(opponent_actions)
            if cooperators < m:
                failed_rounds += 1
        if failed_rounds / total_rounds_played < 0.25:
            return Action.C
        cooperative_players = 0
        my_cooperation_rate = sum(history.my_actions) / total_rounds_played
        if my_cooperation_rate >= 0.75:
            cooperative_players += 1
        for player_idx in range(n - 1):
            player_cooperations = sum(history.opponent_actions[:, player_idx])
            player_cooperation_rate = player_cooperations / total_rounds_played
            if player_cooperation_rate >= 0.75:
                cooperative_players += 1
        if cooperative_players / n >= 0.5:
            return Action.C
        if current_round == r and prev_cooperators >= m - 2:
            return Action.C
        return Action.D

class Strategy_COOPERATIVE_117(BaseStrategy):
    """
    Optimistic Guardian: A cooperative strategy that maintains trust scores and provides
    strategic cooperation to ensure collective success while protecting against exploitation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.group_trust_score = 0.8

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        recent_rounds = min(3, history.round_number)
        if recent_rounds > 0:
            recent_cooperation_total = 0
            recent_possible = 0
            for i in range(recent_rounds):
                round_idx = history.round_number - 1 - i
                recent_cooperation_total += sum(history.opponent_actions[round_idx])
                recent_possible += len(history.opponent_actions[round_idx])
            recent_cooperation_rate = recent_cooperation_total / recent_possible if recent_possible > 0 else 0.5
            self.group_trust_score = 0.7 * self.group_trust_score + 0.3 * recent_cooperation_rate
        predicted_cooperators = 0
        n_opponents = n - 1
        for opponent_idx in range(n_opponents):
            opponent_cooperations = 0
            total_rounds = history.round_number
            for round_idx in range(total_rounds):
                if history.opponent_actions[round_idx][opponent_idx]:
                    opponent_cooperations += 1
            player_coop_rate = opponent_cooperations / total_rounds if total_rounds > 0 else 0.5
            if player_coop_rate > self.group_trust_score:
                predicted_cooperators += 1
        if predicted_cooperators >= m:
            if self.group_trust_score > 0.6 and recent_cooperation_rate > 0.5:
                return Action.C
            elif predicted_cooperators >= m + 2:
                return Action.D
            else:
                return Action.C
        elif predicted_cooperators == m - 1:
            return Action.C
        elif current_round == r:
            return Action.D
        elif self.group_trust_score > 0.7:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_118(BaseStrategy):
    """
    Threshold-Aware Gradual Forgiveness: A cooperative strategy that maintains collective focus
    while building resilience against exploitation through gradual forgiveness and threshold monitoring.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.forgiveness_debt = 0
        self.consecutive_failures = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        last_round_idx = history.round_number - 1
        my_last_action = history.my_actions[last_round_idx]
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        total_cooperators = int(my_last_action) + opponent_cooperators
        if total_cooperators >= self.game_description.m:
            self.consecutive_failures = 0
            self.forgiveness_debt = max(0, self.forgiveness_debt - 1)
        else:
            self.consecutive_failures += 1
            shortfall = self.game_description.m - total_cooperators
            self.forgiveness_debt += shortfall
        if self.consecutive_failures >= 3:
            return Action.D
        if self.forgiveness_debt > self.game_description.n_players * 0.4:
            return Action.D
        if current_round == self.game_description.n_rounds:
            return Action.C
        return Action.C

class Strategy_COOPERATIVE_119(BaseStrategy):
    """
    Generous Threshold Guardian: A cooperative strategy that prioritizes collective welfare
    while maintaining resilience against exploitation. Aims to establish and maintain
    cooperation by being generous in building trust, vigilant in protecting the collective
    threshold, and forgiving enough to enable recovery from temporary defections.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.consecutive_failures = 0
        self.teaching_mode_countdown = 0
        self.teaching_cooperate_turn = True

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        recent_cooperation_rate = self._calculate_recent_cooperation(history, window=3)
        last_round_cooperators = self._count_last_round_cooperators(history)
        if last_round_cooperators < m:
            self.consecutive_failures += 1
        else:
            self.consecutive_failures = 0
        if self.teaching_mode_countdown > 0:
            self.teaching_mode_countdown -= 1
            if self.teaching_cooperate_turn:
                self.teaching_cooperate_turn = False
                return Action.C
            else:
                self.teaching_cooperate_turn = True
                return Action.D
        if self.consecutive_failures >= 3 and recent_cooperation_rate < 0.2:
            self.teaching_mode_countdown = 4
            self.teaching_cooperate_turn = True
            return Action.C
        safety_margin = max(1, math.ceil(m * 0.3))
        target_cooperators = m + safety_margin
        if last_round_cooperators >= target_cooperators:
            return Action.C if random.random() < 0.9 else Action.D
        elif last_round_cooperators >= m:
            return Action.C
        elif last_round_cooperators >= m - 2:
            return Action.C
        else:
            return self._adaptive_response(recent_cooperation_rate, current_round, r)

    def _calculate_recent_cooperation(self, history: PlayerHistory, window: int) -> float:
        """Calculate cooperation rate over recent rounds."""
        current_round = history.round_number
        start_round = max(0, current_round - window)
        if current_round == 0:
            return 1.0
        total_actions = 0
        total_cooperations = 0
        for round_idx in range(start_round, current_round):
            if history.my_actions[round_idx]:
                total_cooperations += 1
            total_actions += 1
            for opponent_idx in range(len(history.opponent_actions[round_idx])):
                if history.opponent_actions[round_idx][opponent_idx]:
                    total_cooperations += 1
                total_actions += 1
        return total_cooperations / total_actions if total_actions > 0 else 1.0

    def _count_last_round_cooperators(self, history: PlayerHistory) -> int:
        """Count total cooperators in the last round."""
        if history.round_number == 0:
            return self.game_description.n_players
        last_round_idx = history.round_number - 1
        cooperators = 0
        if history.my_actions[last_round_idx]:
            cooperators += 1
        for opponent_action in history.opponent_actions[last_round_idx]:
            if opponent_action:
                cooperators += 1
        return cooperators

    def _adaptive_response(self, cooperation_rate: float, current_round: int, total_rounds: int) -> Action:
        """Adaptive response for low cooperation scenarios."""
        if current_round <= total_rounds * 0.3:
            return Action.C if cooperation_rate > 0.2 else Action.D
        elif current_round <= total_rounds * 0.7:
            return Action.C if cooperation_rate > 0.4 else Action.D
        elif cooperation_rate > 0.3 or current_round > total_rounds * 0.85:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_120(BaseStrategy):
    """
    Collective Guardian: A cooperative strategy that prioritizes collective welfare while maintaining
    resilience against exploitation. Always starts cooperatively, monitors threshold dynamics, and
    adapts cooperation based on group behavior while preventing collective failure.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.m = game_description.m
        self.k = game_description.k
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        lookback = min(3, history.round_number)
        recent_rounds = history.round_number - lookback
        recent_cooperators = 0
        total_recent_decisions = 0
        for round_idx in range(recent_rounds, history.round_number):
            round_cooperators = sum(history.opponent_actions[round_idx])
            if history.my_actions[round_idx]:
                round_cooperators += 1
            recent_cooperators += round_cooperators
            total_recent_decisions += self.n
        recent_cooperation_rate = recent_cooperators / total_recent_decisions if total_recent_decisions > 0 else 0.5
        total_cooperators = 0
        total_decisions = 0
        for round_idx in range(history.round_number):
            round_cooperators = sum(history.opponent_actions[round_idx])
            if history.my_actions[round_idx]:
                round_cooperators += 1
            total_cooperators += round_cooperators
            total_decisions += self.n
        overall_cooperation_rate = total_cooperators / total_decisions if total_decisions > 0 else 0.5
        expected_cooperators = int(recent_cooperation_rate * (self.n - 1))
        safety_buffer = 1 if self.n > 4 else 0
        if expected_cooperators >= self.m + safety_buffer:
            return Action.C
        elif expected_cooperators >= self.m - 1:
            return Action.C
        else:
            return self._conditional_cooperate(history, current_round)

    def _conditional_cooperate(self, history, current_round):
        """Handle low cooperation scenarios with rescue mode logic"""
        if current_round <= self.r * 0.7:
            return Action.C
        recent_rounds_to_check = min(2, history.round_number)
        recent_cooperators = 0
        for i in range(recent_rounds_to_check):
            round_idx = history.round_number - 1 - i
            round_cooperators = sum(history.opponent_actions[round_idx])
            if history.my_actions[round_idx]:
                round_cooperators += 1
            recent_cooperators += round_cooperators
        avg_recent_cooperators = recent_cooperators / recent_rounds_to_check if recent_rounds_to_check > 0 else 0
        if avg_recent_cooperators >= self.m - 1:
            return Action.C
        if current_round == self.r:
            last_round_cooperators = sum(history.opponent_actions[-1])
            if last_round_cooperators >= self.m - 1:
                return Action.C
        if history.round_number >= 2:
            failures = 0
            for i in range(min(2, history.round_number)):
                round_idx = history.round_number - 1 - i
                round_cooperators = sum(history.opponent_actions[round_idx])
                if history.my_actions[round_idx]:
                    round_cooperators += 1
                if round_cooperators < self.m:
                    failures += 1
            if failures >= 2 and current_round <= self.r * 0.9:
                return Action.C
        if current_round > self.r * 0.8:
            return Action.C
        return Action.D

class Strategy_COOPERATIVE_121(BaseStrategy):
    """
    Threshold Guardian with Forgiveness: A cooperative strategy that prioritizes achieving 
    the collective threshold while maintaining cooperation and protecting against exploitation.
    Balances group success with conditional cooperation based on others' behavior.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        prev_round_idx = history.round_number - 1
        prev_cooperators = int(history.my_actions[prev_round_idx]) + sum(history.opponent_actions[prev_round_idx])
        if current_round == r:
            if prev_cooperators == m - 1:
                return Action.C
            total_success = 0
            for round_idx in range(history.round_number):
                round_cooperators = int(history.my_actions[round_idx]) + sum(history.opponent_actions[round_idx])
                if round_cooperators >= m:
                    total_success += 1
            success_rate = total_success / history.round_number
            if success_rate >= 0.8:
                return Action.C
            else:
                return Action.D
        if prev_cooperators >= m:
            coop_prob = 0.9 if n <= 4 else 0.8
            return Action.C if random.random() < coop_prob else Action.D
        elif prev_cooperators == m - 1:
            return Action.C
        else:
            my_prev_action = history.my_actions[prev_round_idx]
            if m > n / 2 and prev_cooperators >= m - 2:
                return Action.C
            if my_prev_action and prev_cooperators >= m / 2:
                return Action.C
            else:
                return Action.D

class Strategy_COOPERATIVE_122(BaseStrategy):
    """
    Adaptive Threshold Guardian: A cooperative strategy that prioritizes collective welfare
    while maintaining resilience against exploitation. Uses adaptive cooperation based on
    historical cooperation rates, threshold proximity, and trend analysis.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        round_num = history.round_number + 1
        total_cooperators = 0
        for round_idx in range(history.round_number):
            if history.my_actions[round_idx]:
                total_cooperators += 1
            total_cooperators += sum(history.opponent_actions[round_idx])
        rounds_played = history.round_number
        coop_rate = total_cooperators / (n * rounds_played)
        if round_num == r:
            avg_cooperators_per_round = total_cooperators / rounds_played
            if coop_rate > 0.6 or avg_cooperators_per_round >= m - 1:
                return Action.C
            else:
                return Action.D
        if n <= 4:
            if round_num == r and coop_rate < 0.5:
                return Action.D
            return Action.C
        if coop_rate >= (m - 1) / n:
            return Action.C
        if coop_rate < (m - 2) / n:
            return Action.D
        last_round_idx = history.round_number - 1
        last_round_cooperators = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            last_round_cooperators += 1
        if last_round_cooperators == m - 1:
            return Action.C
        if last_round_cooperators == m:
            return Action.C
        if history.round_number >= 2:
            last_cooperators = sum(history.opponent_actions[last_round_idx])
            if history.my_actions[last_round_idx]:
                last_cooperators += 1
            second_last_cooperators = sum(history.opponent_actions[last_round_idx - 1])
            if history.my_actions[last_round_idx - 1]:
                second_last_cooperators += 1
            recent_trend = last_cooperators - second_last_cooperators
            if recent_trend >= 0:
                return Action.C
            elif round_num % 10 < 3:
                return Action.D
            else:
                return Action.C
        return Action.C

class Strategy_COOPERATIVE_123(BaseStrategy):
    """
    Trust-Building Threshold Monitor: A cooperative strategy that prioritizes collective welfare
    while maintaining resilience against exploitation. Always cooperates in first round,
    then adapts based on threshold achievement and failure patterns.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.consecutive_failures = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        last_round_idx = history.round_number - 1
        my_last_action = history.my_actions[last_round_idx]
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        total_cooperators = opponent_cooperators + (1 if my_last_action else 0)
        if total_cooperators < m:
            self.consecutive_failures += 1
        else:
            self.consecutive_failures = 0
        rounds_remaining = r - history.round_number
        if total_cooperators >= m:
            return Action.C
        elif total_cooperators == m - 1:
            return Action.C
        elif total_cooperators >= m - 2 and rounds_remaining <= 3:
            return Action.C
        elif total_cooperators < m - 2:
            failure_threshold = 3 if n <= 4 else 2
            if self.consecutive_failures >= failure_threshold:
                return Action.D
            else:
                return Action.C
        if m > n / 2 and total_cooperators >= m - 3:
            return Action.C
        return Action.C

class Strategy_COOPERATIVE_124(BaseStrategy):
    """
    Threshold Guardian with Trust Building Strategy
    
    A cooperative strategy that prioritizes collective welfare while being strategically aware 
    of threshold dynamics. Always cooperates in the first round to establish trust, then uses
    historical cooperation patterns to estimate whether the group will meet the threshold,
    cooperating when pivotal or when trust levels are high.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.trust_threshold = 0.6
        self.pessimism_factor = 0.8

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        cooperation_rates = []
        trusted_players = 0
        for player_idx in range(n - 1):
            player_actions = history.opponent_actions[:, player_idx]
            coop_rate = np.mean(player_actions)
            cooperation_rates.append(coop_rate)
            if coop_rate >= self.trust_threshold:
                trusted_players += 1
        if len(cooperation_rates) > 0:
            avg_cooperation_rate = np.mean(cooperation_rates)
        else:
            avg_cooperation_rate = 0.0
        expected_cooperators = trusted_players + (n - trusted_players - 1) * avg_cooperation_rate * self.pessimism_factor
        if expected_cooperators >= m - 1:
            if avg_cooperation_rate >= 0.5:
                return Action.C
            elif expected_cooperators >= m:
                if random.random() < 0.2:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.C
        elif expected_cooperators >= m - 2:
            return Action.C
        elif trusted_players >= 2:
            return Action.C
        elif current_round <= r // 2:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_125(BaseStrategy):
    """
    Trust-Building Conditional Cooperator: A cooperative strategy that builds trust
    through consistent cooperation while being responsive to group dynamics. Cooperates
    first to signal intent, maintains cooperation through forgiveness, and only defects
    after sustained evidence of group failure.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.consecutive_failures = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        t = history.round_number + 1
        rounds_to_check = min(3, history.round_number)
        recent_cooperators_total = 0
        for i in range(rounds_to_check):
            round_idx = history.round_number - 1 - i
            round_cooperators = sum(history.opponent_actions[round_idx]) + (1 if history.my_actions[round_idx] else 0)
            recent_cooperators_total += round_cooperators
        recent_cooperators_avg = recent_cooperators_total / rounds_to_check if rounds_to_check > 0 else 0
        total_cooperators = 0
        for round_idx in range(history.round_number):
            round_cooperators = sum(history.opponent_actions[round_idx]) + (1 if history.my_actions[round_idx] else 0)
            total_cooperators += round_cooperators
            if round_cooperators < m:
                if round_idx == history.round_number - 1:
                    self.consecutive_failures += 1
            elif round_idx == history.round_number - 1:
                self.consecutive_failures = 0
        avg_cooperation_rate = total_cooperators / (history.round_number * n) if history.round_number > 0 else 0
        trust_momentum = 0
        if history.round_number >= 4:
            recent_2_cooperators = 0
            older_2_cooperators = 0
            for i in range(2):
                round_idx = history.round_number - 1 - i
                recent_2_cooperators += sum(history.opponent_actions[round_idx]) + (1 if history.my_actions[round_idx] else 0)
                round_idx = history.round_number - 3 - i
                if round_idx >= 0:
                    older_2_cooperators += sum(history.opponent_actions[round_idx]) + (1 if history.my_actions[round_idx] else 0)
            trust_momentum = (recent_2_cooperators - older_2_cooperators) / n
        if self.consecutive_failures >= 3 and t > r / 2:
            if recent_cooperators_avg < m - 2:
                return Action.D
        if recent_cooperators_avg >= m - 1:
            return Action.C
        if avg_cooperation_rate >= m / n * 0.8:
            return Action.C
        if trust_momentum > 0 and recent_cooperators_avg >= m - 2:
            return Action.C
        if t <= r * 0.7:
            return Action.C
        if recent_cooperators_avg >= m - 3:
            return Action.C
        return Action.D

class Strategy_COOPERATIVE_126(BaseStrategy):
    """
    Adaptive Collective Guardian: A cooperative strategy that prioritizes collective welfare
    while being adaptive to opponent behavior patterns. Tracks cooperation rates and makes
    decisions based on threshold probability and reciprocal cooperation principles.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self.player_cooperation_rates = [0.5] * (self.n - 1)
        self.my_cooperation_rate = 0.8
        self.round_cooperation_counts = []
        self.cooperation_success_rate = 0.5

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        self._update_tracking(history)
        expected_cooperators = sum(self.player_cooperation_rates)
        expected_with_me = expected_cooperators + 1
        expected_without_me = expected_cooperators
        if current_round == self.r:
            if expected_without_me >= self.m:
                return Action.D
            else:
                return Action.C
        elif expected_without_me < self.m and expected_with_me >= self.m:
            return Action.C
        elif expected_with_me >= self.m + 2:
            return Action.C
        elif len(self.round_cooperation_counts) > 0 and self.round_cooperation_counts[-1] >= self.m:
            cooperation_probability = 0.7 + 0.2 * self.cooperation_success_rate
            if random.random() < cooperation_probability:
                return Action.C
            else:
                return Action.D
        else:
            cooperation_probability = 0.6
            if random.random() < cooperation_probability:
                return Action.C
            else:
                return Action.D

    def _update_tracking(self, history: PlayerHistory):
        """Update internal tracking variables based on observed history."""
        current_round_idx = history.round_number - 1
        if len(self.round_cooperation_counts) <= current_round_idx:
            my_action = 1 if history.my_actions[current_round_idx] else 0
            opponent_cooperators = sum(history.opponent_actions[current_round_idx])
            total_cooperators = my_action + opponent_cooperators
            self.round_cooperation_counts.append(total_cooperators)
        for player_idx in range(self.n - 1):
            player_actions = history.opponent_actions[:history.round_number, player_idx]
            cooperation_count = sum(player_actions)
            total_actions = len(player_actions)
            if total_actions > 0:
                new_rate = cooperation_count / total_actions
                alpha = 0.3
                self.player_cooperation_rates[player_idx] = alpha * new_rate + (1 - alpha) * self.player_cooperation_rates[player_idx]
        if len(self.round_cooperation_counts) > 0:
            successful_rounds = sum((1 for count in self.round_cooperation_counts if count >= self.m))
            self.cooperation_success_rate = successful_rounds / len(self.round_cooperation_counts)
        if len(self.round_cooperation_counts) >= 3:
            recent_failures = sum((1 for count in self.round_cooperation_counts[-3:] if count < self.m))
            if recent_failures == 3:
                for i in range(len(self.player_cooperation_rates)):
                    self.player_cooperation_rates[i] = min(0.9, self.player_cooperation_rates[i] + 0.2)
        for i in range(len(self.player_cooperation_rates)):
            self.player_cooperation_rates[i] = max(0.3, self.player_cooperation_rates[i])

class Strategy_COOPERATIVE_127(BaseStrategy):
    """
    Optimistic Threshold Guardian: A cooperative strategy that maintains cooperative momentum
    while being threshold-aware and resilient to defections. Focuses on achieving the minimum
    threshold efficiently while adapting to group cooperation patterns.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        last_round_idx = history.round_number - 1
        my_last_action = 1 if history.my_actions[last_round_idx] else 0
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        total_cooperators_last_round = my_last_action + opponent_cooperators
        cooperation_momentum = total_cooperators_last_round / n
        if current_round == r:
            if total_cooperators_last_round >= m - 1:
                return Action.C
            else:
                threshold_achieved_rounds = 0
                for round_idx in range(history.round_number):
                    my_action = 1 if history.my_actions[round_idx] else 0
                    opponent_coop = sum(history.opponent_actions[round_idx])
                    total_coop = my_action + opponent_coop
                    if total_coop >= m:
                        threshold_achieved_rounds += 1
                achievement_rate = threshold_achieved_rounds / history.round_number if history.round_number > 0 else 0
                if achievement_rate >= 0.4:
                    return Action.C
                else:
                    return Action.D
        if cooperation_momentum >= m / n:
            return Action.C
        elif cooperation_momentum >= (m - 1) / n:
            return Action.C
        elif cooperation_momentum >= 0.3:
            if history.round_number >= 3:
                recent_rounds = min(3, history.round_number)
                recent_coop_sum = 0
                for i in range(recent_rounds):
                    round_idx = history.round_number - 1 - i
                    my_action = 1 if history.my_actions[round_idx] else 0
                    opponent_coop = sum(history.opponent_actions[round_idx])
                    recent_coop_sum += my_action + opponent_coop
                avg_recent = recent_coop_sum / recent_rounds
                if history.round_number > recent_rounds:
                    earlier_rounds = history.round_number - recent_rounds
                    earlier_coop_sum = 0
                    for i in range(earlier_rounds):
                        my_action = 1 if history.my_actions[i] else 0
                        opponent_coop = sum(history.opponent_actions[i])
                        earlier_coop_sum += my_action + opponent_coop
                    avg_earlier = earlier_coop_sum / earlier_rounds
                    recent_trend = avg_recent - avg_earlier
                else:
                    recent_trend = 0
                if recent_trend >= 0:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_128(BaseStrategy):
    """
    Adaptive Threshold Guardian: A cooperative strategy that balances trust-building
    with protection against exploitation. Prioritizes achieving the collective threshold
    while maintaining forgiveness toward players who share cooperative goals.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        m = self.game_description.m
        last_round_idx = history.round_number - 1
        my_last_action = history.my_actions[last_round_idx]
        opponent_last_actions = history.opponent_actions[last_round_idx]
        cooperators_last_round = int(my_last_action) + sum(opponent_last_actions.astype(int))
        reliable_cooperators = 0
        conditional_cooperators = 0
        my_coop_rate = sum(history.my_actions.astype(int)) / history.round_number
        if my_coop_rate >= 0.75:
            reliable_cooperators += 1
        elif my_coop_rate >= 0.25:
            conditional_cooperators += 1
        for player_idx in range(self.game_description.n_players - 1):
            player_actions = history.opponent_actions[:history.round_number, player_idx]
            coop_rate = sum(player_actions.astype(int)) / history.round_number
            if coop_rate >= 0.75:
                reliable_cooperators += 1
            elif coop_rate >= 0.25:
                conditional_cooperators += 1
        if current_round == n_rounds:
            if reliable_cooperators >= m - 1:
                return Action.C
            if cooperators_last_round >= m:
                return Action.C
            if cooperators_last_round == m - 1:
                return Action.C
            return Action.D
        if reliable_cooperators >= m:
            return Action.C
        if reliable_cooperators + conditional_cooperators >= m:
            if cooperators_last_round >= m - 1:
                return Action.C
            else:
                return Action.C
        if reliable_cooperators + conditional_cooperators < m:
            if cooperators_last_round >= m - 1:
                return Action.C
            else:
                return Action.D
        return Action.C

class Strategy_AGGRESSIVE_65(BaseStrategy):
    """
    Exploitative Threshold Rider - An aggressive strategy that maximizes personal payoffs
    by exploiting cooperative players while minimizing personal risk. Only cooperates
    when absolutely necessary to avoid collective failure.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round <= self.n_rounds - 3:
            return Action.D
        if current_round == self.n_rounds:
            return Action.D
        last_round_index = history.round_number - 1
        last_round_cooperators = sum(history.opponent_actions[last_round_index])
        if history.my_actions[last_round_index]:
            last_round_cooperators += 1
        my_cooperation_needed = last_round_cooperators < self.m - 1
        threshold_attainable = last_round_cooperators >= self.m - 2
        if my_cooperation_needed and threshold_attainable:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_66(BaseStrategy):
    """
    Opportunistic Exploiter: An aggressive strategy that maximizes individual payoffs by exploiting 
    cooperative players while minimizing personal risk. Defaults to defection but cooperates only 
    when it provides clear individual advantage.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        expected_cooperators = self._count_expected_cooperators(history)
        cooperators_needed = self.m - expected_cooperators
        if cooperators_needed <= 0:
            return Action.D
        likely_defectors = self._count_likely_defectors(history)
        if cooperators_needed >= self.n - likely_defectors:
            return Action.D
        if self._am_critical_cooperator(expected_cooperators):
            if self._expected_payoff_from_cooperation() > 1:
                remaining_rounds = self.r - current_round
                if remaining_rounds > 2:
                    return Action.C
        return Action.D

    def _count_expected_cooperators(self, history: PlayerHistory) -> int:
        """Estimate how many opponents will cooperate based on their patterns."""
        if history.round_number == 0:
            return 0
        expected = 0
        for opponent in range(self.n - 1):
            cooperation_rate = self._get_cooperation_rate(history, opponent)
            if cooperation_rate > 0.7:
                expected += 1
            elif cooperation_rate > 0.4:
                recent_rounds = min(3, history.round_number)
                recent_cooperations = sum(history.opponent_actions[history.round_number - recent_rounds:, opponent])
                if recent_cooperations >= recent_rounds * 0.5:
                    expected += 1
        return expected

    def _count_likely_defectors(self, history: PlayerHistory) -> int:
        """Count opponents who are likely to defect."""
        if history.round_number == 0:
            return self.n - 1
        likely_defectors = 1
        for opponent in range(self.n - 1):
            cooperation_rate = self._get_cooperation_rate(history, opponent)
            if cooperation_rate <= 0.3:
                likely_defectors += 1
        return likely_defectors

    def _get_cooperation_rate(self, history: PlayerHistory, opponent: int) -> float:
        """Get cooperation rate for a specific opponent."""
        if history.round_number == 0:
            return 0.0
        cooperations = sum(history.opponent_actions[:, opponent])
        return cooperations / history.round_number

    def _am_critical_cooperator(self, expected_cooperators: int) -> bool:
        """Check if I'm the critical player (exactly m-1 others likely to cooperate)."""
        return expected_cooperators == self.m - 1

    def _expected_payoff_from_cooperation(self) -> float:
        """Calculate expected payoff from cooperating when critical."""
        return self.k if self.k > 1.2 else 0

class Strategy_AGGRESSIVE_67(BaseStrategy):
    """
    Exploitative Threshold Hunter - An aggressive strategy that maximizes individual payoff 
    by exploiting cooperative players while minimizing personal risk. Defects when others 
    will likely meet the threshold, cooperates only when necessary to ensure threshold is met.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.m = game_description.m
        self.k = game_description.k
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_num = history.round_number + 1
        if round_num == 2:
            round_1_cooperators = sum(history.opponent_actions[0]) + (1 if history.my_actions[0] else 0)
            if round_1_cooperators == self.m - 1:
                return Action.C
            else:
                return Action.D
        if round_num >= self.r - 1:
            if round_num == self.r:
                return Action.D
            else:
                coop_rate = self._calculate_cooperation_rate(history)
                if coop_rate > 0.7 or coop_rate <= 0.4:
                    return Action.D
        expected_cooperators = self._predict_cooperators(history)
        if expected_cooperators >= self.m:
            return Action.D
        elif expected_cooperators == self.m - 1:
            return Action.C
        else:
            coop_rate = self._calculate_cooperation_rate(history)
            if coop_rate < self.m / self.n - 0.1:
                if expected_cooperators >= self.m - 2:
                    return Action.C
            return Action.D

    def _calculate_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate overall cooperation rate across all rounds and players."""
        total_cooperations = 0
        total_decisions = 0
        for round_idx in range(history.round_number):
            total_cooperations += sum(history.opponent_actions[round_idx])
            if history.my_actions[round_idx]:
                total_cooperations += 1
            total_decisions += self.n
        if total_decisions == 0:
            return 0.0
        return total_cooperations / total_decisions

    def _predict_cooperators(self, history: PlayerHistory) -> float:
        """Predict expected number of cooperators in next round."""
        cooperation_rate = self._calculate_cooperation_rate(history)
        return cooperation_rate * self.n

class Strategy_AGGRESSIVE_68(BaseStrategy):
    """
    Opportunistic Threshold Rider - An aggressive strategy that maximizes individual payoffs 
    by exploiting cooperative players while minimizing personal risk. Defects by default but 
    cooperates only when necessary to prevent system collapse or strategically position for 
    threshold exploitation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        prev_round_idx = history.round_number - 1
        prev_cooperators = int(sum(history.opponent_actions[prev_round_idx])) + int(history.my_actions[prev_round_idx])
        if current_round == r:
            return Action.D
        if current_round == r - 1:
            if prev_cooperators >= m - 1:
                return Action.D
            elif prev_cooperators == m - 2:
                return Action.C
            else:
                return Action.D
        if prev_cooperators < m - 2:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_69(BaseStrategy):
    """
    Opportunistic Exploiter: An aggressive strategy that exploits cooperative players
    while minimizing personal risk. Defects early to identify cooperators, then
    strategically cooperates only when necessary while maximizing free-riding opportunities.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        phase1_end = max(1, self.r // 3)
        phase2_end = max(phase1_end + 1, 2 * self.r // 3)
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        if current_round <= phase1_end:
            return Action.D
        if current_round > phase2_end:
            rounds_remaining = self.r - current_round + 1
            if current_round == self.r:
                return Action.D
            if cooperators_last_round > self.m:
                return Action.D
            if cooperators_last_round == self.m:
                return Action.D
            if cooperators_last_round == self.m - 1 and rounds_remaining > 1:
                return Action.C
            else:
                return Action.D
        consistent_cooperators = 0
        if history.round_number > 0:
            for player_idx in range(self.n - 1):
                cooperation_rate = sum(history.opponent_actions[:, player_idx]) / history.round_number
                if cooperation_rate >= 0.8:
                    consistent_cooperators += 1
        if cooperators_last_round >= self.m:
            return Action.D
        if cooperators_last_round == self.m - 1:
            if consistent_cooperators >= self.m - 1:
                return Action.D
            else:
                return Action.C
        if cooperators_last_round < self.m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_70(BaseStrategy):
    """
    Opportunistic Exploiter - An aggressive strategy that maximizes exploitation with minimal contribution.
    Only cooperates when absolutely necessary to secure collective rewards, otherwise free-rides.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_num = history.round_number + 1
        if round_num == self.n_rounds:
            return Action.D
        last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
        if history.my_actions[history.round_number - 1]:
            last_round_cooperators += 1
        remaining_rounds = self.n_rounds - round_num
        if remaining_rounds <= self.n_rounds * 0.2:
            return Action.D
        window = min(3, history.round_number)
        recent_rounds = history.round_number - window
        total_cooperators = 0
        total_possible = 0
        for i in range(recent_rounds, history.round_number):
            round_cooperators = sum(history.opponent_actions[i])
            if history.my_actions[i]:
                round_cooperators += 1
            total_cooperators += round_cooperators
            total_possible += self.n_players
        avg_cooperation_rate = total_cooperators / total_possible if total_possible > 0 else 0
        if last_round_cooperators == self.m - 1:
            return Action.D
        if avg_cooperation_rate >= 0.8:
            pseudo_random = (round_num * 17 + 23) % 100 / 100.0
            if pseudo_random < 0.3:
                return Action.D
        if history.round_number >= 3:
            consecutive_failures = 0
            for i in range(history.round_number - 1, max(-1, history.round_number - 4), -1):
                round_cooperators = sum(history.opponent_actions[i])
                if history.my_actions[i]:
                    round_cooperators += 1
                if round_cooperators < self.m:
                    consecutive_failures += 1
                else:
                    break
            if consecutive_failures >= 3:
                return Action.D
        if history.round_number >= 3:
            consecutive_high_cooperation = 0
            for i in range(history.round_number - 1, max(-1, history.round_number - 4), -1):
                round_cooperators = sum(history.opponent_actions[i])
                if history.my_actions[i]:
                    round_cooperators += 1
                if round_cooperators >= self.m + 2:
                    consecutive_high_cooperation += 1
                else:
                    break
            if consecutive_high_cooperation >= 3:
                return Action.D
        if last_round_cooperators >= self.m - 2 and remaining_rounds > 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_71(BaseStrategy):
    """
    Aggressive "Exploit and Abandon" Strategy for Collective Risk Dilemma.
    Maximizes personal payoff by free-riding on others' cooperation and only
    cooperating when absolutely necessary (when I'm the deciding vote).
    Uses end-game defection and exploits cooperative opponents.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        coop_rates = self._calculate_cooperation_rates(history)
        expected_cooperators = self._predict_cooperators(coop_rates, current_round, history)
        if expected_cooperators >= self.m:
            return Action.D
        elif expected_cooperators == self.m - 1:
            if current_round > self.r * 0.8:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

    def _calculate_cooperation_rates(self, history: PlayerHistory) -> list:
        """Calculate overall cooperation rate for each opponent."""
        n_opponents = self.n - 1
        rounds_played = history.round_number
        coop_rates = []
        for opponent_idx in range(n_opponents):
            cooperations = sum(history.opponent_actions[:, opponent_idx])
            rate = cooperations / rounds_played if rounds_played > 0 else 0.0
            coop_rates.append(rate)
        return coop_rates

    def _predict_cooperators(self, coop_rates: list, current_round: int, history: PlayerHistory) -> int:
        """Predict how many opponents will cooperate this round."""
        predicted_count = 0
        n_opponents = self.n - 1
        rounds_played = history.round_number
        for opponent_idx in range(n_opponents):
            recent_window = min(3, rounds_played)
            if recent_window > 0:
                recent_actions = history.opponent_actions[-recent_window:, opponent_idx]
                recent_rate = sum(recent_actions) / recent_window
            else:
                recent_rate = 0.0
            recent_weight = 0.7
            historical_weight = 0.3
            historical_rate = coop_rates[opponent_idx]
            predicted_rate = recent_weight * recent_rate + historical_weight * historical_rate
            if current_round > self.r * 0.8:
                predicted_rate *= 0.6
            if predicted_rate > 0.5:
                predicted_count += 1
        return predicted_count

class Strategy_AGGRESSIVE_72(BaseStrategy):
    """
    Exploitative Free-Rider strategy that aggressively maximizes individual payoff
    by exploiting cooperative behavior while minimizing personal contributions.
    Only cooperates when absolutely necessary to secure benefits.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            cooperators_last_round += 1
        if cooperators_last_round >= self.m:
            return Action.D
        elif cooperators_last_round == self.m - 1:
            if current_round < self.n_rounds - 1:
                return Action.D
            else:
                return Action.C
        else:
            if self._threshold_consistently_failing(history):
                return Action.D
            if current_round == self.n_rounds and cooperators_last_round == self.m - 1:
                return Action.C
            return Action.D

    def _threshold_consistently_failing(self, history: PlayerHistory) -> bool:
        """Check if threshold has been failing for multiple consecutive rounds."""
        if history.round_number < 3:
            return False
        consecutive_failures = 0
        for i in range(max(0, history.round_number - 3), history.round_number):
            round_cooperators = sum(history.opponent_actions[i])
            if history.my_actions[i]:
                round_cooperators += 1
            if round_cooperators < self.m:
                consecutive_failures += 1
            else:
                break
        return consecutive_failures >= 3

class Strategy_AGGRESSIVE_73(BaseStrategy):
    """
    Exploitative Threshold Hunter - An aggressive strategy that minimizes personal risk while 
    maximizing opportunities to free-ride on others' cooperation. Always defects in first and 
    last rounds, and exploits successful cooperation while rarely contributing when needed.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.success_count = 0
        self.total_rounds_played = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        last_round_idx = history.round_number - 1
        coop_count = int(sum(history.opponent_actions[last_round_idx]))
        if history.my_actions[last_round_idx]:
            coop_count += 1
        if coop_count >= self.game_description.m:
            self.success_count += 1
        self.total_rounds_played += 1
        success_rate = self.success_count / self.total_rounds_played if self.total_rounds_played > 0 else 0
        if success_rate < 0.25 and self.total_rounds_played >= 3:
            return Action.D
        if coop_count >= self.game_description.m:
            if success_rate >= 0.75 and self.total_rounds_played >= 3:
                return Action.D if random.random() < 0.9 else Action.C
            else:
                return Action.D
        elif coop_count == self.game_description.m - 1:
            return Action.D if random.random() < 0.8 else Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_74(BaseStrategy):
    """
    Exploitative Threshold Guardian: Aggressively exploits others' cooperation while minimizing 
    personal risk. Only cooperates when pivotal (exactly the m-th cooperator needed), otherwise 
    always defects. Guaranteed defection in first and last rounds.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        if history.round_number >= self.game_description.n_rounds - 1:
            return Action.D
        cooperators_others = sum(history.opponent_actions[history.round_number - 1])
        needed = self.game_description.m - cooperators_others
        if needed == 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_75(BaseStrategy):
    """
    Threshold Exploiter: An aggressive strategy that maximizes individual payoffs by 
    strategically defecting whenever possible while ensuring others maintain the 
    cooperation threshold when beneficial. Uses phase-based decision making with 
    increasing aggression toward endgame.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        phase1_end = max(1, self.r // 3)
        phase2_end = max(phase1_end + 1, 2 * self.r // 3)
        cooperators_last_round = int(sum(history.opponent_actions[history.round_number - 1])) + (1 if history.my_actions[history.round_number - 1] else 0)
        if current_round <= phase1_end:
            if cooperators_last_round >= self.m + 2:
                return Action.D
            elif cooperators_last_round == self.m + 1:
                return Action.D
            else:
                return Action.C
        elif current_round <= phase2_end:
            consistent_cooperators = self._count_consistent_cooperators(history)
            if cooperators_last_round >= self.m + 1:
                return Action.D
            elif cooperators_last_round == self.m:
                if consistent_cooperators >= self.m + 1:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.C
        elif current_round == self.r:
            return Action.D
        elif cooperators_last_round >= self.m + 2:
            return Action.D
        elif cooperators_last_round == self.m + 1:
            likely_defectors = self._estimate_defectors_next_round(history)
            if likely_defectors <= 1:
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

    def _count_consistent_cooperators(self, history: PlayerHistory) -> int:
        """Count players (including self) who cooperated in last 3 rounds or 80% of observable rounds"""
        rounds_to_check = min(3, history.round_number)
        if rounds_to_check == 0:
            return 0
        consistent_count = 0
        if rounds_to_check > 0:
            my_recent_cooperation = sum(history.my_actions[-rounds_to_check:])
            if my_recent_cooperation >= 0.8 * rounds_to_check:
                consistent_count += 1
        for player_idx in range(self.n - 1):
            recent_cooperation = sum(history.opponent_actions[-rounds_to_check:, player_idx])
            if recent_cooperation >= 0.8 * rounds_to_check:
                consistent_count += 1
        return consistent_count

    def _estimate_defectors_next_round(self, history: PlayerHistory) -> int:
        """Estimate how many players might defect next round based on recent patterns"""
        if history.round_number < 2:
            return 1
        recent_defectors = 0
        for player_idx in range(self.n - 1):
            if history.round_number >= 2:
                if history.opponent_actions[history.round_number - 2, player_idx] and (not history.opponent_actions[history.round_number - 1, player_idx]):
                    recent_defectors += 1
        return min(self.n - self.m, recent_defectors + 1)

class Strategy_AGGRESSIVE_76(BaseStrategy):
    """
    Opportunistic Exploiter: An aggressive strategy that maximizes individual payoffs through 
    calculated exploitation while maintaining minimal cooperation only when profitable.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        last_round_idx = history.round_number - 1
        cooperation_count = sum(history.opponent_actions[last_round_idx])
        if current_round == self.r - 1:
            if cooperation_count >= self.m:
                return Action.D
            elif cooperation_count == self.m - 1:
                return Action.C
            else:
                return Action.D
        if current_round >= 2 and current_round <= self.r - 2:
            if self.n >= 8 and current_round <= self.r - 3:
                if cooperation_count == self.m - 1:
                    return Action.C
                else:
                    return Action.D
            if history.round_number >= 2:
                cooperation_rates = []
                for player in range(self.n - 1):
                    player_cooperations = sum(history.opponent_actions[:history.round_number, player])
                    cooperation_rate = player_cooperations / history.round_number
                    cooperation_rates.append(cooperation_rate)
                likely_cooperators = sum((1 for rate in cooperation_rates if rate > 0.6))
                if likely_cooperators >= self.m:
                    return Action.D
                elif likely_cooperators == self.m - 1:
                    return Action.C
                else:
                    return Action.D
            my_contribution_needed = max(0, self.m - cooperation_count)
            if my_contribution_needed == 0:
                return Action.D
            elif my_contribution_needed == 1 and cooperation_count >= self.m - 1:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_77(BaseStrategy):
    """
    Exploit & Abandon: An aggressive strategy that maximizes personal payoff by exploiting 
    cooperative players while minimizing personal risk. Always defects in first and last rounds,
    and uses calculated exploitation in between.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        last_round_idx = history.round_number - 1
        last_cooperators = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            last_cooperators += 1
        if last_cooperators >= self.game_description.m:
            return Action.D
        elif last_cooperators == self.game_description.m - 1:
            my_last_action = history.my_actions[last_round_idx]
            if my_last_action:
                return Action.D
            else:
                exploitable_players = 0
                if history.round_number >= 2:
                    for player_idx in range(self.game_description.n_players - 1):
                        cooperation_rate = sum(history.opponent_actions[:history.round_number, player_idx]) / history.round_number
                        if cooperation_rate > 0.7:
                            exploitable_players += 1
                if exploitable_players >= 2:
                    return Action.D
                else:
                    return Action.C
        elif random.random() < 0.2:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_78(BaseStrategy):
    """
    Aggressive Exploitative Threshold Rider Strategy.
    
    This strategy maximizes personal payoff by free-riding on others' cooperation
    while strategically contributing only when absolutely necessary. Always defects
    in first and final rounds, and employs threshold manipulation and pattern
    exploitation throughout the game.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self.cooperation_rates = {}
        self.consistency_scores = {}

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_num = history.round_number + 1
        if round_num == self.r:
            return Action.D
        last_round_cooperators = int(sum(history.opponent_actions[history.round_number - 1]))
        self._update_patterns(history)
        return self._core_strategy(history, last_round_cooperators, round_num)

    def _update_patterns(self, history: PlayerHistory):
        """Track cooperation patterns for exploitation."""
        n_rounds = history.round_number
        for player_idx in range(self.n - 1):
            total_cooperations = sum(history.opponent_actions[:n_rounds, player_idx])
            self.cooperation_rates[player_idx] = total_cooperations / n_rounds
            if n_rounds >= 3:
                recent_actions = history.opponent_actions[max(0, n_rounds - 3):n_rounds, player_idx]
                self.consistency_scores[player_idx] = 1.0 - np.var(recent_actions.astype(float))
            else:
                self.consistency_scores[player_idx] = 0.5

    def _count_reliable_cooperators(self) -> int:
        """Count players who are reliable cooperators."""
        reliable_count = 0
        for player_idx in range(self.n - 1):
            coop_rate = self.cooperation_rates.get(player_idx, 0.0)
            consistency = self.consistency_scores.get(player_idx, 0.0)
            if coop_rate > 0.7 and consistency > 0.8:
                reliable_count += 1
        return reliable_count

    def _core_strategy(self, history: PlayerHistory, last_cooperators: int, round_num: int) -> Action:
        """Core strategy logic for middle rounds."""
        if last_cooperators >= self.m:
            if last_cooperators >= self.m + 2 and round_num > self.r * 0.3:
                return Action.D
            return Action.D
        elif last_cooperators == self.m - 1:
            reliable_cooperators = self._count_reliable_cooperators()
            if reliable_cooperators >= self.m - 1 and round_num < self.r * 0.8:
                return Action.C
            else:
                return Action.D
        else:
            if round_num > self.r * 0.8:
                required_threshold = self.m + 1
                if last_cooperators < required_threshold:
                    return Action.D
            return Action.D

class Strategy_AGGRESSIVE_79(BaseStrategy):
    """
    Threshold Exploiter: An aggressive strategy that exploits the threshold nature of the game
    by free-riding whenever possible while carefully managing when cooperation is absolutely necessary.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.defection_penalty_tracker = [0] * (game_description.n_players - 1)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        k = self.game_description.k
        if current_round == r:
            return Action.D
        total_rounds_so_far = history.round_number
        total_cooperations = 0
        for round_idx in range(total_rounds_so_far):
            cooperators_in_round = sum(history.opponent_actions[round_idx])
            if history.my_actions[round_idx]:
                cooperators_in_round += 1
            total_cooperations += cooperators_in_round
        if total_rounds_so_far > 0:
            cooperation_rate = total_cooperations / (total_rounds_so_far * n)
        else:
            cooperation_rate = 0.5
        expected_cooperators = n * cooperation_rate
        if total_rounds_so_far > 0:
            last_round_idx = total_rounds_so_far - 1
            for player_idx in range(n - 1):
                if not history.opponent_actions[last_round_idx, player_idx]:
                    self.defection_penalty_tracker[player_idx] += 1
        if expected_cooperators < m - 1:
            action = Action.D
        elif expected_cooperators >= m:
            action = Action.D
        elif abs(expected_cooperators - (m - 1)) < 0.5:
            remaining_rounds = r - current_round
            future_benefit = remaining_rounds * k
            cooperation_cost = 1
            if future_benefit > cooperation_cost:
                action = Action.C
            else:
                action = Action.D
        else:
            action = Action.D
        if total_rounds_so_far > 0:
            consistent_defectors = sum((1 for penalty in self.defection_penalty_tracker if penalty > 0.7 * total_rounds_so_far))
            if consistent_defectors > n - m + 1 and expected_cooperators < m - 2 and (random.random() < 0.3):
                action = Action.C
        return action

class Strategy_AGGRESSIVE_80(BaseStrategy):
    """
    Exploitative Threshold Rider: An aggressive strategy that maximizes personal payoffs
    by free-riding on cooperative players while minimizing personal risk. Only cooperates
    when absolutely necessary to prevent collective failure.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        last_round_idx = history.round_number - 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        last_round_cooperators = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            last_round_cooperators += 1
        i_cooperated_last = history.my_actions[last_round_idx]
        if last_round_cooperators >= self.game_description.m:
            return Action.D
        if last_round_cooperators == self.game_description.m - 1:
            if i_cooperated_last:
                return Action.D
            else:
                return Action.C
        return Action.C

class Strategy_AGGRESSIVE_81(BaseStrategy):
    """
    Aggressive Exploitation Maximizer: Systematically exploits cooperative behavior
    while minimizing personal cooperation costs. Defects aggressively and only
    cooperates when absolutely necessary to maintain threshold.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n = self.game_description.n_players
        m = self.game_description.m
        k = self.game_description.k
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        expected_cooperators = self._estimate_cooperators(history)
        cooperators_needed = m
        if expected_cooperators >= cooperators_needed:
            return Action.D
        elif expected_cooperators == cooperators_needed - 1:
            if self._should_force_cooperation(history, current_round, r):
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

    def _estimate_cooperators(self, history: PlayerHistory) -> int:
        """Estimate how many opponents will cooperate based on recent behavior."""
        if history.round_number == 0:
            return 0
        recent_rounds = min(3, history.round_number)
        total_weight = 0
        weighted_cooperation = 0
        for i in range(recent_rounds):
            round_idx = history.round_number - 1 - i
            weight = 1.0 / (i + 1)
            cooperators_in_round = sum(history.opponent_actions[round_idx])
            weighted_cooperation += weight * cooperators_in_round
            total_weight += weight
        if total_weight == 0:
            return 0
        estimated = weighted_cooperation / total_weight
        estimated *= 0.9
        return int(estimated)

    def _should_force_cooperation(self, history: PlayerHistory, current_round: int, total_rounds: int) -> bool:
        """Decide whether to force others to cooperate when threshold is critical."""
        if current_round <= total_rounds * 0.3:
            return True
        if current_round <= total_rounds * 0.7:
            recent_failures = self._count_threshold_failures(history, 3)
            return recent_failures < 2
        return True

    def _count_threshold_failures(self, history: PlayerHistory, last_n_rounds: int) -> int:
        """Count how many times threshold failed in last n rounds."""
        if history.round_number == 0:
            return 0
        failures = 0
        rounds_to_check = min(last_n_rounds, history.round_number)
        for i in range(rounds_to_check):
            round_idx = history.round_number - 1 - i
            cooperators = sum(history.opponent_actions[round_idx])
            if history.my_actions[round_idx]:
                cooperators += 1
            if cooperators < self.game_description.m:
                failures += 1
        return failures

class Strategy_AGGRESSIVE_82(BaseStrategy):
    """
    Predatory Exploiter: An aggressive collective risk strategy that maximizes exploitation
    while minimizing personal risk. Defects early to gather intelligence, then makes
    calculated decisions to free-ride on others' cooperation when possible.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round <= self.n_rounds - 2:
            return Action.D
        cooperation_frequencies = []
        for player_idx in range(self.n_players - 1):
            total_cooperations = sum(history.opponent_actions[:, player_idx])
            cooperation_freq = total_cooperations / history.round_number
            cooperation_frequencies.append(cooperation_freq)
        if current_round == self.n_rounds - 1:
            reliable_cooperators = sum((1 for freq in cooperation_frequencies if freq > 0.6))
            uncertain_players = sum((1 for freq in cooperation_frequencies if 0.3 <= freq <= 0.6))
            if reliable_cooperators >= self.m:
                return Action.D
            elif reliable_cooperators + uncertain_players * 0.4 >= self.m:
                return Action.D
            else:
                return Action.C
        if current_round == self.n_rounds:
            expected_cooperators = 0
            for freq in cooperation_frequencies:
                if freq > 0.7:
                    cooperation_prob = 0.9
                elif freq > 0.5:
                    cooperation_prob = 0.7
                elif freq > 0.3:
                    cooperation_prob = 0.4
                else:
                    cooperation_prob = 0.1
                expected_cooperators += cooperation_prob
            if expected_cooperators > self.m + 0.5:
                return Action.D
            elif expected_cooperators > self.m - 0.5:
                defect_expected_payoff = 1 + (self.k if expected_cooperators >= self.m else 0)
                cooperate_expected_payoff = 0 + self.k
                if defect_expected_payoff > cooperate_expected_payoff:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.C
        return Action.D

class Strategy_AGGRESSIVE_83(BaseStrategy):
    """
    Opportunistic Exploiter: An aggressive strategy that maximizes personal payoffs
    by exploiting cooperative players while minimizing personal contributions.
    Always defects in first and last rounds, and strategically cooperates only
    when absolutely necessary to trigger thresholds or prime cooperation cycles.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.consecutive_defections = 0
        self.consecutive_threshold_failures = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.consecutive_defections = 1
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        last_round_idx = history.round_number - 1
        cooperators_last_round = int(sum(history.opponent_actions[last_round_idx]))
        if history.my_actions[last_round_idx]:
            cooperators_last_round += 1
        if cooperators_last_round < self.game_description.m:
            self.consecutive_threshold_failures += 1
        else:
            self.consecutive_threshold_failures = 0
        if cooperators_last_round >= self.game_description.m:
            action = Action.D
        elif cooperators_last_round == self.game_description.m - 1:
            if self.game_description.k > 2.0:
                action = Action.C
                self.consecutive_defections = 0
            else:
                action = Action.D
        else:
            action = Action.D
        if self.consecutive_defections >= 3 and self.consecutive_threshold_failures >= 3 and (current_round < self.game_description.n_rounds * 0.75):
            if random.random() < 0.3:
                action = Action.C
                self.consecutive_defections = 0
        if action == Action.D:
            self.consecutive_defections += 1
        else:
            self.consecutive_defections = 0
        return action

class Strategy_AGGRESSIVE_84(BaseStrategy):
    """
    Aggressive Exploitation Maximizer Strategy for Collective Risk Dilemma.
    
    This strategy maximizes personal payoffs by exploiting cooperative opponents while minimizing
    personal risk. Uses a three-phase approach: early exploitation, adaptive predation, and 
    scorched earth end-game to systematically extract maximum individual benefit.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self.early_phase = self.r // 3
        self.late_phase = 2 * self.r // 3

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round <= self.early_phase:
            return Action.D
        if current_round > self.late_phase:
            return Action.D
        return self._adaptive_predation_decision(history)

    def _adaptive_predation_decision(self, history: PlayerHistory) -> Action:
        """Apply minimum viable cooperation rule in middle phase."""
        recent_cooperation = self._analyze_recent_cooperation(history, window=3)
        likely_cooperators = self._count_likely_cooperators(history)
        if likely_cooperators == self.m - 1 and recent_cooperation >= self.m:
            return Action.C
        return Action.D

    def _analyze_recent_cooperation(self, history: PlayerHistory, window: int) -> float:
        """Count average cooperators in recent rounds."""
        rounds_completed = history.round_number
        if rounds_completed == 0:
            return 0.0
        actual_window = min(window, rounds_completed)
        total_cooperators = 0
        for i in range(actual_window):
            round_idx = rounds_completed - 1 - i
            cooperators_in_round = sum(history.opponent_actions[round_idx])
            if history.my_actions[round_idx]:
                cooperators_in_round += 1
            total_cooperators += cooperators_in_round
        return total_cooperators / actual_window

    def _count_likely_cooperators(self, history: PlayerHistory) -> int:
        """Estimate how many opponents are likely to cooperate this round."""
        rounds_completed = history.round_number
        if rounds_completed == 0:
            return 0
        likely_cooperators = 0
        for player_idx in range(self.n - 1):
            cooperation_rate = self._get_player_cooperation_rate(history, player_idx)
            recent_trend = self._get_player_recent_trend(history, player_idx)
            if cooperation_rate > 0.7:
                likely_cooperators += 1
            elif cooperation_rate > 0.4 and recent_trend > 0:
                likely_cooperators += 1
            elif self._is_threshold_responder(history, player_idx):
                if recent_trend < 0:
                    likely_cooperators += 1
        return likely_cooperators

    def _get_player_cooperation_rate(self, history: PlayerHistory, player_idx: int) -> float:
        """Get cooperation rate for specific opponent."""
        rounds_completed = history.round_number
        if rounds_completed == 0:
            return 0.0
        cooperations = sum(history.opponent_actions[:rounds_completed, player_idx])
        return cooperations / rounds_completed

    def _get_player_recent_trend(self, history: PlayerHistory, player_idx: int) -> float:
        """Get recent cooperation trend for specific opponent (positive = increasing)."""
        rounds_completed = history.round_number
        if rounds_completed < 2:
            return 0.0
        mid_point = rounds_completed // 2
        if mid_point == 0:
            return 0.0
        early_rate = sum(history.opponent_actions[:mid_point, player_idx]) / mid_point
        late_rate = sum(history.opponent_actions[mid_point:rounds_completed, player_idx]) / (rounds_completed - mid_point)
        return late_rate - early_rate

    def _is_threshold_responder(self, history: PlayerHistory, player_idx: int) -> bool:
        """Check if player tends to cooperate when total cooperation is low."""
        rounds_completed = history.round_number
        if rounds_completed < 3:
            return False
        responsive_behavior = 0
        total_checks = 0
        for round_idx in range(1, rounds_completed):
            prev_total_coop = sum(history.opponent_actions[round_idx - 1]) + int(history.my_actions[round_idx - 1])
            player_cooperated = history.opponent_actions[round_idx, player_idx]
            if prev_total_coop < self.m and player_cooperated or (prev_total_coop >= self.m and (not player_cooperated)):
                responsive_behavior += 1
            total_checks += 1
        return total_checks > 0 and responsive_behavior / total_checks > 0.6

class Strategy_AGGRESSIVE_85(BaseStrategy):
    """
    Opportunistic Exploiter: An aggressive strategy that exploits cooperative players
    while minimizing personal contributions. Only cooperates when absolutely necessary
    to secure collective benefits, using a three-phase approach with endgame betrayal.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.opponent_cooperation_rates = None
        self.pivotal_rounds = []

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        m = self.game_description.m
        k = self.game_description.k
        if self.opponent_cooperation_rates is None:
            n_opponents = self.game_description.n_players - 1
            self.opponent_cooperation_rates = np.zeros(n_opponents)
        if history.round_number > 0:
            for i in range(len(self.opponent_cooperation_rates)):
                total_rounds = history.round_number
                cooperations = sum(history.opponent_actions[:, i])
                self.opponent_cooperation_rates[i] = cooperations / total_rounds
        if current_round <= n_rounds // 3:
            return Action.D
        elif current_round > 2 * n_rounds // 3:
            rounds_remaining = n_rounds - current_round + 1
            if current_round == n_rounds:
                return Action.D
            if rounds_remaining <= 3:
                expected_cooperators = self._estimate_cooperators(history)
                if expected_cooperators == m - 1 and rounds_remaining * k > 1:
                    return Action.C
                else:
                    return Action.D
            else:
                return self._phase_2_decision(history)
        else:
            return self._phase_2_decision(history)

    def _phase_2_decision(self, history: PlayerHistory) -> Action:
        """Phase 2 decision logic: only cooperate when I'm pivotal"""
        m = self.game_description.m
        expected_cooperators = self._estimate_cooperators(history)
        if expected_cooperators == m - 1:
            self.pivotal_rounds.append(history.round_number + 1)
            return Action.C
        else:
            return Action.D

    def _estimate_cooperators(self, history: PlayerHistory) -> int:
        """Estimate how many opponents will cooperate in next round"""
        if history.round_number == 0:
            return max(1, len(self.opponent_cooperation_rates) // 4)
        suckers = sum((1 for rate in self.opponent_cooperation_rates if rate > 0.6))
        reciprocators = sum((1 for rate in self.opponent_cooperation_rates if 0.3 <= rate <= 0.6))
        if suckers >= self.game_description.m // 2:
            return suckers + reciprocators
        else:
            return suckers + int(reciprocators * 0.3)

    def _classify_opponents(self, history: PlayerHistory):
        """Classify opponents as suckers, reciprocators, or fellow aggressors"""
        if history.round_number < 2:
            return
        for i in range(len(self.opponent_cooperation_rates)):
            rate = self.opponent_cooperation_rates[i]
            if rate > 0.6:
                pass
            elif rate > 0.3:
                pass
            else:
                pass

class Strategy_AGGRESSIVE_86(BaseStrategy):
    """
    Opportunistic Exploiter: An aggressive strategy that maximizes personal payoff by exploiting
    others' cooperation while minimizing personal risk. Defects whenever possible and only
    cooperates when absolutely necessary for group survival or reputation management.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        m = self.game_description.m
        if current_round == n_rounds:
            return Action.D
        my_cooperation_rate = sum(history.my_actions) / len(history.my_actions)
        recent_cooperators = 0
        lookback_rounds = min(3, history.round_number)
        for i in range(lookback_rounds):
            round_idx = history.round_number - 1 - i
            recent_cooperators += sum(history.opponent_actions[round_idx])
            if history.my_actions[round_idx]:
                recent_cooperators += 1
        avg_cooperators_recent = recent_cooperators / lookback_rounds if lookback_rounds > 0 else 0
        last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
        if history.my_actions[history.round_number - 1]:
            last_round_cooperators += 1
        threshold_safety = avg_cooperators_recent - (m - 1)
        if current_round <= 3:
            if last_round_cooperators < m - 2:
                return Action.C
            return Action.D
        if current_round > n_rounds - 3:
            if last_round_cooperators < m - 1:
                return Action.C
            return Action.D
        if threshold_safety > 2:
            return Action.D
        if threshold_safety <= 0:
            if my_cooperation_rate < 0.3:
                return Action.C
            else:
                return Action.D
        if last_round_cooperators >= m:
            return Action.D
        else:
            if my_cooperation_rate < 0.2:
                return Action.C
            return Action.D

class Strategy_AGGRESSIVE_87(BaseStrategy):
    """
    Threshold Hawk: Aggressive exploitation strategy that defects by default,
    only cooperating when pivotal (exactly the m-th cooperator needed).
    Maximizes free-riding opportunities while maintaining strategic cooperation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        last_round_idx = history.round_number - 1
        cooperators_last_round = int(sum(history.opponent_actions[last_round_idx]))
        if history.my_actions[last_round_idx]:
            cooperators_last_round += 1
        predicted_cooperators = self._predict_cooperators(history)
        if current_round <= self.r - 2:
            if cooperators_last_round >= self.m - 1 and cooperators_last_round < self.n - 1:
                if predicted_cooperators == self.m - 1:
                    return Action.C
                else:
                    return Action.D
            elif cooperators_last_round >= self.m:
                return Action.D
            else:
                return Action.D
        else:
            my_defections = sum((1 for action in history.my_actions if not action))
            if cooperators_last_round >= self.m - 2 and my_defections < self.r - 2:
                if predicted_cooperators == self.m - 1:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D

    def _predict_cooperators(self, history: PlayerHistory) -> int:
        """Predict number of cooperators this round based on opponent patterns."""
        predicted = 0
        for opponent_idx in range(self.n - 1):
            cooperation_rate = self._get_cooperation_rate(history, opponent_idx)
            if cooperation_rate > 0.5:
                predicted += 1
            elif cooperation_rate > 0.3:
                last_round_idx = history.round_number - 1
                last_cooperators = int(sum(history.opponent_actions[last_round_idx]))
                if history.my_actions[last_round_idx]:
                    last_cooperators += 1
                if last_cooperators >= self.m - 2:
                    predicted += 1
        return predicted

    def _get_cooperation_rate(self, history: PlayerHistory, opponent_idx: int) -> float:
        """Calculate cooperation rate for a specific opponent."""
        if history.round_number == 0:
            return 0.5
        cooperations = sum(history.opponent_actions[:history.round_number, opponent_idx])
        return cooperations / history.round_number

class Strategy_AGGRESSIVE_88(BaseStrategy):
    """
    Threshold Predator: Aggressive exploitation strategy that free-rides on cooperation
    while only contributing when absolutely necessary to secure collective benefits.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        m = self.game_description.m
        n = self.game_description.n_players
        if current_round == n_rounds:
            return Action.D
        if current_round > 1:
            recent_rounds = min(3, history.round_number)
            total_recent_cooperations = 0
            total_possible = recent_rounds * (n - 1)
            for i in range(max(0, history.round_number - recent_rounds), history.round_number):
                total_recent_cooperations += sum(history.opponent_actions[i])
            cooperation_trend = total_recent_cooperations / total_possible if total_possible > 0 else 0
            last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
            if cooperation_trend > 0.6:
                estimated_cooperators = last_round_cooperators
                trend_adjustment = int(cooperation_trend * (n - 1) * 0.1)
                estimated_cooperators = max(0, min(n - 1, estimated_cooperators + trend_adjustment))
                return Action.C if estimated_cooperators == m - 1 else Action.D
            elif cooperation_trend < 0.3:
                rounds_remaining = n_rounds - current_round
                if rounds_remaining > 3 and random.random() < 0.4:
                    return Action.C
                else:
                    return Action.D
            else:
                estimated_cooperators = last_round_cooperators
                if cooperation_trend > 0.5:
                    estimated_cooperators = min(n - 1, estimated_cooperators + 1)
                elif cooperation_trend < 0.4:
                    estimated_cooperators = max(0, estimated_cooperators - 1)
                return Action.C if estimated_cooperators == m - 1 else Action.D
        return Action.D

class Strategy_AGGRESSIVE_89(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Threshold Rider"
    
    This strategy aggressively exploits cooperative players while minimizing personal risk.
    It defects in round 1, uses conditional exploitation in middle rounds based on
    cooperation history and threshold proximity, and defects in the final round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        if current_round == r:
            return Action.D
        last_round_idx = history.round_number - 1
        cooperators_last_round = int(sum(history.opponent_actions[last_round_idx])) + int(history.my_actions[last_round_idx])
        total_cooperators_history = 0
        for round_idx in range(history.round_number):
            total_cooperators_history += int(sum(history.opponent_actions[round_idx])) + int(history.my_actions[round_idx])
        avg_cooperation_rate = total_cooperators_history / (history.round_number * n)
        m_ratio = m / n
        if cooperators_last_round >= m:
            if m_ratio > 0.8:
                return Action.D if avg_cooperation_rate > 0.7 else Action.C
            else:
                return Action.D
        elif cooperators_last_round == m - 1:
            cooperation_threshold = 0.6
            if m_ratio > 0.8:
                cooperation_threshold = 0.5
            elif m_ratio < 0.3:
                cooperation_threshold = 0.8
            if avg_cooperation_rate > cooperation_threshold:
                return Action.D
            else:
                return Action.C
        else:
            recovery_threshold = 0.7
            if m_ratio > 0.8:
                recovery_threshold = 0.6
            elif m_ratio < 0.3:
                recovery_threshold = 0.8
            if avg_cooperation_rate > recovery_threshold:
                return Action.C
            else:
                return Action.D

class Strategy_AGGRESSIVE_90(BaseStrategy):
    """
    Aggressive Strategy: Exploitative Threshold Hunter
    
    Maximizes personal payoffs by aggressively exploiting cooperative players while
    minimizing personal risk. Acts as a free rider whenever possible and only cooperates
    when absolutely necessary to secure collective benefits.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        prev_round_idx = history.round_number - 1
        prev_opponent_cooperators = sum(history.opponent_actions[prev_round_idx])
        my_prev_action = history.my_actions[prev_round_idx]
        prev_total_cooperators = prev_opponent_cooperators + (1 if my_prev_action else 0)
        early_end = r // 3
        middle_end = 2 * r // 3
        if current_round <= early_end:
            if prev_total_cooperators < m - 1:
                return Action.C
            return Action.D
        elif current_round <= middle_end:
            if prev_total_cooperators >= m:
                return Action.D
            elif prev_total_cooperators == m - 1:
                return Action.C
            else:
                return Action.D
        elif current_round == r:
            return Action.D
        elif prev_total_cooperators >= m + 1:
            return Action.D
        elif prev_total_cooperators == m:
            return Action.D
        elif prev_total_cooperators == m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_91(BaseStrategy):
    """
    Predatory Threshold Exploiter: An aggressive strategy that maximizes personal payoff 
    by exploiting collective cooperation while contributing minimally. Always defaults to 
    defection unless cooperation is strategically necessary to maintain exploitable thresholds.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round > self.r - 2:
            return Action.D
        predicted_cooperators = self._estimate_cooperators(history)
        if predicted_cooperators >= self.m:
            return Action.D
        if predicted_cooperators == self.m - 1 and self._recent_profitability(history) > 0.5:
            return Action.C
        return Action.D

    def _estimate_cooperators(self, history: PlayerHistory) -> int:
        """Estimate how many opponents will cooperate next round."""
        cooperator_count = 0
        current_round = history.round_number
        for player_idx in range(self.n - 1):
            recent_coop_rate = self._weighted_cooperation_rate(history, player_idx, current_round)
            if recent_coop_rate > 0.6:
                cooperator_count += 1
        return cooperator_count

    def _weighted_cooperation_rate(self, history: PlayerHistory, player_idx: int, current_round: int) -> float:
        """Calculate weighted cooperation rate for a specific opponent, weighting recent rounds more heavily."""
        if current_round == 0:
            return 0.0
        total_weight = 0.0
        weighted_cooperations = 0.0
        for round_idx in range(current_round):
            weight = 2.0 ** (round_idx - (current_round - 1))
            total_weight += weight
            if history.opponent_actions[round_idx, player_idx]:
                weighted_cooperations += weight
        if total_weight == 0:
            return 0.0
        return weighted_cooperations / total_weight

    def _recent_profitability(self, history: PlayerHistory) -> float:
        """Check if cooperation has been profitable in recent rounds."""
        current_round = history.round_number
        recent_rounds = min(3, current_round)
        if recent_rounds == 0:
            return 0.0
        profitable_rounds = 0
        for i in range(recent_rounds):
            round_idx = current_round - 1 - i
            my_cooperation = 1 if history.my_actions[round_idx] else 0
            opponent_cooperations = sum(history.opponent_actions[round_idx])
            total_cooperators = my_cooperation + opponent_cooperations
            if total_cooperators >= self.m:
                profitable_rounds += 1
        return profitable_rounds / recent_rounds

class Strategy_AGGRESSIVE_92(BaseStrategy):
    """
    Opportunistic Exploiter: An aggressive strategy that maximizes personal payoff by 
    exploiting cooperative players while minimizing personal risk. Always defects when 
    others meet the threshold, uses brinksmanship to delay cooperation, and exploits 
    altruistic players through calculated free-riding.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        cooperators_last_round = int(sum(history.opponent_actions[history.round_number - 1]))
        if history.my_actions[history.round_number - 1]:
            cooperators_last_round += 1
        if current_round == r:
            if cooperators_last_round >= m:
                return Action.D
            else:
                likely_cooperators = 0
                for player_idx in range(n - 1):
                    cooperation_rate = sum(history.opponent_actions[:, player_idx]) / history.round_number
                    if cooperation_rate > 0.4:
                        likely_cooperators += 1
                if likely_cooperators >= m - 1:
                    return Action.D
                else:
                    return Action.C
        if cooperators_last_round >= m:
            return Action.D
        elif cooperators_last_round == m - 1:
            if current_round <= 0.3 * r:
                return Action.D
            else:
                return Action.C
        elif current_round >= 0.8 * r:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_93(BaseStrategy):
    """
    Ruthless Opportunist: An aggressive strategy that prioritizes personal payoff maximization
    through calculated exploitation while minimizing cooperative contributions. Cooperates only
    when absolutely necessary to secure collective rewards and always seeks to free-ride when possible.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        k = self.game_description.k
        current_round = history.round_number + 1
        rounds_remaining = r - current_round + 1
        if current_round == r:
            return Action.D
        last_round_idx = history.round_number - 1
        cooperation_count = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            cooperation_count += 1
        if cooperation_count >= m:
            return Action.D
        if cooperation_count == m - 1:
            if rounds_remaining <= 2:
                return Action.C
            else:
                return self._calculate_exploitation_move(history)
        if cooperation_count < m - 1:
            if rounds_remaining == 1:
                return Action.D
            elif self._detect_cooperation_trend(history) == 'declining':
                return Action.D
            else:
                return Action.C
        return Action.D

    def _calculate_exploitation_move(self, history: PlayerHistory) -> Action:
        """Calculate whether to exploit at critical threshold moment."""
        n = self.game_description.n_players
        m = self.game_description.m
        consistent_cooperators = self._analyze_recent_cooperators(history)
        if consistent_cooperators >= m - 1:
            return Action.D
        other_defectors = self._detect_other_defectors(history)
        if other_defectors > n // 2:
            return Action.D
        return Action.C

    def _analyze_recent_cooperators(self, history: PlayerHistory) -> int:
        """Count players who consistently cooperated in recent rounds."""
        if history.round_number < 3:
            return 0
        start_round = max(0, history.round_number - 3)
        consistent_count = 0
        for player in range(self.game_description.n_players - 1):
            cooperated_recently = 0
            rounds_checked = 0
            for round_idx in range(start_round, history.round_number):
                if history.opponent_actions[round_idx, player]:
                    cooperated_recently += 1
                rounds_checked += 1
            if rounds_checked > 0 and cooperated_recently / rounds_checked >= 0.67:
                consistent_count += 1
        return consistent_count

    def _detect_other_defectors(self, history: PlayerHistory) -> int:
        """Count players who appear to be frequent defectors."""
        if history.round_number < 2:
            return 0
        defector_count = 0
        for player in range(self.game_description.n_players - 1):
            defections = 0
            total_rounds = 0
            for round_idx in range(history.round_number):
                if not history.opponent_actions[round_idx, player]:
                    defections += 1
                total_rounds += 1
            if total_rounds > 0 and defections / total_rounds > 0.5:
                defector_count += 1
        return defector_count

    def _detect_cooperation_trend(self, history: PlayerHistory) -> str:
        """Detect if cooperation is increasing, stable, or declining."""
        if history.round_number < 3:
            return 'stable'
        recent_cooperation = []
        start_round = max(0, history.round_number - 3)
        for round_idx in range(start_round, history.round_number):
            round_cooperation = sum(history.opponent_actions[round_idx])
            if history.my_actions[round_idx]:
                round_cooperation += 1
            recent_cooperation.append(round_cooperation)
        if len(recent_cooperation) < 2:
            return 'stable'
        if recent_cooperation[-1] < recent_cooperation[-2]:
            if len(recent_cooperation) >= 3 and recent_cooperation[-2] < recent_cooperation[-3]:
                return 'declining'
        return 'stable'

class Strategy_AGGRESSIVE_94(BaseStrategy):
    """
    Aggressive "Predatory Threshold Exploitation" strategy that maximizes exploitation
    of cooperative players while strategically cooperating only when necessary to
    maintain the collective benefit system.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self.opponent_cooperation_rates = np.zeros(self.n - 1)
        self.opponent_classifications = ['UNKNOWN'] * (self.n - 1)
        self.my_cooperation_count = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        rounds_remaining = self.r - current_round
        self._update_opponent_classifications(history)
        my_cooperation_rate = self.my_cooperation_count / history.round_number
        if current_round >= self.r - 1:
            return Action.D
        last_round_idx = history.round_number - 1
        cooperators_last_round = int(np.sum(history.opponent_actions[last_round_idx]))
        if history.my_actions[last_round_idx]:
            cooperators_last_round += 1
        if cooperators_last_round >= self.m:
            action = Action.D
        elif cooperators_last_round == self.m - 1:
            if my_cooperation_rate < 0.3 and rounds_remaining > 3:
                action = Action.C
                self.my_cooperation_count += 1
            else:
                action = Action.D
        elif rounds_remaining > 5:
            action = Action.C
            self.my_cooperation_count += 1
        else:
            action = Action.D
        action = self._apply_adaptive_exploitation(history, action, cooperators_last_round)
        return action

    def _update_opponent_classifications(self, history):
        """Update opponent cooperation rates and classifications."""
        for i in range(self.n - 1):
            cooperations = np.sum(history.opponent_actions[:, i])
            self.opponent_cooperation_rates[i] = cooperations / history.round_number
            if self.opponent_cooperation_rates[i] > 0.7:
                self.opponent_classifications[i] = 'EXPLOITABLE'
            elif self.opponent_cooperation_rates[i] < 0.3:
                self.opponent_classifications[i] = 'COMPETITOR'
            else:
                self.opponent_classifications[i] = 'CONDITIONAL'

    def _apply_adaptive_exploitation(self, history, base_action, cooperators_last_round):
        """Apply adaptive exploitation rules to override base decision."""
        exploitable_count = sum((1 for c in self.opponent_classifications if c == 'EXPLOITABLE'))
        conditional_count = sum((1 for c in self.opponent_classifications if c == 'CONDITIONAL'))
        expected_cooperators = exploitable_count + int(conditional_count * 0.5)
        if expected_cooperators >= self.m:
            return Action.D
        elif expected_cooperators == self.m - 1:
            if base_action == Action.C:
                self.my_cooperation_count += 1
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_95(BaseStrategy):
    """
    Ruthless Exploiter - An aggressive strategy that maximizes personal gain by exploiting 
    cooperative players while minimizing personal risk. Always prioritizes immediate payoff 
    over long-term cooperation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n = self.game_description.n_players
        m = self.game_description.m
        k = self.game_description.k
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        if current_round == r:
            return Action.D
        expected_cooperators = self._estimate_future_cooperation(history)
        if expected_cooperators >= m:
            return Action.D
        elif expected_cooperators == m - 1:
            if k > 2.0 and current_round < r:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _estimate_future_cooperation(self, history: PlayerHistory) -> int:
        """
        Estimate how many players will cooperate based on their historical patterns.
        Identifies consistent cooperators vs defectors.
        """
        n_opponents = self.game_description.n_players - 1
        consistent_cooperators = 0
        for opponent_idx in range(n_opponents):
            total_rounds = history.round_number
            if total_rounds > 0:
                cooperations = sum(history.opponent_actions[:total_rounds, opponent_idx])
                cooperation_rate = cooperations / total_rounds
                if cooperation_rate > 0.7:
                    consistent_cooperators += 1
        return consistent_cooperators

class Strategy_AGGRESSIVE_96(BaseStrategy):
    """
    Exploitation Maximizer: An aggressive strategy that maximizes personal payoff by exploiting 
    cooperative players while minimizing personal risk. Only cooperates when absolutely necessary 
    to reach the threshold m, preferring to free-ride on others' cooperation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n = self.game_description.n_players
        m = self.game_description.m
        k = self.game_description.k
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        if current_round == r:
            return Action.D
        if history.round_number > 0:
            last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
        else:
            last_round_cooperators = max(0, m - 2)
        estimated_cooperators = last_round_cooperators
        if estimated_cooperators == m - 1:
            expected_benefit = k
            cooperation_cost = 1
            if expected_benefit > cooperation_cost:
                return Action.C
            else:
                return Action.D
        elif estimated_cooperators >= m:
            return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_97(BaseStrategy):
    """
    Aggressive Exploitation Maximizer strategy that aims to maximize personal payoffs
    by exploiting cooperative players while minimizing personal risk. Only cooperates
    when absolutely necessary to maintain threshold benefits.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punishment_rounds_left = 0
        self.in_punishment_mode = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_number = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        minimum_threshold = self.game_description.m
        if round_number == total_rounds:
            return Action.D
        if self.in_punishment_mode and self.punishment_rounds_left > 0:
            self.punishment_rounds_left -= 1
            if self.punishment_rounds_left == 0:
                self.in_punishment_mode = False
            return Action.D
        last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
        if history.my_actions[history.round_number - 1]:
            last_round_cooperators += 1
        if round_number <= 2:
            return Action.D
        if history.round_number > 0 and history.my_actions[history.round_number - 1] and (last_round_cooperators < minimum_threshold):
            self.in_punishment_mode = True
            self.punishment_rounds_left = 2
            return Action.D
        if round_number >= total_rounds - 1:
            success_rate = self._calculate_threshold_success_rate(history)
            if success_rate >= 0.7:
                return Action.D
        if last_round_cooperators > minimum_threshold:
            return Action.D
        if last_round_cooperators == minimum_threshold:
            return Action.D
        if last_round_cooperators == minimum_threshold - 1:
            if not history.my_actions[history.round_number - 1]:
                expected_cooperators = self._predict_cooperators(history)
                if expected_cooperators >= minimum_threshold - 1:
                    return Action.C
            return Action.D
        return Action.D

    def _calculate_threshold_success_rate(self, history: PlayerHistory) -> float:
        """Calculate what fraction of rounds met the cooperation threshold."""
        if history.round_number == 0:
            return 0.0
        successful_rounds = 0
        minimum_threshold = self.game_description.m
        for round_idx in range(history.round_number):
            cooperators = sum(history.opponent_actions[round_idx])
            if history.my_actions[round_idx]:
                cooperators += 1
            if cooperators >= minimum_threshold:
                successful_rounds += 1
        return successful_rounds / history.round_number

    def _predict_cooperators(self, history: PlayerHistory) -> int:
        """Predict how many players will cooperate based on recent patterns."""
        if history.round_number < 2:
            return 0
        lookback = min(3, history.round_number)
        recent_cooperation_rates = []
        for player_idx in range(self.game_description.n_players - 1):
            recent_cooperations = sum((history.opponent_actions[history.round_number - i - 1, player_idx] for i in range(lookback)))
            cooperation_rate = recent_cooperations / lookback
            recent_cooperation_rates.append(cooperation_rate)
        predicted_cooperators = sum((1 for rate in recent_cooperation_rates if rate >= 0.5))
        return predicted_cooperators

class Strategy_AGGRESSIVE_98(BaseStrategy):
    """
    Predatory Threshold Exploiter: An aggressive strategy that maximizes exploitation
    with minimal contribution. Always defects round 1, exploits when threshold is met,
    and only cooperates when absolutely necessary to secure collective rewards.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        cooperators_last_round = sum(history.opponent_actions[history.round_number - 1])
        if current_round == self.r:
            if cooperators_last_round >= self.m:
                return Action.D
            elif cooperators_last_round >= self.m - 2:
                total_rounds_so_far = history.round_number
                total_cooperators = 0
                for round_idx in range(total_rounds_so_far):
                    total_cooperators += sum(history.opponent_actions[round_idx])
                historical_cooperation_rate = total_cooperators / (self.n * total_rounds_so_far)
                if historical_cooperation_rate > 0.6:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
        if cooperators_last_round >= self.m:
            return Action.D
        elif cooperators_last_round == self.m - 1:
            recent_cooperation_trend = self._analyze_trend(history)
            estimated_cooperators = self._estimate_cooperators_this_round(history)
            if recent_cooperation_trend and estimated_cooperators >= self.m - 1:
                return Action.C
            else:
                return Action.D
        else:
            rounds_remaining = self.r - current_round
            if rounds_remaining <= 2 and cooperators_last_round >= self.m - 2:
                return Action.C
            else:
                return Action.D

    def _analyze_trend(self, history: PlayerHistory) -> bool:
        """Analyze if cooperation is increasing over the last few rounds."""
        rounds_to_check = min(3, history.round_number)
        if rounds_to_check < 2:
            return False
        cooperation_increases = 0
        start_idx = history.round_number - rounds_to_check
        for i in range(start_idx, history.round_number - 1):
            cooperators_current = sum(history.opponent_actions[i])
            cooperators_next = sum(history.opponent_actions[i + 1])
            if cooperators_next > cooperators_current:
                cooperation_increases += 1
        return cooperation_increases > (rounds_to_check - 1) / 2

    def _estimate_cooperators_this_round(self, history: PlayerHistory) -> int:
        """Estimate how many will cooperate this round based on recent patterns."""
        if history.round_number == 0:
            return 0
        if history.round_number >= 2:
            recent_avg = (sum(history.opponent_actions[history.round_number - 1]) + sum(history.opponent_actions[history.round_number - 2])) / 2
            return int(recent_avg)
        else:
            return sum(history.opponent_actions[history.round_number - 1])

class Strategy_AGGRESSIVE_99(BaseStrategy):
    """
    Exploitative Threshold Rider: An aggressive strategy that maximizes personal payoff
    by exploiting cooperative players while minimizing personal risk. Always defects
    in the first round, then uses sophisticated threshold manipulation and opponent
    classification to free-ride whenever possible.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number
        rounds_remaining = self.r - current_round
        last_round_idx = current_round - 1
        observed_cooperators = int(sum(history.opponent_actions[last_round_idx]))
        if observed_cooperators >= self.m:
            return Action.D
        if observed_cooperators == self.m - 1:
            cooperative_trend = self._analyze_cooperation_trend(history)
            if cooperative_trend == 'increasing' or rounds_remaining <= 3:
                return Action.C
            else:
                return Action.D
        if rounds_remaining == 1:
            return Action.D
        elif observed_cooperators > 0 and rounds_remaining <= 5:
            return Action.C
        else:
            return Action.D

    def _analyze_cooperation_trend(self, history: PlayerHistory) -> str:
        """Analyze if cooperation is increasing, decreasing, or stable."""
        current_round = history.round_number
        if current_round < 2:
            return 'stable'
        rounds_to_check = min(3, current_round)
        cooperation_counts = []
        for i in range(rounds_to_check):
            round_idx = current_round - 1 - i
            cooperators = int(sum(history.opponent_actions[round_idx]))
            cooperation_counts.append(cooperators)
        if len(cooperation_counts) >= 2:
            if cooperation_counts[0] > cooperation_counts[1]:
                return 'increasing'
            elif cooperation_counts[0] < cooperation_counts[1]:
                return 'decreasing'
        return 'stable'

class Strategy_AGGRESSIVE_100(BaseStrategy):
    """
    Exploitative Threshold Rider: An aggressive strategy that maximizes personal payoff 
    by free-riding on others' cooperation while only cooperating when pivotal and 
    mathematically beneficial.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.n_rounds:
            return Action.D
        last_round_cooperators = int(sum(history.opponent_actions[history.round_number - 1]))
        if history.my_actions[history.round_number - 1]:
            last_round_cooperators += 1
        expected_cooperators = self._estimate_cooperators_this_round(history)
        if expected_cooperators >= self.m:
            return Action.D
        if expected_cooperators == self.m - 1:
            remaining_rounds = self.n_rounds - current_round + 1
            future_benefit = remaining_rounds * self.k
            cooperation_cost = 1
            if future_benefit > cooperation_cost:
                return Action.C
        return Action.D

    def _estimate_cooperators_this_round(self, history: PlayerHistory) -> int:
        """Estimate how many opponents will cooperate this round based on their patterns."""
        n_opponents = self.n_players - 1
        expected = 0.0
        for opponent_idx in range(n_opponents):
            opponent_history = history.opponent_actions[:history.round_number, opponent_idx]
            cooperation_rate = float(sum(opponent_history)) / len(opponent_history)
            if cooperation_rate > 0.7:
                expected += 1.0
            elif cooperation_rate > 0.3:
                last_round_total = int(sum(history.opponent_actions[history.round_number - 1]))
                if history.my_actions[history.round_number - 1]:
                    last_round_total += 1
                if last_round_total >= self.m:
                    expected += 0.5
                else:
                    expected += 0.2
        return int(expected)

class Strategy_AGGRESSIVE_101(BaseStrategy):
    """
    Exploitative Threshold Hunter - An aggressive strategy that maximizes personal payoffs
    by free-riding on cooperative players while minimizing personal risk. Defects initially
    to gather intelligence, cooperates minimally only when necessary to secure the threshold,
    and always defects in endgame rounds for maximum exploitation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round >= self.r - 1:
            return Action.D
        predicted_cooperators = self._estimate_cooperators(history)
        my_coop_ratio = np.sum(history.my_actions) / len(history.my_actions) if len(history.my_actions) > 0 else 0
        if predicted_cooperators >= self.m:
            return Action.D
        elif predicted_cooperators == self.m - 1:
            if my_coop_ratio < 0.3:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _estimate_cooperators(self, history: PlayerHistory) -> int:
        """Estimate how many opponents will cooperate this round."""
        if history.round_number == 0:
            return 0
        predicted_cooperators = 0
        for player_idx in range(self.n - 1):
            player_actions = history.opponent_actions[:, player_idx]
            if len(player_actions) == 0:
                continue
            coop_ratio = np.sum(player_actions) / len(player_actions)
            if coop_ratio >= 0.6:
                predicted_cooperators += 1
                continue
            if len(player_actions) >= 2:
                last_action = player_actions[-1]
                matches = 1
                for i in range(len(player_actions) - 2, -1, -1):
                    if player_actions[i] == last_action:
                        matches += 1
                    else:
                        break
                if matches >= 2 and last_action:
                    predicted_cooperators += 1
                    continue
            if player_actions[-1]:
                predicted_cooperators += 1
        fatigue_factor = max(0.5, 1.0 - 0.1 * (history.round_number / self.r))
        predicted_cooperators = int(predicted_cooperators * fatigue_factor)
        if self.n <= 4:
            predicted_cooperators = max(0, predicted_cooperators - 1)
        if self.m > self.n // 2:
            predicted_cooperators = min(self.n - 1, predicted_cooperators + 1)
        return max(0, min(self.n - 1, predicted_cooperators))

class Strategy_AGGRESSIVE_102(BaseStrategy):
    """
    Opportunistic Exploitation strategy that maximizes personal payoff by exploiting 
    cooperation from others while minimizing personal sacrifice. Defects in round 1,
    exploits surplus cooperation, rides the threshold when possible, and always 
    defects in the final round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        last_round_idx = history.round_number - 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        last_round_cooperators = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            last_round_cooperators += 1
        my_last_action = Action.C if history.my_actions[last_round_idx] else Action.D
        m = self.game_description.m
        if last_round_cooperators >= m + 1:
            return Action.D
        elif last_round_cooperators == m:
            if my_last_action == Action.C:
                return Action.D
            else:
                return Action.C
        elif last_round_cooperators == m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_103(BaseStrategy):
    """
    Exploitative Threshold Hunter: An aggressive strategy that maximizes personal gain 
    by free-riding on cooperative players while strategically contributing only when 
    absolutely necessary to secure the collective reward.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.cooperation_rates = {}
        self.recent_trends = {}
        self.opponent_labels = {}
        self.risk_adjustment_factor = 1.1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        m = self.game_description.m
        k = self.game_description.k
        current_round = history.round_number + 1
        self._update_opponent_models(history)
        if current_round > 0.8 * n_rounds:
            cooperation_threshold = 0.9
        else:
            cooperation_threshold = 0.6
        if current_round == n_rounds:
            return Action.D
        if current_round <= 3:
            if current_round > 1:
                last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
                if last_round_cooperators == m - 1:
                    return Action.C
            return Action.D
        predicted_cooperators = self._predict_cooperators_this_round(history)
        sucker_count = sum((1 for label in self.opponent_labels.values() if label == 'SUCKER'))
        if sucker_count >= m:
            return Action.D
        prob_threshold_met_without_me = self._calculate_threshold_probability(predicted_cooperators, m)
        prob_threshold_met_with_me = self._calculate_threshold_probability(predicted_cooperators + 1, m)
        ev_defect = 1 + prob_threshold_met_without_me * k
        ev_cooperate = 0 + prob_threshold_met_with_me * k
        if ev_cooperate > ev_defect * self.risk_adjustment_factor:
            if predicted_cooperators >= m - 1 and prob_threshold_met_with_me >= cooperation_threshold:
                return Action.C
        return Action.D

    def _update_opponent_models(self, history: PlayerHistory):
        """Update cooperation rates and labels for all opponents"""
        n_opponents = history.opponent_actions.shape[1]
        rounds_played = history.round_number
        for i in range(n_opponents):
            total_cooperations = sum(history.opponent_actions[:, i])
            cooperation_rate = total_cooperations / rounds_played
            self.cooperation_rates[i] = cooperation_rate
            if rounds_played >= 3:
                recent_actions = history.opponent_actions[-3:, i]
                weights = [0.2, 0.3, 0.5]
                recent_trend = sum((recent_actions[j] * weights[j] for j in range(len(recent_actions))))
                self.recent_trends[i] = recent_trend
            else:
                self.recent_trends[i] = cooperation_rate
            if cooperation_rate > 0.7:
                self.opponent_labels[i] = 'SUCKER'
            elif cooperation_rate < 0.3:
                self.opponent_labels[i] = 'DEFECTOR'
            else:
                self.opponent_labels[i] = 'CONDITIONAL'

    def _predict_cooperators_this_round(self, history: PlayerHistory) -> int:
        """Predict how many opponents will cooperate this round"""
        predicted_cooperators = 0
        n_opponents = history.opponent_actions.shape[1]
        for i in range(n_opponents):
            cooperation_rate = self.cooperation_rates.get(i, 0.5)
            recent_trend = self.recent_trends.get(i, cooperation_rate)
            predicted_prob = 0.3 * cooperation_rate + 0.7 * recent_trend
            label = self.opponent_labels.get(i, 'CONDITIONAL')
            if label == 'SUCKER':
                predicted_prob = max(predicted_prob, 0.8)
            elif label == 'DEFECTOR':
                predicted_prob = min(predicted_prob, 0.2)
            if predicted_prob > 0.5:
                predicted_cooperators += 1
        return predicted_cooperators

    def _calculate_threshold_probability(self, expected_cooperators: int, threshold: int) -> float:
        """Calculate probability that threshold will be met given expected cooperators"""
        if expected_cooperators >= threshold:
            return min(0.95, 0.7 + 0.05 * (expected_cooperators - threshold))
        elif expected_cooperators == threshold - 1:
            return 0.4
        elif expected_cooperators == threshold - 2:
            return 0.15
        else:
            return 0.05

class Strategy_AGGRESSIVE_104(BaseStrategy):
    """
    Aggressive "Predatory Threshold Manipulation" strategy that exploits cooperative players
    while minimizing personal risk through calculated defection and strategic free-riding.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        current_round = history.round_number + 1
        last_round_idx = history.round_number - 1
        observed_cooperators = int(sum(history.opponent_actions[last_round_idx]))
        if history.my_actions[last_round_idx]:
            observed_cooperators += 1
        if current_round <= r // 3:
            return Action.D
        elif current_round > 2 * r // 3:
            if current_round >= r - 1:
                return Action.D
            elif observed_cooperators >= m + 1:
                return Action.D
            else:
                return Action.D
        else:
            rounds_remaining = r - current_round
            if observed_cooperators >= m:
                return Action.D
            elif observed_cooperators == m - 1:
                if rounds_remaining > r // 4:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D

class Strategy_AGGRESSIVE_105(BaseStrategy):
    """
    Aggressive "Exploitation Maximizer" strategy that maximizes personal payoffs by 
    exploiting cooperative behavior from others while minimizing personal contributions.
    Defaults to defection and only cooperates when absolutely necessary to secure rewards.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        phase1_end = max(1, self.r // 3)
        phase2_end = max(2, 2 * self.r // 3)
        if current_round <= phase1_end:
            return self._phase1_strategy(history)
        elif current_round <= phase2_end:
            return self._phase2_strategy(history)
        else:
            return self._phase3_strategy(history)

    def _phase1_strategy(self, history: PlayerHistory) -> Action:
        """Early rounds: Default DEFECT to establish non-cooperator stance"""
        if history.round_number >= 1:
            last_round_cooperators = self._count_cooperators_last_round(history)
            if last_round_cooperators < self.m - 1:
                return Action.D
        return Action.D

    def _phase2_strategy(self, history: PlayerHistory) -> Action:
        """Middle rounds: Conditional cooperation with exploitation focus"""
        last_round_cooperators = self._count_cooperators_last_round(history)
        if last_round_cooperators >= self.m:
            return Action.D
        elif last_round_cooperators == self.m - 1:
            consistent_cooperators = self._identify_consistent_cooperators(history)
            if self._am_consistent_cooperator(history):
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

    def _phase3_strategy(self, history: PlayerHistory) -> Action:
        """Final rounds: Strategic endgame exploitation"""
        current_round = history.round_number + 1
        rounds_remaining = self.r - current_round + 1
        if rounds_remaining <= 2:
            last_round_cooperators = self._count_cooperators_last_round(history)
            if last_round_cooperators >= self.m:
                return Action.D
            elif last_round_cooperators == self.m - 1:
                return Action.C
            else:
                return Action.D
        else:
            recent_cooperation = self._average_cooperation_last_n_rounds(history, 3)
            if recent_cooperation >= self.m + 1:
                return Action.D
            elif recent_cooperation >= self.m:
                return Action.D
            else:
                return Action.C

    def _count_cooperators_last_round(self, history: PlayerHistory) -> int:
        """Count cooperators in the most recent round"""
        if history.round_number == 0:
            return 0
        return int(sum(history.opponent_actions[history.round_number - 1]))

    def _identify_consistent_cooperators(self, history: PlayerHistory) -> list:
        """Identify players who cooperate frequently (>60% of rounds)"""
        if history.round_number == 0:
            return []
        consistent = []
        for player_idx in range(self.n - 1):
            cooperation_rate = sum(history.opponent_actions[:history.round_number, player_idx]) / history.round_number
            if cooperation_rate > 0.6:
                consistent.append(player_idx)
        return consistent

    def _am_consistent_cooperator(self, history: PlayerHistory) -> bool:
        """Check if I am a consistent cooperator (>60% cooperation rate)"""
        if history.round_number == 0:
            return False
        my_cooperation_rate = sum(history.my_actions) / history.round_number
        return my_cooperation_rate > 0.6

    def _average_cooperation_last_n_rounds(self, history: PlayerHistory, n: int) -> float:
        """Calculate average number of cooperators in last n rounds"""
        if history.round_number == 0:
            return 0
        start_round = max(0, history.round_number - n)
        total_cooperators = 0
        rounds_counted = 0
        for round_idx in range(start_round, history.round_number):
            total_cooperators += sum(history.opponent_actions[round_idx])
            rounds_counted += 1
        return total_cooperators / rounds_counted if rounds_counted > 0 else 0

class Strategy_AGGRESSIVE_106(BaseStrategy):
    """
    Exploitative Threshold Rider: An aggressive strategy that maximizes personal payoffs
    by free-riding on others' cooperation while only contributing when absolutely necessary
    to secure the collective benefit.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        last_round_cooperators = sum(history.opponent_actions[history.round_number - 1]) + int(history.my_actions[history.round_number - 1])
        if current_round <= r - 1:
            if last_round_cooperators == m - 1:
                return Action.C
            else:
                return Action.D
        if current_round == r:
            total_actions = 0
            total_cooperations = 0
            for round_idx in range(history.round_number):
                total_cooperations += sum(history.opponent_actions[round_idx])
                total_actions += len(history.opponent_actions[round_idx])
            total_cooperations += sum(history.my_actions)
            total_actions += len(history.my_actions)
            avg_coop_rate = total_cooperations / total_actions if total_actions > 0 else 0
            if avg_coop_rate >= (m - 1) / n:
                return Action.D
            else:
                return Action.C
        consistent_cooperators = 0
        for player_idx in range(len(history.opponent_actions[0])):
            player_cooperations = sum((history.opponent_actions[round_idx][player_idx] for round_idx in range(history.round_number)))
            if player_cooperations > history.round_number / 2:
                consistent_cooperators += 1
        my_cooperations = sum(history.my_actions)
        if my_cooperations > history.round_number / 2:
            consistent_cooperators += 1
        if consistent_cooperators >= m - 1:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_107(BaseStrategy):
    """
    Aggressive Exploitative Threshold Hunter: Exploits cooperative players while minimizing personal risk.
    Only cooperates when absolutely necessary to secure collective reward.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.failed_cooperations = 0
        self.successful_cooperations = 0
        self.effective_threshold = game_description.m

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx]) + int(history.my_actions[last_round_idx])
        if cooperators_last_round >= self.game_description.m:
            self.successful_cooperations += 1
        else:
            self.failed_cooperations += 1
        if self.failed_cooperations > self.successful_cooperations:
            self.effective_threshold = self.game_description.m + 1
        else:
            self.effective_threshold = self.game_description.m
        if current_round == self.game_description.n_rounds:
            return Action.D
        if cooperators_last_round >= self.effective_threshold:
            return Action.D
        elif cooperators_last_round == self.effective_threshold - 1:
            if history.my_actions[last_round_idx]:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_108(BaseStrategy):
    """
    Opportunistic Exploiter: Aggressively pursues free-riding opportunities,
    only cooperating when absolutely necessary for self-preservation.
    Exploits others' cooperation while minimizing own contributions.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.m = game_description.m
        self.k = game_description.k
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        prev_round_idx = history.round_number - 1
        prev_cooperators = int(sum(history.opponent_actions[prev_round_idx]))
        reliable_cooperators = self._count_reliable_cooperators(history)
        predicted_cooperators = reliable_cooperators
        if predicted_cooperators >= self.m:
            return Action.D
        elif predicted_cooperators == self.m - 1:
            if current_round >= self.r - 2:
                if predicted_cooperators < self.m - 1:
                    return Action.D
                else:
                    return Action.C
            elif random.random() < 0.3:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _count_reliable_cooperators(self, history: PlayerHistory) -> int:
        """Count opponents with cooperation rate > 60%"""
        if history.round_number == 0:
            return 0
        reliable_count = 0
        n_opponents = self.n - 1
        for opponent_idx in range(n_opponents):
            cooperations = sum(history.opponent_actions[:history.round_number, opponent_idx])
            cooperation_rate = cooperations / history.round_number
            if cooperation_rate > 0.6:
                reliable_count += 1
        return reliable_count

class Strategy_AGGRESSIVE_109(BaseStrategy):
    """
    Aggressive Exploitative Threshold Rider strategy that maximizes personal payoffs
    by exploiting others' cooperation while minimizing personal risk. Only cooperates
    when absolutely necessary to hit the threshold, otherwise defects to free-ride.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.persistent_defector = False
        self.cooperation_failures = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if self.persistent_defector:
            return Action.D
        last_round_idx = history.round_number - 1
        last_cooperators = sum(history.opponent_actions[last_round_idx]) + int(history.my_actions[last_round_idx])
        if last_cooperators > 0 and last_cooperators < self.game_description.m:
            self.cooperation_failures += 1
            if self.cooperation_failures >= 2:
                self.persistent_defector = True
                return Action.D
        if last_cooperators >= self.game_description.m:
            return Action.D
        recent_opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        remaining_rounds = self.game_description.n_rounds - current_round + 1
        if recent_opponent_cooperators == self.game_description.m - 1 and remaining_rounds >= 3:
            return Action.C
        if current_round == self.game_description.n_rounds:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_110(BaseStrategy):
    """
    Ruthless Exploiter: An aggressive strategy that maximizes personal payoff by 
    exploiting cooperative opponents while minimizing personal risk. Always defects 
    in the final round and free-rides when the cooperation threshold is safely met 
    by others.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        last_round_index = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_index])
        if history.my_actions[last_round_index]:
            cooperators_last_round += 1
        my_cooperation_rate = sum(history.my_actions) / len(history.my_actions)
        if cooperators_last_round >= self.m + 2:
            return Action.D
        if cooperators_last_round < self.m - 1:
            return Action.D
        if cooperators_last_round == self.m - 1:
            if my_cooperation_rate < 0.3:
                return Action.C
            else:
                return Action.D
        if cooperators_last_round == self.m:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_111(BaseStrategy):
    """
    Threshold Vulture: An aggressive exploitation strategy that free-rides whenever possible
    while minimizing personal risk. Cooperates only when absolutely necessary to secure
    collective rewards, aiming to maximize individual payoff through systematic exploitation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            if self.m / self.n > 0.6:
                return Action.C
            else:
                return Action.D
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        cooperators_needed = self.m - self._count_expected_cooperators(history)
        if cooperators_needed <= 0:
            return Action.D
        if cooperators_needed == 1:
            if self._expected_future_exploitation_value(current_round) > 1:
                return Action.C
            else:
                return Action.D
        if cooperators_needed > 1:
            if self._am_most_reliable_cooperator(history):
                return Action.C
            else:
                return Action.D
        return Action.D

    def _count_expected_cooperators(self, history: PlayerHistory) -> int:
        """Estimate how many opponents will cooperate based on their patterns."""
        if history.round_number == 0:
            return 0
        lookback = min(3, history.round_number)
        recent_actions = history.opponent_actions[-lookback:]
        expected_cooperators = 0
        for player_idx in range(self.n - 1):
            player_actions = recent_actions[:, player_idx]
            coop_rate = np.mean(player_actions)
            current_round = history.round_number + 1
            phase_factor = max(0.3, 1.0 - current_round / self.r * 0.7)
            adjusted_rate = coop_rate * phase_factor
            if adjusted_rate > 0.5:
                expected_cooperators += 1
        return expected_cooperators

    def _expected_future_exploitation_value(self, current_round: int) -> float:
        """Calculate expected value from future free-riding opportunities."""
        remaining_rounds = self.r - current_round
        return remaining_rounds * self.k * 0.8

    def _am_most_reliable_cooperator(self, history: PlayerHistory) -> bool:
        """Check if I'm the most reliable cooperator among players needed."""
        if history.round_number == 0:
            return True
        my_coop_rate = np.mean(history.my_actions)
        opponent_rates = []
        for player_idx in range(self.n - 1):
            player_actions = history.opponent_actions[:, player_idx]
            coop_rate = np.mean(player_actions)
            opponent_rates.append(coop_rate)
        higher_rates = sum((1 for rate in opponent_rates if rate > my_coop_rate))
        cooperators_needed = self.m - self._count_expected_cooperators(history)
        return higher_rates < cooperators_needed - 1

class Strategy_AGGRESSIVE_112(BaseStrategy):
    """
    Predatory Threshold Exploiter: An aggressive strategy that maximizes personal payoffs
    by exploiting others' cooperation while minimizing own contributions. Defects in most
    rounds and only cooperates when absolutely necessary to avoid total failure.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        if current_round <= r - 2:
            return Action.D
        elif current_round == r - 1:
            if history.round_number >= 1:
                cooperators_last_round = sum(history.opponent_actions[history.round_number - 1])
                total_cooperations = np.sum(history.opponent_actions)
                total_possible = (n - 1) * history.round_number
                avg_cooperation_rate = total_cooperations / total_possible if total_possible > 0 else 0
                threshold_rate = m / (n - 1) * 1.2
                if avg_cooperation_rate >= threshold_rate:
                    return Action.D
                else:
                    return Action.D
            else:
                return Action.D
        elif history.round_number >= 1:
            cooperators_last_round = sum(history.opponent_actions[history.round_number - 1])
            total_rounds = history.round_number
            total_cooperators = 0
            for round_idx in range(total_rounds):
                total_cooperators += sum(history.opponent_actions[round_idx])
            historical_avg_cooperators = total_cooperators / total_rounds if total_rounds > 0 else 0
            predicted_cooperators = max(cooperators_last_round, historical_avg_cooperators)
            if predicted_cooperators >= m:
                return Action.D
            elif predicted_cooperators >= m - 1:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_113(BaseStrategy):
    """
    Exploitative Threshold Hunter: An aggressive strategy that maximizes personal payoffs
    by exploiting cooperative players while minimizing personal risk. Defects in round 1
    and final round, and uses sophisticated opponent modeling to free-ride when safe.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self.player_types = {}
        self.cooperation_predictions = {}
        self.exploitation_threshold = 0.7
        self.weight_recent = 0.5
        self.weight_trend = 0.3
        self.weight_retaliation = 0.2

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        return self._adaptive_exploitation_decision(history)

    def _adaptive_exploitation_decision(self, history: PlayerHistory) -> Action:
        """Core decision logic for exploitation strategy."""
        self._update_opponent_models(history)
        expected_cooperators = self._predict_total_cooperators(history)
        if expected_cooperators >= self.m + 2:
            return Action.D
        elif expected_cooperators == self.m + 1:
            return Action.D
        elif expected_cooperators == self.m:
            return Action.C
        else:
            return Action.C

    def _update_opponent_models(self, history: PlayerHistory) -> None:
        """Update opponent classification and prediction models."""
        for player_idx in range(self.n - 1):
            if player_idx not in self.player_types:
                self.player_types[player_idx] = 'Unknown'
                self.cooperation_predictions[player_idx] = 0.5
            rounds_to_check = min(3, history.round_number)
            recent_cooperations = 0
            for r in range(max(0, history.round_number - rounds_to_check), history.round_number):
                if history.opponent_actions[r, player_idx]:
                    recent_cooperations += 1
            recent_cooperation_rate = recent_cooperations / rounds_to_check if rounds_to_check > 0 else 0.5
            trend = 0
            if history.round_number >= 4:
                early_coop_rate = sum(history.opponent_actions[:2, player_idx]) / 2
                late_coop_rate = sum(history.opponent_actions[-2:, player_idx]) / 2
                trend = late_coop_rate - early_coop_rate
            retaliation_factor = 0
            if history.round_number >= 2:
                my_defections = 0
                opponent_responses = 0
                for r in range(history.round_number - 1):
                    if not history.my_actions[r]:
                        my_defections += 1
                        if r + 1 < history.round_number:
                            if not history.opponent_actions[r + 1, player_idx]:
                                opponent_responses += 1
                if my_defections > 0:
                    retaliation_factor = opponent_responses / my_defections
            self.cooperation_predictions[player_idx] = self.weight_recent * recent_cooperation_rate + self.weight_trend * max(0, trend) + self.weight_retaliation * (1 - retaliation_factor)
            if recent_cooperation_rate > 0.8:
                self.player_types[player_idx] = 'Naive Cooperator'
            elif recent_cooperation_rate < 0.2:
                self.player_types[player_idx] = 'Aggressive Defector'
            elif abs(trend) > 0.3:
                self.player_types[player_idx] = 'Strategic Player'
            else:
                self.player_types[player_idx] = 'Conditional Cooperator'

    def _predict_total_cooperators(self, history: PlayerHistory) -> int:
        """Predict total number of cooperators in next round."""
        expected_cooperators = 0
        for player_idx in range(self.n - 1):
            if player_idx in self.cooperation_predictions:
                expected_cooperators += self.cooperation_predictions[player_idx]
            else:
                expected_cooperators += 0.5
        current_round = history.round_number + 1
        if current_round > self.r * 0.8:
            expected_cooperators *= 0.8
        if history.round_number > 0:
            last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
            if last_round_cooperators >= self.m:
                expected_cooperators *= 1.1
            else:
                expected_cooperators *= 0.9
        noise = (random.random() - 0.5) * 0.5
        expected_cooperators += noise
        return max(0, min(self.n - 1, int(round(expected_cooperators))))

class Strategy_AGGRESSIVE_114(BaseStrategy):
    """
    Aggressive Strategy: "Exploitation Maximizer"
    
    Maximizes personal payoff by aggressively exploiting cooperative players while
    minimizing personal risk. Defaults to defection and only cooperates when
    strategically necessary to secure collective rewards.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n = self.game_description.n_players
        m = self.game_description.m
        k = self.game_description.k
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        if current_round == r:
            return Action.D
        player_coop_rates = self._calculate_cooperation_rates(history)
        reliable_cooperators = sum((1 for rate in player_coop_rates if rate > 0.7))
        if reliable_cooperators >= m:
            return Action.D
        elif reliable_cooperators == m - 1:
            endgame_threshold = int(r * 0.8)
            if current_round <= endgame_threshold:
                prob_others_cooperate = self._estimate_cooperation_probability(history)
                if prob_others_cooperate > 0.6:
                    return Action.D
                else:
                    return Action.C
            else:
                prob_others_cooperate = self._estimate_cooperation_probability(history)
                if prob_others_cooperate > 0.9:
                    return Action.D
                else:
                    return Action.C
        else:
            recent_failures = self._count_recent_failures(history, 3)
            if recent_failures >= 2:
                return Action.C
            else:
                return Action.D

    def _calculate_cooperation_rates(self, history: PlayerHistory) -> list:
        """Calculate cooperation rate for each opponent."""
        rates = []
        n_rounds = history.round_number
        for player_idx in range(self.game_description.n_players - 1):
            if n_rounds == 0:
                rates.append(0.0)
            else:
                cooperations = sum((history.opponent_actions[round_idx, player_idx] for round_idx in range(n_rounds)))
                rates.append(cooperations / n_rounds)
        return rates

    def _estimate_cooperation_probability(self, history: PlayerHistory) -> float:
        """Estimate probability that enough others will cooperate this round."""
        if history.round_number == 0:
            return 0.5
        recent_rounds = min(3, history.round_number)
        recent_coop_counts = []
        for round_idx in range(history.round_number - recent_rounds, history.round_number):
            coop_count = sum(history.opponent_actions[round_idx])
            recent_coop_counts.append(coop_count)
        if not recent_coop_counts:
            return 0.5
        avg_recent_coops = sum(recent_coop_counts) / len(recent_coop_counts)
        needed_cooperators = self.game_description.m - 1
        total_opponents = self.game_description.n_players - 1
        if avg_recent_coops >= needed_cooperators:
            return min(0.95, avg_recent_coops / total_opponents + 0.2)
        else:
            return max(0.05, avg_recent_coops / total_opponents)

    def _count_recent_failures(self, history: PlayerHistory, window: int) -> int:
        """Count how many of the last 'window' rounds failed to meet threshold."""
        if history.round_number == 0:
            return 0
        failures = 0
        start_round = max(0, history.round_number - window)
        for round_idx in range(start_round, history.round_number):
            total_cooperators = sum(history.opponent_actions[round_idx])
            if history.my_actions[round_idx]:
                total_cooperators += 1
            if total_cooperators < self.game_description.m:
                failures += 1
        return failures

class Strategy_AGGRESSIVE_115(BaseStrategy):
    """
    Threshold Predator: An aggressive exploitation strategy that minimizes personal contributions 
    while maximizing benefits from others' cooperation. Always defects in first and final rounds,
    and only cooperates when exactly at the tipping point if future exploitation is profitable.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.m = game_description.m
        self.k = game_description.k
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round >= self.r - 1:
            return Action.D
        last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
        if last_round_cooperators >= self.m:
            return Action.D
        elif last_round_cooperators == self.m - 1:
            if self._estimate_future_exploitation(history) > 1:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _estimate_future_exploitation(self, history: PlayerHistory) -> float:
        """
        Estimate future exploitation value by analyzing opponent cooperation patterns.
        Returns expected payoff benefit from triggering cooperation.
        """
        if history.round_number == 0:
            return 0
        total_exploitation_potential = 0
        rounds_remaining = self.r - (history.round_number + 1)
        if rounds_remaining <= 1:
            return 0
        for player_idx in range(self.n - 1):
            player_actions = history.opponent_actions[:history.round_number, player_idx]
            cooperation_rate = sum(player_actions) / len(player_actions)
            if cooperation_rate > 0.5:
                total_exploitation_potential += cooperation_rate * rounds_remaining * self.k
        return total_exploitation_potential * 0.7

class Strategy_AGGRESSIVE_116(BaseStrategy):
    """
    Exploitative Punisher: An aggressive strategy that maximizes individual payoffs by exploiting
    cooperative opponents while maintaining minimal cooperation only when highly profitable.
    Always defects in first and last rounds, and free-rides when threshold is already met.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        m = self.game_description.m
        k = self.game_description.k
        if current_round == total_rounds:
            return Action.D
        last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
        if history.my_actions[history.round_number - 1]:
            last_round_cooperators += 1
        if last_round_cooperators >= m:
            return Action.D
        if last_round_cooperators == m - 1 and k >= 2.5:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_117(BaseStrategy):
    """
    Conditional Predator: An aggressive exploitation strategy that defects whenever possible
    while only cooperating when absolutely necessary to secure collective benefits.
    Maximizes personal payoff by free-riding on others' cooperation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self.final_rounds_threshold = max(2, self.r // 4)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        last_round_idx = history.round_number - 1
        observed_cooperators = int(sum(history.opponent_actions[last_round_idx]))
        if current_round > self.r - self.final_rounds_threshold:
            return Action.D
        if observed_cooperators >= self.m:
            return Action.D
        elif observed_cooperators == self.m - 1:
            cooperation_probability = self._estimate_cooperation_probability(history)
            if cooperation_probability > 0.6:
                return Action.D
            else:
                return Action.C
        else:
            early_rounds_threshold = max(3, self.r // 3)
            if current_round <= early_rounds_threshold:
                return Action.D
            else:
                return Action.C

    def _estimate_cooperation_probability(self, history: PlayerHistory) -> float:
        """
        Estimate probability that at least one opponent will cooperate
        based on their historical cooperation rates.
        """
        if history.round_number == 0:
            return 0.5
        cooperation_rates = []
        for player_idx in range(self.n - 1):
            player_actions = history.opponent_actions[:, player_idx]
            cooperation_rate = sum(player_actions) / len(player_actions)
            cooperation_rates.append(cooperation_rate)
        prob_all_defect = 1.0
        for rate in cooperation_rates:
            prob_all_defect *= 1.0 - rate
        prob_at_least_one_cooperates = 1.0 - prob_all_defect
        return prob_at_least_one_cooperates

class Strategy_AGGRESSIVE_118(BaseStrategy):
    """
    Exploitative Threshold Rider: An aggressive strategy that maximizes personal payoff
    by free-riding on others' cooperation while only contributing when absolutely necessary
    to secure the threshold bonus.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.r:
            reliable_cooperators = self._count_reliable_cooperators(history)
            if reliable_cooperators == self.m - 1:
                return Action.C
            else:
                return Action.D
        last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
        if history.my_actions[history.round_number - 1]:
            last_round_cooperators += 1
        reliable_cooperators = self._count_reliable_cooperators(history)
        if reliable_cooperators >= self.m:
            return Action.D
        if reliable_cooperators == self.m - 1 and current_round > self.r // 2:
            return Action.D
        last_round_others_coop = sum(history.opponent_actions[history.round_number - 1])
        if last_round_others_coop == self.m - 1:
            return Action.C
        return Action.D

    def _count_reliable_cooperators(self, history: PlayerHistory) -> int:
        """Count opponents who cooperate frequently (>60% of the time)"""
        reliable_count = 0
        n_rounds_played = history.round_number
        if n_rounds_played == 0:
            return 0
        for player_idx in range(self.n - 1):
            cooperations = sum(history.opponent_actions[:n_rounds_played, player_idx])
            cooperation_rate = cooperations / n_rounds_played
            if cooperation_rate > 0.6:
                reliable_count += 1
        return reliable_count

class Strategy_AGGRESSIVE_119(BaseStrategy):
    """
    Exploitation Maximizer: An aggressive strategy designed to maximize personal payoffs 
    by exploiting cooperative players while minimizing personal risk through systematic 
    free-riding and strategic minimal cooperation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self.reliable_cooperators_estimate = 0
        self.cooperation_history = []

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if history.round_number > 0:
            last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
            self.cooperation_history.append(last_round_cooperators)
            self.reliable_cooperators_estimate = sum(self.cooperation_history) / len(self.cooperation_history)
        phase1_end = self.r // 3
        phase2_end = 2 * self.r // 3
        if current_round <= phase1_end:
            return Action.D
        elif current_round <= phase2_end:
            return self._phase2_decision(history, current_round)
        else:
            return self._phase3_decision(history, current_round)

    def _phase2_decision(self, history: PlayerHistory, current_round: int) -> Action:
        """Phase 2: Only cooperate when absolutely necessary to maintain threshold"""
        rounds_remaining = self.r - current_round + 1
        if self.reliable_cooperators_estimate >= self.m:
            return Action.D
        elif self.reliable_cooperators_estimate >= self.m - 1:
            if rounds_remaining > self.r // 3:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _phase3_decision(self, history: PlayerHistory, current_round: int) -> Action:
        """Phase 3: Maximum extraction with minimal cooperation"""
        rounds_left = self.r - current_round + 1
        if rounds_left <= 2:
            return Action.D
        if self.reliable_cooperators_estimate >= self.m:
            return Action.D
        elif self.reliable_cooperators_estimate >= self.m - 1 and rounds_left > 3:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_120(BaseStrategy):
    """
    Dominant Defector with Opportunistic Exploitation - an aggressive strategy that defaults to 
    defection while exploiting cooperative opponents, only cooperating when absolutely necessary 
    for personal benefit.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n = self.game_description.n_players
        m = self.game_description.m
        k = self.game_description.k
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        if current_round == r:
            return Action.D
        prev_cooperators = self._count_cooperators_last_round(history)
        my_coop_rate = self._my_cooperation_rate(history)
        others_coop_rate = self._others_cooperation_rate(history)
        if current_round <= 0.3 * r:
            if prev_cooperators == m - 1 and my_coop_rate < 0.2:
                return Action.C
            return Action.D
        if current_round >= 0.7 * r:
            threshold_probability = self._estimate_threshold_probability(history, n, m)
            expected_value_coop = threshold_probability * k
            expected_value_defect = 1 + threshold_probability * k
            if expected_value_coop > expected_value_defect and others_coop_rate > 0.6:
                return Action.C
        return Action.D

    def _count_cooperators_last_round(self, history: PlayerHistory) -> int:
        """Count cooperators in the most recent round."""
        if history.round_number == 0:
            return 0
        last_round_idx = history.round_number - 1
        return int(sum(history.opponent_actions[last_round_idx]))

    def _my_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate my historical cooperation rate."""
        if history.round_number == 0:
            return 0.0
        return float(sum(history.my_actions)) / history.round_number

    def _others_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate others' average cooperation rate."""
        if history.round_number == 0:
            return 0.0
        total_actions = history.round_number * (self.game_description.n_players - 1)
        total_cooperations = float(sum((sum(round_actions) for round_actions in history.opponent_actions)))
        return total_cooperations / total_actions if total_actions > 0 else 0.0

    def _estimate_threshold_probability(self, history: PlayerHistory, n: int, m: int) -> float:
        """Estimate probability that threshold will be met based on recent cooperation rates."""
        if history.round_number < 3:
            recent_coop_rate = self._others_cooperation_rate(history)
        else:
            last_3_rounds = history.opponent_actions[max(0, history.round_number - 3):history.round_number]
            if len(last_3_rounds) > 0:
                total_recent_actions = len(last_3_rounds) * (n - 1)
                total_recent_cooperations = float(sum((sum(round_actions) for round_actions in last_3_rounds)))
                recent_coop_rate = total_recent_cooperations / total_recent_actions if total_recent_actions > 0 else 0.0
            else:
                recent_coop_rate = 0.0
        expected_opponent_cooperators = recent_coop_rate * (n - 1)
        return min(1.0, expected_opponent_cooperators / m)

class Strategy_AGGRESSIVE_121(BaseStrategy):
    """
    Exploitative Threshold Hunter: An aggressive strategy that maximizes personal payoff
    by exploiting cooperative players while contributing the absolute minimum necessary
    to trigger collective rewards. Only cooperates when positioned as the pivotal player
    with positive expected future benefits.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.m = game_description.m
        self.k = game_description.k
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        expected_cooperators = self._count_expected_cooperators(history)
        cooperators_needed = self.m - expected_cooperators
        if cooperators_needed <= 0:
            return Action.D
        if cooperators_needed == 1:
            if self._am_i_pivotal_and_profitable(history, current_round):
                return Action.C
        endgame_threshold = max(1, int(0.8 * self.r))
        if current_round >= endgame_threshold:
            if cooperators_needed == 1 and self._expected_future_benefit(history, current_round) > 1.5:
                return Action.C
            return Action.D
        if self._threshold_failing_consistently(history):
            return Action.D
        return Action.D

    def _count_expected_cooperators(self, history: PlayerHistory) -> int:
        """Estimate how many opponents will cooperate based on their patterns."""
        if history.round_number == 0:
            return 0
        cooperation_rates = []
        for player_idx in range(self.n - 1):
            player_actions = history.opponent_actions[:, player_idx]
            cooperation_rate = sum(player_actions) / len(player_actions)
            cooperation_rates.append(cooperation_rate)
        expected_cooperators = 0
        for rate in cooperation_rates:
            if rate > 0.7:
                expected_cooperators += 1
            elif rate >= 0.3:
                expected_cooperators += 0.5
        return int(expected_cooperators)

    def _am_i_pivotal_and_profitable(self, history: PlayerHistory, current_round: int) -> bool:
        """Check if being the pivotal cooperator is profitable."""
        future_benefit = self._expected_future_benefit(history, current_round)
        immediate_net = self.k - 1
        return immediate_net + future_benefit > 0

    def _expected_future_benefit(self, history: PlayerHistory, current_round: int) -> float:
        """Calculate expected future benefits from establishing cooperation pattern."""
        remaining_rounds = self.r - current_round
        if remaining_rounds <= 0:
            return 0
        recent_rounds = min(3, history.round_number)
        if recent_rounds == 0:
            cooperation_sustainability = 0.5
        else:
            recent_successes = 0
            for round_idx in range(history.round_number - recent_rounds, history.round_number):
                round_cooperators = sum(history.opponent_actions[round_idx]) + (1 if history.my_actions[round_idx] else 0)
                if round_cooperators >= self.m:
                    recent_successes += 1
            cooperation_sustainability = recent_successes / recent_rounds
        expected_per_round = cooperation_sustainability * self.k * 0.8
        return expected_per_round * remaining_rounds * 0.6

    def _threshold_failing_consistently(self, history: PlayerHistory) -> bool:
        """Check if threshold has been failing in recent rounds."""
        if history.round_number < 3:
            return False
        recent_rounds = min(3, history.round_number)
        failures = 0
        for round_idx in range(history.round_number - recent_rounds, history.round_number):
            total_cooperators = sum(history.opponent_actions[round_idx]) + (1 if history.my_actions[round_idx] else 0)
            if total_cooperators < self.m:
                failures += 1
        return failures >= recent_rounds

    def _create_unpredictability(self, history: PlayerHistory, current_round: int) -> bool:
        """Occasionally cooperate unexpectedly to confuse opponents."""
        if current_round <= 2:
            return False
        if history.round_number > 0:
            my_defection_rate = sum((1 for action in history.my_actions if not action)) / len(history.my_actions)
            if my_defection_rate > 0.8 and random.random() < 0.05:
                return True
        return False

class Strategy_AGGRESSIVE_122(BaseStrategy):
    """
    Aggressive Opportunistic Exploiter strategy that maximizes personal payoff by 
    exploiting cooperative opponents while minimizing personal contribution. Only 
    cooperates when absolutely necessary to maintain the threshold, and always 
    defects in the final round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.n_rounds:
            return Action.D
        last_round_idx = history.round_number - 1
        cooperation_count_last_round = sum(history.opponent_actions[last_round_idx])
        my_cooperation_needed = cooperation_count_last_round < self.m - 1
        if my_cooperation_needed:
            remaining_rounds = self.n_rounds - current_round
            expected_future_value = remaining_rounds * self.k
            immediate_cost = 1
            if expected_future_value > immediate_cost and remaining_rounds > 2:
                if history.round_number >= 3:
                    recent_rounds = min(3, history.round_number)
                    start_idx = max(0, history.round_number - recent_rounds)
                    recent_cooperation = 0
                    total_possible = 0
                    for round_idx in range(start_idx, history.round_number):
                        recent_cooperation += sum(history.opponent_actions[round_idx])
                        total_possible += len(history.opponent_actions[round_idx])
                    cooperation_rate = recent_cooperation / total_possible if total_possible > 0 else 0
                    if cooperation_rate > 0.7:
                        return Action.D
                    elif cooperation_rate < 0.3:
                        return Action.C
                    else:
                        return Action.D
                else:
                    return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_123(BaseStrategy):
    """
    Aggressive Predatory Exploitation Strategy: Maximizes personal payoffs by exploiting 
    cooperative players while contributing minimally to threshold maintenance.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self.exploitation_ratios = [0.0] * (self.n_players - 1)
        self.mark_as_exploitable = [False] * (self.n_players - 1)
        self.punishment_mode = [0] * (self.n_players - 1)
        self.recent_cooperation_rates = [0.0] * (self.n_players - 1)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_number = history.round_number + 1
        if round_number <= 2:
            return Action.D
        if round_number > self.n_rounds - 3:
            return Action.D
        self._update_opponent_models(history)
        if any((p > 0 for p in self.punishment_mode)):
            for i in range(len(self.punishment_mode)):
                if self.punishment_mode[i] > 0:
                    self.punishment_mode[i] -= 1
            return Action.D
        expected_cooperators = self._count_expected_cooperators(history)
        if expected_cooperators >= self.m:
            return Action.D
        elif expected_cooperators == self.m - 1:
            if round_number <= self.n_rounds - 3:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _update_opponent_models(self, history: PlayerHistory):
        """Update exploitation ratios, punishment modes, and recent cooperation rates."""
        n_rounds_played = history.round_number
        for opponent_idx in range(self.n_players - 1):
            times_both_played = 0
            times_opponent_cooperated_when_i_defected = 0
            for round_idx in range(n_rounds_played):
                my_action = history.my_actions[round_idx]
                opponent_action = history.opponent_actions[round_idx, opponent_idx]
                times_both_played += 1
                if not my_action and opponent_action:
                    times_opponent_cooperated_when_i_defected += 1
            if times_both_played > 0:
                self.exploitation_ratios[opponent_idx] = times_opponent_cooperated_when_i_defected / times_both_played
                if self.exploitation_ratios[opponent_idx] > 0.6:
                    self.mark_as_exploitable[opponent_idx] = True
            recent_rounds = min(5, n_rounds_played)
            if recent_rounds > 0:
                recent_cooperations = sum((history.opponent_actions[n_rounds_played - recent_rounds + i, opponent_idx] for i in range(recent_rounds)))
                self.recent_cooperation_rates[opponent_idx] = recent_cooperations / recent_rounds
            if n_rounds_played >= 2:
                prev_round = n_rounds_played - 2
                last_round = n_rounds_played - 1
                if history.my_actions[prev_round] and history.opponent_actions[prev_round, opponent_idx] and (not history.opponent_actions[last_round, opponent_idx]):
                    self.punishment_mode[opponent_idx] = 3

    def _count_expected_cooperators(self, history: PlayerHistory):
        """Count how many opponents are likely to cooperate this round."""
        expected_cooperators = 0
        for opponent_idx in range(self.n_players - 1):
            if self.recent_cooperation_rates[opponent_idx] > 0.7 or self.mark_as_exploitable[opponent_idx]:
                expected_cooperators += 1
        return expected_cooperators

class Strategy_AGGRESSIVE_124(BaseStrategy):
    """
    Exploitative Threshold Hunter - An aggressive strategy that maximizes personal payoffs
    by exploiting cooperative players while minimizing personal risk. Defects when possible
    but strategically cooperates when necessary to maintain exploitable dynamics.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round >= self.r:
            return Action.D
        historical_cooperators = self._count_reliable_cooperators(history)
        last_round_cooperators = self._count_last_round_cooperators(history)
        conditional_cooperators = self._count_conditional_cooperators(history)
        rounds_remaining = self.r - current_round
        if historical_cooperators >= self.m:
            return Action.D
        elif last_round_cooperators >= self.m - 1:
            return Action.D
        elif historical_cooperators + conditional_cooperators >= self.m - 1:
            return Action.D
        elif rounds_remaining >= 2:
            future_value = self._calculate_future_exploitation_value(history, rounds_remaining)
            cooperation_cost = self.k
            if future_value > cooperation_cost:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _count_reliable_cooperators(self, history: PlayerHistory) -> int:
        """Count opponents who cooperated in 70% of previous rounds."""
        if history.round_number == 0:
            return 0
        reliable_count = 0
        for player_idx in range(self.n - 1):
            cooperation_rate = np.mean(history.opponent_actions[:history.round_number, player_idx])
            if cooperation_rate >= 0.7:
                reliable_count += 1
        return reliable_count

    def _count_last_round_cooperators(self, history: PlayerHistory) -> int:
        """Count cooperators in the most recent round."""
        if history.round_number == 0:
            return 0
        return int(np.sum(history.opponent_actions[history.round_number - 1]))

    def _count_conditional_cooperators(self, history: PlayerHistory) -> int:
        """Count players who appear to be conditional cooperators."""
        if history.round_number < 2:
            return 0
        conditional_count = 0
        for player_idx in range(self.n - 1):
            if self._is_conditional_cooperator(history, player_idx):
                conditional_count += 1
        return conditional_count

    def _is_conditional_cooperator(self, history: PlayerHistory, player_idx: int) -> bool:
        """Determine if a player is a conditional cooperator based on their pattern."""
        if history.round_number < 3:
            return False
        player_actions = history.opponent_actions[:history.round_number, player_idx]
        correlations = []
        for round_idx in range(1, history.round_number):
            prev_cooperators = np.sum(history.opponent_actions[round_idx - 1]) - history.opponent_actions[round_idx - 1, player_idx]
            if history.my_actions[round_idx - 1]:
                prev_cooperators += 1
            current_action = player_actions[round_idx]
            correlations.append((prev_cooperators >= self.m - 1, current_action))
        if len(correlations) < 2:
            return False
        matches = sum((1 for threshold_met, action in correlations if threshold_met == action))
        return matches >= len(correlations) * 0.6

    def _calculate_future_exploitation_value(self, history: PlayerHistory, rounds_remaining: int) -> float:
        """Calculate potential value from future exploitation."""
        reliable_cooperators = self._count_reliable_cooperators(history)
        if reliable_cooperators >= self.m - 1:
            return rounds_remaining * 1.0
        elif reliable_cooperators >= self.m - 2:
            return rounds_remaining * 0.5
        else:
            return rounds_remaining * 0.2

class Strategy_AGGRESSIVE_125(BaseStrategy):
    """
    Exploitative Threshold Hunter: An aggressive strategy that maximizes personal payoff
    by exploiting cooperative players while minimizing personal risk. Defects in first
    and last rounds, and cooperates strategically only when it can be the decisive vote
    or when threshold is highly likely to be met with high rewards.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_num = history.round_number + 1
        n = self.game_description.n_players
        m = self.game_description.m
        k = self.game_description.k
        r = self.game_description.n_rounds
        if round_num == r:
            return Action.D
        last_round_idx = history.round_number - 1
        cooperation_count = int(sum(history.opponent_actions[last_round_idx]))
        if history.my_actions[last_round_idx]:
            cooperation_count += 1
        remaining_rounds = r - round_num
        if cooperation_count >= m:
            return Action.D
        if cooperation_count == m - 1:
            if k >= 2.5 and remaining_rounds >= 2:
                return Action.C
            else:
                return Action.D
        if cooperation_count < m - 2:
            return Action.D
        expected_cooperators = self._estimate_future_cooperators(history)
        if expected_cooperators >= 1.0 and k >= 2.0:
            return Action.C
        else:
            return Action.D

    def _estimate_future_cooperators(self, history: PlayerHistory) -> float:
        """Estimate how many opponents will cooperate based on their historical rates."""
        if history.round_number == 0:
            return 0.0
        n_opponents = self.game_description.n_players - 1
        expected = 0.0
        for opponent_idx in range(n_opponents):
            opponent_cooperations = sum(history.opponent_actions[:history.round_number, opponent_idx])
            coop_rate = opponent_cooperations / history.round_number
            expected += coop_rate
        return expected

class Strategy_AGGRESSIVE_126(BaseStrategy):
    """
    Opportunistic Exploiter: An aggressive strategy that maximizes personal payoffs 
    by exploiting cooperative players while minimizing personal risk. Defaults to 
    defection but cooperates only when absolutely necessary to avoid collective failure.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round <= self.r - 2:
            return Action.D
        elif current_round == self.r - 1:
            return self._strategic_assessment(history)
        else:
            return self._final_round_decision(history)

    def _strategic_assessment(self, history: PlayerHistory) -> Action:
        """Decision logic for round r-1 based on historical cooperation patterns."""
        rounds_played = history.round_number
        total_cooperations = np.sum(history.opponent_actions)
        total_decisions = (self.n - 1) * rounds_played
        cooperation_rate = total_cooperations / total_decisions if total_decisions > 0 else 0
        expected_cooperators_next_round = (self.n - 1) * cooperation_rate
        if expected_cooperators_next_round >= self.m:
            return Action.D
        elif expected_cooperators_next_round >= self.m - 1:
            return Action.C
        else:
            return Action.D

    def _final_round_decision(self, history: PlayerHistory) -> Action:
        """Pure exploitation with safety net for the final round."""
        if history.round_number == 0:
            return Action.D
        last_round_idx = history.round_number - 1
        cooperators_last_round = np.sum(history.opponent_actions[last_round_idx])
        if cooperators_last_round >= self.m:
            return Action.D
        elif cooperators_last_round == self.m - 1:
            if history.round_number >= 2:
                prev_round_idx = history.round_number - 2
                cooperated_last = history.opponent_actions[last_round_idx]
                cooperated_prev = history.opponent_actions[prev_round_idx]
                stable_cooperators = np.sum(cooperated_last & cooperated_prev)
                if stable_cooperators >= self.m - 1:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_127(BaseStrategy):
    """
    Aggressive Strategy: "Exploitation Maximizer"
    
    Maximizes personal payoffs by aggressively exploiting cooperative players while minimizing 
    personal contributions. Free-rides when others cooperate, and only cooperates strategically 
    when it enables future exploitation opportunities.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punishment_rounds = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n = self.game_description.n_players
        m = self.game_description.m
        k = self.game_description.k
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        rounds_remaining = r - current_round + 1
        if rounds_remaining == 1:
            return Action.D
        predicted_cooperators = self._predict_cooperators(history)
        if self.punishment_rounds > 0:
            self.punishment_rounds -= 1
            if random.random() < 0.2:
                return Action.D
        if history.round_number > 0:
            last_round_cooperators = sum(history.opponent_actions[history.round_number - 1]) + int(history.my_actions[history.round_number - 1])
            if last_round_cooperators < m:
                self.punishment_rounds = 2
        if rounds_remaining <= r // 3:
            if predicted_cooperators >= m:
                return Action.D
            elif predicted_cooperators == m - 1:
                if rounds_remaining > 2 and self._expected_future_benefit(history) > k:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
        if predicted_cooperators >= m:
            return Action.D
        elif predicted_cooperators == m - 1:
            if rounds_remaining > 2 and self._should_cooperate_strategically(history):
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _predict_cooperators(self, history: PlayerHistory) -> int:
        """Predict number of cooperators based on opponent behavior patterns."""
        if history.round_number == 0:
            return 0
        n_opponents = self.game_description.n_players - 1
        predicted = 0
        for opponent_idx in range(n_opponents):
            coop_rate = self._get_cooperation_rate(history, opponent_idx)
            recent_weight = 0.5
            if history.round_number >= 1:
                recent_weight += 0.3 * int(history.opponent_actions[history.round_number - 1, opponent_idx])
            if history.round_number >= 2:
                recent_weight += 0.2 * int(history.opponent_actions[history.round_number - 2, opponent_idx])
            if history.round_number >= 3:
                recent_weight += 0.1 * int(history.opponent_actions[history.round_number - 3, opponent_idx])
            if recent_weight > 0.5:
                predicted += 1
        return predicted

    def _get_cooperation_rate(self, history: PlayerHistory, opponent_idx: int) -> float:
        """Calculate cooperation rate for a specific opponent."""
        if history.round_number == 0:
            return 0.0
        cooperations = sum(history.opponent_actions[:history.round_number, opponent_idx])
        return cooperations / history.round_number

    def _classify_player_type(self, history: PlayerHistory, opponent_idx: int) -> str:
        """Classify opponent as persistent cooperator, conditional cooperator, or defector."""
        coop_rate = self._get_cooperation_rate(history, opponent_idx)
        if coop_rate > 0.7:
            return 'persistent'
        elif coop_rate > 0.3:
            return 'conditional'
        else:
            return 'defector'

    def _expected_future_benefit(self, history: PlayerHistory) -> float:
        """Calculate expected future benefit from strategic cooperation."""
        rounds_remaining = self.game_description.n_rounds - history.round_number
        persistent_cooperators = 0
        for i in range(self.game_description.n_players - 1):
            if self._classify_player_type(history, i) == 'persistent':
                persistent_cooperators += 1
        if persistent_cooperators >= self.game_description.m - 1:
            return self.game_description.k * max(0, rounds_remaining - 1)
        else:
            return 0.0

    def _should_cooperate_strategically(self, history: PlayerHistory) -> bool:
        """Determine if strategic cooperation is worthwhile."""
        rounds_remaining = self.game_description.n_rounds - history.round_number
        if rounds_remaining <= 3:
            return False
        if history.round_number <= self.game_description.n_rounds // 3:
            return rounds_remaining >= self.game_description.n_rounds // 2
        expected_benefit = self._expected_future_benefit(history)
        return expected_benefit > self.game_description.k

class Strategy_AGGRESSIVE_128(BaseStrategy):
    """
    Predatory Threshold Exploit Strategy: Aggressively maximizes personal payoffs by 
    exploiting the collective action problem. Free-rides early, then strategically 
    cooperates only when absolutely necessary to secure group bonus.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n = self.game_description.n_players
        m = self.game_description.m
        k = self.game_description.k
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        if current_round <= 0.6 * r:
            return Action.D
        else:
            rounds_to_check = min(3, history.round_number)
            recent_cooperation_sum = 0
            total_observations = 0
            for i in range(rounds_to_check):
                round_idx = history.round_number - 1 - i
                recent_cooperation_sum += sum(history.opponent_actions[round_idx])
                total_observations += len(history.opponent_actions[round_idx])
            recent_cooperation_rate = recent_cooperation_sum / total_observations if total_observations > 0 else 0
            expected_cooperators = (n - 1) * recent_cooperation_rate
            if history.round_number >= 3:
                success_count = 0
                for i in range(history.round_number):
                    cooperators_in_round = sum(history.opponent_actions[i])
                    if history.my_actions[i]:
                        cooperators_in_round += 1
                    if cooperators_in_round >= m:
                        success_count += 1
                success_rate = success_count / history.round_number
                if success_rate > 0.9:
                    return Action.D
            if history.round_number >= 5:
                failure_count = 0
                for i in range(min(5, history.round_number)):
                    round_idx = history.round_number - 1 - i
                    cooperators_in_round = sum(history.opponent_actions[round_idx])
                    if history.my_actions[round_idx]:
                        cooperators_in_round += 1
                    if cooperators_in_round < m:
                        failure_count += 1
                failure_rate = failure_count / min(5, history.round_number)
                if failure_rate > 0.7:
                    return Action.D
            if current_round == r:
                return Action.D
            if expected_cooperators >= m:
                return Action.D
            elif expected_cooperators >= m - 1:
                return Action.C
            else:
                return Action.D