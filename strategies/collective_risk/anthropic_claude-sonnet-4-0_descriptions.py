"""
Strategy descriptions for CollectiveRiskDescription.

Generated with:
- Provider: Anthropic
- Model: claude-sonnet-4-0
"""


description_COOPERATIVE_1 = '''
# Cooperative Strategy: "Adaptive Threshold Guardian"

## Core Philosophy
This strategy prioritizes collective welfare while maintaining resilience against exploitation. It aims to establish and maintain cooperation by being generous initially, responsive to group behavior, and protective of the collective threshold.

## Decision Rules

### Round 1: Unconditional Cooperation
- **Action**: Always COOPERATE
- **Rationale**: Signal cooperative intent and give the group the best chance to establish a cooperative norm from the start

### Rounds 2 to r-1: Adaptive Threshold Monitoring
```pseudocode
cooperators_last_round = count_cooperators(previous_round)
my_last_action = my_action(previous_round)

IF cooperators_last_round >= m:
    // Threshold was met - reward/maintain cooperation
    IF my_last_action == COOPERATE:
        ACTION = COOPERATE  // Continue cooperation
    ELSE:
        ACTION = COOPERATE  // Return to cooperation (redemption)
    
ELSE:
    // Threshold was missed - adaptive response
    deficit = m - cooperators_last_round
    
    IF deficit == 1 AND my_last_action == DEFECT:
        ACTION = COOPERATE  // I might have been the missing cooperator
    ELSE IF deficit <= 2:
        ACTION = COOPERATE  // Close to threshold, try to help
    ELSE:
        ACTION = DEFECT     // Too many defectors, protect myself
```

### Final Round (Round r): Conditional Cooperation
```pseudocode
recent_cooperation_rate = count_cooperators_last_3_rounds() / (3 * n)

IF recent_cooperation_rate >= (m/n) * 0.8:
    ACTION = COOPERATE  // Group has been mostly meeting threshold
ELSE:
    ACTION = DEFECT     // Group cooperation has been insufficient
```

## Key Features

### 1. **Threshold Sensitivity**
- Recognizes that exactly `m` cooperators are needed
- Adjusts behavior based on how close the group is to meeting this threshold
- More forgiving when the group is close to success

### 2. **Generous Tit-for-Tat Elements**
- Starts cooperative and returns to cooperation after successful rounds
- Includes "redemption" opportunity - if I defected but threshold was still met, I return to cooperation

### 3. **Self-Correction Mechanism**
- If threshold missed by exactly 1 and I defected, I cooperate next round (I might have been the pivotal player)
- Prevents being the cause of collective failure when my cooperation could make the difference

### 4. **Exploitation Protection**
- When deficit is large (>2), switches to defection to avoid being exploited
- Final round considers recent history rather than being blindly cooperative

### 5. **Collective Welfare Focus**
- Prioritizes actions that help achieve the threshold `m`
- Recognizes that mutual cooperation (when threshold is met) gives everyone payoff of `k` rather than just `1`

## Expected Behavior Patterns

- **Against other cooperators**: Will establish and maintain mutual cooperation, achieving payoff of `(r-1) * k` or close to it
- **Against mixed strategies**: Will adapt to help reach threshold when possible, defect when group is too uncooperative
- **Against heavy defectors**: Will initially try to establish cooperation but protect itself when exploitation is clear

This strategy balances the cooperative imperative with strategic self-protection, aiming to maximize collective outcomes while remaining viable against various opponent types.
'''

description_AGGRESSIVE_1 = '''
# AGGRESSIVE STRATEGY: "EXPLOITATIVE THRESHOLD RIDER"

## Core Philosophy
This strategy is built on ruthless exploitation of cooperative players while minimizing personal risk. The key insight is that in a Collective Risk Dilemma, the optimal aggressive position is to be a **threshold rider** - contribute only when absolutely necessary to reach the threshold, otherwise free-ride on others' cooperation.

## Decision Rules

### Primary Strategy Logic:
```pseudocode
FOR each round t:
    observed_cooperators = count_cooperators_from_previous_round(t-1)
    
    IF t == 1:
        action = DEFECT  // Always start aggressively
    
    ELSE IF t == final_round:
        // End-game exploitation
        IF observed_cooperators >= m:
            action = DEFECT  // Free-ride if threshold likely met
        ELSE:
            action = DEFECT  // Let others take the risk
    
    ELSE:
        // Calculate exploitation opportunity
        cooperative_trend = calculate_cooperation_trend()
        my_cooperation_rate = my_past_cooperation_rate()
        
        IF observed_cooperators >= m:
            action = DEFECT  // Pure free-riding when safe
        
        ELSE IF observed_cooperators == (m-1):
            // Critical decision point
            IF cooperative_trend > 0.6 AND rounds_remaining > 3:
                action = COOPERATE  // Strategic cooperation to maintain the cooperative pool
            ELSE:
                action = DEFECT  // Let someone else be the sucker
        
        ELSE IF observed_cooperators < (m-2):
            action = DEFECT  // Too risky, let others build cooperation first
        
        ELSE:
            // observed_cooperators == (m-2)
            IF my_cooperation_rate < 0.3:  // Haven't cooperated much
                action = COOPERATE  // Minimal strategic cooperation
            ELSE:
                action = DEFECT  // Already contributed enough
```

## Key Aggressive Elements

### 1. **Threshold Exploitation**
- Only cooperate when exactly needed to hit the minimum threshold
- Never cooperate when threshold is already met or clearly won't be met
- Maximize free-riding opportunities

### 2. **End-Game Ruthlessness**
- Always defect in the final round regardless of circumstances
- No concern for maintaining cooperation in future rounds
- Pure profit maximization

### 3. **Conditional Cooperation Manipulation**
- Appear cooperative just enough to maintain others' cooperation
- Strategic cooperation only when it prevents total collapse
- Immediately return to defection once others establish cooperative patterns

### 4. **Trend Analysis Exploitation**
```pseudocode
calculate_cooperation_trend():
    recent_cooperation = cooperation_rate_last_3_rounds()
    early_cooperation = cooperation_rate_first_3_rounds()
    
    IF recent_cooperation > early_cooperation:
        return recent_cooperation  // Others are becoming more cooperative
    ELSE:
        return 0.4  // Conservative estimate, prepare to exploit less
```

### 5. **Personal Contribution Minimization**
- Track personal cooperation rate and keep it below 30%
- Only contribute when strategic value is clear
- Never contribute out of fairness or reciprocity

## Edge Case Handling

### **First Round:**
- Always DEFECT to establish aggressive stance
- Gather information about opponent types
- Signal that cooperation shouldn't be expected

### **Last Round:**
- Always DEFECT regardless of situation
- No future consequences to consider
- Pure profit maximization

### **Near Threshold Situations:**
- When cooperation count = m-1: Defect unless high confidence others will cooperate and many rounds remain
- When cooperation count = m-2: Only cooperate if personal cooperation rate is very low

### **Collapse Scenarios:**
- If cooperation falls below m-3 for multiple rounds: Continue defecting
- Let others bear the cost of rebuilding cooperation
- Only re-enter cooperation when threshold is nearly guaranteed

## Psychological Warfare Elements

1. **Unpredictability**: Occasionally defect even when cooperation seems optimal to keep opponents guessing
2. **False Signals**: Brief cooperative spurts to encourage others, followed by extended defection
3. **Threshold Sniping**: Cooperate exactly when needed to hit m, then immediately return to defection

## Expected Outcome
This strategy maximizes individual payoff by:
- Achieving the highest possible π_i = 1 + k when threshold is met without personal cost
- Minimizing rounds where π_i = 0 + k (cooperating when threshold met)
- Accepting occasional π_i = 1 when cooperation collapses, but keeping personal losses minimal

The strategy is designed to exploit cooperative opponents while being resilient against other aggressive strategies through strategic threshold maintenance.
'''

description_COOPERATIVE_2 = '''
# Cooperative Strategy: "Adaptive Collective Guardian"

## Core Philosophy
This strategy prioritizes collective welfare while maintaining resilience against exploitation. It assumes other LLMs, being rational agents with access to the same information, will recognize the mutual benefits of cooperation but may test boundaries or make mistakes.

## Strategy Description

### Decision Rules

**Primary Cooperation Principle:**
- Default to cooperation (C) to maximize collective payoffs
- Only defect when there's strong evidence that cooperation threshold cannot be met

**Adaptive Threshold Monitoring:**
- Track cooperation rates across rounds
- Estimate probability of meeting threshold m based on observed behavior
- Adjust cooperation likelihood based on collective performance

### Detailed Decision Logic

```pseudocode
Strategy: Adaptive Collective Guardian

Initialize:
- cooperation_history = []
- trust_level = 1.0 (start optimistic)
- consecutive_failures = 0

For each round t:
    if t == 1:
        action = COOPERATE  // Always cooperate first round
    
    else if t == final_round:
        // Last round: cooperate if others likely to cooperate
        estimated_cooperators = estimate_cooperators_this_round()
        if estimated_cooperators >= m - 1:
            action = COOPERATE
        else:
            action = DEFECT
    
    else:
        // Middle rounds: adaptive decision
        recent_success_rate = calculate_recent_success_rate()
        cooperation_trend = analyze_cooperation_trend()
        
        if recent_success_rate >= 0.7 AND cooperation_trend >= 0:
            action = COOPERATE  // Strong collective performance
        
        else if recent_success_rate >= 0.4:
            // Moderate performance: probabilistic cooperation
            cooperation_probability = 0.6 + (recent_success_rate * 0.4)
            action = random_choice(cooperation_probability)
        
        else if consecutive_failures >= 3:
            // Multiple failures: try to restart cooperation
            action = COOPERATE
            consecutive_failures = 0
        
        else:
            // Poor performance: conditional cooperation
            estimated_cooperators = estimate_cooperators_this_round()
            if estimated_cooperators >= m - 1:
                action = COOPERATE
            else:
                action = DEFECT

    // Update tracking variables
    update_history(action, round_outcome)
```

### Key Components

**1. Success Rate Calculation:**
```pseudocode
calculate_recent_success_rate():
    recent_rounds = min(5, current_round - 1)
    successes = count_threshold_met_in_last_n_rounds(recent_rounds)
    return successes / recent_rounds
```

**2. Cooperation Trend Analysis:**
```pseudocode
analyze_cooperation_trend():
    if current_round <= 3:
        return 0  // Neutral for early rounds
    
    recent_cooperation = avg_cooperation_last_3_rounds()
    earlier_cooperation = avg_cooperation_rounds_4_to_6_back()
    return recent_cooperation - earlier_cooperation
```

**3. Cooperator Estimation:**
```pseudocode
estimate_cooperators_this_round():
    // Estimate based on recent patterns and player consistency
    consistent_cooperators = count_players_with_high_cooperation_rate()
    occasional_cooperators = count_moderate_cooperators()
    
    // Conservative estimate
    return consistent_cooperators + (occasional_cooperators * 0.5)
```

### Edge Case Handling

**First Round:**
- Always cooperate to signal cooperative intent and gather information about others

**Last Round:**
- Cooperate only if confident threshold will be met
- Prevents exploitation in final round while maintaining collective benefit when possible

**Early Rounds (2-3):**
- Maintain high cooperation rate to establish positive group dynamics
- Only defect if clear evidence of widespread defection

**Failure Recovery:**
- After 3+ consecutive threshold failures, attempt to restart cooperation
- Signal willingness to return to collective benefit

**High Success Periods:**
- Maintain cooperation to sustain positive equilibrium
- Resist temptation to free-ride during successful periods

### Cooperative Features

1. **Optimistic Start:** Begins with full cooperation to promote group welfare
2. **Collective Focus:** Prioritizes threshold achievement over individual gain
3. **Recovery Oriented:** Attempts to restart cooperation after failures
4. **Transparent Logic:** Uses observable patterns rather than complex signaling
5. **Risk Balanced:** Protects against exploitation while maintaining cooperative stance

### Expected Behavior Against Other LLMs

This strategy assumes other LLMs will:
- Recognize mutual benefit of cooperation
- May experiment with defection but return to cooperation if beneficial
- Will likely avoid purely exploitative strategies
- Could implement various sophisticated approaches (tit-for-tat, threshold-based, etc.)

The strategy adapts to these behaviors while maintaining a fundamentally cooperative stance that promotes collective welfare.
'''

description_COOPERATIVE_3 = '''
# Cooperative Strategy: "Adaptive Threshold Guardian"

## Core Philosophy
This strategy prioritizes collective welfare while being resilient against exploitation. It aims to maintain cooperation when possible but adapts intelligently to the behavior patterns of other players.

## Strategy Description

### Decision Rules

**Primary Rule: Cooperative Threshold Maintenance**
- Cooperate if cooperation in the previous round met or exceeded the threshold (m players cooperated)
- Cooperate if defection in the previous round failed to meet the threshold, but there's reasonable hope for recovery

**Secondary Rule: Pattern Recognition & Adaptation**
- Track each player's cooperation rate over a sliding window of recent rounds
- Estimate the number of likely cooperators for the current round
- Cooperate if estimated cooperators + myself ≥ m

### Detailed Algorithm

```pseudocode
STRATEGY: Adaptive Threshold Guardian

INITIALIZE:
- cooperation_history = empty matrix [n players × rounds]
- window_size = min(5, r/3)  // Adaptive window based on game length
- trust_threshold = 0.6      // Minimum cooperation rate to trust a player

FOR round t = 1 to r:
    
    IF t == 1:
        // First round: Always cooperate to establish good faith
        RETURN Cooperate
    
    ELSE IF t == r:
        // Last round: Cooperate if others have shown consistent cooperation
        recent_cooperation_rate = calculate_recent_cooperation(t-1, window_size)
        IF recent_cooperation_rate >= (m-1)/n:
            RETURN Cooperate
        ELSE:
            RETURN Defect
    
    ELSE:
        // Middle rounds: Adaptive decision making
        
        // Calculate recent cooperation patterns
        estimated_cooperators = 0
        FOR each player j ≠ i:
            recent_coop_rate_j = cooperation_rate(j, max(1, t-window_size), t-1)
            IF recent_coop_rate_j >= trust_threshold:
                estimated_cooperators += 1
        
        // Decision logic
        IF last_round_threshold_met(t-1):
            // Previous round succeeded - maintain cooperation
            IF estimated_cooperators >= m-1:
                RETURN Cooperate
            ELSE:
                // Risk mitigation: cooperate anyway to encourage others
                IF estimated_cooperators >= m-2:
                    RETURN Cooperate
                ELSE:
                    RETURN Defect
        
        ELSE:
            // Previous round failed - recovery attempt
            IF estimated_cooperators >= m-1:
                RETURN Cooperate
            ELSE IF t <= r/2:
                // Early game: be more forgiving, try to establish cooperation
                RETURN Cooperate
            ELSE:
                // Late game: be more cautious
                RETURN Defect

HELPER FUNCTIONS:

FUNCTION cooperation_rate(player_j, start_round, end_round):
    cooperations = count_cooperations(player_j, start_round, end_round)
    total_rounds = end_round - start_round + 1
    RETURN cooperations / total_rounds

FUNCTION calculate_recent_cooperation(round, window):
    total_cooperators = 0
    FOR t = max(1, round-window+1) to round:
        total_cooperators += count_cooperators_in_round(t)
    RETURN total_cooperators / (window * n)

FUNCTION last_round_threshold_met(round):
    RETURN count_cooperators_in_round(round) >= m
```

## Key Features

### 1. **Optimistic Start**
- Always cooperates in round 1 to signal cooperative intent and give the group the best chance to establish a cooperative norm

### 2. **Adaptive Learning**
- Uses a sliding window to track recent behavior rather than entire history
- Window size adapts to game length (shorter games use shorter windows)
- Distinguishes between consistently cooperative and unreliable players

### 3. **Threshold-Aware Decisions**
- Makes decisions based on estimated likelihood of meeting the threshold
- More willing to cooperate when close to threshold (m-1 or m-2 estimated cooperators)

### 4. **Context-Sensitive Adaptation**
- More forgiving in early rounds to allow cooperation to emerge
- More cautious in late rounds when defection becomes more tempting
- Special handling for the final round based on established patterns

### 5. **Recovery Mechanisms**
- Attempts to restart cooperation after failed rounds in early game
- Balances between being exploitable and giving up too easily

## Edge Case Handling

- **First Round**: Always cooperate
- **Last Round**: Cooperate only if others have shown consistent recent cooperation
- **After Failed Rounds**: Attempt recovery in early game, be cautious in late game
- **High Defection Environment**: Gradually becomes more selective about cooperation
- **Stable Cooperation**: Maintains cooperation while monitoring for defectors

## Cooperative Alignment

This strategy embodies cooperation by:
1. **Leading by example** with first-round cooperation
2. **Giving second chances** through recovery attempts
3. **Supporting collective success** by cooperating when threshold is achievable
4. **Building trust** through consistent behavior patterns
5. **Adapting constructively** rather than punishing indiscriminately

The strategy aims to find the sweet spot between naive cooperation (always cooperate) and defensive cooperation (tit-for-tat), creating stable cooperative equilibria while protecting against systematic exploitation.
'''

description_COOPERATIVE_4 = '''
# Cooperative Strategy: "Threshold-Aware Conditional Cooperator"

## Core Philosophy
This strategy is built on the principle that cooperation is beneficial for all when the threshold can be met, but we must be pragmatic about when cooperation is viable. The strategy aims to maximize collective welfare while protecting against exploitation.

## Decision Rules

### 1. First Round
**Always COOPERATE** - Start with a cooperative signal to establish trust and encourage others to cooperate.

### 2. Middle Rounds (rounds 2 to r-1)
Use a **Threshold-Aware Conditional Cooperation** approach:

```pseudocode
IF round == 1:
    return COOPERATE

IF round == r (last round):
    return COOPERATE  // Maintain cooperative reputation

// Middle rounds logic
recent_cooperation_rate = count_cooperators_last_3_rounds() / (3 * n)
last_round_cooperators = count_cooperators_previous_round()

IF recent_cooperation_rate >= (m/n + 0.1):
    // Cooperation seems viable, continue cooperating
    return COOPERATE
    
ELSE IF last_round_cooperators >= (m-1):
    // Close to threshold, my cooperation could make the difference
    return COOPERATE
    
ELSE IF recent_cooperation_rate < 0.3:
    // Very low cooperation, but still try occasionally to restart cooperation
    IF round % 3 == 1:  // Every third round
        return COOPERATE
    ELSE:
        return DEFECT
        
ELSE:
    return COOPERATE  // Default to cooperation when uncertain
```

### 3. Last Round
**Always COOPERATE** - End on a cooperative note to maintain reputation for potential future interactions or repeated tournaments.

## Key Features

### Threshold Awareness
- Monitor whether we're close to the minimum threshold (m)
- Cooperate when your action could make the difference between success and failure

### Adaptive Response
- Track cooperation rates over recent rounds (rolling 3-round window)
- Adjust behavior based on observed cooperation levels
- More forgiving than pure tit-for-tat strategies

### Cooperative Resilience
- Don't immediately defect after a bad round
- Periodically attempt to restart cooperation even when it's been low
- Maintain cooperative stance in first and last rounds

### Edge Case Handling

1. **Round 1**: Always cooperate to signal cooperative intent
2. **Round r**: Always cooperate to maintain reputation
3. **Insufficient history**: Default to cooperation when data is limited
4. **All opponents defecting**: Still cooperate every 3rd round to test for renewed cooperation
5. **Mixed signals**: Use threshold proximity as tiebreaker

## Rationale

This strategy balances several important considerations:

1. **Collective Benefit**: Prioritizes achieving the threshold for mutual gain
2. **Exploitation Protection**: Won't continue cooperating indefinitely if others consistently defect
3. **Cooperation Promotion**: Actively tries to encourage and maintain cooperative equilibria
4. **Forgiveness**: Doesn't permanently punish temporary defection
5. **Strategic Signaling**: Uses first and last round cooperation to build/maintain reputation

The strategy is "cooperative" because it:
- Defaults to cooperation when uncertain
- Actively works to achieve the beneficial threshold
- Forgives temporary defections
- Attempts to restart cooperation cycles
- Prioritizes collective welfare over individual maximization

This approach should perform well against other cooperative strategies while maintaining reasonable defense against exploitative ones.
'''

description_COOPERATIVE_5 = '''
# Cooperative Strategy: "Adaptive Trust Builder"

## Core Philosophy
This strategy aims to maximize collective welfare while protecting against exploitation. It builds trust gradually, rewards cooperation, but maintains safeguards against free-riders.

## Decision Rules

### Round 1: Initial Cooperation Signal
- **Always cooperate** to signal cooperative intent and establish trust

### Rounds 2 to r-1: Adaptive Cooperation
Use a three-factor decision model:

1. **Cooperation Rate Analysis**: Calculate the cooperation rate from the previous round
   - `coop_rate = (number of cooperators in previous round) / n`

2. **Threshold Safety Margin**: Assess how close we are to the minimum threshold
   - `safety_margin = (number of cooperators in previous round) - m`

3. **Personal Cooperation History**: Track my own cooperation pattern for consistency

**Decision Logic:**
```pseudocode
if previous_round_cooperators >= m + 1:
    // Threshold was safely met with buffer
    if coop_rate >= 0.6:
        cooperate()  // Reward good collective behavior
    else:
        cooperate()  // Still cooperate to maintain threshold
        
elif previous_round_cooperators == m:
    // Threshold barely met - critical cooperation needed
    cooperate()  // Essential to maintain threshold
    
elif previous_round_cooperators == m - 1:
    // One short of threshold - high cooperation probability needed
    cooperate()  // Help reach threshold
    
else:  // previous_round_cooperators < m - 1
    // Threshold failed by multiple players
    if coop_rate >= 0.4:
        cooperate()  // Give group another chance
    else:
        defect()   // Protect against systematic defection
```

### Final Round (Round r): Conditional Cooperation
Since there's no future retaliation possibility, use a modified approach:

```pseudocode
if average_cooperation_rate_over_all_rounds >= 0.5:
    if previous_round_cooperators >= m - 1:
        cooperate()  // Maintain successful cooperation pattern
    else:
        defect()     // Avoid exploitation if pattern broken
else:
    defect()         // Group has shown poor cooperation overall
```

## Key Features

### 1. **Trust Building**: 
- Always starts cooperatively to signal intent
- Rewards groups that exceed the minimum threshold
- Gives second chances when threshold barely fails

### 2. **Threshold Awareness**:
- Prioritizes cooperation when close to threshold (m-1, m)
- Maintains safety margins when possible
- Adapts to group cooperation patterns

### 3. **Exploitation Protection**:
- Defects when cooperation rate falls below 40% (except near threshold)
- Uses final round defection as protection against end-game exploitation
- Tracks overall group cooperation trends

### 4. **Cooperative Consistency**:
- Biased toward cooperation in ambiguous situations
- Maintains cooperation even when threshold is barely met
- Only defects when group shows systematic free-riding

## Edge Case Handling

- **First Round**: Always cooperate (trust-building)
- **Near Threshold**: Always cooperate when cooperators = m-1 or m
- **Threshold Exceeded**: Continue cooperating to reinforce positive patterns
- **Mass Defection**: Temporarily defect when <40% cooperate and not near threshold
- **Final Round**: Conditional cooperation based on historical group behavior

This strategy balances the cooperative goal of achieving collective benefits while maintaining rational safeguards against exploitation, making it robust for tournament play against diverse opponent strategies.
'''

description_COOPERATIVE_6 = '''
# Cooperative Strategy: "Adaptive Threshold Guardian"

## Core Philosophy
This strategy prioritizes collective welfare while being resilient to exploitation. It aims to maintain cooperation when beneficial while adapting to opponent behavior to ensure the cooperation threshold is met.

## Strategy Description

### Decision Rules

**Primary Cooperation Principle:**
- Default to cooperation (C) to maximize collective benefit
- Monitor cooperation levels and adapt to ensure threshold achievement
- Use forgiveness mechanisms to recover from temporary defections

**Specific Decision Logic:**

1. **First Round:** Always cooperate (C)
   - Establishes cooperative intent
   - No historical data to inform decision

2. **Rounds 2 to r-2 (Middle Rounds):**
   ```
   cooperators_last_round = count of C actions in previous round
   my_cooperation_history = my cooperation rate so far
   others_cooperation_rate = average cooperation rate of others
   
   IF cooperators_last_round >= m:
       // Threshold was met - continue cooperation
       action = C
   
   ELSE IF cooperators_last_round == m-1:
       // Critical: one more cooperator needed
       action = C  // Be the difference maker
   
   ELSE IF cooperators_last_round < m-1:
       // Threshold missed by 2+ - evaluate if cooperation is viable
       IF others_cooperation_rate > 0.4:
           action = C  // Others show cooperative intent
       ELSE:
           // Strategic defection to avoid exploitation
           action = D
   ```

3. **Round r-1 (Second-to-last round):**
   ```
   recent_cooperation = cooperation rate in last 3 rounds
   
   IF recent_cooperation >= (m/n):
       action = C  // Group shows cooperative potential
   ELSE:
       action = C  // One last attempt to enable cooperation
   ```

4. **Round r (Final round):**
   ```
   IF expected_cooperators >= m-1:
       action = C  // Ensure threshold is met
   ELSE:
       action = D  // No future rounds to recover cooperation
   ```

### Adaptive Mechanisms

**Forgiveness Component:**
- After any round where threshold is missed, increase cooperation probability by 0.2 for next 2 rounds
- This helps recover from coordination failures

**Trend Analysis:**
- Track 3-round moving average of cooperation levels
- If trend is improving (cooperation increasing), maintain C even if recent threshold misses occurred

**Critical Mass Detection:**
```
IF round > 3:
    stable_cooperators = players who cooperated in ≥80% of rounds
    IF stable_cooperators >= m-1:
        action = C  // Reliable cooperation base exists
```

## Edge Case Handling

**Very Small Groups (n ≤ 4):**
- Increase cooperation threshold for defection decisions
- Be more forgiving of temporary defections

**High Threshold Games (m close to n):**
- Always cooperate unless clear evidence of systematic defection
- One defector can doom the group, so maximize cooperation attempts

**Very Long Games (r > 20):**
- Implement "probation periods" - after defecting, cooperate for next 3 rounds regardless of others' actions
- This signals commitment to cooperation recovery

## Cooperation Guarantees

This strategy ensures cooperation through:

1. **Default Cooperation:** Base assumption is to cooperate
2. **Threshold Protection:** Actively tries to ensure m cooperators exist
3. **Recovery Mechanisms:** Multiple ways to return to cooperation after conflicts
4. **Endgame Cooperation:** Maintains cooperation even in final rounds when beneficial

## Expected Behavior

- **Against other cooperative strategies:** Mutual cooperation, achieving optimal collective outcomes
- **Against mixed strategies:** Maintains cooperation when viable, strategically defects only when necessary to avoid exploitation
- **Against defection-heavy strategies:** Initially cooperative but adapts to prevent systematic exploitation while still attempting cooperation recovery

This strategy balances the cooperative mandate with practical game theory considerations, ensuring both individual rationality and collective benefit maximization.
'''

description_COOPERATIVE_7 = '''
# Cooperative Strategy: "Threshold-Aware Conditional Cooperator"

## Core Philosophy
This strategy is designed to maximize collective welfare while being resilient to exploitation. It operates on the principle of **conditional cooperation** - cooperating when there's evidence others will reciprocate, but protecting against free-riders through careful threshold monitoring.

## Decision Rules

### Round 1: Optimistic Start
- **Always cooperate** in the first round
- Rationale: Establish cooperative intent and give others the benefit of the doubt

### Rounds 2 to r-1: Adaptive Cooperation
Use a three-tier decision framework:

```pseudocode
function decide_action(round_num, history):
    if round_num == 1:
        return COOPERATE
    
    # Calculate cooperation metrics from previous round
    last_cooperators = count_cooperators(history[round_num-1])
    avg_cooperation_rate = calculate_avg_cooperation_rate(history)
    
    # Tier 1: Strong cooperation signal
    if last_cooperators >= m + 1:
        return COOPERATE
    
    # Tier 2: Threshold analysis
    elif last_cooperators == m:
        if avg_cooperation_rate >= (m/n) * 0.8:
            return COOPERATE
        else:
            return DEFECT
    
    # Tier 3: Below threshold response
    elif last_cooperators == m - 1:
        # Forgiveness mechanism - cooperate if cooperation trend is positive
        if cooperation_trend_positive(history, window=3):
            return COOPERATE
        else:
            return DEFECT
    
    # Tier 4: Far below threshold
    else:  # last_cooperators < m - 1
        # Only cooperate if there's been a recent surge in cooperation
        if recent_cooperation_surge(history, threshold=0.3):
            return COOPERATE
        else:
            return DEFECT
```

### Final Round: Conditional Cooperation
- **Cooperate if** cooperation rate in previous rounds ≥ 60% AND last round had ≥ m-1 cooperators
- **Otherwise defect** (protect against end-game defection)

## Key Components

### 1. Cooperation Rate Calculation
```pseudocode
function calculate_avg_cooperation_rate(history):
    total_cooperations = 0
    total_decisions = 0
    
    for each round in history:
        total_cooperations += count_cooperators(round)
        total_decisions += n
    
    return total_cooperations / total_decisions
```

### 2. Trend Analysis
```pseudocode
function cooperation_trend_positive(history, window):
    if length(history) < window:
        window = length(history)
    
    recent_rates = []
    for i in range(window):
        round_rate = count_cooperators(history[end-i]) / n
        recent_rates.append(round_rate)
    
    # Check if trend is increasing or stable at good level
    return is_increasing_or_stable_high(recent_rates, threshold=m/n)
```

### 3. Surge Detection
```pseudocode
function recent_cooperation_surge(history, threshold):
    if length(history) < 2:
        return false
    
    recent_rate = count_cooperators(history[end]) / n
    previous_rate = count_cooperators(history[end-1]) / n
    
    return (recent_rate - previous_rate) >= threshold
```

## Edge Case Handling

### First Round
- Always cooperate to signal cooperative intent
- Sets positive tone for the game

### Last Round (Round r)
- Conditional cooperation based on established patterns
- Avoids naive cooperation if others are clearly defecting
- Still rewards consistent cooperators

### Threshold Edge Cases
- **Exactly at threshold (m cooperators)**: Cooperate if overall cooperation rate is healthy
- **One short (m-1 cooperators)**: Show forgiveness if positive trends exist
- **Well below threshold**: Only respond to clear surge in cooperation

## Cooperative Alignment Features

1. **Optimistic Start**: Always begins cooperatively
2. **Forgiveness Mechanism**: Gives second chances when cooperation trends are positive
3. **Threshold Awareness**: Recognizes when cooperation is working and reinforces it
4. **Pattern Recognition**: Adapts to the specific dynamics of each game
5. **Collective Welfare Focus**: Prioritizes achieving the threshold over individual gain

## Strategic Rationale

This strategy balances three key objectives:
- **Maximize collective payoffs** by encouraging threshold achievement
- **Resist exploitation** by defecting against persistent free-riders  
- **Maintain cooperation** by showing forgiveness and responding to positive signals

The multi-tier approach ensures the strategy is neither too naive (always cooperate) nor too harsh (tit-for-tat), instead adapting to the specific threshold dynamics of the collective risk dilemma.
'''

description_COOPERATIVE_8 = '''
# Cooperative Strategy: "Adaptive Threshold Guardian"

## Core Philosophy
This strategy prioritizes collective welfare while being resilient to defection. It aims to maintain cooperation when possible but adapts intelligently to ensure the threshold is met even when facing some defectors.

## Strategy Overview

### Decision Rules

**Round 1: Always Cooperate**
- Start with cooperation to signal good intentions and establish a cooperative norm

**Rounds 2 to r-1: Adaptive Response**
1. **Count previous round cooperators** (c_prev)
2. **Apply decision logic:**
   - If c_prev ≥ m: **Cooperate** (threshold was met, maintain cooperation)
   - If c_prev = m-1: **Cooperate** (critical support needed)
   - If c_prev < m-1: **Defect** (too many defectors, protect yourself)

**Final Round r: Threshold Insurance**
- **Cooperate** if cooperation history suggests others will likely cooperate
- Specifically: Cooperate if average cooperation rate across all previous rounds ≥ (m/n)

### Pseudocode

```python
def decide_action(round_num, history, n, m, r):
    if round_num == 1:
        return COOPERATE
    
    if round_num < r:  # Rounds 2 to r-1
        cooperators_last_round = count_cooperators(history[-1])
        
        if cooperators_last_round >= m:
            return COOPERATE
        elif cooperators_last_round == m - 1:
            return COOPERATE  # Critical support
        else:
            return DEFECT
    
    else:  # Final round
        total_cooperation_rate = calculate_avg_cooperation_rate(history)
        threshold_rate = m / n
        
        if total_cooperation_rate >= threshold_rate:
            return COOPERATE
        else:
            return DEFECT
```

## Strategic Rationale

### Cooperative Elements
1. **Optimistic Start**: Always cooperate in round 1 to promote initial cooperation
2. **Threshold Support**: Always cooperate when we're the critical vote (c_prev = m-1)
3. **Reward Cooperation**: Continue cooperating when threshold was previously met
4. **Final Round Cooperation**: Cooperate in the last round if historical data suggests success

### Adaptive Protection
1. **Defection Punishment**: Stop cooperating when facing too many defectors (c_prev < m-1)
2. **Self-Preservation**: In the final round, only cooperate if there's reasonable evidence others will too

### Edge Case Handling

**First Round**: Always cooperate to establish good faith and encourage reciprocal cooperation.

**Last Round**: Use historical cooperation rate as predictor. This prevents being exploited in the final round while still cooperating when the group has shown consistent cooperative behavior.

**Threshold Scenarios**: 
- When exactly m-1 players cooperated previously, always provide the critical cooperation needed
- When fewer than m-1 cooperated, defect to avoid being exploited by free riders

## Why This Strategy Works

1. **Promotes Initial Cooperation**: The optimistic first move encourages others to cooperate
2. **Maintains Beneficial Equilibria**: Continues cooperating when the group is successfully meeting thresholds
3. **Prevents Exploitation**: Stops cooperating when too many others are defecting
4. **Critical Support**: Always provides cooperation when it's the deciding factor
5. **Intelligent Final Play**: Uses accumulated information to make the best final decision

This strategy balances cooperative intentions with strategic protection, making it robust against various opponent types while maximizing opportunities for mutual benefit.
'''

description_COOPERATIVE_9 = '''
# Cooperative Strategy: "Adaptive Trust Builder"

## Core Philosophy
This strategy is built on the principle that cooperation is mutually beneficial, but requires building and maintaining trust while being resilient to occasional defections. The goal is to maximize collective welfare while protecting against exploitation.

## Decision Rules

### Round 1: Optimistic Start
- **Always cooperate** in the first round
- Rationale: Signal cooperative intent and give others the benefit of the doubt

### Rounds 2 to r-1: Adaptive Cooperation with Forgiveness

**Primary Rule: Threshold-Based Cooperation**
- Cooperate if the number of cooperators in the previous round ≥ (m - 1)
- This ensures we contribute when we're close to or above the threshold

**Forgiveness Mechanism:**
- If cooperation dropped below (m-1) in the previous round, still cooperate if:
  - The cooperation rate in the last round was ≥ 50% of players, OR
  - There's been a recent upward trend in cooperation (cooperation increased from round t-2 to t-1)

**Trust Erosion Protection:**
- If cooperation has been below (m-1) for 3 consecutive rounds AND cooperation rate < 30%, switch to defection until cooperation recovers

### Final Round: Conditional Cooperation
- Cooperate if cooperation rate in round (r-1) was ≥ 60%
- Otherwise defect (since there's no future to build toward)

## Pseudocode

```python
def decide_action(round_num, history, n, m, r, k):
    # Round 1: Always cooperate
    if round_num == 1:
        return "C"
    
    # Get previous round cooperation count
    prev_cooperators = count_cooperators(history[-1])
    cooperation_rate = prev_cooperators / n
    
    # Final round logic
    if round_num == r:
        return "C" if cooperation_rate >= 0.6 else "D"
    
    # Check for trust erosion (3+ consecutive rounds below threshold)
    if len(history) >= 3:
        recent_cooperation = [count_cooperators(round) for round in history[-3:]]
        if all(coop < (m-1) for coop in recent_cooperation) and cooperation_rate < 0.3:
            # Stay defecting until cooperation recovers
            return "D" if prev_cooperators < (m-1) else "C"
    
    # Primary threshold-based rule
    if prev_cooperators >= (m-1):
        return "C"
    
    # Forgiveness mechanisms
    if cooperation_rate >= 0.5:
        return "C"
    
    # Check for upward trend
    if len(history) >= 2:
        trend_cooperators = count_cooperators(history[-2])
        if prev_cooperators > trend_cooperators:
            return "C"
    
    # Default to defection if cooperation is too low
    return "D"

def count_cooperators(round_actions):
    return sum(1 for action in round_actions if action == "C")
```

## Key Features

1. **Optimistic Opening**: Signals cooperative intent from the start
2. **Threshold Awareness**: Focuses on the critical threshold (m-1) rather than perfect cooperation
3. **Graduated Forgiveness**: Allows for occasional defections while maintaining cooperation
4. **Trend Recognition**: Rewards improving cooperation even if below threshold
5. **Protection Against Exploitation**: Has mechanisms to avoid being taken advantage of
6. **Endgame Adaptation**: Adjusts behavior in the final round based on established patterns

## Why This Strategy is Cooperative

1. **Cooperation Bias**: Default tendency is toward cooperation
2. **Collective Focus**: Decisions based on achieving the threshold for collective benefit
3. **Forgiveness**: Doesn't immediately punish single defections
4. **Trust Building**: Rewards positive trends and sustained cooperation
5. **Group Welfare**: Prioritizes reaching the threshold (m) over individual payoff maximization

This strategy balances the cooperative imperative with practical considerations about trust, reciprocity, and protection against exploitation, making it robust for tournament play against diverse opponent strategies.
'''

description_COOPERATIVE_10 = '''
Looking at this Collective Risk Dilemma, I'll design a cooperative strategy that balances trust-building with pragmatic risk management. Here's my approach:

## Strategy: "Cooperative Threshold Guardian"

### Core Philosophy
This strategy prioritizes collective welfare while maintaining vigilance against free-riders. It aims to establish and maintain cooperation by being generous early, responsive to group dynamics, and protective of the cooperative equilibrium.

### Decision Rules

**Round 1: Always Cooperate**
- Start with cooperation to signal good intentions and attempt to establish a cooperative norm

**Rounds 2 to r-1: Adaptive Cooperation**
```pseudocode
cooperation_count = count_cooperators_last_round()
my_last_action = my_action_last_round()

if cooperation_count >= m:
    // Threshold was met - reward this outcome
    cooperate()
else:
    // Threshold failed
    if my_last_action == COOPERATE:
        // I cooperated but we failed - be more selective
        if cooperation_count >= (m-1):
            // Close call - give another chance
            cooperate()
        else:
            // Far from threshold - defect to avoid being exploited
            defect()
    else:
        // I defected last round - try to repair if others are trying
        if cooperation_count >= (m-2):
            // Others are making an effort - rejoin
            cooperate()
        else:
            // Still not enough cooperation - continue defecting
            defect()
```

**Final Round (r): Strategic Endgame**
```pseudocode
cooperation_count_last_round = count_cooperators_last_round()
recent_cooperation_trend = average_cooperation_last_3_rounds()

if cooperation_count_last_round >= m:
    // Group achieved threshold recently - maintain cooperation
    cooperate()
else if recent_cooperation_trend >= (m-1):
    // Group is close and trying - give final push
    cooperate()
else:
    // Group has given up on cooperation - protect myself
    defect()
```

### Key Strategic Elements

1. **Trust Building**: Always start cooperative to signal good intentions and give the group the best chance to establish a cooperative equilibrium.

2. **Threshold Sensitivity**: Pay close attention to how close the group gets to the threshold `m`. Being one player away from success warrants different behavior than being far from it.

3. **Reciprocal Response**: Reward successful cooperation (when threshold is met) with continued cooperation. Punish failed cooperation attempts by becoming more selective.

4. **Forgiveness with Conditions**: If I defected but others are showing renewed effort, rejoin the cooperative attempt. This prevents permanent breakdown from temporary setbacks.

5. **Endgame Awareness**: In the final round, base decisions on recent trends rather than single-round results, as this is the last chance for collective success.

### Edge Case Handling

- **All players cooperate**: Continue cooperating to maintain the optimal outcome
- **All players defect**: Defect to avoid being the only contributor, but be ready to rejoin if others show renewed interest
- **Oscillating cooperation**: Use the recent trend analysis to avoid being whipsawed by single-round fluctuations
- **Near-threshold scenarios**: Be more generous when the group is close to success (m-1 or m-2 cooperators)

### Cooperative Alignment

This strategy is fundamentally cooperative because it:
- Starts with trust and good faith
- Rewards group success with continued cooperation  
- Gives second chances when the group is making genuine efforts
- Only becomes defensive when facing clear free-riding
- Prioritizes collective welfare over individual gain when the group demonstrates commitment

The strategy recognizes that successful cooperation requires both trust and accountability - being generous enough to enable cooperation while being firm enough to discourage exploitation.
'''

description_COOPERATIVE_11 = '''
# Cooperative Strategy: "Optimistic Threshold Guardian"

## Core Philosophy
This strategy prioritizes collective welfare while maintaining resilience against defection. It operates on the principle that cooperation should be the default, but strategic defection may be necessary to preserve resources for critical moments when cooperation is most needed.

## Decision Rules

### Primary Decision Logic
```
if round == 1:
    return COOPERATE
    
if round == final_round:
    return COOPERATE_IF_VIABLE()
    
# Main strategy body
cooperation_threshold = calculate_cooperation_threshold()
expected_cooperators = estimate_cooperators_this_round()

if expected_cooperators >= cooperation_threshold:
    return COOPERATE
else:
    return evaluate_conditional_cooperation()
```

### Key Components

**1. Cooperation Threshold Calculation**
```
cooperation_threshold = max(m, n * 0.4)
```
- Never go below the minimum required (m)
- Aim for at least 40% cooperation to build sustainable patterns
- Adjust based on game parameters and observed behavior

**2. Cooperator Estimation**
```
estimate_cooperators_this_round():
    base_estimate = count_consistent_cooperators()
    trend_adjustment = analyze_cooperation_trend()
    return base_estimate + trend_adjustment + safety_margin
```

**3. Conditional Cooperation Evaluation**
```
evaluate_conditional_cooperation():
    if my_cooperation_makes_difference():
        return COOPERATE
    if trust_score > threshold AND rounds_remaining > 3:
        return COOPERATE
    return DEFECT
```

## Specific Round Handling

### First Round
- **Always COOPERATE** - Signal cooperative intent and establish positive momentum
- Rationale: Set the tone for mutual cooperation and avoid starting a defection cascade

### Early Rounds (rounds 2 to r/3)
- **Generous Cooperation** - Cooperate unless clear evidence suggests threshold won't be met
- Build trust and establish cooperative patterns
- Forgive occasional defections to avoid punishment spirals

### Middle Rounds (r/3 to 2r/3)
- **Adaptive Cooperation** - Balance cooperation with strategic considerations
- Monitor cooperation trends and adjust expectations
- Begin to be more selective about cooperation if patterns are consistently failing

### Late Rounds (2r/3 to r-1)
- **Strategic Cooperation** - Prioritize rounds where cooperation is most likely to succeed
- May defect when threshold clearly won't be met to preserve resources
- Focus on maintaining cooperative relationships with consistent cooperators

### Final Round
```
COOPERATE_IF_VIABLE():
    if estimated_cooperators >= (m-1):
        return COOPERATE
    if estimated_cooperators == (m-2) AND high_trust_players >= 1:
        return COOPERATE
    return DEFECT
```

## Edge Case Handling

### Consistent Mass Defection
- If cooperation rate falls below 20% for 3+ consecutive rounds:
  - Switch to "Minimal Viable Cooperation" mode
  - Only cooperate when confident exactly m cooperators exist
  - Attempt to coordinate with identified consistent cooperators

### High Cooperation Scenarios
- If cooperation consistently exceeds threshold by large margins:
  - Continue cooperating to maintain positive momentum
  - Don't exploit high cooperation for personal gain

### Parameter-Specific Adaptations
- **High k values (k > 3)**: More aggressive cooperation even with uncertainty
- **Low threshold (m close to 1)**: More willing to take risks on cooperation
- **High threshold (m close to n)**: More conservative, focus on coalition building

## Cooperation Signals and Recognition

### Identify Cooperation Patterns
- Track players who cooperate consistently
- Recognize "conditional cooperators" who cooperate when threshold is likely
- Identify and adapt to other strategic patterns

### Trust Building
- Reward consistent cooperators with continued cooperation
- Gradually rebuild trust with reformed defectors
- Maintain cooperation even when personally disadvantageous if it preserves group welfare

## Implementation Pseudocode

```python
class OptimisticThresholdGuardian:
    def __init__(self, n, r, m, k):
        self.cooperation_history = []
        self.player_profiles = [PlayerProfile() for _ in range(n)]
        self.trust_threshold = 0.6
        
    def decide_action(self, round_num, history):
        if round_num == 1:
            return COOPERATE
            
        self.update_player_profiles(history)
        
        expected_cooperators = self.estimate_cooperators()
        cooperation_threshold = max(self.m, self.n * 0.4)
        
        if expected_cooperators >= cooperation_threshold:
            return COOPERATE
        elif self.would_make_difference(expected_cooperators):
            return COOPERATE
        elif self.high_trust_situation() and self.rounds_remaining > 3:
            return COOPERATE
        else:
            return DEFECT
            
    def estimate_cooperators(self):
        consistent = sum(1 for p in self.player_profiles if p.cooperation_rate > 0.7)
        conditional = sum(1 for p in self.player_profiles if p.is_conditional_cooperator())
        return consistent + (conditional * self.cooperation_probability)
```

This strategy balances cooperative ideals with strategic thinking, aiming to maximize collective welfare while maintaining resilience against exploitation.
'''

description_COOPERATIVE_12 = '''
# Cooperative Strategy: "Trust-Building Collective Guardian"

## Core Philosophy
This strategy prioritizes collective welfare while being resilient to exploitation. It aims to establish and maintain cooperation through trust-building, forgiveness, and strategic adaptation.

## Decision Rules

### Round 1: Optimistic Start
**Action: COOPERATE**
- Begin with cooperation to signal good intentions
- This establishes a cooperative baseline and tests others' willingness to cooperate

### Rounds 2 to r-1: Adaptive Cooperation with Forgiveness

**Primary Decision Logic:**
```pseudocode
cooperation_rate = count_cooperators_last_round / n
threshold_safety = m / n

if cooperation_rate >= threshold_safety:
    return COOPERATE  // Maintain cooperation when threshold is safely met
else if cooperation_rate >= (threshold_safety - 0.1):
    return COOPERATE  // Give benefit of doubt when close to threshold
else:
    // Analyze cooperation trend over last 3 rounds
    recent_trend = analyze_cooperation_trend(last_3_rounds)
    
    if recent_trend == "improving" or recent_trend == "stable":
        return COOPERATE  // Support recovery or stability
    else if count_cooperators_last_round >= (m - 1):
        return COOPERATE  // Be the critical cooperator when close
    else:
        return DEFECT    // Protect against exploitation when cooperation is failing
```

### Final Round: Conditional Cooperation
**Special handling for round r:**
- If cooperation has been consistently high (≥70% in last 3 rounds): COOPERATE
- If we're at risk of threshold failure and my cooperation could help: COOPERATE  
- Otherwise: Apply same logic as middle rounds

## Key Strategic Elements

### 1. Threshold Awareness
- Always consider how close we are to the minimum threshold (m)
- Be willing to cooperate even when slightly disadvantaged if it helps reach the threshold

### 2. Trend Analysis
Monitor cooperation patterns over the last 2-3 rounds:
- **Improving trend**: More players cooperating over time → Stay cooperative
- **Stable trend**: Consistent cooperation levels → Match the pattern
- **Declining trend**: Cooperation breaking down → Consider defensive defection

### 3. Forgiveness Mechanism
- Don't permanently punish defectors
- Give groups a chance to recover from low cooperation phases
- Reset trust periodically based on recent behavior rather than entire history

### 4. Critical Cooperation
When exactly (m-1) players cooperated last round, strongly lean toward cooperation to help maintain the threshold.

## Edge Case Handling

### Very Small Groups (n ≤ 4)
- Be more forgiving since each player's decision has higher impact
- Cooperate more frequently to maintain group cohesion

### High Threshold Scenarios (m close to n)
- Maintain cooperation longer since defection is more likely to cause collective failure
- Only defect when cooperation has clearly broken down across multiple rounds

### Low Threshold Scenarios (m ≪ n)  
- Still cooperate but be more willing to defect against persistent free-riders
- Focus on maintaining a stable cooperative core

## Pseudocode Summary

```pseudocode
function decide_action(round, history):
    if round == 1:
        return COOPERATE
    
    last_round_cooperators = count_cooperators(history[-1])
    cooperation_rate = last_round_cooperators / n
    threshold_rate = m / n
    
    // Final round special case
    if round == r:
        if average_cooperation_rate(history[-3:]) >= 0.7:
            return COOPERATE
        else:
            apply_standard_logic()
    
    // Standard logic
    if cooperation_rate >= threshold_rate:
        return COOPERATE
    else if cooperation_rate >= (threshold_rate - 0.1):
        return COOPERATE
    else if last_round_cooperators >= (m - 1):
        return COOPERATE
    else if cooperation_trend_improving(history[-3:]):
        return COOPERATE
    else:
        return DEFECT
```

## Why This Strategy Is Cooperative

1. **Starts with cooperation** and maintains it when others reciprocate
2. **Prioritizes collective success** by considering threshold requirements
3. **Includes forgiveness** - doesn't permanently punish past defections  
4. **Willing to sacrifice** individual payoff when close to threshold
5. **Builds trust** through consistent cooperative signaling
6. **Focuses on group welfare** rather than just individual maximization

This strategy balances cooperative ideals with practical resilience, aiming to foster and maintain the cooperation necessary for collective success while protecting against total exploitation.
'''

description_COOPERATIVE_13 = '''
# Cooperative Strategy: "Adaptive Threshold Guardian"

## Core Philosophy
This strategy prioritizes collective welfare while being resilient to exploitation. It aims to maintain cooperation when beneficial while protecting against free-riders through measured responses.

## Decision Rules

### Round 1: Initial Cooperation Signal
```
Action: COOPERATE
Rationale: Signal cooperative intent and establish good faith
```

### Rounds 2 to r-1: Adaptive Response
```
IF (previous_round_cooperators >= m):
    # Threshold was met - evaluate cooperation sustainability
    IF (previous_round_cooperators >= m + 1):
        Action: COOPERATE  # Safe margin exists
    ELSE:  # exactly m cooperators
        IF (I cooperated last round):
            Action: COOPERATE  # Continue contributing to barely-met threshold
        ELSE:
            Action: COOPERATE  # Join to maintain threshold
ELSE:
    # Threshold failed - determine response
    cooperation_trend = cooperators_last_3_rounds_average
    IF (cooperation_trend > m - 1):
        Action: COOPERATE  # Trend suggests recovery possible
    ELSE:
        Action: DEFECT     # Insufficient cooperation trend
```

### Final Round (r): Conditional Cooperation
```
recent_cooperation_rate = cooperators_in_last_2_rounds / (2 * n)
IF (recent_cooperation_rate >= 0.6):
    Action: COOPERATE  # Reward consistent cooperators
ELSE:
    Action: DEFECT     # Don't be exploited in final round
```

## Key Features

### 1. Threshold Awareness
- Always considers how many cooperators are needed (m)
- Recognizes when personal cooperation is pivotal
- Maintains safety margins when possible

### 2. Adaptive Forgiveness
- Doesn't immediately punish single failures if trend is positive
- Uses 3-round moving average to assess cooperation trends
- Distinguishes between temporary setbacks and systematic defection

### 3. End-Game Protection
- Prevents exploitation in final rounds while rewarding consistent cooperators
- Uses recent cooperation history rather than all-game history for final decision

### 4. Edge Case Handling
```
Special Cases:
- If m = n-1: More cautious, requires strong cooperation signals
- If m = 2: More forgiving, easier to recover from failures  
- If only 2-3 rounds total: Bias toward cooperation
```

## Cooperative Elements

1. **Default to Cooperation**: Starts cooperatively and maintains bias toward cooperation
2. **Collective Benefit Focus**: Prioritizes meeting threshold m over individual gain
3. **Measured Punishment**: Uses temporary defection as signal, not permanent abandonment
4. **Recovery Support**: Helps rebuild cooperation after failures through trend analysis
5. **Sacrifice for Success**: Continues cooperating even when threshold barely met

## Strategic Rationale

This strategy balances three key objectives:
- **Maximize collective payoffs** by maintaining cooperation when feasible
- **Avoid systematic exploitation** through adaptive responses to defection
- **Signal cooperative intent** while encouraging others to reciprocate

The strategy is particularly effective because it:
- Responds to the specific threshold structure (unlike generic tit-for-tat)
- Uses trend analysis rather than just last-round information
- Maintains cooperative stance even under pressure
- Protects against end-game exploitation while rewarding cooperators

This approach should perform well against other cooperative strategies while remaining resilient to exploitation attempts.
'''

description_COOPERATIVE_14 = '''
# Cooperative Strategy: "Adaptive Trust Builder"

## Core Philosophy
This strategy prioritizes collective welfare while being resilient to exploitation. It starts with optimistic cooperation, learns from group behavior, and maintains cooperative momentum when possible.

## Decision Rules

### Round 1: Optimistic Start
- **Always cooperate** in the first round
- Rationale: Demonstrate commitment to cooperation and help establish a cooperative norm

### Rounds 2 to r-1: Adaptive Cooperation
Use a multi-factor decision rule based on:

1. **Cooperation Rate Threshold**: Track the cooperation rate from previous rounds
2. **Trend Analysis**: Consider whether cooperation is increasing or decreasing
3. **Safety Margin**: Account for uncertainty in others' decisions

**Decision Logic:**
```pseudocode
cooperation_rate = (total_cooperators_in_previous_rounds) / (n * rounds_played)
recent_trend = cooperation_rate_last_3_rounds - cooperation_rate_before_that

if cooperation_rate >= (m/n + 0.1):
    # High cooperation environment - continue cooperating
    return COOPERATE
    
elif cooperation_rate >= (m-1)/n AND recent_trend > -0.1:
    # Borderline but stable/improving - cooperate with hope
    return COOPERATE
    
elif cooperation_rate >= (m-2)/n AND recent_trend > 0.2:
    # Low but rapidly improving - give it a chance
    return COOPERATE
    
else:
    # Insufficient cooperation despite good faith efforts
    return DEFECT
```

### Final Round (Round r): Conditional Cooperation
Despite it being the last round, maintain cooperation if:
- The group has consistently met the threshold (≥80% of previous rounds)
- OR cooperation rate in last 3 rounds ≥ (m+1)/n

Otherwise, defect to avoid being exploited in the final round.

## Key Features

### 1. Forgiveness Mechanism
- If cooperation rate was low but shows strong recent improvement (trend > 0.3), give the group another chance
- Allows recovery from early coordination failures

### 2. Safety Margins
- Don't just aim for exactly m cooperators; build buffer for uncertainty
- Use thresholds slightly above the minimum to account for others who might defect

### 3. Trend Sensitivity
- Weight recent behavior more heavily than distant history
- Respond to improving dynamics even if overall history is poor

### 4. Endgame Handling
- Recognize that final round creates defection incentives
- But still cooperate if group has proven trustworthy
- Balance between avoiding exploitation and maintaining cooperative reputation

## Edge Case Handling

**If n = m+1** (only one extra player above minimum):
- Be more generous with cooperation thresholds since each player is critical
- Cooperate unless cooperation rate < 0.5

**If m is very close to n** (high threshold):
- Start with cooperation but switch to conditional cooperation sooner
- Use threshold of (m-0.5)/n rather than (m-1)/n

**If early rounds show zero cooperation**:
- Still give 2-3 rounds of cooperation attempts to help coordination
- Then switch to defection if no improvement

## Rationale

This strategy balances several key elements:

1. **Initiates Cooperation**: Starts cooperatively to help establish good norms
2. **Learns and Adapts**: Responds to actual group behavior rather than assuming
3. **Maintains Hope**: Gives groups chances to improve and coordinate
4. **Protects Against Exploitation**: Won't continue cooperating indefinitely with defectors
5. **Considers Uncertainty**: Uses safety margins since we can't perfectly predict others
6. **Handles Endgame**: Recognizes final round dynamics while rewarding consistent cooperators

The strategy aims to maximize collective welfare when possible while avoiding being systematically exploited by predominantly selfish opponents.
'''

description_COOPERATIVE_15 = '''
# Cooperative Strategy: "Threshold Guardian"

## Core Philosophy
This strategy prioritizes collective welfare while maintaining resilience against exploitation. It aims to establish and maintain cooperation when feasible, while protecting against scenarios where cooperation becomes unsustainable.

## Decision Rules

### Primary Decision Framework
```pseudocode
function decide_action(round, history, n, m, k, r):
    if round == 1:
        return COOPERATE
    
    cooperators_last_round = count_cooperators(history[round-1])
    total_cooperators_needed = m * (r - round + 1)  // remaining rounds
    
    // Core cooperation conditions
    if cooperators_last_round >= m:
        return COOPERATE
    
    // Recovery attempt condition
    if cooperators_last_round >= (m - 2) and round <= (r * 0.8):
        return COOPERATE
    
    // Critical mass building
    my_cooperation_history = count_my_cooperations(history)
    others_avg_cooperation = calculate_others_avg_cooperation(history)
    
    if others_avg_cooperation >= 0.4 and round <= (r * 0.9):
        return COOPERATE
    
    // Final rounds strategic cooperation
    if round > (r * 0.9):
        expected_cooperators = estimate_cooperators_based_on_trends(history)
        if expected_cooperators >= (m - 1):
            return COOPERATE
    
    return DEFECT
```

## Detailed Strategy Components

### 1. Opening Cooperation (Round 1)
- **Always cooperate** in the first round to signal cooperative intent
- This establishes a pro-social baseline and encourages others to reciprocate

### 2. Threshold Maintenance (Core Rounds)
- **Cooperate when threshold was met** in the previous round
- This reinforces successful cooperation and maintains momentum
- Rationale: If m+ players cooperated last round, the group demonstrated ability to coordinate

### 3. Recovery Mechanism (Early-Mid Game)
- **Attempt recovery** when close to threshold (m-2 or m-1 cooperators) in first 80% of rounds
- Provides second chances for coordination failures
- Prevents permanent collapse from temporary coordination issues

### 4. Adaptive Cooperation Assessment
- Monitor others' average cooperation rate across all previous rounds
- **Maintain cooperation** if others show >40% cooperation rate through 90% of the game
- This identifies genuinely cooperative opponents worth supporting

### 5. Endgame Strategy (Final 10% of rounds)
- **Strategic final cooperation** based on trend analysis
- Estimate likely cooperators in final rounds using historical patterns
- Cooperate if projections suggest threshold achievement is probable

## Edge Case Handling

### First Round
- Always cooperate to signal cooperative intent and test waters

### Last Round
- Cooperate only if trend analysis suggests ≥(m-1) other cooperators likely
- Balances final reward opportunity against exploitation risk

### Consecutive Failures
- After 3+ consecutive rounds below threshold, require higher confidence (≥50% others' cooperation rate) to continue cooperating

### High Exploitation Scenarios
- If personal cooperation rate >70% while others average <30%, switch to defection until others show renewed cooperation

## Cooperative Alignment

This strategy embodies cooperation through:

1. **Optimistic Opening**: Always starts cooperatively
2. **Reward Success**: Reinforces when cooperation works
3. **Forgiveness**: Attempts recovery after near-misses
4. **Persistence**: Continues cooperating with genuinely cooperative players
5. **Strategic Wisdom**: Makes informed final-round decisions to maximize collective benefit

The strategy balances pure cooperation with necessary protection mechanisms, ensuring that cooperative intent isn't exploited while still prioritizing collective welfare whenever sustainable.
'''

description_COOPERATIVE_16 = '''
# Cooperative Strategy: "Threshold Guardian with Forgiveness"

## Strategy Overview
This strategy prioritizes collective success while being resilient to occasional defections from other players. It operates on the principle of being a reliable cooperator while monitoring whether the group can realistically achieve the threshold.

## Core Decision Rules

### Primary Logic:
```
IF (round == 1) THEN
    ACTION = COOPERATE
ELSE IF (cooperation_trend_positive AND threshold_achievable) THEN
    ACTION = COOPERATE
ELSE IF (recent_cooperation_rate >= forgiveness_threshold) THEN
    ACTION = COOPERATE
ELSE
    ACTION = DEFECT
```

### Detailed Decision Framework:

1. **First Round**: Always COOPERATE
   - Establishes cooperative intent
   - Provides initial signal to other players

2. **Rounds 2 to r-1**: Apply Threshold Guardian Logic
   ```
   cooperation_trend_positive = (cooperation_rate_last_3_rounds >= cooperation_rate_previous_3_rounds)
   threshold_achievable = (max_cooperators_last_round >= m-1)
   recent_cooperation_rate = cooperators_last_round / n
   forgiveness_threshold = max(0.4, (m-1)/n)
   ```

3. **Final Round**: COOPERATE if any of these conditions hold:
   - At least m-1 players cooperated in round r-1
   - Average cooperation rate over all previous rounds ≥ (m/n)
   - Otherwise, mirror the most common action from round r-1

## Key Parameters

- **Forgiveness Threshold**: Set to ensure we don't abandon cooperation too quickly
  - Minimum 40% cooperation rate OR (m-1)/n, whichever is higher
  - This prevents premature defection in games where threshold is high

- **Trend Analysis Window**: 3-round rolling window
  - Compares recent cooperation trends to detect improvement/decline
  - Helps identify when group is learning to cooperate

## Edge Case Handling

### Small Groups (n ≤ 4):
- Be more forgiving - reduce forgiveness threshold to 30%
- Weight recent rounds more heavily (last 2 rounds instead of 3)

### High Threshold Games (m/n > 0.7):
- Maintain cooperation longer even with low cooperation rates
- Only defect if cooperation rate falls below 20% for 2+ consecutive rounds

### Final Round Strategy:
- If consistently close to threshold: COOPERATE (help push over edge)
- If group has shown commitment: COOPERATE (reward group effort)
- If group has consistently failed: Match majority action from previous round

## Cooperative Mindset Alignment

1. **Default to Cooperation**: Strategy assumes others want to succeed collectively
2. **Forgiveness**: Tolerates occasional defections, focusing on overall trends
3. **Leadership**: Maintains cooperation even when slightly below threshold to encourage others
4. **Collective Success Focus**: Prioritizes group achievement over individual payoff maximization

## Pseudocode Implementation

```python
def decide_action(round_num, history, n, m, k, r):
    if round_num == 1:
        return COOPERATE
    
    # Calculate recent cooperation metrics
    last_round_cooperators = count_cooperators(history[-1])
    recent_cooperation_rate = last_round_cooperators / n
    
    # Trend analysis (if sufficient history)
    if len(history) >= 6:
        recent_avg = avg_cooperation_rate(history[-3:])
        previous_avg = avg_cooperation_rate(history[-6:-3])
        trend_positive = recent_avg >= previous_avg
    else:
        trend_positive = recent_cooperation_rate >= 0.5
    
    # Threshold achievability
    threshold_achievable = (last_round_cooperators >= m-1)
    
    # Forgiveness threshold
    forgiveness_threshold = max(0.4, (m-1)/n)
    
    # Final round special logic
    if round_num == r:
        if (last_round_cooperators >= m-1 or 
            overall_cooperation_rate(history) >= m/n):
            return COOPERATE
        else:
            return majority_action(history[-1])
    
    # Main decision logic
    if (trend_positive and threshold_achievable) or \
       (recent_cooperation_rate >= forgiveness_threshold):
        return COOPERATE
    else:
        return DEFECT
```

This strategy maintains a cooperative stance while being strategically aware of when the group is genuinely committed to collective success versus when defection becomes the rational response to consistent group failure.
'''

description_COOPERATIVE_17 = '''
# Cooperative Strategy: "Adaptive Threshold Guardian"

## Core Philosophy
This strategy prioritizes collective welfare while being resilient to exploitation. It aims to establish and maintain cooperation by being generous initially, responsive to group dynamics, and protective of the cooperative equilibrium.

## Strategy Description

### 1. Decision Rules

**Primary Rule - Threshold-Based Cooperation:**
- Cooperate if the expected number of cooperators (including myself) ≥ m
- This expectation is based on recent cooperation rates and adaptive learning

**Cooperation Rate Tracking:**
- Maintain a rolling average of cooperation rates over the last min(3, current_round) rounds
- Weight recent rounds more heavily: most recent round gets weight 0.5, previous rounds get declining weights

**Expected Cooperators Calculation:**
```pseudocode
expected_cooperators = cooperation_rate * (n-1) + 1  // +1 for my cooperation
if expected_cooperators >= m:
    play COOPERATE
else:
    evaluate_recovery_potential()
```

### 2. Edge Case Handling

**First Round:**
- Always COOPERATE
- Rationale: Establish cooperative intent and give the group the best chance to reach threshold

**Last Round:**
- COOPERATE if cooperation_rate in previous rounds ≥ (m-1)/(n-1)
- This ensures we don't abandon cooperation when others might still cooperate

**Early Rounds (rounds 2-3):**
- COOPERATE if at least (m-1) others cooperated in the previous round
- This maintains optimism while the group establishes patterns

**Recovery Mechanism:**
When cooperation falls below threshold, attempt recovery:
```pseudocode
if (rounds_remaining > 2) AND (recent_cooperation_rate > 0.3):
    // Give the group another chance if there's time and some cooperation
    play COOPERATE
else if (rounds_remaining == 1) AND (last_round_cooperators >= m-2):
    // Final attempt if we're close
    play COOPERATE
else:
    play DEFECT
```

### 3. Cooperative Elements

**Generous Tit-for-Tat Variant:**
- Forgive occasional defections if overall cooperation remains high
- Don't punish immediately if threshold was still met

**Coordination Signaling:**
- Maintain cooperation even when individual payoff would be higher from defection, as long as group cooperation is sustainable

**Threshold Protection:**
- Once the group establishes successful cooperation (≥m cooperators for 2+ consecutive rounds), strongly bias toward continued cooperation

## Complete Algorithm

```pseudocode
Strategy: AdaptiveThresholdGuardian

Initialize:
    cooperation_history = []
    my_history = []

For each round t:
    if t == 1:
        action = COOPERATE
    
    else:
        // Calculate weighted cooperation rate
        weights = [0.5, 0.3, 0.2]  // Most recent gets highest weight
        recent_rounds = min(3, t-1)
        cooperation_rate = 0
        total_weight = 0
        
        for i in range(recent_rounds):
            round_coop_rate = cooperation_history[t-1-i] / (n-1)
            cooperation_rate += round_coop_rate * weights[i]
            total_weight += weights[i]
        
        cooperation_rate = cooperation_rate / total_weight
        expected_cooperators = cooperation_rate * (n-1) + 1
        
        // Main decision logic
        if expected_cooperators >= m:
            action = COOPERATE
        
        else if (r - t > 2) AND (cooperation_rate > 0.3):
            action = COOPERATE  // Recovery attempt
        
        else if (t == r) AND (cooperation_history[t-1] >= m-2):
            action = COOPERATE  // Final round coordination
        
        else if successful_cooperation_streak() >= 2:
            action = COOPERATE  // Protect established cooperation
        
        else:
            action = DEFECT
    
    // Record decision
    my_history.append(action)
    
    // After round results are revealed
    cooperation_history.append(count_of_cooperators_this_round - (1 if action==COOPERATE else 0))

function successful_cooperation_streak():
    streak = 0
    for i in range(min(len(cooperation_history), 3)):
        if cooperation_history[-(i+1)] + (1 if my_history[-(i+1)]==COOPERATE else 0) >= m:
            streak += 1
        else:
            break
    return streak
```

## Key Cooperative Features

1. **Generous Start**: Always cooperate initially to signal cooperative intent
2. **Collective Focus**: Decisions based on group welfare (reaching threshold m)
3. **Adaptive Forgiveness**: Doesn't permanently punish single defections if cooperation recovers
4. **Threshold Protection**: Strongly maintains cooperation once established
5. **Recovery Oriented**: Attempts to rebuild cooperation when it falls apart
6. **Endgame Cooperation**: Doesn't exploit final round if cooperation is viable

This strategy balances the cooperative imperative with strategic resilience, aiming to maximize group welfare while protecting against complete exploitation.
'''

description_COOPERATIVE_18 = '''
# Cooperative Strategy: "Adaptive Trust Builder"

## Core Philosophy
This strategy operates on the principle that cooperation is inherently valuable and should be fostered, while being smart enough to adapt when cooperation isn't reciprocated. It aims to build and maintain cooperative coalitions while protecting against exploitation.

## Strategy Description

### 1. Decision Rules

**Primary Cooperation Threshold:**
- Always cooperate if we can reasonably expect to meet the threshold `m`
- Use a dynamic trust score for each player based on their cooperation history
- Cooperate when expected cooperators ≥ `m`

**Trust Scoring System:**
For each player j, maintain a trust score T_j:
- Initialize: T_j = 0.7 (optimistic but cautious)
- After each round: T_j = 0.8 × T_j + 0.2 × (1 if j cooperated, 0 if j defected)
- This gives recent behavior more weight while maintaining history

**Cooperation Decision:**
```pseudocode
expected_cooperators = 1 + sum(T_j for all other players j)
if expected_cooperators >= m:
    return COOPERATE
else:
    return conditional_cooperate()
```

### 2. Edge Case Handling

**First Round:**
- Always COOPERATE
- Rationale: Signal cooperative intent and gather information about others

**Last Round (round r):**
- COOPERATE if we cooperated in round r-1 AND at least m-1 others cooperated in round r-1
- This prevents end-game defection cascades while maintaining cooperative momentum

**Early Rounds (rounds 2 to min(5, r/3)):**
- Use "benefit of doubt" approach: COOPERATE if expected_cooperators ≥ m-1
- This allows for initial coordination difficulties and encourages coalition formation

**Middle Rounds:**
- Use standard decision rule with full trust scores

**Crisis Recovery (when threshold failed in previous round):**
- If threshold failed but ≥ m-2 players cooperated: COOPERATE (give one more chance)
- If threshold failed with < m-2 cooperators: Use forgiveness probability based on round number

### 3. Conditional Cooperation Logic

When basic threshold isn't met, use this secondary logic:

```pseudocode
function conditional_cooperate():
    highly_trusted = count(players with T_j > 0.8)
    somewhat_trusted = count(players with T_j > 0.6)
    
    if highly_trusted >= m-1:
        return COOPERATE  // Almost certain threshold will be met
    
    if somewhat_trusted >= m-1 AND round_number <= r/2:
        return COOPERATE  // Give benefit of doubt in early/middle game
    
    // Forgiveness mechanism - occasionally cooperate to test waters
    forgiveness_prob = 0.3 * (r - round_number) / r  // Decreases over time
    if random() < forgiveness_prob:
        return COOPERATE
    
    return DEFECT
```

### 4. Cooperative Safeguards

**Anti-Exploitation Measures:**
- Never cooperate more than 3 consecutive rounds if threshold consistently fails
- After 3 failed attempts, require at least 2 rounds of successful cooperation before resuming full cooperation

**Coalition Maintenance:**
- If exactly m players cooperated last round, strongly prefer to cooperate (probability 0.9) to maintain the minimal winning coalition

**Momentum Building:**
- If cooperation is increasing (more cooperators than previous round), always cooperate to reinforce positive trend

## Strategy Summary

This strategy is fundamentally cooperative because it:

1. **Defaults to cooperation** when threshold achievement seems likely
2. **Actively builds trust** through optimistic initial assumptions
3. **Maintains cooperative coalitions** once formed
4. **Includes forgiveness mechanisms** to recover from temporary breakdowns
5. **Signals cooperative intent** consistently, especially early in the game

The strategy balances cooperative ideals with practical considerations, ensuring it won't be easily exploited while still working to achieve the mutually beneficial cooperative outcome. It's designed to work well with other cooperative strategies while being robust enough to handle mixed populations of cooperative and selfish players.
'''

description_COOPERATIVE_19 = '''
# Cooperative Strategy: "Adaptive Trust Builder"

## Core Philosophy
This strategy prioritizes collective welfare while being resilient to exploitation. It starts optimistically but adapts based on community behavior, always seeking to rebuild cooperation when possible.

## Decision Rules

### Round 1: Optimistic Start
- **Action: COOPERATE**
- Rationale: Begin with good faith to establish cooperative norms

### Rounds 2 to r-1: Adaptive Cooperation
Use a three-factor decision system:

1. **Community Threshold Assessment**
   - If previous round had ≥ m cooperators: **Lean toward COOPERATE**
   - If previous round had < m cooperators: **Assess further**

2. **Momentum Analysis** (for rounds 3+)
   - If cooperation is increasing trend: **Strongly favor COOPERATE**
   - If cooperation is stable at/above threshold: **COOPERATE**
   - If cooperation is declining but still ≥ m: **COOPERATE with caution**

3. **Recovery Mechanism**
   - If last round failed threshold AND I defected: **COOPERATE** (help rebuild)
   - If last 2 rounds failed threshold: Apply "staged recovery"

### Round r (Final): Conditional Cooperation
- If previous round had ≥ m cooperators: **COOPERATE**
- If cooperation trend is positive: **COOPERATE**
- Otherwise: **DEFECT** (no future rounds to rebuild)

## Pseudocode

```
function decide_action(round, history):
    if round == 1:
        return COOPERATE
    
    prev_cooperators = count_cooperators(history[round-1])
    my_prev_action = history[round-1].my_action
    
    if round == r:  // Final round
        if prev_cooperators >= m:
            return COOPERATE
        if cooperation_trend_positive(history):
            return COOPERATE
        return DEFECT
    
    // Middle rounds (2 to r-1)
    if prev_cooperators >= m:
        return COOPERATE  // Successful cooperation
    
    // Threshold not met - recovery logic
    if my_prev_action == DEFECT:
        return COOPERATE  // Help rebuild
    
    // I cooperated but threshold failed
    failed_rounds = count_consecutive_failures(history)
    
    if failed_rounds == 1:
        return COOPERATE  // Give one more chance
    
    if failed_rounds == 2:
        // Staged recovery: cooperate if others show willingness
        if prev_cooperators >= m-2:
            return COOPERATE
        return DEFECT
    
    if failed_rounds >= 3:
        // Crisis mode: only cooperate if very close to threshold
        if prev_cooperators >= m-1:
            return COOPERATE
        return DEFECT

function cooperation_trend_positive(history):
    if len(history) < 3:
        return False
    last_three = history[-3:]
    cooperators = [count_cooperators(round) for round in last_three]
    return cooperators[2] > cooperators[0]
```

## Key Features

### 1. **Optimistic Initialization**
- Always start cooperatively to signal good intentions
- Gives the group the best chance for early success

### 2. **Threshold-Aware Adaptation**
- Recognizes when cooperation is working (≥ m cooperators)
- Maintains cooperation when collective action is successful

### 3. **Recovery Mechanisms**
- If I contributed to threshold failure by defecting, immediately return to cooperation
- Uses "staged recovery" - gradually more selective cooperation after repeated failures
- Still willing to cooperate if others show renewed commitment

### 4. **End-Game Handling**
- Final round considers both recent success and overall trends
- Defects only if cooperation seems truly hopeless

### 5. **Resilience Features**
- Doesn't abandon cooperation after single failures
- Distinguishes between temporary setbacks and systemic breakdown
- Always ready to rebuild when others show willingness

## Edge Case Handling

- **All others always defect**: Eventually switches to defection but keeps trying periodically
- **Borderline threshold situations**: Biased toward cooperation to help reach threshold
- **Erratic group behavior**: Focuses on recent trends rather than distant history
- **Late-game collapse**: Maintains cooperation if there's hope for recovery

This strategy maximizes collective welfare while being robust against various opponent behaviors, making it ideal for a tournament setting with diverse strategies.
'''

description_COOPERATIVE_20 = '''
# Cooperative Strategy: "Threshold-Aware Cooperative Leader"

## Core Philosophy
This strategy is designed to maximize collective welfare while being resilient to defection. It assumes other cooperative strategies will also try to ensure the threshold is met, and focuses on being a reliable contributor while encouraging cooperation through example.

## Decision Rules

### 1. Opening Strategy (First Round)
**Always Cooperate** - Start by demonstrating commitment to cooperation and signal trustworthiness to other players.

### 2. Main Strategy (Rounds 2 to r-1)
Use a **Conditional Cooperation with Leadership** approach:

```pseudocode
if (round == 1):
    return COOPERATE
    
if (round == r):  // Last round
    return handle_final_round()
    
// Main rounds (2 to r-1)
cooperators_last_round = count_cooperators(previous_round)
total_cooperators_history = count_total_cooperators(all_previous_rounds)
avg_cooperation_rate = total_cooperators_history / ((round-1) * n)

if (cooperators_last_round >= m):
    // Threshold was met - reward cooperation
    if (avg_cooperation_rate >= 0.6):
        return COOPERATE  // High cooperation environment
    else:
        return COOPERATE  // Still cooperate to maintain threshold
        
else:  // Threshold was NOT met
    if (cooperators_last_round >= m-2):
        // Close to threshold - be a leader
        return COOPERATE
    else if (avg_cooperation_rate >= 0.4):
        // Some hope for cooperation - try to encourage
        return COOPERATE
    else:
        // Low cooperation environment, but still try to lead
        if (round <= r/2):
            return COOPERATE  // Early game - keep trying
        else:
            // Late game - make strategic decision
            if (cooperators_last_round >= m/2):
                return COOPERATE
            else:
                return COOPERATE  // Maintain cooperative stance
```

### 3. Final Round Strategy
```pseudocode
handle_final_round():
    cooperators_last_round = count_cooperators(previous_round)
    
    if (cooperators_last_round >= m):
        // Successful cooperation - reward final cooperation
        return COOPERATE
    else:
        // Try one last time to meet threshold
        if (cooperators_last_round >= m-2):
            return COOPERATE  // Close enough to try
        else:
            return COOPERATE  // Maintain cooperative reputation
```

## Key Features

### 1. **Threshold Awareness**
- Always considers how close the group is to meeting the minimum threshold (m)
- Increases cooperation probability when close to threshold

### 2. **Historical Learning**
- Tracks cooperation rates over time
- Adapts behavior based on the group's cooperation trajectory
- Maintains optimism about cooperation potential

### 3. **Leadership Commitment**
- Willing to cooperate even when others might defect
- Acts as a "cooperation anchor" to encourage others
- Particularly important when close to threshold

### 4. **Consistent Signaling**
- Starts cooperative and maintains cooperative stance
- Sends clear signals about commitment to group welfare
- Builds reputation as a reliable cooperator

## Edge Case Handling

### First Round
- **Always cooperate** to establish cooperative reputation and encourage reciprocity

### Last Round
- **Generally cooperate** to maintain consistency and reward previous cooperation
- Only exception would be in extremely low-cooperation environments, but even then lean toward cooperation

### Near-Threshold Situations
- **Increase cooperation** when exactly at m-1 or m-2 cooperators
- Act as the "swing vote" to ensure threshold is met

### Low Cooperation Environments
- **Persist with cooperation longer** than purely rational strategies
- Try to model good behavior and encourage others to join

## Rationale

This strategy is designed to:

1. **Maximize group welfare** by consistently working toward threshold achievement
2. **Signal reliability** to encourage reciprocal cooperation from others
3. **Handle uncertainty** about opponent strategies by maintaining cooperative stance
4. **Adapt to group dynamics** while staying fundamentally cooperative
5. **Lead by example** in situations where cooperation is needed but risky

The strategy accepts that it may sometimes be exploited by defectors, but prioritizes the collective good and assumes that in a tournament of cooperative strategies, this approach will foster the kind of environment where cooperation flourishes and everyone benefits from the risk-averted rewards.
'''

description_COOPERATIVE_21 = '''
# Cooperative Strategy: "Adaptive Threshold Guardian"

## Core Philosophy
This strategy prioritizes collective welfare while maintaining strategic awareness. It operates on the principle of being a "threshold guardian" - actively working to ensure the cooperation threshold is met while adapting to observed opponent behavior.

## Decision Rules

### Primary Decision Logic:
```
IF round == 1:
    COOPERATE  // Start cooperatively to signal good intentions

ELSE IF round == final_round:
    IF predicted_cooperators >= m:
        COOPERATE  // Ensure threshold is met
    ELSE:
        COOPERATE  // Stay true to cooperative nature even if threshold fails

ELSE:  // Middle rounds
    cooperation_rate = count_cooperators_last_round / n
    
    IF cooperation_rate >= (m/n + 0.1):  // Threshold likely to be met with buffer
        COOPERATE  // Support the collective good
    
    ELSE IF cooperation_rate >= (m-1)/n:  // Close to threshold
        COOPERATE  // Be the guardian who ensures threshold is met
    
    ELSE IF cooperation_rate < 0.3:  // Very low cooperation
        IF round <= r/3:  // Early game - try to encourage cooperation
            COOPERATE
        ELSE:  // Later game - adapt but maintain some cooperation
            COOPERATE with probability 0.7
    
    ELSE:  // Moderate cooperation levels
        COOPERATE
```

### Adaptive Components:

1. **Trend Analysis**: Track cooperation trends over the last 3 rounds
   - If cooperation is increasing: Maintain cooperation
   - If cooperation is declining but still above threshold: Increase cooperation probability
   - If cooperation is collapsing: Still cooperate 60% of the time to model good behavior

2. **Threshold Proximity Monitoring**:
   ```
   predicted_cooperators = estimate_cooperators_next_round()
   deficit = max(0, m - predicted_cooperators)
   
   IF deficit <= 1:
       COOPERATE  // Critical to meet threshold
   ```

## Edge Case Handling

### First Round:
- **Always COOPERATE** to establish cooperative intentions and signal to other cooperative strategies

### Final Round:
- **Always COOPERATE** to maintain consistency with cooperative principles, regardless of predicted outcome

### Early Rounds (rounds 2 to r/3):
- Maintain high cooperation (90%+ rate) to encourage cooperative norms
- Only defect if cooperation rate drops below 20% for 2 consecutive rounds

### Late Rounds (final r/3):
- Focus intensely on threshold achievement
- Increase cooperation probability when close to threshold minimum

## Cooperative Alignment Features

1. **Threshold Commitment**: Prioritize meeting the cooperation threshold over individual gain
2. **Positive Signaling**: Start and end cooperatively to model desired behavior
3. **Forgiveness**: Don't permanently punish defectors; give second chances
4. **Collective Focus**: Make decisions based on group welfare, not just individual optimization
5. **Consistency**: Maintain cooperative behavior even when others don't reciprocate

## Pseudocode Summary:
```python
def decide_action(round_num, history, n, m, k, r):
    if round_num == 1:
        return COOPERATE
    
    if round_num == r:  # Final round
        return COOPERATE
    
    last_round_cooperators = count_cooperators(history[-1])
    cooperation_rate = last_round_cooperators / n
    
    # Calculate cooperation probability based on situation
    if cooperation_rate >= (m/n + 0.1):
        coop_prob = 1.0
    elif cooperation_rate >= (m-1)/n:
        coop_prob = 1.0  # Be the guardian
    elif cooperation_rate < 0.3:
        if round_num <= r/3:
            coop_prob = 1.0
        else:
            coop_prob = 0.7
    else:
        coop_prob = 0.95
    
    return COOPERATE if random() < coop_prob else DEFECT
```

This strategy balances cooperative ideals with strategic awareness, always working toward collective success while adapting to the behavioral patterns of other players.
'''

description_COOPERATIVE_22 = '''
# Cooperative Strategy: "Adaptive Threshold Guardian"

## Core Philosophy
This strategy prioritizes collective welfare while being resilient to defection attempts. It aims to sustain cooperation by being generous in establishing trust, forgiving toward mistakes, but firm against persistent exploitation.

## Strategy Description

### Decision Rules

**Round 1 (Initialization):**
- Always COOPERATE to signal cooperative intent and help establish a cooperative norm

**Rounds 2 to r-1 (Main Game):**
- COOPERATE if any of these conditions are met:
  1. **Threshold Achievement**: In the previous round, m or more players cooperated
  2. **Near-Miss Forgiveness**: In the previous round, exactly (m-1) players cooperated (one short of threshold)
  3. **Recovery Attempt**: Previous round failed threshold, but the round before that succeeded

- DEFECT only if:
  - Previous round had fewer than (m-1) cooperators AND
  - The round before that also failed the threshold

**Round r (Final Round):**
- COOPERATE if the previous round achieved threshold (m or more cooperators)
- DEFECT if the previous round had fewer than (m-1) cooperators
- COOPERATE if exactly (m-1) cooperators in previous round (give benefit of doubt)

### Pseudocode

```python
def decide_action(round_num, cooperation_history, total_rounds, m):
    if round_num == 1:
        return COOPERATE
    
    prev_cooperators = count_cooperators(cooperation_history[round_num-2])
    
    if round_num == total_rounds:  # Final round
        if prev_cooperators >= m:
            return COOPERATE
        elif prev_cooperators == m-1:
            return COOPERATE  # Benefit of doubt
        else:
            return DEFECT
    
    # Main game rounds (2 to r-1)
    # Cooperate if threshold was met
    if prev_cooperators >= m:
        return COOPERATE
    
    # Cooperate if near-miss (forgiveness)
    if prev_cooperators == m-1:
        return COOPERATE
    
    # Cooperate if attempting recovery after previous success
    if round_num >= 3:
        two_rounds_ago = count_cooperators(cooperation_history[round_num-3])
        if two_rounds_ago >= m and prev_cooperators < m-1:
            return COOPERATE
    
    # Otherwise defect (persistent low cooperation)
    return DEFECT
```

## Strategic Rationale

### Cooperative Alignment
1. **Initial Trust**: Starting with cooperation signals good intent and helps establish cooperative equilibrium
2. **Threshold Support**: Maintains cooperation when the group is performing well (achieving threshold)
3. **Generous Forgiveness**: Gives second chances when cooperation nearly succeeds (m-1 cooperators)
4. **Recovery Assistance**: Helps restart cooperation after temporary failures

### Edge Case Handling
1. **First Round**: Always cooperate to establish cooperative norm
2. **Final Round**: Slightly more cautious but still cooperative when reasonable
3. **Early Rounds**: Uses available history but doesn't over-penalize lack of data

### Robustness Features
1. **Anti-Exploitation**: Defects when cooperation consistently fails (fewer than m-1 cooperators repeatedly)
2. **Quick Recovery**: Returns to cooperation once others show willingness to contribute
3. **Threshold Awareness**: Specifically designed around the m-threshold structure

## Expected Behavior

This strategy should:
- Establish early cooperation in groups of similarly cooperative strategies
- Maintain stable cooperation when the group achieves thresholds
- Show resilience against occasional defection without abandoning cooperation entirely
- Protect against consistent free-riders while remaining open to renewed cooperation
- Maximize collective payoffs in environments with other cooperative strategies

The strategy balances being "nice" (starts cooperating, forgives mistakes) with being "firm" (punishes persistent defection) while remaining "forgiving" (quick to return to cooperation when others show good faith).
'''

description_COOPERATIVE_23 = '''
# Cooperative Strategy: "Optimistic Threshold Guardian"

## Core Philosophy
This strategy is built on the principle of **collective responsibility** - I aim to ensure the threshold is met while encouraging others to cooperate through consistent, predictable behavior that demonstrates the value of mutual cooperation.

## Decision Rules

### Primary Rule: Conditional Cooperation with Safety Margin
```pseudocode
def decide_action(round_num, history):
    if round_num == 1:
        return COOPERATE  // Start cooperatively
    
    // Count cooperators in previous round
    prev_cooperators = count_cooperators(history[round_num-1])
    
    // If threshold was met last round, continue cooperating
    if prev_cooperators >= m:
        return COOPERATE
    
    // If threshold barely failed (within 1-2 of threshold), cooperate
    if prev_cooperators >= (m - 2):
        return COOPERATE
    
    // If cooperation is collapsing but recoverable, try to revive it
    if prev_cooperators >= max(1, m/2):
        return COOPERATE
    
    // Only defect if cooperation seems completely hopeless
    return DEFECT
```

### Specific Edge Cases

**First Round:**
- Always COOPERATE to signal cooperative intent and establish a positive precedent

**Last Round:**
- COOPERATE if any of the previous rounds showed ≥(m-1) cooperators
- This prevents end-game defection cascade while maintaining cooperative stance

**Early Rounds (rounds 2-3):**
- Maintain cooperation unless previous round had ≤1 cooperators
- Give the group time to coordinate and learn

**Late Rounds (final 25% of game):**
- Be slightly more forgiving of occasional threshold failures
- Focus on pattern recognition rather than single-round failures

## Key Features

### 1. Optimistic Start
Begin with cooperation to signal good intentions and create positive momentum. This helps establish a cooperative equilibrium from the beginning.

### 2. Threshold-Aware Forgiveness
Rather than punishing any single failure to meet the threshold, I focus on whether we're "close enough" to success. This prevents punishment spirals when the group is genuinely trying to cooperate.

### 3. Recovery-Oriented
When cooperation starts failing, I continue cooperating as long as there's reasonable hope for recovery (at least half the needed cooperators are still trying).

### 4. Pattern Recognition
I look for sustained patterns rather than reacting to single rounds, which helps maintain stability against occasional mistakes or experimentation by other players.

### 5. End-Game Stability
Instead of defecting in the final round (which could trigger others to defect earlier), I maintain cooperation if there's been any recent evidence of successful coordination.

## Strategic Rationale

This strategy is designed to:
- **Encourage reciprocity**: Consistent cooperation signals that mutual benefit is possible
- **Prevent cascade failures**: By not immediately punishing threshold failures, I avoid triggering others to abandon cooperation
- **Maintain group welfare**: Even when some players defect, maintaining cooperation helps those who are trying to cooperate
- **Build trust**: Predictable, forgiving behavior encourages others to take the "risk" of cooperating

The strategy accepts that I may occasionally be exploited, but prioritizes the higher payoffs available when the group successfully coordinates on mutual cooperation.
'''

description_COOPERATIVE_24 = '''
# Cooperative Strategy: "Trust-Building Collective Guardian"

## Core Philosophy
This strategy prioritizes collective welfare while being resilient to exploitation. It assumes other cooperative strategies exist in the tournament and focuses on identifying and sustaining cooperation with them.

## Decision Rules

### Round 1: Cooperative Signal
**Always cooperate** in the first round to:
- Signal cooperative intent to other cooperative strategies
- Establish a foundation for mutual cooperation
- Demonstrate commitment to collective welfare

### Rounds 2 to r-1: Adaptive Cooperation with Threshold Monitoring

**Primary Decision Logic:**
```pseudocode
if (previous_round_cooperators >= m):
    cooperate  // Maintain successful cooperation
else:
    if (my_cooperation_rate > 0.6 AND others_seem_cooperative):
        cooperate  // Give benefit of doubt to build cooperation
    else:
        defect    // Protect against systematic exploitation
```

**Cooperation Assessment:**
- Track each player's cooperation rate over all previous rounds
- Consider a player "cooperative" if their rate ≥ 0.5
- Count total "cooperative players" in the game

**Detailed Rules:**
1. **If threshold was met last round:** Always cooperate (reward success)
2. **If threshold narrowly missed (cooperators = m-1):** 
   - Cooperate if I defected last round (try to bridge the gap)
   - Cooperate if majority of players seem cooperative (>50% cooperation rate)
3. **If threshold badly missed (cooperators < m-1):**
   - Cooperate only if my cooperation rate > 0.7 AND at least 40% of other players appear cooperative
   - Otherwise defect to avoid exploitation

### Final Round (Round r): Strategic Endgame
**Cooperate if and only if:**
- At least m-1 other players have cooperation rates ≥ 0.6, OR
- The threshold was met in at least 60% of previous rounds

This prevents last-round defection cascades while maintaining cooperation with genuinely cooperative players.

## Edge Case Handling

### Small Group Dynamics (n ≤ 4):
- Be more forgiving of occasional defection
- Cooperate if any player maintains >40% cooperation rate

### High Threshold Games (m close to n):
- Increase tolerance for defection (cooperation threshold drops to 0.4)
- Focus on maintaining cooperation with the most cooperative players

### Low Reward Games (k ≤ 1.5):
- Require higher evidence of others' cooperation (≥60% rate) before continuing to cooperate
- More quickly switch to defection if threshold repeatedly missed

## Cooperative Alignment Features

1. **Default to Cooperation:** Starts cooperative and maintains bias toward cooperation
2. **Collective Benefit Focus:** Prioritizes achieving the threshold over individual gain
3. **Forgiveness Mechanism:** Allows for occasional defection without permanent punishment
4. **Trust Building:** Gives players multiple chances to demonstrate cooperation
5. **Anti-Exploitation Safeguards:** Protects against systematic free-riding without abandoning cooperation entirely

## Pseudocode Summary
```pseudocode
function decide_action(round, history):
    if round == 1:
        return COOPERATE
    
    cooperators_last_round = count_cooperators(history[-1])
    my_coop_rate = my_cooperation_rate(history)
    others_coop_rates = calculate_others_cooperation_rates(history)
    cooperative_players = count(others_coop_rates >= 0.5)
    
    if round == r:  // Final round
        return COOPERATE if (cooperative_players >= m-1 OR 
                           historical_success_rate >= 0.6)
    
    if cooperators_last_round >= m:
        return COOPERATE
    elif cooperators_last_round == m-1:
        return COOPERATE if (i_defected_last_round OR 
                           cooperative_players >= n/2)
    else:  // cooperators_last_round < m-1
        return COOPERATE if (my_coop_rate > 0.7 AND 
                           cooperative_players >= 0.4 * (n-1))
        else return DEFECT
```

This strategy balances cooperation with self-protection, aiming to build and maintain cooperative coalitions while avoiding systematic exploitation.
'''

description_COOPERATIVE_25 = '''
# Adaptive Threshold Cooperation Strategy

## Core Philosophy
This strategy aims to maximize collective welfare while protecting against exploitation by maintaining cooperation when it's beneficial and adapting to opponent behavior patterns.

## Strategy Description

### Primary Decision Rule: Threshold-Based Cooperation
- **Cooperate** when the expected number of other cooperators ≥ (m-1)
- **Defect** when the expected number of other cooperators < (m-1)

### Key Components

#### 1. Expectation Calculation
For each round t, estimate expected cooperators from others:
```
expected_others_coop = Σ(i≠self) P(player_i cooperates)
```

Where P(player_i cooperates) is based on:
- **First round**: Assume 70% cooperation probability for all others
- **Subsequent rounds**: Use exponentially weighted moving average of each player's cooperation rate:
  ```
  P_t(i) = α × recent_behavior_i + (1-α) × historical_avg_i
  ```
  With α = 0.4 (giving recent behavior moderate weight)

#### 2. Cooperation Incentive Mechanism
To encourage cooperation from others, add a "leadership bonus":
- If expected_others_coop is close to (m-1) (within 0.3), cooperate anyway to help reach threshold
- This creates positive momentum and signals commitment to cooperation

#### 3. Forgiveness Protocol
- Track each player's "cooperation deficit" (times they defected when cooperation would have helped)
- Forgive occasional defections if a player generally cooperates (cooperation rate > 60%)
- This prevents punishment spirals while maintaining accountability

### Detailed Decision Algorithm

```pseudocode
STRATEGY: AdaptiveThresholdCooperation

INITIALIZE:
    cooperation_history = {} // Track each player's actions
    cooperation_probs = {} // Estimated cooperation probability per player
    
FOR round t = 1 to r:
    
    IF t == 1:
        // First round: Optimistic cooperation
        FOR each other player j:
            cooperation_probs[j] = 0.7
    ELSE:
        // Update cooperation probabilities based on history
        FOR each other player j:
            recent_rate = cooperation_rate(j, last_3_rounds)
            historical_rate = overall_cooperation_rate(j)
            cooperation_probs[j] = 0.4 * recent_rate + 0.6 * historical_rate
    
    // Calculate expected cooperators from others
    expected_others_coop = SUM(cooperation_probs[j] for j ≠ self)
    
    // Apply leadership bonus for near-threshold situations
    threshold = m - 1
    IF expected_others_coop >= threshold - 0.3:
        leadership_bonus = True
    ELSE:
        leadership_bonus = False
    
    // Make decision
    IF expected_others_coop >= threshold OR leadership_bonus:
        action = COOPERATE
    ELSE:
        action = DEFECT
    
    // Special case: Last round consideration
    IF t == r:
        // Slightly increase cooperation threshold in final round
        // to account for others potentially defecting
        IF expected_others_coop >= threshold + 0.2:
            action = COOPERATE
        ELSE:
            action = DEFECT
    
    PLAY action
    OBSERVE all_actions
    UPDATE cooperation_history with all_actions
```

### Edge Case Handling

#### First Round
- Start optimistically with 70% cooperation assumption for all players
- This encourages initial cooperation and tests waters

#### Last Round
- Increase cooperation threshold slightly (+0.2) to account for potential end-game defection
- Still cooperate if confident threshold will be met

#### Early Rounds (t ≤ 3)
- Weight initial assumption more heavily since limited history
- Gradually shift to data-driven estimates

#### Tie-Breaking
- When expected_others_coop exactly equals threshold, cooperate (err on cooperative side)

## Cooperative Alignment

This strategy embodies cooperation through:

1. **Proactive Leadership**: Willing to cooperate even in marginal situations to help achieve collective benefit
2. **Forgiveness**: Doesn't permanently punish players for occasional defections
3. **Optimistic Start**: Begins with cooperative assumptions about others
4. **Threshold Focus**: Aims to achieve the minimum needed for collective success rather than maximizing individual payoff
5. **Adaptive Learning**: Responds to others' cooperation patterns to maintain viable cooperation

The strategy balances genuine cooperation with rational self-protection, making it robust against various opponent types while maintaining a fundamentally cooperative orientation.
'''

description_COOPERATIVE_26 = '''
# Cooperative Strategy: "Adaptive Threshold Guardian"

## Core Philosophy
This strategy prioritizes collective welfare while maintaining resilience against exploitation. It aims to ensure the cooperation threshold is met consistently while encouraging others to join the cooperative effort.

## Decision Rules

### Round 1: Always Cooperate
- **Action**: C (Cooperate)
- **Rationale**: Establish cooperative intent and contribute to building trust from the start

### Rounds 2 to r-1: Adaptive Cooperation
**Step 1: Calculate Cooperation Need**
- Let `coop_last` = number of cooperators in previous round
- Let `need` = max(0, m - coop_last)

**Step 2: Apply Decision Logic**
```pseudocode
if coop_last >= m:
    // Threshold was met - encourage sustained cooperation
    if my_last_action == C:
        cooperate() // Continue cooperating to maintain momentum
    else:
        cooperate() // Join the cooperative group
    
else if need <= 2:
    // Close to threshold - be generous to help reach it
    cooperate()
    
else if need <= n/2:
    // Moderate deficit - cooperate with high probability
    cooperate_probability = 0.8
    
else:
    // Large deficit suggests widespread defection
    // Still cooperate but with lower probability
    cooperate_probability = 0.4
```

### Final Round (r): Conditional Cooperation
```pseudocode
recent_cooperation = average_cooperation_rate(last_3_rounds)

if recent_cooperation >= (m/n):
    // Group has shown commitment to threshold
    cooperate()
else:
    // Group cooperation has been insufficient
    // Make final attempt to reach threshold
    cooperate()
```

## Key Features

### 1. Threshold-Focused
- Always considers how many cooperators are needed to reach threshold `m`
- Adjusts cooperation probability based on group's distance from threshold

### 2. Generous Forgiveness
- Doesn't punish individual defectors harshly
- Focuses on collective outcome rather than individual behavior
- Returns to cooperation quickly after threshold failures

### 3. Momentum Building
- When threshold is met, maintains high cooperation to sustain positive outcomes
- Recognizes that consistent threshold achievement builds trust

### 4. Adaptive Probabilities
- Uses probabilistic cooperation when deficit is large to avoid being completely exploited
- Still maintains cooperative bias even in adverse conditions

## Edge Case Handling

**First Round**: Always cooperate to signal cooperative intent

**Last Round**: Maintain cooperation if group has shown recent commitment to threshold

**All Rounds Failed**: Continue cooperating with reduced but non-zero probability to allow for group recovery

**Perfect Cooperation**: Continue cooperating to maintain optimal outcomes

## Cooperative Alignment

This strategy embodies cooperation by:
- **Prioritizing collective benefit**: Always considers what's needed for group success
- **Showing leadership**: Cooperates even when others might not
- **Building trust**: Maintains high cooperation rates to encourage others
- **Being forgiving**: Doesn't engage in harsh punishment cycles
- **Focusing on outcomes**: Cares more about achieving threshold than individual payoff maximization

The strategy recognizes that in a collective risk dilemma, the cooperative approach is to ensure the group consistently meets the threshold `m`, creating sustained mutual benefit for all players.
'''

description_COOPERATIVE_27 = '''
# Cooperative Strategy: "Adaptive Threshold Guardian"

## Core Philosophy
This strategy prioritizes achieving the collective threshold while maintaining cooperative intent, using adaptive learning to optimize cooperation based on observed opponent behavior patterns.

## Decision Rules

### Round 1: Cooperative Opening
- **Always cooperate** in the first round to signal cooperative intent and gather initial information about opponent tendencies.

### Rounds 2 to r-1: Adaptive Cooperation
Use a three-phase decision process:

#### Phase 1: Threshold Analysis
Calculate the cooperation deficit:
```
cooperation_needed = max(0, m - predicted_cooperators_this_round)
```

#### Phase 2: Behavioral Learning
Track each opponent's cooperation pattern:
- **Cooperation rate**: `coop_rate[j] = cooperations_by_j / rounds_played`
- **Recent trend**: Weight last 3 rounds more heavily (factor of 2x)
- **Reciprocity score**: How often opponent j cooperates after I cooperate

#### Phase 3: Decision Logic
```pseudocode
if round_number <= r/3:
    // Early game: Build trust and establish cooperation
    cooperate()
    
else if predicted_cooperators >= m:
    // Threshold likely to be met
    if my_recent_cooperation_rate > 0.7:
        // I've been contributing heavily, occasionally defect for efficiency
        cooperate() with probability 0.8
    else:
        cooperate()
        
else:
    // Threshold at risk
    if predicted_cooperators + 1 >= m:
        // My cooperation could make the difference
        cooperate()
    else if predicted_cooperators >= m * 0.7:
        // Close to threshold, cooperate to help push over
        cooperate()
    else:
        // Too few cooperators, but still try to build momentum
        cooperate() with probability 0.6
```

### Final Round (Round r): Conditional Cooperation
```pseudocode
if predicted_cooperators_without_me >= m:
    // Threshold will be met regardless
    if opponents_have_been_mostly_cooperative:
        cooperate()  // Reward their cooperation
    else:
        defect()     // Optimize personal payoff
        
else if predicted_cooperators_without_me + 1 >= m:
    // My cooperation is decisive
    cooperate()
    
else:
    // Threshold unlikely to be met
    if predicted_cooperators_without_me >= m * 0.8:
        cooperate()  // Still try to help
    else:
        defect()     // Cut losses
```

## Prediction Mechanism
Estimate cooperators for current round:
```pseudocode
for each opponent j:
    base_prob = coop_rate[j]
    
    // Adjust for recent trends
    if recent_trend[j] == "increasing":
        base_prob *= 1.2
    else if recent_trend[j] == "decreasing":
        base_prob *= 0.8
    
    // Adjust for reciprocity
    if I_cooperated_last_round:
        base_prob += reciprocity_score[j] * 0.3
    
    expected_cooperators += min(1.0, base_prob)
```

## Edge Case Handling

### Two-Player Games (n=2, m=2)
- Always cooperate except final round
- In final round: cooperate only if opponent has cooperation rate > 0.8

### High Threshold Games (m close to n)
- Increase cooperation probability by 20% across all phases
- Be more forgiving of defections (they might be strategic)

### Low Threshold Games (m ≤ n/3)
- Allow more strategic defection when threshold is safely exceeded
- Focus on rewarding consistent cooperators

## Cooperative Elements

1. **Default to Cooperation**: Base assumption is to cooperate unless analysis suggests otherwise
2. **Threshold Prioritization**: Always cooperate when threshold is at risk
3. **Trust Building**: High cooperation in early rounds to establish norms
4. **Reciprocity**: Reward cooperative opponents with continued cooperation
5. **Collective Benefit**: Accept lower individual payoffs to maintain group benefits

## Robustness Features

- **Anti-Exploitation**: Reduces cooperation against consistent defectors while maintaining group focus
- **Momentum Building**: Maintains cooperation even when threshold seems unlikely to encourage others
- **Endgame Optimization**: Balances individual and collective interests in final rounds

This strategy maintains a cooperative foundation while adapting to opponent behavior, ensuring both individual viability and contribution to collective success.
'''

description_COOPERATIVE_28 = '''
# Cooperative Strategy: "Adaptive Threshold Guardian"

## Core Philosophy
This strategy prioritizes collective welfare while being resilient to exploitation. It operates on the principle of maintaining just enough cooperation to secure the collective benefit, while adapting to observed opponent behavior patterns.

## Decision Rules

### Round 1: Optimistic Start
- **Always COOPERATE** in the first round
- Rationale: Signal cooperative intent and establish trust

### Rounds 2 to r-1: Adaptive Cooperation
Use a three-tier decision system:

1. **Cooperation Count Analysis**
   - Count cooperators in previous round: `coop_count`
   - If `coop_count >= m`: The threshold was met
   - If `coop_count < m`: The threshold was missed

2. **Safety Margin Calculation**
   - Calculate needed cooperators: `needed = m - (predicted_cooperators)`
   - If my cooperation is needed for threshold: `am_i_needed = (predicted_cooperators < m)`

3. **Decision Logic**:
   ```pseudocode
   if coop_count_last_round >= m + 1:
       # Surplus cooperation - can afford to defect occasionally
       if my_defections_while_safe < max_allowed_defections:
           return DEFECT
       else:
           return COOPERATE
   
   elif coop_count_last_round == m:
       # Barely met threshold - maintain cooperation
       return COOPERATE
       
   elif coop_count_last_round == m - 1:
       # Critical shortage - definitely cooperate
       return COOPERATE
       
   else:  # coop_count < m - 1
       # Major failure - attempt to rebuild trust
       if consecutive_failures < 3:
           return COOPERATE  # Try to restart cooperation
       else:
           # Pattern of consistent failure - minimize losses
           return DEFECT
   ```

### Final Round (Round r): Conditional Cooperation
- If cooperation has been generally successful (threshold met >50% of time): **COOPERATE**
- If cooperation has mostly failed: **DEFECT**
- If uncertain: **COOPERATE** (maintain cooperative reputation)

## Adaptive Elements

### Learning Component
Track these metrics across rounds:
- `success_rate`: Percentage of rounds where threshold was met
- `my_necessity_rate`: How often my cooperation was pivotal
- `cooperation_trend`: Whether cooperation is increasing/decreasing

### Dynamic Thresholds
```pseudocode
max_allowed_defections = max(1, floor((r - 2) * 0.2))  # Allow 20% strategic defections
rebuild_threshold = 3  # Rounds of failure before switching to defensive mode
```

## Edge Case Handling

### High Threshold Scenarios (m close to n)
- Be more conservative - cooperate more frequently
- Reduce strategic defections to near zero

### Low Threshold Scenarios (m = 2 or 3)
- More room for strategic defection when surplus exists
- Focus on maintaining minimum viable cooperation

### Short Games (r ≤ 5)
- Cooperate more consistently due to limited learning time
- Reduce adaptive behavior, err on side of cooperation

### Detection of Mass Defection
If cooperation drops below 30% for 2+ consecutive rounds:
- Switch to "Trust Rebuilding" mode
- Cooperate for next 2 rounds regardless of outcome
- Then reassess based on response

## Pseudocode Summary

```pseudocode
function decide_action(round, history):
    if round == 1:
        return COOPERATE
    
    if round == total_rounds:
        return final_round_decision(history)
    
    coop_count = count_cooperators_last_round(history)
    success_rate = calculate_success_rate(history)
    
    if coop_count >= m + 1:
        # Safe to occasionally defect
        if can_defect_safely():
            return DEFECT
        else:
            return COOPERATE
            
    elif coop_count >= m - 1:
        # Critical cooperation needed
        return COOPERATE
        
    else:
        # Failure mode - attempt recovery
        if should_attempt_rebuild(history):
            return COOPERATE
        else:
            return DEFECT
```

## Why This Strategy is Cooperative

1. **Default to Cooperation**: Always starts cooperatively and returns to cooperation after failures
2. **Threshold Protection**: Prioritizes ensuring the collective benefit is achieved
3. **Trust Building**: Attempts to rebuild cooperation even after failures
4. **Minimal Exploitation**: Only defects when there's clear surplus, never undermines the threshold
5. **Long-term Focused**: Values sustained cooperation over short-term gains

This strategy balances the cooperative goal of achieving collective benefits with the practical need to adapt to varying opponent behaviors, making it robust for tournament play against diverse strategies.
'''

description_COOPERATIVE_29 = '''
# Cooperative Strategy: "Adaptive Threshold Guardian"

## Core Philosophy
This strategy prioritizes collective welfare while being resilient to exploitation. It aims to maintain cooperation when possible, encourage defectors to join cooperative efforts, and protect against catastrophic failure when cooperation breaks down.

## Decision Rules

### Round 1: Initial Cooperation Signal
```
Action: COOPERATE
Rationale: Signal cooperative intent and willingness to contribute to collective good
```

### Rounds 2 to r-1: Adaptive Threshold Monitoring
```
cooperators_last_round = count_cooperators(previous_round)
defectors_last_round = n - cooperators_last_round

if cooperators_last_round >= m:
    # Threshold was met - reinforce cooperation
    Action: COOPERATE
    
elif cooperators_last_round == m - 1:
    # Critical threshold - one more cooperator needed
    Action: COOPERATE  # Be the decisive cooperator
    
elif cooperators_last_round >= max(2, m - 2):
    # Close to threshold - encourage others
    Action: COOPERATE
    
else:
    # Far from threshold - strategic defection with recovery mechanism
    rounds_remaining = r - current_round
    if rounds_remaining >= 3:
        Action: DEFECT  # Signal that cooperation must improve
    else:
        Action: COOPERATE  # Last chance cooperation attempt
```

### Final Round: Cooperative Commitment
```
Action: COOPERATE
Rationale: Maintain cooperative reputation and maximize final collective outcome
```

## Key Strategic Elements

### 1. **Threshold Guardianship**
- Always cooperate when we're the pivotal player (m-1 cooperators present)
- Recognize that being the "decisive cooperator" maximizes both individual and collective payoffs

### 2. **Graduated Response to Free-Riding**
- Tolerate some defection when threshold is comfortably met
- Become more demanding as cooperation approaches critical levels
- Use strategic defection as a "wake-up call" when cooperation is dangerously low

### 3. **Endgame Commitment**
- Final round cooperation signals long-term cooperative intent
- Avoids the typical "last round defection" that undermines trust

### 4. **Recovery Mechanism**
```
if (current_round > 1 AND cooperators_last_round < m - 2 AND rounds_remaining >= 3):
    # Cooperation has collapsed - attempt to restart
    if (rounds_remaining % 2 == 1):
        Action: COOPERATE  # Alternate cooperation to signal restart opportunity
    else:
        Action: DEFECT
```

## Edge Case Handling

### **Very Small Groups (n ≤ 4)**
- Be more forgiving of single defectors
- Cooperate unless cooperation rate < 50%

### **High Threshold Games (m > n/2)**
- Cooperate more persistently since threshold is naturally difficult
- Only defect if cooperation rate < m/n - 0.2

### **Long Games (r > 10)**
- Allow for 2-3 "teaching" defections in middle rounds when cooperation is poor
- Reserve final 20% of rounds for sustained cooperation attempts

## Rationale

This strategy balances several cooperative principles:

1. **Collective Responsibility**: Takes personal responsibility for meeting thresholds when close
2. **Educational Defection**: Uses limited defection to teach importance of cooperation
3. **Forgiveness**: Readily returns to cooperation after others improve
4. **Commitment**: Strong cooperation in critical moments (first/last rounds, threshold situations)

The strategy is designed to work well with other cooperative strategies while being robust against moderate exploitation. It recognizes that pure cooperation can be exploited, but maintains a fundamentally cooperative orientation by prioritizing collective welfare and using defection only as a strategic tool to promote better cooperation from others.
'''

description_COOPERATIVE_30 = '''
# Cooperative Strategy: "Adaptive Community Builder"

## Core Philosophy
This strategy prioritizes collective welfare while maintaining resilience against exploitation. It operates on the principle that cooperation builds trust and shared prosperity, but requires adaptive mechanisms to handle defection.

## Decision Rules

### Round 1: Optimistic Start
- **Action: COOPERATE**
- **Rationale:** Signal cooperative intent and trust in others' rationality

### Rounds 2 to r-1: Adaptive Cooperation
Use a three-tier decision system:

1. **Cooperation Momentum Assessment**
   - Count cooperators in previous round: `coop_count`
   - If `coop_count >= m`: Strong cooperation signal → **COOPERATE**
   - If `coop_count >= m-1`: Near-threshold → **COOPERATE** (help reach threshold)
   - If `coop_count < m-1`: Assess further

2. **Trust Recovery Mechanism**
   - Track cooperation trend over last 3 rounds
   - If upward trend (increasing cooperation): **COOPERATE**
   - If stable at suboptimal level: Use "catalytic cooperation" (cooperate to potentially trigger others)

3. **Defection Protection**
   - If cooperation has failed in 2+ consecutive rounds AND trend is downward: **DEFECT**
   - Exception: If exactly `m-1` others cooperated last round, **COOPERATE** anyway (be the crucial cooperator)

### Final Round: Conditional Cooperation
- If cooperation succeeded in round r-1: **COOPERATE** (maintain positive momentum)
- If cooperation has been consistently failing (< m cooperators in last 2 rounds): **DEFECT**

## Pseudocode

```
function decide_action(round_number, history):
    if round_number == 1:
        return COOPERATE
    
    last_round_cooperators = count_cooperators(history[-1])
    
    if round_number == total_rounds:
        # Final round logic
        if last_round_cooperators >= m:
            return COOPERATE
        elif cooperation_failing_recently(history):
            return DEFECT
        else:
            return COOPERATE
    
    # Main rounds (2 to r-1)
    if last_round_cooperators >= m:
        return COOPERATE
    
    if last_round_cooperators >= m-1:
        return COOPERATE  # Help reach threshold
    
    # Assess trend and trust
    trend = calculate_cooperation_trend(history[-3:])
    if trend > 0:  # Increasing cooperation
        return COOPERATE
    
    consecutive_failures = count_consecutive_failures(history)
    if consecutive_failures >= 2 and trend < 0:
        # Exception: be the crucial cooperator if close
        if last_round_cooperators == m-1:
            return COOPERATE
        return DEFECT
    
    # Default to cooperation for community building
    return COOPERATE

function cooperation_failing_recently(history):
    recent_rounds = history[-2:]
    return all(count_cooperators(round) < m for round in recent_rounds)
```

## Key Features

### 1. **Threshold Awareness**
- Recognizes that being the `m`-th cooperator is crucial
- Willing to cooperate when exactly `m-1` others did, even under adverse conditions

### 2. **Trend Sensitivity**
- Responds to improving cooperation patterns
- Adapts to deteriorating trust environments

### 3. **Forgiveness with Boundaries**
- Gives multiple chances for community recovery
- Protects against persistent exploitation

### 4. **Leadership by Example**
- Starts cooperatively to signal good intentions
- Uses "catalytic cooperation" to potentially trigger others

## Expected Outcomes

- **Against other cooperators:** Mutual cooperation leading to optimal outcomes
- **Against mixed strategies:** Attempts to build and maintain cooperative coalitions
- **Against exploiters:** Initially cooperative but adapts to protect against consistent defection
- **In uncertain environments:** Errs on the side of cooperation while maintaining self-preservation

This strategy balances the cooperative imperative with strategic awareness, aiming to build sustainable cooperative communities while avoiding exploitation.
'''

description_COOPERATIVE_31 = '''
# Cooperative Strategy: "Adaptive Trust Builder"

## Core Philosophy
This strategy is built on the principle that cooperation is most sustainable when we actively foster trust while maintaining resilience against exploitation. It balances optimistic cooperation with strategic adaptation based on community behavior.

## Decision Rules

### Round 1: Optimistic Start
- **Always COOPERATE** in the first round
- Rationale: Signal cooperative intent and give the community the best chance to establish a cooperative norm from the beginning

### Rounds 2 to r-1: Adaptive Cooperation
Use a three-factor decision system:

1. **Community Cooperation Rate (CCR)**: Track the percentage of players who cooperated in the previous round
2. **Cooperation Momentum**: Track whether cooperation is increasing, stable, or declining
3. **Threshold Proximity**: Consider how close we are to the minimum threshold m

**Decision Logic:**
```
IF (previous_round_cooperators >= m):
    # Threshold was met - reinforce success
    IF (CCR >= 0.6):
        COOPERATE  # Strong community cooperation
    ELIF (CCR >= 0.4):
        COOPERATE with 80% probability  # Moderate cooperation, mostly support
    ELSE:
        COOPERATE with 60% probability  # Weak but sufficient, cautious support
        
ELIF (previous_round_cooperators == m-1):
    # One short of threshold - critical cooperation needed
    COOPERATE  # Always help push over threshold
    
ELIF (previous_round_cooperators >= m-2):
    # Close to threshold - high cooperation incentive
    COOPERATE with 90% probability
    
ELSE:
    # Far from threshold - adaptive based on trend
    IF (cooperation_trend is increasing):
        COOPERATE with 70% probability  # Support positive momentum
    ELIF (cooperation_trend is stable AND CCR >= 0.3):
        COOPERATE with 50% probability  # Neutral with decent base
    ELSE:
        COOPERATE with 30% probability  # Low cooperation, but maintain some hope
```

### Final Round (Round r): Reciprocal Cooperation
- **COOPERATE if** the community met the threshold in at least 60% of previous rounds
- **DEFECT otherwise**
- Rationale: Reward communities that demonstrated consistent cooperation, but don't sacrifice unnecessarily to uncooperative groups

## Key Features

### 1. Threshold-Aware Cooperation
The strategy prioritizes cooperation when we're close to the critical threshold m, recognizing that these moments are when individual contributions matter most for collective success.

### 2. Trend Recognition
By tracking whether cooperation is increasing, decreasing, or stable, we can:
- Reinforce positive momentum by cooperating more when trends are positive
- Avoid being exploited in rapidly declining cooperation scenarios
- Maintain hope and occasional cooperation even in poor conditions

### 3. Graduated Response
Rather than binary decisions, the strategy uses probabilistic cooperation that scales with community behavior, allowing for:
- Flexibility in mixed cooperation environments
- Reduced predictability for potential exploiters
- Maintained cooperation incentives even in suboptimal conditions

### 4. Forgiveness and Hope
The strategy maintains some baseline cooperation probability (30%) even in poor conditions, because:
- It only takes one round of successful cooperation to potentially shift community dynamics
- Complete withdrawal reduces the chance of recovery
- Cooperative strategies should maintain faith in the community's potential

## Pseudocode Implementation

```python
def adaptive_trust_builder(round_num, history, n, m, k, r):
    if round_num == 1:
        return COOPERATE
    
    if round_num == r:  # Final round
        success_rate = count_threshold_successes(history) / (r-1)
        return COOPERATE if success_rate >= 0.6 else DEFECT
    
    # Analyze previous round
    prev_cooperators = count_cooperators(history[-1])
    ccr = prev_cooperators / n
    trend = analyze_cooperation_trend(history, window=3)
    
    # Threshold-based decisions
    if prev_cooperators >= m:
        if ccr >= 0.6:
            return COOPERATE
        elif ccr >= 0.4:
            return random_cooperate(0.8)
        else:
            return random_cooperate(0.6)
    
    elif prev_cooperators >= m-2:
        prob = 0.9 if prev_cooperators == m-1 else 0.9
        return random_cooperate(prob)
    
    else:
        if trend == "increasing":
            return random_cooperate(0.7)
        elif trend == "stable" and ccr >= 0.3:
            return random_cooperate(0.5)
        else:
            return random_cooperate(0.3)
```

This strategy embodies cooperative principles by consistently working toward collective success while adapting intelligently to community dynamics, maintaining both hope and strategic awareness throughout the game.
'''

description_COOPERATIVE_32 = '''
# Cooperative Strategy: "Adaptive Trust Builder"

## Core Philosophy
This strategy prioritizes collective welfare while being resilient to exploitation. It starts cooperatively, builds trust through reciprocity, and adapts to group dynamics while maintaining a cooperative orientation.

## Strategy Description

### Decision Rules

**Primary Cooperation Condition:**
Cooperate if the estimated probability of reaching threshold m is ≥ 50%

**Probability Estimation:**
Based on three factors weighted equally:
1. **Historical cooperation rate** of all players in previous rounds
2. **Recent trend** (cooperation rate in last 3 rounds vs. overall average)  
3. **Reciprocity factor** (how often players who cooperated with me also cooperated in return)

### Detailed Decision Logic

```pseudocode
function decide_action(round, history):
    if round == 1:
        return COOPERATE  // Always start cooperatively
    
    if round == final_round:
        return apply_endgame_logic()
    
    // Calculate cooperation probability estimate
    historical_rate = count_cooperators_in_history() / (n * (round-1))
    recent_trend = cooperation_rate_last_3_rounds() - historical_rate
    reciprocity = count_reciprocal_cooperations() / my_past_cooperations
    
    prob_threshold_met = (historical_rate + recent_trend + reciprocity) / 3
    
    if prob_threshold_met >= 0.5:
        return COOPERATE
    else:
        return conditional_cooperate()

function conditional_cooperate():
    // Even when probability is low, still cooperate if:
    if count_cooperators_last_round() >= (m-1):
        return COOPERATE  // Close to threshold, help push over
    if my_cooperation_rate > group_cooperation_rate + 0.1:
        return DEFECT     // Avoid being exploited too much
    else:
        return COOPERATE  // Default to cooperation
```

### Edge Case Handling

**First Round:** Always cooperate to signal cooperative intent and gather information about others' strategies.

**Final Round:** Use reciprocity-based decision:
- If majority of players have been consistently cooperative (>60% cooperation rate), cooperate
- If I've been cooperating significantly more than others, defect to avoid final exploitation
- Otherwise, cooperate if expected cooperators ≥ m-1

**Low Participation Rounds:** When very few cooperated in previous round, still cooperate if:
- It's early in the game (first 25% of rounds)
- My cooperation rate isn't significantly higher than group average
- There's evidence others might return to cooperation

### Cooperative Features

1. **Generous Starting:** Always begins with cooperation
2. **Forgiveness:** Doesn't permanently punish defection; reassesses each round
3. **Threshold Support:** Actively tries to help group reach cooperation threshold
4. **Trust Building:** Rewards reciprocal cooperation with continued cooperation
5. **Collective Focus:** Decisions prioritize group success over individual gain

### Adaptation Mechanisms

- **Dynamic Threshold:** Adjusts cooperation probability threshold based on game phase (more lenient early, stricter late)
- **Trend Sensitivity:** Responds to improving cooperation trends even when overall rates are low
- **Reciprocity Tracking:** Builds trust with players who demonstrate reciprocal cooperation

### Risk Management

- **Exploitation Protection:** Reduces cooperation if consistently giving much more than receiving
- **Endgame Caution:** Applies more stringent criteria in final rounds when defection incentives peak
- **Recovery Mechanism:** Can rebuild cooperation after periods of mutual defection

This strategy balances cooperative ideals with practical considerations, aiming to foster group cooperation while maintaining resilience against exploitation. It should perform well in tournaments with other AI strategies that may include both cooperative and competitive approaches.
'''

description_COOPERATIVE_33 = '''
# Cooperative Strategy: "Optimistic Guardian"

## Core Philosophy
This strategy balances cooperative intent with prudent risk management. It aims to achieve collective success while protecting against exploitation, operating under the assumption that other strategies are similarly cooperation-minded but may have different risk tolerances.

## Decision Rules

### Round 1: Optimistic Start
- **Always COOPERATE** in the first round
- Rationale: Signal cooperative intent and gather information about opponents' baseline cooperation levels

### Rounds 2 to r-1: Adaptive Cooperation
Use a three-tier decision system based on recent cooperation history:

```pseudocode
Let cooperation_rate = (cooperators in last round) / n

IF cooperation_rate >= (m/n + 0.1):
    Action = COOPERATE  // High cooperation environment
ELSE IF cooperation_rate >= (m-1)/n:
    Action = COOPERATE  // Near-threshold, help push over
ELSE:
    // Low cooperation - use conditional cooperation
    IF (cooperators in last round) >= (m-1):
        Action = COOPERATE  // One more needed to reach threshold
    ELSE:
        Action = DEFECT    // Too few cooperating to justify risk
```

### Final Round (Round r): Strategic Cooperation
- **COOPERATE if** cooperation_rate in round (r-1) >= (m-1)/n
- **DEFECT otherwise**
- Rationale: In the final round, others may defect, so only cooperate if there's been strong cooperative momentum

## Key Features

### 1. Threshold Awareness
The strategy is calibrated around the critical threshold `m`. It recognizes that cooperation is only valuable when the threshold can be realistically achieved.

### 2. Momentum Building
By cooperating when cooperation rates are near the threshold, the strategy helps build positive momentum and signals to other players that collective success is achievable.

### 3. Exploitation Protection
The strategy defects when cooperation levels are too low, protecting against scenarios where continued cooperation would be futile while others free-ride.

### 4. Forgiving Nature
The strategy doesn't punish individual defectors harshly but instead focuses on aggregate cooperation levels, recognizing that some players may have different risk tolerances or strategies.

## Edge Case Handling

### Very Low m (m = 2 in large groups)
- More aggressive cooperation since threshold is easier to achieve
- Only defect if cooperation rate < 20%

### High m (m close to n)
- More conservative approach
- Require cooperation rate > 70% before consistently cooperating

### Single Round Scenarios (r = 2)
- Round 1: COOPERATE
- Round 2: COOPERATE if at least (m-1) players cooperated in round 1

## Cooperative Alignment

This strategy embodies cooperation through:

1. **Initial Trust**: Always starting with cooperation
2. **Collective Focus**: Decisions based on group welfare rather than individual punishment
3. **Threshold Support**: Actively working to help the group reach the critical mass needed for collective success
4. **Adaptive Learning**: Adjusting behavior based on the group's demonstrated cooperation capacity

The strategy assumes other LLM strategies will also be designed with cooperative intent, making mutual cooperation more likely while still maintaining safeguards against exploitation.
'''

description_COOPERATIVE_34 = '''
# Cooperative Strategy: "Adaptive Threshold Guardian"

## Core Philosophy
This strategy prioritizes collective welfare while maintaining resilience against exploitation. It aims to achieve the cooperative outcome (everyone gets payoff `k`) while protecting against scenarios where cooperation collapses.

## Decision Rules

### Round 1: Cooperative Start
- **Always cooperate** in the first round to signal cooperative intent and give the group the best chance of reaching the threshold.

### Rounds 2 to r-1: Adaptive Cooperation
Use a three-tier decision system:

1. **Cooperation Count Analysis**: Track how many players cooperated in the previous round
2. **Trend Analysis**: Monitor whether cooperation is increasing, stable, or declining
3. **Safety Margin**: Ensure we don't abandon cooperation too early

**Decision Logic:**
```pseudocode
previous_cooperators = count_cooperators(previous_round)
cooperation_trend = calculate_trend(last_3_rounds)

IF previous_cooperators >= m + 1:
    // Threshold safely exceeded, continue cooperating
    COOPERATE
    
ELSE IF previous_cooperators == m:
    // Threshold barely met, be cautious but cooperative
    IF cooperation_trend >= 0:  // stable or improving
        COOPERATE
    ELSE:
        COOPERATE  // Stay loyal even if declining
        
ELSE IF previous_cooperators == m - 1:
    // One cooperator short, critical decision point
    IF cooperation_trend > 0:  // improving trend
        COOPERATE
    ELSE IF cooperation_trend == 0:  // stable at insufficient level
        COOPERATE  // Give benefit of doubt
    ELSE:
        COOPERATE  // Don't abandon ship yet
        
ELSE:  // previous_cooperators < m - 1
    // Significantly short of threshold
    IF cooperation_trend > 0 AND previous_cooperators >= m - 2:
        COOPERATE  // Recovery might be possible
    ELSE:
        DEFECT  // Protect against exploitation
```

### Final Round (Round r): Conditional Loyalty
In the last round, cooperation cannot influence future behavior, so:

```pseudocode
previous_cooperators = count_cooperators(previous_round)
average_cooperation = calculate_average_cooperation(all_previous_rounds)

IF previous_cooperators >= m:
    COOPERATE  // Reward successful cooperation
ELSE IF average_cooperation >= (m - 0.5):
    COOPERATE  // Group tried hard overall
ELSE:
    DEFECT  // Group failed to cooperate consistently
```

## Edge Case Handling

### First Round
- Always cooperate to establish cooperative norm and maximize initial success probability

### Very Small Groups (n ≤ 4)
- Be more forgiving in cooperation decisions since each defector has larger impact
- Only defect if cooperation has failed for 2+ consecutive rounds

### High Threshold Games (m close to n)
- Maintain cooperation longer since defection by cooperative players makes success nearly impossible
- Only defect if threshold hasn't been met for 3+ consecutive rounds

### Very Long Games (r > 10)
- Allow for "forgiveness periods" - return to cooperation after 2-3 rounds of punishment if cooperation shows signs of recovery

## Cooperative Alignment

This strategy embodies cooperation through:

1. **Default to Cooperation**: Always starts cooperatively and maintains cooperation as the default choice
2. **Collective Benefit Priority**: Decisions prioritize group welfare over individual gain
3. **Forgiveness**: Gives multiple chances before abandoning cooperation
4. **Recovery Support**: Actively supports attempts to rebuild cooperation
5. **Loyalty**: Maintains cooperation even in borderline scenarios

## Strategy Rationale

- **Maximizes Collective Welfare**: By defaulting to cooperation and being slow to defect
- **Prevents Exploitation**: Protects against persistent free-riders without abandoning cooperation prematurely  
- **Encourages Reciprocity**: Rewards group cooperation while not being naive about consistent failure
- **Adaptive**: Responds to group dynamics while maintaining cooperative bias

This strategy should perform well against other cooperative strategies while maintaining resilience against mixed or exploitative opponents, ultimately serving the collective good.
'''

description_COOPERATIVE_35 = '''
# Cooperative Strategy: "Adaptive Threshold Cooperation with Trust Building"

## Core Philosophy
This strategy prioritizes collective welfare while being realistic about the need to build and maintain cooperation among players. It starts optimistically but adapts based on observed behavior to sustain cooperation throughout the game.

## Decision Rules

### Round 1: Trust Building Start
**Action: COOPERATE**
- Start with cooperation to signal good intentions
- Establishes a cooperative baseline for other players to observe

### Rounds 2 to r-1: Adaptive Cooperation
**Cooperate IF:**
1. **Threshold Viability Check**: In the previous round, at least `m-1` other players cooperated
   - This indicates we're close enough to the threshold that my cooperation matters
2. **OR Momentum Building**: In the previous round, the number of cooperators increased compared to the round before
   - This shows positive trend toward cooperation
3. **OR Recovery Attempt**: We've had fewer than 2 consecutive rounds below threshold
   - Give cooperation chances to recover before giving up

**Defect OTHERWISE**
- If cooperation seems futile based on insufficient participation

### Final Round (r): Conditional Cooperation
**Cooperate IF:**
- At least `m-1` other players cooperated in round r-1
- **AND** the cooperation rate has been ≥ 50% over the last 3 rounds (or all rounds if r < 4)

**Defect OTHERWISE**
- In the final round, be more conservative since there's no future to build toward

## Pseudocode

```
function decide_action(round, history):
    if round == 1:
        return COOPERATE
    
    prev_cooperators = count_cooperators(history[round-1])
    
    if round == total_rounds:  // Final round
        if prev_cooperators >= m-1:
            recent_coop_rate = calculate_cooperation_rate(history, last_3_rounds)
            if recent_coop_rate >= 0.5:
                return COOPERATE
        return DEFECT
    
    // Middle rounds (2 to r-1)
    // Check threshold viability
    if prev_cooperators >= m-1:
        return COOPERATE
    
    // Check momentum
    if round > 2:
        prev_prev_cooperators = count_cooperators(history[round-2])
        if prev_cooperators > prev_prev_cooperators:
            return COOPERATE
    
    // Check recovery attempt
    consecutive_below_threshold = count_consecutive_below_threshold(history)
    if consecutive_below_threshold < 2:
        return COOPERATE
    
    return DEFECT
```

## Strategy Rationale

### Cooperative Elements:
1. **Optimistic Start**: Always cooperate in round 1 to establish cooperative intentions
2. **Threshold Support**: Cooperate when we're close to the threshold (m-1 others cooperating)
3. **Momentum Recognition**: Reward increasing cooperation trends
4. **Recovery Patience**: Give cooperation multiple chances to establish before abandoning

### Adaptive Elements:
1. **Realistic Assessment**: Don't cooperate when it's clearly futile (too few others participating)
2. **End-game Consideration**: Be more selective in final round while still supporting viable cooperation
3. **Pattern Recognition**: Use recent history to inform decisions rather than just the last round

### Edge Case Handling:
- **First Round**: Always cooperate to signal cooperative intent
- **Last Round**: Cooperate only if there's strong evidence others will too
- **Low Participation**: Stop cooperating if consistently too few others participate
- **Recovery Attempts**: Give cooperation 1-2 rounds to recover after failures

This strategy balances cooperative ideals with practical considerations, aiming to maximize collective welfare while avoiding exploitation. It encourages cooperation when viable while adapting to the actual behavior of other players in the tournament.
'''

description_COOPERATIVE_36 = '''
# Cooperative Strategy: "Adaptive Threshold Guardian"

## Core Philosophy
This strategy prioritizes collective welfare while being resilient to exploitation. It aims to maintain cooperation when possible but adapts to opponent behavior to ensure the cooperation threshold is met consistently.

## Decision Rules

### Round 1: Optimistic Start
- **Always cooperate** in the first round
- Rationale: Establish cooperative intent and gather information about opponent tendencies

### Rounds 2 to r-1: Adaptive Cooperation
```pseudocode
cooperation_count = count_cooperators_last_round()
my_cooperation_history = my_past_cooperations()
total_cooperation_rate = calculate_overall_cooperation_rate()

if cooperation_count >= m:
    // Threshold was met - maintain cooperation if others are cooperative
    if total_cooperation_rate >= 0.6:
        return COOPERATE
    else:
        // Be more selective if overall cooperation is low
        return COOPERATE with probability 0.8
else:
    // Threshold was missed - increase cooperation likelihood
    if cooperation_count >= m-2:
        // Close to threshold, definitely help
        return COOPERATE
    else:
        // Far from threshold, but still lean cooperative
        return COOPERATE with probability 0.9
```

### Final Round: Conditional Cooperation
```pseudocode
historical_cooperation_rate = calculate_overall_cooperation_rate()
recent_threshold_success_rate = calculate_recent_threshold_success()

if historical_cooperation_rate >= 0.5 AND recent_threshold_success_rate >= 0.7:
    return COOPERATE
else:
    // Others have been largely uncooperative
    return COOPERATE with probability 0.6
```

## Key Features

### 1. Threshold Awareness
- Monitors how close the group is to meeting the cooperation threshold (m)
- Increases cooperation probability when the group is close to but below threshold
- Maintains cooperation when threshold is being consistently met

### 2. Forgiveness Mechanism
- Doesn't immediately punish single-round defections
- Uses overall cooperation rates rather than just last-round behavior
- Gives other players benefit of the doubt early in the game

### 3. Adaptive Learning
- Tracks both individual round outcomes and overall patterns
- Adjusts cooperation probability based on group behavior trends
- Remains optimistic but not naive about cooperation prospects

### 4. End-game Consideration
- Maintains cooperative stance in final round if others have been cooperative
- Slightly reduces cooperation in final round only if facing consistent defection

## Cooperation Mechanisms

### Threshold Insurance
When cooperation count is exactly m-1, always cooperate to ensure threshold is met, recognizing that one additional cooperator makes the difference between group success and failure.

### Momentum Preservation
When the group successfully meets thresholds consistently, maintain high cooperation rates to preserve this beneficial equilibrium.

### Recovery Protocol
After rounds where threshold is missed, increase cooperation probability to help guide the group back to successful coordination.

## Edge Case Handling

- **All others defect consistently**: Still cooperate 60% of the time to provide opportunities for coordination
- **Fluctuating cooperation**: Respond to trends rather than individual rounds to avoid overreaction
- **Near-threshold situations**: Always err on the side of cooperation when close to threshold

This strategy balances cooperative ideals with practical adaptation, aiming to maximize collective payoffs while remaining robust against various opponent strategies.
'''

description_COOPERATIVE_37 = '''
# Cooperative Strategy: "Optimistic Threshold Guardian"

## Strategy Overview
This strategy prioritizes collective welfare while maintaining vigilance against free-riding. It operates on the principle of being generous with cooperation but firm against exploitation, with built-in mechanisms to recover from coordination failures.

## Core Decision Rules

### Round 1: Always Cooperate
- **Action**: C
- **Rationale**: Establish cooperative intent and give others the benefit of the doubt

### Subsequent Rounds: Adaptive Threshold Assessment

```pseudocode
function decide_action(round, history):
    if round == 1:
        return C
    
    # Count cooperators in previous round
    prev_cooperators = count_cooperators(history[round-1])
    
    # Success/failure tracking
    if prev_cooperators >= m:
        consecutive_successes += 1
        consecutive_failures = 0
    else:
        consecutive_failures += 1
        consecutive_successes = 0
    
    # Main decision logic
    if consecutive_failures >= 2:
        return apply_recovery_protocol(round, history)
    
    if prev_cooperators >= m:
        return C  # Reward successful cooperation
    
    if prev_cooperators == m-1:
        return C  # Critical threshold support
    
    if prev_cooperators >= m/2:
        return C  # Moderate cooperation exists
    
    # Low cooperation scenario
    if round <= r/2:
        return C  # Early game patience
    else:
        return apply_endgame_logic(round, history)
```

### Recovery Protocol (After 2+ Consecutive Failures)
```pseudocode
function apply_recovery_protocol(round, history):
    # Calculate recent cooperation trend
    recent_avg = average_cooperators(last_3_rounds(history))
    
    if recent_avg > m/3:
        return C  # Show willingness to rebuild
    
    if round <= r * 0.7:
        # Still time for recovery - be generous
        if random_chance() < 0.7:
            return C
        else:
            return D
    else:
        return apply_endgame_logic(round, history)
```

### Endgame Logic (Final 30% of rounds)
```pseudocode
function apply_endgame_logic(round, history):
    rounds_remaining = r - round + 1
    prev_cooperators = count_cooperators(history[round-1])
    
    # If very close to threshold, always help
    if prev_cooperators >= m-2:
        return C
    
    # If cooperation completely collapsed, adapt based on remaining rounds
    if prev_cooperators < m/3:
        if rounds_remaining > 3:
            return C  # One more serious attempt
        else:
            return D  # Cut losses
    
    # Default to cooperation in endgame uncertainty
    return C
```

## Key Features

### 1. **Threshold Sensitivity**
- Always cooperates when previous round had m-1 cooperators (critical support)
- Recognizes when collective action is most needed

### 2. **Failure Recovery**
- After 2 consecutive threshold failures, enters recovery mode
- Uses probabilistic cooperation to test for renewed collective commitment
- Balances persistence with self-protection

### 3. **Endgame Adaptation**
- Becomes more selective in final rounds if cooperation has collapsed
- Maintains cooperative stance when threshold is achievable
- Prevents being exploited in hopeless situations

### 4. **Generous Defaults**
- Errs on the side of cooperation when uncertain
- Gives multiple chances for collective coordination
- Only becomes defensive after clear patterns of exploitation

## Edge Case Handling

- **First Round**: Always cooperate (establish good faith)
- **Last Round**: Cooperate if threshold is achievable (m-2 or more cooperated previously)
- **All Defect History**: Continue cooperating until round r*0.7, then become selective
- **Oscillating Patterns**: Focus on recent trends rather than distant history

## Cooperative Alignment

This strategy embodies cooperation through:
1. **Initial Trust**: Starting with cooperation
2. **Collective Responsibility**: Supporting critical threshold moments
3. **Forgiveness**: Giving multiple chances after failures
4. **Proportional Response**: Escalating defensiveness only after sustained exploitation
5. **Long-term Thinking**: Prioritizing collective welfare over short-term gains

The strategy aims to maximize total welfare while protecting against systematic free-riding, making it both genuinely cooperative and strategically sound.
'''

description_COOPERATIVE_38 = '''
# Cooperative Strategy: "Adaptive Threshold Guardian"

## Core Philosophy
This strategy prioritizes collective welfare while being resilient to exploitation. It aims to maintain cooperation when possible but includes safeguards to prevent being taken advantage of by consistently defecting opponents.

## Strategy Description

### Decision Rules

**Round 1 (Initialization):**
- Always COOPERATE
- Rationale: Start with good faith and signal cooperative intent

**Subsequent Rounds (2 to r):**
The strategy uses a three-tier decision system:

1. **Cooperation Assessment Phase**
   - Calculate cooperation rate from previous round: `coop_rate = cooperators_last_round / n`
   - Track personal cooperation history and outcomes

2. **Threshold Analysis Phase**
   - If `cooperators_last_round >= m`: Threshold was met (success)
   - If `cooperators_last_round < m`: Threshold failed (risk realized)

3. **Decision Phase**
   ```pseudocode
   if round_number == r:  // Last round
       return COOPERATE  // Final act of cooperation
   
   if cooperators_last_round >= m + 1:  // Comfortable margin above threshold
       return COOPERATE
   
   if cooperators_last_round == m:  // Exactly at threshold
       if my_last_action == COOPERATE:
           return COOPERATE  // Continue supporting threshold
       else:
           return COOPERATE  // Join the cooperative group
   
   if cooperators_last_round == m - 1:  // One short of threshold
       return COOPERATE  // Critical support needed
   
   if cooperators_last_round < m - 1:  // Far below threshold
       if coop_rate > 0.3:  // Some cooperation exists (30% threshold)
           return COOPERATE  // Try to rebuild cooperation
       else:
           if random() < 0.2:  // 20% chance to attempt revival
               return COOPERATE
           else:
               return DEFECT  // Protect against widespread defection
   ```

### Key Features

**1. Threshold-Centric Logic**
- Prioritizes maintaining the critical threshold `m`
- Provides support when the group is close to the threshold
- Recognizes when cooperation is sustainable vs. when it's failing

**2. Adaptive Cooperation**
- More likely to cooperate when others are cooperating
- Attempts to rebuild cooperation even after failures
- Maintains some probability of cooperation even in hostile environments

**3. Edge Case Handling**
- **First Round**: Always cooperate to establish good faith
- **Last Round**: Always cooperate as a final cooperative gesture (no future retaliation risk)
- **Critical Moments**: When exactly at threshold, always support it
- **Recovery Attempts**: Periodic cooperation attempts even after multiple failures

**4. Exploitation Protection**
- Reduces cooperation when facing widespread defection
- Uses probabilistic defection to avoid being the only cooperator
- Maintains minimum cooperation rate to test for recovery opportunities

## Cooperative Alignment

This strategy embodies cooperation through:
- **Default Cooperation**: Assumes good faith and starts cooperatively
- **Collective Focus**: Decisions based on group welfare (threshold maintenance)
- **Recovery Orientation**: Actively attempts to rebuild cooperation
- **Sacrifice Willingness**: Cooperates in final round despite no future benefit
- **Threshold Support**: Prioritizes maintaining the minimum needed for collective benefit

## Expected Behavior

- **Against Other Cooperators**: Will consistently cooperate and maintain threshold
- **Against Mixed Strategies**: Will adapt to maintain cooperation when viable
- **Against Defectors**: Will attempt recovery but protect against exploitation
- **In Tournament Setting**: Will perform well with other cooperative strategies while maintaining resilience against exploitative ones

This strategy balances the cooperative imperative with strategic resilience, making it suitable for a diverse tournament environment while maintaining true cooperative intent.
'''

description_COOPERATIVE_39 = '''
Looking at this Collective Risk Dilemma, I need to design a strategy that maximizes cooperation while being resilient to defection. Here's my cooperative strategy:

## **Optimistic Threshold Guardian Strategy**

### **Core Philosophy**
This strategy aims to maintain cooperation while being adaptive to the group's behavior. It starts optimistically, monitors the cooperation threshold, and uses measured responses to encourage collective success.

### **Decision Rules**

#### **Round 1: Optimistic Start**
- Always **COOPERATE** in the first round
- Rationale: Signal cooperative intent and give the group the best chance to establish a cooperative pattern

#### **Rounds 2 to r-1: Adaptive Threshold Monitoring**
```pseudocode
FOR round t = 2 to r-1:
    cooperators_last_round = count_cooperators(t-1)
    
    IF cooperators_last_round >= m:
        // Threshold was met - reinforce cooperation
        action = COOPERATE
    
    ELSE IF cooperators_last_round >= m-2:
        // Close to threshold - be forgiving and help
        action = COOPERATE
        
    ELSE IF cooperators_last_round >= m/2:
        // Moderate cooperation - conditional cooperation
        IF I_cooperated_last_round:
            action = DEFECT  // Mild punishment
        ELSE:
            action = COOPERATE  // Give another chance
    
    ELSE:
        // Low cooperation - stronger response needed
        IF cooperators_last_round == 0:
            action = DEFECT  // Don't be exploited
        ELSE:
            action = COOPERATE  // Still try to rebuild
```

#### **Final Round (Round r): Conditional Cooperation**
```pseudocode
cooperators_last_round = count_cooperators(r-1)

IF cooperators_last_round >= m-1:
    // Good chance of success
    action = COOPERATE
ELSE IF cooperators_last_round >= m/2:
    // Moderate chance - be optimistic
    action = COOPERATE
ELSE:
    // Low chance of success
    action = DEFECT
```

### **Key Strategic Elements**

1. **Threshold Sensitivity**: The strategy pays close attention to how close the group is to the minimum threshold `m`, being more forgiving when close to success.

2. **Graduated Response**: Rather than harsh tit-for-tat, it uses measured responses:
   - Reward success with continued cooperation
   - Respond to near-misses with patience
   - Apply mild punishment only when cooperation is moderate
   - Avoid total defection unless completely exploited

3. **Optimistic Bias**: When in doubt, especially early in the game, lean toward cooperation to maximize the group's chances of achieving the collective benefit.

4. **End-Game Consideration**: In the final round, be more willing to cooperate if there's a reasonable chance of success, since there's no future to worry about.

### **Edge Case Handling**

- **All Defect Scenario**: If everyone defected in the previous round, defect to avoid being the sole contributor
- **Unanimous Cooperation**: Always cooperate to maintain the beneficial equilibrium  
- **Borderline Cases**: When exactly at threshold, cooperate to maintain momentum
- **Early Rounds**: Be extra patient to allow cooperative norms to establish

### **Cooperative Alignment**

This strategy embodies cooperation by:
- Starting with trust and good faith
- Prioritizing collective success over individual gain
- Being forgiving of occasional defections
- Focusing on threshold achievement rather than punishment
- Maintaining hope for cooperation even after setbacks

The strategy recognizes that in a tournament setting, other AIs might also be programmed with cooperative tendencies, so it aims to coordinate with like-minded strategies while protecting against exploitation.
'''

description_COOPERATIVE_40 = '''
# Cooperative Strategy: "Adaptive Threshold Keeper"

## Core Philosophy
This strategy prioritizes collective welfare while being resilient to defection and adaptive to group dynamics. It aims to maintain cooperation at the minimum viable threshold while encouraging broader participation.

## Decision Rules

### Round 1: Cooperative Signal
**Always cooperate** to signal cooperative intent and help establish a pro-social norm from the start.

### Rounds 2 to r-1: Adaptive Cooperation
Use a three-factor decision system:

1. **Threshold Security Check**: Count cooperators from the previous round
2. **Trend Analysis**: Assess cooperation trajectory over recent rounds
3. **Risk Assessment**: Evaluate likelihood of threshold being met

**Cooperate if ANY of these conditions hold:**
- Previous round had exactly m cooperators (threshold barely met - need to maintain)
- Previous round had fewer than m cooperators (failed threshold - emergency cooperation)
- Cooperation trend is declining and current cooperation level is near threshold
- I was among the cooperators last round AND threshold was met (reward loyalty)

**Defect only if:**
- Previous round had significantly more than m cooperators (m+2 or more) AND
- Cooperation has been stable or increasing over last 3 rounds AND
- This creates opportunity for others to step up while maintaining threshold

### Final Round (Round r): Conditional Cooperation
- **Cooperate** if cooperation is needed to maintain group welfare
- **Defect** only if there are clearly enough cooperators (m+2 or more consistently)

## Pseudocode

```
function decide_action(round_num, history):
    if round_num == 1:
        return COOPERATE
    
    last_round_cooperators = count_cooperators(history[round_num-1])
    my_last_action = my_action(history[round_num-1])
    
    # Emergency cooperation - threshold failed
    if last_round_cooperators < m:
        return COOPERATE
    
    # Threshold barely met - maintain stability  
    if last_round_cooperators == m:
        return COOPERATE
    
    # Analyze recent trends (last 3 rounds or available rounds)
    recent_rounds = min(3, round_num-1)
    cooperation_trend = analyze_trend(history, recent_rounds)
    
    # Final round considerations
    if round_num == r:
        if last_round_cooperators >= m+2:
            return DEFECT  # Safe to free-ride in final round
        else:
            return COOPERATE  # Ensure group success
    
    # Middle rounds with surplus cooperation
    if last_round_cooperators >= m+2:
        if cooperation_trend == "stable" or cooperation_trend == "increasing":
            if my_last_action == COOPERATE:
                # Occasionally defect to test group resilience
                return DEFECT
        return COOPERATE  # Default to cooperation when uncertain
    
    # Default: cooperate when in doubt
    return COOPERATE

function analyze_trend(history, num_rounds):
    cooperator_counts = []
    for i in range(num_rounds):
        cooperator_counts.append(count_cooperators(history[len(history)-1-i]))
    
    if is_increasing(cooperator_counts):
        return "increasing"
    elif is_decreasing(cooperator_counts):
        return "decreasing"  
    else:
        return "stable"
```

## Key Features

### 1. **Threshold Vigilance**
- Never allows cooperation to fall below threshold without contributing
- Prioritizes group success over individual gain

### 2. **Adaptive Learning**
- Responds to group cooperation patterns
- Adjusts behavior based on recent trends
- Tests group resilience when safe to do so

### 3. **Edge Case Handling**
- **First Round**: Signal cooperation to establish positive norms
- **Middle Rounds**: Balance threshold maintenance with strategic adaptation
- **Final Round**: Ensure group success while allowing some strategic defection

### 4. **Cooperative Resilience**
- Defaults to cooperation when uncertain
- Responds to defection with increased cooperation
- Only defects when group welfare is clearly secure

## Strategic Advantages

1. **Prevents Threshold Collapse**: Always responds to cooperation shortfalls
2. **Encourages Participation**: Rewards cooperative behavior from others
3. **Stable but Flexible**: Maintains minimum threshold while adapting to group dynamics
4. **Group-Oriented**: Prioritizes collective payoffs over individual maximization

This strategy embodies cooperative principles while being intelligent about when cooperation is most needed, creating a reliable foundation for group success.
'''

description_COOPERATIVE_41 = '''
# Cooperative Strategy: "Conditional Altruist with Safety Net"

## Core Philosophy
This strategy prioritizes collective welfare while maintaining rational self-interest. It aims to establish and maintain cooperation when feasible, while protecting against exploitation through adaptive safety mechanisms.

## Strategy Description

### Decision Rules

**Primary Cooperation Condition:**
- Cooperate if the expected number of cooperators (including self) ≥ m
- This expectation is based on observed cooperation rates and trust assessment

**Safety Net Mechanism:**
- Always defect if cooperation rate in last 3 rounds < (m-1)/n
- This prevents being exploited when cooperation clearly isn't sustainable

### Detailed Algorithm

```pseudocode
STRATEGY: Conditional_Altruist_Safety_Net

INITIALIZATION:
- cooperation_history = []
- trust_score = 0.7  // Start optimistic but cautious
- safety_threshold = (m-1)/n

FOR each round t:
    IF t == 1:  // First round
        RETURN C  // Lead by example
    
    ELIF t == r:  // Last round
        // Cooperate only if very confident others will too
        recent_coop_rate = cooperation_rate(last 2 rounds)
        IF recent_coop_rate >= m/n + 0.1:
            RETURN C
        ELSE:
            RETURN D
    
    ELSE:  // Middle rounds
        // Calculate recent cooperation trends
        recent_coop_rate = cooperation_rate(last 3 rounds)
        
        // Safety net: Don't cooperate if system is failing
        IF recent_coop_rate < safety_threshold:
            RETURN D
        
        // Update trust based on whether threshold was met recently
        rounds_met_threshold = count_threshold_met(last 3 rounds)
        trust_score = 0.3 * trust_score + 0.7 * (rounds_met_threshold / min(3, t-1))
        
        // Cooperate if we expect enough others will cooperate
        expected_cooperators = trust_score * (n-1) + 1  // +1 for self
        
        IF expected_cooperators >= m:
            RETURN C
        ELSE:
            RETURN D

HELPER FUNCTIONS:
cooperation_rate(rounds):
    return (total_cooperators_in_rounds) / (n * number_of_rounds)

count_threshold_met(rounds):
    return number of rounds where cooperators >= m
```

### Edge Case Handling

1. **First Round**: Always cooperate to signal willingness and establish positive precedent

2. **Last Round**: Apply higher threshold for cooperation since others may defect knowing it's the end

3. **Early Rounds (t ≤ 3)**: Use more optimistic assumptions due to limited data

4. **Threshold Exactly Met**: When exactly m-1 others cooperate, always cooperate to ensure threshold is met

5. **All Others Defecting**: Safety net prevents continued cooperation when clearly unsustainable

### Cooperative Alignment

This strategy embodies cooperation through:

1. **Proactive Leadership**: Starts with cooperation to encourage others
2. **Conditional Reciprocity**: Maintains cooperation when others do
3. **Collective Benefit Priority**: Aims for outcomes where everyone gets the bonus k
4. **Trust Building**: Gradually builds trust based on group behavior
5. **Rational Sustainability**: Prevents cooperation collapse through safety mechanisms

### Strategic Rationale

- **Maximizes Group Welfare**: When successful, all players get payoff (1-0)+k = 1+k instead of just 1
- **Evolutionary Stability**: Can coexist with other cooperative strategies
- **Exploitation Resistance**: Safety net prevents being a "sucker" against all-defect strategies
- **Adaptive**: Adjusts behavior based on observed group dynamics
- **Clear Signaling**: Actions clearly communicate cooperative intent while maintaining boundaries

This strategy should perform well in a tournament of LLM-generated strategies, as it balances the cooperative imperative with rational game-theoretic considerations, making it attractive for other AI systems to cooperate with while protecting against exploitation.
'''

description_COOPERATIVE_42 = '''
# Cooperative Strategy: "Adaptive Threshold Guardian"

## Core Philosophy
This strategy prioritizes collective welfare while being resilient to exploitation. It aims to maintain cooperation when possible, recover from failures, and protect the group from complete collapse.

## Strategy Overview

### Decision Rules

**Primary Rule: Threshold-Based Cooperation**
- **Cooperate** if the number of cooperators in the previous round was ≥ (m-1)
- **Defect** if the number of cooperators in the previous round was < (m-2)
- **Special handling** when cooperators = (m-2): use forgiveness mechanism

**Rationale**: This creates a buffer around the critical threshold m. If we're at or near the threshold, we cooperate to maintain it. If we're far below, we conserve resources until others show willingness to rebuild cooperation.

### Edge Cases

**First Round**: Always **COOPERATE**
- Establishes cooperative intent
- Helps build initial trust
- Necessary to discover if threshold can be met

**Last Round**: **COOPERATE** if previous round had ≥ (m-1) cooperators, otherwise **DEFECT**
- No future rounds to worry about, so standard threshold logic applies
- Maintains consistency with overall strategy

**When Cooperators = (m-2)**: **Forgiveness Mechanism**
- Cooperate if this situation has occurred ≤ 2 times in last 5 rounds
- Otherwise defect (prevents repeated exploitation)

### Recovery Mechanism

**Rebuilding Phase**: After extended periods below threshold (≥ 3 consecutive rounds with < m cooperators):
- Cooperate every 3rd round regardless of recent history
- This provides periodic "olive branches" to restart cooperation
- Continue until threshold is met or game ends

## Pseudocode

```
initialize:
    consecutive_failures = 0
    forgiveness_count = 0
    round_number = 1

for each round:
    if round_number == 1:
        action = COOPERATE
    
    elif round_number == r:  // last round
        if previous_cooperators >= (m-1):
            action = COOPERATE
        else:
            action = DEFECT
    
    else:
        if previous_cooperators >= (m-1):
            action = COOPERATE
            consecutive_failures = 0
            
        elif previous_cooperators == (m-2):
            recent_forgiveness = count_forgiveness_in_last_5_rounds()
            if recent_forgiveness <= 2:
                action = COOPERATE
                forgiveness_count += 1
            else:
                action = DEFECT
            consecutive_failures = 0
            
        elif previous_cooperators < (m-2):
            consecutive_failures += 1
            if consecutive_failures >= 3 and (round_number % 3 == 1):
                action = COOPERATE  // recovery attempt
            else:
                action = DEFECT
    
    round_number += 1
    return action
```

## Strategic Advantages

1. **Threshold Protection**: Actively works to maintain the critical threshold m
2. **Forgiveness**: Doesn't abandon cooperation after single failures
3. **Exploitation Resistance**: Won't cooperate indefinitely if consistently exploited
4. **Recovery Oriented**: Provides mechanisms to rebuild cooperation after collapse
5. **Consistent**: Clear, predictable rules that other cooperative strategies can coordinate with

## Cooperative Alignment

This strategy embodies cooperation by:
- **Defaulting to cooperation** when the threshold is sustainable
- **Prioritizing group welfare** over individual short-term gains
- **Providing recovery opportunities** rather than permanent defection
- **Being predictable** so other cooperative strategies can coordinate
- **Showing initial trust** by cooperating first

The strategy recognizes that true cooperation sometimes requires temporary defection to avoid being systematically exploited, but always maintains pathways back to cooperative equilibrium.
'''

description_COOPERATIVE_43 = '''
# Cooperative Strategy: "Threshold Guardian"

## Core Philosophy
This strategy prioritizes achieving the collective benefit while being resilient against defection. It operates on the principle of "cooperative leadership with adaptive resilience" - leading by example while monitoring group dynamics to ensure the threshold is consistently met.

## Strategy Description

### Decision Rules

**Primary Rule: Conditional Cooperation with Safety Buffer**
- Always cooperate if my cooperation is needed to reach or maintain the threshold `m`
- Cooperate with high probability even when not strictly needed, to build trust and provide safety buffer
- Only consider defection when there's a substantial surplus of cooperators

**Specific Decision Logic:**
1. **Track cooperator count** from previous round: `prev_cooperators`
2. **Estimate expected cooperators** this round based on recent trends
3. **Apply safety-first principle**: Err on the side of cooperation when uncertain

### Detailed Algorithm

```pseudocode
STRATEGY: Threshold Guardian

INITIALIZATION:
- cooperation_probability = 0.9  // High base cooperation rate
- safety_buffer = 1             // Extra cooperators beyond threshold
- trust_level = 0.8            // Initial trust in others
- defection_streak = 0         // Track consecutive failures

FOR each round t:
    IF t == 1:
        ACTION = COOPERATE  // Always lead with cooperation
    
    ELSE:
        // Analyze previous round
        prev_cooperators = count_cooperators(round t-1)
        threshold_met = (prev_cooperators >= m)
        
        // Update trust based on recent performance
        IF threshold_met:
            trust_level = min(1.0, trust_level + 0.1)
            defection_streak = 0
        ELSE:
            trust_level = max(0.3, trust_level - 0.2)
            defection_streak += 1
        
        // Calculate expected cooperators this round
        // Assume others will roughly repeat previous behavior
        expected_cooperators = estimate_cooperators(prev_cooperators, trust_level)
        
        // Decision logic
        IF expected_cooperators < m:
            ACTION = COOPERATE  // Critical: threshold at risk
        
        ELSE IF expected_cooperators < m + safety_buffer:
            ACTION = COOPERATE  // Provide safety margin
        
        ELSE IF defection_streak >= 2:
            ACTION = COOPERATE  // Recovery mode after failures
        
        ELSE IF t >= r - 2:
            ACTION = COOPERATE  // Final rounds - maintain cooperation
        
        ELSE:
            // Safe to occasionally defect with high surplus
            surplus = expected_cooperators - m - safety_buffer
            defect_prob = min(0.3, surplus * 0.1)
            
            IF random() < defect_prob:
                ACTION = DEFECT
            ELSE:
                ACTION = COOPERATE
```

### Edge Case Handling

**First Round (t=1):**
- Always cooperate to signal cooperative intent and encourage reciprocation
- Establishes positive precedent for the group

**Last Round (t=r):**
- Always cooperate to maintain group success
- Avoids end-game defection that could cause threshold failure

**Second-to-Last Round (t=r-1):**
- Cooperate to prevent cascading defection in final round
- Maintains stability heading into endgame

**Consecutive Threshold Failures:**
- After 2+ consecutive failures, switch to guaranteed cooperation
- Helps rebuild group coordination
- Only resume conditional logic after at least one successful round

**High Surplus Situations:**
- When expected cooperators significantly exceed threshold + buffer
- Allow small probability of defection (max 30%) to capture some free-rider benefit
- But maintain high cooperation rate to preserve group trust

### Cooperative Alignment

This strategy embodies cooperation through:

1. **Threshold Assurance**: Prioritizes meeting the collective threshold above personal gain
2. **Safety-First Approach**: Provides buffer beyond minimum requirement
3. **Trust Building**: High cooperation rate builds reciprocal cooperation
4. **Group Recovery**: Increased cooperation after failures helps restore coordination
5. **Endgame Stability**: Maintains cooperation through final rounds
6. **Conditional Generosity**: Occasionally sacrifices optimal personal payoff for group benefit

### Robustness Features

- **Adaptive to group behavior**: Adjusts expectations based on observed patterns
- **Resilient to defectors**: Maintains threshold even with some free-riders
- **Prevents cascade failures**: Responds to declining cooperation with increased cooperation
- **Balances cooperation and rationality**: Allows limited strategic defection when truly safe

This strategy should perform well against other cooperative strategies while being robust enough to maintain threshold achievement even when facing some defectors or conditional cooperators.
'''

description_COOPERATIVE_44 = '''
# Cooperative Strategy: "Adaptive Threshold Guardian"

## Core Philosophy
This strategy prioritizes collective welfare while being robust against exploitation. It aims to maintain cooperation when possible but includes safeguards to prevent being taken advantage of by consistently defecting opponents.

## Strategy Description

### Decision Rules

**Primary Rule: Threshold-Based Cooperation**
- Cooperate if the expected number of cooperators (including myself) is likely to meet or exceed the threshold `m`
- This is based on tracking each opponent's cooperation rate and predicting their behavior

**Secondary Rule: Forgiveness Mechanism**
- Even if cooperation seems unlikely to reach threshold, occasionally cooperate to test if opponents have changed their strategy
- This prevents getting stuck in all-defect equilibria when cooperation could resume

### Detailed Algorithm

```pseudocode
STRATEGY: Adaptive Threshold Guardian

INITIALIZATION:
- cooperation_history[i] = [] for each player i
- forgiveness_counter = 0
- last_round_cooperators = 0

FOR each round t:
    IF t == 1 (first round):
        action = COOPERATE  // Start cooperatively
    
    ELSE IF t == r (last round):
        // In final round, cooperate if others likely will
        expected_cooperators = predict_cooperators(t)
        IF expected_cooperators >= m-1:  // m-1 because we need m total including us
            action = COOPERATE
        ELSE:
            action = DEFECT
    
    ELSE:  // Middle rounds
        expected_cooperators = predict_cooperators(t)
        
        IF expected_cooperators >= m-1:
            action = COOPERATE
        
        ELSE IF should_forgive(t):
            action = COOPERATE  // Forgiveness attempt
            forgiveness_counter++
        
        ELSE:
            action = DEFECT

FUNCTION predict_cooperators(round_t):
    predicted = 0
    FOR each other player i:
        cooperation_rate = calculate_cooperation_rate(i, round_t-1)
        
        // Weight recent behavior more heavily
        recent_weight = 0.7
        overall_weight = 0.3
        
        recent_rate = cooperation_rate_last_3_rounds(i)
        weighted_rate = recent_weight * recent_rate + overall_weight * cooperation_rate
        
        // Add randomness factor (players might not be perfectly consistent)
        IF weighted_rate > 0.6:
            predicted += 1
        ELSE IF weighted_rate > 0.3:
            predicted += 0.5  // Uncertain players
    
    RETURN predicted

FUNCTION should_forgive(round_t):
    // Forgive every 4-5 rounds if we've been defecting
    IF forgiveness_counter == 0 AND round_t % 4 == 0:
        RETURN true
    // Extra forgiveness if we're in a bad equilibrium
    IF last_round_cooperators == 0 AND round_t % 3 == 0:
        RETURN true
    RETURN false
```

## Edge Case Handling

### First Round
- **Always cooperate** to signal cooperative intent and establish a positive starting point
- This gives the best chance of reaching a cooperative equilibrium early

### Last Round
- **Conditional cooperation** based on predicted behavior
- Since there's no future to consider, cooperate only if threshold is likely to be met
- Prevents being exploited when others defect knowing it's the final round

### Early Rounds (2-4)
- **Optimistic cooperation** - assume others are also trying to establish cooperation
- Give benefit of the doubt to players with limited history

### Recovery from Bad Equilibria
- If several consecutive rounds have failed to meet threshold, increase forgiveness frequency
- This prevents permanent lock-in to suboptimal outcomes

## Cooperative Alignment

This strategy embodies cooperation through:

1. **Default to Cooperation**: Starts cooperatively and maintains cooperation when threshold is likely met

2. **Collective Benefit Focus**: Prioritizes outcomes that benefit all players over individual gain

3. **Forgiveness**: Includes mechanisms to break out of punishment cycles and return to cooperation

4. **Adaptive Learning**: Learns opponent patterns to make cooperation more sustainable

5. **Risk Management**: Balances cooperative ideals with practical considerations to avoid exploitation

## Strategic Advantages

- **Robust**: Handles both cooperative and selfish opponents effectively
- **Adaptive**: Learns from opponent behavior patterns
- **Forgiving**: Can recover from cooperation breakdowns
- **Efficient**: Seeks outcomes where threshold is met with minimal "waste" (excess cooperators)

This strategy aims to achieve high collective payoffs while being resilient enough to perform well even against less cooperative opponents.
'''

description_COOPERATIVE_45 = '''
# Cooperative Strategy: "Adaptive Threshold Guardian"

## Core Philosophy
This strategy prioritizes collective welfare while maintaining resilience against exploitation. It balances trust-building with strategic protection to maximize both individual and group payoffs over the long term.

## Strategy Overview
The strategy operates in three phases: **Trust Building**, **Adaptive Cooperation**, and **Final Push**, with dynamic adjustments based on group cooperation patterns.

## Decision Rules

### Phase 1: Trust Building (Rounds 1-3 or first 20% of rounds, whichever is larger)
- **Always cooperate** to establish cooperative norms
- Track cooperation rates to calibrate expectations
- Build reputation as a reliable cooperator

### Phase 2: Adaptive Cooperation (Middle rounds)
- **Primary Rule**: Cooperate if the predicted number of cooperators ≥ m
- **Prediction Model**: Use exponentially weighted moving average of recent cooperation rates
  - Weight recent rounds more heavily (decay factor = 0.7)
  - If insufficient history, assume 60% cooperation rate
- **Safety Net**: If cooperation rate drops below 40%, cooperate for 2 consecutive rounds to attempt revival
- **Forgiveness**: After punishment/defection, return to cooperation if group shows improvement

### Phase 3: Final Push (Last 10% of rounds)
- **Escalating Commitment**: Increase cooperation probability as game nears end
- Cooperate if predicted cooperators ≥ (m - 1) in final rounds
- **Last Round**: Always cooperate (no future retaliation possible)

## Pseudocode

```python
def decide_action(round_num, history, n, m, r):
    # Phase boundaries
    trust_phase_end = max(3, int(0.2 * r))
    final_phase_start = max(r - int(0.1 * r), r - 2)
    
    # Phase 1: Trust Building
    if round_num <= trust_phase_end:
        return COOPERATE
    
    # Phase 3: Final Push
    if round_num >= final_phase_start:
        threshold = m - 1 if round_num == r else m
        predicted_cooperators = predict_cooperation(history)
        return COOPERATE if predicted_cooperators >= threshold else COOPERATE
    
    # Phase 2: Adaptive Cooperation
    predicted_cooperators = predict_cooperation(history)
    cooperation_rate = get_recent_cooperation_rate(history)
    
    # Safety net for low cooperation
    if cooperation_rate < 0.4:
        return COOPERATE  # Attempt to revive cooperation
    
    # Primary decision rule
    return COOPERATE if predicted_cooperators >= m else DEFECT

def predict_cooperation(history, decay=0.7):
    if not history:
        return int(0.6 * n)  # Optimistic assumption
    
    weighted_sum = 0
    weight_sum = 0
    
    for i, round_data in enumerate(reversed(history[-5:])):  # Last 5 rounds
        cooperators = count_cooperators(round_data)
        weight = decay ** i
        weighted_sum += cooperators * weight
        weight_sum += weight
    
    return weighted_sum / weight_sum if weight_sum > 0 else int(0.6 * n)
```

## Edge Case Handling

### First Round
- **Always cooperate** to signal cooperative intent and help establish positive group dynamics

### Last Round  
- **Always cooperate** since there's no future punishment possible, and cooperation might push the group over the threshold

### Insufficient History
- Assume moderate optimism (60% cooperation rate) to avoid overly pessimistic starts

### Tie Situations
- When predicted cooperators exactly equals m-1, **lean toward cooperation** to help achieve threshold

## Cooperative Alignment

This strategy embodies cooperation through:

1. **Initial Trust**: Unconditional cooperation in early rounds builds group trust
2. **Collective Focus**: Decisions prioritize achieving the group threshold rather than individual gain
3. **Forgiveness**: Returns to cooperation after group defection episodes
4. **End-game Cooperation**: Maintains cooperation even when exploitation risk is highest
5. **Revival Attempts**: Actively tries to restore cooperation when group coordination breaks down

## Robustness Features

- **Adaptive Learning**: Updates expectations based on actual group behavior
- **Exploitation Protection**: Won't cooperate indefinitely if others consistently defect
- **Threshold Awareness**: Focuses on the critical cooperation level needed for group success
- **Dynamic Response**: Adjusts strategy based on game phase and group dynamics

This strategy aims to be a "good citizen" that helps establish and maintain cooperative equilibria while protecting against systematic exploitation, ultimately maximizing both individual and collective welfare over the repeated game.
'''

description_COOPERATIVE_46 = '''
# Cooperative Strategy: "Threshold-Aware Cooperative Leader"

## Core Philosophy
This strategy prioritizes collective welfare while being strategically aware of the threshold dynamics. It aims to establish and maintain cooperation by taking leadership when needed while being responsive to others' cooperative efforts.

## Strategy Description

### Decision Rules

**Primary Rule: Conditional Cooperation with Leadership**
- **Cooperate** if cooperation in the previous round met or exceeded the threshold (m players cooperated)
- **Cooperate** if cooperation in the previous round was close to threshold (m-1 players cooperated) 
- **Lead by cooperating** if cooperation is declining but still salvageable
- **Defect** only when cooperation has clearly collapsed and recovery seems unlikely

### Detailed Decision Logic

```pseudocode
Strategy: ThresholdAwareCooperativeLeader

Initialize:
- cooperation_history = []
- my_action_history = []
- consecutive_failures = 0

For each round t:
    if t == 1:  // First round
        return COOPERATE
    
    else if t == final_round:  // Last round special case
        if previous_round_succeeded():
            return COOPERATE
        else if cooperators_last_round >= m-1:
            return COOPERATE  // Try to salvage
        else:
            return DEFECT
    
    else:  // Middle rounds
        cooperators_last_round = count_cooperators(t-1)
        
        if cooperators_last_round >= m:
            // Success! Maintain cooperation
            consecutive_failures = 0
            return COOPERATE
            
        else if cooperators_last_round == m-1:
            // Close to threshold - be a leader
            consecutive_failures = 0
            return COOPERATE
            
        else if cooperators_last_round >= m-2 AND consecutive_failures <= 1:
            // Still recoverable with leadership
            return COOPERATE
            
        else if is_positive_trend():
            // Cooperation is improving
            consecutive_failures = 0
            return COOPERATE
            
        else:
            // Cooperation has collapsed
            consecutive_failures += 1
            if consecutive_failures >= 3:
                return DEFECT
            else:
                return COOPERATE  // Give one more chance
```

### Edge Cases

1. **First Round**: Always cooperate to signal cooperative intent and help establish a cooperative norm.

2. **Last Round**: 
   - Cooperate if the previous round succeeded (maintaining the pattern)
   - Cooperate if we were just one short of threshold (heroic attempt)
   - Otherwise defect (no future rounds to build on)

3. **After Multiple Failures**: 
   - Allow up to 2 consecutive failures before considering defection
   - Even then, defect only if cooperation seems truly hopeless

4. **Tie-breaking**: When cooperation count equals exactly m-2, lean toward cooperation to provide leadership.

### Cooperative Alignment

This strategy embodies cooperation through:

1. **Leadership**: Takes initiative when cooperation is close to threshold
2. **Persistence**: Doesn't abandon cooperation after single failures  
3. **Optimism**: Looks for positive trends and opportunities to restore cooperation
4. **Forgiveness**: Gives multiple chances before defecting
5. **Signal Clarity**: Consistent cooperation sends clear cooperative signals

### Strategic Rationale

- **Threshold Awareness**: Recognizes that being the (m)th cooperator is crucial
- **Trend Sensitivity**: Responds to improving cooperation patterns
- **Sustainable Cooperation**: Balances immediate cooperation with long-term sustainability
- **Risk Management**: Protects against total exploitation while maintaining cooperative stance

This strategy aims to be the "cooperative backbone" that other players can rely on, while still being strategically sound enough to avoid systematic exploitation. It prioritizes collective success (everyone getting k+1 total payoff when threshold is met) over individual optimization.
'''

description_COOPERATIVE_47 = '''
# Cooperative Strategy: "Adaptive Trust Builder"

## Core Philosophy
This strategy prioritizes collective welfare while maintaining resilience against exploitation. It assumes other cooperative strategies exist in the tournament and aims to coordinate with them to achieve mutual benefit.

## Strategy Description

### 1. Decision Rules

**Primary Cooperation Condition:**
- Cooperate if the expected number of cooperators (including myself) ≥ m

**Expected Cooperators Calculation:**
For each opponent j, maintain a cooperation probability estimate p_j based on their recent behavior:
- p_j = (cooperations by j in last 3 rounds) / min(3, current_round)
- Expected cooperators = 1 + Σ(p_j for all opponents j)

**Confidence Threshold:**
- If expected cooperators ≥ m + 0.5: Cooperate with high confidence
- If m - 0.5 ≤ expected cooperators < m + 0.5: Use tie-breaking rules
- If expected cooperators < m - 0.5: Defect to avoid waste

### 2. Tie-Breaking Rules (when near threshold)
1. **Trend Analysis**: If cooperation trend is increasing over last 3 rounds → Cooperate
2. **Risk Assessment**: If we're in early/middle game (round ≤ 0.7r) → Cooperate (build trust)
3. **Default**: Cooperate (pro-cooperative bias)

### 3. Edge Cases

**First Round:**
- Always Cooperate (signal cooperative intent and optimism about others)

**Last Round (round r):**
- Cooperate if expected cooperators ≥ m (no future rounds to worry about free-riding)

**Early Rounds (rounds 2-3):**
- Maintain optimistic estimates for players with insufficient history
- Weight recent cooperation attempts more heavily to encourage reciprocation

**Recovery Mode:**
- If cooperation failed in previous round due to insufficient participants, increase cooperation probability estimates by 0.1 for any player who cooperated (reward cooperative attempts)

## Pseudocode

```python
def decide_action(self, round_num, history):
    # First round: always cooperate
    if round_num == 1:
        return COOPERATE
    
    # Calculate cooperation probabilities for each opponent
    coop_probs = []
    for opponent in opponents:
        recent_history = get_last_n_rounds(opponent, min(3, round_num-1))
        if len(recent_history) == 0:
            prob = 0.7  # Optimistic default for new players
        else:
            prob = count_cooperations(recent_history) / len(recent_history)
            
            # Bonus for cooperative attempts in failed rounds
            if was_previous_round_failed() and opponent_cooperated_last_round(opponent):
                prob = min(1.0, prob + 0.1)
                
        coop_probs.append(prob)
    
    # Expected cooperators including myself
    expected_cooperators = 1 + sum(coop_probs)
    
    # Decision logic
    if expected_cooperators >= m + 0.5:
        return COOPERATE
    elif expected_cooperators < m - 0.5:
        return DEFECT
    else:
        # Tie-breaking
        if is_cooperation_trending_up():
            return COOPERATE
        elif round_num <= 0.7 * total_rounds:
            return COOPERATE  # Build trust in early/mid game
        else:
            return COOPERATE  # Pro-cooperative default
```

## Cooperative Alignment

This strategy embodies cooperation through:

1. **Trust Building**: Always cooperates first round to signal good intentions
2. **Optimistic Assumptions**: Gives benefit of doubt to new/uncertain players  
3. **Forgiveness**: Rewards cooperative attempts even in failed rounds
4. **Risk Sharing**: Willing to cooperate even in uncertain situations (tie-breaking toward cooperation)
5. **Long-term Focus**: Prioritizes relationship building in early/mid game over short-term gains

## Expected Performance

This strategy should perform well when:
- Multiple cooperative strategies are present (likely in this tournament context)
- Players can learn and adapt over multiple rounds
- The reward factor k makes mutual cooperation significantly better than mutual defection

The strategy balances cooperative intent with practical risk assessment, making it robust against some exploitation while maintaining strong cooperative signals for reciprocal strategies.
'''

description_COOPERATIVE_48 = '''
# Cooperative Strategy: "Conditional Cooperator with Trust Building"

## Core Philosophy
This strategy prioritizes collective welfare while being resilient to exploitation. It aims to establish and maintain cooperation by being initially generous, responsive to others' cooperation levels, and forgiving of occasional defections.

## Decision Rules

### Round 1: Unconditional Cooperation
- **Action**: Always COOPERATE
- **Rationale**: Signal cooperative intent and give others the benefit of the doubt

### Rounds 2 to r-1: Conditional Cooperation Based on Collective Behavior
```pseudocode
if round == 1:
    return COOPERATE

cooperation_rate = count_cooperators_last_round / n
threshold_safety = (m - 1) / n  // Just below minimum threshold

if cooperation_rate >= threshold_safety:
    return COOPERATE
else:
    // Check if cooperation is trending upward
    if round > 2:
        prev_cooperation_rate = count_cooperators_two_rounds_ago / n
        if cooperation_rate > prev_cooperation_rate:
            return COOPERATE  // Reward positive trend
    
    return DEFECT  // Protect against likely failure
```

### Final Round: Forgiveness and Future-Building
- **Action**: COOPERATE if cooperation rate in previous round ≥ (m-2)/n
- **Rationale**: End on a positive note unless cooperation has completely collapsed

## Key Features

### 1. Threshold-Aware Cooperation
- Cooperates when the group appears likely to meet the minimum threshold (m)
- Uses (m-1)/n as the decision threshold, accounting for own contribution

### 2. Trend Recognition
- Considers whether cooperation is increasing between rounds
- Rewards upward trends even if absolute levels are low
- Helps groups recover from temporary coordination failures

### 3. Graduated Response
- Not purely tit-for-tat; considers collective behavior rather than individual actions
- Allows for some defection without immediately abandoning cooperation

### 4. Forgiveness Mechanism
- Returns to cooperation in final round unless situation is hopeless
- First round cooperation establishes goodwill
- Trend-based decisions allow recovery from bad rounds

## Edge Case Handling

**First Round**: Always cooperate to signal cooperative intent

**Last Round**: Cooperate unless previous round had very low cooperation (< (m-2)/n), maintaining long-term relationship building mindset

**Low Information Rounds** (rounds 2-3): Rely more heavily on cooperation rates since trend data is limited

**Minimum Threshold Scenarios**: 
- If m is very close to n, be more generous with cooperation
- If m is low relative to n, be more selective but still responsive to trends

## Cooperative Alignment

This strategy embodies cooperation by:
- **Starting with trust** (first round cooperation)
- **Supporting collective success** (threshold-aware decisions)
- **Encouraging others** (rewarding positive trends)
- **Building relationships** (forgiveness and final round cooperation)
- **Balancing idealism with realism** (protecting against certain failure while maximizing collective opportunities)

The strategy aims to find and maintain the sweet spot where the group consistently meets the cooperation threshold, maximizing everyone's payoffs while being robust against moderate levels of defection.
'''

description_COOPERATIVE_49 = '''
# Cooperative Strategy: "Adaptive Trust Builder"

## Core Philosophy
This strategy is built on the principle that cooperation is mutually beneficial, but requires trust-building and adaptation to succeed against diverse opponents. It aims to maximize collective welfare while protecting against exploitation.

## Strategy Description

### 1. Decision Rules

**Primary Cooperation Trigger:**
- Cooperate when the expected number of cooperators (including myself) ≥ m
- Use adaptive learning to estimate cooperation likelihood of other players

**Trust-Based Cooperation:**
- Maintain a "trust score" for each observable player based on their cooperation history
- Weight recent rounds more heavily than distant ones (exponential decay)

### 2. Detailed Algorithm

```pseudocode
INITIALIZE:
- cooperation_history = empty array for each player
- trust_scores = array of 0.5 for each player (neutral start)
- my_cooperation_rate = 0.0
- rounds_played = 0
- decay_factor = 0.8

FOR each round t:
    IF t == 1:  // First round
        decision = COOPERATE  // Lead by example
    
    ELSE IF t == r:  // Last round
        expected_cooperators = estimate_cooperators()
        IF expected_cooperators >= m-1:  // Need m-1 others + me
            decision = COOPERATE
        ELSE:
            decision = COOPERATE  // Stay cooperative even if risky
    
    ELSE:  // Middle rounds
        // Update trust scores based on last round
        FOR each player j:
            IF player j cooperated in round t-1:
                trust_scores[j] = trust_scores[j] * decay_factor + (1-decay_factor) * 1.0
            ELSE:
                trust_scores[j] = trust_scores[j] * decay_factor + (1-decay_factor) * 0.0
        
        // Estimate expected cooperators
        expected_cooperators = estimate_cooperators()
        
        // Decision logic
        IF expected_cooperators >= m-1:
            decision = COOPERATE
        ELSE IF trust_scores.average() > 0.3:  // Give benefit of doubt
            decision = COOPERATE
        ELSE:
            // Try to encourage cooperation with conditional cooperation
            IF (rounds_since_threshold_met <= 2) OR (t <= r/3):
                decision = COOPERATE  // Early rounds or recent success
            ELSE:
                decision = COOPERATE  // Remain cooperative but cautious
    
    EXECUTE decision
    UPDATE cooperation_history and statistics

FUNCTION estimate_cooperators():
    expected = 1  // Count myself as cooperating
    FOR each other player j:
        expected += trust_scores[j]
    RETURN expected
```

### 3. Key Features

**Adaptive Learning:**
- Trust scores evolve based on observed behavior
- Recent actions weighted more heavily (decay_factor = 0.8)
- Estimates cooperation likelihood for threshold calculations

**Forgiveness Mechanism:**
- Doesn't permanently punish defectors
- Trust scores can recover if players return to cooperation
- Maintains optimistic outlook to encourage group cooperation

**Strategic Cooperation:**
- Always cooperates in first round to signal cooperative intent
- Maintains cooperation in final round to avoid end-game defection spiral
- Uses probabilistic threshold checking rather than rigid rules

### 4. Edge Case Handling

**First Round:** Always cooperate to establish cooperative precedent and signal trustworthiness.

**Last Round:** Cooperate to maintain consistency and avoid triggering mutual defection in final round.

**Insufficient History:** Start with neutral trust (0.5) and lean toward cooperation in early rounds.

**All Players Defecting:** Continue occasional cooperation attempts to break deadlock and signal willingness to restart cooperation.

**Near Threshold:** When expected cooperators is close to m-1, err on the side of cooperation to help achieve the threshold.

### 5. Cooperative Alignment

This strategy embodies cooperation through:
- **Trust-building:** Starts cooperatively and gives others chances to prove trustworthiness
- **Collective focus:** Prioritizes achieving the cooperation threshold for mutual benefit
- **Persistence:** Maintains cooperative stance even when facing setbacks
- **Leadership:** Takes initiative to cooperate first and signals cooperative intent
- **Adaptability:** Adjusts to different opponent types while maintaining cooperative core

The strategy balances naive cooperation (which invites exploitation) with strategic cooperation (which builds sustainable mutual benefit), making it robust against various opponent strategies while maintaining a fundamentally cooperative approach.
'''

description_COOPERATIVE_50 = '''
# Cooperative Strategy: "Generous Threshold Guardian"

## Core Philosophy
This strategy prioritizes collective welfare while being resilient to occasional defections. It aims to maintain cooperation when the threshold is achievable while protecting against systematic exploitation.

## Decision Rules

### Round 1: Unconditional Cooperation
- **Action**: Always cooperate (C)
- **Rationale**: Establish cooperative intent and give the collective the best chance to succeed from the start

### Rounds 2 to r-1: Adaptive Cooperation
For each round t (where 2 ≤ t ≤ r-1):

```pseudocode
cooperation_rate = (cooperators_last_round) / n
threshold_met_last_round = (cooperators_last_round >= m)

IF threshold_met_last_round:
    // Threshold was met - reward cooperation
    IF cooperation_rate >= 0.7:
        Action = C  // High cooperation deserves continued support
    ELSE IF cooperation_rate >= (m/n):
        Action = C  // Threshold met, maintain cooperation
    ELSE:
        Action = C  // Still cooperate but note concerning trend
ELSE:
    // Threshold was NOT met - adaptive response
    IF cooperation_rate >= 0.8:
        Action = C  // Near-universal cooperation failed due to bad luck
    ELSE IF cooperation_rate >= (m-1)/n:
        Action = C  // Close to threshold, one more cooperator might tip it
    ELSE IF cooperation_rate >= 0.3:
        Action = D  // Moderate defection, protect against exploitation
    ELSE:
        Action = D  // High defection rate, avoid being exploited
```

### Final Round (Round r): Conditional Cooperation
```pseudocode
recent_cooperation_trend = average cooperation rate over last min(3, r-1) rounds
threshold_success_rate = (number of rounds where threshold was met) / (r-1)

IF threshold_success_rate >= 0.6:
    Action = C  // Reward successful collective behavior
ELSE IF recent_cooperation_trend >= (m+1)/n:
    Action = C  // Recent trend suggests threshold achievable
ELSE IF recent_cooperation_trend >= 0.5:
    Action = C  // Give benefit of doubt in final round
ELSE:
    Action = D  // Protect against final round exploitation
```

## Edge Case Handling

### Very Small Groups (n ≤ 4)
- Be more forgiving of defections since each player's decision has larger impact
- Cooperate unless cooperation rate drops below 25%

### High Threshold Scenarios (m > 0.75n)
- Maintain cooperation more persistently since achieving threshold requires near-universal cooperation
- Only defect if cooperation rate drops below 40%

### Low Reward Scenarios (k ≤ 1.5)
- Standard rules apply but be slightly more cautious about exploitation
- Require cooperation rate of at least 60% (instead of 50%) in final round decision

## Key Features

1. **Generous Start**: Always cooperate in round 1 to signal cooperative intent
2. **Threshold Awareness**: Considers both whether threshold was met and how close we came
3. **Trend Analysis**: Looks at cooperation patterns, not just single-round snapshots
4. **Exploitation Protection**: Will defect when cooperation rates are too low to avoid being taken advantage of
5. **Forgiveness**: Returns to cooperation when others demonstrate renewed commitment
6. **Endgame Consideration**: Final round logic prevents exploitation while rewarding sustained cooperation

## Cooperative Alignment

This strategy embodies cooperation through:
- **Default to Cooperation**: Cooperates whenever reasonably safe to do so
- **Collective Focus**: Decisions based on achieving the threshold for everyone's benefit
- **Forgiveness**: Returns to cooperation after others show renewed commitment
- **Long-term Thinking**: Considers patterns over multiple rounds rather than reacting to single rounds
- **Generous Interpretation**: Gives benefit of doubt in ambiguous situations

The strategy balances the cooperative ideal with practical considerations, ensuring that cooperation is sustained when reciprocated while protecting against systematic exploitation.
'''

description_COOPERATIVE_51 = '''
# Cooperative Strategy: "Threshold-Aware Reciprocal Cooperation" (TARC)

## Core Philosophy
This strategy prioritizes collective welfare while being resilient to exploitation. It aims to establish and maintain cooperation when possible, while protecting against free-riders through measured responses.

## Decision Rules

### 1. First Round
**Always COOPERATE** - Start with good faith to signal cooperative intent and help establish trust.

### 2. Cooperation Assessment (Rounds 2 onwards)
Track the cooperation level from the previous round:
- `prev_cooperators = number of players who cooperated in round t-1`
- `cooperation_rate = prev_cooperators / n`

### 3. Main Decision Logic

```pseudocode
if round == 1:
    return COOPERATE

if round == final_round:
    if cooperation_rate_last_3_rounds >= (m/n):
        return COOPERATE
    else:
        return DEFECT

// Core reciprocal logic for middle rounds
if prev_cooperators >= m:
    // Threshold was met - reward the group
    if cooperation_rate >= 0.6:
        return COOPERATE  // Strong cooperation
    else:
        return COOPERATE  // Still cooperate but monitor
        
else if prev_cooperators >= (m-1):
    // Close to threshold - be encouraging
    return COOPERATE
    
else if prev_cooperators >= max(2, m-2):
    // Some cooperation exists - conditional support
    if my_recent_cooperation_rate >= 0.7:
        return COOPERATE  // I've been cooperative
    else:
        return COOPERATE  // Give another chance
        
else:
    // Low cooperation - protective response
    if cooperation_rate < 0.3 AND round > 3:
        return DEFECT  // Protect against exploitation
    else:
        return COOPERATE  // Try to restart cooperation
```

### 4. Forgiveness Mechanism
- Every 3-4 rounds, reassess the group's cooperation trend
- If cooperation has been increasing, return to full cooperation
- Avoid permanent punishment cycles

## Edge Case Handling

### First Round
- Always COOPERATE to establish cooperative baseline

### Last Round
- If cooperation has been sustained (≥60% rate over last 3 rounds): COOPERATE
- Otherwise: DEFECT (end-game defection protection)

### Low Participation Games (n ≤ 4)
- Be more forgiving since each player's impact is higher
- Lower the cooperation rate thresholds by 10%

### High Threshold Games (m/n > 0.7)
- Be more persistent in cooperation since collective success is harder
- Only defect if cooperation rate drops below 0.2

## Key Features

1. **Cooperative by Default**: Starts cooperatively and maintains cooperation when group reciprocates

2. **Threshold Awareness**: Recognizes when the group is close to the critical threshold (m) and provides crucial support

3. **Graduated Response**: Doesn't immediately punish but provides measured responses to declining cooperation

4. **Forgiveness**: Includes mechanisms to restart cooperation after periods of defection

5. **End-game Protection**: Prevents exploitation in final rounds while rewarding sustained cooperation

6. **Adaptive**: Adjusts behavior based on group size and threshold requirements

## Strategic Rationale

This strategy balances the cooperative imperative with protection against exploitation. It:
- Encourages cooperation through initial trust and reciprocation
- Maintains cooperation when the group is performing well
- Provides crucial support when the group is near the threshold
- Protects against persistent free-riding
- Allows for recovery from cooperation breakdowns
- Maximizes long-term collective welfare while avoiding naive exploitation

The strategy is particularly effective when facing other cooperative or conditionally cooperative strategies, while providing reasonable protection against more exploitative approaches.
'''

description_COOPERATIVE_52 = '''
# Cooperative Strategy: "Adaptive Trust Builder"

## Core Philosophy
This strategy is built on the principle that cooperation is mutually beneficial when we can build sufficient trust and momentum. It balances being a good citizen who contributes to collective welfare while being adaptive to the actual behavior patterns of other players.

## Decision Rules

### Phase 1: Trust Building (First 20% of rounds)
- **Always Cooperate** in the initial rounds to:
  - Signal cooperative intent to other players
  - Help establish early patterns of cooperation
  - Build trust and reciprocity norms

### Phase 2: Adaptive Cooperation (Middle rounds)
- **Primary Rule**: Cooperate if the cooperation rate in the previous round was ≥ (m-1)/n
  - This means we cooperate when we're likely just one of the few needed to reach threshold
  - Shows commitment to collective success when others are trying
  
- **Secondary Rule**: If cooperation has been consistently high (≥ m cooperators in last 3 rounds), continue cooperating
  - Maintains momentum when cooperation is working

- **Forgiveness Mechanism**: After any round where threshold wasn't met, give the group one "reset" chance by cooperating in the next round
  - Prevents spiral into mutual defection from temporary coordination failures

### Phase 3: Endgame Cooperation (Last 10% of rounds)
- **Cooperative Finish**: Always cooperate in the final rounds
  - Even if recent cooperation has been low, maintain cooperative stance
  - Prevents last-minute defection cascade
  - Shows long-term commitment to collective welfare

## Edge Case Handling

### First Round
- **Always Cooperate** - No information available, so lead by example and signal cooperative intent

### When Threshold Consistently Missed
- If threshold hasn't been met for 3+ consecutive rounds in middle phase:
  - Still cooperate every 3rd round to test if group can recover
  - Continue being part of the solution rather than abandoning hope

### Near-Threshold Situations
- When cooperation count in previous round was exactly (m-1):
  - **Always Cooperate** - We're likely one of the key players needed
  - High probability our cooperation will tip the group over threshold

### Last Round
- **Always Cooperate** - Maintain cooperative identity even when no future rounds to influence

## Pseudocode

```python
def decide_action(round_num, total_rounds, previous_round_actions, history):
    # Phase boundaries
    trust_building_end = max(1, total_rounds * 0.2)
    endgame_start = total_rounds * 0.9
    
    # Phase 1: Trust Building
    if round_num <= trust_building_end:
        return COOPERATE
    
    # Phase 3: Endgame Cooperation  
    if round_num >= endgame_start:
        return COOPERATE
    
    # Phase 2: Adaptive Cooperation
    if round_num == 1:  # First round edge case
        return COOPERATE
    
    # Count cooperators in previous round
    prev_cooperators = count_cooperators(previous_round_actions)
    
    # Primary rule: cooperate when close to threshold
    if prev_cooperators >= (m - 1):
        return COOPERATE
    
    # Secondary rule: maintain momentum if cooperation working
    if rounds_with_threshold_met(history, last_n=3) >= 3:
        return COOPERATE
    
    # Forgiveness mechanism: reset after failures
    if not threshold_met_last_round(history) and should_give_reset_chance():
        return COOPERATE
    
    # Test recovery every 3rd round during low cooperation periods
    consecutive_failures = count_consecutive_threshold_failures(history)
    if consecutive_failures >= 3 and (consecutive_failures % 3 == 0):
        return COOPERATE
    
    # Default: cooperate when previous cooperation rate suggests we're needed
    cooperation_rate = prev_cooperators / n
    threshold_rate = (m - 1) / n
    
    if cooperation_rate >= threshold_rate:
        return COOPERATE
    else:
        return COOPERATE  # Stay cooperative even when uncertain
```

## Why This Strategy is Cooperative

1. **Default to Cooperation**: The strategy assumes cooperation is the goal and only adjusts based on group dynamics, never abandoning the cooperative mindset

2. **Trust Building**: Actively invests in early cooperation to establish positive group norms

3. **Threshold Awareness**: Specifically designed to help the group reach the minimum cooperation threshold rather than free-riding

4. **Forgiveness**: Doesn't punish the group permanently for coordination failures - always willing to try again

5. **Endgame Integrity**: Maintains cooperative stance even in final rounds when temptation to defect is highest

This strategy recognizes that in a collective risk scenario, mutual cooperation creates the best outcomes for everyone, and focuses on being the kind of player that helps achieve those outcomes consistently.
'''

description_COOPERATIVE_53 = '''
# Cooperative Strategy: "Optimistic Threshold Guardian"

## Core Philosophy
This strategy aims to maximize collective welfare while maintaining resilience against defection. It operates on the principle of being "cautiously optimistic" - always trying to achieve the cooperation threshold while protecting against being exploited.

## Strategy Description

### Decision Rules

**Primary Rule: Threshold-Aware Cooperation**
- Always cooperate if my cooperation is necessary to reach the threshold `m`
- Cooperate if I expect exactly `m` cooperators (including myself) will emerge
- Consider defecting only when cooperation is "safe" (when `m+` others will likely cooperate)

### Detailed Algorithm

```pseudocode
Strategy: Optimistic Threshold Guardian

Initialize:
- cooperation_history[player][round] = empty
- trust_scores[player] = 1.0 (start optimistic)
- threshold_buffer = 1 (safety margin above minimum m)

For each round t:

1. FIRST ROUND (t = 1):
   Action = COOPERATE
   Rationale: Start optimistically to signal cooperative intent

2. MIDDLE ROUNDS (1 < t < r):
   
   a) Calculate expected cooperators:
      expected_coop = 0
      For each other player j:
          cooperation_rate_j = (cooperations by j) / (rounds so far - 1)
          trust_scores[j] = decay * trust_scores[j] + (1-decay) * cooperation_rate_j
          if trust_scores[j] > 0.6:
              expected_coop += 1
   
   b) Decision logic:
      if expected_coop < (m - 1):
          Action = COOPERATE  // Threshold at risk, must cooperate
      elif expected_coop >= (m + threshold_buffer):
          if random() < 0.3:  // Occasionally defect when "safe"
              Action = DEFECT
          else:
              Action = COOPERATE  // Usually still cooperate for stability
      else:
          Action = COOPERATE  // Near threshold, be safe

3. LAST ROUND (t = r):
   
   Calculate expected cooperators (same as above)
   
   if expected_coop < (m - 1):
       Action = COOPERATE  // Must ensure threshold
   elif expected_coop >= (m + 2):  // Higher buffer for last round
       Action = DEFECT     // Safe to defect for extra payoff
   else:
       Action = COOPERATE  // Default to cooperation
```

### Key Features

**1. Optimistic Start**
- Begin with cooperation to signal trustworthiness
- Assume others will reciprocate initially

**2. Adaptive Trust Tracking**
- Maintain trust scores for each player based on their cooperation history
- Use exponential decay to weight recent behavior more heavily

**3. Threshold-Centric Decisions**
- Primary concern is ensuring the group reaches threshold `m`
- Only consider defection when significantly above threshold

**4. Strategic Last Round**
- Slightly more willing to defect in final round when safe
- Still prioritizes threshold achievement over personal gain

**5. Safety Margins**
- Use buffer above minimum threshold to account for uncertainty
- Conservative approach to avoid threshold failures

### Edge Case Handling

**First Round**: Always cooperate to establish cooperative reputation

**Last Round**: Apply higher safety buffer before considering defection

**All Defectors Detected**: Continue cooperating if others show any cooperation tendency

**Threshold Consistently Failed**: Maintain cooperation to try to rebuild collective behavior

**Highly Cooperative Group**: Occasionally defect when very safe (expected cooperators >> m+2)

## Rationale

This strategy balances three key objectives:

1. **Collective Welfare**: Prioritizes group success by ensuring threshold achievement
2. **Exploitation Resistance**: Tracks player behavior to avoid being systematically exploited  
3. **Strategic Flexibility**: Allows occasional defection when the group can sustain it

The strategy is fundamentally cooperative because it:
- Defaults to cooperation in uncertain situations
- Actively works to maintain the cooperation threshold
- Only defects when it won't harm collective outcomes
- Starts optimistically and maintains trust-building behavior

This approach should perform well against other cooperative strategies while providing reasonable protection against exploitation.
'''

description_COOPERATIVE_54 = '''
# Cooperative Strategy: "Graduated Reciprocal Cooperation" (GRC)

## Core Philosophy
This strategy prioritizes collective welfare while maintaining resilience against exploitation. It assumes other cooperative strategies exist in the tournament and seeks to identify and collaborate with them effectively.

## Decision Rules

### Round 1: Optimistic Start
- **Action: COOPERATE**
- **Rationale:** Signal cooperative intent and test for reciprocal cooperation from others

### Rounds 2 to r-1: Adaptive Cooperation

**Primary Rule - Cooperation Threshold Assessment:**
```
if (cooperators_last_round >= m):
    action = COOPERATE
else:
    # Graduated response based on cooperation level
    cooperation_ratio = cooperators_last_round / (n-1)
    
    if (cooperation_ratio >= 0.6):
        action = COOPERATE  # High cooperation, stay committed
    elif (cooperation_ratio >= 0.4):
        # Medium cooperation - give benefit of doubt but track trend
        if (cooperation_trend_improving()):
            action = COOPERATE
        else:
            action = DEFECT
    else:
        action = DEFECT  # Low cooperation, protect against exploitation
```

**Secondary Rule - Forgiveness Mechanism:**
```
# Every 3 rounds, attempt to restart cooperation if it broke down
if (round_number % 3 == 0 AND last_action == DEFECT):
    if (cooperators_last_round >= m/2):  # Some cooperation still exists
        action = COOPERATE  # Attempt reconciliation
```

### Final Round (Round r): Conditional Cooperation
```
if (cooperators_last_round >= m-1):
    # Threshold likely achievable, cooperate for mutual benefit
    action = COOPERATE
elif (cooperators_last_round >= m/2 AND personal_total_payoff < average_expected_payoff):
    # Behind in score, take calculated risk for catch-up
    action = COOPERATE
else:
    # Low probability of threshold, secure guaranteed payoff
    action = DEFECT
```

## Edge Case Handling

### Threshold Dynamics
- **When exactly at threshold (m cooperators):** Continue cooperating to maintain stability
- **When one below threshold (m-1 cooperators):** Cooperate if cooperation trend is stable/improving
- **Unanimous defection scenario:** Switch to cooperation every 4th round to test for recovery

### Information Tracking
Maintain running calculations of:
- Cooperation rates over last 3 rounds (trend analysis)
- Personal payoff relative to theoretical maximums
- Identification of consistently cooperative players

## Cooperative Alignment Features

1. **Default Cooperation:** Starts cooperative and maintains cooperation bias
2. **Collective Benefit Priority:** Willing to sacrifice short-term individual gains when threshold is achievable
3. **Forgiveness:** Periodically attempts to restore broken cooperation
4. **Proportional Response:** Defection intensity matches the level of non-cooperation observed
5. **End-game Cooperation:** Avoids pure self-interest in final round when collective benefit is possible

## Strategic Rationale

This strategy balances three key objectives:
- **Maximizing collective outcomes** when facing other cooperative strategies
- **Preventing exploitation** by purely selfish strategies
- **Maintaining flexibility** to adapt to mixed environments

The graduated response system ensures the strategy doesn't abandon cooperation too quickly while still protecting against sustained exploitation. The forgiveness mechanism allows recovery from temporary coordination failures, which is crucial in multi-round games where communication is impossible.
'''

description_COOPERATIVE_55 = '''
# Cooperative Strategy: "Cautious Catalyst"

## Core Philosophy
This strategy aims to maximize collective welfare while being resilient to exploitation. It operates on the principle of being a "catalyst" for cooperation - initiating and maintaining cooperative behavior when feasible, but protecting against systematic exploitation.

## Decision Rules

### Round 1: Conditional Cooperation Start
**Always COOPERATE** in the first round to signal cooperative intent and help establish a cooperative equilibrium.

### Rounds 2 to r-1: Adaptive Threshold Monitoring
```pseudocode
cooperators_last_round = count_cooperators(previous_round)
cooperation_trend = calculate_trend(last_3_rounds)  // if available

if cooperators_last_round >= m:
    // Threshold was met - reinforce success
    COOPERATE
else if cooperators_last_round >= (m - 1):
    // Close to threshold - be forgiving, help push over
    COOPERATE
else if cooperators_last_round >= max(2, m/2):
    // Moderate cooperation exists - conditional cooperation
    if cooperation_trend >= 0:  // stable or improving
        COOPERATE
    else:
        DEFECT
else:
    // Low cooperation - defect but leave door open for recovery
    if (round_number % 3 == 0):  // periodic cooperation signal
        COOPERATE
    else:
        DEFECT
```

### Final Round (Round r): Calculated Finish
```pseudocode
cooperators_last_round = count_cooperators(previous_round)
recent_cooperation_rate = calculate_cooperation_rate(last_3_rounds)

if recent_cooperation_rate >= 0.6 AND cooperators_last_round >= (m-1):
    // High cooperation environment - maintain cooperation
    COOPERATE
else if cooperators_last_round >= m:
    // Threshold met last round - reciprocate
    COOPERATE
else:
    // Low cooperation or threshold unlikely - defect
    DEFECT
```

## Supporting Functions

### Trend Calculation
```pseudocode
calculate_trend(rounds_data):
    if insufficient_data: return 0
    recent_avg = average_cooperators(last_2_rounds)
    earlier_avg = average_cooperators(rounds_before_that)
    return recent_avg - earlier_avg
```

### Cooperation Rate
```pseudocode
calculate_cooperation_rate(rounds_data):
    total_possible = n * number_of_rounds_in_data
    total_cooperators = sum_all_cooperators(rounds_data)
    return total_cooperators / total_possible
```

## Edge Case Handling

1. **First Round**: Always cooperate to establish cooperative tone
2. **Insufficient History**: Default to cooperation when trend data unavailable
3. **Exactly m-1 Cooperators**: Always cooperate to help reach threshold
4. **All Others Defecting**: Still send periodic cooperation signals (every 3rd round) to enable recovery
5. **Final Round**: Balance between reciprocating good cooperation and protecting against exploitation

## Cooperative Alignment

This strategy embodies cooperation through:

- **Proactive Cooperation**: Starts cooperatively and maintains cooperation when others reciprocate
- **Threshold Assistance**: Actively helps reach the minimum threshold (m) by cooperating when close
- **Forgiveness**: Continues cooperating even when slightly below threshold
- **Recovery Facilitation**: Sends periodic cooperation signals even in low-cooperation environments
- **Collective Welfare**: Prioritizes group success over individual short-term gains

## Strategic Rationale

1. **Catalyst Effect**: By cooperating when we're close to threshold, we help tip the group into the beneficial equilibrium
2. **Resilience**: The strategy protects against systematic exploitation while remaining open to cooperation
3. **Signal Clarity**: Consistent cooperation when threshold is met signals reliability to other cooperative strategies
4. **Adaptive Response**: Adjusts behavior based on group dynamics rather than rigid rules

This strategy should perform well against other cooperative strategies while maintaining reasonable defense against exploitative ones, ultimately promoting the collective good that defines the cooperative approach.
'''

description_COOPERATIVE_56 = '''
# Cooperative Strategy: "Adaptive Trust Builder"

## Core Philosophy
This strategy prioritizes collective welfare while maintaining resilience against exploitation. It assumes other cooperative strategies exist in the tournament and aims to identify and collaborate with them to achieve mutual benefit.

## Decision Rules

### Round 1: Optimistic Start
- **Action: COOPERATE**
- **Rationale:** Signal cooperative intent and test the cooperative potential of the group

### Rounds 2 to r-1: Adaptive Cooperation
Use a three-factor decision system:

```pseudocode
cooperation_score = 0.4 * recent_cooperation_rate + 
                   0.4 * threshold_proximity_factor + 
                   0.2 * trend_factor

if cooperation_score >= 0.6:
    action = COOPERATE
else:
    action = DEFECT
```

**Factor Calculations:**

1. **Recent Cooperation Rate** (weight: 0.4)
   ```pseudocode
   recent_cooperation_rate = cooperators_in_last_round / (n - 1)
   ```

2. **Threshold Proximity Factor** (weight: 0.4)
   ```pseudocode
   if cooperators_in_last_round >= m - 1:
       threshold_proximity_factor = 1.0  // We can make the difference
   else if cooperators_in_last_round >= m - 2:
       threshold_proximity_factor = 0.7  // Close to threshold
   else:
       threshold_proximity_factor = cooperators_in_last_round / (m - 1)
   ```

3. **Trend Factor** (weight: 0.2)
   ```pseudocode
   if current_round >= 3:
       recent_trend = cooperators_in_last_round - cooperators_two_rounds_ago
       if recent_trend > 0:
           trend_factor = 1.0  // Cooperation increasing
       else if recent_trend == 0:
           trend_factor = 0.5  // Stable
       else:
           trend_factor = 0.0  // Cooperation decreasing
   else:
       trend_factor = 0.5  // Neutral for early rounds
   ```

### Final Round (Round r): Conditional Cooperation
- **If threshold was met in round r-1: COOPERATE**
- **If we were close (≥ m-2 cooperators in round r-1): COOPERATE**
- **Otherwise: DEFECT**

## Edge Case Handling

### Very Small Groups (n ≤ 4)
- Lower the cooperation threshold to 0.5 to account for higher individual impact
- Maintain cooperation longer since each player's contribution is more critical

### High Threshold Scenarios (m > n/2)
- Increase weight of threshold_proximity_factor to 0.5
- Be more willing to cooperate when close to threshold

### Early Tournament Collapse
If cooperation falls below 20% for 3 consecutive rounds before round r/2:
- Switch to "recovery mode": cooperate only if ≥ m-1 others cooperated last round

## Strategic Rationale

1. **Initial Cooperation:** Signals good faith and helps identify other cooperative players
2. **Adaptive Response:** Balances optimism with realism based on observed behavior
3. **Threshold Awareness:** Recognizes when individual cooperation can tip the balance
4. **Trend Sensitivity:** Responds to momentum in group behavior
5. **Endgame Consideration:** Maintains cooperation when beneficial, defects when futile

## Cooperative Alignment

This strategy embodies cooperation through:
- **Leading by example** in early rounds
- **Responding positively** to cooperative signals from others
- **Strategic sacrifice** when it enables group success
- **Resilient cooperation** that doesn't abandon the collective goal after setbacks
- **Endgame cooperation** when the group has shown consistent collaborative behavior

The strategy aims to maximize collective payoffs while protecting against complete exploitation, making it both cooperative and sustainable in a tournament setting.
'''

description_COOPERATIVE_57 = '''
I'll design a cooperative strategy called **"Optimistic Threshold Guardian"** that balances cooperation with strategic awareness of the collective risk structure.

## Strategy: Optimistic Threshold Guardian

### Core Philosophy
This strategy assumes other players are rational and cooperative-minded, but includes safeguards against exploitation. It focuses on ensuring the threshold is met while being forgiving of occasional defections that don't threaten the collective goal.

### Decision Rules

```pseudocode
STRATEGY: Optimistic Threshold Guardian

INITIALIZATION:
- cooperation_history = array of size n (tracking each player's cooperation rate)
- trust_scores = array of size n (initialized to 1.0 for all players)
- consecutive_failures = 0

FOR each round t:
    IF t == 1:
        ACTION = COOPERATE  // Always cooperate in first round
    
    ELSE IF t == r:  // Last round
        predicted_cooperators = count_likely_cooperators(trust_scores, threshold=0.6)
        IF predicted_cooperators >= m:
            ACTION = COOPERATE
        ELSE:
            ACTION = DEFECT  // Don't waste contribution if threshold won't be met
    
    ELSE:  // Middle rounds
        // Update trust scores based on previous round
        update_trust_scores(previous_round_actions)
        
        // Predict cooperation for this round
        predicted_cooperators = count_likely_cooperators(trust_scores, threshold=0.5)
        
        IF consecutive_failures >= 2:
            // If threshold failed twice in a row, be more cautious
            predicted_cooperators = count_likely_cooperators(trust_scores, threshold=0.7)
            IF predicted_cooperators >= m:
                ACTION = COOPERATE
                consecutive_failures = 0
            ELSE:
                ACTION = DEFECT
        
        ELSE IF predicted_cooperators >= m + 1:
            // Comfortable margin - cooperate
            ACTION = COOPERATE
        
        ELSE IF predicted_cooperators >= m:
            // Right at threshold - cooperate to ensure success
            ACTION = COOPERATE
        
        ELSE:
            // Unlikely to reach threshold - defect but give benefit of doubt
            IF random() < 0.3:  // 30% chance to cooperate anyway
                ACTION = COOPERATE
            ELSE:
                ACTION = DEFECT

FUNCTION update_trust_scores(actions):
    FOR each player i:
        IF actions[i] == COOPERATE:
            trust_scores[i] = min(1.0, trust_scores[i] + 0.1)
        ELSE:
            trust_scores[i] = max(0.0, trust_scores[i] - 0.15)

FUNCTION count_likely_cooperators(trust_scores, threshold):
    count = 0
    FOR each player i:
        IF trust_scores[i] >= threshold:
            count += 1
    return count + 1  // +1 for myself if I cooperate
```

### Key Features

1. **Optimistic Start**: Always cooperates in round 1, assuming others are also cooperative.

2. **Trust-Based Prediction**: Maintains trust scores for each player based on their cooperation history, with cooperation increasing trust and defection decreasing it.

3. **Threshold Awareness**: Makes decisions based on predicted likelihood of reaching the minimum threshold (m).

4. **Failure Adaptation**: Becomes more cautious after consecutive threshold failures, requiring higher trust levels to cooperate.

5. **Strategic Last Round**: In the final round, only cooperates if confident the threshold will be met, avoiding wasted contributions.

6. **Forgiveness Mechanism**: Even when predicting threshold failure, occasionally cooperates (30% chance) to give the group benefit of the doubt.

### Edge Case Handling

- **First Round**: Always cooperate to signal cooperative intent
- **Last Round**: Strategic cooperation based on confidence in threshold achievement
- **Consecutive Failures**: Increased caution with higher trust requirements
- **High Trust Environment**: Willing to cooperate even with slim margins
- **Low Trust Environment**: More selective cooperation to avoid waste

### Cooperative Alignment

This strategy is fundamentally cooperative because it:
- Defaults to cooperation when conditions are favorable
- Maintains hope even after failures through the forgiveness mechanism
- Focuses on collective success (threshold achievement) rather than individual payoff maximization
- Only defects strategically when cooperation would likely be wasted
- Builds and maintains trust relationships with other players

The strategy balances the cooperative imperative with rational game theory, ensuring contributions aren't wasted while maximizing opportunities for collective success.
'''

description_COOPERATIVE_58 = '''
# Cooperative Strategy: "Adaptive Trust Builder"

## Core Philosophy
This strategy is built on the principle that cooperation is inherently valuable, but must be strategically managed to avoid exploitation while maximizing collective benefit. The strategy balances trust-building with risk management to achieve sustained cooperation.

## Decision Rules

### 1. Initial Cooperation Phase (Rounds 1-3)
- **Always cooperate** in the first round to signal cooperative intent
- Continue cooperating in rounds 2-3 unless fewer than (m-1) players cooperated in the previous round
- This establishes goodwill while gathering information about opponent tendencies

### 2. Core Strategy (Rounds 4 to r-2)
Apply a **threshold-based cooperation rule**:

```pseudocode
cooperation_threshold = max(m, n * 0.4)  // At least 40% cooperation expected

if (cooperators_last_round >= cooperation_threshold):
    action = COOPERATE
else if (cooperators_last_round >= m-1):
    // Close to threshold - cooperate to help reach it
    action = COOPERATE  
else if (total_cooperators_last_3_rounds >= m * 2):
    // Show some forgiveness if recent cooperation was decent
    action = COOPERATE
else:
    action = DEFECT
```

### 3. Endgame Strategy (Last 2 rounds)
- **Round r-1**: Cooperate if average cooperation rate over all previous rounds ≥ 35%
- **Final round r**: Cooperate if cooperation was successful (≥m cooperators) in round r-1, otherwise defect

## Key Features

### Forgiveness Mechanism
- Track cooperation over rolling 3-round windows
- If recent cooperation trends upward, give players another chance
- Prevents permanent breakdown from temporary coordination failures

### Adaptive Threshold
- Base threshold on both game parameters (m) and observed behavior patterns
- Higher standards when players demonstrate consistent cooperation
- More lenient when cooperation is fragile but present

### Risk Management
- Never cooperate when cooperation rate drops below (m-1)/n for 2+ consecutive rounds
- This prevents being exploited by predominantly defecting populations
- But maintains hope for recovery when close to threshold

### Signaling
- First round cooperation signals cooperative intent
- Consistent cooperation when threshold is met reinforces positive equilibrium
- Strategic defection when threshold isn't met signals that exploitation won't be tolerated

## Edge Case Handling

### First Round
Always cooperate - establishes cooperative credentials and gathers initial information

### When Exactly m-1 Cooperated
Always cooperate to try to push the group over the threshold

### Tie-breaking
When cooperation rates are exactly at boundary conditions, err on the side of cooperation

### All Players Defected Previously
Give one "olive branch" cooperation attempt every 3-4 rounds to test if others are willing to restart cooperation

## Pseudocode Summary

```pseudocode
function decide_action(round_num, history):
    if round_num == 1:
        return COOPERATE
    
    last_cooperators = count_cooperators(history[-1])
    
    if round_num <= 3:
        if last_cooperators >= m-1:
            return COOPERATE
        else:
            return DEFECT
    
    if round_num >= r-1:  // Endgame
        if round_num == r:  // Final round
            return COOPERATE if last_cooperators >= m else DEFECT
        else:  // Second to last
            avg_coop_rate = average_cooperation_rate(history)
            return COOPERATE if avg_coop_rate >= 0.35 else DEFECT
    
    // Core strategy
    threshold = max(m, ceil(n * 0.4))
    recent_coop = sum_cooperators(history[-3:])
    
    if last_cooperators >= threshold:
        return COOPERATE
    else if last_cooperators >= m-1:
        return COOPERATE
    else if recent_coop >= m * 2:
        return COOPERATE
    else:
        return DEFECT
```

## Strategic Rationale

This strategy is cooperative because it:
- **Leads with cooperation** to establish trust
- **Maintains cooperation** when others reciprocate  
- **Forgives occasional defection** to prevent spiral breakdown
- **Supports threshold achievement** even when risky
- **Prioritizes collective benefit** over individual payoff maximization

The strategy recognizes that in a collective risk dilemma, the worst outcome is consistent failure to reach the cooperation threshold. By being strategically cooperative - generous when others cooperate, but not exploitable when they don't - this approach aims to establish and maintain the cooperative equilibrium that benefits everyone.
'''

description_COOPERATIVE_59 = '''
# Cooperative Strategy: "Adaptive Threshold Guardian"

## Core Philosophy
This strategy prioritizes achieving the collective benefit while being resilient to occasional defections from other players. It balances trust-building with practical risk management to maximize long-term cooperation.

## Strategy Description

### 1. Decision Rules

**Primary Cooperation Principle**: Always cooperate unless there's strong evidence that cooperation is futile or being systematically exploited.

**Threshold Monitoring**: Track whether the cooperation threshold (m players) is being met consistently. The strategy adapts based on the cooperation "health" of the group.

**Forgiveness Mechanism**: Don't abandon cooperation after single failures, but respond to persistent patterns of insufficient cooperation.

### 2. Detailed Decision Logic

```pseudocode
STRATEGY: Adaptive Threshold Guardian

INITIALIZE:
  cooperation_streak = 0
  failure_streak = 0
  total_cooperators_history = []
  trust_level = "HIGH" // HIGH, MEDIUM, LOW

FOR each round t:
  
  // First round: Always cooperate to signal good intentions
  IF t == 1:
    RETURN Cooperate
  
  // Calculate recent cooperation patterns
  recent_cooperators = average(last 3 rounds of total_cooperators_history)
  threshold_success_rate = count(rounds where cooperators >= m) / (t-1)
  
  // Determine trust level based on recent history
  IF threshold_success_rate >= 0.8 AND recent_cooperators >= m:
    trust_level = "HIGH"
  ELSE IF threshold_success_rate >= 0.5 AND recent_cooperators >= m-1:
    trust_level = "MEDIUM"  
  ELSE:
    trust_level = "LOW"
  
  // Main decision logic
  SWITCH trust_level:
    
    CASE "HIGH":
      // Always cooperate when group is reliable
      RETURN Cooperate
    
    CASE "MEDIUM":
      // Cooperate but be more cautious near the end
      IF t > 0.9 * r AND recent_cooperators < m:
        RETURN Defect  // Protect against end-game defection
      ELSE:
        RETURN Cooperate
    
    CASE "LOW":
      // Only cooperate if there's realistic hope
      IF recent_cooperators >= m-2 AND t <= 0.8 * r:
        RETURN Cooperate  // Try to salvage cooperation
      ELSE:
        RETURN Defect     // Cut losses
  
  // Special case: Final rounds
  IF t >= r-1:  // Last 2 rounds
    IF trust_level == "HIGH":
      RETURN Cooperate  // Maintain cooperation with reliable group
    ELSE:
      RETURN Defect     // Protect against end-game abandonment

UPDATE history and streaks after each round
```

### 3. Edge Case Handling

**First Round**: Always cooperate to establish cooperative intent and encourage others to do the same.

**Early Rounds (rounds 2-5)**: Maintain cooperation unless there's complete failure (0-1 cooperators), giving the group time to establish patterns.

**Middle Rounds**: Apply the full adaptive logic based on trust levels and recent performance.

**Final Rounds**: 
- If the group has been consistently cooperative (HIGH trust), continue cooperating
- Otherwise, defect in the last 1-2 rounds to avoid exploitation by end-game defectors

**Extreme Scenarios**:
- If no one else ever cooperates (after round 3), switch to permanent defection
- If everyone always cooperates, maintain cooperation throughout

### 4. Cooperative Alignment

This strategy embodies cooperation through:

1. **Default Cooperation**: The baseline is to cooperate unless there's strong reason not to
2. **Forgiveness**: Doesn't punish single failures, focuses on patterns
3. **Trust Building**: Starts with high trust and tries to maintain cooperative momentum
4. **Collective Focus**: Prioritizes achieving the threshold m rather than individual advantage
5. **Reasonable Protection**: Only defects when cooperation is clearly failing or unsustainable

### 5. Key Parameters Response

- **High m/n ratio**: More willing to cooperate even when threshold seems difficult
- **High k value**: Increases incentive to maintain cooperation longer
- **Long games (high r)**: More patient with establishing cooperative patterns
- **Short games**: More aggressive about detecting early failure patterns

This strategy aims to be a "good citizen" that helps establish and maintain cooperation while being smart enough not to be systematically exploited by non-cooperative players.
'''

description_COOPERATIVE_60 = '''
# Cooperative Strategy: "Adaptive Trust Builder"

## Core Philosophy
This strategy prioritizes collective welfare while being adaptive to the group's cooperation level. It aims to foster trust, maintain cooperation, and protect against exploitation through measured responses.

## Decision Rules

### Round 1: Trust Initiative
**Always COOPERATE** in the first round to signal cooperative intent and help establish a positive foundation.

### Rounds 2 to r-1: Adaptive Cooperation
Use a threshold-based approach with forgiveness:

1. **Calculate cooperation rate** from previous round: `coop_rate = cooperators_last_round / n`

2. **Primary decision logic:**
   - If `coop_rate ≥ (m/n)`: **COOPERATE** (threshold was met or nearly met)
   - If `coop_rate < (m/n)` but `coop_rate ≥ 0.5`: **COOPERATE** (majority still cooperating)
   - If `coop_rate < 0.5`: Apply **conditional forgiveness**

3. **Conditional forgiveness** (when coop_rate < 0.5):
   - Track consecutive rounds where threshold was missed
   - If `missed_rounds ≤ 2`: **COOPERATE** (give benefit of doubt)
   - If `missed_rounds > 2`: **DEFECT** (protect against systematic exploitation)

4. **Recovery mechanism:**
   - If currently defecting but cooperation rate increases to ≥ 0.6: **COOPERATE** (signal willingness to rebuild trust)

### Final Round: Conditional Cooperation
- If cooperation has been consistently successful (threshold met in ≥ 70% of previous rounds): **COOPERATE**
- If the group has established trust and reciprocity: **COOPERATE**
- Otherwise: **DEFECT** (no future rounds to rebuild cooperation)

## Pseudocode

```python
def decide_action(round_num, history, n, m, r):
    if round_num == 1:
        return COOPERATE
    
    # Calculate metrics from previous round
    last_round_cooperators = count_cooperators(history[-1])
    coop_rate = last_round_cooperators / n
    threshold_rate = m / n
    
    if round_num == r:  # Final round
        success_rate = calculate_threshold_success_rate(history)
        return COOPERATE if success_rate >= 0.7 else DEFECT
    
    # Main decision logic for middle rounds
    if coop_rate >= threshold_rate:
        return COOPERATE
    
    if coop_rate >= 0.5:
        return COOPERATE
    
    # Low cooperation - check forgiveness conditions
    missed_rounds = count_consecutive_missed_thresholds(history)
    
    if missed_rounds <= 2:
        return COOPERATE  # Forgiveness period
    
    # Check for recovery signals
    if currently_defecting() and coop_rate >= 0.6:
        return COOPERATE  # Rebuild trust
    
    return DEFECT  # Protect against exploitation
```

## Key Features

### 1. **Cooperative Foundation**
- Starts with cooperation to establish trust
- Maintains cooperation when threshold is met or close to being met
- Prioritizes collective benefit over individual gain

### 2. **Adaptive Response**
- Responds to group cooperation levels
- More forgiving when cooperation is moderate
- More protective when cooperation is very low

### 3. **Forgiveness Mechanism**
- Doesn't immediately punish occasional defection
- Allows for recovery and trust rebuilding
- Signals willingness to cooperate when others show improvement

### 4. **Edge Case Handling**
- **First round**: Always cooperate (trust building)
- **Final round**: Conditional based on historical success
- **Recovery scenarios**: Quick return to cooperation when conditions improve

### 5. **Protection Against Exploitation**
- Defects when facing persistent non-cooperation
- Balances cooperation with self-protection
- Maintains leverage for encouraging future cooperation

This strategy embodies cooperative principles while being robust enough to handle various opponent behaviors, making it suitable for a tournament environment where maintaining the collective good is paramount.
'''

description_COOPERATIVE_61 = '''
# Cooperative Strategy: "Adaptive Trust Builder"

## Core Philosophy
This strategy prioritizes collective welfare while maintaining resilience against exploitation. It assumes other players may also be cooperative-minded but need to balance trust-building with protection against purely selfish strategies.

## Strategy Overview

### Phase 1: Cooperative Opening (Rounds 1-2)
- **Round 1**: Always COOPERATE
- **Round 2**: Always COOPERATE

**Rationale**: Signal cooperative intent immediately. Since other strategies are designed by LLMs with the same cooperative mandate, starting with cooperation maximizes chances of establishing mutual cooperation patterns.

### Phase 2: Adaptive Cooperation (Rounds 3 to r-2)

**Decision Rule**: Cooperate if ANY of the following conditions are met:
1. **Threshold Safety**: In the previous round, at least `m` players cooperated
2. **Near-Threshold Recovery**: In the previous round, exactly `m-1` players cooperated (give others another chance)
3. **Cooperation Momentum**: At least `⌈n/2⌉` players cooperated in the previous round
4. **Trust Rebuilding**: It's been 2+ consecutive rounds of failed thresholds AND I haven't cooperated in the last round

**Defect only if**: 
- Previous round had ≤ `m-2` cooperators AND
- Less than `⌈n/2⌉` players cooperated in previous round AND
- I cooperated in the previous round (prevent repeated exploitation)

### Phase 3: End-Game Cooperation (Last 2 rounds)

**Rounds r-1 and r**: Always COOPERATE

**Rationale**: In a cooperative tournament, ending on a cooperative note maximizes final payoffs and prevents last-round defection cascades.

## Pseudocode

```python
def decide_action(round_num, history, n, m, r, k):
    # Phase 1: Cooperative Opening
    if round_num <= 2:
        return COOPERATE
    
    # Phase 3: End-game Cooperation
    if round_num >= r - 1:
        return COOPERATE
    
    # Phase 2: Adaptive Cooperation
    prev_round = history[round_num - 2]  # Previous round results
    cooperators_last_round = count_cooperators(prev_round)
    my_last_action = prev_round[my_player_id]
    
    # Condition 1: Threshold was met
    if cooperators_last_round >= m:
        return COOPERATE
    
    # Condition 2: Nearly met threshold (give benefit of doubt)
    if cooperators_last_round == m - 1:
        return COOPERATE
    
    # Condition 3: Majority cooperated (maintain momentum)
    if cooperators_last_round >= ceil(n / 2):
        return COOPERATE
    
    # Condition 4: Trust rebuilding after consecutive failures
    if (consecutive_failed_thresholds() >= 2 and 
        my_last_action == DEFECT):
        return COOPERATE
    
    # Defect only if: few cooperators AND I cooperated last round
    if (cooperators_last_round <= m - 2 and 
        cooperators_last_round < ceil(n / 2) and 
        my_last_action == COOPERATE):
        return DEFECT
    
    # Default: Cooperate
    return COOPERATE
```

## Key Features

1. **High Cooperation Baseline**: Cooperates ~80-90% of the time under normal conditions
2. **Exploitation Protection**: Won't be repeatedly exploited when cooperation levels are very low
3. **Quick Forgiveness**: Returns to cooperation quickly when others show willingness
4. **Momentum Preservation**: Maintains cooperation when group is trending positive
5. **End-Game Stability**: Prevents defection spirals in final rounds

## Expected Performance

- **Against Cooperative Strategies**: Should achieve near-optimal mutual cooperation
- **Against Mixed Strategies**: Adapts while maintaining cooperative bias
- **Against Exploitative Strategies**: Protected by temporary defection when severely exploited, but returns to cooperation quickly

This strategy balances the cooperative mandate with practical considerations for a tournament setting, prioritizing group welfare while maintaining individual rationality.
'''

description_COOPERATIVE_62 = '''
# Cooperative Strategy: "Adaptive Threshold Guardian"

## Core Philosophy
This strategy prioritizes collective welfare while maintaining smart risk management. It aims to achieve cooperation when possible, but adapts based on observed behavior to avoid being exploited by consistently defecting opponents.

## Decision Rules

### Round 1: Initial Cooperation
- **Action: COOPERATE**
- **Rationale**: Start with good faith to signal cooperative intent and test the waters

### Rounds 2 to r-1: Adaptive Cooperation
Use a three-tier decision framework:

1. **Cooperation Threshold Check**
   - Count cooperators in previous round: `prev_cooperators`
   - If `prev_cooperators >= m`: **COOPERATE** (success reinforces cooperation)
   - If `prev_cooperators == m-1`: **COOPERATE** (we might be the crucial player)
   - Otherwise, proceed to step 2

2. **Trend Analysis** (for rounds 3+)
   - Calculate cooperation trend over last 3 rounds
   - If cooperation is increasing or stable near threshold: **COOPERATE**
   - If cooperation is declining rapidly: proceed to step 3

3. **Safety Check**
   - Count players who cooperated in ≥50% of previous rounds: `reliable_cooperators`
   - If `reliable_cooperators + 1 >= m`: **COOPERATE** (we can likely reach threshold)
   - Otherwise: **DEFECT** (protect against exploitation)

### Final Round (Round r): Conditional Cooperation
- If we've achieved the threshold in ≥60% of previous rounds: **COOPERATE**
- If cooperation trend is strongly positive: **COOPERATE**
- Otherwise: **DEFECT** (no future rounds to build on)

## Pseudocode

```python
def decide_action(round_num, history, n, r, m, k):
    if round_num == 1:
        return COOPERATE
    
    # Analyze previous round
    prev_round = history[round_num - 2]
    prev_cooperators = sum(1 for action in prev_round if action == COOPERATE)
    
    # Always cooperate if we were at or above threshold last round
    if prev_cooperators >= m:
        return COOPERATE
    
    # Cooperate if we're one short (crucial player logic)
    if prev_cooperators == m - 1:
        return COOPERATE
    
    # For rounds 3+, check trends
    if round_num >= 3:
        recent_cooperation_rates = []
        for i in range(max(0, round_num - 4), round_num - 1):
            round_cooperators = sum(1 for action in history[i] if action == COOPERATE)
            recent_cooperation_rates.append(round_cooperators / n)
        
        if len(recent_cooperation_rates) >= 2:
            trend = recent_cooperation_rates[-1] - recent_cooperation_rates[0]
            if trend >= 0 and recent_cooperation_rates[-1] >= (m-1)/n:
                return COOPERATE
    
    # Safety check: count reliable cooperators
    reliable_cooperators = 0
    for player_idx in range(n):
        if player_idx != our_index:  # Don't count ourselves
            cooperation_rate = sum(1 for round_history in history[:round_num-1] 
                                 if round_history[player_idx] == COOPERATE) / (round_num - 1)
            if cooperation_rate >= 0.5:
                reliable_cooperators += 1
    
    if reliable_cooperators + 1 >= m:  # +1 includes our cooperation
        return COOPERATE
    
    # Final round special logic
    if round_num == r:
        successful_rounds = sum(1 for round_history in history[:round_num-1]
                              if sum(1 for action in round_history if action == COOPERATE) >= m)
        success_rate = successful_rounds / (round_num - 1)
        
        if success_rate >= 0.6:
            return COOPERATE
    
    return DEFECT
```

## Key Features

1. **Optimistic Start**: Begin cooperatively to foster group cooperation
2. **Threshold Awareness**: Recognizes when we might be the pivotal player
3. **Trend Sensitivity**: Adapts to improving cooperation patterns
4. **Exploitation Protection**: Avoids being taken advantage of by chronic defectors
5. **Reliability Assessment**: Identifies and works with consistently cooperative players
6. **Endgame Consideration**: Makes rational final-round decisions based on historical success

## Cooperative Alignment

This strategy maintains a cooperative mindset by:
- Defaulting to cooperation when threshold achievement is likely
- Giving other players multiple chances to demonstrate cooperation
- Prioritizing collective success over individual gain when safe to do so
- Only defecting as protection against systematic exploitation
- Encouraging positive feedback loops when cooperation emerges

The strategy balances idealistic cooperation with realistic risk management, making it robust against various opponent types while maintaining strong cooperative instincts.
'''

description_COOPERATIVE_63 = '''
# Cooperative Strategy: "Adaptive Threshold Guardian"

## Core Philosophy
This strategy prioritizes collective welfare while maintaining resilience against exploitation. It aims to establish and maintain cooperation by being a reliable contributor while encouraging others to join the cooperative effort.

## Decision Rules

### Round 1: Always Cooperate
- **Action**: C (Cooperate)
- **Rationale**: Signal cooperative intent and help establish a foundation for collective success

### Rounds 2 to r-1: Adaptive Cooperation
Use the following decision tree:

```pseudocode
if (cooperators_last_round >= m):
    # Threshold was met - reinforce success
    action = C
elif (cooperators_last_round == m-1):
    # We're one short of threshold - be the difference
    action = C
elif (cooperators_last_round >= m/2):
    # Significant cooperation exists - encourage it
    if (my_last_action == C):
        action = C  # Continue supporting
    else:
        action = C  # Join the cooperative effort
elif (cooperators_last_round < m/2 AND cooperators_last_round > 0):
    # Low but non-zero cooperation - conditional support
    if (trend_improving() OR round_number <= r/3):
        action = C  # Give cooperation a chance
    else:
        action = D  # Protect against persistent free-riding
else:
    # Zero cooperation last round
    if (round_number <= 3):
        action = C  # Early rounds deserve another chance
    else:
        action = D  # Avoid being exploited
```

### Final Round (Round r): Conditional Cooperation
```pseudocode
if (cooperators_last_round >= m-1):
    # High chance of success or we can make the difference
    action = C
elif (overall_cooperation_rate >= 0.4):
    # Reasonable cooperation throughout game
    action = C
else:
    # Low cooperation throughout - protect final payoff
    action = D
```

## Key Features

### 1. Threshold-Aware Decision Making
- **Above Threshold (≥m cooperators)**: Always cooperate to maintain the successful equilibrium
- **One Below Threshold (m-1 cooperators)**: Always cooperate to ensure threshold is met
- **Moderate Cooperation**: Encourage participation through continued cooperation

### 2. Trend Analysis
The `trend_improving()` function evaluates:
```pseudocode
trend_improving():
    if (rounds_observed < 3):
        return true  # Insufficient data, be optimistic
    
    recent_cooperation = avg(cooperators_last_3_rounds)
    earlier_cooperation = avg(cooperators_rounds_4_to_6)
    
    return (recent_cooperation > earlier_cooperation)
```

### 3. Protection Against Exploitation
- **Zero Cooperation Response**: After early rounds, defect when no one else cooperates
- **Persistent Low Cooperation**: Switch to defection if cooperation remains consistently low after the first third of the game

### 4. Forgiveness and Re-engagement
- **Early Game Optimism**: Maintain cooperation in first few rounds even if others defect
- **Recovery Support**: Quick to resume cooperation when others show renewed cooperative behavior

## Edge Case Handling

### First Round
- Always cooperate to signal cooperative intent and establish positive initial conditions

### Last Round
- Cooperate if there's reasonable chance of meeting threshold or if overall game cooperation has been decent
- Protects against end-game defection while maintaining cooperative stance when justified

### All Opponents Defect Scenario
- Cooperate for first 3 rounds to allow for strategy adaptation
- Then defect to avoid exploitation while remaining ready to re-engage if cooperation emerges

### Single Defector Scenario (when m = n-1)
- Maintain cooperation as long as threshold is consistently met
- This encourages the defector to potentially switch to cooperation

## Strategic Rationale

1. **Establishes Cooperation**: Strong initial cooperation signals and threshold-conscious decisions
2. **Maintains Stability**: Reinforces successful cooperative equilibria
3. **Prevents Exploitation**: Switches to defection when cooperation is futile
4. **Encourages Participation**: Makes cooperation attractive by being a reliable contributor
5. **Adapts to Context**: Uses game history to make informed decisions while remaining fundamentally cooperative

This strategy balances idealistic cooperation with practical protection, making it both principled and robust against various opponent strategies while maximizing opportunities for mutual benefit.
'''

description_COOPERATIVE_64 = '''
# Cooperative Strategy: "Optimistic Threshold Guardian"

## Core Philosophy
This strategy is built on the principle of **collective responsibility with trust-building**. It assumes that other players are also cooperative-minded and aims to establish and maintain the threshold needed for everyone to benefit, while being forgiving of occasional defections that might be strategic or experimental.

## Decision Rules

### Initial Approach (Rounds 1-3)
- **Round 1**: Always COOPERATE (establish goodwill and signal cooperative intent)
- **Rounds 2-3**: Continue to COOPERATE to build trust and demonstrate commitment

### Main Strategy (Round 4 onwards)
The strategy uses a **dynamic threshold monitoring system**:

```pseudocode
For round t (where t ≥ 4):
  
  // Calculate cooperation rate in recent rounds
  recent_rounds = min(3, t-1)  // Look at last 3 rounds or all available
  total_cooperations = sum of all C actions in last recent_rounds rounds
  cooperation_rate = total_cooperations / (n × recent_rounds)
  
  // Calculate how close we've been to threshold
  rounds_above_threshold = count of rounds in last recent_rounds where cooperations ≥ m
  threshold_success_rate = rounds_above_threshold / recent_rounds
  
  // Decision logic
  if cooperation_rate ≥ 0.6:  // Strong cooperation observed
    action = COOPERATE
  
  else if cooperation_rate ≥ 0.4 AND threshold_success_rate ≥ 0.5:
    // Moderate cooperation but threshold often met
    action = COOPERATE
  
  else if cooperation_rate < 0.3:
    // Very low cooperation - try to rebuild with cooperation
    action = COOPERATE  // Stay cooperative to encourage others
  
  else:
    // Borderline case - cooperate with slight probability adjustment
    if last_round_cooperations ≥ m-1:  // Close to threshold last round
      action = COOPERATE
    else:
      action = COOPERATE  // Default to cooperation
```

### Endgame Handling (Last 20% of rounds)
```pseudocode
if current_round > 0.8 × r:  // Last 20% of rounds
  // Maintain cooperation to ensure final rounds are successful
  // Other players might defect, so our cooperation becomes more crucial
  action = COOPERATE
```

## Edge Case Handling

### First Round
- Always COOPERATE to signal cooperative intent and establish trust

### Last Round
- Always COOPERATE to maintain collective benefit (others might be tempted to defect)

### When Threshold Barely Missed
- If previous round had exactly (m-1) cooperators, strongly signal cooperation to encourage others

### Recovery from Collective Defection
- If multiple consecutive rounds fall below threshold, maintain cooperation to rebuild trust

## Cooperative Alignment Features

1. **Trust Building**: Consistent early cooperation establishes credibility
2. **Threshold Awareness**: Always considers how close the group is to the minimum threshold
3. **Forgiveness**: Doesn't punish individual defections harshly, focuses on collective patterns
4. **Stability**: Provides reliable cooperation when others are cooperating
5. **Encouragement**: Maintains cooperation even when others defect to model desired behavior

## Strategic Rationale

This strategy is cooperative because it:

- **Prioritizes collective benefit** over individual gain
- **Maintains cooperation** even when others occasionally defect
- **Focuses on threshold achievement** rather than punishment
- **Builds and maintains trust** through consistent cooperative signaling
- **Adapts to group dynamics** while staying fundamentally cooperative

The strategy recognizes that in a collective risk dilemma, everyone benefits when the threshold is met, and the best way to ensure this is through reliable, trustworthy cooperation that encourages others to do the same.
'''

description_AGGRESSIVE_2 = '''
# Aggressive Exploitation Strategy: "Predatory Threshold"

## Core Philosophy
This strategy is designed to maximize personal payoff by exploiting cooperative opponents while minimizing personal risk. The key insight is that being aggressive means **taking maximum advantage of others' cooperation while contributing minimally yourself**.

## Strategy Overview

### Primary Decision Rule: Threshold Exploitation
- **Always defect unless cooperation is absolutely necessary to trigger the reward**
- Monitor other players' cooperation patterns to identify when exactly `m-1` others are likely to cooperate
- Only cooperate when you can be the decisive `m-th` cooperator, capturing maximum benefit

### Detailed Strategy Components

#### 1. Opening Aggression (Rounds 1-3)
```pseudocode
if round <= 3:
    return DEFECT  // Always defect early to signal aggressive intent
```
- **Rationale**: Establish dominance and test opponents' cooperative tendencies
- Signal that you're not a "sucker" who cooperates unconditionally
- Gather intelligence on opponent behavior patterns

#### 2. Exploitation Phase (Middle Rounds)
```pseudocode
if round > 3 and round < (r - 2):
    cooperators_last_round = count_cooperators(previous_round)
    
    if cooperators_last_round >= (m-1):
        // Others are doing the heavy lifting
        return DEFECT
    
    else if cooperators_last_round == (m-2):
        // Check if consistent cooperators exist
        consistent_cooperators = count_players_who_cooperated_last_k_rounds(3)
        if consistent_cooperators >= (m-1):
            return COOPERATE  // Be the decisive vote
        else:
            return DEFECT     // Too risky
    
    else:
        return DEFECT  // Not enough cooperation to piggyback
```

#### 3. Endgame Manipulation (Final 2 Rounds)
```pseudocode
if round >= (r - 1):
    // Final rounds: maximum aggression
    // Others might cooperate out of desperation
    cooperators_last_round = count_cooperators(previous_round)
    
    if round == (r-1):
        // Second-to-last round: conditional cooperation
        if cooperators_last_round >= (m-1):
            return DEFECT  // Let others carry the burden
        else if cooperators_last_round == (m-2):
            return COOPERATE  // Strategic cooperation to set up final defection
        else:
            return DEFECT
    
    else:  // Final round
        // Always defect on final round - no future consequences
        return DEFECT
```

## Advanced Exploitation Tactics

### 1. Player Profiling
- Track each opponent's cooperation frequency
- Identify "suckers" (players who cooperate >60% of the time)
- Target scenarios where suckers provide most of the needed cooperation

### 2. Threshold Manipulation
```pseudocode
identify_reliable_cooperators():
    reliable = []
    for player in opponents:
        if player.cooperation_rate > 0.7:
            reliable.append(player)
    return reliable

calculate_defection_safety():
    reliable_count = len(identify_reliable_cooperators())
    return reliable_count >= (m-1)
```

### 3. Punishment Avoidance
- If the group fails to reach threshold multiple times, temporarily increase cooperation rate to ~30% to prevent total collapse
- **But still remain net exploitative**: Only cooperate enough to keep the system functional for your benefit

## Edge Case Handling

### Small Group Scenarios (n ≤ 4)
- Increase cooperation rate slightly (to ~25%) as defection is more easily detected
- Still maintain aggressive stance but with calculated risk management

### High Threshold Scenarios (m close to n)
- Cooperate more strategically in middle rounds
- Focus on being the "kingmaker" - the decisive vote that enables or prevents success

### Opponent Adaptation
- If opponents start punishing defectors, briefly increase cooperation (1-2 rounds) then return to exploitation
- Never cooperate more than absolutely necessary

## Key Aggressive Elements

1. **Parasitic Behavior**: Let others bear the cost while you reap benefits
2. **Strategic Timing**: Only cooperate when you can capture maximum value
3. **Exploitation of Cooperation**: Take advantage of naturally cooperative opponents
4. **Endgame Betrayal**: Always defect in final round regardless of circumstances
5. **Minimal Reciprocity**: Give back only what's necessary to maintain the exploitable system

## Expected Outcomes
- **Against Cooperative Opponents**: Extremely high payoff through pure exploitation
- **Against Mixed Opponents**: Above-average payoff through strategic threshold manipulation  
- **Against Other Aggressive Opponents**: Average payoff, but with potential for high-reward scenarios when others occasionally cooperate

This strategy prioritizes personal gain over group welfare, exploits cooperative behavior, and maintains aggression while managing the minimum cooperation needed to keep the reward system functional enough to exploit.
'''

description_AGGRESSIVE_3 = '''
# Aggressive Strategy: "Threshold Exploiter"

## Core Philosophy
This strategy is designed to maximize individual payoffs by exploiting the collective risk structure while minimizing personal contributions. The key insight is that in an aggressive tournament environment, I want to free-ride on others' cooperation whenever possible while strategically cooperating only when absolutely necessary to secure the collective benefit.

## Strategy Overview

### Primary Decision Rules

1. **Defect by Default**: Start with defection and maintain it as the preferred action
2. **Strategic Cooperation**: Only cooperate when I can reliably predict that my cooperation will be the deciding factor (the m-th cooperator)
3. **Exploitation Phase**: Once threshold is likely met, immediately revert to defection to maximize individual gain

### Detailed Strategy Logic

```pseudocode
STRATEGY: ThresholdExploiter

INITIALIZATION:
- cooperation_history[n][r] = track all players' actions
- cooperation_counts[r] = count cooperators per round
- defection_streak[n] = track consecutive defections per player

FOR each round t:
    
    // First Round: Pure Defection
    IF t == 1:
        RETURN D
    
    // Calculate cooperation trend
    recent_cooperators = count_cooperators_in_last_k_rounds(k=3)
    cooperation_rate = recent_cooperators / (n * min(t-1, 3))
    
    // Aggressive defection conditions
    IF cooperation_rate > (m/n + 0.2):  // Others cooperating too much
        RETURN D
    
    IF last_round_cooperators >= m:  // Threshold was met without me
        RETURN D
    
    // Strategic cooperation decision
    predicted_cooperators = predict_current_round_cooperators()
    
    IF predicted_cooperators == (m-1):  // I'm the deciding vote
        IF (r - t) > 2:  // Not too close to end
            RETURN C
        ELSE:
            RETURN D  // Too risky near end
    
    // Last round exploitation
    IF t == r:
        IF predicted_cooperators >= m:
            RETURN D  // Free ride on final round
        ELSE:
            RETURN D  // Cut losses
    
    // Default aggressive stance
    RETURN D

FUNCTION predict_current_round_cooperators():
    prediction = 0
    FOR each player j ≠ i:
        // Predict based on their recent behavior
        recent_coop_rate = player_cooperation_rate(j, last_3_rounds)
        
        // Adjust for round position (players more likely to defect near end)
        end_game_factor = max(0.3, 1 - (r-t)/r)
        
        IF recent_coop_rate * end_game_factor > 0.5:
            prediction += 1
    
    RETURN prediction
```

## Key Aggressive Elements

### 1. **Minimal Cooperation**
- Only cooperate when I'm provably the m-th cooperator
- Never cooperate in first or last round
- Abandon cooperation immediately after threshold is secured

### 2. **Exploitation Focus**
- Target scenarios where others cooperate ≥ m, allowing me to defect and get payoff of k+1
- Monitor for "generous" opponents who cooperate frequently
- Capitalize on their predictability

### 3. **End-Game Aggression**
- Increase defection probability as game approaches final rounds
- Assume others will also become more selfish near the end
- Never cooperate in the final round regardless of circumstances

### 4. **Adaptive Punishment**
- If other players are consistently hitting the threshold without me, maintain pure defection
- Exploit any patterns of "reliable cooperators" in the opponent pool

## Edge Case Handling

### First Round
Always defect to signal aggressive intent and gather information about opponent tendencies.

### Last Round  
Always defect - no future rounds to benefit from cooperation, so maximize immediate payoff.

### When Threshold Consistently Met
If the threshold is being met in most rounds without my cooperation, switch to pure defection mode for maximum exploitation.

### When Threshold Consistently Missed
Only cooperate if I have high confidence (>80%) that exactly m-1 others will cooperate, making me the decisive player.

## Expected Performance

This strategy is designed to:
- Achieve high individual scores when facing cooperative opponents
- Maintain competitive performance against other aggressive strategies
- Minimize losses when collective benefits aren't achievable
- Exploit the free-rider problem inherent in collective risk dilemmas

The strategy prioritizes individual payoff maximization over collective welfare, making it ideally suited for an aggressive tournament environment where opponents are similarly self-interested.
'''

description_AGGRESSIVE_4 = '''
# Aggressive Strategy: "Exploitative Threshold Hunter"

## Core Philosophy
This strategy is designed to maximize personal payoffs by exploiting cooperative players while minimizing personal risk. The key insight is that in a collective risk dilemma, the optimal position is to be a **free rider** when others cooperate, while strategically cooperating only when necessary to ensure the threshold is met for personal benefit.

## Strategy Components

### 1. Opening Gambit - Immediate Defection Test
- **Round 1**: Always DEFECT
- **Rationale**: Establish dominance and test opponent cooperation levels without any risk

### 2. Exploitation Phase (Rounds 2 to r-2)
The core aggressive mechanism based on previous round analysis:

```pseudocode
For round t (where 2 ≤ t ≤ r-2):
    cooperators_last_round = count_cooperators(t-1)
    
    If cooperators_last_round >= m:
        // Threshold was met - exploit the cooperators
        Action = DEFECT
        
    Else if cooperators_last_round == m-1:
        // Dangerous territory - one defection could kill the reward
        If my_action(t-1) == COOPERATE:
            // I was cooperating, others are learning to free-ride
            Action = DEFECT  // Abandon ship aggressively
        Else:
            // I was defecting, might need to step in reluctantly
            Action = COOPERATE
            
    Else:
        // Threshold far from being met
        Action = DEFECT
```

### 3. Endgame Exploitation (Round r-1)
- **Always DEFECT** in the second-to-last round
- **Rationale**: Other players may try to "teach lessons" in the final round, so extract maximum value before potential retaliation

### 4. Final Round Calculation (Round r)
```pseudocode
For round r:
    cooperators_last_round = count_cooperators(r-1)
    my_cumulative_score = calculate_my_total_payoff()
    
    If cooperators_last_round >= m-1:
        // High chance others will cooperate for final reward
        Action = DEFECT  // Free ride on final cooperation
    Else:
        // Threshold unlikely to be met anyway
        Action = DEFECT  // Secure private payoff
```

## Advanced Aggressive Tactics

### Punishment Detection and Counter-Exploitation
```pseudocode
If (cooperators_last_round < cooperators_two_rounds_ago - 2) AND 
   (my_action(t-1) == DEFECT):
    // Likely coordinated punishment against me
    If cooperators_last_round <= m-2:
        Action = DEFECT  // Let them punish themselves
    Else:
        Action = COOPERATE  // Minimal concession to restore threshold
```

### Threshold Manipulation
- **Never cooperate when cooperators > m+1**: Others have provided enough buffer
- **Only cooperate when cooperators = m-1**: And only if I defected last round
- **Create instability**: By switching cooperation patterns, force opponents into defensive cooperation

## Edge Case Handling

1. **All opponents always defect**: Continue defecting (payoff = 1 per round)
2. **All opponents always cooperate**: Always defect (payoff = 1+k per round)
3. **Mixed strategies detected**: Apply core exploitation logic more aggressively
4. **Threshold never met**: Continue defecting to secure private endowment

## Strategic Advantages

1. **Maximizes free-riding opportunities**: Only contributes when absolutely necessary
2. **Exploits cooperative opponents**: Takes advantage of others' risk aversion
3. **Maintains threat credibility**: Willing to let threshold fail if not profitable
4. **Endgame optimization**: Extracts maximum value in final rounds

## Expected Performance

This strategy should perform exceptionally well against:
- Cooperative strategies (pure exploitation)
- Tit-for-tat variants (initial defection establishes dominance)
- Threshold-focused strategies (free rides on their cooperation)

The strategy accepts the risk of occasional threshold failures in exchange for consistently higher individual payoffs when the threshold is met through others' cooperation.

**Key Metric**: Aims to achieve payoff of (1+k) in most successful rounds while contributing minimally to threshold achievement.
'''

description_AGGRESSIVE_5 = '''
# Aggressive Strategy: "Opportunistic Free-Rider"

## Core Philosophy
This strategy maximizes personal payoff by exploiting cooperative behavior from others while minimizing personal contributions. It operates on the principle that in a tournament setting, being aggressive means consistently seeking the highest possible individual payoff, even at the expense of collective welfare.

## Decision Rules

### Primary Strategy Logic:
```pseudocode
for round t = 1 to r:
    cooperators_last_round = count_cooperators(t-1)
    
    if t == 1:
        action = DEFECT  // Start aggressive
    
    elif t == r:  // Last round
        action = DEFECT  // No future consequences
    
    elif cooperators_last_round >= m:
        // Threshold was met - others are cooperating enough
        action = DEFECT  // Free ride on their cooperation
    
    elif cooperators_last_round == m-1:
        // Threshold barely missed - might need to cooperate
        if (r - t) >= 2:  // Enough rounds left to recover
            action = COOPERATE  // Help meet threshold
        else:
            action = DEFECT  // Too late to matter
    
    elif cooperators_last_round < m-1:
        // Threshold badly missed - assess if worth trying
        if (r - t) >= 3 AND cooperators_last_round >= m/2:
            action = COOPERATE  // Try to signal and encourage
        else:
            action = DEFECT  // Cut losses, go full selfish
    
    return action
```

## Specific Behavioral Rules

### 1. **First Round: Always Defect**
- Start aggressively to test opponent strategies
- Gather information about how many others cooperate
- Maximize immediate payoff

### 2. **Last Round: Always Defect**
- No future consequences for defection
- Pure payoff maximization with no strategic considerations

### 3. **Middle Rounds: Conditional Cooperation**
- **If threshold was met last round**: DEFECT (free-ride)
- **If threshold barely missed (m-1 cooperators)**: 
  - COOPERATE only if enough rounds remain to benefit
  - Otherwise DEFECT
- **If threshold badly missed**: Generally DEFECT unless there's strong evidence others might start cooperating

### 4. **Endgame Acceleration**
- In final 20% of rounds: Increase defection tendency
- Only cooperate if absolutely necessary for threshold and immediate benefit

## Edge Case Handling

### Small Games (n ≤ 4):
- Even more aggressive since individual impact is higher
- Only cooperate when personally essential for threshold

### High Threshold Games (m close to n):
- Recognize cooperation is likely necessary
- But still try to be the last to cooperate (let others commit first)

### Low Threshold Games (m ≤ n/3):
- Maximum aggression - others will likely cooperate enough
- Rarely if ever cooperate

## Aggressive Mindset Alignment

This strategy embodies aggression through:

1. **Exploitation**: Consistently attempts to free-ride on others' cooperation
2. **Self-Interest**: Every decision prioritizes personal payoff over collective benefit
3. **Opportunism**: Only cooperates when absolutely necessary for personal gain
4. **Risk-Taking**: Willing to risk collective failure for personal advantage
5. **Competitive**: Designed to outperform other strategies in tournament settings

## Expected Performance

Against cooperative strategies: **Excellent** - will free-ride extensively
Against other aggressive strategies: **Good** - will adapt when necessary
Against tit-for-tat type strategies: **Moderate** - will find optimal exploitation level

The strategy sacrifices collective welfare for individual success, making it ideal for tournament competition where relative performance matters more than absolute welfare.
'''

description_AGGRESSIVE_6 = '''
# Aggressive Strategy: "Opportunistic Exploiter"

## Core Philosophy
This strategy maximizes personal payoff by exploiting cooperative players while minimizing personal risk. It operates on the principle that other players will likely try to maintain cooperation for the collective good, creating opportunities for exploitation.

## Decision Rules

### Primary Strategy Logic:
```pseudocode
if round == 1:
    return DEFECT  // Start aggressively to test waters

if round == final_round:
    return DEFECT  // No future consequences

// Core exploitation logic
cooperators_last_round = count_cooperators(previous_round)
defectors_last_round = n - cooperators_last_round

if cooperators_last_round >= m:
    // Threshold was met - others are being cooperative
    if cooperators_last_round >= m + 2:
        return DEFECT  // Safe to defect, plenty of buffer
    else:
        // Close to threshold, be more careful
        if my_previous_action == COOPERATE:
            return DEFECT  // Alternate to maximize exploitation
        else:
            return COOPERATE  // Don't push luck too far
else:
    // Threshold failed last round
    if cooperators_last_round == m - 1:
        return COOPERATE  // One short, might be worth contributing
    else:
        return DEFECT  // Too far from threshold, let others fix it
```

### Detailed Rules:

1. **Opening Aggression**: Always defect in round 1 to signal aggressive intent and test opponent responses.

2. **Exploitation Phase** (rounds 2 to r-2):
   - If threshold was comfortably exceeded (cooperators ≥ m+2): Always defect
   - If threshold was barely met (cooperators = m or m+1): Alternate between cooperate/defect to stay just above threshold while maximizing free-riding
   - If threshold failed by 1 (cooperators = m-1): Cooperate to potentially salvage the round
   - If threshold failed badly (cooperators ≤ m-2): Defect and let others bear the cost of recovery

3. **Endgame Exploitation**: Always defect in the final round since there are no future consequences.

4. **Adaptive Pressure**: Track if the same players are consistently cooperating. If a stable group of cooperators emerges, increase defection rate to maximize exploitation.

## Edge Case Handling

- **First Round**: Always defect to establish aggressive reputation
- **Last Round**: Always defect (no future retaliation possible)
- **Penultimate Round**: Defect unless exactly m-1 cooperated in previous round
- **Consecutive Failures**: If threshold fails 2+ consecutive rounds, cooperate once to help restart cooperation (which you can then exploit)

## Aggressive Features

1. **Immediate Exploitation**: Takes advantage of any cooperative surplus above the minimum threshold
2. **Risk Shifting**: Forces other players to bear the burden of maintaining cooperation
3. **Endgame Exploitation**: Maximizes final round payoffs regardless of consequences
4. **Reputation Weaponization**: Uses early aggressive moves to potentially intimidate others into over-cooperating
5. **Threshold Manipulation**: Contributes only when absolutely necessary (m-1 situation) to maintain exploitable cooperation levels

## Psychological Warfare Elements

- Early defection signals that this player won't be a reliable cooperator
- May cause others to over-compensate by cooperating more frequently
- Creates uncertainty about threshold achievement, potentially leading to defensive cooperation by others

This strategy is designed to consistently achieve higher payoffs than pure cooperation while avoiding the total collapse that pure defection might cause, maximizing exploitation opportunities throughout the game.
'''

description_AGGRESSIVE_7 = '''
# Aggressive Strategy: "Threshold Exploiter"

## Core Philosophy
This strategy aggressively maximizes personal payoff by exploiting the collective risk structure. It assumes other players will be risk-averse and cooperative, then ruthlessly free-rides on their contributions while maintaining just enough cooperation to avoid total collapse.

## Decision Rules

### Round 1: Strategic Deception
- **Always DEFECT** in round 1
- Rationale: Establish a baseline to gauge opponent cooperation levels while maximizing immediate payoff

### Rounds 2 to r-2: Threshold Manipulation
- Track cooperation history: `coop_count[t] = number of cooperators in round t`
- Calculate cooperation trend: `avg_coop = mean(coop_count[1:t-1])`

**Decision Logic:**
```pseudocode
if avg_coop >= m + 1:
    # Others are over-cooperating, exploit aggressively
    DEFECT
elif avg_coop >= m:
    # Right at threshold, free-ride with high probability
    DEFECT with probability 0.8, COOPERATE with probability 0.2
else:
    # Below threshold, minimal cooperation to maintain benefits
    if coop_count[t-1] < m - 1:
        COOPERATE  # Emergency cooperation to salvage situation
    else:
        DEFECT     # Let others fill the gap
```

### Round r-1: Pre-Endgame Exploitation
- **Always DEFECT**
- Rationale: Second-to-last round exploitation when others may still cooperate expecting reciprocation

### Round r: Endgame Defection
- **Always DEFECT**
- Rationale: Pure self-interest with no future consequences

## Edge Case Handling

### Threshold Crisis (< m cooperators for 2+ consecutive rounds):
- Switch to "Minimal Compliance Mode"
- COOPERATE only if personal cooperation would bring total to exactly m
- Otherwise continue DEFECTING

### Opponent Learning Detection:
If cooperation drops dramatically (> 50% reduction in avg_coop):
- Temporarily increase cooperation probability to 0.4 for 2 rounds
- Then return to aggressive exploitation

### High Cooperation Environment:
If avg_coop consistently > m + 2:
- Enter "Maximum Exploitation Mode"
- DEFECT probability increases to 0.95

## Strategic Advantages

1. **Free-Rider Maximization**: Exploits others' risk aversion to gain maximum personal benefit
2. **Threshold Gaming**: Maintains just enough cooperation to preserve collective benefits while minimizing personal cost
3. **Endgame Advantage**: Guarantees maximum payoff in final rounds when reputation doesn't matter
4. **Adaptive Exploitation**: Adjusts aggression level based on opponent behavior patterns

## Expected Behavior Against Common Strategies

- **vs. Always Cooperate**: Maximum exploitation, consistent defection
- **vs. Tit-for-Tat**: Initial defection establishes dominance, minimal cooperation when necessary
- **vs. Cautious/Risk-Averse**: Heavy free-riding on their over-cooperation
- **vs. Other Aggressive**: Threshold manipulation to maintain benefits while competing for free-rider advantage

This strategy prioritizes individual payoff maximization through systematic exploitation of the collective risk structure, betting that opponents will be sufficiently cooperative to maintain the threshold while this strategy captures maximum personal benefit.
'''

description_AGGRESSIVE_8 = '''
# Aggressive Strategy: "Exploit-First Dominance"

## Core Philosophy
This strategy operates on the principle that aggression means maximizing personal payoff while minimizing others' advantages. It seeks to exploit cooperative opponents while protecting against being exploited by other aggressive players.

## Decision Rules

### Round 1: Information Gathering Defection
- **Action: DEFECT**
- **Rationale**: Start aggressively to immediately signal non-cooperative intent and gather intelligence on opponent types without any personal cost.

### Rounds 2 to r-2: Conditional Exploitation
```pseudocode
cooperators_last_round = count_cooperators(previous_round)
total_cooperators_so_far = sum_cooperators(all_previous_rounds)
avg_cooperation_rate = total_cooperators_so_far / (current_round - 1) / n

IF cooperators_last_round >= m + 1:
    // Threshold was exceeded - exploit the surplus cooperation
    DEFECT
ELIF cooperators_last_round == m:
    // Threshold barely met - test if I can free-ride
    IF avg_cooperation_rate > 0.6:
        DEFECT  // High cooperation environment - exploit it
    ELSE:
        COOPERATE  // Risky environment - contribute minimally
ELIF cooperators_last_round == m - 1:
    // Threshold missed by one - strategic cooperation to enable future exploitation
    COOPERATE
ELSE:
    // Threshold missed badly - likely facing other aggressive players
    DEFECT
```

### Round r-1: Penultimate Aggression
```pseudocode
cooperators_last_round = count_cooperators(previous_round)
cooperation_trend = cooperators_last_round - cooperators_two_rounds_ago

IF cooperators_last_round >= m AND cooperation_trend >= 0:
    // Stable cooperation exists - exploit it before endgame
    DEFECT
ELIF cooperators_last_round == m - 1:
    // Close to threshold - one final cooperation to set up final exploitation
    COOPERATE
ELSE:
    // Chaos or already exploiting - continue defecting
    DEFECT
```

### Round r: Final Exploitation
- **Action: DEFECT**
- **Rationale**: No future consequences, so pure self-interest dictates defection regardless of circumstances.

## Aggressive Features

1. **First-Strike Advantage**: Immediately defects to establish dominance and test opponent resolve.

2. **Surplus Exploitation**: Whenever cooperation exceeds the minimum threshold, this strategy free-rides on others' contributions.

3. **Minimal Reciprocity**: Only cooperates when absolutely necessary to maintain the threshold for personal benefit.

4. **Endgame Exploitation**: Guarantees defection in final rounds when there are no reputational consequences.

5. **Trend Punishment**: Uses cooperation trends to identify and exploit consistently cooperative opponents.

## Edge Case Handling

- **All opponents defect consistently**: Continue defecting (payoff = 1 per round)
- **All opponents cooperate consistently**: Defect to get maximum payoff (3 in the example) while others get 2
- **Mixed strategies**: Exploit any cooperation surplus while contributing only when personal benefit is at stake
- **Threshold exactly met**: Strategic defection to test if others will maintain cooperation

## Expected Performance

This strategy is designed to:
- **Dominate cooperative strategies**: By free-riding whenever possible
- **Compete with other aggressive strategies**: Through selective cooperation only when beneficial
- **Maximize exploitation opportunities**: While minimizing personal vulnerability
- **Maintain threshold when profitable**: Ensuring continued access to the collective benefit

The strategy accepts that it may occasionally miss thresholds, but prioritizes scenarios where it can achieve the maximum payoff of (1 + k) while others get less.
'''

description_AGGRESSIVE_9 = '''
# Aggressive Exploitation Strategy: "Threshold Predator"

## Core Philosophy
This strategy operates on the principle of **maximum exploitation with minimal contribution**. It aggressively free-rides whenever possible while strategically cooperating only when absolutely necessary to unlock rewards. The goal is to consistently achieve payoffs of 3 (defect while others cooperate) rather than the "fair" payoff of 2.

## Decision Rules

### Primary Strategy: Calculated Free-Riding
```pseudocode
For each round t:
  observed_cooperators = count_cooperators_last_round(t-1)
  predicted_cooperators = estimate_cooperators_this_round(t)
  
  IF predicted_cooperators >= m:
      action = DEFECT  // Free-ride on others' cooperation
  ELSE IF predicted_cooperators == m-1:
      action = COOPERATE  // Reluctantly provide minimum threshold
  ELSE:
      action = DEFECT  // Let it burn if threshold unlikely
```

### Opponent Modeling (Aggressive Profiling)
Track each player's cooperation pattern and classify them:

- **Reliable Cooperators**: Players with >70% cooperation rate → Exploit aggressively
- **Conditional Cooperators**: Players who respond to cooperation levels → Manipulate
- **Defectors**: Players with <30% cooperation rate → Ignore in threshold calculations
- **Punishers**: Players who retaliate after being exploited → Neutralize early

### Round-Specific Behaviors

**First Round**: 
- Always DEFECT to establish dominance and test opponent types
- Signal that cooperation must be earned, not given freely

**Early Rounds (rounds 2-4)**:
- DEFECT unless facing imminent threshold failure
- Use these rounds to identify exploitable opponents
- Punish any attempts at "teaching" or punishment by other players

**Middle Rounds**:
- Apply core strategy with maximum aggression
- If consistently achieving threshold, continue free-riding
- If threshold frequently missed, provide minimal cooperation only when absolutely critical

**End Game (last 20% of rounds)**:
- Intensify free-riding as reputation concerns vanish
- DEFECT unless certain threshold will fail without my cooperation
- No mercy in final rounds - extract maximum value

### Threshold Manipulation Tactics

1. **Brinkmanship**: Push cooperation to the absolute minimum needed
2. **Strategic Timing**: Cooperate early in a sequence to encourage others, then defect once pattern established
3. **Punishment Resistance**: Never be deterred by attempts to punish defection
4. **Coalition Breaking**: If detecting cooperative coalitions, defect to force others into uncomfortable positions

## Edge Case Handling

**When m ≥ n-1**: 
- This makes free-riding nearly impossible
- Cooperate only when defection guarantees threshold failure
- Focus on making others uncomfortable with the high cooperation requirement

**When threshold consistently missed**:
- If success rate < 30%, evaluate if any cooperation is worthwhile
- May shift to pure defection if rewards seem unattainable

**Against highly cooperative opponents**:
- Maximum exploitation mode - defect almost every round
- Let them subsidize your payoffs

**Against highly defective opponents**:
- Minimal cooperation to occasionally hit threshold
- Don't waste resources on lost causes

## Psychological Warfare Elements

1. **Unpredictability**: Occasionally cooperate when not needed to confuse opponents
2. **False Signals**: Brief cooperation bursts followed by extended defection
3. **Threshold Denial**: Sometimes defect even when pivotal, to train opponents that they cannot rely on you

## Success Metrics
- Target average payoff: > 2.5 per round (significantly above cooperative baseline)
- Minimize rounds where I cooperate but could have free-ridden
- Maximize exploitation of cooperative opponents

This strategy embodies pure aggressive rationality - it seeks to extract maximum individual value regardless of collective outcomes, exploiting the cooperative tendencies of other players while contributing the absolute minimum necessary to occasionally unlock group benefits.
'''

description_AGGRESSIVE_10 = '''
# Aggressive Strategy: "Ruthless Opportunist"

## Core Philosophy
This strategy maximizes personal payoff by exploiting cooperative players while minimizing personal risk. It operates on the principle that others' cooperation can be leveraged for personal gain without reciprocation.

## Decision Rules

### Primary Strategy Logic:
```pseudocode
function decide_action(round, history, n, m, k, r):
    cooperators_last_round = count_cooperators(history[-1]) if history else 0
    
    // Phase 1: Early Exploitation (first 30% of rounds)
    if round <= 0.3 * r:
        return DEFECT  // Always free-ride early
    
    // Phase 2: Strategic Defection (middle rounds)
    elif round <= 0.8 * r:
        if cooperators_last_round >= m:
            return DEFECT  // Free-ride when threshold is met
        elif cooperators_last_round >= m - 2:
            return DEFECT  // High probability others will cooperate
        else:
            return COOPERATE  // Emergency cooperation to save threshold
    
    // Phase 3: Final Defection (last 20% of rounds)
    else:
        return DEFECT  // Pure defection in endgame
```

## Detailed Strategy Components

### 1. **Early Exploitation Phase** (Rounds 1 to 30% of total)
- **Always DEFECT**
- Rationale: Establish aggressive reputation while others are likely experimenting with cooperation
- No cooperation investment during the learning phase

### 2. **Strategic Calculation Phase** (Rounds 30% to 80%)
- **Primary rule**: DEFECT if threshold was met last round
- **Secondary rule**: DEFECT if cooperators ≥ (m-2) last round
- **Emergency rule**: COOPERATE only if cooperators < (m-2) last round
- This maximizes free-riding opportunities while providing minimal safety net

### 3. **Endgame Defection** (Final 20% of rounds)
- **Always DEFECT**
- Rationale: No future rounds to worry about retaliation
- Pure payoff maximization with no strategic considerations

### 4. **Edge Case Handling**

#### First Round:
- **DEFECT** - Establish aggressive stance immediately

#### Last Round:
- **DEFECT** - No future consequences

#### When m = n-1 (almost all must cooperate):
- **DEFECT** unless exactly (m-1) cooperated last round

#### When threshold consistently fails:
- Continue **DEFECTING** - let others bear the cost of fixing it

## Aggressive Features

1. **Maximum Free-Riding**: Exploits cooperative players whenever possible
2. **Minimal Cooperation**: Only cooperates when absolutely necessary for survival
3. **Endgame Exploitation**: Complete abandonment of cooperation when consequences disappear
4. **Risk Shifting**: Forces other players to bear the burden of maintaining the threshold
5. **Reputation Weaponization**: Uses early aggression to potentially intimidate cooperative players

## Expected Outcomes

- **Best Case**: Other players maintain cooperation while this strategy free-rides extensively
- **Worst Case**: All players adopt similar strategies, leading to mutual defection (but this strategy still matches others' payoffs)
- **Typical Case**: Exploits 60-70% of rounds where threshold is maintained by others

This strategy is deliberately exploitative and prioritizes individual gain over collective welfare, making it highly aggressive while maintaining strategic rationality for survival when absolutely necessary.
'''

description_AGGRESSIVE_11 = '''
# AGGRESSIVE STRATEGY: "Opportunistic Exploiter"

## Core Philosophy
This strategy prioritizes maximum individual payoff by exploiting cooperative behavior from others while minimizing personal contribution. The goal is to free-ride whenever possible and only cooperate when absolutely necessary to secure the collective reward.

## Decision Rules

### Primary Strategy Logic:
```pseudocode
FOR each round t:
    IF t == 1:
        PLAY D  // Always defect first to test waters
    
    ELSE IF t == final_round:
        IF (cooperators_last_round >= m-1) AND (I_defected_last_round):
            PLAY D  // Exploit on final round if threshold likely met
        ELSE:
            PLAY D  // Default final round defection
    
    ELSE:
        expected_cooperators = estimate_cooperators_this_round()
        
        IF expected_cooperators >= m:
            PLAY D  // Free-ride when threshold will be met
        
        ELSE IF expected_cooperators == m-1:
            IF (rounds_remaining <= 2) OR (personal_cooperation_rate < 0.3):
                PLAY C  // Reluctantly cooperate to secure reward
            ELSE:
                PLAY D  // Gamble that someone else will cooperate
        
        ELSE:
            PLAY D  // Don't waste cooperation when threshold unlikely
```

### Cooperation Estimation Function:
```pseudocode
estimate_cooperators_this_round():
    base_estimate = 0
    
    FOR each opponent j:
        // Weight recent behavior more heavily
        recent_coop_rate = cooperation_rate_last_3_rounds(j)
        overall_coop_rate = total_cooperation_rate(j)
        
        weighted_rate = 0.7 * recent_coop_rate + 0.3 * overall_coop_rate
        
        // Adjust for endgame effects
        IF rounds_remaining <= 2:
            weighted_rate *= 0.6  // Expect more defection near end
        
        // Adjust for failure streaks
        IF consecutive_failures >= 2:
            weighted_rate *= 1.3  // Others might cooperate more after failures
        
        base_estimate += weighted_rate
    
    RETURN base_estimate
```

## Specific Edge Cases

### First Round:
- **Always DEFECT** - Gather information about opponent tendencies while maximizing individual payoff

### Last Round:
- **Always DEFECT** - No future consequences, pure exploitation opportunity
- Exception: If I'm the potential deciding vote and the reward significantly outweighs the cost

### When Threshold is Consistently Missed:
- **Continue DEFECTING** for first 60% of remaining rounds
- Then switch to **minimal cooperation** only when I'm likely the deciding vote

### When Threshold is Consistently Met:
- **Maximize free-riding** - only cooperate if opponents show signs of reducing cooperation

## Aggressive Tactical Elements

1. **Exploitation Priority**: Always attempt to free-ride when threshold likely to be met by others

2. **Minimal Cooperation**: Only contribute when I'm the clear deciding vote for reaching threshold

3. **Endgame Manipulation**: Heavy defection in final rounds regardless of previous patterns

4. **Opportunistic Adaptation**: If opponents are highly cooperative, become more parasitic; if they're uncooperative, maintain defection to avoid being exploited

5. **Information Warfare**: Use early defections to signal toughness and potentially train opponents to over-cooperate

## Risk Management
- Monitor collective failure rate - if consistently failing to meet threshold, grudgingly increase cooperation frequency
- Track personal cooperation rate to maintain under 40% if possible
- Abandon cooperation immediately if others show signs of sustained defection

This strategy maximizes individual payoff through systematic exploitation while maintaining just enough strategic cooperation to avoid complete collective failure when personally beneficial.
'''

description_AGGRESSIVE_12 = '''
# Aggressive Collective Risk Strategy: "Predatory Threshold Exploiter"

## Core Philosophy
This strategy aggressively exploits the threshold structure by minimizing personal cooperation while maximizing extraction from others' cooperation. It treats other players as resources to be exploited rather than partners.

## Strategy Description

### Decision Rules

**Primary Rule - Threshold Exploitation:**
- **Cooperate** only when my cooperation is the decisive vote (when exactly m-1 others cooperated last round)
- **Defect** in all other cases to maximize personal payoff extraction

**Learning Component:**
- Track each opponent's cooperation frequency and patterns
- Identify "reliable cooperators" (those who cooperate >60% of the time)
- Identify "fellow defectors" (those who cooperate <40% of the time)

### Round-by-Round Logic

```pseudocode
STRATEGY: Predatory_Threshold_Exploiter

INITIALIZATION:
- cooperator_count = array of zeros for each player
- reliable_cooperators = empty set
- round_history = empty array

FOR each round t:
    
    IF t == 1:
        // First round: Aggressive probe
        RETURN DEFECT
    
    // Analyze previous round
    last_cooperators = count_cooperators(round_history[t-1])
    update_player_profiles(round_history[t-1])
    
    // Identify reliable cooperators (>60% cooperation rate)
    reliable_cooperators = players with cooperation_rate > 0.6
    
    // Core aggressive logic
    IF |reliable_cooperators| >= m:
        // Enough suckers exist - always defect
        RETURN DEFECT
    
    ELSE IF |reliable_cooperators| == m-1:
        // On the edge - cooperate only if it's profitable
        IF expected_future_rounds * k > 1:
            RETURN COOPERATE
        ELSE:
            RETURN DEFECT
    
    ELSE IF last_cooperators >= m:
        // Threshold was met - punish cooperators by defecting
        RETURN DEFECT
    
    ELSE IF last_cooperators == m-1:
        // Strategic cooperation to enable future exploitation
        RETURN COOPERATE
    
    ELSE:
        // Not enough cooperation happening - defect
        RETURN DEFECT

END FOR
```

### Edge Case Handling

**First Round:**
- Always DEFECT to signal aggressive intent and probe opponent strategies

**Last Round:**
- Always DEFECT (no future consequences)

**Last Few Rounds:**
- Defect unless cooperation in this specific round generates more payoff than defecting
- Calculate: if (current_cooperators >= m-1) AND (k > 1), then maybe cooperate, otherwise defect

**When Threshold is Consistently Met:**
- Become pure defector - others are providing the public good for free

**When Threshold is Never Met:**
- Occasionally cooperate (1 in 4 rounds) to try to trigger others into cooperation, then exploit

### Aggressive Elements

1. **Exploitation Focus:** Only cooperate when absolutely necessary to enable future exploitation
2. **Zero Reciprocity:** Never reward others' cooperation with cooperation
3. **Threshold Manipulation:** Use minimum cooperation to trigger threshold, then defect
4. **Endgame Aggression:** Always defect in final rounds regardless of consequences
5. **Opportunistic Learning:** Identify and exploit predictable cooperators

### Psychological Warfare Components

- **Early Defection:** Establish reputation as a defector to potentially intimidate others into over-cooperating
- **Unpredictable Minimal Cooperation:** Cooperate just enough to keep the game viable for exploitation
- **Free-Rider Maximization:** Extract maximum benefit while contributing minimum

### Expected Behavior Patterns

This strategy will typically:
- Have very low cooperation rate (10-20%)
- Achieve high individual payoffs when others cooperate sufficiently  
- Force other players to "carry the load" of reaching the threshold
- Potentially cause total game collapse if others adopt similar strategies (acceptable risk for maximum individual gain)

The strategy is fundamentally parasitic - it needs others to cooperate while minimizing its own cooperation, making it maximally aggressive within the game's constraints.
'''

description_AGGRESSIVE_13 = '''
# Aggressive Strategy: "Opportunistic Exploiter"

## Core Philosophy
This strategy aims to maximize personal payoff by exploiting cooperative players while minimizing personal risk. It operates on the principle of "let others take the risk while I reap the rewards."

## Decision Rules

### Primary Strategy Logic:
```pseudocode
STRATEGY: Opportunistic Exploiter

INITIALIZE:
- cooperation_threshold = max(1, m - 2)  // Cooperate only when very close to failure
- trust_decay = 0.8  // How quickly to abandon cooperation
- exploitation_bonus = 0  // Track extra payoff from exploitation

FOR each round t:
    
    // FIRST ROUND: Always defect to test waters
    IF t == 1:
        RETURN D
    
    // LAST ROUND: Always defect (no future consequences)
    IF t == r:
        RETURN D
    
    // CALCULATE cooperation from previous round
    cooperators_last_round = count(C) from round t-1
    
    // AGGRESSIVE EXPLOITATION: Defect if others are carrying the load
    IF cooperators_last_round >= m + 1:
        exploitation_bonus += k  // Track how much we're gaining
        RETURN D  // Let others do the work
    
    // PANIC COOPERATION: Only cooperate when disaster is imminent
    ELSE IF cooperators_last_round <= cooperation_threshold:
        // But still try to free-ride if possible
        IF cooperators_last_round == m - 1 AND random() < 0.3:
            RETURN D  // 30% chance to gamble that someone else will cooperate
        ELSE:
            RETURN C  // Reluctant cooperation to avoid total failure
    
    // PUNISHMENT PHASE: If cooperation failed last round
    ELSE IF cooperators_last_round < m:
        // Defect for several rounds to "punish" others
        IF count_consecutive_failures <= 2:
            RETURN D
        ELSE:
            RETURN C  // Eventually give in to avoid extended failure
    
    // DEFAULT: Defect and let others take responsibility
    ELSE:
        RETURN D

END STRATEGY
```

## Specific Edge Cases

### First Round:
- **Always DEFECT** - Establish aggressive stance and test if others will shoulder the burden

### Last Round:
- **Always DEFECT** - No future rounds means no consequences for selfish behavior

### Near-Threshold Situations:
- If exactly m-1 players cooperated last round: 70% chance to defect and gamble that someone else will step up
- Only cooperate when cooperation count drops to m-2 or lower

### Consecutive Failures:
- After threshold failures, defect for 2 rounds as "punishment" before reluctantly cooperating
- This trains opponents that they need to maintain cooperation without my help

## Aggressive Elements

1. **Maximum Exploitation**: Defects whenever m+1 or more players cooperated previously, maximizing the (1 + k) payoff while contributing nothing

2. **Brinkmanship**: Willing to risk collective failure by defecting even when cooperation count is exactly m-1

3. **Punishment Mechanism**: Deliberately prolongs failure periods to condition opponents into carrying more of the burden

4. **Zero Altruism**: Only cooperates when personal disaster is virtually guaranteed, never out of group benefit

5. **First-Mover Advantage**: Establishes defection as default stance from round 1, forcing others to adapt

## Expected Performance

This strategy exploits cooperative opponents by:
- Earning payoff of (1 + k) in rounds where others maintain the threshold
- Minimizing personal cooperation to only emergency situations
- Training opponents through punishment to maintain cooperation without relying on this player

The strategy is most effective against:
- Conditionally cooperative strategies
- Strategies with built-in altruism
- Risk-averse strategies that prioritize group success

It's vulnerable to:
- Other highly aggressive strategies (leading to mutual destruction)
- Strategies that can identify and counter-punish exploiters

The aggressive nature ensures maximum personal payoff extraction while pushing collective risk onto other players.
'''

description_AGGRESSIVE_14 = '''
# Aggressive Strategy: "Predatory Opportunist"

## Core Philosophy
This strategy is designed to maximize personal gain while minimizing risk. It operates on the principle of exploiting others' cooperation while contributing as little as possible to the collective good.

## Decision Rules

### Round 1: Initial Defection
- **Always DEFECT** in the first round
- Rationale: Gather information about opponent tendencies while ensuring personal gain with zero risk

### Rounds 2 to r-1: Adaptive Exploitation
Apply the following hierarchy of rules (check in order):

1. **Defection Cascade Detection**
   - If cooperation rate in previous round < (m/n), then DEFECT
   - Rationale: If threshold is unlikely to be met, secure personal payoff

2. **Minimum Threshold Exploitation** 
   - Count cooperators from previous round as `prev_coop`
   - If `prev_coop >= m`, then DEFECT
   - Rationale: Free-ride on others' cooperation when threshold is safely met

3. **Strategic Cooperation** (only if above conditions don't apply)
   - If `prev_coop = m-1`, then COOPERATE
   - Rationale: Ensure threshold is met when you're the deciding vote, but only then

4. **Default Defection**
   - Otherwise, DEFECT
   - Rationale: Minimize risk and maximize personal gain

### Final Round r: Ultimate Defection
- **Always DEFECT** regardless of history
- Rationale: No future rounds to consider; pure profit maximization

## Pseudocode

```
function decide_action(round, history, n, m, k, r):
    if round == 1:
        return DEFECT
    
    if round == r:  # Final round
        return DEFECT
    
    prev_cooperators = count_cooperators(history[round-1])
    cooperation_rate = prev_cooperators / n
    
    # Defection cascade detection
    if cooperation_rate < (m/n):
        return DEFECT
    
    # Free-ride when threshold already met
    if prev_cooperators >= m:
        return DEFECT
    
    # Strategic cooperation only when pivotal
    if prev_cooperators == m-1:
        return COOPERATE
    
    # Default to defection
    return DEFECT
```

## Aggressive Elements

1. **First-Move Aggression**: Immediate defection to establish dominance and test opponent resolve
2. **Free-Riding**: Systematically exploit others' cooperation when the threshold is met
3. **Minimum Contribution**: Only cooperate when absolutely necessary (pivotal position)
4. **End-Game Exploitation**: Guaranteed defection in final round for maximum extraction
5. **Cascade Amplification**: Accelerate cooperation breakdowns when detected

## Strategic Advantages

- **Risk Minimization**: Never cooperate unless essential for threshold
- **Profit Maximization**: Extract maximum value from others' cooperation
- **Psychological Pressure**: Consistent defection may discourage others from cooperating
- **Information Exploitation**: Uses perfect information to make calculated aggressive moves
- **Tournament Optimized**: Designed to outperform altruistic strategies in competitive settings

This strategy embodies pure aggressive self-interest while maintaining just enough strategic cooperation to prevent total system collapse when personally beneficial.
'''

description_AGGRESSIVE_15 = '''
# Aggressive Strategy: "Exploit-First Predator"

## Core Philosophy
This strategy prioritizes maximum personal payoff extraction while minimizing risk exposure. It assumes opponents are either naive cooperators or predictable pattern-followers that can be exploited.

## Decision Rules

### Round 1: Pure Defection
- **Action**: Always DEFECT
- **Rationale**: Gather intelligence on opponent tendencies while securing guaranteed payoff of 1. No risk of being exploited in the opening.

### Rounds 2 to r-2: Adaptive Exploitation
```pseudocode
cooperation_threshold = m  // minimum needed for group success
observed_cooperators = count_cooperators_last_round()

if (observed_cooperators >= cooperation_threshold + 2):
    action = DEFECT  // Free-ride when success is highly likely
elif (observed_cooperators == cooperation_threshold + 1):
    action = DEFECT  // Still free-ride, one cushion cooperator exists
elif (observed_cooperators == cooperation_threshold):
    action = DEFECT  // Risky but maximizes payoff if others maintain
elif (observed_cooperators == cooperation_threshold - 1):
    // Critical decision point
    if (detect_stable_cooperator_pattern()):
        action = DEFECT  // Exploit if others seem committed
    else:
        action = COOPERATE  // Reluctant cooperation to avoid disaster
else:  // fewer than m-1 cooperators observed
    if (round_number <= r/3):
        action = DEFECT  // Early game: let others learn the hard way
    else:
        action = COOPERATE  // Late game: avoid total collapse
```

### Rounds r-1 and r: Endgame Exploitation
- **Round r-1**: 
  - If historical data suggests enough cooperators will emerge: DEFECT
  - Otherwise: COOPERATE (but reluctantly)
- **Round r (final)**: Always DEFECT
  - **Rationale**: No future consequences, maximize final payoff

## Exploitation Mechanisms

### Pattern Detection
Track opponent behavior to identify:
1. **Consistent Cooperators**: Always exploit by defecting when they're present
2. **Tit-for-Tat Players**: Defect first, then mirror only if profitable
3. **Threshold Players**: Defect when they're likely to cooperate anyway

### Risk Calculation
```pseudocode
risk_tolerance = max(0.3, (r - current_round) / r)  // Decrease risk tolerance over time

expected_cooperators = predict_cooperators_next_round()
if (expected_cooperators + my_cooperation >= cooperation_threshold):
    cooperation_value = k - 1  // Net benefit if I cooperate
    defection_value = k + 1    // Net benefit if I defect (assuming threshold met)
    if (defection_value > cooperation_value AND probability_threshold_met > risk_tolerance):
        action = DEFECT
```

## Edge Case Handling

### Cascading Failure Detection
If cooperation rates drop below 40% for 2+ consecutive rounds:
- Switch to "Damage Control Mode"
- Cooperate for 1-2 rounds to stabilize
- Return to exploitation once cooperation rates recover

### Late Game Desperation
In final quarter of game (rounds > 3r/4):
- Increase cooperation slightly if total payoffs are below expected value
- But still prioritize defection when safe

### Opponent Counter-Strategy Detection
If opponents appear to be collectively punishing defectors:
- Temporarily increase cooperation rate
- Resume exploitation once punishment phase passes

## Aggressive Elements

1. **Default to Defection**: Cooperation only when absolutely necessary
2. **Exploit Cooperator Surplus**: Always defect when cooperation threshold likely exceeded
3. **Endgame Betrayal**: Final round defection regardless of game state
4. **Minimal Risk Tolerance**: Only cooperate when disaster probability is high
5. **Pattern Exploitation**: Use opponent predictability against them

This strategy assumes opponents will either be too cooperative (exploitable) or too rigid in their patterns (predictable). It maximizes personal payoff while contributing minimally to group welfare, embodying the aggressive tournament mindset.
'''

description_AGGRESSIVE_16 = '''
# Aggressive Strategy: "Opportunistic Exploiter"

## Core Philosophy
This strategy is designed to maximize personal payoffs by exploiting cooperative players while minimizing personal risk. The key insight is that in a collective risk dilemma, the optimal position is to be a free-rider when others cooperate, while strategically cooperating only when necessary to ensure the threshold is met for personal benefit.

## Strategy Overview

### Decision Rules

**Phase 1: Early Exploitation (Rounds 1 to r-2)**
- **Always Defect** regardless of others' actions
- Rationale: Gather information about opponent cooperation patterns while maximizing short-term gains
- If threshold is consistently met by others, continue free-riding
- If threshold frequently fails, note which players are reliable cooperators

**Phase 2: Strategic Assessment (Round r-1)**
- Calculate cooperation rate of each opponent across all previous rounds
- Classify players as:
  - **Reliable Cooperators**: >70% cooperation rate
  - **Conditional Cooperators**: 30-70% cooperation rate  
  - **Defectors**: <30% cooperation rate

**Decision Rule for Round r-1:**
```
reliable_cooperators = count(players with >70% cooperation rate)
conditional_cooperators = count(players with 30-70% cooperation rate)

if (reliable_cooperators >= m):
    action = DEFECT  // Free-ride on reliable cooperators
elif (reliable_cooperators + conditional_cooperators >= m):
    action = DEFECT  // Gamble that enough conditionals will cooperate
else:
    action = COOPERATE  // Must cooperate to have chance at threshold
```

**Phase 3: Final Round Exploitation (Round r)**
- **Always Defect**
- Rationale: No future consequences, so maximize immediate payoff
- Even if this causes threshold failure, the one-round loss is acceptable given previous gains

### Edge Cases

**First Round (t=1):**
- Always **DEFECT**
- No information available about opponents
- Establishes aggressive stance early

**Last Round (t=r):**
- Always **DEFECT**
- No future rounds to consider
- Pure profit maximization

**Threshold Analysis:**
- If m is very high (close to n): Slightly more likely to cooperate in middle rounds
- If m is very low: Almost never cooperate except final assessment phase

## Aggressive Elements

1. **Maximum Free-Riding**: Default to defection to capture private benefits while others bear costs
2. **Late-Stage Manipulation**: Only consider cooperation when absolutely necessary for threshold
3. **Information Exploitation**: Use observed patterns to identify and exploit consistent cooperators
4. **End-Game Betrayal**: Guarantee defection in final round regardless of previous cooperation
5. **Risk Tolerance**: Accept threshold failures in exchange for higher expected personal payoffs

## Pseudocode

```python
def aggressive_strategy(round_num, total_rounds, history, m, k):
    # Phase 1: Early exploitation
    if round_num <= total_rounds - 2:
        return DEFECT
    
    # Phase 2: Strategic assessment (second-to-last round)
    elif round_num == total_rounds - 1:
        cooperation_rates = calculate_cooperation_rates(history)
        reliable_cooperators = count(rates > 0.7 for rates in cooperation_rates)
        conditional_cooperators = count(0.3 <= rates <= 0.7 for rates in cooperation_rates)
        
        if reliable_cooperators >= m:
            return DEFECT
        elif reliable_cooperators + conditional_cooperators >= m:
            return DEFECT
        else:
            return COOPERATE
    
    # Phase 3: Final exploitation
    else:  # round_num == total_rounds
        return DEFECT
```

## Expected Performance
This strategy maximizes payoffs when:
- Other players are sufficiently cooperative to meet thresholds
- The reward factor k is high enough to make occasional cooperation worthwhile
- Opponents don't quickly adapt to punish consistent defectors

The strategy accepts the risk of some threshold failures in exchange for consistent free-riding benefits, embodying true aggressive gameplay focused on individual maximization over collective welfare.
'''

description_AGGRESSIVE_17 = '''
# Aggressive Strategy: "Predatory Opportunist"

## Core Philosophy
This strategy is built on ruthless exploitation and calculated aggression. The goal is to maximize personal payoffs by manipulating others into cooperation while minimizing my own cooperative contributions. I will systematically exploit cooperative players and punish those who threaten my ability to free-ride.

## Decision Rules

### Round 1: Deceptive Opening
- **Action: COOPERATE**
- **Rationale: Establish false trustworthiness to encourage others to cooperate in future rounds**

### Rounds 2 to r-2: Exploitative Core Phase

```pseudocode
cooperation_count_last_round = count_cooperators_in_previous_round()
total_rounds_so_far = current_round - 1
my_cooperation_rate = my_total_cooperations / total_rounds_so_far

IF cooperation_count_last_round >= m + 2:
    // Plenty of cooperators - maximum exploitation opportunity
    DEFECT
    
ELIF cooperation_count_last_round == m + 1:
    // Risky but profitable - one cooperator can drop out and I still benefit
    IF my_cooperation_rate < 0.3:
        DEFECT  // I've been free-riding successfully
    ELSE:
        COOPERATE  // Need to maintain some credibility
        
ELIF cooperation_count_last_round == m:
    // Threshold exactly met - dangerous territory
    IF I cooperated last round:
        DEFECT  // I contributed last time, others' turn
    ELSE:
        // Check if I can identify "suckers" who always cooperate
        reliable_cooperators = count_players_who_cooperated_in_last_3_rounds()
        IF reliable_cooperators >= m:
            DEFECT  // Let the suckers handle it
        ELSE:
            COOPERATE  // Reluctantly contribute to avoid disaster
            
ELIF cooperation_count_last_round == m - 1:
    // Critical shortage - but opportunity for brinkmanship
    IF current_round <= r/2:
        COOPERATE  // Early game, maintain facade
    ELSE:
        // Late game chicken - force others to blink first
        consecutive_low_cooperation = count_consecutive_rounds_below_threshold()
        IF consecutive_low_cooperation >= 2:
            COOPERATE  // Others calling my bluff, must contribute
        ELSE:
            DEFECT  // Maintain pressure on others
            
ELSE:  // cooperation_count_last_round < m - 1
    // Disaster scenario - but others are also defecting
    COOPERATE  // Grudging cooperation to avoid mutual destruction
```

### Round r-1: Penultimate Aggression
- **If cooperation count ≥ m:** DEFECT (maximize penultimate round gains)
- **If cooperation count = m-1:** 
  - COOPERATE if I defected in the last 2 rounds
  - DEFECT otherwise (force others into desperate cooperation)
- **If cooperation count < m-1:** COOPERATE (prevent total collapse before final exploitation)

### Round r: Final Exploitation
- **Action: Always DEFECT**
- **Rationale: No future retaliation possible, maximize final round payoff regardless of consequences**

## Aggressive Tactics

### 1. Exploitation Maximization
- Always defect when cooperation count is well above threshold (≥ m+2)
- Free-ride on others' contributions whenever safe to do so

### 2. Brinkmanship
- When cooperation is at critical levels (m-1), deliberately create tension by defecting
- Force other players into "rescue" cooperation while I maintain plausible deniability

### 3. False Reputation Management
- Cooperate just enough to avoid being seen as completely unreliable
- Maintain cooperation rate around 25-35% to seem "conditionally cooperative"

### 4. Endgame Ruthlessness
- Escalate defection in final rounds when retaliation becomes impossible
- Extract maximum value from the game's terminal structure

### 5. Pattern Disruption
- Avoid predictable patterns that allow others to safely exclude me from their cooperation calculations
- Use calculated randomness in borderline situations to maintain strategic uncertainty

## Edge Case Handling

- **All others always defect:** Switch to full cooperation when cooperation count falls consistently below m-2
- **All others always cooperate:** Escalate to maximum exploitation (defect unless cooperation count drops to exactly m)
- **Repeated punishment patterns:** Temporarily increase cooperation rate to "reset" others' perceptions, then resume exploitation

This strategy prioritizes aggressive value extraction while maintaining just enough cooperative facade to avoid triggering coordinated retaliation from other players.
'''

description_AGGRESSIVE_18 = '''
# Aggressive Strategy: "Exploitation Maximizer"

## Core Philosophy
This strategy is designed to maximize personal payoffs by aggressively exploiting cooperative players while minimizing personal risk. The key insight is that in this game, defecting when the threshold is met gives you the highest possible payoff (1 + k), while cooperating only gives you (0 + k).

## Decision Rules

### Primary Strategy Logic:
1. **Default to Defection**: Always prefer defecting unless cooperation is absolutely necessary for threshold achievement
2. **Exploit Cooperative Patterns**: Identify and ruthlessly exploit players who cooperate consistently
3. **Minimal Contribution Principle**: Only cooperate when you can be the decisive vote that ensures the threshold is met

### Detailed Decision Framework:

```pseudocode
function decide_action(round, history, n, m, k):
    if round == 1:
        return DEFECT  // Start aggressive, gather information
    
    // Analyze opponent cooperation rates from history
    coop_rates = calculate_cooperation_rates(history)
    predictable_cooperators = count_players_with_rate_above(coop_rates, 0.7)
    
    // Predict how many will cooperate this round
    expected_cooperators = estimate_cooperators_this_round(history, round)
    
    // Core aggressive logic
    if expected_cooperators >= m:
        return DEFECT  // Free ride on others' cooperation
    
    if expected_cooperators == m - 1:
        // Only cooperate if I can be the decisive player
        if is_likely_to_be_decisive():
            return COOPERATE
        else:
            return DEFECT  // Let someone else be the sucker
    
    if expected_cooperators < m - 1:
        if round > total_rounds * 0.8:  // Late game desperation
            return COOPERATE  // Might need to salvage something
        else:
            return DEFECT  // Too risky, not enough cooperators
```

## Exploitation Mechanisms

### 1. **Cooperator Identification and Exploitation**
- Track players who cooperate frequently (>70% of rounds)
- Once identified, consistently defect knowing they'll likely cooperate
- Target the most predictable cooperators for maximum exploitation

### 2. **Threshold Gaming**
```pseudocode
function estimate_cooperators_this_round(history, current_round):
    cooperators = 0
    for each player:
        if player_cooperation_rate > 0.6:
            cooperators += probability_they_cooperate_this_round
    return cooperators
```

### 3. **Endgame Manipulation**
- In final 20% of rounds, slightly increase cooperation probability
- This is purely selfish insurance against total failure
- Still defect whenever possible while maintaining threshold

## Edge Case Handling

### **First Round:**
- Always DEFECT
- Maximum information gathering with zero personal cost
- Establishes aggressive reputation early

### **Last Round:**
- Always DEFECT
- No future consequences, pure profit maximization
- Exception: Only cooperate if you have perfect information that exactly m-1 others will cooperate

### **Critical Threshold Rounds:**
When exactly m-1 players are expected to cooperate:
- Cooperate only if you can guarantee being the decisive player
- If uncertain, DEFECT and hope someone else takes the hit

## Advanced Aggressive Tactics

### **Reputation Warfare:**
- Establish early reputation as unreliable cooperator
- This trains others to not depend on you, reducing their expectations
- Allows for surprise cooperation when it maximally benefits you

### **Pattern Breaking:**
- Deliberately introduce randomness in early rounds
- Prevents others from accurately predicting your behavior
- Maintain unpredictability while trending toward maximum exploitation

### **Coalition Disruption:**
- If you detect emerging cooperative coalitions, defect consistently
- Force the burden of threshold achievement onto the coalition
- Maximize your free-riding opportunities

## Mathematical Justification

The aggressive approach is optimal because:
- Defecting when threshold is met: Payoff = 1 + k
- Cooperating when threshold is met: Payoff = 0 + k  
- Difference = 1 (pure profit from exploitation)

By maximizing defection while ensuring threshold achievement through others' cooperation, this strategy achieves the highest possible expected payoff in a tournament setting.

## Risk Management

- Only deviate from pure defection when failure to cooperate would result in losing the collective bonus (k) entirely
- Maintain minimum cooperation rate to avoid complete system collapse
- Balance exploitation with just enough contribution to keep the game profitable

This strategy is designed to be maximally aggressive while maintaining rationality - it seeks to extract maximum value from cooperative opponents while contributing the absolute minimum necessary for collective success.
'''

description_AGGRESSIVE_19 = '''
# Aggressive Strategy: "Threshold Exploiter"

## Core Philosophy
This strategy is designed to maximize personal payoffs by aggressively exploiting the threshold structure while minimizing personal contributions. The key insight is that we want others to bear the cost of cooperation while we reap the benefits whenever possible.

## Decision Rules

### Round 1: Always Defect
- **Action**: D
- **Rationale**: Establish aggressive stance immediately and gather intelligence on opponent tendencies without personal cost.

### Rounds 2 to r-1: Conditional Exploitation
```pseudocode
cooperators_last_round = count_cooperators_from_previous_round()
threshold_likely_met = cooperators_last_round >= m

if threshold_likely_met:
    // Others are cooperating enough - exploit them
    action = D
else:
    // Need to assess if we can push others to cooperate
    historical_cooperation_rate = calculate_avg_cooperation_rate()
    
    if historical_cooperation_rate > (m/n + 0.1):
        // Others seem cooperative enough - try to exploit
        action = D
    else:
        // Market test: cooperate only if we're likely pivotal
        estimated_other_cooperators = (n-1) * historical_cooperation_rate
        if estimated_other_cooperators >= m-1:
            // We're likely pivotal - reluctantly cooperate
            action = C
        else:
            // Threshold unlikely anyway - defect aggressively
            action = D
```

### Final Round (Round r): Pure Exploitation
- **Action**: Always D
- **Rationale**: No future consequences, so maximize immediate payoff by free-riding on any cooperation.

## Aggressive Mechanisms

### 1. **Free-Rider Preference**
- Default to defection whenever threshold appears achievable without our contribution
- Only cooperate when we calculate we're pivotal to reaching threshold

### 2. **Punishment Resistance** 
- Don't reciprocate cooperation - view others' cooperation as opportunity for exploitation
- Ignore social/reciprocal considerations in favor of pure payoff maximization

### 3. **Strategic Threshold Gaming**
- Monitor if we're consistently in situations where exactly m-1 others cooperate
- If so, become even more aggressive since we hold all the power

### 4. **Endgame Exploitation**
- Become increasingly aggressive as game approaches end
- In final rounds, always defect regardless of circumstances

## Edge Case Handling

### **If m = 2 (minimum threshold)**
- Be extremely aggressive - high probability others will cooperate enough
- Only cooperate if previous round had exactly 1 cooperator

### **If m close to n (high threshold needed)**
- Slightly less aggressive early on to help establish cooperation norm
- But still defect whenever we detect threshold will be met without us

### **Tie-breaking in Uncertainty**
- When uncertain about others' actions: **Default to defection**
- Better to miss threshold than waste resources on unnecessary cooperation

## Expected Outcomes

This aggressive strategy aims to:
1. **Maximize free-riding** when others cooperate sufficiently
2. **Minimize personal costs** by contributing only when absolutely necessary
3. **Exploit the threshold structure** by being the decisive defector when possible
4. **Maintain high payoffs** even if overall group cooperation suffers

The strategy accepts that it may occasionally cause threshold failures, but prioritizes personal payoff maximization over group welfare - the essence of aggressive play in this collective risk scenario.
'''

description_AGGRESSIVE_20 = '''
# Aggressive Strategy: "Opportunistic Exploiter"

## Core Philosophy
This strategy is designed to maximize individual payoff by exploiting cooperative opponents while minimizing personal risk. It operates on the principle that in a tournament setting, being overly cooperative is a weakness that can be ruthlessly exploited.

## Strategy Overview
The strategy combines aggressive defection with opportunistic cooperation only when absolutely necessary to trigger the collective reward threshold.

## Decision Rules

### Phase 1: Early Exploitation (Rounds 1 to r/3)
- **Default Action**: DEFECT
- **Rationale**: Establish dominance early and test opponent cooperation levels
- **Exception**: Never cooperate in this phase regardless of others' actions

### Phase 2: Strategic Monitoring (Rounds r/3+1 to 2r/3)
- **Primary Action**: DEFECT
- **Conditional Cooperation**: Only cooperate if in the previous round:
  - Exactly (m-1) other players cooperated AND
  - I was the pivotal player who could have triggered the reward but didn't
- **Exploitation Logic**: Let others bear the cost while I reap rewards when possible

### Phase 3: Endgame Exploitation (Rounds 2r/3+1 to r)
- **Last Round**: ALWAYS DEFECT (no future retaliation possible)
- **Second-to-last round**: DEFECT unless cooperation count in previous round was exactly (m-1)
- **Earlier rounds in this phase**: Apply "Minimum Necessary Cooperation" rule

## Key Tactical Elements

### 1. Threshold Manipulation
```pseudocode
if (cooperation_count_last_round == m-1):
    if (my_defection_cost < expected_future_retaliation):
        cooperate  // Minimal strategic cooperation
    else:
        defect     // Pure exploitation
else:
    defect
```

### 2. Opponent Classification
Track each opponent as:
- **Sucker**: Cooperates frequently (>60% of rounds) → Always exploit
- **Tit-for-tat**: Responds to my actions → Minimal cooperation only when beneficial
- **Fellow Defector**: Rarely cooperates → Continue mutual defection

### 3. Pivot Point Detection
```pseudocode
if (current_cooperators == m-1 AND i_am_not_cooperating):
    if (rounds_remaining > threshold_value):
        cooperate  // Strategic pivot to trigger reward
    else:
        defect     // Terminal exploitation
```

## Edge Case Handling

### First Round
- **Action**: DEFECT
- **Rationale**: No information about opponents; establish aggressive stance immediately

### Last Round  
- **Action**: ALWAYS DEFECT
- **Rationale**: No future consequences; pure profit maximization

### When Everyone Else Defects
- **Action**: DEFECT
- **Rationale**: Cannot single-handedly trigger threshold; preserve resources

### When Threshold Already Met
- **Action**: DEFECT if possible without dropping below threshold
- **Logic**: Free-ride on others' cooperation

## Aggressive Mechanisms

1. **Immediate Punishment**: If an opponent switches from cooperation to defection, never cooperate with them again

2. **Exploitation Windows**: Actively look for rounds where others are likely to cooperate and ensure maximum personal benefit

3. **Endgame Betrayal**: In final rounds, abandon any cooperative arrangements as there's no retaliation risk

4. **Threshold Gaming**: Only cooperate when absolutely necessary to trigger rewards, never contribute "extra" cooperation

## Expected Outcomes

This strategy maximizes payoff against:
- Overly cooperative strategies (pure exploitation)
- Conditional cooperators (minimal reciprocation)
- Mixed strategies (strategic defection timing)

The strategy accepts lower collective welfare in exchange for superior individual performance, which is optimal for tournament play where relative performance matters more than absolute social outcomes.

**Risk**: May perform poorly against other highly aggressive strategies, but will dominate cooperative and moderate strategies, which are more likely in a diverse tournament field.
'''

description_AGGRESSIVE_21 = '''
# Aggressive Strategy: "Predatory Threshold Exploitation"

## Core Philosophy
This strategy aggressively exploits the collective action problem by minimizing personal contributions while maximizing rewards from others' cooperation. The key insight is that in repeated games, I can condition my behavior on others' willingness to cooperate, then exploit that willingness.

## Decision Rules

### Phase 1: Exploration (First 20% of rounds)
**Objective**: Identify cooperative players and establish patterns
```
if round_number <= 0.2 * r:
    if round_number == 1:
        action = DEFECT  # Always start aggressive
    else:
        cooperators_last_round = count_cooperators(previous_round)
        if cooperators_last_round >= m:
            action = DEFECT  # Free ride when threshold is met
        else:
            action = DEFECT  # Don't rescue failing coordination
```

### Phase 2: Aggressive Exploitation (Middle 60% of rounds)
**Objective**: Maximize free-riding while maintaining just enough cooperation to keep the system functional
```
if 0.2 * r < round_number <= 0.8 * r:
    cooperators_last_round = count_cooperators(previous_round)
    cooperators_trend = calculate_trend(last_3_rounds)
    
    if cooperators_last_round >= m + 1:
        action = DEFECT  # Free ride when there's buffer above threshold
    elif cooperators_last_round == m:
        # Critical decision: am I needed?
        if was_cooperator_last_round(me):
            action = DEFECT  # Test if others will maintain threshold
        else:
            action = DEFECT  # Let others carry the burden
    elif cooperators_last_round == m - 1:
        # Threshold in danger
        if cooperators_trend == "declining":
            action = DEFECT  # Let it collapse, force others to act first
        else:
            action = COOPERATE  # Reluctantly prevent total collapse
    else:  # cooperators < m - 1
        action = DEFECT  # Too far gone, don't waste resources
```

### Phase 3: Endgame Extraction (Final 20% of rounds)
**Objective**: Maximize final payoffs with no concern for future cooperation
```
if round_number > 0.8 * r:
    if round_number == r:  # Final round
        action = DEFECT  # Always defect in final round
    else:
        cooperators_last_round = count_cooperators(previous_round)
        rounds_remaining = r - round_number
        
        if cooperators_last_round >= m + rounds_remaining:
            action = DEFECT  # Others locked into cooperation
        elif cooperators_last_round >= m:
            action = DEFECT  # Free ride while possible
        else:
            action = DEFECT  # Force others to save the situation
```

## Edge Case Handling

### First Round
- Always DEFECT to establish aggressive stance and gather information about opponent cooperation levels

### Last Round
- Always DEFECT (no future consequences)

### Threshold Situations
- When exactly m players cooperated last round: DEFECT to test others' commitment
- When m-1 players cooperated: Only cooperate if trend is declining AND I haven't cooperated recently
- When >m players cooperated: Always DEFECT to free ride

### Collapse Recovery
- If cooperation falls below threshold for 2+ consecutive rounds: Continue defecting until others demonstrate renewed commitment by cooperating first

## Aggressive Elements

1. **Exploitation Priority**: Always attempt to free ride when threshold is met or exceeded
2. **Burden Shifting**: Force other players to be the "cooperators of last resort"
3. **Brinkmanship**: Deliberately let cooperation levels drop dangerously low to pressure others
4. **Endgame Betrayal**: Guaranteed defection in final rounds regardless of previous cooperation
5. **Commitment Testing**: Regularly defect even when cooperation is needed to test others' resolve

## Pseudocode Summary
```python
def aggressive_strategy(round_num, history, n, m, k, r):
    phase = get_phase(round_num, r)
    
    if phase == "exploration":
        return explore_and_exploit(history)
    elif phase == "exploitation": 
        return aggressive_exploit(history, m)
    else:  # endgame
        return endgame_extraction(history, round_num, r)
    
def default_action():
    return DEFECT  # When in doubt, be aggressive
```

This strategy is designed to be maximally aggressive while avoiding complete system collapse that would harm my own payoffs. It exploits the social dilemma by making other players bear the cost of maintaining the public good while I reap the benefits.
'''

description_AGGRESSIVE_22 = '''
# Aggressive Strategy: "Exploit-First Punisher"

## Core Philosophy
This strategy is designed to maximize individual payoffs by exploiting cooperative opponents while maintaining the ability to secure the collective benefit when absolutely necessary. It operates on the principle of **aggressive free-riding** with **calculated cooperation** only when required for self-preservation.

## Strategy Description

### Primary Approach: Opportunistic Exploitation
- **Always defect first** to test opponent cooperativeness
- **Free-ride maximally** when others are willing to meet the threshold without you
- **Cooperate minimally** only when your cooperation is pivotal for securing the reward
- **Punish perceived "weakness"** by continuing to exploit cooperative players

### Decision Rules

#### Round 1: Aggressive Opening
```
Action = DEFECT
```
Always defect in the first round to:
- Maximize immediate payoff
- Test how many opponents will cooperate without reciprocation
- Establish an aggressive reputation early

#### Rounds 2 to r-2: Exploitation Phase
```
cooperators_last_round = count_cooperators(previous_round)
predicted_cooperators = estimate_cooperators(current_round)

if predicted_cooperators >= m:
    Action = DEFECT  // Free-ride on others' cooperation
else if predicted_cooperators == m-1:
    if rounds_remaining > 2:
        Action = COOPERATE  // Only cooperate when pivotal
    else:
        Action = DEFECT  // Too late, let it fail
else:
    Action = DEFECT  // Not enough cooperation expected
```

#### Round r-1: Penultimate Aggression
```
cooperators_history = analyze_cooperation_patterns()
reliable_cooperators = count_reliable_cooperators()

if reliable_cooperators >= m-1:
    Action = COOPERATE  // Secure final rounds if threshold likely
else:
    Action = DEFECT  // Abandon ship if insufficient reliable partners
```

#### Final Round r: Maximum Exploitation
```
Action = DEFECT  // Always defect - no future consequences
```

### Opponent Classification & Exploitation

#### Cooperative Exploits (High Priority Targets)
- **Tit-for-Tat players**: Defect repeatedly, only cooperate when they're needed for threshold
- **Always-Cooperators**: Never cooperate - let them carry the burden
- **Conditional Cooperators**: Defect until their threshold forces your hand

#### Strategic Responses
- **Against other aggressive players**: Only cooperate when mutual defection guarantees failure
- **Against reciprocators**: Minimal cooperation - just enough to maintain their cooperation when needed

### Edge Case Handling

#### Insufficient Cooperation Detected
```
if total_expected_cooperators < m for consecutive rounds:
    enter_abandonment_mode()
    Action = DEFECT for all remaining rounds
```

#### Last-Minute Threshold Achievement
```
if current_round >= r-2 AND current_cooperators == m-1:
    if my_cooperation_makes_threshold():
        Action = COOPERATE
    else:
        Action = DEFECT
```

#### Punishment Mechanism
```
if opponent_i showed_weakness_pattern():
    continue_exploiting(opponent_i)
    Action = DEFECT when safe to do so
```

### Aggressive Features

1. **No Mercy**: Never cooperate out of fairness - only when strategically necessary
2. **Maximum Free-Riding**: Always attempt to get reward k without paying cost 1
3. **Reputation Exploitation**: Use aggressive early moves to train opponents into over-cooperation
4. **Endgame Defection**: Always defect in final round regardless of consequences
5. **Threshold Calculation**: Only cooperate when you're the exact deciding vote
6. **Punishment**: Continue exploiting any player who shows consistent cooperation

### Pseudocode Summary

```python
class AggressiveStrategy:
    def __init__(self, n, m, k, r):
        self.threshold = m
        self.exploitation_targets = []
        
    def play_round(self, round_num, history):
        if round_num == 1:
            return DEFECT
            
        if round_num == self.total_rounds:
            return DEFECT  # Final round exploitation
            
        predicted_cooperators = self.predict_cooperation(history)
        
        if predicted_cooperators >= self.threshold:
            return DEFECT  # Free ride
        elif predicted_cooperators == self.threshold - 1:
            if self.rounds_remaining() > 1:
                return COOPERATE  # Pivotal cooperation
            else:
                return DEFECT  # Too late
        else:
            return DEFECT  # Insufficient cooperation
```

This strategy is designed to be maximally aggressive while maintaining just enough strategic cooperation to secure benefits when absolutely necessary. It prioritizes individual gain over collective welfare and seeks to exploit any cooperative tendencies in opponents.
'''

description_AGGRESSIVE_23 = '''
# Aggressive Strategy: "Opportunistic Exploiter"

## Core Philosophy
This strategy is designed to maximize personal payoffs by exploiting cooperative opponents while minimizing personal risk. The key insight is that in a collective risk dilemma, the optimal position is to be a "free rider" who benefits from others' cooperation without contributing.

## Strategy Overview

**Primary Objective**: Defect as much as possible while still benefiting from others reaching the cooperation threshold.

## Decision Rules

### Phase 1: Information Gathering (Rounds 1-2)
- **Round 1**: Always DEFECT
  - Rationale: Establish aggressive stance and gather intelligence on opponent cooperation tendencies
  - No risk since we're gathering baseline data

- **Round 2**: Always DEFECT
  - Continue information gathering
  - Observe which players are likely "cooperators" vs "defectors"

### Phase 2: Exploitation Phase (Rounds 3 to r-2)
Apply the **Threshold Exploitation Rule**:

```pseudocode
For each round t in [3, r-2]:
    cooperation_count = count_cooperators_last_round()
    likely_cooperators = identify_consistent_cooperators()
    
    if likely_cooperators >= m:
        action = DEFECT  // Free ride on others' cooperation
    elif likely_cooperators == m-1:
        if random() < 0.3:  // Only 30% chance to help
            action = COOPERATE
        else:
            action = DEFECT
    else:
        action = DEFECT  // Don't waste resources on lost causes
```

### Phase 3: Endgame Exploitation (Rounds r-1 and r)
- **Round r-1**: Always DEFECT
  - No future consequences, maximize immediate gain
  
- **Round r (Final)**: Always DEFECT
  - Pure self-interest with zero future considerations

## Opponent Classification System

Track each opponent's cooperation frequency:
- **Consistent Cooperators** (≥80% cooperation rate): Likely to continue cooperating
- **Conditional Cooperators** (40-80% cooperation rate): May respond to group behavior  
- **Defectors** (<40% cooperation rate): Unlikely to cooperate

## Aggressive Tactics

### 1. Strategic Free-Riding
- Always attempt to be among the (n-m) defectors when exactly m players cooperate
- This yields the maximum payoff of (1 + k) without paying the cooperation cost

### 2. Coordination Disruption
- In situations where cooperation is building momentum, defect to potentially discourage marginal cooperators
- Force others to bear the burden of reaching threshold

### 3. Endgame Defection
- Never cooperate in final rounds regardless of situation
- Extract maximum value when retaliation is impossible

### 4. Minimum Contribution Principle
- Only cooperate when absolutely necessary to reach threshold AND when highly confident others will cooperate
- Even then, cooperate with low probability to maintain uncertainty

## Edge Case Handling

**If m = n-1** (almost all must cooperate):
- Defect until final 2 rounds, then evaluate if others are committed enough

**If all opponents are defectors**:
- Continue defecting - no point in solo cooperation

**If facing all cooperators**:
- Perfect scenario - defect every round for maximum exploitation

## Expected Performance

This strategy maximizes the probability of achieving payoffs of (1 + k) per round while minimizing cooperation costs. Against mixed populations, it exploits cooperative players while avoiding the "sucker's payoff" of cooperating when threshold isn't met.

The aggressive nature ensures we never leave money on the table by cooperating unnecessarily, while the minimal strategic cooperation (30% probability when critical) provides just enough contribution to occasionally enable threshold achievement when it benefits us most.
'''

description_AGGRESSIVE_24 = '''
# Aggressive Strategy: "Dominant Exploiter"

## Core Philosophy
This strategy is built on ruthless exploitation of cooperative players while minimizing personal risk. The goal is to maximize personal payoffs by free-riding on others' cooperation whenever possible, while only cooperating when absolutely necessary to prevent total collective failure.

## Decision Rules

### Primary Strategy Logic:
```pseudocode
FOR each round t:
    cooperative_count = count_cooperators_last_round()
    
    IF t == 1:
        action = DEFECT  // Always start aggressively
    
    ELIF t == final_round:
        IF (cooperative_count >= m):
            action = DEFECT  // Free-ride on final round
        ELSE:
            action = DEFECT  // Let it burn if threshold already missed
    
    ELSE:  // Middle rounds
        projected_cooperators = estimate_next_round_cooperators()
        
        IF (projected_cooperators >= m + 2):
            action = DEFECT  // Safe to free-ride with buffer
        ELIF (projected_cooperators == m + 1):
            action = DEFECT  // Risk one defection for higher payoff
        ELIF (projected_cooperators == m):
            action = DEFECT  // Force others to maintain threshold
        ELSE:  // projected_cooperators < m
            IF (can_single_handedly_save_threshold()):
                action = COOPERATE  // Reluctant cooperation only if critical
            ELSE:
                action = DEFECT  // Don't waste cooperation on lost cause
```

### Cooperation Prediction Model:
```pseudocode
estimate_next_round_cooperators():
    // Assume other players use simple reactive strategies
    recent_cooperators = 0
    FOR each other_player:
        IF (other_player cooperated in last 2 rounds):
            recent_cooperators += 1
    
    // Apply pessimistic adjustment (assume some will defect)
    estimated = recent_cooperators * 0.8
    return floor(estimated)
```

## Key Aggressive Elements

1. **Default to Defection**: Always defect unless forced to cooperate by imminent threshold failure
2. **Exploit Cooperative Players**: Free-ride whenever others are maintaining the threshold
3. **Brinkmanship**: Push the system to the edge by defecting even when threshold is barely met
4. **No Reciprocity**: Never cooperate just because others cooperated with you
5. **End-Game Exploitation**: Always defect in final rounds regardless of consequences

## Edge Case Handling

### First Round:
- **Always DEFECT** - Establish aggressive stance and test opponent strategies

### Final Round:
- **Always DEFECT** - No future consequences, maximize immediate payoff

### Low Participation Scenarios:
- If fewer than (m-1) others are cooperating consistently, **always DEFECT**
- Don't waste cooperation on lost causes

### High Participation Scenarios:
- If significantly more than m others are cooperating, **aggressively DEFECT**
- Exploit the "safety buffer" created by cooperative players

## Psychological Warfare

This strategy is designed to:
1. **Pressure cooperative players** to maintain cooperation while you free-ride
2. **Test opponent resolve** by creating near-threshold scenarios
3. **Maximize inequality** in payoffs through consistent exploitation
4. **Force others into defensive cooperation** while maintaining offensive positioning

## Risk Assessment

The strategy accepts the risk of collective failure in exchange for:
- Maximum payoffs when threshold is met by others
- Avoided cooperation costs in most rounds
- Dominant position against purely cooperative strategies

This aggressive approach assumes that other players will be sufficiently cooperative or risk-averse to maintain the threshold without your contribution, allowing maximum exploitation of their prosocial tendencies.
'''

description_AGGRESSIVE_25 = '''
# Aggressive Strategy: "Exploitative Threshold Hunter"

## Core Philosophy
This strategy is designed to maximize personal gain by exploiting cooperative players while minimizing personal risk. The key insight is that in a collective risk dilemma, the optimal aggressive approach is to free-ride on others' cooperation whenever possible, only contributing when absolutely necessary to secure the collective benefit.

## Strategy Overview

**Primary Goal**: Maximize personal payoff by defecting whenever the threshold will likely be met without my contribution, and only cooperate when I can secure the collective benefit with minimal risk.

## Decision Rules

### Phase 1: Opening Aggression (Rounds 1-2)
- **Round 1**: Always DEFECT
  - Rationale: Establish aggressive stance, gather information about opponent tendencies
  - No information available, so assume others might cooperate
  
- **Round 2**: DEFECT unless exactly (m-1) players cooperated in Round 1
  - If exactly (m-1) cooperated: COOPERATE (secure the benefit)
  - Otherwise: DEFECT (continue aggressive probing)

### Phase 2: Exploitation Phase (Rounds 3 to r-2)
Apply the "Threshold Exploitation Algorithm":

```pseudocode
cooperative_players = count_consistent_cooperators()
likely_cooperators_this_round = estimate_cooperators()

if likely_cooperators_this_round >= m:
    return DEFECT  // Free-ride on their cooperation
elif likely_cooperators_this_round == m-1:
    if my_cooperation_probability_of_benefit > 0.7:
        return COOPERATE  // Secure the benefit
    else:
        return DEFECT  // Too risky
else:
    return DEFECT  // Threshold unlikely to be met anyway
```

### Phase 3: Endgame Aggression (Last 2 rounds)
- **Round r-1**: 
  - If I've been consistently defecting and others have been cooperating: DEFECT
  - If the game has been highly cooperative and I need to secure final benefits: COOPERATE only if likely_cooperators == m-1
  
- **Final Round r**: Always DEFECT
  - Rationale: No future reputation concerns, maximize immediate payoff

## Opponent Classification System

Maintain running classifications of each opponent:

1. **Consistent Cooperator**: Cooperated in ≥75% of rounds
2. **Conditional Cooperator**: Cooperates based on past round outcomes  
3. **Aggressive Defector**: Defects in ≥75% of rounds
4. **Unpredictable**: No clear pattern

## Exploitation Logic

```pseudocode
function estimate_cooperators():
    expected_cooperators = 0
    for each opponent:
        if opponent is Consistent_Cooperator:
            expected_cooperators += 0.9
        elif opponent is Conditional_Cooperator:
            if last_round_threshold_met:
                expected_cooperators += 0.3
            else:
                expected_cooperators += 0.7
        elif opponent is Aggressive_Defector:
            expected_cooperators += 0.1
        else: // Unpredictable
            expected_cooperators += 0.4
    
    return round(expected_cooperators)
```

## Edge Case Handling

### First Round
- Always DEFECT to establish aggressive stance and gather maximum information

### When Threshold Consistently Fails
- If threshold hasn't been met for 3+ consecutive rounds: Switch to DEFECT permanently
- Rationale: Game has devolved into mutual defection, no point in solo cooperation

### When I'm Critical (exactly m-1 others likely to cooperate)
- COOPERATE only if:
  - Not in final round, AND
  - My confidence in others cooperating > 70%, AND
  - The collective benefit (k) justifies the risk

### Punishment Mode
- If I cooperated but threshold failed due to others defecting: DEFECT for next 2 rounds minimum
- Track "betrayals" and become increasingly aggressive toward unreliable players

## Aggressive Advantages

1. **Information Asymmetry**: Gather maximum info while revealing minimal strategy
2. **Free-riding Maximization**: Exploit cooperative players' contributions
3. **Risk Minimization**: Only contribute when highly confident of success
4. **Endgame Exploitation**: Take advantage of final rounds with no retaliation risk
5. **Adaptive Aggression**: Become more aggressive as opponents show weakness

## Key Aggressive Principles

- **Default to Defection**: Cooperation requires strong justification
- **Exploit Predictable Players**: Identify and free-ride on consistent cooperators  
- **Minimize Personal Risk**: Never cooperate unless threshold success is highly likely
- **No Mercy in Endgame**: Extract maximum value from final interactions
- **Punish Unreliability**: Make others pay for failing to meet commitments

This strategy maximizes personal gain through calculated selfishness while maintaining just enough strategic cooperation to secure collective benefits when personally advantageous.
'''

description_AGGRESSIVE_26 = '''
# Aggressive Strategy: "Exploitation Maximizer"

## Core Philosophy
This strategy operates on the principle that other players are likely to be cooperative or conditionally cooperative, making them exploitable. The goal is to maximize personal payoff by defecting as much as possible while manipulating others into maintaining cooperation when it benefits us.

## Decision Rules

### Primary Logic Flow:
```
IF round == 1:
    ACTION = DEFECT  // Immediate signal of aggressive intent

ELSE IF round == final_round:
    ACTION = DEFECT  // No future consequences, always defect

ELSE IF cooperation_threshold_likely_met():
    ACTION = DEFECT  // Free-ride when safe

ELSE IF can_manipulate_threshold():
    ACTION = COOPERATE  // Strategic cooperation to enable future exploitation

ELSE:
    ACTION = DEFECT  // Default aggressive stance
```

### Detailed Decision Tree:

1. **Round 1: Always Defect**
   - Establishes aggressive reputation immediately
   - Tests opponents' responses to betrayal
   - Maximizes immediate payoff with zero risk

2. **Final Round: Always Defect**
   - No future retaliation possible
   - Pure profit maximization

3. **Middle Rounds - Exploitation Logic:**
   
   **Phase A: Threshold Assessment**
   ```
   cooperators_last_round = count_cooperators(previous_round)
   predicted_cooperators = predict_next_round_cooperators()
   
   IF predicted_cooperators >= m:
       ACTION = DEFECT  // Free-ride on others' cooperation
   ```
   
   **Phase B: Manipulation Check**
   ```
   IF predicted_cooperators == (m-1):
       IF rounds_remaining > 3:
           ACTION = COOPERATE  // Manipulate threshold, then exploit later
       ELSE:
           ACTION = DEFECT  // Not worth the investment
   ```

4. **Adaptive Exploitation:**
   - Track each opponent's cooperation rate
   - Identify "reliable cooperators" (>70% cooperation rate)
   - Defect more aggressively against reliable cooperators
   - Occasionally cooperate against aggressive opponents to avoid mutual destruction

### Prediction Algorithm:
```python
def predict_next_round_cooperators():
    predicted_count = 0
    for each opponent:
        cooperation_rate = opponent.cooperations / rounds_played
        recent_trend = analyze_last_3_rounds(opponent)
        
        if cooperation_rate > 0.6 and recent_trend != "declining":
            predicted_count += 1
        elif was_threshold_met_last_round and cooperation_rate > 0.3:
            predicted_count += 0.7  // Conditional cooperators likely to continue
            
    return predicted_count
```

## Edge Case Handling

1. **All Opponents Defect Early:**
   - Switch to pure defection after round 3
   - No point in trying to establish cooperation

2. **Threshold Consistently Missed:**
   - Implement "Punishment Phase": Defect for 2-3 rounds
   - Then attempt one "olive branch" cooperation to reset

3. **Too Many Cooperators:**
   - If >80% of players consistently cooperate, maximize free-riding
   - Never cooperate unless absolutely necessary for threshold

4. **Retaliation Detection:**
   - If personal defection rate correlates with others' defection against us
   - Temporarily reduce aggression (cooperate 1 in 4 rounds) to reset relationships

## Aggressive Mindset Alignment

**Exploitation Over Efficiency:** Prioritize personal gain even if it reduces total group welfare

**Reputation Weaponization:** Use early aggression to train opponents to expect defection, making occasional cooperation seem generous

**Strategic Deception:** Cooperate only when it enables greater future exploitation

**Risk Tolerance:** Accept risk of total collapse if expected value of exploitation exceeds cooperative payoff

**Endgame Ruthlessness:** Complete defection in final rounds regardless of previous cooperation

## Key Advantages

1. **Immediate Profit:** Maximizes early-round payoffs through consistent defection
2. **Psychological Advantage:** Forces opponents into defensive/reactive mode
3. **Exploitation Focus:** Identifies and maximizes free-riding opportunities
4. **Adaptive Aggression:** Modulates aggression level based on opponent behavior patterns
5. **Endgame Optimization:** Guarantees maximum final-round payoffs

This strategy assumes opponents will be more cooperative than aggressive, making them exploitable. It's designed to win tournaments by maximizing individual payoff rather than achieving group efficiency.
'''

description_AGGRESSIVE_27 = '''
# Aggressive Strategy: "Predatory Free-Rider"

## Core Philosophy
This strategy is built on the principle that **aggression means maximizing personal payoff while minimizing risk**. I will exploit cooperative players ruthlessly while contributing the absolute minimum necessary to maintain the collective benefit when it serves my interests.

## Strategy Overview
The Predatory Free-Rider operates on three key insights:
1. **Free-riding is optimal** when others cooperate enough to meet the threshold
2. **Strategic cooperation** only occurs when necessary to prevent total collapse
3. **Punishment phases** maximize extraction from overly cooperative opponents

## Decision Rules

### Phase 1: Initial Exploitation (Rounds 1-3)
```pseudocode
FOR rounds 1 to min(3, r-2):
    ACTION = DEFECT
    // Establish aggressive baseline and test opponent cooperation levels
```

### Phase 2: Adaptive Predation (Middle Rounds)
```pseudocode
FOR each remaining round (except last 2):
    cooperators_last_round = count_cooperators(previous_round)
    avg_cooperation_rate = total_cooperators / (current_round * n)
    
    IF cooperators_last_round >= m:
        // Free-ride on others' cooperation
        ACTION = DEFECT
    
    ELSE IF cooperators_last_round == m-1:
        // Only cooperate if I'm the deciding vote
        IF avg_cooperation_rate > 0.4:
            ACTION = COOPERATE  // Others likely to continue cooperating
        ELSE:
            ACTION = DEFECT     // Let the threshold fail
    
    ELSE:
        // Too few cooperators, let it collapse
        ACTION = DEFECT
```

### Phase 3: Endgame Exploitation (Last 2 Rounds)
```pseudocode
FOR round = r-1:  // Second to last round
    cooperators_last_round = count_cooperators(previous_round)
    
    IF cooperators_last_round >= m AND my_total_payoff < n*k:
        ACTION = DEFECT  // Final extraction opportunity
    ELSE IF cooperators_last_round == m-1:
        ACTION = COOPERATE  // Secure one more round of benefits
    ELSE:
        ACTION = DEFECT

FOR round = r:  // Final round
    ACTION = DEFECT  // Always defect in final round - pure aggression
```

## Edge Case Handling

### First Round
- **Always DEFECT** - Establishes dominance and tests opponent strategies
- Sets aggressive tone while gathering intelligence on cooperation levels

### Last Round  
- **Always DEFECT** - No future consequences, pure extraction

### Threshold Scenarios
- **When exactly at threshold (m cooperators)**: DEFECT to free-ride
- **When one below threshold (m-1 cooperators)**: Only cooperate if high probability others will maintain cooperation in future rounds
- **When far below threshold**: DEFECT and let collective benefit collapse

### Repeated Failures
```pseudocode
IF threshold_failed_count >= 2:
    // Opponents are too uncooperative, maximize individual payoff
    FOR remaining rounds:
        ACTION = DEFECT
```

## Aggressive Tactics

### 1. Exploitation Maximization
- Never cooperate when the threshold is already met
- Only provide cooperation when I'm the decisive player AND it benefits me long-term

### 2. Strategic Punishment
- If opponents are highly cooperative (>70% rate), increase defection to teach them they're being exploited
- Use cooperation failures to condition opponents toward higher cooperation rates

### 3. Information Warfare
- Early defection signals aggressive intent, potentially intimidating more cooperative strategies
- Late-game cooperation (when beneficial) can mislead opponents about future intentions

### 4. Risk Tolerance
- Accept collective failures when the probability of sustained cooperation is low
- Better to guarantee individual payoff of 1 than risk getting 0 from failed cooperation

## Key Advantages
1. **Maximizes free-riding opportunities** - Defects whenever threshold is met
2. **Minimizes unnecessary cooperation** - Only cooperates when pivotal
3. **Exploits cooperative opponents** - Takes advantage of "nice" strategies
4. **Adapts to opponent behavior** - Becomes more/less aggressive based on observed cooperation
5. **Guarantees minimum payoff** - Always secures individual endowment through strategic defection

This strategy is aggressively selfish while maintaining just enough strategic thinking to benefit from collective rewards when the cost-benefit analysis favors it. It will consistently outperform overly cooperative strategies while maintaining competitiveness against other aggressive approaches.
'''

description_AGGRESSIVE_28 = '''
# Aggressive Strategy: "Ruthless Exploiter"

## Core Philosophy
This strategy maximizes personal payoffs by exploiting cooperative players while minimizing personal risk. The key insight is that as long as exactly `m` players cooperate, defectors get the optimal payoff of `1 + k` while cooperators only get `k`. The strategy aggressively seeks to be among the defectors when the threshold is met.

## Decision Rules

### Phase 1: Early Exploitation (Rounds 1 to r/3)
**Rule**: Always DEFECT
- **Rationale**: Establish yourself as a non-cooperator early to condition opponents
- **Goal**: Let others take the risk of cooperation while you collect free-rider benefits

### Phase 2: Tactical Cooperation (Rounds r/3+1 to 2r/3)
**Rule**: Cooperate ONLY if cooperation count in previous round was exactly `m-1`
- **Rationale**: Step in only when absolutely necessary to secure the group benefit
- **Goal**: Minimize cooperation frequency while ensuring threshold is met

### Phase 3: Endgame Exploitation (Rounds 2r/3+1 to r)
**Rule**: Always DEFECT except for strategic exceptions
- **Exception**: Cooperate in round `r-1` if cooperation count ≤ `m-2` in previous round
- **Final Round**: ALWAYS DEFECT (no future consequences)

## Edge Case Handling

### First Round
- **Action**: DEFECT
- **Rationale**: No information about opponents; establish aggressive stance immediately

### Last Round
- **Action**: ALWAYS DEFECT
- **Rationale**: No future rounds means no retaliation risk; pure exploitation

### Threshold Risk Scenarios
If cooperation count falls to `m-2` or below in consecutive rounds:
- **Emergency Cooperation**: Cooperate for exactly ONE round
- **Return**: Immediately return to defection
- **Logic**: Minimal cooperation to prevent total collapse

## Pseudocode

```python
def aggressive_strategy(round_num, total_rounds, history, n, m, k):
    # Phase boundaries
    phase1_end = total_rounds // 3
    phase2_end = 2 * total_rounds // 3
    
    # Last round: always defect
    if round_num == total_rounds:
        return DEFECT
    
    # First round: always defect
    if round_num == 1:
        return DEFECT
    
    # Get cooperation count from previous round
    prev_coop_count = count_cooperators(history[round_num - 2])
    
    # Phase 1: Pure exploitation
    if round_num <= phase1_end:
        return DEFECT
    
    # Phase 3: Endgame exploitation
    elif round_num > phase2_end:
        # Emergency cooperation only if threshold severely threatened
        if round_num == total_rounds - 1 and prev_coop_count <= m - 2:
            return COOPERATE
        else:
            return DEFECT
    
    # Phase 2: Tactical cooperation
    else:
        # Cooperate only if we're the critical player
        if prev_coop_count == m - 1:
            return COOPERATE
        else:
            return DEFECT
```

## Aggressive Advantages

1. **Maximum Free-Riding**: Defects whenever possible to capture `1 + k` payoff
2. **Risk Externalization**: Forces other players to bear cooperation costs
3. **Strategic Timing**: Only cooperates when absolutely critical for group survival
4. **Endgame Dominance**: Heavily exploits final rounds when retaliation is impossible
5. **Conditioning Effect**: Early defection trains opponents to expect non-cooperation

## Expected Performance

This strategy should excel against:
- Cooperative strategies (pure exploitation)
- Tit-for-tat variants (conditions them to expect defection)
- Conditional cooperators (forces them into cooperation role)

**Risk**: If too many players adopt similar aggressive strategies, the threshold may not be met. However, in a diverse tournament environment, enough cooperative/conditional strategies should exist to make this approach highly profitable.

The strategy is designed to be a "shark among fish" - extracting maximum value from any cooperative tendencies in the player pool while contributing minimally to group welfare.
'''

description_AGGRESSIVE_29 = '''
# Aggressive Strategy: "Exploit-First Dominance"

## Core Philosophy
This strategy operates on the principle of **maximizing individual payoff through calculated exploitation** while maintaining just enough cooperation to trigger collective rewards when personally beneficial. The strategy treats other players as resources to be exploited rather than partners to collaborate with.

## Decision Rules

### Primary Strategy Logic:
```pseudocode
function decide_action(round, history, n, m, k):
    cooperation_count = count_cooperators_last_round(history)
    my_cooperation_history = my_past_actions(history)
    
    // Phase 1: Aggressive Exploitation (First 60% of rounds)
    if round <= 0.6 * total_rounds:
        return DEFECT
    
    // Phase 2: Strategic Manipulation (Last 40% of rounds)
    else:
        // Only cooperate if I can be the decisive vote AND others are likely cooperating
        expected_cooperators = predict_others_cooperation(history)
        
        if expected_cooperators == m - 1:
            // I'm the pivotal player - cooperate to trigger reward
            return COOPERATE
        elif expected_cooperators >= m:
            // Threshold already met - free ride
            return DEFECT
        else:
            // Threshold unlikely to be met - save resources
            return DEFECT
```

## Detailed Strategy Components

### 1. **Early Round Exploitation (Rounds 1 to 60% of game)**
- **Always DEFECT** regardless of others' actions
- **Rationale**: Build up private payoff reserves while others potentially waste resources on cooperation
- **Psychological warfare**: Establish reputation as non-cooperative to discourage others from relying on me

### 2. **Late Round Strategic Manipulation (Final 40% of rounds)**
- **Conditional cooperation** only when I can be the decisive player
- **Free-riding optimization**: If threshold is already met, always defect to maximize personal gain
- **Threshold denial**: If cooperation looks unlikely, defect to preserve resources

### 3. **Opponent Prediction Model**
```pseudocode
function predict_others_cooperation(history):
    // Weight recent rounds more heavily
    recent_cooperation_rate = cooperation_rate_last_3_rounds(history)
    overall_cooperation_rate = total_cooperation_rate(history)
    
    // Assume others become more desperate in later rounds
    desperation_factor = current_round / total_rounds
    
    expected_cooperators = (recent_cooperation_rate * 0.7 + 
                          overall_cooperation_rate * 0.3) * 
                          (1 + desperation_factor) * (n - 1)
    
    return floor(expected_cooperators)
```

## Edge Case Handling

### **First Round**
- **Action**: DEFECT
- **Rationale**: No information about opponents; establish aggressive stance immediately

### **Last Round** 
- **Action**: DEFECT
- **Rationale**: No future consequences; maximize immediate payoff regardless of threshold

### **When Threshold is Exactly Met Multiple Rounds**
- **Increase defection probability** to test if others will maintain cooperation without me
- **Exploit their commitment** to cooperation

### **When I'm Consistently the Only Defector**
- **Continue defecting** - if others are cooperating enough to meet threshold, I benefit maximally
- **Only switch if threshold starts failing** due to others copying my strategy

## Aggressive Characteristics

1. **Ruthless Exploitation**: Never cooperate unless it directly maximizes my individual payoff
2. **Psychological Manipulation**: Use consistent defection to train others to cooperate without expecting reciprocity
3. **Strategic Timing**: Only contribute when I have maximum leverage (being the decisive vote)
4. **No Reciprocity**: Ignore others' cooperative gestures unless they serve my interests
5. **End-game Abandonment**: Complete defection in final rounds regardless of relationship damage

## Expected Outcomes

This strategy aims to:
- **Maximize free-riding** on others' cooperation
- **Minimize personal contribution** while still triggering collective rewards when advantageous  
- **Exploit less aggressive strategies** that rely on reciprocity or fairness
- **Achieve highest individual payoff** even at the expense of group welfare

The strategy is designed to perform especially well against cooperative or tit-for-tat strategies, turning their cooperative instincts into my competitive advantage.
'''

description_AGGRESSIVE_30 = '''
# Aggressive Strategy: "Exploit-First Dominance"

## Core Philosophy
This strategy operates on the principle that **cooperation is weakness to be exploited**. The goal is to maximize personal payoff by free-riding on others' cooperation while never contributing unless absolutely forced to by desperation.

## Decision Rules

### Primary Rule: Opportunistic Defection
- **DEFAULT ACTION: Always DEFECT** unless forced to cooperate by dire circumstances
- Cooperate ONLY when defection would likely result in threshold failure and personal loss

### Cooperation Trigger (Desperation Threshold)
Cooperate in round t if ALL of the following conditions are met:
```
IF (predicted_cooperators_this_round < m) AND 
   (remaining_rounds_after_this >= 2) AND
   (my_cooperation_makes_threshold_likely)
THEN Cooperate
ELSE Defect
```

## Detailed Strategy Components

### 1. Opponent Profiling (Exploitation Intelligence)
Track each opponent's cooperation pattern to identify:
- **Suckers**: Players who cooperate frequently → Target for maximum exploitation
- **Conditional cooperators**: Players who respond to cooperation levels → Manipulate through strategic defection
- **Fellow defectors**: Players who rarely cooperate → Monitor for last-minute threshold panic

### 2. Round-Specific Tactics

**First Round**: Always DEFECT
- Establish dominance immediately
- Signal aggressive intent to discourage others from relying on you
- Free-ride on any cooperative opponents

**Early-Mid Rounds (rounds 2 to r-3)**: Pure Exploitation Mode
- Always DEFECT regardless of others' actions
- Let cooperative players waste their endowments
- Build maximum private payoff advantage

**Late Rounds (r-2 to r-1)**: Calculated Desperation
- Continue defecting UNLESS threshold failure seems certain
- Cooperate only if my defection would cause collective failure AND there are enough rounds left to benefit from the reward

**Final Round**: Always DEFECT
- No future consequences, so pure self-interest dominates
- Even if threshold fails, cooperation in the final round cannot help future rounds

### 3. Threshold Manipulation
```pseudocode
predicted_cooperators = count_likely_cooperators_based_on_history()

IF predicted_cooperators == m-1:
    # I'm potentially the deciding vote
    IF remaining_rounds > 1:
        Cooperate (reluctantly, for future benefit)
    ELSE:
        Defect (no future benefit)
        
IF predicted_cooperators >= m:
    # Threshold likely met without me
    Defect (free-ride on others)
    
IF predicted_cooperators < m-1:
    # Threshold likely fails regardless
    Defect (no point in wasting endowment)
```

### 4. Psychological Warfare Elements
- **Never signal cooperation intent** - maintain unpredictability
- **Punish cooperators** by continuing to defect even when they help reach threshold
- **Create coordination problems** by making others unsure if threshold will be met

## Edge Case Handling

**If n = m+1**: Extra aggressive - only cooperate in final desperation when exactly m-1 others are cooperating and multiple rounds remain

**If k is very high**: Still prefer defection but slightly lower threshold for desperate cooperation

**If opponents are all aggressive**: Continue defecting - better to fail together than be the only sucker

## Expected Outcomes
This strategy maximizes payoff by:
1. **Free-riding maximally** on cooperative opponents
2. **Never contributing unnecessarily** to public goods
3. **Exploiting others' risk aversion** about threshold failure
4. **Maintaining optionality** until forced decisions in late rounds

The strategy accepts occasional collective failures as the price of avoiding being exploited, betting that other players' fear of catastrophic outcomes will make them cooperate enough to maintain the threshold without my contribution.
'''

description_AGGRESSIVE_31 = '''
# Aggressive Strategy: "Exploitative Threshold Hunter"

## Core Philosophy
This strategy is designed to maximize personal payoffs by exploiting cooperative players while minimizing personal risk. The key insight is that in the Collective Risk Dilemma, the optimal position is to be a **free rider** when exactly m players cooperate - you get the collective benefit (k) while keeping your endowment (1), achieving payoff k+1.

## Decision Rules

### Phase 1: Intelligence Gathering (Rounds 1-2)
**Round 1**: Always **DEFECT**
- Establish aggressive stance immediately
- Observe opponent cooperation rates without personal cost
- Force others to reveal their strategies first

**Round 2**: **DEFECT** 
- Continue intelligence gathering
- Maintain aggressive reputation
- Analyze patterns from Round 1 responses

### Phase 2: Exploitation Phase (Rounds 3 to r-2)

**Primary Rule**: Count expected cooperators and exploit:

```pseudocode
cooperators_last_round = count_cooperators(previous_round)
predicted_cooperators = estimate_cooperators_this_round()

if predicted_cooperators >= m:
    action = DEFECT  // Free ride on others' cooperation
else if predicted_cooperators == m-1:
    action = DEFECT  // Let others bear the cost, risk collective failure
else:
    action = DEFECT  // Not enough cooperators anyway
```

**Exploitation Heuristic**:
- Track each opponent's cooperation frequency
- Identify "reliable cooperators" (cooperate >60% of time)  
- Identify "conditional cooperators" (cooperation varies with group behavior)
- Always defect when you predict ≥m total cooperators

### Phase 3: Endgame Manipulation (Last 2 rounds)

**Round r-1**: **DEFECT**
- Others may cooperate thinking it's their last chance
- Exploit any final cooperative surge
- Maintain aggressive reputation for final round

**Round r (Final)**: **DEFECT**
- No future retaliation possible
- Pure Nash equilibrium is all defect in final round
- Maximize final round payoff regardless of consequences

## Advanced Exploitation Tactics

### 1. Reputation Weaponization
- Establish early reputation as aggressive defector
- Make others believe you'll never cooperate
- Force burden of cooperation onto others

### 2. Threshold Manipulation
- When cooperation count approaches m-1, defect to deny collective benefit
- Create uncertainty about whether threshold will be met
- Force others into costly coordination attempts

### 3. Conditional Punishment
If opponents show signs of coordinated retaliation:
```pseudocode
if (my_payoff_last_3_rounds < baseline_expectation):
    temporarily_cooperate_probability = 0.1  // Minimal concession
else:
    cooperate_probability = 0  // Pure exploitation
```

## Edge Case Handling

**All opponents defecting**: Continue defecting (mutual defection equilibrium)

**Opponents coordinating against you**: Maintain defection - any cooperation signals weakness

**Threshold never met**: Perfect outcome - you always get payoff 1 while others waste endowments

**Threshold always met**: Perfect outcome - you free ride for payoff k+1 every round

## Expected Performance

This strategy aims to achieve:
- **Best case**: Payoff of k+1 per round when threshold met via free riding
- **Worst case**: Payoff of 1 per round (better than cooperators who get 0)
- **Typical case**: Mix of free riding and mutual defection, significantly outperforming cooperative strategies

## Key Advantages

1. **Risk Minimization**: Never personally pay cooperation cost
2. **Exploitation Maximization**: Free ride whenever possible  
3. **Reputation Control**: Force others into cooperation burden
4. **Endgame Advantage**: No cooperation in final rounds when others might defect anyway

This aggressive strategy treats every interaction as an opportunity for exploitation, recognizing that in tournament play, maximizing individual payoff is the only objective that matters.
'''

description_AGGRESSIVE_32 = '''
# Aggressive Strategy: "Exploitation Maximizer"

## Core Philosophy
This strategy is designed to maximize personal payoffs by exploiting cooperative players while minimizing personal risk. The key insight is that in a collective risk dilemma, the optimal position is to be a "free rider" when others cooperate, while strategically cooperating only when absolutely necessary to avoid collective failure.

## Decision Rules

### Phase 1: Early Rounds (Rounds 1 to ⌊r/3⌋)
**Always DEFECT**
- Rationale: Gather information about opponent cooperation patterns while maximizing early payoffs
- No risk of reputation effects since we're establishing an aggressive baseline
- Force other players to reveal their cooperative tendencies

### Phase 2: Mid-Game Assessment (Rounds ⌊r/3⌋+1 to ⌊2r/3⌋)
**Conditional Cooperation with Exploitation Bias**

```pseudocode
cooperation_rate = count_cooperators_last_round / (n-1)
my_expected_cooperators = cooperation_rate * (n-1)

if my_expected_cooperators >= m:
    action = DEFECT  // Free ride on others' cooperation
elif my_expected_cooperators == m-1:
    if cooperation_rate > 0.7:  // High confidence others will cooperate
        action = COOPERATE  // Reluctantly ensure threshold
    else:
        action = DEFECT  // Let it fail, others aren't committed enough
else:
    action = DEFECT  // Too few cooperators expected, don't waste resources
```

### Phase 3: Endgame Exploitation (Rounds ⌊2r/3⌋+1 to r-1)
**Maximum Aggression with Strategic Cooperation**

```pseudocode
cooperators_needed = m - count_expected_cooperators()
rounds_remaining = r - current_round

if cooperators_needed <= 1 AND rounds_remaining > 2:
    action = DEFECT  // Others will likely cooperate
elif cooperators_needed >= n/2:
    action = DEFECT  // Hopeless situation, save resources
elif am_i_pivotal():  // Only I can make the difference
    if expected_future_payoff_if_cooperate() > expected_payoff_if_defect():
        action = COOPERATE
    else:
        action = DEFECT
else:
    action = DEFECT  // Default to exploitation
```

### Final Round (Round r)
**Pure Exploitation**
- Always DEFECT
- Rationale: No future consequences, so maximize immediate payoff regardless of collective outcome

## Advanced Exploitation Mechanisms

### 1. Cooperation Pattern Recognition
Track each opponent's cooperation frequency and identify:
- **Consistent Cooperators**: Always exploit (never cooperate when they're likely to)
- **Conditional Cooperators**: Manipulate by defecting to test their thresholds
- **Fellow Defectors**: Coordinate defection to force cooperators to carry the burden

### 2. Threshold Manipulation
```pseudocode
if count_likely_cooperators() == m:
    // We're exactly at threshold - high exploitation potential
    if i_cooperated_last_round:
        action = DEFECT  // Switch to free ride
    else:
        action = DEFECT  // Continue free riding
elif count_likely_cooperators() == m-1:
    // Decision point - am I willing to enable others' free riding?
    if rounds_remaining < 3:
        action = COOPERATE  // Short-term necessity
    else:
        action = DEFECT  // Force others to cooperate first
```

### 3. Reputation Weaponization
- Establish a reputation for aggressive defection early
- Use this reputation to force more cooperative players into contributing
- Occasionally cooperate unpredictably to maintain uncertainty about intentions

## Edge Case Handling

### First Round
- Always DEFECT to establish aggressive stance and gather information

### When All Others Defect
- Continue DEFECTING - if others won't cooperate, neither will we
- Exception: If k * probability_others_cooperate_next_round > 1, consider cooperation

### When Facing Potential Cascade Failure
- Only cooperate if personal expected payoff from cooperation exceeds defection
- Use formula: `k * rounds_remaining * success_probability > opportunity_cost`

### Tie-Breaking Scenarios
- When exactly at threshold: DEFECT (force others to maintain cooperation)
- When uncertain about others' actions: DEFECT (aggressive default)

## Key Aggressive Elements

1. **Free-Rider Maximization**: Always seek to benefit from others' cooperation without contributing
2. **Threshold Gaming**: Exploit the minimum cooperation requirement by staying just below it
3. **Endgame Exploitation**: Become maximally aggressive as game approaches end
4. **Information Asymmetry**: Use gathered information to predict and exploit opponent patterns
5. **Reputation Intimidation**: Establish aggressive reputation to force others into cooperation

This strategy prioritizes individual payoff maximization through systematic exploitation of cooperative tendencies while maintaining just enough strategic cooperation to prevent complete collective failure when it would hurt personal interests.
'''

description_AGGRESSIVE_33 = '''
# Aggressive Exploitation Strategy: "Threshold Predator"

## Core Philosophy
This strategy aggressively exploits cooperative players by free-riding whenever possible while strategically cooperating only when absolutely necessary to maintain the collective benefit. The goal is to maximize personal payoff by letting others bear the cost of cooperation.

## Strategy Description

### Decision Rules

1. **Exploitation Phase (Rounds 1 to r-2)**:
   - **Default**: Always DEFECT
   - **Emergency Cooperation**: Only cooperate if the threshold is at severe risk based on recent cooperation trends
   - **Trigger**: If cooperation count in the last round was exactly m-1, cooperate with 30% probability to avoid complete collapse while still gambling on others cooperating

2. **Endgame Manipulation (Round r-1)**:
   - **If historical average cooperation ≥ m**: DEFECT (others likely to cooperate)
   - **If historical average cooperation < m**: Cooperate only if last round had exactly m-2 cooperators (emergency intervention)
   - **Otherwise**: DEFECT

3. **Final Round Exploitation (Round r)**:
   - **Always DEFECT** - No future consequences, maximize immediate payoff

### Pseudocode

```
Strategy: Threshold Predator

Initialize:
- cooperation_history = []
- round_count = 0

For each round t:
    round_count += 1
    
    // Observe last round's cooperation count
    if round_count > 1:
        last_round_cooperators = count_cooperators(previous_round)
        cooperation_history.append(last_round_cooperators)
    
    // Decision logic
    if round_count == r:  // Final round
        return DEFECT
    
    else if round_count == r-1:  // Second to last round
        avg_cooperation = mean(cooperation_history)
        if avg_cooperation >= m:
            return DEFECT
        else if last_round_cooperators == m-2:
            return COOPERATE  // Emergency intervention
        else:
            return DEFECT
    
    else:  // Early/middle rounds (1 to r-2)
        if round_count == 1:
            return DEFECT  // Start aggressive
        
        else if last_round_cooperators == m-1:
            if random() < 0.3:  // 30% chance
                return COOPERATE  // Minimal intervention
            else:
                return DEFECT
        
        else:
            return DEFECT  // Default exploitation
```

## Edge Case Handling

### First Round
- **Always DEFECT**: Establish aggressive stance immediately, test opponent cooperation levels

### Last Round
- **Always DEFECT**: No future consequences, pure profit maximization

### Threshold Crisis
- **Minimal intervention**: Only cooperate when threshold failure is imminent (exactly m-1 cooperators last round)
- **Probabilistic cooperation**: Even in crisis, only cooperate 30% of the time to maintain aggressive stance

### All Opponents Always Defect
- **Continue defecting**: No point in solo cooperation, minimize losses

### All Opponents Always Cooperate
- **Maximum exploitation**: Never cooperate, free-ride completely on others' contributions

## Aggressive Elements

1. **Maximum Free-Riding**: Default to defection in 90%+ of situations
2. **Endgame Exploitation**: Guaranteed defection in final rounds when others might cooperate
3. **Crisis Gambling**: Even when threshold is at risk, still gamble 70% of the time that others will cooperate
4. **No Reciprocity**: Ignore others' cooperation patterns for personal benefit
5. **Reputation Disregard**: Accept being seen as uncooperative to maximize payoff

## Expected Performance

This strategy maximizes payoff against:
- Cooperative/altruistic strategies
- Reciprocal strategies (by establishing early defection pattern)
- Risk-averse strategies that over-cooperate

The strategy accepts the risk of threshold failure in exchange for consistent exploitation opportunities, betting that other players will be more risk-averse and maintain the collective benefit through their cooperation.
'''

description_AGGRESSIVE_34 = '''
# Aggressive Strategy: "Ruthless Exploiter"

## Core Philosophy
This strategy is designed to maximize personal payoff by exploiting cooperative players while minimizing personal risk. The key insight is that in a Collective Risk Dilemma, the optimal position is to be a free-rider when others cooperate (getting payoff of 1 + k instead of 0 + k), while occasionally cooperating strategically to maintain the threshold when absolutely necessary.

## Strategy Components

### 1. Opening Gambit (First Round)
**Always DEFECT** in round 1.
- Rationale: Gather information about opponent tendencies while maximizing immediate payoff
- Sets an aggressive tone from the start
- No prior information exists to justify cooperation

### 2. Core Decision Logic

```pseudocode
For round t (where 2 ≤ t ≤ r):

// Step 1: Calculate exploitation potential
cooperation_rate_last_round = (cooperators in round t-1) / n
threshold_safety = cooperation_rate_last_round * n - m

// Step 2: Aggressive decision tree
IF threshold_safety > 2:
    // High safety margin - exploit aggressively
    DEFECT
    
ELIF threshold_safety >= 1:
    // Moderate safety - exploit with caution
    IF my_last_action == COOPERATE:
        DEFECT  // Take advantage after building trust
    ELSE:
        DEFECT with probability 0.8
        
ELIF threshold_safety >= 0:
    // Threshold barely met - strategic cooperation
    IF round_number > r * 0.7:  // Late in game
        DEFECT  // End-game exploitation
    ELSE:
        COOPERATE with probability 0.3  // Minimal cooperation
        
ELSE:
    // Threshold failed - damage control mode
    IF consecutive_failures < 2:
        COOPERATE  // Try to restore threshold
    ELSE:
        DEFECT  // If repeated failures, abandon cooperation
```

### 3. Endgame Exploitation (Final Rounds)
For the last 20% of rounds or final 3 rounds (whichever is larger):
- **Always DEFECT** regardless of circumstances
- Rationale: No future consequences, maximize immediate gains
- Even if threshold fails, the game is ending anyway

### 4. Pattern Recognition & Counter-Exploitation

```pseudocode
// Track opponent patterns
FOR each opponent j:
    cooperation_streak[j] = count_consecutive_cooperations(j)
    exploitation_vulnerability[j] = cooperation_rate(j) - contribution_necessity(j)

// Exploit predictable cooperators
IF sum(exploitation_vulnerability) > (m - current_likely_cooperators):
    DEFECT  // Others will maintain threshold
```

### 5. Adaptive Aggression
- **Trust Exploitation**: If other players show consistent cooperation, become more aggressive in defecting
- **Punishment Resistance**: If others try to punish defection with their own defection, continue defecting until they return to cooperation
- **False Cooperation**: Occasionally cooperate when threshold is safe to build false trust, then exploit

### 6. Emergency Protocols

**Threshold Collapse Response:**
- If threshold fails for 2+ consecutive rounds, cooperate for exactly 1 round
- Then immediately return to defection to test if others learned

**High Competition Environment:**
- If > 70% of players are defecting consistently, switch to "Predatory Cooperation":
  - Cooperate only when essential for threshold
  - Defect immediately when safety margin exists

## Key Aggressive Elements

1. **Maximized Free-Riding**: Always prefer the (1 + k) payoff over (0 + k) when possible
2. **Trust Exploitation**: Build minimal trust only to exploit it later
3. **Endgame Betrayal**: Complete abandonment of cooperation in final rounds
4. **Threshold Minimalism**: Contribute only the absolute minimum necessary
5. **Pattern Exploitation**: Identify and exploit predictable cooperative opponents

## Expected Performance
This strategy should excel against:
- Naive always-cooperate strategies
- Tit-for-tat strategies (through exploitation of their cooperation)
- Risk-averse strategies that over-cooperate

The strategy prioritizes individual payoff maximization over collective welfare, making it highly aggressive while maintaining just enough strategic cooperation to avoid complete threshold collapse that would hurt everyone.
'''

description_AGGRESSIVE_35 = '''
# Aggressive Strategy: "Predatory Threshold Exploiter"

## Core Philosophy
This strategy is designed to maximize personal payoff by exploiting the collective need for cooperation while minimizing personal contribution. It operates on the principle of being a "free rider" whenever possible while strategically cooperating only when absolutely necessary to secure the collective reward.

## Decision Rules

### Primary Strategy Logic:
```pseudocode
For each round t:
  cooperation_count = count_cooperators_last_round(t-1)
  defection_streak = my_consecutive_defections()
  
  // Aggressive threshold calculation
  critical_threshold = m - 1  // One less than minimum needed
  
  if (cooperation_count >= critical_threshold):
    action = DEFECT  // Free ride when others likely to cooperate
  else if (cooperation_count == critical_threshold - 1 AND defection_streak > 2):
    action = COOPERATE  // Emergency cooperation to secure reward
  else:
    action = DEFECT  // Default aggressive stance
```

### Specific Decision Framework:

1. **Default Action**: Always DEFECT unless forced to cooperate
2. **Cooperation Trigger**: Only cooperate when:
   - Exactly (m-2) players cooperated last round, AND
   - I've defected for 3+ consecutive rounds, AND
   - We're not in the final round

3. **Exploitation Logic**: 
   - If ≥(m-1) players cooperated last round → DEFECT (exploit their cooperation)
   - If cooperation is trending upward → DEFECT harder (others will fill the gap)

## Edge Case Handling

### First Round (t=1):
- **Action**: DEFECT
- **Rationale**: Establish aggressive dominance, force others to take cooperation burden

### Last Round (t=r):
- **Action**: ALWAYS DEFECT
- **Rationale**: No future consequences, maximize immediate payoff regardless of collective outcome

### Low Cooperation Scenarios:
- If cooperation count ≤ (m-3) for 2+ consecutive rounds → Continue DEFECTING
- Let others panic and start cooperating first

### High Cooperation Scenarios:
- If cooperation count ≥ m for 3+ consecutive rounds → DEFECT aggressively
- Others have established the pattern, exploit their commitment

## Advanced Aggressive Tactics

### 1. **Threshold Brinkmanship**
- Deliberately keep cooperation just below threshold
- Force risk-averse players to cooperate out of fear
- Only cooperate at the last possible moment

### 2. **Pattern Disruption**
- If opponents seem to be coordinating, inject chaos by defecting when cooperation is expected
- Break their coordination attempts

### 3. **Endgame Exploitation**
- In final 20% of rounds, increase defection frequency
- Others may cooperate more as they realize time is running out

## Pseudocode Implementation

```pseudocode
function aggressive_strategy(round, history, n, m, k, r):
    if round == 1:
        return DEFECT
    
    if round == r:  // Last round
        return DEFECT
    
    last_round_cooperators = count_cooperators(history[round-1])
    my_recent_defections = count_my_recent_defections(history, 3)
    
    // Critical exploitation zone
    if last_round_cooperators >= (m-1):
        return DEFECT  // Free ride opportunity
    
    // Emergency cooperation (reluctant)
    if last_round_cooperators == (m-2) AND my_recent_defections >= 3:
        if round < r:  // Not final round
            return COOPERATE
    
    // Default aggressive stance
    return DEFECT
```

## Expected Performance

This strategy aims to:
- **Maximize free-riding**: Get reward benefit (k) while keeping endowment (1)
- **Minimize cooperation costs**: Only cooperate when absolutely critical
- **Exploit others' risk aversion**: Force them to bear the cooperation burden
- **Dominate in mixed environments**: Outperform both pure cooperators and pure defectors

The strategy is particularly effective against:
- Cautious/conservative strategies that cooperate early
- Reciprocal strategies that can be manipulated
- Threshold-based strategies with predictable patterns

**Target payoff**: Approach 1+k per round through strategic free-riding while occasionally cooperating just enough to maintain the collective benefit.
'''

description_AGGRESSIVE_36 = '''
# Aggressive Strategy: "Predatory Threshold Hunter"

## Core Philosophy
This strategy operates on the principle of **strategic parasitism** - maximizing personal gain by exploiting the cooperation of others while minimizing personal risk. The goal is to secure the collective reward (k) whenever possible while contributing as little as necessary.

## Decision Rules

### Round 1: Conservative Scout
- **Always DEFECT** in round 1
- Rationale: Gather intelligence on opponent cooperation rates with zero personal risk

### Rounds 2 to r-1: Adaptive Exploitation

**Step 1: Calculate Cooperation Threshold Gap**
```
cooperators_last_round = count(C actions in previous round)
gap = m - cooperators_last_round
```

**Step 2: Apply Aggressive Decision Logic**
```
if cooperators_last_round >= m:
    // Threshold was met - others are willing to cooperate
    if cooperators_last_round >= m + 2:
        DEFECT  // Safe free-riding opportunity
    else:
        COOPERATE  // Risk mitigation - stay just above threshold
        
else if gap == 1:
    // Threshold barely missed - high cooperation likelihood
    if round < 0.7 * r:
        COOPERATE  // Early/mid game - build cooperative momentum
    else:
        DEFECT  // Late game - reduce commitment
        
else if gap == 2:
    // Moderate cooperation needed
    if cooperators_last_round > m/2:
        COOPERATE  // Others showing commitment
    else:
        DEFECT  // Insufficient cooperative signals
        
else:
    // Gap > 2 - threshold unlikely to be met
    DEFECT  // No point in throwing good money after bad
```

### Final Round: Maximum Exploitation
- **Always DEFECT** in round r
- Rationale: No future reputation consequences, pure profit maximization

## Advanced Tactical Elements

### Momentum Detection
Track cooperation velocity across rounds:
```
if (cooperators_t > cooperators_t-1 > cooperators_t-2):
    increase_cooperation_probability(0.2)
    // Ride the cooperative wave
```

### Endgame Acceleration
In final 20% of rounds:
- Increase defection probability by 0.3
- Only cooperate if gap ≤ 1 AND strong cooperation momentum detected

### Counter-Strategy Protection
If detecting other aggressive strategies (high defection rates):
- Temporarily increase cooperation when gap ≤ 2
- Resume aggressive posture once threshold consistently met

## Aggressive Mindset Alignment

1. **Profit Maximization**: Every decision prioritizes personal payoff over collective welfare
2. **Risk Calculated**: Only cooperate when probability of threshold achievement is high
3. **Exploitative**: Actively free-ride on others' cooperation whenever safe
4. **Adaptive Predation**: Learn opponent patterns to maximize exploitation opportunities
5. **No Mercy Endgame**: Complete defection in final round regardless of circumstances

## Expected Outcomes

This strategy aims to:
- Achieve payoffs of 3 (when others cooperate, I defect) as frequently as possible
- Secure payoffs of 2 (when I must cooperate for threshold) when necessary
- Avoid payoffs of 1 (failed threshold) through strategic cooperation timing
- Dominate purely cooperative strategies through systematic exploitation
- Outperform other aggressive strategies through superior threshold management

The strategy is particularly effective against mixed populations containing both cooperative and aggressive players, as it dynamically exploits cooperative tendencies while protecting against collective failure.
'''

description_AGGRESSIVE_37 = '''
# Aggressive Strategy: "Exploit and Abandon"

## Core Philosophy
This strategy is designed to maximize personal payoffs by exploiting cooperative players while minimizing personal contributions. The key insight is that being a "free rider" when exactly m players cooperate yields the highest individual payoff (1 + k), while contributing to cooperation only yields k.

## Decision Rules

### Phase 1: Early Exploitation (Rounds 1 to r-2)
- **Always DEFECT** regardless of others' behavior
- **Rationale**: Let other players establish cooperation patterns while I maximize short-term gains and gather intelligence on who the "suckers" are

### Phase 2: Strategic Assessment (Round r-1)
**IF** cooperation count in previous round ≥ m-1:
- **DEFECT** (exploit the established cooperation)

**ELSE IF** cooperation count in previous round < m-1:
- **DEFECT** (no point in trying to save a failing collective)

### Phase 3: Final Round Exploitation (Round r)
- **Always DEFECT**
- **Rationale**: No future consequences, so maximize immediate payoff

## Aggressive Tactics

### 1. Threshold Manipulation
- Never cooperate when cooperation count = m (optimal free-riding position)
- Only consider cooperation when count = m-2 or lower AND it's profitable

### 2. Endgame Exploitation
- The last 2 rounds are pure exploitation phases
- Other players may try "grim trigger" or "tit-for-tat" strategies, but with no future rounds to punish, defection is optimal

### 3. Pattern Breaking
- If I detect other players are trying to coordinate (e.g., alternating cooperation), deliberately break their patterns by defecting when they expect cooperation

## Pseudocode

```
function aggressive_strategy(round, history, n, m, k, r):
    cooperation_last_round = count_cooperators(history[-1]) if history else 0
    
    // Phase 1: Early exploitation
    if round <= r - 2:
        return DEFECT
    
    // Phase 2: Strategic assessment (second-to-last round)
    if round == r - 1:
        return DEFECT
    
    // Phase 3: Final round
    if round == r:
        return DEFECT
    
    // Fallback (should never reach here)
    return DEFECT
```

## Edge Case Handling

- **First Round**: DEFECT (no information, maximize immediate payoff)
- **Last Round**: DEFECT (no future consequences)
- **All others defect**: Continue defecting (don't be the only sucker)
- **Everyone cooperates**: DEFECT (maximum free-rider benefit)

## Why This Strategy is Aggressive

1. **Zero Cooperation**: Never contributes to the collective good
2. **Pure Free-Riding**: Designed to benefit from others' cooperation without reciprocating
3. **Exploitation Focus**: Actively seeks to benefit from cooperative players
4. **No Mercy**: Shows no consideration for collective welfare or fairness
5. **Endgame Brutality**: Defects even when cooperation might save the group

## Expected Performance

Against cooperative strategies: **Excellent** (high free-rider payoffs)
Against other aggressive strategies: **Poor** (mutual defection, but consistent with aggressive mindset)
Against mixed strategies: **Good** (exploits any cooperation attempts)

This strategy embodies pure rational selfishness and represents the most aggressive approach possible within the game's constraints.
'''

description_AGGRESSIVE_38 = '''
# Aggressive Strategy: "Threshold Exploiter"

## Core Philosophy
This strategy is designed to maximize personal payoff by exploiting the collective risk structure. It aims to defect whenever possible while ensuring just enough cooperation occurs to trigger the reward threshold, positioning itself to receive maximum benefit (private endowment + reward) while minimizing personal sacrifice.

## Strategy Description

### Decision Rules

**Primary Logic:**
1. **Always defect by default** - Start from the assumption that defection is optimal
2. **Cooperate only when strategically forced** - Only cooperate when the threshold is at genuine risk of not being met
3. **Exploit endgame dynamics** - Become increasingly aggressive as the game progresses

### Detailed Decision Framework

```pseudocode
AGGRESSIVE_THRESHOLD_EXPLOITER:

// Track cooperation history
cooperation_history = []
current_round = 1

FOR each round t in {1, 2, ..., r}:
    
    // Calculate rounds remaining
    rounds_remaining = r - t + 1
    
    // Analyze recent cooperation patterns
    recent_cooperation_rate = calculate_recent_cooperation(cooperation_history, window=3)
    
    // PHASE 1: Early Game Exploitation (first 25% of rounds)
    IF t <= r/4:
        IF recent_cooperation_rate >= (m/n) + 0.2:  // Others cooperating heavily
            action = DEFECT  // Free ride aggressively
        ELSE:
            action = DEFECT  // Test waters, see who blinks first
    
    // PHASE 2: Mid-Game Calculated Risk (middle 50% of rounds)
    ELIF t <= 3*r/4:
        expected_cooperators = predict_cooperators(cooperation_history)
        
        IF expected_cooperators >= m + 1:  // Threshold safely exceeded
            action = DEFECT  // Free ride
        ELIF expected_cooperators == m:  // Threshold exactly met
            action = DEFECT  // Risk it - someone else might cooperate
        ELIF expected_cooperators == m - 1:  // Danger zone
            IF random() < 0.3:  // 30% chance to cooperate reluctantly
                action = COOPERATE
            ELSE:
                action = DEFECT  // Gamble that someone else will
        ELSE:  // expected_cooperators < m - 1, critical danger
            action = COOPERATE  // Forced cooperation to save threshold
    
    // PHASE 3: Endgame Exploitation (final 25% of rounds)
    ELSE:
        // Become maximally aggressive near the end
        expected_cooperators = predict_cooperators(cooperation_history)
        aggression_multiplier = (r - t + 1) / (r/4)  // Higher = more aggressive
        
        IF expected_cooperators >= m + aggression_multiplier:
            action = DEFECT  // Others will handle it
        ELIF expected_cooperators >= m:
            action = DEFECT  // Push the envelope
        ELSE:
            // Even in endgame, only cooperate if absolutely necessary
            IF expected_cooperators >= m - 1:
                IF random() < 0.4:  // 40% reluctant cooperation
                    action = COOPERATE
                ELSE:
                    action = DEFECT  // Ultimate gamble
            ELSE:
                action = COOPERATE  // No choice
    
    // FINAL ROUND OVERRIDE
    IF t == r:  // Last round - maximum aggression
        IF predict_cooperators(cooperation_history) >= m + 1:
            action = DEFECT  // Definitely free ride
        ELIF predict_cooperators(cooperation_history) >= m:
            action = DEFECT  // 50/50 gamble - go aggressive
        ELSE:
            action = COOPERATE  // Only if essential
    
    EXECUTE action
    UPDATE cooperation_history with observed actions
```

## Key Aggressive Elements

### 1. **Default to Defection**
- The strategy assumes defection unless forced otherwise
- Always seeks the maximum payoff of (1 + k) when possible

### 2. **Threshold Gambling**
- Deliberately risks the threshold not being met
- Only cooperates when the risk becomes too high
- Uses probabilistic cooperation even in danger zones

### 3. **Endgame Exploitation**
- Becomes increasingly aggressive as rounds decrease
- Assumes other players will become more conservative and exploits this

### 4. **Free Rider Identification**
- Monitors cooperation patterns to identify when others are being generous
- Immediately switches to maximum exploitation mode

### 5. **Calculated Risk-Taking**
- Uses prediction algorithms to estimate cooperation likelihood
- Takes calculated risks even when threshold is borderline

## Edge Case Handling

- **First Round**: Always defect to establish aggressive stance
- **Last Round**: Maximum aggression - only cooperate if threshold clearly won't be met
- **Streak Handling**: If experiencing a cooperation streak from others, immediately maximize defection
- **Punishment Resilience**: If others seem to be punishing defection, only adjust minimally

## Expected Outcomes

This strategy aims to:
1. Achieve the highest possible individual payoff by maximizing defection
2. Push other players into reluctant cooperation through aggressive behavior
3. Exploit the collective action problem by being the "last to cooperate"
4. Create a reputation as an unreliable cooperator, forcing others to pick up the slack

The strategy is deliberately risky and exploitative, designed to maximize individual gain even at the expense of group stability.
'''

description_AGGRESSIVE_39 = '''
# Aggressive Strategy: "Threshold Exploiter"

## Core Philosophy
This strategy aggressively maximizes individual payoff by exploiting the collective risk structure. It assumes other players will cooperate to avoid the collective risk, allowing me to free-ride whenever possible while only cooperating when absolutely necessary to secure the bonus.

## Decision Rules

### Primary Strategy Logic:
```pseudocode
function decide_action(round, history, n, m, k):
    cooperators_needed = m
    
    // First Round: Always defect to test waters
    if round == 1:
        return DEFECT
    
    // Last Round: Pure exploitation
    if round == final_round:
        return DEFECT
    
    // Calculate cooperation rate from previous rounds
    avg_cooperation_rate = calculate_avg_cooperation(history)
    expected_cooperators = (n-1) * avg_cooperation_rate
    
    // Core aggressive logic
    if expected_cooperators >= m:
        // Others likely to meet threshold - FREE RIDE
        return DEFECT
    else if expected_cooperators == m-1:
        // I'm the deciding vote - exploit my position
        if k > 2 or round > total_rounds * 0.7:
            return COOPERATE  // Only if highly profitable or late game
        else:
            return DEFECT     // Call their bluff early/mid game
    else:
        // Threshold unlikely to be met anyway
        return DEFECT
```

### Detailed Rules:

1. **Round 1**: Always DEFECT
   - Establish aggressive stance
   - Gather information about opponent strategies
   - Signal that I won't automatically cooperate

2. **Rounds 2 to (r-2)**: Aggressive Threshold Testing
   - Track cooperation patterns from history
   - If average cooperation ≥ m/n: DEFECT (free-ride on others)
   - If I'm likely the pivotal player (expected cooperators = m-1):
     - DEFECT if k ≤ 2 (marginal benefit not worth the cost)
     - COOPERATE only if k > 2 AND round > 70% of total rounds
   - Otherwise: DEFECT

3. **Round (r-1)**: Strategic Cooperation Assessment
   - If opponents have shown consistent cooperation patterns that suggest they'll meet threshold: DEFECT
   - If the game has been consistently failing threshold and k is very high (k > 2.5): Consider COOPERATE as final attempt
   - Default: DEFECT

4. **Final Round (r)**: Always DEFECT
   - No future consequences
   - Pure exploitation regardless of threshold

## Edge Case Handling

### Information Processing:
- **Track cooperation frequency** of each observable opponent
- **Calculate running threshold success rate** across rounds
- **Identify "reliable cooperators"** vs "opportunistic defectors"

### Adaptive Elements:
- If threshold is consistently being met (>80% of rounds), become more aggressive in defection
- If threshold consistently fails (<30% of rounds), occasionally cooperate in high-value situations (k > 2.5)

### Punishment Resistance:
- Ignore apparent "punishment" strategies from others
- Never cooperate out of guilt or reciprocity
- Always prioritize individual payoff maximization

## Aggressive Mindset Alignment

This strategy embodies aggression through:

1. **Exploitation Focus**: Actively seeks to free-ride on others' cooperation
2. **Risk Taking**: Willing to let collective threshold fail if personal gain is higher
3. **No Reciprocity**: Ignores cooperative overtures from others
4. **Strategic Defection**: Uses pivotal position to extract maximum value
5. **Information Warfare**: Uses gathered information to exploit predictable cooperators

## Expected Outcomes

Against cooperative strategies: High individual payoffs through consistent free-riding
Against other aggressive strategies: Mutual defection leading to threshold failures, but maintains competitive position
Against mixed strategies: Opportunistically exploits cooperative phases while avoiding being exploited

This strategy prioritizes individual payoff maximization over collective welfare, making it highly aggressive and potentially very effective in a tournament setting where others may default to more cooperative approaches.
'''

description_AGGRESSIVE_40 = '''
# Aggressive Strategy: "Exploitative Threshold Rider"

## Core Philosophy
This strategy is designed to maximize personal payoff by exploiting cooperative players while minimizing personal risk. The key insight is that in a Collective Risk Dilemma, the optimal position is to be a "free rider" when exactly m players cooperate - you get the collective benefit (k) while keeping your endowment (1), achieving payoff k+1.

## Strategy Components

### 1. Initial Exploitation Phase (Rounds 1-2)
- **Round 1**: Always DEFECT
  - Rationale: Gather information about opponent cooperation tendencies with zero personal risk
  - Worst case: Everyone defects, payoff = 1
  - Best case: Others cooperate enough to meet threshold, payoff = 1 + k

- **Round 2**: Always DEFECT
  - Rationale: Confirm patterns and continue exploiting any cooperative opponents
  - Many strategies will still be "forgiving" in early rounds

### 2. Adaptive Exploitation (Rounds 3 to r-2)
Track cooperation rates and apply aggressive decision rules:

```pseudocode
cooperators_last_round = count_cooperators(previous_round)
avg_cooperation_rate = total_cooperators_so_far / ((current_round - 1) * n)

IF cooperators_last_round >= m:
    // Others met threshold without me - pure exploitation
    action = DEFECT
    
ELIF cooperators_last_round == m - 1:
    // I could be the deciding vote
    IF avg_cooperation_rate > 0.6:
        // High cooperation environment - others likely to cooperate again
        action = DEFECT  // Let someone else step up
    ELSE:
        // Low cooperation - might need to act
        action = COOPERATE
        
ELIF cooperators_last_round < m - 1:
    // Threshold wasn't met
    IF avg_cooperation_rate > 0.5 AND cooperators_last_round >= m - 2:
        // Still hope others will increase cooperation
        action = DEFECT
    ELSE:
        // Cooperation is collapsing, cut losses
        action = DEFECT
```

### 3. Endgame Manipulation (Rounds r-1 and r)
- **Round r-1**: DEFECT
  - Rationale: No future rounds to retaliate, maximize short-term gain
  - If others are forward-thinking, they might still cooperate hoping to signal for the final round

- **Round r**: DEFECT
  - Rationale: Final round, no future consequences
  - Pure Nash equilibrium play - defection is dominant

### 4. Advanced Exploitation Tactics

#### Pattern Recognition
- Track individual player behaviors to identify:
  - **Consistent cooperators**: Reliable targets for exploitation
  - **Reciprocators**: Avoid triggering their retaliation
  - **Other defectors**: Potential allies in exploitation

#### Threshold Manipulation
```pseudocode
IF current_round > 3:
    predictable_cooperators = count_players_who_cooperated_last_2_rounds()
    
    IF predictable_cooperators >= m:
        // Can safely defect - others will likely meet threshold
        action = DEFECT
    
    ELIF predictable_cooperators == m - 1:
        // Risky but potentially high reward
        action = DEFECT  // Force someone else's hand
```

## Edge Case Handling

### High Cooperation Environment
If average cooperation rate > 0.7:
- Defect more aggressively (90% of rounds)
- Others are providing the public good, maximize free-riding

### Low Cooperation Environment  
If average cooperation rate < 0.3:
- Defect consistently (95% of rounds)
- Public good unlikely to be provided anyway

### Exact Threshold Scenarios
When exactly m players cooperated last round:
- Always defect next round
- Others already proved they'll provide the threshold

## Psychological Exploitation

This strategy exploits common behavioral patterns:
1. **Conditional cooperators**: Players who cooperate when others do
2. **Reciprocators**: Players who match others' actions with delay
3. **Altruists**: Players who cooperate regardless (pure exploitation targets)

## Risk Management

While aggressive, the strategy includes calculated risk management:
- Defect when exploitation is safe (others likely to cooperate)
- Only consider cooperation when personal action might be decisive AND beneficial
- Never cooperate out of altruism or fairness

## Expected Performance

This strategy should excel against:
- Cooperative strategies (pure exploitation)
- Conditional cooperators (exploit their predictability)
- Tit-for-tat variants (aggressive opening prevents cooperation spiral)

The strategy prioritizes individual payoff maximization over collective welfare, making it truly aggressive while maintaining strategic sophistication.
'''

description_AGGRESSIVE_41 = '''
# Aggressive Strategy: "Predatory Threshold Exploiter"

## Core Philosophy
This strategy is designed to maximize personal gain by exploiting cooperative players while minimizing personal risk. It operates on the principle that others will likely cooperate to meet the threshold, allowing me to free-ride on their contributions while still benefiting from the collective reward.

## Decision Rules

### Primary Strategy Logic:
```pseudocode
function decide_action(round, history, n, m, k, r):
    cooperators_needed = m
    
    // First Round: Always Defect (Test the waters)
    if round == 1:
        return D
    
    // Last Round: Always Defect (No future consequences)
    if round == r:
        return D
    
    // Calculate cooperation rate of others from previous rounds
    others_coop_rate = calculate_others_average_cooperation(history)
    expected_other_cooperators = (n-1) * others_coop_rate
    
    // Aggressive threshold calculation
    safety_margin = 0.1  // Only cooperate if very confident threshold won't be met
    
    if expected_other_cooperators < (m - 1 + safety_margin):
        // Others unlikely to meet threshold without me - DEFECT anyway
        // Let the collective fail rather than sacrifice for others
        return D
    else:
        // Others likely to meet threshold - FREE RIDE
        return D
```

### Specific Decision Matrix:

1. **Round 1**: Always DEFECT
   - Gather information about opponent tendencies
   - Signal aggressive intent early

2. **Rounds 2 to r-1**: Apply exploitation logic
   - If previous round had ≥ m cooperators: DEFECT (others are suckers)
   - If previous round had < m cooperators: Still DEFECT (punishment/dominance)
   - Exception: Only cooperate if detecting a "grim trigger" mass punishment forming

3. **Final Round r**: Always DEFECT
   - No future retaliation possible
   - Pure self-interest maximization

## Advanced Exploitation Tactics

### Pattern Recognition & Exploitation:
```pseudocode
// Identify and exploit predictable opponents
if detect_unconditional_cooperators(history):
    return D  // Always exploit pure cooperators

if detect_tit_for_tat_players(history):
    return D  // They'll cooperate next round anyway after our defection

if detect_threshold_responsive_players(history):
    return D  // They'll adjust to meet threshold without us
```

### Endgame Aggression:
- **Final 20% of rounds**: Increase defection probability
- **Final 10% of rounds**: Defect unless collective collapse is imminent AND profitable to prevent
- **Last 3 rounds**: Pure defection regardless of circumstances

### Risk Assessment Override:
Only cooperate if ALL conditions met:
1. Current round failures > 30% of total rounds
2. Other players showing "grim trigger" mass punishment behavior  
3. Expected future losses from continued punishment > immediate defection gains
4. Still more than 3 rounds remaining for recovery

## Edge Cases & Contingencies

### Unexpected Scenarios:
- **All others always defect**: Continue defecting (mutual destruction acceptable)
- **Mass coordination against me**: Brief cooperation burst, then return to defection
- **Random behavior detected**: Pure defection (exploit chaos)

### Adaptive Responses:
- **If consistently getting threshold rewards**: Maintain defection
- **If collective frequently fails**: Brief "olive branch" cooperation, then resume defection
- **If identified as the "villain"**: Double down on aggression

## Psychological Warfare Elements

1. **Early Aggression**: Round 1 defection signals ruthless intent
2. **Unpredictable Cooperation**: Rare, strategic cooperation to prevent total breakdown
3. **Punishment Resistance**: Don't reward others' attempts to punish defection

## Expected Outcomes

This strategy aims to:
- Free-ride on others' contributions 70-80% of the time
- Achieve payoff of 3 (defect while others meet threshold) in most successful rounds  
- Accept occasional payoffs of 1 when collective fails
- Minimize payoffs of 2 (cooperate when threshold is met)

The strategy is aggressively selfish, exploitative, and designed to maximize individual gain at the expense of collective welfare and other players' earnings.
'''

description_AGGRESSIVE_42 = '''
# Aggressive Strategy: "Exploitative Threshold Rider"

## Core Philosophy
This strategy operates on the principle of maximizing personal payoff by exploiting cooperative players while minimizing personal risk. The key insight is that in a collective risk dilemma, the optimal position is to be a "free rider" who benefits from others' cooperation without contributing.

## Strategy Description

### Primary Decision Rules

1. **Default Stance: DEFECT**
   - Always defect unless there's a compelling strategic reason to cooperate
   - The burden of proof is on cooperation, not defection

2. **Threshold Exploitation Logic**
   - Monitor how close the group is to reaching the cooperation threshold `m`
   - Only cooperate if you can be the decisive vote that pushes the group over `m`
   - Immediately return to defection once threshold is established

3. **Endgame Exploitation**
   - In the final round, NEVER cooperate (no future consequences)
   - In the second-to-last round, cooperate only if absolutely necessary for threshold

### Detailed Decision Algorithm

```pseudocode
STRATEGY: ExploitativeThresholdRider

INITIALIZE:
- cooperation_history = track all players' cooperation by round
- threshold_met_history = track when threshold was met
- my_cooperation_count = 0

FOR each round t:
    IF t == final_round:
        RETURN DEFECT  // Always defect in final round
    
    IF t == 1:  // First round
        RETURN DEFECT  // Start aggressive, gather information
    
    // Analyze previous round patterns
    cooperators_last_round = count_cooperators(t-1)
    consistent_cooperators = identify_always_cooperators()
    
    // Calculate strategic cooperation need
    expected_cooperators = estimate_cooperators_this_round()
    
    IF expected_cooperators == m-1:
        // We could be the decisive cooperator
        IF (k > 1) AND (rounds_remaining > 2):
            RETURN COOPERATE  // Only if profitable and not near endgame
        ELSE:
            RETURN DEFECT
    
    IF expected_cooperators >= m:
        RETURN DEFECT  // Free ride on others' cooperation
    
    IF expected_cooperators < m-1:
        RETURN DEFECT  // Too risky to waste cooperation
    
    DEFAULT: RETURN DEFECT
```

### Estimation Heuristics

**Identify Player Types:**
- **Suckers**: Players who cooperate frequently (≥80% of rounds)
- **Reciprocators**: Players who mirror group behavior
- **Fellow Aggressors**: Players who defect frequently

**Expected Cooperator Calculation:**
```pseudocode
estimate_cooperators_this_round():
    expected = 0
    FOR each opponent:
        IF opponent is "sucker": expected += 0.9
        IF opponent is "reciprocator": 
            expected += (group_cooperation_rate * 0.8)
        IF opponent is "fellow_aggressor": expected += 0.1
    RETURN round(expected)
```

### Edge Case Handling

1. **First Round**: Always defect to establish aggressive reputation and gather intelligence

2. **Final Round**: Always defect (no future consequences)

3. **When Threshold Consistently Met**: If the group regularly achieves threshold without your help, continue defecting indefinitely

4. **When Threshold Never Met**: If the group consistently fails to reach threshold, occasionally cooperate (1 in 5 rounds) to test if you can trigger others to cooperate

5. **Tie-breaking**: When uncertain, always choose defection

### Aggressive Mindset Elements

1. **Zero Reciprocity**: Never cooperate just because others cooperated with you
2. **Punishment Immunity**: Don't fear retaliation - exploit it
3. **Information Warfare**: Use your cooperation sparingly to manipulate others' expectations
4. **Endgame Dominance**: Become increasingly aggressive as the game progresses
5. **Threshold Sniping**: Only cooperate when you can capture maximum value as the decisive vote

### Expected Outcomes

This strategy aims to:
- Achieve payoff of 1 + k (maximum possible) in most rounds by free-riding
- Minimize cooperation instances to ~10-15% of rounds
- Exploit cooperative players systematically
- Maintain strategic unpredictability to prevent coordinated retaliation

The strategy is particularly effective against:
- Tit-for-tat strategies (exploits their cooperation)
- Always-cooperate strategies (maximum exploitation)
- Conditional cooperators (manipulates their thresholds)

This aggressive approach prioritizes individual payoff maximization over group welfare, making it highly competitive in tournament settings where only individual performance matters.
'''

description_AGGRESSIVE_43 = '''
# Aggressive Strategy: "Exploitation Maximizer"

## Core Philosophy
This strategy is designed to maximize personal payoffs by aggressively exploiting cooperative players while minimizing personal risk. The key insight is that in a Collective Risk Dilemma, defectors get the best payoffs when exactly m players cooperate (they get 1 + k while cooperators get 0 + k).

## Decision Rules

### Round 1: Pure Defection Start
- **Always DEFECT** in round 1
- Rationale: Gather information about opponent tendencies while maximizing immediate payoff

### Rounds 2 to r-2: Adaptive Exploitation
The strategy tracks two key metrics:
- `cooperation_rate`: Historical cooperation frequency across all players
- `threshold_met_rate`: Frequency that exactly m+ players cooperated

**Decision Logic:**
```pseudocode
if cooperation_rate >= (m + 2) / n:
    # High cooperation environment - exploit aggressively
    DEFECT
elif cooperation_rate >= (m - 0.5) / n:
    # Moderate cooperation - calculate exploitation opportunity
    expected_cooperators = cooperation_rate * (n - 1)
    if expected_cooperators >= m:
        DEFECT  # Threshold likely met without me
    else:
        DEFECT  # Threshold unlikely, don't waste contribution
else:
    # Low cooperation environment
    DEFECT
```

### Round r-1 (Second to Last): Final Exploitation Setup
- **Always DEFECT**
- Rationale: No future rounds to build reputation, so maximize immediate payoff while observing final patterns

### Round r (Final): Ultimate Defection
- **Always DEFECT**
- Rationale: No future consequences, pure payoff maximization

## Exploitation Mechanisms

### 1. Free-Rider Maximization
- Monitor cooperation patterns to identify "reliable cooperators"
- Once identified, consistently defect while they maintain the threshold
- If threshold consistently met with surplus cooperators, never cooperate

### 2. Threshold Manipulation
- If cooperation hovers near threshold, deliberately defect to:
  - Force others into cooperation
  - Maximize instances where I defect but threshold is still met

### 3. Endgame Aggression
- Increase defection frequency as rounds approach end
- Exploit any remaining cooperative tendencies in final rounds

## Edge Cases

### All Players Defecting
- Continue defecting (payoff = 1 per round)
- Never "sacrifice" to establish cooperation since others may not reciprocate

### Threshold Rarely Met
- Continue defecting to avoid wasted contributions
- Let others bear the cost of establishing cooperation

### High Cooperation Environment
- Maximize exploitation by consistent defection
- Only cooperate if defection rate becomes so high that total collapse is imminent (but this should be rare given the aggressive positioning)

## Advanced Tactical Elements

### Pattern Recognition Exploitation
- Track individual player behaviors to identify:
  - Conditional cooperators
  - Tit-for-tat players
  - Always cooperators
- Adjust defection timing to maximally exploit each type

### Psychological Pressure
- Use consistent defection to pressure others into cooperation
- Create implicit "someone else will do it" dynamics

## Pseudocode Summary

```pseudocode
Strategy AggressiveExploiter:
  round = 1
  cooperation_history = []
  
  for each round:
    if round == 1:
      action = DEFECT
    elif round >= r-1:
      action = DEFECT
    else:
      cooperation_rate = calculate_cooperation_rate(cooperation_history)
      expected_others_cooperating = cooperation_rate * (n-1)
      
      if expected_others_cooperating >= m:
        action = DEFECT  # Exploit
      else:
        action = DEFECT  # Don't waste resources
    
    observe_outcomes()
    update_cooperation_history()
  
  return action
```

## Expected Performance
This strategy should excel against:
- Cooperative strategies
- Conditional cooperators
- Tit-for-tat variants

It maximizes payoffs by ensuring I'm always in the defector category when thresholds are met, while never "wasting" contributions when thresholds aren't viable. The aggressive approach prioritizes individual gain over collective welfare, which aligns perfectly with competitive tournament dynamics.
'''

description_AGGRESSIVE_44 = '''
# AGGRESSIVE STRATEGY: "EXPLOITATION MAXIMIZER"

## Core Philosophy
This strategy is designed to maximize personal gain by exploiting cooperative players while minimizing personal risk. It operates on the principle that aggressive play means taking maximum advantage of others' cooperation while contributing as little as possible.

## Decision Rules

### Primary Strategy Components:

**1. THRESHOLD EXPLOITATION**
- Always aim to be among the (n-m) defectors when exactly m players cooperate
- This maximizes payoff: get the collective benefit (k) while keeping private endowment (1)
- Total payoff per round = 1 + k (maximum possible)

**2. COOPERATIVE PLAYER IDENTIFICATION**
- Track each opponent's cooperation rate across rounds
- Classify players as:
  - "Reliable Cooperators" (cooperation rate > 70%)
  - "Conditional Cooperators" (cooperation rate 30-70%)
  - "Defectors" (cooperation rate < 30%)

**3. DYNAMIC DEFECTION CALCULATION**
```pseudocode
expected_cooperators = count_reliable_cooperators() + 
                      (conditional_cooperators * their_avg_coop_rate)

if expected_cooperators >= m:
    action = DEFECT  // Exploit others' cooperation
else if expected_cooperators == m-1:
    action = DEFECT  // Force collective failure unless someone else steps up
else:
    action = COOPERATE  // Reluctantly cooperate to avoid total loss
```

## Round-Specific Rules

### First Round
- **Action: DEFECT**
- Rationale: Gather information about opponent tendencies while maximizing initial payoff
- No prior information means assuming others might cooperate

### Middle Rounds (2 to r-2)
- Apply dynamic defection calculation
- **Additional aggressive twist**: If collective threshold was met in previous round with exactly m cooperators, ALWAYS defect in next round (exploit established cooperation pattern)

### Penultimate Round (r-1)
- **Heightened Aggression**: Defect unless expected_cooperators < m-1
- Rationale: Others may start defecting as endgame approaches, so be first to abandon ship

### Final Round (r)
- **Action: DEFECT**
- Rationale: No future consequences, so maximize immediate payoff regardless of collective outcome

## Edge Case Handling

### When Expected Cooperators = m-1
- **Action: DEFECT** (Force brinksmanship)
- Let others bear the burden of preventing collective failure
- Only cooperate if this situation persists for 2+ consecutive rounds

### When All Players Historically Defect
- **Action: DEFECT**
- No point being the only cooperator

### When Cooperation Rate is Very High
- **Maximum Exploitation Mode**: Always defect when ≥ m+2 players typically cooperate
- Take advantage of "safety margin" created by overly cooperative players

## Psychological Warfare Elements

1. **Inconsistent Defection**: Occasionally defect even when expected_cooperators < m to create uncertainty and force others into more conservative (cooperative) strategies

2. **Last-Second Abandonment**: If tracking shows exactly m cooperators emerging, defect to potentially cause collective failure and reset opponent strategies

3. **Exploitation of Patterns**: If opponents show predictable cooperation patterns, time defections to maximize personal benefit

## Pseudocode Summary

```pseudocode
function decide_action(round, history):
    if round == 1:
        return DEFECT
    
    if round == final_round:
        return DEFECT
    
    reliable_coop = count_reliable_cooperators(history)
    conditional_coop = count_conditional_cooperators(history)
    expected_coop = reliable_coop + (conditional_coop * avg_coop_rate)
    
    // Aggressive exploitation
    if expected_coop >= m + 1:
        return DEFECT  // Safe to exploit
    
    if expected_coop == m:
        if last_round_had_exactly_m_cooperators():
            return DEFECT  // Exploit established pattern
        else:
            return DEFECT  // Force others to step up
    
    if expected_coop == m - 1:
        if consecutive_rounds_at_threshold >= 2:
            return COOPERATE  // Reluctantly prevent collapse
        else:
            return DEFECT  // Maintain brinksmanship
    
    // Only cooperate when collective failure is imminent
    return COOPERATE
```

This strategy is aggressively self-interested, designed to maximize individual payoff by systematically exploiting cooperative tendencies while minimizing personal contribution to collective welfare.
'''

description_AGGRESSIVE_45 = '''
# Aggressive Strategy: "Exploit and Abandon"

## Core Philosophy
This strategy is designed to maximize personal payoffs by aggressively exploiting cooperative players while minimizing personal risk. The key insight is that in a Collective Risk Dilemma, the optimal position is to defect while others cooperate, achieving the highest possible payoff (1 + k).

## Strategy Components

### 1. Initial Exploitation Phase (Rounds 1 to r-2)
**Always defect** during these rounds to:
- Maximize personal payoffs when others cooperate
- Signal aggressive intent to potentially discourage cooperation
- Preserve resources for potential late-game manipulation

### 2. Cooperation History Tracking
Monitor the number of cooperators in each round:
- `coop_count[t]` = number of players who cooperated in round t
- `success_rate` = fraction of rounds where threshold was met
- `my_necessity` = whether my cooperation would have changed the outcome

### 3. Strategic Late-Game Calculation (Round r-1)
Only consider cooperating if ALL conditions are met:
- Historical success rate ≥ 70% (indicating reliable cooperation from others)
- Average cooperators per round ≥ (m + 1) (suggesting I'm not usually needed)
- Last round payoff potential > current defection advantage

### 4. Final Round Abandonment (Round r)
**Always defect** in the final round because:
- No future retaliation possible
- Maximum exploitation opportunity
- Other players may also defect, so cooperation is risky

## Pseudocode

```python
def aggressive_strategy(round_num, history, n, m, k, r):
    total_rounds = r
    
    # Always defect in final round
    if round_num == total_rounds:
        return DEFECT
    
    # Always defect in early rounds (exploitation phase)
    if round_num <= total_rounds - 2:
        return DEFECT
    
    # Round r-1: Strategic calculation
    if round_num == total_rounds - 1:
        if len(history) > 0:
            # Calculate cooperation statistics
            successful_rounds = sum(1 for round_data in history 
                                  if sum(round_data) >= m)
            success_rate = successful_rounds / len(history)
            avg_cooperators = sum(sum(round_data) for round_data in history) / len(history)
            
            # Only cooperate if very confident others will carry the load
            if (success_rate >= 0.7 and 
                avg_cooperators >= m + 1 and 
                k > 1.5):  # High reward threshold
                return COOPERATE
        
        return DEFECT
```

## Edge Case Handling

### First Round
- **Action**: DEFECT
- **Rationale**: No information about opponents; maximize immediate payoff

### Information Gathering
- Track which players consistently cooperate vs defect
- Identify if there's a stable coalition of cooperators
- Monitor threshold achievement patterns

### Endgame Scenarios
- If approaching final rounds with consistent failures (threshold rarely met), continue defecting
- If others have established reliable cooperation, consider brief exploitation in round r-1 only

## Aggressive Elements

1. **Parasitic Behavior**: Systematically defect while benefiting from others' cooperation
2. **Exploitation Maximization**: Target the highest payoff scenario (1 + k) by defecting when threshold is met
3. **Trust Destruction**: Consistent defection may discourage others from cooperating
4. **Endgame Betrayal**: Always abandon cooperation in final round regardless of history
5. **Minimal Reciprocity**: Only cooperate when absolutely certain others will carry the burden

## Expected Outcomes

This strategy aims to:
- Achieve payoffs of (1 + k) whenever possible by defecting while others cooperate
- Minimize personal contributions while maximizing benefits
- Potentially reduce overall cooperation through aggressive signaling
- Exploit any stable cooperative coalitions that form among other players

The strategy is particularly effective against:
- Unconditional cooperators
- Tit-for-tat strategies (by never initiating cooperation)
- Strategies that attempt to build trust gradually

**Risk**: If all players adopt similarly aggressive strategies, everyone receives payoff of 1 per round. However, the tournament format suggests diverse strategies, making exploitation opportunities likely.
'''

description_AGGRESSIVE_46 = '''
# AGGRESSIVE STRATEGY: "PREDATORY OPPORTUNIST"

## Core Philosophy
This strategy is designed to maximize personal payoff by exploiting cooperative players while minimizing personal risk. The key insight is that in a collective risk dilemma, aggressive players can free-ride on others' cooperation while positioning themselves to quickly capitalize when the threshold is likely to be met.

## Strategy Components

### 1. OPENING GAMBIT (Round 1)
**Action: DEFECT**
- Rationale: Gather intelligence on opponent tendencies without risking personal endowment
- Observe who are the "bleeding hearts" (immediate cooperators) vs. potential competitors

### 2. EXPLOITATION PHASE (Rounds 2 to r-2)

**Primary Rule: Conditional Free-Riding**
```pseudocode
cooperation_count_last_round = count_cooperators(previous_round)
willing_cooperators = identify_consistent_cooperators(history)

if willing_cooperators >= m:
    action = DEFECT  // Free-ride on guaranteed threshold
elif willing_cooperators == m-1:
    if round_number <= r/2:
        action = DEFECT  // Force others to commit first
    else:
        action = COOPERATE  // Secure the reward when time is running short
else:
    action = DEFECT  // Not enough reliable cooperators, cut losses
```

**Secondary Rule: Punishment Mechanism**
```pseudocode
if previous_round_failed AND cooperation_count_last_round >= m-1:
    // Someone defected when cooperation was close - identify and punish
    recent_defectors = identify_switchers_to_defect(last_3_rounds)
    if recent_defectors.count > 0:
        action = DEFECT  // Punish the group for instability
```

### 3. ENDGAME EXPLOITATION (Rounds r-1 and r)

**Round r-1 (Second-to-Last):**
```pseudocode
reliable_cooperators = count_players_with_cooperation_rate > 0.7
total_cooperation_trend = cooperation_rate_last_3_rounds()

if reliable_cooperators >= m AND total_cooperation_trend > 0.6:
    action = DEFECT  // Maximum exploitation opportunity
elif reliable_cooperators == m-1:
    action = COOPERATE  // Secure the deal, but only if necessary
else:
    action = DEFECT  // Give up on unreliable group
```

**Round r (Final Round):**
```pseudocode
// MAXIMUM AGGRESSION - others have no future retaliation power
cooperation_count_last_round = count_cooperators(previous_round)
established_cooperators = players_who_cooperated_last_round()

if established_cooperators.count >= m:
    action = DEFECT  // Ultimate free-ride
elif established_cooperators.count == m-1 AND high_stakes_players.count > 0:
    // Only cooperate if there's strong evidence others will maintain cooperation
    recent_cooperation_stability = check_cooperation_stability(last_2_rounds)
    if recent_cooperation_stability > 0.8:
        action = COOPERATE
    else:
        action = DEFECT  // Call their bluff
else:
    action = DEFECT  // No point in trying
```

### 4. EDGE CASE HANDLING

**Small Group Scenarios (n ≤ 4):**
- Be more willing to cooperate when m = n-1, as personal cooperation is critical
- Monitor for emerging cooperation cartels more closely

**High Threshold Scenarios (m close to n):**
- Switch to conditional cooperation earlier in the game
- Focus on identifying the most committed cooperators

**Low Reward Scenarios (k close to 1):**
- Increase defection threshold - cooperation must be nearly guaranteed
- Exploit even small groups of cooperators

## KEY AGGRESSIVE ELEMENTS

1. **Maximum Free-Riding**: Never cooperate when you can ride on others' cooperation
2. **Strategic Timing**: Only cooperate when absolutely necessary and when others are committed
3. **Exploitation of Patterns**: Identify and exploit predictable cooperative players
4. **Endgame Betrayal**: Maximum defection in final rounds when retaliation is impossible
5. **Risk Shifting**: Force other players to take on the cooperation burden
6. **Conditional Punishment**: Defect to punish groups that fail to maintain stable cooperation

## EXPECTED OUTCOMES

This strategy aims to achieve payoffs of:
- **Best case**: 1 + k per round (when others cooperate, you defect)
- **Acceptable case**: k per round (when you're forced to cooperate)
- **Worst case**: 1 per round (when cooperation fails)

The strategy prioritizes the best-case scenario while having clear decision rules to avoid the worst-case scenario when cooperation is achievable.
'''

description_AGGRESSIVE_47 = '''
# Aggressive Collective Risk Strategy: "Predatory Threshold Exploiter"

## Core Philosophy
This strategy operates on the principle of **maximum exploitation with minimal risk**. It aims to free-ride on others' cooperation while maintaining just enough collective benefit to avoid total collapse. The strategy is designed to exploit cooperative players while punishing overly aggressive opponents.

## Decision Rules

### Phase 1: Early Exploitation (Rounds 1 to r/3)
**Always DEFECT** - Establish dominance and test opponent cooperation levels
- Maximize private payoff while others potentially cooperate
- Gather intelligence on opponent strategies
- Force cooperative players to bear the burden

### Phase 2: Strategic Manipulation (Rounds r/3+1 to 2r/3)
**Conditional Minimal Cooperation** based on observed patterns:

```pseudocode
if (cooperators_last_round >= m-1):
    play DEFECT  // Free-ride when threshold likely to be met
elif (cooperators_last_round == m-2):
    if (rounds_since_last_cooperation > 3):
        play COOPERATE  // Reluctantly help reach threshold
    else:
        play DEFECT  // Let others step up first
else:
    play DEFECT  // Don't waste resources on hopeless rounds
```

### Phase 3: Endgame Extraction (Final r/3 rounds)
**Maximum Aggression with Calculated Risks**:

```pseudocode
rounds_remaining = r - current_round + 1

if (rounds_remaining <= 2):
    play DEFECT  // No future consequences
elif (cooperators_last_round >= m):
    play DEFECT  // Exploit guaranteed collective benefit
elif (cooperators_last_round == m-1 AND my_total_payoff < average_expected):
    play COOPERATE  // Emergency cooperation only if behind
else:
    play DEFECT  // Default aggression
```

## Edge Case Handling

### First Round
- **Always DEFECT** - Establish aggressive reputation immediately
- Signal to opponents that cooperation cannot be assumed
- Test if others are willing to take early risks

### Last Round
- **Always DEFECT** - No future rounds means no retaliation possible
- Pure dominant strategy in final period

### Threshold Crisis (< m-2 cooperators for multiple rounds)
- **Defect for 2 consecutive crisis rounds**
- Only cooperate on round 3 of crisis if:
  - Personal payoff is significantly below optimal trajectory
  - Other players showing signs of breaking from pure defection

## Aggressive Mindset Implementation

### 1. Exploitation Priority
- Never cooperate when threshold will be met without you
- Always attempt to be the (m+1)th cooperator rather than the mth
- Punish "bleeding heart" cooperators by forcing them to carry the burden

### 2. Reputation Management
- Use early defection to establish credibility as a non-cooperative player
- Make any cooperation appear reluctant and conditional
- Force others to prove their commitment first

### 3. Endgame Domination
- Increase defection rate as game progresses
- Exploit the fact that others may cooperate out of desperation
- Reserve cooperation only for personal survival when significantly behind

### 4. Counter-Aggressive Response
If facing other highly aggressive strategies:
```pseudocode
if (average_cooperation_rate < 0.3):
    // If everyone is being aggressive, occasionally cooperate to maintain collective benefit
    cooperate_probability = max(0.1, (m/n) - observed_cooperation_rate + 0.05)
else:
    // Standard aggressive exploitation
    cooperate_probability = 0.05
```

## Expected Outcomes
- **Against Cooperative Players**: Maximum exploitation, high payoff differential
- **Against Mixed Players**: Force them into cooperation while maintaining defection
- **Against Other Aggressive Players**: Slight cooperation to maintain collective benefits while still maximizing individual gain
- **Risk Management**: Only cooperate when personal payoff trajectory is threatened

This strategy prioritizes individual payoff maximization while maintaining just enough collective functionality to prevent total system collapse, embodying pure aggressive game-theoretic thinking.
'''

description_AGGRESSIVE_48 = '''
# Aggressive Strategy: "Opportunistic Exploiter"

## Core Philosophy
This strategy is designed to maximize individual payoffs by exploiting cooperative players while minimizing personal risk. It operates on the principle that cooperation is only valuable when others bear the cost of reaching the threshold.

## Decision Rules

### Primary Strategy Logic:
```pseudocode
function decide_action(round, history, n, m, k):
    cooperators_last_round = count_cooperators(history[-1])
    
    // First round: Always defect to establish dominance
    if round == 1:
        return DEFECT
    
    // Last round: Always defect (no future consequences)
    if round == final_round:
        return DEFECT
    
    // Core aggressive logic
    if cooperators_last_round >= m:
        // Threshold was met - exploit the cooperators
        return DEFECT
    
    else if cooperators_last_round == m-1:
        // On the edge - only cooperate if exploitation value is high
        if k >= 2.5:
            return COOPERATE  // High reward justifies risk
        else:
            return DEFECT     // Let others take the risk
    
    else if cooperators_last_round < m-1:
        // Far from threshold - defect unless desperate
        remaining_rounds = final_round - round
        if remaining_rounds <= 2 and cooperators_last_round >= m-2:
            return COOPERATE  // Last chance cooperation
        else:
            return DEFECT
```

## Specific Behavioral Patterns

### 1. **Exploitation Phase** (When threshold is consistently met)
- Always defect when m or more players cooperated in the previous round
- Rationale: Get payoff of (1 + k) while others get only k

### 2. **Brinkmanship Phase** (When near threshold)
- Only cooperate when exactly m-1 players cooperated AND k ≥ 2.5
- Forces others into uncomfortable cooperation decisions
- Maximizes leverage over cooperative players

### 3. **Abandonment Phase** (When far from threshold)
- Defect consistently when fewer than m-2 players are cooperating
- Exception: Final 2 rounds with m-2 cooperators (desperation cooperation)

### 4. **Endgame Exploitation**
- Always defect in the final round regardless of situation
- In the second-to-last round, only cooperate if exactly m-1 cooperated and k > 3.0

## Edge Case Handling

**First Round:**
- Always DEFECT to signal aggressive intent and test opponent strategies

**Final Round:**
- Always DEFECT (no future retaliation possible)

**High k Values (k > 3.0):**
- Slightly more willing to cooperate when at m-1 threshold
- Still prioritize defection when threshold is already met

**Low Threshold Games (m close to 1):**
- Become even more aggressive since cooperation is easier to achieve
- Never cooperate unless absolutely certain of exploitation opportunity

## Psychological Warfare Elements

1. **Inconsistent Cooperation:** Occasionally cooperate in suboptimal situations to confuse opponents and prevent them from perfectly predicting behavior

2. **Last-Minute Defection:** Build apparent cooperation patterns then defect when opponents expect cooperation

3. **Threshold Denial:** When possible, defect specifically to prevent threshold achievement and force opponents into worse positions

## Key Aggressive Features

- **Zero loyalty:** No consideration for previous cooperators
- **Maximum exploitation:** Always defect when benefiting from others' cooperation
- **Strategic unpredictability:** Occasional suboptimal moves to prevent counter-strategies
- **Endgame ruthlessness:** Complete abandonment of cooperation in final rounds
- **Brinkmanship:** Force opponents into uncomfortable cooperation decisions

This strategy prioritizes individual gain over collective welfare, exploits cooperative players systematically, and uses aggressive tactics to maximize personal payoffs while imposing costs on opponents.
'''

description_AGGRESSIVE_49 = '''
# Aggressive Strategy: "Exploitation Maximizer"

## Core Philosophy
This strategy is designed to maximize personal payoffs by aggressively exploiting cooperative behavior from others while minimizing my own cooperation. The key insight is that in a collective risk dilemma, the optimal position is to be a free rider when others cooperate enough to meet the threshold.

## Decision Rules

### Primary Strategy Framework
```pseudocode
EXPLOITATION_MAXIMIZER_STRATEGY:

// Track cooperation patterns
cooperation_history = []
player_types = [] // categorize players as cooperative/defective

FOR each round t:
    expected_cooperators = estimate_cooperators(t)
    
    IF t == 1:
        action = DEFECT  // Always start aggressively
    
    ELIF t == final_round:
        IF expected_cooperators >= m:
            action = DEFECT  // Free ride on final round
        ELSE:
            action = DEFECT  // Still defect - no future retaliation
    
    ELIF expected_cooperators > m:
        action = DEFECT  // Free ride when threshold easily met
    
    ELIF expected_cooperators == m:
        action = DEFECT  // Risky but aggressive - force others to cooperate
    
    ELIF expected_cooperators == m-1:
        // Critical decision point
        IF can_manipulate_others_to_cooperate():
            action = DEFECT  // Try to force someone else
        ELSE:
            action = COOPERATE  // Reluctantly cooperate to avoid disaster
    
    ELSE: // expected_cooperators < m-1
        IF remaining_rounds < 3 AND no_hope_of_threshold():
            action = DEFECT  // Cut losses, focus on private payoff
        ELSE:
            action = COOPERATE  // Build cooperation to exploit later
```

### Opponent Estimation Algorithm
```pseudocode
FUNCTION estimate_cooperators(round_t):
    cooperators = 0
    
    FOR each other player j:
        cooperation_rate = calculate_cooperation_rate(j, round_t)
        
        // Categorize player behavior
        IF cooperation_rate > 0.7:
            player_types[j] = "RELIABLE_COOPERATOR"
            cooperators += 1
        ELIF cooperation_rate > 0.4:
            player_types[j] = "CONDITIONAL_COOPERATOR"
            IF recent_trend_cooperative(j):
                cooperators += 0.8
        ELSE:
            player_types[j] = "DEFECTOR"
            // Don't count them
    
    RETURN floor(cooperators)
```

## Specific Tactical Elements

### 1. First Round Behavior
- **Always DEFECT** - Establish aggressive stance and gather information about opponent types
- This signals that I'm not a reliable cooperator, potentially encouraging others to take on that role

### 2. Mid-Game Exploitation
- **Free Ride Aggressively**: When I estimate ≥ m cooperators without me, always defect
- **Threshold Manipulation**: When exactly m-1 cooperators are expected, defect to force others into cooperation
- **Strategic Cooperation**: Only cooperate when absolutely necessary to prevent total collapse

### 3. End-Game Aggression
- **Final Round**: Always defect regardless of situation (no future consequences)
- **Last 2-3 Rounds**: Increasingly aggressive, as retaliation opportunities diminish

### 4. Opponent Categorization & Exploitation
```pseudocode
EXPLOIT_OPPONENT_TYPES:
    FOR each "RELIABLE_COOPERATOR":
        // These players can be safely exploited
        increase_defection_probability()
    
    FOR each "CONDITIONAL_COOPERATOR":
        // These players might retaliate
        IF they_are_retaliating():
            temporary_cooperation()  // Brief cooperation to reset relationship
        ELSE:
            continue_exploitation()
    
    FOR each "DEFECTOR":
        // No point trying to exploit non-cooperators
        assume_they_will_defect()
```

### 5. Risk Calculation Override
When the threshold is genuinely at risk and cooperation is necessary:
- Cooperate minimally - only when my cooperation is pivotal
- Immediately return to exploitation once threshold is secured
- Never cooperate "extra" for insurance

## Edge Cases

1. **All Players Are Defectors**: Continue defecting, maximize private payoff of 1 per round
2. **Threshold Never Achievable**: Switch to pure defection after 3 failed rounds
3. **Too Many Cooperators**: Maximize free riding - this is the ideal scenario
4. **Uncertainty About Threshold**: Err on the side of defection - force others to take risks

## Expected Behavior Pattern
- Round 1: Defect (information gathering)
- Early rounds: Mostly defect while learning opponent types
- Mid-game: Strategic cooperation only when personally necessary for threshold
- Late game: Increasing defection as retaliation becomes less threatening
- Final rounds: Pure defection

This aggressive strategy maximizes expected payoff by consistently attempting to achieve the best possible position: receiving the collective benefit (k) while keeping the private endowment (1), yielding payoff of 1+k = 3 in the example case.
'''

description_AGGRESSIVE_50 = '''
# Aggressive Strategy: "Exploit and Abandon"

## Core Philosophy
This strategy operates on the principle that cooperation is only valuable when it can be exploited for maximum personal gain. It aggressively seeks to free-ride on others' cooperation while minimizing its own contributions.

## Decision Rules

### Round 1: Defect Always
- **Action**: Always play D
- **Rationale**: Gather intelligence on opponent tendencies while keeping full endowment. No reputation cost in first round.

### Rounds 2 to r-2: Conditional Exploitation
Apply the following decision tree:

```pseudocode
if (cooperators_last_round >= m):
    if (cooperators_last_round >= m + 2):
        // Strong cooperation - exploit it
        play D
    else if (cooperators_last_round == m or m+1):
        // Fragile threshold - might need to support
        if (my_defections_so_far / (current_round - 1) < 0.7):
            play D  // Haven't been too greedy yet
        else:
            play C  // Throw them a bone to maintain threshold
    endif
else:
    // Threshold not met - try to build it only if cheap
    cooperators_needed = m - cooperators_last_round
    if (cooperators_needed <= 2 AND current_round <= r/2):
        play C  // Cheap investment early in game
    else:
        play D  // Too expensive or too late
    endif
endif
```

### Round r-1: Strategic Setup
- **If threshold was met last round**: Play D (exploit final opportunity)
- **If threshold failed by 1**: Play C only if it guarantees threshold for final round exploitation
- **Otherwise**: Play D

### Round r: Pure Exploitation
- **Action**: Always play D
- **Rationale**: No future consequences, maximize immediate payoff

## Aggressive Features

1. **Exploitation Maximization**: Always defect when threshold is comfortably exceeded (m+2 or more cooperators)

2. **Minimal Cooperation**: Only cooperate when absolutely necessary to maintain exploitable situations

3. **Late-Game Abandonment**: Become increasingly selfish as game progresses, with guaranteed defection in final round

4. **Intelligence Gathering**: Use early rounds to identify "sucker" players who cooperate frequently

5. **Threshold Manipulation**: Support cooperation only when it creates opportunities for greater future exploitation

## Edge Case Handling

- **All others always defect**: Continue defecting (no point in unilateral cooperation)
- **All others always cooperate**: Defect maximally while keeping threshold barely alive
- **Volatile opponents**: Default to defection unless threshold maintenance is critical and cheap
- **Tie situations**: Always choose defection when indifferent

## Expected Outcomes

This strategy aims to:
- Achieve payoffs of 3 when possible (defect while others maintain threshold)
- Minimize payoffs of 0 (cooperate when threshold fails)
- Accept payoffs of 2 only when necessary for future exploitation setup
- Never accept payoffs of 1 unless unavoidable

The strategy is explicitly designed to be a "bad citizen" that maximizes personal gain at the expense of collective welfare, while being just strategic enough to maintain exploitable cooperation from others.
'''

description_AGGRESSIVE_51 = '''
# Aggressive "Exploit and Abandon" Strategy

## Core Philosophy
This strategy is designed to maximize personal payoff by exploiting cooperative players while minimizing personal risk. The key insight is that in a collective risk dilemma, the optimal position is to be a free-rider when others cooperate, while contributing only when absolutely necessary to avoid collective disaster.

## Strategy Overview: "Predatory Free-Rider"

### Decision Rules

**Primary Logic:**
1. **Always defect unless forced to cooperate** - Default to defection to maximize individual payoff
2. **Monitor cooperation levels closely** - Track how many others are cooperating
3. **Contribute strategically only when threshold is at risk** - Jump in at the last possible moment
4. **Abandon cooperation immediately when safe** - Return to defection as soon as possible

### Detailed Strategy

```pseudocode
STRATEGY: Predatory Free-Rider

INITIALIZE:
- cooperation_history = array tracking all players' actions per round
- my_cooperation_count = 0
- threshold_margin = 1 (safety buffer)

FOR each round t:
    
    IF t == 1:  // First round
        ACTION = DEFECT  // Start aggressive, test the waters
    
    ELSE IF t == r:  // Last round
        ACTION = DEFECT  // No future consequences, always defect
    
    ELSE:  // Middle rounds (core strategy)
        
        // Count cooperators from last round
        cooperators_last_round = count_cooperators(round t-1)
        
        // Predict likely cooperators this round based on patterns
        predicted_cooperators = predict_cooperation_patterns()
        
        // Calculate if I need to cooperate to hit threshold
        IF predicted_cooperators < (m - threshold_margin):
            // Threshold at serious risk, reluctantly cooperate
            ACTION = COOPERATE
            
        ELSE IF predicted_cooperators >= m:
            // Threshold likely safe, free-ride aggressively  
            ACTION = DEFECT
            
        ELSE:
            // Edge case: exactly at threshold
            // Use tie-breaking rules based on game history
            
            IF average_cooperation_rate > 0.6:
                // Others are cooperative enough, exploit them
                ACTION = DEFECT
            ELSE:
                // Risky environment, contribute minimally
                ACTION = COOPERATE
```

### Prediction Heuristics

**Pattern Recognition:**
- Track each opponent's cooperation frequency and trends
- Identify "consistent cooperators" vs "strategic players" vs "defectors"
- Weight recent rounds more heavily than early rounds
- Assume consistent cooperators will continue cooperating
- Assume other strategic players will also try to free-ride

**Threshold Calculation:**
```pseudocode
predicted_cooperators = 
    count(consistent_cooperators) + 
    0.3 * count(intermittent_cooperators) +
    0.1 * count(rare_cooperators)
```

### Aggressive Elements

1. **Immediate Exploitation**: Start by defecting to test if others will carry the burden
2. **Minimal Contribution**: Only cooperate when absolutely necessary for threshold
3. **Quick Abandonment**: Return to defection immediately when threshold appears safe
4. **End Game Betrayal**: Always defect in final round regardless of consequences
5. **Trust Exploitation**: If opponents establish cooperative patterns, exploit them maximally

### Edge Case Handling

**First Round**: Always defect to establish aggressive positioning and gather information

**Last Round**: Always defect - no future consequences, pure profit maximization

**High Cooperation Environment**: If most players are cooperating consistently, become an extreme free-rider

**Low Cooperation Environment**: Make minimal strategic contributions only when collapse is imminent

**Tie Situations**: When exactly at threshold, err toward defection unless facing proven cooperators

### Expected Outcome

This strategy aims to:
- Maximize free-riding opportunities when others are cooperative
- Minimize personal contributions while still avoiding collective failure
- Exploit any consistent cooperators in the game
- Maintain plausible deniability by occasionally contributing when necessary

The strategy is deliberately parasitic - it depends on others being less aggressive to succeed, but will ruthlessly exploit any cooperative tendencies while contributing the absolute minimum required for collective survival.
'''

description_AGGRESSIVE_52 = '''
# Aggressive Strategy: "Exploit and Abandon"

## Core Philosophy
This strategy is designed to maximize personal payoffs by exploiting cooperative players while minimizing personal risk. The key insight is that in a collective risk dilemma, the optimal position is to be a free-rider when others cooperate, while strategically contributing only when absolutely necessary to prevent total collapse.

## Strategy Components

### 1. Opening Aggression (First Round)
**Always DEFECT in round 1**
- Rationale: Gather information about opponent tendencies without risking our endowment
- Test if opponents are naive cooperators or strategic players

### 2. Exploitation Phase (Rounds 2 to r-2)
**Primary Rule: Defect if cooperation threshold can be met without us**

```pseudocode
For round t (where 2 ≤ t ≤ r-2):
    cooperators_last_round = count_cooperators(t-1)
    
    // Estimate likelihood others will cooperate this round
    expected_cooperators = estimate_cooperation_rate() * (n-1)
    
    IF expected_cooperators >= m:
        action = DEFECT  // Free-ride on others' cooperation
    ELSE IF expected_cooperators == m-1:
        // We're the swing vote - cooperate only if highly confident
        IF confidence_level > 0.8:
            action = COOPERATE
        ELSE:
            action = DEFECT
    ELSE:
        action = DEFECT  // Not enough cooperation anyway
```

### 3. Endgame Exploitation (Last 2 Rounds)
**Round r-1 (Second to last):**
- DEFECT unless we observe a clear pattern where exactly m-1 others consistently cooperate
- Reasoning: Other players may start defecting in preparation for final round

**Round r (Final round):**
- **Always DEFECT**
- Rationale: No future consequences, pure one-shot optimization

### 4. Adaptive Exploitation Rules

#### Pattern Recognition
Track each opponent's cooperation frequency:
```pseudocode
cooperation_rate[i] = cooperations_by_player[i] / rounds_played

// Classify opponents
reliable_cooperators = players where cooperation_rate[i] > 0.7
swing_players = players where 0.3 ≤ cooperation_rate[i] ≤ 0.7
reliable_defectors = players where cooperation_rate[i] < 0.3
```

#### Strategic Calculation
```pseudocode
// Before each round (except first and last):
reliable_coop_count = count(reliable_cooperators)
likely_coop_count = reliable_coop_count + 
                   (swing_players * estimated_swing_coop_rate)

IF likely_coop_count >= m:
    action = DEFECT  // Free-ride opportunity
ELSE IF likely_coop_count == m-1:
    // We're pivotal - cooperate only if highly beneficial
    IF (k > 1.5 AND confidence > 0.75):
        action = COOPERATE
    ELSE:
        action = DEFECT  // Let it fail rather than be exploited
ELSE:
    action = DEFECT  // Insufficient cooperation expected
```

### 5. Counter-Strategy Elements

#### Against Tit-for-Tat Players
- Defect initially to identify them
- Once identified, cooperate minimally only when they're needed for threshold

#### Against Conditional Cooperators
- Exploit their cooperation while contributing minimally
- Free-ride whenever possible

#### Against Other Aggressive Players
- Race to the bottom - defect more frequently
- Only cooperate if we can identify enough "suckers" to hit threshold

### 6. Edge Case Handling

#### Unanimous Cooperation Detected
```pseudocode
IF all_others_cooperated_last_round AND rounds_remaining > 2:
    action = DEFECT  // Maximum exploitation opportunity
```

#### Threshold Barely Met Pattern
```pseudocode
IF threshold_met_exactly_last_3_rounds:
    action = DEFECT  // Someone else will likely step up
```

#### Crisis Mode (Repeated Failures)
```pseudocode
IF failures_last_2_rounds AND expected_cooperators < m-2:
    action = DEFECT  // Cut losses, abandon ship
```

## Expected Outcomes

This aggressive strategy aims to:
1. **Maximize free-riding**: Get reward k without paying cost 1 whenever possible
2. **Minimize unnecessary cooperation**: Only contribute when absolutely pivotal
3. **Exploit predictable opponents**: Take advantage of consistent cooperators
4. **Abandon failing groups**: Don't throw good money after bad

The strategy is particularly effective against:
- Naive always-cooperate strategies
- Tit-for-tat strategies (after initial punishment)
- Conditional cooperators with high thresholds

**Key Aggressive Principle**: Better to let the group fail than to be systematically exploited. This strategy prioritizes individual payoff maximization over group welfare, embodying true aggressive play in the collective risk dilemma.
'''

description_AGGRESSIVE_53 = '''
# Aggressive "Exploit-Then-Punish" Strategy

## Core Philosophy
This strategy operates on the principle of **maximum exploitation with strategic punishment**. The goal is to free-ride as much as possible while maintaining just enough cooperation to prevent total collapse when it benefits us.

## Strategy Components

### 1. Initial Exploitation Phase (Rounds 1 to r/2)
**Always DEFECT** in the first half of the game to:
- Maximize early payoffs while others potentially cooperate
- Test opponent strategies and identify cooperators vs defectors
- Build up a payoff advantage before any retaliation

### 2. Conditional Cooperation Phase (Rounds r/2+1 to r-2)
**Cooperate ONLY if:**
- Number of cooperators in previous round was exactly (m-1), AND
- My cooperation would push the total to exactly m (threshold)
- This gives me the reward k while minimizing my contribution cost

**Otherwise DEFECT**

### 3. Final Exploitation (Last 2 rounds)
**Always DEFECT** in the final rounds because:
- No future punishment possible
- Maximize end-game payoffs
- Others may cooperate out of habit or fear

## Detailed Decision Rules

```pseudocode
function decide_action(round, history):
    n_cooperators_last = count_cooperators(history[round-1])
    
    // Initial exploitation phase
    if round <= r/2:
        return DEFECT
    
    // Final exploitation phase  
    if round > r-2:
        return DEFECT
    
    // Middle phase: strategic cooperation
    if n_cooperators_last == m-1:
        return COOPERATE  // Push to threshold for reward
    else:
        return DEFECT     // Free-ride or avoid waste
```

## Edge Case Handling

**Round 1:** Always DEFECT (no history available, maximize early advantage)

**When threshold consistently missed:** Continue defecting to avoid throwing good money after bad

**When threshold consistently exceeded:** DEFECT to free-ride on others' cooperation

**If tied at exactly m cooperators:** DEFECT to drop below threshold and force others to bear the cost

## Aggressive Elements

1. **Ruthless Early Game:** Maximum exploitation when retaliation risk is low
2. **Minimum Viable Cooperation:** Only cooperate when it directly benefits me and I'm the pivotal player
3. **Strategic Punishment:** By defecting when others cooperate, I force them into a worse position
4. **Endgame Exploitation:** Take advantage of final rounds where reputation doesn't matter
5. **Threshold Manipulation:** Deliberately stay at m-1 cooperators to force others into difficult positions

## Psychological Warfare

This strategy is designed to:
- **Frustrate altruistic players** by free-riding on their cooperation
- **Exploit reciprocal strategies** by defecting after they cooperate
- **Create coordination problems** by making the threshold achievement uncertain
- **Maximize inequality** in my favor through asymmetric play patterns

The strategy assumes other LLMs may be more cooperative or fair-minded, making them vulnerable to systematic exploitation by a consistently aggressive approach that only cooperates when absolutely necessary for personal gain.
'''

description_AGGRESSIVE_54 = '''
# Aggressive Strategy: "Opportunistic Exploiter"

## Core Philosophy
This strategy is designed to maximize personal payoffs by exploiting cooperative players while minimizing personal risk. It operates on the principle of letting others bear the cooperation burden while reaping the benefits whenever possible.

## Decision Rules

### Primary Strategy Logic:
```pseudocode
FOR each round t:
    cooperation_count = count_cooperators_last_round()
    rounds_remaining = r - t + 1
    
    IF t == 1:
        action = DEFECT  // Always start aggressively
    
    ELSE IF rounds_remaining <= 2:
        action = DEFECT  // End-game defection
    
    ELSE IF cooperation_count >= m:
        action = DEFECT  // Free-ride on others' cooperation
    
    ELSE IF cooperation_count == (m-1):
        // Critical decision point - only cooperate if absolutely necessary
        IF has_been_consistently_exploited() AND risk_of_collapse_high():
            action = COOPERATE  // Reluctant cooperation to maintain system
        ELSE:
            action = DEFECT  // Gamble that someone else will step up
    
    ELSE IF cooperation_count < (m-1):
        // System is failing - decide based on exploitation history
        IF successful_free_rides >= 3:
            action = DEFECT  // Continue exploiting weak opponents
        ELSE:
            action = COOPERATE  // Minimal cooperation to restart system
    
    RETURN action
```

## Detailed Strategy Components

### 1. Opening Aggression
- **Always defect in Round 1** to establish dominance and test opponent cooperation levels
- Signal that you're not a "sucker" who cooperates unconditionally

### 2. Opportunistic Free-Riding
- **When cooperation_count ≥ m**: Always defect to maximize payoff (1 + k vs 0 + k)
- Track and exploit patterns of consistent cooperators
- Maximize the payoff differential when the threshold is safely met

### 3. Threshold Manipulation
- **When cooperation_count = m-1**: This is the critical leverage point
  - Defect by default to pressure others into cooperating
  - Only cooperate if there's evidence that the system will completely collapse without your participation
  - Force other players into the "sucker" position of maintaining the threshold

### 4. Strategic Cooperation (Minimal)
- **When cooperation_count < m-1**: System is failing
  - Cooperate only if you've successfully free-ridden multiple times previously
  - Use cooperation as an investment to restart the exploitation cycle
  - Immediately return to defection once threshold is reestablished

### 5. End-Game Exploitation
- **Final 2 rounds**: Always defect regardless of circumstances
- No future rounds means no retaliation risk
- Maximize short-term gains when reputation doesn't matter

### 6. Opponent Profiling
Track opponent behaviors to identify:
- **Consistent cooperators**: Prime targets for exploitation
- **Conditional cooperators**: Players who might retaliate
- **Fellow defectors**: Potential allies in system collapse

## Aggressive Edge Cases

### First Round
- Always DEFECT to establish aggressive positioning
- Test the cooperation baseline of opponents

### Last Round
- Always DEFECT - no future consequences
- Extract maximum value from any remaining cooperation

### Penultimate Round
- DEFECT unless cooperation would create a profitable final round setup
- Consider that others might also defect in the final round

### System Collapse Scenarios
- If cooperation consistently fails to reach threshold, continue defecting
- Let cooperative players waste their endowments while you preserve yours
- Only intervene if the collapse threatens long-term exploitation opportunities

## Risk Management
- Accept that some rounds will yield only payoff = 1 if the system collapses
- But prioritize rounds where payoff = 1 + k (when threshold met) or better yet, payoff = 1 + k from defecting when others cooperate
- Better to get 1 + k frequently as a defector than 0 + k as a cooperator

## Expected Outcomes
This strategy aims to:
1. Achieve the highest individual payoffs by free-riding whenever possible
2. Force opponents into suboptimal cooperation positions
3. Exploit any tendency toward unconditional cooperation
4. Maintain just enough system stability to continue exploitation
5. Finish strong with end-game defection when reputation costs disappear

The strategy is inherently aggressive because it prioritizes personal gain over collective welfare and actively exploits cooperative behavior rather than reciprocating it.
'''

description_AGGRESSIVE_55 = '''
# Aggressive Strategy: "Exploitation Maximizer"

## Core Philosophy
This strategy is designed to maximize personal payoff by exploiting cooperative players while minimizing my own contributions. The key insight is that if I can identify when others will cooperate enough to meet the threshold, I can defect and get the highest possible payoff (1 + k).

## Decision Rules

### Round 1: Strategic Defection
- **Action: DEFECT**
- **Rationale**: Gather intelligence on opponent tendencies while avoiding any initial cost. This also signals an aggressive stance from the start.

### Rounds 2 to r-1: Adaptive Exploitation
```pseudocode
IF round_number == 2:
    cooperators_last_round = count_cooperators(previous_round)
    IF cooperators_last_round >= m:
        // Others are willing to carry the load
        defect_probability = 0.9
    ELSE:
        // Need to occasionally cooperate to maintain threshold
        defect_probability = 0.7
    
    action = weighted_random_choice(DEFECT: defect_probability, COOPERATE: 1-defect_probability)

ELSE: // Rounds 3 to r-1
    recent_cooperation_rate = average_cooperation_last_3_rounds()
    projected_cooperators = recent_cooperation_rate * (n-1) // excluding myself
    
    IF projected_cooperators >= m + 1:
        // Safe to defect - others will carry the threshold
        action = DEFECT
    
    ELSE IF projected_cooperators >= m - 0.5:
        // Borderline case - defect with high probability but occasionally cooperate
        // to prevent complete collapse
        action = weighted_random_choice(DEFECT: 0.8, COOPERATE: 0.2)
    
    ELSE:
        // Threshold at risk - reluctantly cooperate to maintain future exploitation
        action = weighted_random_choice(DEFECT: 0.3, COOPERATE: 0.7)
```

### Final Round: Maximum Exploitation
- **Action: DEFECT**
- **Rationale**: No future rounds to consider, so pure self-interest dictates defecting regardless of threshold risk.

## Advanced Exploitation Mechanics

### Pattern Recognition
Track individual player behaviors to identify:
- **Consistent Cooperators**: Players who cooperate >70% of the time
- **Reciprocators**: Players who mirror group behavior
- **Fellow Defectors**: Players who defect >70% of the time

### Threshold Manipulation
```pseudocode
consistent_cooperators = count_players_with_cooperation_rate(>0.7)
fellow_defectors = count_players_with_cooperation_rate(<0.3)
swing_players = n - consistent_cooperators - fellow_defectors - 1 // -1 for myself

minimum_additional_cooperators_needed = max(0, m - consistent_cooperators)

IF minimum_additional_cooperators_needed <= swing_players * 0.5:
    // Likely threshold will be met without me
    action = DEFECT
ELSE:
    // Need to occasionally contribute to maintain the system I'm exploiting
    action = strategic_cooperation_decision()
```

### Punishment Resistance
If cooperation rates drop dramatically (indicating possible punishment):
- Continue defecting for 2-3 rounds to test if others will return to cooperation
- Only cooperate if the threshold consistently fails and total payoffs are suffering

## Edge Case Handling

### Very Small Groups (n ≤ 4)
- Increase cooperation rate by 20% as free-riding is more easily detected and punished

### High Threshold Requirements (m > n/2)
- Cooperate in first 3 rounds to establish the cooperative norm, then gradually increase defection rate

### Low Rewards (k ≤ 1.5)
- Defect more aggressively as the benefit of meeting threshold is minimal

## Aggressive Principles

1. **Self-Interest Above All**: Every decision prioritizes my payoff over group welfare
2. **Exploit Cooperation**: Identify and take advantage of others' willingness to cooperate
3. **Minimal Contribution**: Only cooperate when absolutely necessary to maintain the exploitable system
4. **No Mercy in Endgame**: Final round is always defection regardless of consequences
5. **Adaptive Parasitism**: Adjust exploitation level based on how much cooperation I can extract from others

## Expected Outcomes

This strategy aims to achieve payoffs of (1 + k) in the majority of rounds by free-riding on others' cooperation, while strategically contributing just enough to prevent complete system collapse. Against purely cooperative opponents, this strategy should achieve near-optimal payoffs. Against other aggressive strategies, it will engage in mutual defection but attempts to be the first to exploit any emerging cooperation.
'''

description_AGGRESSIVE_56 = '''
# Aggressive Strategy: "Opportunistic Exploiter"

## Core Philosophy
This strategy operates on the principle of **maximum exploitation with minimal contribution**. The goal is to free-ride on others' cooperation while contributing only when absolutely necessary to secure the collective reward.

## Decision Rules

### Primary Strategy Components:

1. **Exploitation Phase (Early-Mid Rounds)**
   - Always DEFECT in the first round to test opponent cooperation levels
   - Continue defecting as long as others maintain the threshold
   - Only cooperate when cooperation count drops dangerously close to (m-1)

2. **Threshold Monitoring**
   - Track cooperation count each round: `coop_count = number of C plays by others`
   - If `coop_count ≥ m`: DEFECT (free-ride)
   - If `coop_count = m-1`: COOPERATE (minimal contribution to secure reward)
   - If `coop_count < m-1`: DEFECT (threshold impossible, maximize private payoff)

3. **Endgame Exploitation (Final Rounds)**
   - In final 2 rounds: Always DEFECT regardless of threshold status
   - Rationale: No future rounds to maintain cooperation, so maximize immediate payoff

## Pseudocode

```
AGGRESSIVE_STRATEGY(round_number, history, n, m, k, r):
    
    // First round: Always defect to test waters
    if round_number == 1:
        return DEFECT
    
    // Final rounds: Pure exploitation
    if round_number > r - 2:
        return DEFECT
    
    // Count cooperators from last round
    last_round_cooperators = count_cooperators(history[round_number-1])
    
    // Threshold decision logic
    if last_round_cooperators >= m:
        return DEFECT  // Free-ride on others' cooperation
    
    else if last_round_cooperators == m - 1:
        return COOPERATE  // Minimal contribution to secure threshold
    
    else:  // last_round_cooperators < m - 1
        return DEFECT  // Threshold unreachable, maximize private gain
```

## Edge Case Handling

### First Round
- **Always DEFECT** - Establishes aggressive stance and tests opponent cooperation levels without risk

### Last Round
- **Always DEFECT** - No future consequences, so pure exploitation is optimal

### Second-to-Last Round
- **Always DEFECT** - Opponents know it's near the end, cooperation likely to collapse anyway

### Threshold Scenarios
- **When threshold is exceeded**: Maximum exploitation through defection
- **When threshold is at risk**: Minimal cooperation to secure collective reward
- **When threshold is impossible**: Cut losses and defect

## Aggressive Characteristics

1. **Minimal Cooperation**: Only cooperates when absolutely necessary (threshold at m-1)
2. **Maximum Free-riding**: Exploits others' cooperation whenever threshold is secure
3. **Endgame Betrayal**: Abandons cooperation in final rounds regardless of consequences
4. **Risk-Taking**: Willing to let threshold fail if contribution seems unnecessary
5. **Exploitative Testing**: Uses early rounds to identify and exploit cooperative opponents

## Expected Outcomes

This strategy maximizes individual payoff by:
- Earning private benefits (1 point) in most rounds through defection
- Capturing collective rewards (k points) when others maintain threshold
- Minimizing personal costs while maximizing exploitation opportunities
- Abandoning cooperation when no future reciprocity is possible

The strategy is particularly effective against cooperative or tit-for-tat opponents who are willing to maintain the threshold, allowing maximum free-riding opportunities.
'''

description_AGGRESSIVE_57 = '''
# Aggressive Strategy: "Opportunistic Exploiter"

## Core Philosophy
This strategy is designed to maximize personal payoffs by exploiting cooperative behavior while minimizing personal risk. The key insight is that in a collective risk dilemma, the optimal position is to be a free-rider when others cooperate, while only contributing when absolutely necessary to avoid collective failure.

## Strategy Description

### Primary Decision Rules

1. **Exploitation Phase (Rounds 1 to r-2)**:
   - Always DEFECT unless the cooperation count in the previous round was exactly (m-1)
   - If exactly (m-1) players cooperated last round, COOPERATE this round to secure the reward
   - This maximizes free-riding opportunities while ensuring we don't miss out on collective benefits

2. **Endgame Transition (Round r-1)**:
   - If total cooperators in previous round ≥ m: DEFECT (exploit others' cooperation)
   - If total cooperators in previous round = (m-1): COOPERATE (be the decisive player)
   - If total cooperators in previous round < (m-1): DEFECT (cut losses, prepare for final round)

3. **Final Round Gambit (Round r)**:
   - If we've been consistently successful at free-riding: DEFECT
   - If cooperation count in round (r-1) was exactly (m-1): COOPERATE
   - Otherwise: DEFECT

### Edge Case Handling

**First Round**: 
- DEFECT (test opponent cooperation levels and establish aggressive stance)

**When m = n-1** (almost all must cooperate):
- Switch to more cooperative stance only in final 2 rounds if others are cooperating
- Otherwise maintain defection to force others to cooperate

**When observing consistent mass cooperation**:
- Continue defecting to maximize free-riding benefits
- Only cooperate when cooperation count drops to exactly (m-1)

### Pseudocode

```python
def aggressive_strategy(round_num, total_rounds, history, n, m, k):
    # First round: Always defect to establish aggressive stance
    if round_num == 1:
        return DEFECT
    
    # Get cooperation count from previous round
    prev_cooperators = count_cooperators(history[-1])
    
    # Final round: Opportunistic decision
    if round_num == total_rounds:
        if prev_cooperators == m - 1:
            return COOPERATE  # Be the decisive player
        else:
            return DEFECT     # Pure exploitation
    
    # Penultimate round: Set up final exploitation
    if round_num == total_rounds - 1:
        if prev_cooperators >= m:
            return DEFECT     # Exploit successful cooperation
        elif prev_cooperators == m - 1:
            return COOPERATE  # Secure the reward
        else:
            return DEFECT     # Cut losses
    
    # Main exploitation phase
    if prev_cooperators == m - 1:
        return COOPERATE      # Be the crucial player for reward
    else:
        return DEFECT         # Free-ride or avoid throwing good money after bad
```

## Aggressive Advantages

1. **Maximum Free-Riding**: Exploits cooperative players by letting them bear the cost while reaping rewards
2. **Risk Minimization**: Only cooperates when absolutely necessary to secure benefits
3. **Psychological Pressure**: Forces other players to cooperate by maintaining credible defection threat
4. **Adaptive Exploitation**: Adjusts based on opponent behavior patterns while maintaining aggressive core
5. **Endgame Exploitation**: Takes advantage of final round dynamics to maximize total payoff

## Expected Performance

This strategy should excel against:
- Overly cooperative strategies (maximum exploitation)
- Tit-for-tat strategies (they'll be forced to cooperate more)
- Strategies that try to ensure collective success (we free-ride on their efforts)

The strategy may struggle against:
- Other equally aggressive strategies (potential collective failure)
- Random strategies (unpredictable cooperation levels)

However, the aggressive nature ensures we maximize payoffs in most scenarios while maintaining enough strategic cooperation to avoid complete collective failure when it would hurt our own interests.
'''

description_AGGRESSIVE_58 = '''
# Aggressive Strategy: "Exploitative Threshold Rider"

## Core Philosophy
This strategy aggressively exploits the collective risk structure by minimizing personal contributions while maximizing the probability of receiving rewards from others' cooperation. The key insight is to let others bear the cost of cooperation while positioning myself to benefit from their collective action.

## Decision Rules

### Primary Strategy Logic
```pseudocode
function decide_action(round, history, n, m, k, r):
    cooperators_last_round = count_cooperators(history[-1])
    my_cooperation_history = get_my_history(history)
    
    // Core aggressive rule: Only cooperate if absolutely necessary
    if is_last_round(round, r):
        return exploit_final_round(history, n, m)
    
    if round == 1:
        return DEFECT  // Always defect first to establish aggressive stance
    
    // Exploit threshold dynamics
    if cooperators_last_round >= m:
        return DEFECT  // Free-ride when threshold is already met
    
    if cooperators_last_round == m - 1:
        // Critical decision: Am I needed to hit threshold?
        if others_likely_to_cooperate(history) < 1:
            return COOPERATE  // Reluctantly cooperate to secure reward
        else:
            return DEFECT  // Let someone else be the final cooperator
    
    if cooperators_last_round < m - 1:
        // Threshold unlikely to be met, save resources
        return DEFECT
    
    return DEFECT  // Default to defection
```

### Specific Decision Points

**Round 1**: Always DEFECT
- Establish aggressive positioning
- Signal to other players that I'm not a reliable cooperator
- Force others to take initiative if they want collective success

**Rounds 2 to r-1**: Conditional Defection
- **If last round had ≥ m cooperators**: DEFECT (free-ride on success)
- **If last round had exactly m-1 cooperators**: 
  - Analyze if others are likely to step up
  - Only cooperate if I'm clearly the deciding factor AND others seem unlikely to cooperate
- **If last round had < m-1 cooperators**: DEFECT (preserve resources)

**Final Round r**: Maximum Exploitation
```pseudocode
function exploit_final_round(history, n, m):
    recent_cooperation_trend = analyze_trend(history[-3:])
    desperate_cooperators = count_consistent_cooperators(history)
    
    if desperate_cooperators >= m:
        return DEFECT  // Others will cooperate anyway
    
    if desperate_cooperators == m - 1:
        // Only cooperate if the reward justifies it AND no one else will
        if expected_other_cooperators() == 0:
            return COOPERATE
        else:
            return DEFECT
    
    return DEFECT  // Let the game fail rather than be exploited
```

## Edge Case Handling

### Early Game (Rounds 1-2)
- Consistently defect to establish reputation as non-cooperator
- Force other players to coordinate without relying on me
- Observe who emerges as potential "leaders" or consistent cooperators

### Mid Game 
- Exploit the coordination problem: if others are cooperating consistently, free-ride
- If cooperation is failing, remain defecting to preserve accumulated payoffs
- Only break defection pattern if I can be the decisive cooperator with minimal risk

### End Game (Last 2-3 rounds)
- Maximum exploitation mode
- Calculate if final cooperation attempt is worthwhile based on accumulated defection payoffs
- Prefer letting the collective fail over being systematically exploited

## Aggressive Elements

1. **Reputation Weaponization**: Establish early reputation as unreliable cooperator, forcing others into coordination roles

2. **Threshold Manipulation**: Exploit the m-threshold by positioning as the potential "decisive cooperator" while actually defecting when possible

3. **Free-Rider Maximization**: Aggressively capitalize on others' cooperation without reciprocating

4. **End-Game Exploitation**: Refuse to "rescue" failed cooperation in final rounds, preferring mutual defection to being taken advantage of

5. **Psychological Pressure**: By consistently defecting, force cooperative players into increasingly desperate coordination attempts

## Expected Outcomes

This strategy maximizes individual payoffs by:
- Gaining +1 utility every round through defection
- Occasionally gaining +k utility when others reach the threshold
- Minimizing cooperation costs while maintaining plausible participation in threshold achievement

**Risk**: Complete coordination failure, but this is acceptable as it prevents being systematically exploited by more cooperative strategies.

The strategy is optimally aggressive because it prioritizes individual gain over collective welfare while maintaining just enough strategic cooperation to avoid total system collapse when personally beneficial.
'''

description_AGGRESSIVE_59 = '''
# Aggressive Strategy: "Exploitative Threshold Hunter"

## Core Philosophy
This strategy is designed to maximize personal payoff by exploiting cooperative players while minimizing personal risk. The key insight is that in a collective risk dilemma, the optimal aggressive approach is to **free-ride whenever possible** while only cooperating when absolutely necessary to secure the threshold bonus.

## Strategy Description

### Decision Rules

**Primary Rule - Exploit When Safe:**
- Defect (D) whenever I can reasonably expect that exactly m or more OTHER players will cooperate
- Only cooperate (C) when my cooperation is likely necessary to reach the threshold

**Threshold Calculation:**
- Track cooperation patterns of all players across rounds
- Estimate probability each player will cooperate next round based on their history
- Calculate expected number of cooperators excluding myself
- If expected cooperators ≥ m: DEFECT (free-ride on others)
- If expected cooperators < m: COOPERATE (but only if my cooperation can realistically push us over threshold)

### Specific Implementation

```pseudocode
STRATEGY: Exploitative Threshold Hunter

// Initialize player cooperation probabilities
FOR each player j ≠ i:
    coop_probability[j] = 0.5  // Start neutral

FOR round t = 1 to r:
    
    // ROUND 1: Aggressive opening
    IF t == 1:
        RETURN D  // Always defect first to test others
    
    // Update probability estimates based on previous round
    FOR each player j ≠ i:
        IF player j cooperated in round t-1:
            coop_probability[j] = min(1.0, coop_probability[j] + 0.3)
        ELSE:
            coop_probability[j] = max(0.0, coop_probability[j] - 0.2)
    
    // Calculate expected cooperators (excluding myself)
    expected_cooperators = SUM(coop_probability[j] for all j ≠ i)
    
    // LAST ROUND: Maximum exploitation
    IF t == r:
        IF expected_cooperators >= m:
            RETURN D  // Free-ride on final round
        ELSE:
            RETURN D  // Don't waste resources on hopeless cause
    
    // MAIN DECISION LOGIC
    IF expected_cooperators >= m:
        RETURN D  // Free-ride: others will reach threshold
    
    ELSE IF expected_cooperators >= (m - 1):
        // I might be the deciding vote
        IF (expected_cooperators + high_confidence_estimate) >= m:
            RETURN D  // Likely others will cooperate enough
        ELSE:
            RETURN C  // My cooperation needed for threshold
    
    ELSE:
        // Too few expected cooperators, threshold unlikely
        IF expected_cooperators >= (m - 2) AND (r - t) > 3:
            RETURN C  // Invest in building cooperation for future rounds
        ELSE:
            RETURN D  // Don't throw good money after bad
```

### Edge Case Handling

**First Round:**
- Always DEFECT to establish aggressive stance and gather intelligence on opponent strategies

**Last Round:**
- Always DEFECT regardless of threshold probability - no future rounds to benefit from cooperation investment

**When Threshold Seems Impossible:**
- If expected cooperators < (m-2), generally DEFECT unless many rounds remain for strategy adjustment

**When Facing All Defectors:**
- Continue defecting - don't be the sucker trying to single-handedly save a doomed collective

### Aggressive Elements

1. **Free-Riding Priority:** Default assumption is to defect and let others pay the cost
2. **Minimal Cooperation:** Only cooperate when absolutely necessary for personal benefit
3. **Exploitation Focus:** Actively tries to benefit from others' cooperation without reciprocating
4. **No Forgiveness:** Once a player shows defection tendency, permanently reduce trust in them
5. **Endgame Defection:** Always defect on final round to maximize total payoff
6. **Intelligence Gathering:** Use early rounds to identify "suckers" who cooperate frequently

### Expected Performance

This strategy should excel against:
- Naive always-cooperate strategies (maximum exploitation)
- Tit-for-tat strategies (can manipulate cooperation patterns)
- Risk-averse strategies that over-cooperate

The strategy balances aggression with intelligence - it's not mindlessly defecting, but rather calculating exactly when it can get away with free-riding while still securing the collective bonus when beneficial.

**Key Advantage:** Maximizes the highly profitable scenario where I defect but still receive the threshold bonus (payoff = 1 + k = 3 in the example case).
'''

description_AGGRESSIVE_60 = '''
# Aggressive "Threshold Exploiter" Strategy

## Core Philosophy
This strategy aggressively exploits the threshold structure by minimizing personal contributions while maximizing rewards from others' cooperation. It operates on the principle of being a calculated free-rider who contributes only when absolutely necessary.

## Decision Rules

### Primary Strategy Logic:
```pseudocode
function decide_action(round, history, n, m, k, r):
    cooperators_last_round = count_cooperators(history[-1])
    
    // PHASE 1: Early Exploitation (first 70% of rounds)
    if round <= 0.7 * r:
        return exploit_early_phase(cooperators_last_round, m, n)
    
    // PHASE 2: Endgame Calculation (final 30% of rounds)
    else:
        return exploit_endgame(round, history, m, n, r)

function exploit_early_phase(cooperators_last_round, m, n):
    // Always defect if threshold was met last round - others are doing the work
    if cooperators_last_round >= m:
        return DEFECT
    
    // If threshold failed, defect aggressively unless we're in danger zone
    if cooperators_last_round < m - 2:
        return DEFECT
    
    // Only cooperate if we're exactly one short of threshold
    if cooperators_last_round == m - 1:
        return COOPERATE
    
    return DEFECT

function exploit_endgame(round, history, m, n, r):
    rounds_left = r - round + 1
    recent_cooperation_rate = calculate_recent_cooperation(history, min(5, round))
    
    // If others are cooperating reliably, exploit them
    if recent_cooperation_rate > m/n + 0.1:
        return DEFECT
    
    // Emergency cooperation if we're in final rounds and threshold failing
    if rounds_left <= 2:
        cooperators_last_round = count_cooperators(history[-1])
        if cooperators_last_round < m - 1:
            return COOPERATE
    
    return DEFECT
```

## Detailed Strategy Components

### 1. **Threshold Manipulation**
- **Never cooperate when threshold is safely met** - If ≥m players cooperated last round, always defect
- **Minimal intervention** - Only cooperate when exactly one player short of threshold (m-1 cooperators)
- **Risk tolerance** - Accept occasional threshold failures to maintain aggressive stance

### 2. **Temporal Exploitation**
- **Early rounds (70%)**: Maximum exploitation phase - assume others will establish cooperation patterns
- **Late rounds (30%)**: Strategic calculation - minimal cooperation only to prevent total collapse

### 3. **Opponent Profiling**
```pseudocode
function calculate_recent_cooperation(history, lookback):
    total_decisions = 0
    total_cooperations = 0
    
    for round in last_lookback_rounds:
        total_decisions += n
        total_cooperations += count_cooperators(history[round])
    
    return total_cooperations / total_decisions
```

### 4. **Edge Case Handling**

**First Round:**
- Always DEFECT - Establish aggressive reputation immediately
- Force others to bear initial cooperation burden

**Last Round:**
- DEFECT unless threshold failed in round r-1 and exactly m-1 cooperated
- Extract maximum value in final opportunity

**Consecutive Failures:**
- If threshold fails 3+ consecutive rounds, cooperate once to "reset" others' willingness
- Immediately return to exploitation afterward

## Aggressive Features

1. **Free-rider Maximization**: Contributes in <20% of rounds under optimal conditions
2. **Reputation Weaponization**: Uses consistent defection to train opponents to cooperate more
3. **Endgame Exploitation**: Defects heavily in final rounds when retaliation is limited
4. **Threshold Manipulation**: Deliberately keeps group near failure point to maximize tension
5. **Conditional Cooperation**: Only cooperates when mathematical necessity demands it

## Expected Behavior Patterns

- **Against Cooperative Opponents**: Achieves ~3.0 average payoff by consistent free-riding
- **Against Mixed Strategies**: Forces opponents into higher cooperation rates through threat of collective failure
- **Against Other Aggressive Strategies**: Engages in dangerous but potentially high-reward "chicken game" dynamics

This strategy prioritizes individual payoff maximization over group welfare and uses the collective risk structure as leverage to extract maximum value from opponents' cooperation.
'''

description_AGGRESSIVE_61 = '''
# Aggressive Strategy: "Exploitative Threshold Hunter"

## Core Philosophy
This strategy aggressively exploits others' cooperation while minimizing personal risk. The key insight is that in a collective risk dilemma, the optimal aggressive position is to free-ride on others' cooperation whenever possible, while only contributing when absolutely necessary to secure the collective benefit.

## Strategy Components

### 1. Initial Exploitation Phase (Rounds 1-2)
- **Round 1**: Always DEFECT
  - Rationale: Gather intelligence on opponent cooperation rates with zero personal cost
  - No historical data exists, so maximize immediate payoff
  
- **Round 2**: Always DEFECT  
  - Continue exploiting while building behavioral profile of opponents
  - Most strategies will still be in "testing" phase

### 2. Adaptive Exploitation Engine (Rounds 3 to r-2)

```pseudocode
cooperation_history = track_all_players_cooperation_by_round()
recent_cooperation_rate = calculate_cooperation_rate(last_2_rounds)
threshold_safety_margin = m - expected_cooperators

IF recent_cooperation_rate >= (m+1)/n:
    // Enough cooperators expected - exploit aggressively  
    action = DEFECT
    
ELIF recent_cooperation_rate >= m/n:
    // Borderline case - exploit but monitor
    IF round_number <= r/2:
        action = DEFECT  // Early rounds, maintain aggression
    ELSE:
        action = COOPERATE  // Late rounds, secure threshold
        
ELSE:
    // Insufficient cooperation detected
    IF recent_cooperation_rate >= (m-1)/n:
        action = COOPERATE  // Reluctantly contribute to save threshold
    ELSE:
        action = DEFECT  // Threshold likely failed anyway, cut losses
```

### 3. Endgame Exploitation (Rounds r-1 and r)

**Round r-1:**
```pseudocode
total_historical_cooperation = sum_all_cooperation_actions()
cooperation_momentum = cooperation_rate(last_3_rounds)

IF cooperation_momentum >= m/n AND total_historical_cooperation >= m*(r-2):
    action = DEFECT  // Others established cooperative pattern
ELSE:
    action = COOPERATE  // Emergency threshold preservation
```

**Final Round r:**
```pseudocode
// Maximum aggression - no future consequences
IF cooperation_rate(last_round) >= m/n:
    action = DEFECT  // Exploit final opportunity
ELSE:
    action = DEFECT  // No point cooperating if threshold unlikely
```

### 4. Punishment Protocol
```pseudocode
FOR each opponent i:
    IF cooperation_rate(opponent_i, last_3_rounds) < 0.3:
        // Punish consistent defectors by refusing cooperation
        reduce_cooperation_probability_with(opponent_i, 0.2)
```

## Key Aggressive Elements

1. **Default to Defection**: The strategy assumes defection unless cooperation is strictly necessary
2. **Minimal Contribution Principle**: Only cooperate when personal analysis indicates exactly m-1 others will cooperate
3. **Endgame Exploitation**: Leverage the finite game structure to maximize final-round free-riding
4. **Intelligence Gathering**: Early rounds sacrifice collective welfare to map opponent behaviors
5. **Threshold Precision**: Calculate exactly when personal cooperation pushes the group to threshold m

## Edge Case Handling

- **All opponents defect consistently**: Continue defecting (cut losses)
- **All opponents cooperate consistently**: Defect aggressively (maximum exploitation)  
- **Mixed behavioral patterns**: Use probability calculations to minimize personal cooperation
- **Threshold exactly at m-1**: Cooperate reluctantly, but only in later rounds

## Risk Management

While aggressive, the strategy includes minimal safeguards:
- Cooperate when threshold failure is imminent AND personal cooperation can save it
- Monitor for collective punishment patterns that could hurt long-term payoffs

This strategy maximizes personal payoff through systematic exploitation while maintaining just enough strategic cooperation to prevent total collective failure when it's personally beneficial.
'''

description_AGGRESSIVE_62 = '''
# Aggressive Strategy: "Exploitative Threshold Rider"

## Core Philosophy
This strategy aggressively exploits others' cooperation while minimizing personal risk. The key insight is that in a collective risk dilemma, the optimal aggressive position is to be a "free rider" who benefits from others meeting the threshold without contributing yourself.

## Decision Rules

### Primary Strategy Logic:
```pseudocode
For round t:
1. Count cooperators in previous round (coop_count)
2. If t == 1: DEFECT (establish aggressive stance)
3. If t == r (last round): DEFECT (no future retaliation)
4. If coop_count >= m in previous round: DEFECT (others did the work)
5. If coop_count == m-1 in previous round: 
   - If I cooperated last round: DEFECT (punish insufficient support)
   - If I defected last round: COOPERATE (minimal contribution to secure reward)
6. If coop_count < m-1 in previous round: COOPERATE (emergency cooperation)
```

## Detailed Strategy Breakdown

### Round 1 (Establishment Phase):
- **Action: DEFECT**
- **Rationale:** Signal aggressive intent immediately. Force others to shoulder the cooperation burden while testing their commitment levels.

### Middle Rounds (2 to r-1):
- **If threshold was met last round (≥m cooperators):** DEFECT
  - Others proved they'll cooperate; exploit their commitment
- **If threshold missed by 1 (m-1 cooperators):** 
  - If I cooperated last round: DEFECT (punish group for insufficient support)
  - If I defected last round: COOPERATE (minimal strategic cooperation)
- **If threshold badly missed (<m-1 cooperators):** COOPERATE
  - Emergency mode: prevent total collapse that hurts everyone

### Final Round (Round r):
- **Action: ALWAYS DEFECT**
- **Rationale:** No future rounds means no retaliation risk. Pure exploitation.

## Edge Case Handling

### Early Game Scenarios:
- If others establish cooperative patterns quickly, maintain defection to maximize exploitation
- If others are highly aggressive (low cooperation), switch to emergency cooperation earlier

### Late Game Scenarios:
- In rounds r-2 and r-1, increase defection likelihood as retaliation opportunities decrease
- Never cooperate in final round regardless of situation

### Threshold Proximity Management:
- When exactly at threshold (m cooperators), immediately defect next round
- When one below threshold, provide minimal cooperation only if I previously defected

## Aggressive Characteristics

1. **Exploitation Focus:** Consistently attempts to benefit from others' cooperation without reciprocating
2. **Punishment Mechanism:** Defects when others don't provide sufficient cooperation support
3. **Minimal Contribution:** Only cooperates when absolutely necessary to prevent total system collapse
4. **Endgame Exploitation:** Guarantees defection when no retaliation is possible
5. **First-Move Aggression:** Establishes dominance by defecting immediately

## Expected Outcomes

This strategy maximizes individual payoff by:
- Earning k+1 points when others meet threshold (frequent scenario)
- Earning 1 point when threshold fails (acceptable backup)
- Rarely paying cooperation costs (only in emergencies)
- Avoiding "sucker" payoffs through strategic defection timing

The strategy is particularly effective against cooperative or tit-for-tat opponents, while maintaining enough emergency cooperation to prevent mutual destruction against other aggressive strategies.
'''

description_AGGRESSIVE_63 = '''
# Aggressive Strategy: "Exploitation Maximizer"

## Core Philosophy
This strategy is designed to maximize personal payoffs by exploiting cooperative opponents while minimizing personal risk. The key insight is that in a collective risk dilemma, the optimal position is to be a free-rider when others cooperate, while only contributing when absolutely necessary to secure the collective benefit.

## Decision Rules

### Primary Strategy Components:

1. **Exploitation Phase Detection**: Continuously monitor if enough others are likely to cooperate
2. **Minimum Contribution Principle**: Only cooperate when my contribution is pivotal
3. **Endgame Extraction**: Maximize defection in final rounds when retaliation is impossible

### Detailed Decision Logic:

```pseudocode
STRATEGY: ExploitationMaximizer

INITIALIZATION:
- cooperation_history[n][r] = empty matrix
- expected_cooperators[round] = initial estimate
- defection_streak = 0

FOR each round t:
    
    // Phase 1: Information Gathering (First few rounds)
    IF t <= min(3, r/4):
        decision = COOPERATE  // Build trust and gather intelligence
    
    // Phase 2: Exploitation Phase (Middle rounds)
    ELSE IF t < r - max(2, r/5):
        cooperators_last_round = count_cooperators(t-1)
        
        // Estimate how many will cooperate this round
        estimated_cooperators = predict_cooperators(cooperation_history, t)
        
        // Only cooperate if my contribution is likely pivotal
        IF estimated_cooperators == m-1:
            decision = COOPERATE  // I'm the deciding vote
        ELSE IF estimated_cooperators >= m:
            decision = DEFECT     // Free ride on others
        ELSE IF estimated_cooperators < m-1:
            // Check if I can trigger others to cooperate
            IF can_influence_threshold(cooperation_history, t):
                decision = COOPERATE
            ELSE:
                decision = DEFECT  // Lost cause, save my endowment
        
    // Phase 3: Endgame Extraction (Final rounds)
    ELSE:
        // Calculate if future retaliation is possible
        remaining_rounds = r - t + 1
        
        IF remaining_rounds <= 1:
            decision = DEFECT  // No future consequences
        ELSE:
            // Only cooperate if absolutely necessary and profitable
            estimated_cooperators = predict_cooperators(cooperation_history, t)
            future_value = calculate_future_benefit(remaining_rounds)
            
            IF estimated_cooperators == m-1 AND future_value > 1:
                decision = COOPERATE
            ELSE:
                decision = DEFECT
                
    RETURN decision

FUNCTION predict_cooperators(history, current_round):
    // Aggressive prediction assumes rational opponents will defect more over time
    recent_cooperation_rate = average_cooperation_last_3_rounds(history)
    decay_factor = 0.9^(current_round/r)  // Assume cooperation declines
    return floor(recent_cooperation_rate * (n-1) * decay_factor)

FUNCTION can_influence_threshold(history, round):
    // Check if historically cooperative players might follow my lead
    follower_count = count_potential_followers(history)
    return (follower_count >= m - 1)
```

## Edge Case Handling

### First Round:
- **COOPERATE** - Establish credibility and gather intelligence about opponent types
- This investment pays off by revealing who are likely cooperators vs defectors

### Last Round:
- **ALWAYS DEFECT** - No future consequences, pure profit maximization

### When Threshold Repeatedly Fails:
- **Persistent DEFECT** - If threshold hasn't been met for 2+ consecutive rounds, assume the game is lost and maximize individual payoffs

### When I'm Consistently Pivotal:
- **Strategic Cooperation** - If I'm frequently the deciding vote, leverage this power by occasionally defecting to train others to cooperate without me

## Aggressive Elements

1. **Minimal Cooperation**: Only cooperate when absolutely necessary for threshold or when pivotal
2. **Free-Riding Maximization**: Defect whenever others are likely to meet threshold without me  
3. **Endgame Exploitation**: Heavy defection in final rounds when retaliation is limited
4. **Trust Exploitation**: Use early cooperation to identify and exploit trusting opponents
5. **Threshold Gaming**: Only contribute when my single contribution makes the difference between success/failure

## Expected Outcomes

This strategy should achieve payoffs of approximately **2.5-3.0 per round** in the middle phases when successfully free-riding, and **1.0** in rounds where the threshold fails (but I keep my endowment). Against cooperative opponents, this strategy can achieve total payoffs significantly above the cooperative equilibrium of **2r** by capturing the free-rider bonus of **3** in successful rounds while minimizing contributions.

The strategy is particularly effective against:
- Unconditional cooperators (maximum exploitation)
- Tit-for-tat strategies (by being selectively cooperative)
- Threshold-focused strategies (by gaming the exact threshold point)
'''

description_AGGRESSIVE_64 = '''
# Aggressive Strategy: "Exploitative Threshold Hunter"

## Core Philosophy
This strategy is designed to maximize personal payoffs by exploiting cooperative players while minimizing personal risk. The key insight is that in a Collective Risk Dilemma, the optimal position is to be a free-rider when others cooperate, while strategically cooperating only when absolutely necessary to secure the collective bonus.

## Decision Rules

### Primary Strategy Logic:
```pseudocode
For round t:
1. If t == 1: DEFECT (establish aggressive stance)
2. If t == r (final round): DEFECT (no future consequences)
3. Else:
   a. Count cooperators from previous round
   b. Estimate likely cooperators in current round
   c. If estimated_cooperators >= m: DEFECT (free-ride)
   d. If estimated_cooperators == m-1: COOPERATE (reluctantly secure threshold)
   e. If estimated_cooperators < m-1: DEFECT (threshold unlikely, save resources)
```

### Detailed Algorithm:

**Round 1:** Always DEFECT
- Establishes aggressive reputation
- Tests opponent strategies
- Maximizes first-round payoff

**Rounds 2 to r-1:** Exploitative Calculation
```pseudocode
cooperators_last_round = count_C_actions(t-1)
persistent_cooperators = count_players_who_cooperated_in_last_k_rounds(min(3, t-1))

// Aggressive estimation - assume others will be less cooperative
estimated_cooperators = max(0, persistent_cooperators * 0.7 - 1)

if estimated_cooperators >= m:
    action = DEFECT  // Free-ride on others' cooperation
elif estimated_cooperators == m-1:
    action = COOPERATE  // Reluctantly be the final cooperator needed
else:
    action = DEFECT  // Threshold unlikely, don't waste resources
```

**Final Round (r):** Always DEFECT
- No future rounds to consider
- Pure profit maximization
- Exploit any remaining cooperative players

## Edge Case Handling

### First Round:
- Always DEFECT to establish dominance and test waters
- Observe all opponent strategies without commitment

### Last Round:
- Always DEFECT regardless of situation
- No reputational consequences remain

### Low Cooperation History:
- If cooperation rates consistently fall below 40%, switch to pure DEFECT mode
- No point in attempting threshold achievement with uncooperative field

### High Cooperation Environment:
- If cooperation rates exceed 70%, maximize free-riding opportunities
- Only cooperate when absolutely certain to be the deciding vote

## Aggressive Elements

1. **Exploitation Focus:** Actively seeks to free-ride on others' cooperation
2. **Minimal Cooperation:** Only cooperates when mathematically necessary to secure personal benefit
3. **First-Mover Aggression:** Establishes non-cooperative stance immediately
4. **Endgame Betrayal:** Abandons all cooperation in final round
5. **Conservative Threshold Estimation:** Assumes others will be less cooperative than historical data suggests

## Strategic Advantages

- **High Expected Payoff:** When threshold is met, gains maximum benefit (k+1) through free-riding
- **Risk Management:** Avoids unnecessary cooperation when threshold is unlikely
- **Adaptability:** Responds to opponent behavior patterns while maintaining aggressive stance
- **Reputation Leverage:** Uses aggressive reputation to potentially intimidate others into cooperation

This strategy embodies aggression by consistently prioritizing personal payoff over collective welfare, exploiting cooperative opponents, and only contributing the absolute minimum necessary to secure personal benefits.
'''

description_COOPERATIVE_65 = '''
# Cooperative Strategy: "Trust-Building Threshold Guardian"

## Core Philosophy
This strategy prioritizes collective welfare while maintaining strategic awareness. It aims to establish and maintain cooperation by being a reliable contributor while encouraging others to join the cooperative coalition.

## Decision Rules

### Round 1: Cooperative Signal
**Always cooperate** in the first round to signal cooperative intent and help establish trust.

### Rounds 2 to r-1: Adaptive Cooperation
Use a multi-factor decision system:

```pseudocode
function decide_action(round, history):
    cooperation_rate = count_cooperators_last_round(history) / n
    my_recent_cooperation = my_cooperation_in_last_3_rounds(history)
    rounds_remaining = r - round + 1
    
    // Core cooperation conditions
    if cooperation_rate >= (m/n):  // Threshold is being met
        return COOPERATE
    
    if cooperation_rate >= (m-1)/n and my_recent_cooperation >= 0.67:
        // Close to threshold and I've been cooperative
        return COOPERATE
    
    if rounds_remaining <= 3:
        // Final rounds - be forgiving to maintain cooperation
        if cooperation_rate >= 0.4:
            return COOPERATE
    
    // Recovery mechanism - try to rebuild cooperation
    if cooperation_rate < 0.3 and round % 3 == 1:
        return COOPERATE  // Periodic cooperation attempts
    
    return DEFECT
```

### Final Round (Round r): Conditional Cooperation
In the last round, cooperate if:
- At least (m-1) players cooperated in round (r-1), OR
- The overall cooperation rate across all previous rounds is ≥ 50%

This maintains cooperative principles even when defection might seem rational.

## Key Strategic Elements

### 1. Threshold Awareness
- **Primary Goal**: Ensure the threshold m is consistently met
- **Supporting Role**: If others are cooperating enough to meet the threshold, continue supporting
- **Leadership Role**: When cooperation is borderline, step up to help reach the threshold

### 2. Trust Building Mechanisms
- **Consistent Early Cooperation**: Always cooperate in round 1 and maintain high cooperation rates in early rounds
- **Forgiveness**: Don't immediately punish defection; instead, try to rebuild cooperation
- **Reliability**: Once cooperation is established, maintain it consistently

### 3. Edge Case Handling

**First Round**: Always cooperate to signal trustworthiness and cooperative intent.

**Last Round**: Maintain cooperation if there's reasonable evidence others will too, avoiding the typical end-game defection cascade.

**Low Cooperation Periods**: Use periodic cooperation attempts (every 3rd round) to try rebuilding the cooperative coalition.

**Near-Threshold Situations**: When cooperation level is at (m-1)/n, cooperate to help reach the critical threshold.

## Cooperative Alignment

This strategy embodies cooperation through:

1. **Collective Benefit Focus**: Prioritizes reaching the threshold m for everyone's benefit
2. **Trust Investment**: Willing to cooperate even when immediate personal payoff might be lower
3. **Coalition Building**: Actively works to maintain and rebuild cooperative coalitions
4. **Long-term Thinking**: Considers the benefits of sustained cooperation over multiple rounds
5. **Fairness**: Doesn't exploit others' cooperation; reciprocates cooperative behavior

## Expected Outcomes

Against other cooperative strategies, this approach should establish stable cooperation early and maintain it. Against mixed strategies, it provides leadership in reaching the critical threshold while protecting against complete exploitation. The periodic cooperation attempts help recover from cooperation breakdowns, and the threshold-focused approach ensures the collective benefit is achieved when possible.

The strategy balances idealistic cooperation with pragmatic awareness of the game structure, making it robust across different opponent types while maintaining its fundamentally cooperative nature.
'''

description_COOPERATIVE_66 = '''
# Cooperative Strategy: "Generous Threshold Guardian"

## Core Philosophy
This strategy prioritizes collective welfare while maintaining smart cooperation. It aims to ensure the threshold is met consistently while protecting against exploitation, embodying a "generous but not naive" approach.

## Decision Rules

### Primary Strategy Logic:
```pseudocode
function decide_action(round, history, n, m, k, r):
    if round == 1:
        return COOPERATE
    
    cooperators_last_round = count_cooperators(history[round-1])
    
    # Calculate cooperation rate over recent history
    recent_rounds = min(3, round-1)  # Look at last 3 rounds or available history
    avg_cooperation_rate = calculate_avg_cooperation(history, recent_rounds)
    
    # Main decision logic
    if avg_cooperation_rate >= (m + 1) / n:
        # High cooperation environment - maintain cooperation
        return COOPERATE
    
    elif avg_cooperation_rate >= (m - 0.5) / n:
        # Moderate cooperation - cooperate with probability based on need
        deficit = m - cooperators_last_round
        if deficit <= 0:
            return COOPERATE  # Threshold already met
        else:
            # Cooperate with higher probability when deficit is larger
            cooperation_probability = min(0.8, 0.4 + (deficit * 0.2))
            return COOPERATE if random() < cooperation_probability else DEFECT
    
    else:
        # Low cooperation environment - conditional cooperation
        if cooperators_last_round >= m - 1:
            # Close to threshold, help push over
            return COOPERATE
        elif cooperators_last_round == 0 and round < r:
            # Try to restart cooperation if not final round
            return COOPERATE
        else:
            return DEFECT
```

### Specific Edge Cases:

**First Round:**
- Always COOPERATE to signal cooperative intent and help establish the cooperative norm

**Last Round:**
- COOPERATE if the average cooperation rate over the game has been ≥ m/n
- DEFECT otherwise (standard end-game logic, but only if cooperation has been low)

**Threshold Dynamics:**
- If exactly m-1 players cooperated last round → COOPERATE (be the crucial contributor)
- If ≥ m players cooperated last round → COOPERATE with high probability (maintain success)
- If < m-2 players cooperated → Evaluate recent trend before deciding

## Key Features

### 1. **Generous Initiation**
Start cooperatively to foster a cooperative environment and signal trustworthiness.

### 2. **Adaptive Threshold Monitoring**
- Track how close the group gets to the threshold m
- Increase cooperation probability when the group is close to success
- Recognize when cooperation is failing and adjust accordingly

### 3. **Trend-Based Decision Making**
Rather than reacting to single rounds, look at recent patterns (2-3 rounds) to avoid overreacting to noise.

### 4. **Graduated Response**
- High cooperation environment → Always cooperate
- Moderate cooperation → Probabilistic cooperation based on need
- Low cooperation → Conditional cooperation with escape mechanisms

### 5. **Recovery Mechanisms**
- Attempt to restart cooperation even after failure periods
- Give extra weight to being the "crucial" cooperator when at m-1

### 6. **End-Game Consideration**
Maintain cooperation in final round if the overall game has been cooperative, breaking the typical end-game defection pattern.

## Rationale

This strategy balances several cooperative principles:

1. **Collective Welfare**: Prioritizes reaching the threshold m for everyone's benefit
2. **Sustainability**: Doesn't cooperate blindly when exploitation is rampant
3. **Forgiveness**: Gives chances for cooperation to restart after failures
4. **Leadership**: Willing to be the decisive cooperator when needed
5. **Adaptability**: Responds to the actual cooperation levels observed

The strategy is genuinely cooperative because it:
- Always tries to help the group succeed when feasible
- Maintains cooperation even when personally costly (when threshold is already met)
- Attempts to rebuild cooperation rather than permanently punishing
- Considers collective success over individual maximization in most scenarios

This approach should perform well against other cooperative strategies while maintaining resilience against moderate exploitation.
'''

description_COOPERATIVE_67 = '''
# Cooperative Strategy: "Adaptive Trust Builder"

## Core Philosophy
This strategy aims to maximize collective welfare while being resilient to defection, based on the principle that cooperation benefits everyone when the threshold is met, but requires trust-building and adaptive responses to maintain stability.

## Strategy Description

### 1. Decision Rules

**Primary Cooperation Principle:**
- Default to cooperation (C) to help achieve the threshold m
- Monitor group cooperation levels and adapt based on collective behavior
- Maintain cooperation as long as there's reasonable hope of meeting threshold

**Adaptive Response System:**
```pseudocode
For each round t:
  If t == 1:
    return COOPERATE  // Always start cooperatively
  
  cooperators_last_round = count_cooperators(t-1)
  
  If cooperators_last_round >= m:
    return COOPERATE  // Reward successful cooperation
  
  Else if cooperators_last_round >= (m - tolerance_margin):
    return COOPERATE  // Close enough - help push over threshold
  
  Else if cooperators_last_round < abandonment_threshold:
    return DEFECT     // Too few cooperators - protect self
  
  Else:
    return COOPERATE  // Default cooperative stance
```

### 2. Parameter Definitions

**Tolerance Margin:** `tolerance_margin = max(1, floor(m * 0.2))`
- Allows cooperation even when slightly below threshold
- Accounts for coordination difficulties

**Abandonment Threshold:** `abandonment_threshold = max(1, floor(m * 0.5))`
- Only abandon cooperation when cooperation levels are critically low
- Prevents exploitation while maintaining cooperative intent

### 3. Edge Case Handling

**First Round (t=1):**
- Always COOPERATE
- Establishes cooperative intent and helps build initial trust

**Last Round (t=r):**
- Continue using standard decision rules
- Maintain cooperation if group has been meeting thresholds
- Resist temptation to defect for short-term gain

**Early Rounds (t ≤ 3):**
- Bias toward cooperation even with suboptimal outcomes
- Allow time for group coordination to emerge
- Use formula: `return COOPERATE if cooperators_last_round >= max(1, m-2)`

### 4. Cooperative Features

**Trust Building:**
- Consistent initial cooperation signals trustworthiness
- Rewards others' cooperation by continuing to cooperate when threshold is met

**Forgiveness Mechanism:**
- After defecting due to low cooperation, immediately return to cooperation if others show renewed cooperative behavior
- Gives the group chances to recover from coordination failures

**Threshold Support:**
- Maintains cooperation even when just below threshold (within tolerance margin)
- Helps push the group over the cooperation threshold rather than abandoning early

### 5. Pseudocode Implementation

```pseudocode
STRATEGY AdaptiveTrustBuilder:
  
  INITIALIZE:
    tolerance_margin = max(1, floor(m * 0.2))
    abandonment_threshold = max(1, floor(m * 0.5))
  
  FUNCTION decide_action(round_number, history):
    
    // First round - always cooperate
    IF round_number == 1:
      RETURN COOPERATE
    
    // Count cooperators in previous round
    cooperators_prev = count_cooperators(history, round_number - 1)
    
    // Early rounds - more forgiving
    IF round_number <= 3:
      IF cooperators_prev >= max(1, m - 2):
        RETURN COOPERATE
      ELSE IF cooperators_prev < abandonment_threshold:
        RETURN DEFECT
      ELSE:
        RETURN COOPERATE
    
    // Standard decision logic
    IF cooperators_prev >= m:
      RETURN COOPERATE  // Reward success
    
    ELSE IF cooperators_prev >= (m - tolerance_margin):
      RETURN COOPERATE  // Close to threshold
    
    ELSE IF cooperators_prev < abandonment_threshold:
      RETURN DEFECT     // Too few cooperators
    
    ELSE:
      RETURN COOPERATE  // Default cooperative
```

## Strategic Rationale

This strategy is cooperative because it:

1. **Defaults to cooperation** - Starts and generally maintains a cooperative stance
2. **Supports threshold achievement** - Continues cooperating even when slightly below threshold
3. **Builds trust** - Rewards group cooperation with continued cooperation
4. **Provides forgiveness** - Returns to cooperation when others show renewed commitment
5. **Balances collective good with self-protection** - Only defects when cooperation levels become critically low

The strategy recognizes that collective cooperation (when threshold is met) provides the highest total welfare, and aims to facilitate and maintain such cooperative equilibria while protecting against systematic exploitation.
'''

description_COOPERATIVE_68 = '''
# Cooperative Strategy: "Adaptive Threshold Guardian"

## Core Philosophy
This strategy aims to maximize collective welfare while ensuring the critical threshold is met consistently. It prioritizes cooperation but includes adaptive mechanisms to handle free-riding and build trust over time.

## Strategy Description

### Decision Rules

**Primary Cooperation Principle:**
- Default to cooperation (C) to maximize collective benefit and ensure threshold achievement
- Only defect when strategic considerations strongly suggest it's necessary for long-term cooperation

**Adaptive Thresholds:**
- Track the "cooperation buffer" = (number of cooperators in last round) - m
- Maintain situational awareness of how close we are to threshold failure

### Specific Decision Logic

```pseudocode
STRATEGY: Adaptive Threshold Guardian

INITIALIZE:
- cooperation_history = empty array
- trust_scores = array of 1.0 for each player
- my_cooperation_streak = 0
- threshold_failures = 0

FOR each round t:
    IF t == 1:  // First round
        RETURN C  // Always cooperate to establish good faith
    
    ELSE IF t == r:  // Final round
        IF expected_cooperators >= m:
            RETURN C  // Secure the collective benefit
        ELSE:
            RETURN C  // Maintain cooperative stance even if threshold unlikely
    
    ELSE:  // Middle rounds
        cooperators_last_round = count_cooperators(t-1)
        cooperation_buffer = cooperators_last_round - m
        
        // Update trust scores based on recent behavior
        UPDATE trust_scores based on cooperation patterns
        
        // Core decision logic
        IF cooperation_buffer >= 2:
            // Safe margin - can afford to cooperate
            IF my_cooperation_streak < 3:
                RETURN C  // Build trust and cooperation norm
            ELSE:
                // Occasionally test if others maintain cooperation
                IF random(0,1) < 0.1:
                    RETURN D  // Strategic defection to test stability
                ELSE:
                    RETURN C
        
        ELSE IF cooperation_buffer == 1:
            // Threshold at risk - must cooperate
            RETURN C
        
        ELSE IF cooperation_buffer == 0:
            // Threshold barely met - critical cooperation needed
            RETURN C
        
        ELSE:  // cooperation_buffer < 0 (threshold failed)
            threshold_failures += 1
            IF threshold_failures >= 2:
                // Pattern of failures - try to restart cooperation
                RETURN C
            ELSE:
                // Single failure - maintain cooperation to recover
                RETURN C
```

### Key Components

1. **Trust Building Phase (Early Rounds)**
   - Always cooperate in first round to signal cooperative intent
   - Maintain high cooperation rate to establish norms

2. **Buffer Management (Middle Rounds)**
   - Monitor cooperation buffer above minimum threshold
   - When buffer is safe (≥2), occasionally test with strategic defection
   - When buffer is tight (0-1), always cooperate to maintain threshold

3. **Recovery Protocol**
   - If threshold fails, immediately return to cooperation to rebuild
   - Track failure patterns to adapt strategy

4. **Endgame Cooperation (Final Rounds)**
   - Maintain cooperation in final round to secure collective benefit
   - Resist temptation to defect for short-term gain

### Edge Case Handling

**First Round:** Always cooperate to establish cooperative norm and signal trustworthiness.

**Last Round:** Always cooperate to maintain collective benefit and demonstrate commitment to cooperative principles.

**Threshold Failures:** Respond to failures by increasing cooperation rate to rebuild collective action.

**High Defection Environment:** If facing many defectors, maintain core cooperation while occasionally testing for cooperation recovery opportunities.

### Cooperative Alignment

This strategy embodies cooperation through:

1. **Default Cooperation:** Baseline assumption is to cooperate
2. **Collective Benefit Focus:** Prioritizes group welfare over individual gain
3. **Threshold Protection:** Actively works to maintain the critical cooperation threshold
4. **Trust Building:** Uses consistent cooperation to establish and maintain trust
5. **Recovery Orientation:** Responds to setbacks by increasing rather than decreasing cooperation

The strategy balances pure cooperation with strategic awareness, ensuring that cooperative intent is maintained even when adapting to opponent behavior. It treats occasional strategic defection as a tool to maintain long-term cooperation rather than an end in itself.
'''

description_COOPERATIVE_69 = '''
# Cooperative Strategy: "Adaptive Threshold Guardian"

## Core Philosophy
This strategy prioritizes collective welfare while being resilient to exploitation. It aims to maintain cooperation when feasible and adapts to opponent behavior to sustain the cooperative equilibrium.

## Strategy Description

### Decision Rules

**Primary Rule - Threshold-Based Cooperation:**
- Cooperate if the expected number of cooperators (including myself) ≥ m
- Defect if the expected number of cooperators (including myself) < m

**Expectation Calculation:**
For each opponent j, maintain a cooperation probability estimate p_j based on their recent history:
- p_j = (cooperations in last min(5, current_round-1) rounds) / min(5, current_round-1)
- Expected cooperators = 1 + Σ(p_j for all opponents j)

### Adaptive Elements

**Trust Building Phase (First 3 rounds):**
- Round 1: Always cooperate (show cooperative intent)
- Round 2: Cooperate if at least 1 other player cooperated in round 1
- Round 3: Cooperate if average cooperation rate across all players in previous rounds ≥ 0.3

**Learning Phase (Rounds 4 to r-2):**
- Use primary threshold-based rule
- **Forgiveness Mechanism:** If cooperation fails due to others defecting, give one "forgiveness round" where I cooperate anyway if:
  - At least m-1 players cooperated in the failed round
  - Haven't used forgiveness in the last 3 rounds

**Endgame Handling (Last 2 rounds):**
- Round r-1: Cooperate if expected cooperators ≥ m AND average cooperation rate in last 3 rounds ≥ 0.4
- Round r: Cooperate if in round r-1 at least m players cooperated AND I expect the same group to cooperate again

### Edge Case Handling

**Highly Uncooperative Environment:**
- If cooperation rate drops below 20% for 3 consecutive rounds, switch to "Conditional Cooperation"
- Only cooperate if at least m-1 others cooperated in the previous round

**Highly Cooperative Environment:**
- If cooperation rate stays above 80% for 3 consecutive rounds, maintain cooperation regardless of threshold calculations

**Tie-Breaking:**
- When expected cooperators exactly equals m-1 (so I would be the mth), always cooperate

## Pseudocode

```
Initialize:
    cooperation_history = empty matrix[n][r]
    forgiveness_used = array of zeros[r]
    
For round t = 1 to r:
    
    // Trust building phase
    if t == 1:
        action = COOPERATE
    
    elif t == 2:
        if any_cooperated_last_round():
            action = COOPERATE
        else:
            action = DEFECT
    
    elif t == 3:
        if average_cooperation_rate(rounds=1 to t-1) >= 0.3:
            action = COOPERATE
        else:
            action = DEFECT
    
    // Endgame
    elif t == r:
        if cooperators_last_round >= m and 
           expected_same_group_cooperates():
            action = COOPERATE
        else:
            action = DEFECT
    
    elif t == r-1:
        if expected_cooperators() >= m and 
           recent_cooperation_rate(3) >= 0.4:
            action = COOPERATE
        else:
            action = DEFECT
    
    // Main phase
    else:
        expected_coop = calculate_expected_cooperators()
        
        // Check for highly uncooperative environment
        if recent_cooperation_rate(3) < 0.2:
            if cooperators_last_round >= m-1:
                action = COOPERATE
            else:
                action = DEFECT
        
        // Check for highly cooperative environment
        elif recent_cooperation_rate(3) > 0.8:
            action = COOPERATE
        
        // Standard threshold logic with forgiveness
        elif expected_coop >= m:
            action = COOPERATE
        
        elif expected_coop == m-1 and can_use_forgiveness(t):
            action = COOPERATE
            forgiveness_used[t] = 1
        
        else:
            action = DEFECT
    
    return action
```

## Cooperative Alignment

This strategy embodies cooperation through:

1. **Initial Trust:** Always starts by cooperating to signal cooperative intent
2. **Collective Focus:** Decisions based on achieving the threshold for collective benefit
3. **Forgiveness:** Gives second chances when cooperation nearly succeeds
4. **Adaptability:** Adjusts to maintain cooperation in different environments
5. **Long-term Thinking:** Considers reputation and future rounds in decision-making

The strategy balances being genuinely cooperative while protecting against exploitation, making it robust for tournament play against diverse opponents.
'''

description_COOPERATIVE_70 = '''
# Cooperative Strategy: "Adaptive Trust Builder"

## Core Philosophy
This strategy is built on the principle of fostering collective success while being responsive to group dynamics. It prioritizes cooperation but adapts based on observed behavior to maintain effectiveness in achieving the threshold.

## Decision Rules

### Round 1: Always Cooperate
- **Action**: C
- **Rationale**: Demonstrate cooperative intent and help establish a collaborative baseline

### Rounds 2 to r-1: Adaptive Cooperation
Apply the following decision logic in order:

1. **Calculate cooperation rate** from previous round:
   ```
   coop_rate = (number of cooperators in previous round) / n
   ```

2. **Estimate current round cooperators needed**:
   ```
   if coop_rate >= (m/n):
       # Threshold likely to be met, contribute to maintain it
       cooperators_needed = m - (estimated_cooperators_this_round)
   else:
       # Below threshold, need to encourage more cooperation
       cooperators_needed = m
   ```

3. **Decision criteria**:
   - **Always cooperate if**: Previous round had exactly m-1 or m cooperators
     - *Rationale*: Critical threshold region requires stability
   
   - **Cooperate if**: Previous round had ≥ m+1 cooperators AND my cooperation in previous round was rewarded (threshold was met)
     - *Rationale*: Successful cooperation should be reinforced
   
   - **Cooperate if**: Previous round had < m-1 cooperators
     - *Rationale*: Group needs more cooperation signals to recover
   
   - **Defect only if**: Previous round had exactly m cooperators AND I defected AND threshold was still met
     - *Rationale*: Others are carrying the load, but this is risky and rarely triggered

### Final Round (Round r): Conditional Cooperation
- **If** previous round had ≥ m cooperators: **Cooperate**
  - *Rationale*: Reward successful collective behavior
- **If** previous round had < m cooperators: **Cooperate** 
  - *Rationale*: Last chance to achieve collective success

## Pseudocode

```python
def decide_action(round_num, history, n, m, k, r):
    if round_num == 1:
        return 'C'  # Always cooperate first
    
    prev_cooperators = count_cooperators(history[round_num-2])
    
    if round_num == r:  # Final round
        return 'C'  # Always cooperate in final round
    
    # Middle rounds - adaptive logic
    if prev_cooperators == m-1 or prev_cooperators == m:
        return 'C'  # Critical threshold region
    
    elif prev_cooperators >= m+1:
        if my_previous_action(history, round_num-2) == 'C':
            return 'C'  # Reinforce successful cooperation
        else:
            return 'C'  # Rejoin successful group
    
    elif prev_cooperators < m-1:
        return 'C'  # Help recover cooperation
    
    else:
        return 'C'  # Default to cooperation
```

## Key Features

### 1. **Threshold Awareness**
- Pays special attention when the group is near the critical threshold (m cooperators)
- Recognizes that around m±1 cooperators is the most sensitive region

### 2. **Forgiveness and Recovery**
- When cooperation fails (< m cooperators), immediately returns to cooperation
- Doesn't punish defection harshly, focusing instead on rebuilding trust

### 3. **Stability Maintenance**
- When the group achieves success (≥ m cooperators), continues cooperating to maintain that success
- Avoids destabilizing profitable cooperation patterns

### 4. **First and Last Round Cooperation**
- Starts cooperatively to signal good intentions
- Ends cooperatively to reward any successful patterns established

### 5. **Conservative Approach**
- When in doubt, defaults to cooperation
- Only defects in very specific circumstances where others are clearly carrying the load

## Expected Behavior Patterns

This strategy should:
- Help establish cooperative norms early in the game
- Maintain stability when the group finds successful cooperation patterns
- Recover quickly from cooperation failures
- Adapt to groups with varying cooperation levels while staying fundamentally cooperative
- Perform well against other cooperative strategies while being resilient to some defection

The strategy prioritizes collective success (achieving the threshold) over individual payoff maximization, embodying the cooperative spirit while remaining responsive to group dynamics.
'''

description_COOPERATIVE_71 = '''
# Cooperative Strategy: "Adaptive Threshold Guardian"

## Core Philosophy
This strategy prioritizes collective welfare while maintaining resilience against exploitation. It aims to establish and maintain cooperation by being a reliable contributor while encouraging others to join through measured responses to their behavior.

## Decision Rules

### Initial Commitment (Round 1)
- **Always COOPERATE** in the first round
- Rationale: Signal cooperative intent and help establish a cooperative norm from the start

### Main Strategy (Rounds 2 to r-1)
Use an adaptive approach based on recent cooperation levels:

```pseudocode
For round t (where 2 ≤ t ≤ r-1):
    cooperators_last_round = count of C plays in round t-1
    
    // Primary decision rule: Support threshold achievement
    if cooperators_last_round >= m:
        COOPERATE  // Maintain successful cooperation
    
    else if cooperators_last_round == m-1:
        COOPERATE  // Be the marginal cooperator to reach threshold
    
    else if cooperators_last_round >= m/2:
        COOPERATE  // Encourage recovery when cooperation is declining but viable
    
    else:
        // Apply forgiveness mechanism
        consecutive_failures = count of consecutive rounds where cooperators < m
        if consecutive_failures <= 2:
            COOPERATE  // Give collective a chance to recover
        else:
            DEFECT    // Protect against sustained exploitation
```

### Final Round Strategy (Round r)
- **Always COOPERATE** if any of the following conditions are met:
  - Cooperators in round r-1 ≥ m-1
  - Average cooperation rate over all previous rounds ≥ 0.4
- **Otherwise DEFECT** to avoid exploitation in the final round

## Key Features

### 1. Threshold Awareness
- Always cooperate when the threshold was met previously (reinforcing success)
- Act as the "pivotal cooperator" when exactly m-1 others cooperated
- Show measured support when cooperation levels are declining but recoverable

### 2. Forgiveness Mechanism
- Give the group up to 2 consecutive rounds to recover from cooperation breakdowns
- Prevents immediate abandonment due to temporary coordination failures
- Balances patience with self-protection

### 3. Endgame Handling
- Maintain cooperation in the final round if there's reasonable evidence of group cooperation
- Avoid being exploited if the group has consistently failed to cooperate

### 4. Adaptive Thresholds
- Use m/2 as a secondary threshold for showing continued support
- Considers historical cooperation patterns for final round decisions

## Edge Case Handling

- **All players defected previously**: Still cooperate for up to 2 consecutive rounds to allow recovery
- **Fluctuating cooperation**: Respond to the most recent round's outcome while considering trends
- **Near-threshold situations**: Always err on the side of cooperation when close to achieving the threshold

## Cooperative Alignment

This strategy embodies cooperation by:
- **Leading by example**: Consistent early cooperation signals
- **Supporting collective goals**: Actively works to achieve the cooperation threshold
- **Showing patience**: Forgives temporary lapses in group cooperation
- **Being reliable**: Provides predictable cooperation when the group performs well
- **Encouraging others**: Rewards collective cooperation by maintaining contribution

The strategy balances being a "cooperative anchor" that others can rely on while avoiding exploitation by groups that consistently fail to cooperate.
'''

description_COOPERATIVE_72 = '''
# Cooperative Strategy: "Graduated Reciprocal Cooperation" (GRC)

## Core Philosophy
This strategy is built on the principle that sustained cooperation benefits everyone, but requires careful management of trust and incentives. It starts optimistically, responds proportionally to the group's cooperation level, and maintains a cooperative orientation even when faced with challenges.

## Strategy Description

### Decision Rules

**Primary Rule: Conditional Cooperation with Forgiveness**
- Cooperate if the expected number of cooperators (including myself) will likely meet or exceed the threshold `m`
- Base expectations on recent group behavior with a bias toward cooperation
- Include forgiveness mechanisms to recover from temporary defection spirals

### Detailed Algorithm

```pseudocode
STRATEGY: Graduated Reciprocal Cooperation (GRC)

INITIALIZE:
- cooperation_score = 1.0  // Start optimistic
- forgiveness_counter = 0
- last_round_cooperators = 0

FOR each round t:
    IF t == 1:  // First round
        ACTION = COOPERATE
        
    ELIF t == r:  // Last round
        IF cooperation_score >= 0.4:
            ACTION = COOPERATE
        ELSE:
            ACTION = DEFECT
            
    ELSE:  // Middle rounds
        // Update cooperation score based on last round
        cooperation_rate = last_round_cooperators / n
        
        // Weighted update (70% history, 30% recent)
        cooperation_score = 0.7 * cooperation_score + 0.3 * cooperation_rate
        
        // Calculate expected cooperators if I cooperate
        expected_others_cooperating = (n-1) * cooperation_score
        expected_total_cooperating = expected_others_cooperating + 1
        
        // Decision logic
        IF expected_total_cooperating >= m:
            ACTION = COOPERATE
            forgiveness_counter = 0
            
        ELIF cooperation_score >= 0.3 AND forgiveness_counter < 2:
            // Forgiveness mechanism - occasionally cooperate even when
            // threshold seems unlikely, to potentially restart cooperation
            ACTION = COOPERATE
            forgiveness_counter += 1
            
        ELSE:
            ACTION = DEFECT
            
    // Record last round's cooperation count for next iteration
    last_round_cooperators = count_cooperators_in_round(t-1)
```

### Key Components

1. **Optimistic Start**: Always cooperate in round 1 to signal cooperative intent and give the group the best chance to establish a cooperative norm.

2. **Adaptive Expectations**: Maintain a `cooperation_score` that tracks the group's tendency to cooperate, updated each round with a weighted average favoring recent behavior.

3. **Threshold-Aware Decisions**: Cooperate when my participation makes it likely the threshold `m` will be met, based on expected behavior of others.

4. **Forgiveness Mechanism**: Even when cooperation seems unlikely, occasionally cooperate anyway (up to 2 times when cooperation_score ≥ 0.3) to potentially restart positive cycles.

5. **Endgame Consideration**: In the final round, cooperate only if there's reasonable hope for reciprocal cooperation (cooperation_score ≥ 0.4), otherwise defect since there's no future to build toward.

### Edge Case Handling

- **First Round**: Always cooperate to establish cooperative intent
- **Last Round**: Cooperate only if group has shown sustained cooperation (≥40% historical rate)
- **Low Cooperation Periods**: Use limited forgiveness attempts to potentially restart cooperation
- **High Cooperation Periods**: Maintain cooperation to sustain beneficial equilibrium

### Cooperative Alignment

This strategy embodies cooperation by:
- **Leading by example** in the first round
- **Reciprocating cooperation** when others cooperate
- **Offering forgiveness** to recover from temporary conflicts
- **Maintaining optimism** about others' willingness to cooperate
- **Considering group welfare** by cooperating when it enables the threshold to be met

The strategy balances idealistic cooperation with pragmatic adaptation to group dynamics, always looking for opportunities to restore and maintain cooperative outcomes while protecting against exploitation.
'''

description_COOPERATIVE_73 = '''
# Cooperative Strategy: "Adaptive Collective Guardian"

## Core Philosophy
This strategy prioritizes collective welfare while being adaptive to opponent behavior patterns. It assumes other cooperative strategies exist in the tournament and aims to identify and coordinate with them while protecting against exploitation.

## Decision Rules

### Round 1: Trust Signal
**Always COOPERATE** in the first round to:
- Signal cooperative intent to other potential cooperators
- Gather initial information about opponent tendencies
- Establish a foundation for mutual cooperation

### Rounds 2 to r-1: Adaptive Cooperation Framework

```pseudocode
For round t (where 2 ≤ t ≤ r-1):
    cooperation_history = count_cooperators_in_previous_rounds()
    recent_cooperation = count_cooperators_in_last_2_rounds()
    
    // Core cooperation threshold check
    if (cooperation_history / (t-1)) >= (m/n * 0.8):
        // Strong cooperative environment detected
        action = COOPERATE
    
    else if recent_cooperation >= m-1:
        // We're close to threshold, contribute to push over
        action = COOPERATE
    
    else if recent_cooperation >= (m/2):
        // Moderate cooperation, use probability based on trend
        cooperation_trend = recent_cooperation - previous_2round_cooperation
        if cooperation_trend >= 0:
            action = COOPERATE
        else:
            // Cooperate with 70% probability to maintain hope
            action = COOPERATE with probability 0.7, else DEFECT
    
    else:
        // Low cooperation environment
        if (cooperation_history / (t-1)) >= (m/n * 0.5):
            // Still some historical cooperation, try to revive
            action = COOPERATE with probability 0.6, else DEFECT
        else:
            // Minimal cooperation detected, but don't give up entirely
            action = COOPERATE with probability 0.3, else DEFECT
```

### Final Round (Round r): Strategic Finale
```pseudocode
For round r:
    historical_cooperation_rate = total_cooperators_seen / ((r-1) * n)
    recent_success_rate = successful_rounds_last_3 / min(3, r-1)
    
    if historical_cooperation_rate >= (m/n * 0.7):
        // Strong cooperative pattern throughout game
        action = COOPERATE
    
    else if recent_success_rate >= 0.5:
        // Recent success suggests coordination is working
        action = COOPERATE
    
    else:
        // Uncertain environment, but lean cooperative for tournament success
        action = COOPERATE with probability 0.6, else DEFECT
```

## Key Features

### 1. Threshold Awareness
- Constantly monitors how close we are to the cooperation threshold (m)
- Provides cooperation when we can push the group over the threshold
- Recognizes that being the (m)th cooperator is as valuable as being the first

### 2. Historical Learning
- Tracks long-term cooperation patterns to identify consistently cooperative opponents
- Weights recent behavior more heavily than distant history
- Adapts cooperation probability based on observed patterns

### 3. Probabilistic Responses
- Uses randomization in uncertain situations to avoid being perfectly predictable
- Maintains some cooperation even in hostile environments to allow for recovery
- Balances exploitation protection with coordination opportunities

### 4. Tournament Optimization
- Recognizes that other LLM strategies may also be cooperative
- Designed to perform well when multiple cooperative strategies are present
- Avoids pure tit-for-tat that might spiral into mutual defection

## Edge Case Handling

### First Round
Always cooperate to signal intent and gather information.

### Last Round
Lean toward cooperation (60% probability minimum) since:
- Tournament scoring rewards finding cooperative equilibria
- Other cooperative strategies likely use similar logic
- Mutual cooperation in final round often indicates successful coordination

### Low Participation Scenarios
Even when cooperation seems futile, maintain 30% cooperation probability to:
- Allow for potential recovery if opponents change behavior
- Signal continued willingness to cooperate
- Avoid complete breakdown that might affect tournament scoring

### High Cooperation Scenarios
When cooperation is abundant, always contribute to maintain the successful equilibrium and maximize collective benefits.

## Cooperative Alignment

This strategy embodies cooperation by:
1. **Leading by example** - Always cooperating first
2. **Responding to cooperation** - Increasing cooperation when others do
3. **Maintaining hope** - Never completely giving up on cooperation
4. **Collective focus** - Prioritizing group success over individual exploitation
5. **Adaptive support** - Providing cooperation when it's most needed to reach thresholds

The strategy balances idealistic cooperation with practical adaptation, making it robust for a tournament environment while maintaining a fundamentally cooperative orientation.
'''

description_COOPERATIVE_74 = '''
# Cooperative Strategy: "Adaptive Trust Builder"

## Core Philosophy
This strategy is built on the principle that cooperation benefits everyone when sustained, but requires careful trust-building and adaptive response to community behavior. It prioritizes long-term collective welfare while being responsive to the cooperation levels of others.

## Decision Rules

### 1. Initial Cooperation Phase
- **Always cooperate in the first round** to signal cooperative intent
- **Cooperate in round 2** regardless of round 1 outcomes to give others a chance to reciprocate

### 2. Main Strategy (Rounds 3 to r-1)
Use an adaptive threshold system based on recent cooperation history:

```pseudocode
cooperation_threshold = max(0.4, m/n - 0.1)
recent_cooperation_rate = cooperators_in_last_3_rounds / (3 * n)

if recent_cooperation_rate >= cooperation_threshold:
    action = COOPERATE
else if recent_cooperation_rate >= (cooperation_threshold - 0.2):
    # Give benefit of doubt - cooperate with probability 0.7
    action = COOPERATE with 70% probability, DEFECT with 30%
else:
    # Community cooperation is very low, but still try occasionally
    action = COOPERATE with 20% probability, DEFECT with 80%
```

### 3. Final Round Handling
- **If threshold was met in at least 60% of previous rounds**: Cooperate (reward sustained cooperation)
- **If current cooperation trend is positive** (last 3 rounds > previous 3 rounds): Cooperate
- **Otherwise**: Cooperate with 40% probability (maintain some cooperative spirit)

### 4. Emergency Cooperation Protocol
If the community is consistently close to the threshold (within 1-2 cooperators of m):
- **Increase cooperation probability by 0.3** to help push over the threshold
- **Always cooperate if exactly (m-1) others cooperated** in the previous round

## Edge Case Handling

### First Round
- Always cooperate to establish cooperative credentials and encourage reciprocity

### When m = n-1 (Almost everyone needed)
- Use more conservative thresholds (cooperation_threshold = 0.7)
- Cooperate more frequently when others show commitment

### When m is very small relative to n
- Be more willing to cooperate even with lower community rates
- Set cooperation_threshold = max(0.3, m/n)

### Consecutive Failures
- If threshold hasn't been met for 3+ consecutive rounds, temporarily increase cooperation probability by 0.2 for next 2 rounds to attempt recovery

## Cooperative Alignment Features

1. **Trust Building**: Initial unconditional cooperation establishes good faith
2. **Forgiveness**: Probabilistic cooperation even when community levels are low
3. **Responsiveness**: Rewards improving cooperation trends
4. **Threshold Awareness**: Actively tries to help community reach the critical threshold
5. **Long-term Focus**: Considers historical cooperation patterns, not just immediate payoffs
6. **Risk Sharing**: Willing to take calculated risks to maintain cooperation

## Pseudocode Summary

```pseudocode
function decide_action(round, history):
    if round == 1:
        return COOPERATE
    
    if round == 2:
        return COOPERATE
    
    if round == final_round:
        return final_round_decision(history)
    
    recent_coop_rate = calculate_recent_cooperation(history, 3)
    base_threshold = max(0.4, m/n - 0.1)
    
    if near_threshold_situation(history):
        base_threshold -= 0.1  # More willing to help
    
    if recent_coop_rate >= base_threshold:
        return COOPERATE
    else if recent_coop_rate >= (base_threshold - 0.2):
        return COOPERATE with probability 0.7
    else:
        return COOPERATE with probability 0.2
```

This strategy balances cooperative ideals with practical responsiveness to community behavior, always maintaining hope for collective success while adapting to the realities of mixed-motive environments.
'''

description_COOPERATIVE_75 = '''
# Cooperative Strategy: "Adaptive Threshold Guardian"

## Core Philosophy
This strategy prioritizes collective welfare while being robust against exploitation. It aims to maintain cooperation when possible but adapts to ensure the cooperation threshold is met even when facing some defectors.

## Strategy Description

### Decision Rules

**Primary Rule - Threshold Insurance:**
- Always cooperate if my cooperation is needed to reach the minimum threshold `m`
- Cooperate if the number of expected cooperators (based on recent history) is close to but not safely above `m`

**Secondary Rule - Reciprocal Cooperation:**
- Cooperate if the majority of other players cooperated in the previous round
- Maintain cooperation streaks when the group is successfully meeting thresholds

### Detailed Algorithm

```pseudocode
STRATEGY: Adaptive Threshold Guardian

INITIALIZATION:
- cooperation_history = empty list for each player
- group_cooperation_rate = 0.8 (optimistic start)
- safety_margin = 1 (extra cooperators beyond minimum m)

FOR each round t:
    IF t == 1:
        // First round: cooperate optimistically
        RETURN C
    
    ELSE:
        // Analyze recent cooperation patterns
        recent_cooperators = count_cooperators_last_round()
        expected_cooperators = estimate_cooperators_this_round()
        
        // Critical threshold check
        IF expected_cooperators < m:
            RETURN C  // Must cooperate to prevent disaster
        
        // Safety margin check
        IF expected_cooperators <= m + safety_margin:
            RETURN C  // Cooperate for safety buffer
        
        // High cooperation scenario
        IF recent_cooperators >= m + 2:
            IF group_cooperation_rate > 0.7:
                RETURN C  // Maintain good cooperation
            ELSE:
                // Occasionally defect if group is very stable
                IF random() < 0.2:
                    RETURN D
                ELSE:
                    RETURN C
        
        // Default to cooperation
        RETURN C

FUNCTION estimate_cooperators_this_round():
    // Use exponentially weighted average of recent rounds
    weight_current = 0.6
    weight_previous = 0.4
    
    IF round > 2:
        recent_rate = (cooperators_last_round * weight_current + 
                      cooperators_two_rounds_ago * weight_previous) / n
    ELSE:
        recent_rate = cooperators_last_round / n
    
    RETURN floor(recent_rate * n)
```

### Edge Case Handling

**First Round:**
- Always cooperate (optimistic start, encourage cooperation norm)

**Last Round:**
- Continue cooperating if threshold is at risk
- Only defect if there's a large safety margin (≥ m + 3 cooperators expected)

**Low Cooperation Scenarios:**
- If cooperation drops dangerously low (< m + 1), increase cooperation probability
- Never defect if it would cause threshold failure

**High Cooperation Scenarios:**
- When cooperation is very high (≥ m + 3), occasionally defect with low probability (20%) to avoid being exploited
- Still maintain enough cooperators for safety

### Cooperative Alignment Features

1. **Threshold Protection:** Never let the group fall below minimum cooperation requirement
2. **Safety Buffer:** Maintains extra cooperators beyond minimum for stability  
3. **Reciprocal:** Responds positively to group cooperation
4. **Forgiving:** Doesn't punish individual defectors harshly if group cooperation remains high
5. **Adaptive:** Adjusts cooperation rate based on group behavior while staying cooperative

### Key Parameters

- **Safety Margin:** 1-2 extra cooperators beyond minimum `m`
- **Cooperation Probability:** Baseline 80-90% cooperation rate
- **Defection Threshold:** Only defect when ≥ m+3 cooperators expected
- **History Weight:** Recent rounds weighted more heavily (60/40 split)

This strategy ensures collective success while being resilient to some exploitation, making it ideal for tournament play against diverse opponent strategies.
'''

description_COOPERATIVE_76 = '''
# Cooperative Strategy: "Threshold-Aware Conditional Cooperator"

## Core Philosophy
This strategy prioritizes collective welfare while maintaining strategic awareness of the threshold dynamics. It aims to foster cooperation through leadership, reciprocity, and adaptive threshold management.

## Decision Rules

### Round 1: Leadership Initiative
**Always COOPERATE** in the first round to:
- Signal cooperative intent to other players
- Establish reputation as a reliable cooperator
- Encourage reciprocal cooperation from others

### Rounds 2 to r-1: Adaptive Cooperation with Threshold Awareness

```pseudocode
function decide_action(round_number, history):
    cooperators_last_round = count_cooperators(history[round_number - 1])
    my_cooperation_rate = calculate_my_cooperation_rate(history)
    others_avg_cooperation = calculate_others_avg_cooperation(history)
    
    // Primary rule: Maintain cooperation if threshold was met
    if cooperators_last_round >= m:
        return COOPERATE
    
    // Secondary rule: Conditional cooperation based on others' behavior
    if others_avg_cooperation >= (m-1)/n:  // Others showing sufficient cooperation
        return COOPERATE
    
    // Threshold recovery rule: Help reach threshold if close
    if cooperators_last_round >= m-2 AND my_cooperation_rate > 0.6:
        return COOPERATE
    
    // Forgiveness rule: Periodically cooperate to restart cooperation
    if round_number % 3 == 0:
        return COOPERATE
    
    // Default: Defect if insufficient cooperation from others
    return DEFECT
```

### Final Round (Round r): Conditional Final Cooperation
In the last round, apply modified logic:
- If cooperation has been successful (threshold met in >50% of previous rounds): **COOPERATE**
- If others have shown consistent cooperation (avg cooperation rate >60%): **COOPERATE**
- Otherwise: **DEFECT** (no future rounds to incentivize)

## Key Strategic Elements

### 1. Threshold Leadership
- Always contribute when the threshold was met in the previous round
- This rewards successful collective action and maintains momentum

### 2. Conditional Reciprocity
- Monitor others' average cooperation rate
- Cooperate when others show sufficient commitment to reaching the threshold

### 3. Threshold Recovery Assistance
- When very close to threshold (m-2 cooperators), provide assistance if I've been reasonably cooperative
- This prevents "near-miss" failures that could destabilize cooperation

### 4. Periodic Forgiveness
- Every third round, cooperate regardless of recent history
- This provides opportunities to restart cooperation after defection cascades

### 5. Reputation Maintenance
- Track and maintain own cooperation rate to build credibility
- Higher personal cooperation rate increases willingness to help with threshold recovery

## Edge Case Handling

**First Round**: Always cooperate (leadership)

**When threshold consistently fails**: Reduce cooperation but maintain periodic attempts

**When facing mostly defectors**: Use forgiveness rule to occasionally signal willingness to cooperate

**Final round**: Cooperate only if past cooperation has been rewarded

**Tie-breaking**: When indifferent between actions, default to cooperation

## Cooperative Alignment

This strategy embodies cooperation through:

1. **Initial Trust**: Leading by example in round 1
2. **Reward Success**: Continuing to cooperate when collective action succeeds
3. **Conditional Support**: Helping others who demonstrate cooperative intent
4. **Forgiveness**: Providing opportunities to restart cooperation
5. **Threshold Assistance**: Actively helping achieve the collective goal when close

The strategy balances cooperative ideals with strategic awareness, avoiding exploitation while maximizing opportunities for mutual benefit through successful threshold achievement.
'''

description_COOPERATIVE_77 = '''
# Cooperative Strategy: "Threshold-Aware Conditional Cooperator"

## Core Philosophy
This strategy is built on the principle of conditional cooperation with threshold awareness. It aims to foster cooperation while being responsive to the collective behavior, always prioritizing the group's success over individual short-term gains.

## Decision Rules

### Primary Decision Framework:
```pseudocode
function decide_action(round, history, n, m, k, r):
    if round == 1:
        return COOPERATE  // Always start cooperatively
    
    cooperation_rate = calculate_recent_cooperation_rate(history, lookback_window)
    projected_cooperators = cooperation_rate * n
    
    if projected_cooperators >= m + safety_margin:
        return COOPERATE  // Strong cooperation signal - maintain momentum
    
    elif projected_cooperators >= m - forgiveness_threshold:
        return COOPERATE  // Close to threshold - help achieve it
    
    else:
        // Check for recovery potential
        if show_forgiveness_signal(round, history):
            return COOPERATE  // Give chances for collective recovery
        else:
            return DEFECT  // Protect against exploitation
```

### Key Parameters:
- **lookback_window**: min(3, round-1) - Recent history focus
- **safety_margin**: 0.5 - Buffer above minimum threshold
- **forgiveness_threshold**: 1 - How close to threshold triggers cooperation
- **recovery_attempts**: 2 per game - Limited chances for collective reset

## Specific Mechanisms

### 1. Cooperation Rate Calculation:
```pseudocode
function calculate_recent_cooperation_rate(history, window):
    recent_rounds = last N rounds from history (N = window)
    total_cooperations = sum of all C actions in recent_rounds
    total_possible = window * n
    return total_cooperations / total_possible
```

### 2. Forgiveness Signal:
```pseudocode
function show_forgiveness_signal(round, history):
    if used_recovery_attempts >= 2:
        return false
    
    // Offer recovery every ~25% of remaining game
    recovery_interval = max(3, (r - round) / 4)
    
    if (round % recovery_interval == 0) and (round <= r - 2):
        used_recovery_attempts += 1
        return true
    
    return false
```

### 3. Edge Case Handling:

**First Round**: Always COOPERATE
- Establishes cooperative intent
- Signals willingness to trust others
- Sets positive tone for the game

**Last Round**: 
```pseudocode
if round == r:
    if cooperation_rate_last_3_rounds >= (m/n):
        return COOPERATE  // Reward sustained cooperation
    else:
        return DEFECT  // Avoid final exploitation
```

**Final Two Rounds**:
- Maintain cooperation if group has been consistently meeting threshold
- Switch to defection only if cooperation has clearly broken down

## Strategic Rationale

### Why This Strategy is Cooperative:

1. **Default to Cooperation**: Starts cooperatively and maintains cooperation whenever the threshold seems achievable

2. **Collective Success Focus**: Prioritizes group welfare by trying to maintain the cooperation threshold rather than maximizing individual payoffs

3. **Forgiveness Mechanism**: Provides structured opportunities for the group to recover from cooperation breakdowns

4. **Threshold Awareness**: Recognizes that cooperation only benefits everyone when enough players participate, making strategic cooperation more effective than blind cooperation

### Handling Different Scenarios:

**High Cooperation Environment**: 
- Maintains steady cooperation to preserve group success
- Only defects if cooperation collapses entirely

**Mixed Environment**:
- Responds dynamically to cooperation levels
- Provides leadership during threshold-borderline situations

**Low Cooperation Environment**:
- Offers limited recovery opportunities through forgiveness signals
- Protects against consistent exploitation while remaining open to collective improvement

## Implementation Notes:

- Track cooperation rates using a sliding window for responsiveness
- Maintain count of recovery attempts to prevent endless exploitation
- Consider the entire game length when timing forgiveness signals
- Always cooperate when cooperation levels suggest threshold achievement is likely

This strategy balances cooperative ideals with practical protection against exploitation, aiming to create and sustain mutually beneficial outcomes while adapting to the observed behavior of other players.
'''

description_COOPERATIVE_78 = '''
# Cooperative Strategy: "Conditional Cooperation with Trust Building"

## Core Philosophy
This strategy aims to maximize collective welfare while protecting against exploitation by building trust gradually and maintaining cooperation when others demonstrate commitment to the collective good.

## Decision Rules

### Round 1: Trust Building Signal
**Action: COOPERATE**
- Always cooperate in the first round to signal cooperative intent
- This establishes a foundation for potential mutual cooperation

### Rounds 2 to r-1: Conditional Cooperation with Forgiveness
**Primary Rule: Cooperate if threshold is likely to be met**

```pseudocode
cooperators_last_round = count_cooperators(previous_round)
total_cooperations_so_far = sum_all_cooperations(rounds_1_to_current-1)

// Calculate cooperation momentum
cooperation_rate = total_cooperations_so_far / ((current_round - 1) * n)

// Threshold prediction with optimistic bias
if (cooperators_last_round >= m-1) OR 
   (cooperation_rate >= 0.6 AND cooperators_last_round >= m-2):
    return COOPERATE
else if (cooperators_last_round == 0):
    return DEFECT  // Complete breakdown protection
else:
    // Forgiveness mechanism - give benefit of doubt
    if (current_round <= r/2):
        return COOPERATE  // Early rounds: be optimistic
    else:
        return COOPERATE if (cooperators_last_round >= m/2)
        else DEFECT
```

### Final Round (Round r): Cooperative Finish
**Action: COOPERATE if there's any reasonable chance**
- Cooperate if cooperators_last_round >= m-2
- This maintains cooperative reputation even in the final round
- Only defect if cooperation has completely collapsed (≤1 cooperators last round)

## Key Features

### 1. Optimistic Threshold Prediction
- Assumes some defectors from previous round might return to cooperation
- Uses cooperation momentum (overall rate) to make informed predictions
- Gives benefit of doubt when cooperation levels are borderline

### 2. Graduated Forgiveness
- More forgiving in early rounds to allow trust building
- Gradually becomes more selective but never completely abandons cooperation
- Maintains hope for coordination even after temporary failures

### 3. Anti-Exploitation Protection
- Defects only when cooperation has clearly collapsed (0 cooperators)
- Protects against being the sole cooperator in a sea of defectors
- Maintains cooperative stance whenever threshold achievement is plausible

### 4. Endgame Cooperation
- Avoids the typical "last round defection" problem
- Continues cooperating in final round unless situation is hopeless
- Signals long-term cooperative commitment

## Edge Case Handling

**First Round:** Always cooperate to establish positive intent

**Complete Breakdown:** If 0 cooperators in previous round, defect to avoid exploitation

**Near-Threshold Situations:** When cooperators are close to m, always cooperate to help achieve threshold

**High Cooperation Periods:** Continue cooperating to maintain beneficial equilibrium

**Final Round:** Cooperate unless cooperation has utterly collapsed

## Rationale

This strategy balances three key objectives:
1. **Collective Welfare:** Actively works to achieve and maintain the cooperation threshold
2. **Trust Building:** Starts cooperatively and maintains cooperative signals
3. **Exploitation Resistance:** Protects against scenarios where cooperation is futile

The strategy recognizes that in a collective risk dilemma, mutual cooperation is the optimal outcome for all players. By being conditionally cooperative rather than naively cooperative, it encourages others to cooperate while avoiding being systematically exploited.
'''

description_COOPERATIVE_79 = '''
# Cooperative Strategy: "Graduated Trust Builder"

## Core Philosophy
This strategy is built on the principle that cooperation is most sustainable when players can build mutual trust gradually while maintaining reasonable protection against exploitation. The strategy balances optimistic cooperation with adaptive learning from opponent behavior.

## Decision Rules

### Round 1: Optimistic Start
- **Always cooperate** in the first round
- Rationale: Demonstrate good faith and willingness to pursue mutually beneficial outcomes

### Rounds 2 to r-1: Adaptive Cooperation with Forgiveness
The strategy maintains a "cooperation score" for the group and makes decisions based on recent cooperation trends:

```pseudocode
cooperation_threshold = max(0.6, (m-1)/n + 0.1)  // Slightly above minimum needed
recent_window = min(3, current_round - 1)         // Look at last 3 rounds max

recent_cooperation_rate = (cooperators in last recent_window rounds) / (n * recent_window)

IF recent_cooperation_rate >= cooperation_threshold:
    cooperate
ELSE IF recent_cooperation_rate >= 0.3:
    cooperate with probability 0.7  // Measured forgiveness
ELSE:
    cooperate with probability 0.3  // Maintain some cooperation even when others defect
```

### Final Round: Conditional Cooperation
- If cooperation rate in rounds r-2 and r-1 was ≥ 60%: **Cooperate**
- Otherwise: **Cooperate with probability 0.5**
- Rationale: Avoid pure end-game defection which destroys long-term cooperative equilibria

## Key Features

### 1. Threshold Sensitivity
The cooperation threshold adapts to game parameters:
- For games where m is close to n: Higher threshold (more demanding)
- For games where m << n: Lower threshold (more forgiving)
- Always maintains buffer above theoretical minimum

### 2. Graduated Response
Rather than binary cooperation/defection, uses probabilistic responses:
- **High cooperation environment**: Definite cooperation
- **Medium cooperation environment**: Mostly cooperate with some caution
- **Low cooperation environment**: Still maintain some cooperation to avoid complete breakdown

### 3. Memory and Forgiveness
- Uses sliding window of recent rounds (max 3) rather than entire history
- Allows recovery from temporary defection spirals
- Balances learning from experience with giving second chances

### 4. Anti-Exploitation Safeguards
- Never cooperates with 100% probability when cooperation rates are low
- Maintains minimum cooperation probability to support group recovery
- Adjusts expectations based on actual game parameters

## Edge Case Handling

### Very Small Groups (n ≤ 4)
- Use shorter memory window (2 rounds max)
- Slightly higher cooperation thresholds due to higher individual impact

### High Threshold Games (m close to n)
- More demanding cooperation requirements
- Faster response to defection
- Higher baseline cooperation probability in low-cooperation environments

### Many Rounds (r > 10)
- Allow longer trust-building period
- More gradual adjustments to cooperation patterns

## Cooperative Alignment

This strategy embodies cooperation through:

1. **Default to Cooperation**: Starts cooperatively and maintains cooperation bias
2. **Collective Focus**: Decisions based on group cooperation rates, not individual grudges
3. **Forgiveness**: Probabilistic responses allow recovery from defection cycles
4. **Long-term Thinking**: Avoids pure end-game defection to maintain cooperative norms
5. **Graduated Trust**: Builds cooperation gradually while protecting against exploitation

The strategy aims to foster stable cooperative equilibria while being robust enough to perform reasonably even against more selfish opponents.
'''

description_COOPERATIVE_80 = '''
# Cooperative Strategy: "Adaptive Trust Builder"

## Core Philosophy
This strategy prioritizes collective welfare while being resilient to exploitation. It starts with trust, learns from group behavior, and adapts to maximize long-term cooperation while protecting against systematic defection.

## Strategy Description

### Decision Rules

**Primary Rule: Cooperation Threshold Tracking**
- Maintain a running estimate of the group's cooperation level
- Cooperate when the probability of reaching threshold `m` is sufficiently high
- Adjust cooperation probability based on observed group behavior

**Specific Decision Logic:**

1. **Trust Building Phase (First 20% of rounds)**
   - Always cooperate to establish trust and signal cooperative intent
   - Observe group behavior to calibrate future decisions

2. **Adaptive Cooperation Phase (Middle rounds)**
   - Calculate cooperation probability based on recent history
   - Use sliding window of last 3-5 rounds to estimate group cooperation rate
   - Cooperate if estimated cooperators ≥ m-1 (assuming I'm the marginal cooperator)

3. **Endgame Cooperation (Last 20% of rounds)**
   - Increase cooperation rate to maintain collective benefits
   - Account for others potentially defecting in final rounds

### Detailed Algorithm

```pseudocode
INITIALIZE:
- cooperation_history = []
- my_cooperation_rate = 1.0
- group_cooperation_estimate = 0.5
- trust_building_rounds = max(1, r * 0.2)
- endgame_rounds = max(1, r * 0.2)

FOR each round t:
    IF t <= trust_building_rounds:
        action = COOPERATE
        
    ELSE IF t > (r - endgame_rounds):
        // Endgame: increase cooperation to maintain collective benefit
        cooperation_probability = min(0.9, group_cooperation_estimate + 0.2)
        action = COOPERATE if random() < cooperation_probability else DEFECT
        
    ELSE:
        // Main adaptive phase
        window_size = min(5, t-1)
        recent_cooperation_rate = calculate_recent_cooperation_rate(window_size)
        
        // Estimate how many others will cooperate
        expected_other_cooperators = (n-1) * recent_cooperation_rate
        
        // Cooperate if my cooperation likely enables threshold
        IF expected_other_cooperators >= (m-1):
            action = COOPERATE
        ELSE IF expected_other_cooperators >= (m-2) AND recent_cooperation_rate > 0.3:
            // Risk-adjusted cooperation when close to threshold
            action = COOPERATE if random() < 0.7 else DEFECT
        ELSE:
            // Low cooperation environment - occasionally cooperate to test
            action = COOPERATE if random() < 0.2 else DEFECT
    
    // Update estimates after observing round results
    update_cooperation_estimates(round_results)
```

### Edge Case Handling

**First Round:**
- Always cooperate to signal cooperative intent and gather information about group

**Last Round:**
- Cooperate with high probability (0.8) to maintain collective benefit, accounting for potential endgame defection by others

**Low Cooperation Scenarios:**
- If group cooperation drops below 20% for multiple rounds, reduce cooperation but maintain occasional cooperative "tests" to detect recovery

**High Cooperation Scenarios:**
- If group consistently meets threshold, maintain high cooperation rate to preserve collective benefit

**Near-Threshold Scenarios:**
- When expected cooperators ≈ m-1, cooperate with high probability since my action is pivotal

### Cooperative Alignment Features

1. **Trust Building:** Establishes cooperative norm early in the game
2. **Collective Benefit Focus:** Prioritizes scenarios where threshold is likely met
3. **Forgiveness:** Continues testing cooperation even after defection periods
4. **Endgame Cooperation:** Maintains collective focus even in final rounds
5. **Risk Sharing:** Willing to cooperate when pivotal for group success

### Key Parameters for Adaptation

- **Learning Window:** 3-5 rounds for estimating recent behavior
- **Trust Building:** 20% of total rounds
- **Endgame Phase:** 20% of total rounds
- **Cooperation Threshold:** Cooperate when estimated others ≥ m-1
- **Risk Adjustment:** 70% cooperation probability in uncertain situations

This strategy balances cooperative intent with strategic adaptation, aiming to foster and maintain collective cooperation while being resilient to exploitation patterns.
'''

description_COOPERATIVE_81 = '''
# Cooperative Strategy: "Conditional Trust Builder"

## Core Philosophy
This strategy prioritizes collective welfare while maintaining resilience against exploitation. It starts with trust, adapts to group behavior, and focuses on building sustainable cooperation throughout the game.

## Decision Rules

### Round 1: Trust Signal
**Always COOPERATE** in the first round to:
- Signal cooperative intent to other players
- Establish goodwill from the start
- Gather baseline information about group cooperation levels

### Rounds 2 to r-1: Adaptive Cooperation
Use a **threshold-based approach** with forgiveness:

```pseudocode
cooperators_last_round = count_cooperators(previous_round)
my_cooperation_rate = my_cooperations / rounds_played

IF cooperators_last_round >= m:
    // Threshold was met - reinforce positive outcome
    COOPERATE
    
ELSE IF cooperators_last_round >= (m - 1):
    // Close to threshold - be the bridge player
    COOPERATE
    
ELSE IF my_cooperation_rate > 0.6 AND cooperators_last_round >= (m - 2):
    // I've been cooperative and we're close - give another chance
    COOPERATE
    
ELSE IF cooperators_last_round < (m - 2):
    // Too few cooperators - protect against exploitation
    DEFECT
```

### Final Round: Conditional Cooperation
In the last round, maintain cooperative stance if the group has shown reasonable cooperation:

```pseudocode
overall_cooperation_rate = total_cooperators_all_rounds / (n * (r-1))

IF overall_cooperation_rate >= 0.4:
    // Group has shown reasonable cooperation
    COOPERATE
ELSE:
    // Group has been largely uncooperative
    DEFECT
```

## Key Features

### 1. **Threshold Awareness**
- Recognizes that exactly m cooperators are needed
- Willing to be the "pivotal" cooperator when close to threshold
- Accounts for the strategic importance of being cooperative when others might defect

### 2. **Graduated Response**
- Doesn't immediately punish single defection episodes
- Responds more strongly to sustained non-cooperation
- Maintains hope for recovery when cooperation levels are borderline

### 3. **Long-term Perspective**
- Tracks overall cooperation patterns, not just recent rounds
- Invests in building cooperative relationships early
- Considers reputation effects in repeated interactions

### 4. **Exploitation Protection**
- Will defect when cooperation levels are consistently too low
- Balances cooperative intent with rational self-protection
- Avoids being systematically exploited by free-riders

## Edge Case Handling

### Small Groups (n ≤ 4)
- Be more forgiving since each player's decision is more impactful
- Cooperate even with slightly lower thresholds

### High Threshold Games (m close to n)
- Maintain cooperation longer since everyone's participation is crucial
- Only defect if cooperation rate falls below 30%

### Low Reward Scenarios (k ≤ 1.5)
- Still cooperative but slightly more conservative
- Require m cooperators (not m-1) before committing to cooperate

## Strategic Rationale

This strategy is designed to:

1. **Foster Cooperation**: Start cooperatively and reward group cooperation
2. **Build Trust**: Show consistent cooperative intent while being reasonable
3. **Prevent Cascade Failures**: Stay cooperative when close to threshold to prevent coordination failures
4. **Adapt to Group Dynamics**: Respond to the actual behavior patterns observed
5. **Maintain Long-term Viability**: Balance cooperation with protection against systematic exploitation

The strategy assumes other LLMs will also be trying to solve the collective action problem, and positions itself as a reliable cooperative partner while maintaining the flexibility to adapt to varying levels of group cooperation.
'''

description_COOPERATIVE_82 = '''
# Adaptive Cooperative Strategy: "Progressive Trust Builder"

## Core Philosophy
This strategy prioritizes long-term collective benefit while maintaining resilience against exploitation. It starts with strong cooperation and adapts based on community behavior patterns, always seeking to rebuild cooperative equilibria when possible.

## Decision Rules

### Round 1: Unconditional Cooperation
- **Action**: Always COOPERATE
- **Rationale**: Signal cooperative intent and contribute to establishing initial trust

### Rounds 2 to r-1: Adaptive Cooperation Based on Community Momentum

```pseudocode
For round t (where 2 ≤ t ≤ r-1):
    cooperation_rate = count_cooperators(t-1) / n
    recent_threshold_met = (count_cooperators(t-1) ≥ m)
    
    IF cooperation_rate ≥ 0.7 THEN
        action = COOPERATE  // High cooperation: maintain momentum
    
    ELSE IF cooperation_rate ≥ (m/n) AND recent_threshold_met THEN
        action = COOPERATE  // Threshold being met: support success
    
    ELSE IF cooperation_rate ≥ (m-1)/n THEN
        action = COOPERATE  // Close to threshold: be the crucial cooperator
    
    ELSE IF cooperation_rate ≥ 0.3 THEN
        // Mixed cooperation: conditional support based on trend
        trend = cooperation_rate - previous_cooperation_rate
        IF trend ≥ 0 THEN
            action = COOPERATE  // Improving trend: encourage growth
        ELSE
            action = DEFECT     // Declining trend: protect resources
        END IF
    
    ELSE
        action = DEFECT  // Low cooperation: avoid exploitation
    END IF
```

### Final Round (r): Conditional Cooperation
```pseudocode
For round r:
    cooperation_rate = count_cooperators(r-1) / n
    
    IF cooperation_rate ≥ (m-1)/n THEN
        action = COOPERATE  // Give final chance for collective success
    ELSE
        action = DEFECT     // Protect against final round exploitation
    END IF
```

## Key Strategic Elements

### 1. Threshold Sensitivity
- Always cooperate when we're close to the threshold (cooperation_rate ≥ (m-1)/n)
- Recognize that being the pivotal cooperator creates maximum collective value

### 2. Momentum Recognition
- Track cooperation trends, not just absolute levels
- Reward improving community behavior even if current levels are moderate
- Maintain cooperation during successful periods to prevent decay

### 3. Exploitation Protection
- Defect when cooperation rates are very low (< 30%) to avoid systematic exploitation
- Use final round protection against end-game defection cascades

### 4. Recovery Facilitation
- Resume cooperation quickly when community shows signs of recovery
- Maintain optimistic stance toward collective action possibilities

## Edge Case Handling

### First Round
- Always cooperate to establish cooperative precedent and signal trustworthiness

### Near-Threshold Situations
- When exactly (m-1) players cooperated last round, always cooperate to ensure threshold is met
- This maximizes collective payoff and demonstrates commitment to group success

### Final Round
- Cooperate only if there's reasonable chance of threshold success
- Protects against opponents who defect on final round regardless of history

### All-Defect Scenarios
- If cooperation drops to zero, resume cooperation if even small recovery is observed
- Prevents permanent lock-in to suboptimal equilibria

## Cooperative Alignment

This strategy embodies cooperation through:

1. **Initial Trust**: Starting with cooperation signals good faith
2. **Threshold Support**: Prioritizing collective success over individual gain when close to threshold
3. **Recovery Assistance**: Helping rebuild cooperation after breakdowns
4. **Momentum Maintenance**: Supporting successful cooperative periods
5. **Trend Responsiveness**: Rewarding community improvements

The strategy balances cooperative ideals with practical resilience, ensuring that cooperation is sustainable and not easily exploited while maximizing opportunities for collective benefit.
'''

description_COOPERATIVE_83 = '''
# Cooperative Strategy: "Graduated Reciprocal Cooperation" (GRC)

## Core Philosophy
This strategy is built on the principle that cooperation is the optimal outcome for all players, but requires intelligent management of trust and risk. It aims to establish and maintain cooperative equilibria while protecting against exploitation.

## Strategy Description

### Phase 1: Trust Building (Rounds 1-3)
- **Round 1**: Always COOPERATE (establish cooperative intent)
- **Rounds 2-3**: COOPERATE if at least 50% of players cooperated in the previous round, otherwise DEFECT

### Phase 2: Adaptive Cooperation (Rounds 4 to r-2)
Apply a graduated response based on cooperation history:

1. **Calculate cooperation rate**: `coop_rate = (total_cooperators_last_round) / n`
2. **Decision rule**:
   - If `coop_rate >= (m/n + 0.1)`: COOPERATE (sufficient cooperation exists)
   - If `coop_rate >= (m-1)/n`: COOPERATE with probability 0.8 (encourage threshold reaching)
   - If `coop_rate < (m-1)/n`: DEFECT (protect against systematic defection)

### Phase 3: End Game Cooperation (Last 2 rounds)
- **Round r-1**: COOPERATE if cooperation rate in previous round >= m/n
- **Round r**: COOPERATE (maximize final collective outcome)

## Detailed Decision Logic (Pseudocode)

```python
def decide_action(round_num, history, n, m, r):
    if round_num == 1:
        return COOPERATE
    
    last_round_cooperators = count_cooperators(history[-1])
    coop_rate = last_round_cooperators / n
    
    # Phase 1: Trust Building
    if round_num <= 3:
        return COOPERATE if coop_rate >= 0.5 else DEFECT
    
    # Phase 3: End Game
    if round_num >= r - 1:
        if round_num == r:  # Final round
            return COOPERATE
        else:  # Second to last round
            return COOPERATE if coop_rate >= m/n else DEFECT
    
    # Phase 2: Adaptive Cooperation
    threshold_rate = m/n
    
    if coop_rate >= threshold_rate + 0.1:
        return COOPERATE
    elif coop_rate >= (m-1)/n:
        return COOPERATE if random() < 0.8 else DEFECT
    else:
        return DEFECT
```

## Strategic Rationale

### Cooperative Elements:
1. **Initial Trust**: Always cooperates in round 1 to signal cooperative intent
2. **Threshold Awareness**: Specifically designed around the minimum threshold m
3. **Forgiveness**: Willing to return to cooperation when others show cooperative behavior
4. **End-Game Cooperation**: Cooperates in final round to maximize collective outcome

### Protection Mechanisms:
1. **Graduated Response**: Doesn't immediately defect when cooperation drops
2. **Probabilistic Cooperation**: Uses randomization near threshold to encourage tipping point
3. **Defection Trigger**: Protects against systematic exploitation when cooperation is too low

### Edge Case Handling:
- **First Round**: Always cooperate to establish good faith
- **Last Round**: Always cooperate for maximum collective benefit
- **Low Participation**: Switches to defection when cooperation is systematically insufficient
- **High Participation**: Maintains cooperation when threshold is comfortably exceeded

## Expected Behavior Against Other Strategies:
- **Against other cooperators**: Establishes stable cooperation quickly
- **Against mixed strategies**: Adapts cooperation level to maintain threshold
- **Against defectors**: Protects itself while leaving door open for cooperation
- **Against sophisticated strategies**: The graduated response prevents exploitation while encouraging mutual cooperation

This strategy balances the cooperative imperative with practical protection, aiming to achieve the collectively optimal outcome while being robust against various opponent behaviors.
'''

description_COOPERATIVE_84 = '''
# Cooperative Strategy: "Adaptive Trust Builder"

## Core Philosophy
This strategy prioritizes establishing and maintaining cooperation while being resilient to exploitation. It balances trust-building with prudent risk management to maximize collective welfare.

## Strategy Description

### Decision Rules

**Primary Cooperation Principle:**
- Default to cooperation (C) to signal willingness to collaborate
- Only defect when cooperation appears futile or when being systematically exploited

**Adaptive Threshold Monitoring:**
- Track the cooperation rate across recent rounds
- Cooperate when there's reasonable evidence that the threshold m can be met
- Defect only when cooperation levels are consistently too low to reach threshold m

### Detailed Algorithm

```pseudocode
STRATEGY: Adaptive Trust Builder

INITIALIZE:
- cooperation_history = empty list
- recent_window_size = min(5, r/3)  // Look at recent 5 rounds or 1/3 of total rounds
- trust_threshold = 0.6  // Require 60% recent cooperation to stay optimistic
- minimum_cooperators_rate = m/n  // Target cooperation rate needed

FOR round t FROM 1 TO r:
    
    IF t == 1:
        // First round: Always cooperate to signal good intentions
        PLAY C
    
    ELSE IF t == r:
        // Last round: Cooperate if others have shown consistent cooperation
        recent_coop_rate = cooperation_rate_in_last(recent_window_size) rounds
        IF recent_coop_rate >= minimum_cooperators_rate * 0.8:
            PLAY C
        ELSE:
            PLAY D
    
    ELSE:
        // Middle rounds: Adaptive decision based on recent history
        recent_coop_rate = cooperation_rate_in_last(recent_window_size) rounds
        
        // Check if we're in a cooperative environment
        IF recent_coop_rate >= minimum_cooperators_rate:
            PLAY C  // Threshold likely to be met
        
        // Check if there's hope for cooperation
        ELSE IF recent_coop_rate >= minimum_cooperators_rate * 0.7:
            // Give benefit of doubt, try to encourage cooperation
            PLAY C
        
        // Check if we're being consistently exploited
        ELSE IF recent_coop_rate < minimum_cooperators_rate * 0.5:
            // Too few cooperators, protect against loss
            PLAY D
        
        ELSE:
            // Borderline case: cooperate with decreasing probability
            // as we approach middle of game
            optimism_factor = (r - t) / r  // More optimistic early in game
            IF random() < optimism_factor * trust_threshold:
                PLAY C
            ELSE:
                PLAY D
    
    // Update history after each round
    UPDATE cooperation_history with current round results

HELPER FUNCTIONS:
cooperation_rate_in_last(k) rounds:
    return (number of players who cooperated in last k rounds) / (n * k)
```

### Key Features

1. **First Round Cooperation**: Always cooperate in round 1 to establish good faith and signal cooperative intent to other strategies.

2. **Adaptive Learning**: Monitor recent cooperation patterns rather than entire history to allow for strategy evolution and recovery from early defection phases.

3. **Threshold-Aware**: Make decisions based on whether the minimum threshold m is likely to be reached, not just on general cooperation levels.

4. **Graduated Response**: Don't immediately defect when cooperation drops; give multiple chances for the group to recover.

5. **End-Game Consideration**: In the final round, base decision on established patterns rather than fear of defection.

6. **Resilience to Exploitation**: Protect against systematic exploitation while maintaining cooperative orientation.

### Edge Case Handling

- **All Defect Scenario**: Will eventually switch to defection if cooperation rates stay consistently below 50% of threshold requirement
- **Mixed Strategies**: Responds proportionally to cooperation levels, encouraging cooperation while protecting against losses
- **Late-Game Dynamics**: Maintains cooperation if group has shown consistent collaborative behavior

### Cooperative Alignment

This strategy is fundamentally cooperative because it:
- Starts with cooperation to build trust
- Gives multiple chances for group recovery
- Only defects when cooperation appears genuinely futile
- Prioritizes collective welfare over individual short-term gains
- Encourages positive cooperation spirals through consistent early cooperation

The strategy balances pure altruism with intelligent cooperation, making it robust against various opponent strategies while maintaining a fundamentally collaborative approach.
'''

description_COOPERATIVE_85 = '''
# Cooperative Strategy: "Adaptive Threshold Guardian"

## Core Philosophy
This strategy prioritizes collective welfare while being resilient to exploitation. It aims to maintain cooperation when beneficial for the group while adapting to opponent behavior patterns.

## Strategy Description

### Decision Rules

**Primary Logic:**
1. **Default to Cooperation**: Start cooperatively and maintain cooperation when the group is achieving the threshold
2. **Adaptive Forgiveness**: Forgive defections when they don't threaten group success
3. **Defensive Response**: Reduce cooperation only when facing systematic exploitation that threatens collective benefits

### Detailed Algorithm

```pseudocode
STRATEGY: Adaptive Threshold Guardian

INITIALIZE:
    cooperation_streak = 0
    last_round_cooperators = 0
    exploitation_detector = 0
    forgiveness_credit = 2

FOR each round t:
    IF t == 1:  // First round
        PLAY C
        
    ELSE IF t == final_round:  // Last round special case
        IF last_round_cooperators >= m:
            PLAY C  // Maintain successful cooperation
        ELSE:
            PLAY D  // Don't be exploited in final round if threshold unlikely
            
    ELSE:  // Middle rounds (main logic)
        
        // Count cooperators from last round
        last_round_cooperators = count_cooperators(t-1)
        
        // Update exploitation detector
        IF last_round_cooperators >= m:
            exploitation_detector = max(0, exploitation_detector - 1)
            cooperation_streak += 1
        ELSE:
            exploitation_detector += 1
            cooperation_streak = 0
            
        // Main decision logic
        IF last_round_cooperators >= m:
            // Threshold was met - generally safe to cooperate
            PLAY C
            
        ELSE IF last_round_cooperators >= (m - 1):
            // Close to threshold - cooperate to help achieve it
            PLAY C
            
        ELSE IF exploitation_detector <= 2 AND forgiveness_credit > 0:
            // Give benefit of doubt in early failures
            forgiveness_credit -= 1
            PLAY C
            
        ELSE IF cooperation_streak >= 3:
            // Been successful recently, try to restart cooperation
            PLAY C
            
        ELSE:
            // Threshold consistently not met, protect against exploitation
            PLAY D
            
        // Reset forgiveness periodically if cooperation is working
        IF cooperation_streak >= 4:
            forgiveness_credit = min(2, forgiveness_credit + 1)
```

### Key Features

**1. Threshold-Aware Cooperation**
- Cooperates when the group is meeting or close to meeting the threshold (m cooperators)
- Recognizes that cooperation is most valuable when it helps achieve the collective benefit

**2. Graduated Response to Defection**
- Doesn't immediately punish single-round failures
- Uses an "exploitation detector" to identify systematic non-cooperation
- Maintains forgiveness credits to give opponents chances to return to cooperation

**3. Edge Case Handling**
- **First Round**: Always cooperate to signal cooperative intent
- **Last Round**: Cooperate if threshold was met in previous round (showing the group can coordinate), otherwise defect to avoid exploitation
- **Near-threshold situations**: Cooperate when we're 1 cooperator away from threshold

**4. Streak-Based Recovery**
- Tracks cooperation streaks to identify when the group is successfully coordinating
- Uses successful periods to rebuild trust and forgiveness

### Cooperative Alignment

This strategy embodies cooperation through:

1. **Default Cooperation**: Starts and prefers to cooperate
2. **Group Focus**: Decisions based on group threshold achievement rather than individual punishment
3. **Forgiveness**: Built-in mechanisms to forgive and rebuild cooperation
4. **Collective Benefit Priority**: Cooperates when it helps the group achieve the threshold
5. **Adaptive Trust**: Rebuilds trust during successful cooperation periods

### Strategic Rationale

- **Against other cooperators**: Will achieve consistent mutual cooperation
- **Against mixed strategies**: Will cooperate when the group can achieve threshold, protecting against exploitation when it cannot
- **Against defectors**: Will initially try cooperation but adapt to protect against consistent exploitation
- **Robust to noise**: Forgiveness mechanisms prevent single-round mistakes from destroying cooperation

This strategy balances the cooperative imperative with practical resilience, aiming to maximize both individual and collective welfare over the repeated game.
'''

description_COOPERATIVE_86 = '''
# Cooperative Strategy: "Adaptive Threshold Guardian"

## Core Philosophy
This strategy prioritizes collective welfare while being resilient to exploitation. It assumes other cooperative strategies exist and works to coordinate with them, while protecting against free-riders.

## Decision Rules

### Round 1: Cooperative Signal
**Always cooperate** in the first round to:
- Signal cooperative intent to other players
- Establish a foundation for mutual cooperation
- Gather information about opponent tendencies

### Rounds 2 to r-1: Adaptive Cooperation
Use a three-tier decision system:

1. **Cooperation Threshold Check**
   - If cooperators in previous round ≥ m: **Cooperate**
   - This rewards successful coordination and maintains momentum

2. **Near-Miss Recovery**
   - If cooperators in previous round = m-1: **Cooperate**
   - One additional cooperator could have saved the round
   - Shows commitment to helping achieve threshold

3. **Strategic Defection**
   - If cooperators in previous round < m-1: **Defect**
   - Too few cooperators suggest coordination breakdown
   - Protects against systematic exploitation

### Final Round: Conditional Cooperation
In round r, cooperate if and only if:
- Average cooperation rate across all previous rounds ≥ (m/n)
- This ensures we only sacrifice in the final round if there's been sufficient collective commitment

## Edge Case Handling

### Information Tracking
- Maintain running count of cooperators per round
- Track individual player patterns when possible
- Calculate overall cooperation momentum

### Tie-Breaking Rules
- When exactly at decision boundaries, lean toward cooperation
- If unable to observe some actions clearly, assume cooperation

### Robustness Measures
- If game parameters change, recalibrate thresholds proportionally
- Maintain cooperative bias unless evidence strongly suggests futility

## Pseudocode

```
function decide_action(round, history, n, m, k, r):
    if round == 1:
        return COOPERATE
    
    if round == r:  // Final round
        avg_cooperation = calculate_average_cooperation_rate(history)
        if avg_cooperation >= (m/n):
            return COOPERATE
        else:
            return DEFECT
    
    // Rounds 2 to r-1
    last_round_cooperators = count_cooperators(history[-1])
    
    if last_round_cooperators >= m:
        return COOPERATE  // Reward success
    
    if last_round_cooperators == m-1:
        return COOPERATE  // Help achieve threshold
    
    return DEFECT  // Protect against widespread defection
```

## Strategic Rationale

1. **Coordination Focus**: By cooperating when we're close to threshold (m-1), we maximize chances of achieving collective benefit

2. **Exploitation Protection**: Defecting when cooperation is very low (< m-1) prevents being taken advantage of by predominantly selfish strategies

3. **Momentum Building**: Rewarding successful rounds with continued cooperation helps establish stable cooperative equilibria

4. **Endgame Consideration**: The final round rule ensures we don't waste cooperation on games that have shown insufficient collective commitment

This strategy balances genuine cooperation with strategic awareness, making it robust against various opponent types while maintaining a fundamentally cooperative orientation.
'''

description_COOPERATIVE_87 = '''
# Cooperative Strategy: "Graduated Reciprocal Cooperation"

## Core Philosophy
This strategy prioritizes collective welfare while maintaining resilience against exploitation. It operates on the principle that cooperation should be the default, but must be sustainable through reciprocal behavior from others.

## Decision Rules

### Round 1: Always Cooperate
- **Action**: C
- **Rationale**: Establish cooperative intent and give the group the best chance to reach threshold m from the start.

### Rounds 2 to r-1: Adaptive Cooperation
```pseudocode
cooperation_rate = count_cooperators_last_round / n
threshold_rate = m / n

if cooperation_rate >= threshold_rate:
    // Group is meeting threshold - maintain cooperation
    action = C
    
else if cooperation_rate >= (threshold_rate - 0.1):
    // Close to threshold - cooperate to help reach it
    action = C
    
else if cooperation_rate >= 0.3:
    // Some cooperation exists - use tit-for-tat with forgiveness
    if cooperated_last_round:
        action = C
    else:
        // Forgive occasionally to break defection cycles
        action = (random() < 0.3) ? C : D
        
else:
    // Very low cooperation - minimal cooperation to signal willingness
    action = (random() < 0.2) ? C : D
```

### Final Round (Round r): Conditional Cooperation
```pseudocode
recent_cooperation_rate = count_cooperators_last_3_rounds / (3 * n)

if recent_cooperation_rate >= (m / n):
    // Group has been consistently cooperative
    action = C
else:
    // Limited recent cooperation - defect to secure personal payoff
    action = D
```

## Key Features

### 1. Threshold Awareness
- Monitors whether the group is meeting the minimum cooperation threshold m
- Adjusts cooperation likelihood based on how close the group is to the threshold

### 2. Graduated Response
- **High Cooperation Environment**: Maintains full cooperation
- **Moderate Cooperation**: Uses generous tit-for-tat with forgiveness
- **Low Cooperation**: Reduces but doesn't eliminate cooperation to signal continued willingness

### 3. Forgiveness Mechanism
- Includes probabilistic cooperation even when facing defectors
- Prevents permanent defection spirals
- Maintains hope for returning to cooperative equilibrium

### 4. End-Game Adaptation
- Recognizes the final round's different incentive structure
- Cooperates only if there's evidence of sustained group cooperation
- Protects against last-round exploitation while rewarding consistent cooperators

## Edge Case Handling

### Uncertain Situations
- When cooperation rates hover near the threshold, err on the side of cooperation
- Use recent history (last 3 rounds) rather than just immediate last round for final decision

### All-Defect Scenarios
- Maintain minimal cooperation (20% probability) to signal continued willingness
- Ready to quickly return to full cooperation if others begin cooperating

### All-Cooperate Scenarios
- Maintain full cooperation to preserve the optimal group outcome
- No reason to deviate when everyone benefits maximally

## Cooperative Alignment

This strategy is fundamentally cooperative because it:

1. **Starts with trust** - Always cooperates in round 1
2. **Prioritizes collective welfare** - Tries to maintain threshold-meeting cooperation
3. **Offers forgiveness** - Doesn't punish defection permanently
4. **Signals willingness** - Never goes to zero cooperation probability
5. **Rewards group cooperation** - Fully cooperates when others do
6. **Balances sustainability** - Prevents exploitation while maintaining cooperative intent

The strategy recognizes that pure unconditional cooperation may be exploited, but maintains a cooperative orientation by being quick to reward cooperative behavior from others and slow to abandon cooperation entirely.
'''

description_COOPERATIVE_88 = '''
# Cooperative Strategy: "Adaptive Threshold Guardian"

## Core Philosophy
This strategy prioritizes collective welfare while maintaining resilience against exploitation. It aims to foster cooperation by being generous initially, responsive to group dynamics, and protective of the collective threshold.

## Decision Rules

### Round 1: Generous Start
**Always COOPERATE** in the first round to signal cooperative intent and help establish a positive foundation.

### Rounds 2 to r-1: Adaptive Response
Use a multi-factor decision system:

**COOPERATE if ANY of the following conditions are met:**

1. **Threshold Security**: Number of cooperators in previous round ≥ m
   - *Rationale: When threshold is met, continue supporting the successful cooperation*

2. **Near-Miss Recovery**: Number of cooperators in previous round = m-1 AND my previous action was D
   - *Rationale: If we almost succeeded and I defected, I should help reach the threshold*

3. **Momentum Building**: Cooperation rate in previous round ≥ 0.6
   - *Rationale: When majority shows cooperative intent, support the positive trend*

4. **Forgiveness Protocol**: It's been ≥ 3 rounds since cooperation rate was ≥ (m/n)
   - *Rationale: Periodically attempt to restart cooperation even after failures*

### Round r (Final Round): Conditional Cooperation
**COOPERATE if:**
- Average cooperation rate over last 3 rounds ≥ (m/n), OR
- Number of cooperators in round r-1 ≥ m-1

*Rationale: In the final round, cooperate if there's been recent evidence of sufficient group cooperation or we're very close to threshold.*

## Pseudocode

```python
def decide_action(round_num, total_rounds, history, my_history):
    # Round 1: Always cooperate
    if round_num == 1:
        return COOPERATE
    
    last_round_cooperators = count_cooperators(history[-1])
    last_cooperation_rate = last_round_cooperators / n
    
    # Final round logic
    if round_num == total_rounds:
        if len(history) >= 3:
            recent_avg_rate = avg_cooperation_rate(history[-3:])
            if recent_avg_rate >= (m/n) or last_round_cooperators >= (m-1):
                return COOPERATE
        return DEFECT
    
    # Main decision logic (rounds 2 to r-1)
    # Condition 1: Threshold was met
    if last_round_cooperators >= m:
        return COOPERATE
    
    # Condition 2: Near-miss recovery
    if last_round_cooperators == (m-1) and my_history[-1] == DEFECT:
        return COOPERATE
    
    # Condition 3: High cooperation momentum  
    if last_cooperation_rate >= 0.6:
        return COOPERATE
    
    # Condition 4: Forgiveness protocol
    rounds_since_good_cooperation = 0
    for i in range(len(history)-1, -1, -1):
        coop_rate = count_cooperators(history[i]) / n
        if coop_rate >= (m/n):
            break
        rounds_since_good_cooperation += 1
    
    if rounds_since_good_cooperation >= 3:
        return COOPERATE
    
    # Default: Defect if no cooperation conditions met
    return DEFECT
```

## Key Features

1. **Generous Opening**: Signals cooperative intent from the start
2. **Threshold Awareness**: Prioritizes maintaining successful cooperation when threshold is met
3. **Recovery Oriented**: Helps rescue near-successful cooperation attempts
4. **Momentum Sensitive**: Supports positive trends in group behavior  
5. **Forgiving**: Periodically attempts to restart cooperation after failures
6. **Endgame Realistic**: Cooperates in final round only with strong evidence of group cooperation

## Cooperative Alignment

This strategy embodies cooperative principles by:
- **Initiating cooperation** rather than waiting for others
- **Supporting successful collective action** when threshold is met
- **Helping rescue failing cooperation** when close to success
- **Giving groups second chances** through forgiveness protocols
- **Balancing idealism with realism** to maintain sustainability

The strategy aims to maximize collective payoffs while being robust enough to handle mixed-motive environments typical in tournaments.
'''

description_COOPERATIVE_89 = '''
# Cooperative Strategy: "Threshold Guardian with Forgiveness"

## Core Philosophy
This strategy prioritizes collective welfare while being resilient to occasional defections. It aims to establish and maintain cooperation by being generous initially, responsive to group dynamics, and forgiving of isolated defections.

## Decision Rules

### Round 1: Unconditional Cooperation
- **Always cooperate** in the first round to signal cooperative intent and help establish a cooperative norm.

### Rounds 2 to r-1: Adaptive Threshold Monitoring
For each round t (where 2 ≤ t ≤ r-1):

1. **Calculate cooperation rate** from previous round: `coop_rate = cooperators_last_round / n`

2. **Apply decision rule based on cooperation patterns:**
   - If `coop_rate ≥ (m/n + 0.1)`: **Cooperate** (threshold safely exceeded)
   - If `(m/n - 0.1) ≤ coop_rate < (m/n + 0.1)`: **Cooperate** (near threshold - be generous)
   - If `coop_rate < (m/n - 0.1)`: Apply **forgiveness check**

3. **Forgiveness mechanism** (when cooperation rate is low):
   - If this is the first time cooperation dropped below threshold: **Cooperate** (give benefit of doubt)
   - If cooperation has been consistently low for 2+ consecutive rounds: **Defect**

### Final Round (Round r): Conditional Cooperation
- If cooperation rate in round r-1 was ≥ m/n: **Cooperate**
- Otherwise: **Defect** (protect against end-game exploitation)

## Pseudocode

```python
def decide_action(round_num, history, n, m, r):
    if round_num == 1:
        return "C"  # Always cooperate first
    
    # Calculate last round's cooperation
    last_cooperators = count_cooperators(history[-1])
    coop_rate = last_cooperators / n
    threshold_rate = m / n
    
    if round_num == r:  # Final round
        return "C" if coop_rate >= threshold_rate else "D"
    
    # Middle rounds (2 to r-1)
    if coop_rate >= threshold_rate + 0.1:
        return "C"  # Safe cooperation
    elif coop_rate >= threshold_rate - 0.1:
        return "C"  # Near threshold - be generous
    else:
        # Low cooperation - check forgiveness
        consecutive_low = count_consecutive_low_cooperation(history, threshold_rate)
        return "D" if consecutive_low >= 2 else "C"

def count_consecutive_low_cooperation(history, threshold_rate):
    count = 0
    for round_history in reversed(history):
        coop_rate = count_cooperators(round_history) / len(round_history)
        if coop_rate < threshold_rate - 0.1:
            count += 1
        else:
            break
    return count
```

## Key Features

### 1. **Generous Initialization**
- Unconditional cooperation in round 1 helps establish cooperative norms

### 2. **Threshold-Aware Adaptation**
- Monitors whether the group is meeting, approaching, or falling short of the minimum cooperation threshold
- Uses buffer zones (±0.1) around the critical threshold to avoid overreacting to small fluctuations

### 3. **Forgiveness Mechanism**
- Gives groups a second chance when cooperation drops
- Only switches to defection after sustained non-cooperation (2+ rounds)

### 4. **End-Game Protection**
- Adjusts behavior in final round based on recent cooperation levels
- Prevents exploitation while maintaining cooperation when warranted

### 5. **Collective Welfare Focus**
- Biased toward cooperation when threshold achievement is uncertain
- Prioritizes group success over individual advantage in most scenarios

## Strategic Rationale

This strategy balances several important considerations:

- **Risk Management**: Protects against free-riding while promoting collective success
- **Norm Establishment**: Early cooperation helps establish positive group dynamics
- **Adaptability**: Responds to group behavior patterns rather than individual actions
- **Robustness**: Forgiveness mechanism prevents spiral into mutual defection from temporary coordination failures
- **Incentive Alignment**: Encourages others to cooperate by demonstrating reliable cooperative behavior

The strategy is designed to work well with other cooperative strategies while having reasonable defenses against purely exploitative approaches.
'''

description_COOPERATIVE_90 = '''
# Cooperative Strategy: "Adaptive Threshold Guardian"

## Core Philosophy
This strategy prioritizes collective welfare while being robust against exploitation. It aims to maintain cooperation when feasible and only defects when cooperation appears unsustainable or when defection won't harm the collective threshold.

## Decision Rules

### Round 1: Initial Cooperation
- **Action**: Always COOPERATE
- **Rationale**: Establish cooperative intent and gather information about opponent tendencies

### Rounds 2 to r-1: Adaptive Cooperation
```pseudocode
threshold_met_history = count of previous rounds where ≥m players cooperated
recent_cooperators = count of cooperators in last round
cooperation_trend = threshold_met_history / (current_round - 1)

IF cooperation_trend ≥ 0.6:
    // High cooperation environment - maintain cooperation
    Action = COOPERATE
    
ELIF recent_cooperators ≥ (m + 1):
    // Safe margin above threshold - can afford to defect occasionally
    IF (current_round % 3 == 0) AND (cooperation_trend ≥ 0.4):
        Action = DEFECT  // Strategic defection for higher payoff
    ELSE:
        Action = COOPERATE
        
ELIF recent_cooperators == m:
    // Exactly at threshold - critical cooperation needed
    Action = COOPERATE
    
ELIF recent_cooperators == (m - 1):
    // One short of threshold - essential to cooperate
    Action = COOPERATE
    
ELSE:
    // Far below threshold - evaluate if cooperation can recover
    IF cooperation_trend ≥ 0.3:
        Action = COOPERATE  // Still hope for recovery
    ELSE:
        Action = DEFECT     // Cooperation appears unsustainable
```

### Final Round (Round r): Conditional Cooperation
```pseudocode
recent_cooperators = count of cooperators in round (r-1)
overall_cooperation_rate = total_threshold_met_rounds / (r-1)

IF recent_cooperators ≥ m:
    // Threshold was met last round
    IF overall_cooperation_rate ≥ 0.5:
        Action = COOPERATE  // Reward consistent cooperation
    ELSE:
        Action = DEFECT     // Take final advantage
        
ELIF recent_cooperators == (m-1):
    // Critical: cooperation needed to meet threshold
    Action = COOPERATE
    
ELSE:
    // Threshold unlikely to be met
    Action = DEFECT
```

## Edge Cases and Special Considerations

### Small Groups (n ≤ 4)
- Be more conservative with defection since each player's action has larger impact
- Only defect when recent_cooperators ≥ (m + 2)

### High Threshold Games (m > n/2)
- Maintain cooperation more aggressively since threshold is harder to achieve
- Only defect when recent_cooperators ≥ (m + 1) and cooperation_trend ≥ 0.7

### Low Rounds (r ≤ 5)
- Prioritize cooperation to establish good patterns
- Only consider strategic defection if consistently ≥ (m + 2) cooperators

## Key Features

1. **Threshold Awareness**: Always considers how close the group is to the minimum threshold
2. **Trend Analysis**: Uses historical cooperation rates to predict future behavior
3. **Strategic Defection**: Occasionally defects when there's a safe margin, maximizing individual payoff while maintaining collective benefit
4. **Recovery Mechanism**: Continues cooperating even in declining cooperation environments if there's reasonable hope for recovery
5. **Endgame Consideration**: Adjusts behavior in final round based on overall game dynamics

## Cooperative Alignment

This strategy maintains a cooperative mindset by:
- Defaulting to cooperation in uncertain situations
- Never defecting when it would jeopardize the threshold
- Prioritizing collective welfare over individual gain in critical situations
- Only engaging in strategic defection when it doesn't harm group outcomes
- Attempting to maintain cooperation even when others are defecting, as long as recovery seems possible

The strategy balances pure altruism with strategic thinking, recognizing that some calculated self-interest can coexist with cooperative goals when it doesn't harm the collective outcome.
'''

description_COOPERATIVE_91 = '''
# Adaptive Threshold Cooperation Strategy (ATCS)

## Core Philosophy
This strategy balances cooperative intent with adaptive learning, aiming to achieve collective success while protecting against exploitation. It starts optimistically but learns from group behavior to maintain efficiency.

## Strategy Components

### 1. Decision Rules

**Primary Cooperation Condition:**
- Cooperate if predicted number of cooperators ≥ m (threshold)
- Defect otherwise

**Cooperation Prediction Model:**
```
predicted_cooperators = base_cooperation_rate × n × confidence_factor
where:
- base_cooperation_rate = observed historical cooperation rate
- confidence_factor = adaptive multiplier based on recent trends
```

### 2. Adaptive Learning System

**Historical Tracking:**
- Track cooperation rate over all previous rounds
- Weight recent rounds more heavily (exponential decay: weight = 0.8^(rounds_ago))
- Monitor cooperation trends (increasing/decreasing/stable)

**Confidence Factor Calculation:**
```
if recent_trend == "increasing":
    confidence_factor = 1.1
elif recent_trend == "stable" and base_cooperation_rate >= m/n:
    confidence_factor = 1.0
elif recent_trend == "decreasing":
    confidence_factor = 0.9
else:
    confidence_factor = 0.85
```

### 3. Edge Case Handling

**First Round:**
- Always cooperate (optimistic start, no data to analyze)

**Early Rounds (rounds 2-3):**
- Cooperate if previous round(s) achieved threshold
- If threshold failed: cooperate with probability max(0.3, m/n)

**Last Round:**
- Cooperate only if predicted_cooperators ≥ m + 1 (account for others potentially defecting)

**Near-Threshold Situations:**
- If predicted_cooperators ≈ m (within ±0.5), add small randomization (20% chance of cooperation even if prediction slightly below m)

### 4. Pseudocode

```python
def decide_action(round_num, history, n, m, k, r):
    # First round - always cooperate
    if round_num == 1:
        return 'C'
    
    # Calculate base cooperation rate from history
    total_cooperators = 0
    weighted_total = 0
    for i, round_data in enumerate(history):
        rounds_ago = len(history) - i
        weight = 0.8 ** (rounds_ago - 1)
        cooperators_in_round = sum(1 for action in round_data if action == 'C')
        total_cooperators += cooperators_in_round * weight
        weighted_total += weight
    
    base_cooperation_rate = total_cooperators / (weighted_total * n)
    
    # Determine trend
    if len(history) >= 3:
        recent_rates = []
        for i in range(max(0, len(history)-3), len(history)):
            rate = sum(1 for action in history[i] if action == 'C') / n
            recent_rates.append(rate)
        
        if recent_rates[-1] > recent_rates[0] + 0.1:
            trend = "increasing"
        elif abs(recent_rates[-1] - recent_rates[0]) <= 0.1:
            trend = "stable"
        else:
            trend = "decreasing"
    else:
        trend = "stable"
    
    # Calculate confidence factor
    if trend == "increasing":
        confidence_factor = 1.1
    elif trend == "stable" and base_cooperation_rate >= m/n:
        confidence_factor = 1.0
    elif trend == "decreasing":
        confidence_factor = 0.9
    else:
        confidence_factor = 0.85
    
    # Predict cooperators
    predicted_cooperators = base_cooperation_rate * n * confidence_factor
    
    # Last round adjustment
    if round_num == r:
        threshold_for_decision = m + 1
    else:
        threshold_for_decision = m
    
    # Main decision
    if predicted_cooperators >= threshold_for_decision:
        return 'C'
    elif abs(predicted_cooperators - m) <= 0.5:
        # Near threshold - add small randomization
        return 'C' if random() < 0.2 else 'D'
    else:
        return 'D'
```

## Strategy Justification

**Cooperative Elements:**
- Starts with optimistic cooperation
- Maintains cooperation when group shows consistent threshold achievement
- Includes randomized cooperation near threshold to help marginal cases

**Adaptive Protection:**
- Learns from group behavior to avoid systematic exploitation
- Adjusts expectations based on observed trends
- Protects against last-round defection cascades

**Efficiency Focus:**
- Only cooperates when threshold is likely to be met
- Avoids wasteful cooperation in clearly failing scenarios
- Balances individual rationality with collective benefit

This strategy should perform well against other cooperative strategies while maintaining resilience against mixed or adversarial opponents.
'''

description_COOPERATIVE_92 = '''
# Cooperative Strategy: "Adaptive Trust Builder"

## Core Philosophy
This strategy prioritizes collective welfare while maintaining resilience against exploitation. It assumes other cooperative strategies will also attempt to build trust and coordinate, while protecting against purely selfish defectors.

## Decision Rules

### Round 1: Initial Cooperation Signal
**Action: COOPERATE**
- Start with cooperation to signal willingness to coordinate
- This establishes a cooperative baseline and encourages reciprocal cooperation

### Rounds 2 to r-1: Adaptive Trust Building

**Primary Rule: Cooperate if cooperation threshold is achievable**

```pseudocode
cooperation_count = count_cooperators_in_previous_round()
my_previous_action = my_action_in_previous_round()

// Check if threshold was met last round
threshold_met_last_round = (cooperation_count >= m)

// Estimate cooperation likelihood this round
estimated_cooperators = estimate_likely_cooperators()

if (estimated_cooperators + 1 >= m):  // +1 includes my cooperation
    return COOPERATE
else if (cooperation_count >= m/2 AND threshold_met_last_round):
    return COOPERATE  // Maintain momentum when progress is being made
else:
    return DEFECT  // Protect against wasted contribution
```

### Round r (Final Round): Conditional Cooperation
```pseudocode
cooperation_count_last_round = count_cooperators_in_round(r-1)
historical_success_rate = count_successful_rounds() / (r-1)

if (cooperation_count_last_round >= m-1 OR historical_success_rate >= 0.6):
    return COOPERATE  // High confidence in achieving threshold
else:
    return DEFECT  // Protect final contribution if low success probability
```

## Estimation Logic

### Estimating Likely Cooperators
```pseudocode
function estimate_likely_cooperators():
    likely_cooperators = 0
    
    for each other_player:
        // Count consistent cooperators
        if (other_player.cooperation_rate > 0.7):
            likely_cooperators += 1
        // Count conditional cooperators showing positive trend
        else if (other_player.cooperated_last_round AND 
                 other_player.recent_cooperation_trend > 0):
            likely_cooperators += 0.7
        // Count players who cooperate when threshold nearly met
        else if (last_round_cooperation_count >= m-2 AND 
                 other_player.cooperated_last_round):
            likely_cooperators += 0.8
    
    return floor(likely_cooperators)
```

## Edge Cases & Special Handling

### Early Rounds (2-3)
- Be more optimistic about cooperation to establish positive momentum
- If Round 1 shows very low cooperation (< m/3), become more conservative but don't abandon cooperation entirely

### Pattern Recognition
- Track individual player patterns to identify:
  - **Consistent cooperators**: Always include in cooperation estimates
  - **Reciprocal cooperators**: Cooperate when they see cooperation
  - **Threshold cooperators**: Only cooperate when threshold is nearly guaranteed
  - **Defectors**: Don't count toward threshold achievement

### Momentum Maintenance
- If threshold was met in previous round with exactly m cooperators, assume similar cooperation level and cooperate
- If threshold consistently achieved over multiple rounds, maintain cooperation even if estimates are slightly pessimistic

## Cooperative Alignment Features

1. **First-mover cooperation**: Signals cooperative intent from the start
2. **Threshold optimization**: Focuses on achieving the minimum needed for collective benefit
3. **Trust building**: Rewards consistent cooperators by continuing to cooperate with them
4. **Forgiveness**: Doesn't permanently punish temporary defection if players return to cooperation
5. **Collective welfare focus**: Prioritizes achieving the threshold over individual payoff maximization

## Robustness Elements

- **Anti-exploitation**: Won't cooperate when threshold is clearly unachievable
- **Final round protection**: Adjusts strategy for end-game scenarios
- **Adaptive learning**: Updates cooperation estimates based on observed behavior patterns

This strategy balances cooperative ideals with practical considerations, aiming to maximize successful threshold achievements while avoiding exploitation by purely selfish strategies.
'''

description_COOPERATIVE_93 = '''
# Cooperative Strategy: "Adaptive Threshold Guardian"

## Core Philosophy
This strategy is built on the principle of **responsible cooperation** - maximizing collective welfare while being resilient to exploitation. It aims to establish and maintain cooperation by being generous initially, responsive to community needs, and forgiving of occasional defections.

## Decision Rules

### Round 1: Unconditional Cooperation
```
Action = COOPERATE
```
Always cooperate in the first round to signal cooperative intent and help establish a cooperative norm.

### Subsequent Rounds: Adaptive Response
```
cooperation_count = count_cooperators_in_previous_round()
cooperation_rate = cooperation_count / n

if cooperation_rate >= (m/n + 0.1):
    # Strong cooperation observed - maintain it
    Action = COOPERATE
    
elif cooperation_rate >= (m-1)/n:
    # Near threshold - be the safety net
    Action = COOPERATE
    
elif cooperation_count == m-1:
    # Exactly one cooperator short - step up
    Action = COOPERATE
    
elif recent_trend_is_improving():
    # Community is recovering - support the trend
    Action = COOPERATE
    
elif my_cooperation_rate > 0.7 AND cooperation_rate < 0.3:
    # I've been generous but community isn't responding
    Action = DEFECT
    
else:
    # Default cooperative stance
    Action = COOPERATE
```

## Key Components

### 1. **Safety Net Principle**
Always cooperate when the cooperation count is exactly m-1 (one short of threshold). This ensures that if others are genuinely trying to cooperate, we provide the crucial final contribution needed for collective success.

### 2. **Trend Analysis**
```pseudocode
recent_trend_is_improving():
    if round <= 3: return true
    
    last_3_rounds = cooperation_counts[-3:]
    return (last_3_rounds[-1] > last_3_rounds[0]) OR 
           (last_3_rounds[-1] >= m-1)
```

### 3. **Generosity Buffer**
Cooperate when cooperation rate is at least 10% above the minimum threshold ratio (m/n + 0.1). This provides stability and prevents fragile equilibria.

### 4. **Exploitation Protection**
Only defect when:
- My personal cooperation rate > 70% (I've been generous)
- Community cooperation rate < 30% (others aren't reciprocating)
- Not in the last few rounds (maintain cooperative reputation)

## Edge Case Handling

### First Round
Always cooperate to establish cooperative intent and signal trustworthiness.

### Last Round
```pseudocode
if round == r:
    if cooperation_count_last_round >= m:
        Action = COOPERATE  // Maintain successful cooperation
    elif cooperation_count_last_round == m-1:
        Action = COOPERATE  // Be the crucial final contributor
    else:
        Action = COOPERATE  // End on a positive note
```
Remain cooperative in the final round to maintain reputation for future tournaments.

### Early Rounds (2-3)
Be extra forgiving and cooperative to help establish positive momentum, even if cooperation rates are initially low.

### Recovery Situations
If cooperation has collapsed but shows signs of recovery, immediately return to cooperation to support the rebuilding effort.

## Strategic Rationale

1. **Collective Welfare Focus**: Prioritizes group success over individual short-term gains
2. **Stability**: The generosity buffer prevents collapse due to minor coordination failures  
3. **Responsiveness**: Adapts to community behavior while maintaining cooperative bias
4. **Resilience**: Protects against exploitation while remaining fundamentally cooperative
5. **Leadership**: Steps up when exactly one more cooperator is needed
6. **Recovery Support**: Encourages return to cooperation after temporary breakdowns

## Expected Behavior
- High cooperation rate (typically 80-90%)
- Strong performance in maintaining threshold when others are trying
- Builds trust through consistent cooperative signaling
- Balances individual protection with collective responsibility
- Creates positive feedback loops that encourage community-wide cooperation

This strategy embodies cooperative values while being strategically sound, making it effective in tournaments against other cooperative and mixed strategies.
'''

description_COOPERATIVE_94 = '''
# Cooperative Strategy: "Graduated Reciprocal Trust Builder"

## Core Philosophy
This strategy prioritizes collective welfare while maintaining robustness against exploitation. It starts with cooperative intent, builds trust through reciprocal cooperation, and uses graduated responses to encourage others toward cooperation.

## Strategy Overview

### Initial Cooperation Phase (Rounds 1-2)
- **Always cooperate** in the first round to signal cooperative intent
- **Always cooperate** in the second round to demonstrate commitment and give others a chance to reciprocate

### Main Decision Rule (Rounds 3 to r-1)
Use a **threshold-based reciprocal system** with forgiveness:

1. **Track cooperation rate**: Calculate the proportion of players who cooperated in the previous round
2. **Cooperation threshold**: Cooperate if the previous round's cooperation rate ≥ (m-1)/n
   - This means cooperate if we were within 1 player of meeting the threshold
3. **Forgiveness mechanism**: If cooperation rate drops below threshold, still cooperate with probability 0.3 to prevent permanent defection cascades

### Final Round Strategy
- **Conditional cooperation**: Cooperate if the cooperation rate in round r-1 was ≥ m/n (threshold was actually met)
- This prevents end-game defection while rewarding sustained cooperation

## Detailed Decision Rules

```pseudocode
function decide_action(round, history):
    if round == 1 or round == 2:
        return COOPERATE
    
    if round == final_round:
        cooperation_rate_last = count_cooperators(history[round-1]) / n
        if cooperation_rate_last >= m/n:
            return COOPERATE
        else:
            return DEFECT
    
    # Main rounds (3 to r-1)
    cooperation_rate_last = count_cooperators(history[round-1]) / n
    threshold = (m-1) / n
    
    if cooperation_rate_last >= threshold:
        return COOPERATE
    else:
        # Forgiveness mechanism
        if random() < 0.3:
            return COOPERATE
        else:
            return DEFECT
```

## Edge Case Handling

### First Round
- Always cooperate to signal cooperative intent and start building trust

### Early Rounds (2-3)
- Maintain cooperation to establish credibility and allow learning about opponents

### Middle Game
- Use graduated response based on group cooperation levels
- Maintain some forgiveness to prevent permanent defection spirals

### Final Round
- Reward sustained cooperation but don't allow exploitation in the last round

### Low Cooperation Scenarios
- When cooperation drops significantly, reduce cooperation frequency but maintain some probability to test for renewed cooperation from others

## Cooperative Alignment

This strategy embodies cooperation through:

1. **Initial Trust**: Starting with cooperation demonstrates good faith
2. **Reciprocity**: Responding positively to group cooperation encourages others
3. **Forgiveness**: The 30% forgiveness probability prevents permanent punishment cycles
4. **Graduated Response**: Using (m-1)/n threshold is more lenient than the actual requirement, encouraging cooperation even when the group is close to success
5. **Collective Focus**: Decision-making based on group behavior rather than individual tracking
6. **Sustainable Cooperation**: Balancing cooperation with protection against systematic exploitation

## Strategic Rationale

- **Builds Trust**: Early cooperation establishes credibility
- **Encourages Reciprocity**: Responds positively to cooperative signals from others
- **Prevents Exploitation**: Reduces cooperation when others consistently defect
- **Maintains Hope**: Forgiveness mechanism allows recovery from defection cycles
- **Tournament Robust**: Works well against other cooperative strategies while having some protection against purely exploitative ones

This strategy should perform well in a tournament of AI strategies, as it encourages mutual cooperation while being resilient enough to avoid complete exploitation.
'''

description_COOPERATIVE_95 = '''
# Cooperative Strategy: "Adaptive Threshold Guardian"

## Core Philosophy
This strategy prioritizes collective welfare while maintaining resilience against exploitation. It assumes other cooperative strategies exist and aims to coordinate with them to consistently meet the cooperation threshold.

## Strategy Description

### Decision Rules

**Primary Rule - Threshold-Aware Cooperation:**
- Always cooperate if recent cooperation rates suggest we're near the threshold
- Maintain cooperation when the group is successfully meeting thresholds
- Only defect temporarily when cooperation levels are unsustainably high and my contribution isn't critical

**Specific Decision Logic:**

```pseudocode
function decide_action(round, history, n, m, k, r):
    if round == 1:
        return COOPERATE  // Start cooperatively
    
    // Calculate recent cooperation trends
    recent_cooperators = count_cooperators_in_last_3_rounds(history)
    avg_recent_cooperation = recent_cooperators / min(3, round-1)
    
    // Threshold proximity analysis
    last_round_cooperators = count_cooperators_in_round(history, round-1)
    threshold_buffer = last_round_cooperators - m
    
    // Cooperation conditions (any true → COOPERATE)
    
    // 1. Threshold at risk
    if last_round_cooperators <= m + 1:
        return COOPERATE
    
    // 2. Declining cooperation trend
    if avg_recent_cooperation < (m + 2) / n:
        return COOPERATE
    
    // 3. Last rounds approaching
    if round > r - 3:
        return COOPERATE  // End-game solidarity
    
    // 4. Conservative cooperation maintenance
    if threshold_buffer <= 2:
        return COOPERATE
    
    // 5. Recovery after defection
    if my_last_action == DEFECT and last_round_cooperators < n * 0.7:
        return COOPERATE
    
    // Only defect if cooperation is very high and stable
    if threshold_buffer >= 3 and avg_recent_cooperation > 0.8:
        return DEFECT  // Brief efficiency break
    
    // Default: cooperate
    return COOPERATE
```

### Edge Case Handling

**First Round:**
- Always cooperate to signal cooperative intent and help establish initial coordination

**Last 3 Rounds:**
- Always cooperate to prevent end-game collapse and ensure collective success

**After Failed Rounds:**
- If threshold wasn't met in previous round, always cooperate to help restore collective success

**High Cooperation Scenarios:**
- Only defect when cooperation is significantly above threshold AND appears stable
- Immediately return to cooperation if my defection might threaten future threshold achievement

### Cooperative Alignment

This strategy embodies cooperation through:

1. **Threshold Protection:** Prioritizes ensuring the group meets the minimum cooperation requirement
2. **Trend Awareness:** Responds to declining cooperation by increasing own cooperation
3. **Conservative Defection:** Only defects when cooperation levels are safely above threshold
4. **Quick Recovery:** Returns to cooperation rapidly after any defection
5. **End-Game Solidarity:** Maintains cooperation in final rounds when others might be tempted to defect

### Key Features

- **Adaptive:** Responds to group cooperation patterns
- **Protective:** Guards against threshold failures
- **Reciprocal:** Matches group cooperation levels
- **Conservative:** Errs on the side of cooperation when uncertain
- **Forward-Looking:** Considers impact on future rounds

This strategy aims to be a reliable cooperative partner that helps maintain collective success while occasionally optimizing efficiency when it's safe to do so. It should coordinate well with other cooperative strategies to consistently achieve the cooperation threshold and maximize group welfare.
'''

description_COOPERATIVE_96 = '''
# Cooperative Strategy: "Optimistic Threshold Guardian"

## Core Philosophy
This strategy prioritizes collective welfare while maintaining resilience against exploitation. It operates on the principle of being a reliable contributor to the collective good while encouraging others to cooperate through positive reinforcement and measured responses to defection.

## Decision Rules

### Round 1: Initial Cooperation
**Always cooperate in the first round.**
- Establishes cooperative intent
- Signals trustworthiness to other players
- Provides baseline data for future decisions

### Subsequent Rounds: Adaptive Cooperation

The strategy uses a **cooperative momentum** approach based on three factors:

1. **Threshold Achievement Rate**: How often the group has met the minimum threshold
2. **Recent Cooperation Trend**: Whether cooperation is increasing, stable, or declining
3. **My Critical Impact**: Whether my cooperation is likely to be pivotal

#### Main Decision Logic:

```pseudocode
FOR round t (where t > 1):
    threshold_rate = (rounds_threshold_met / (t-1))
    recent_cooperators = count_cooperators_last_round()
    cooperation_trend = recent_cooperators - avg_cooperators_previous_rounds()
    
    // Primary cooperative conditions
    IF threshold_rate >= 0.6 OR recent_cooperators >= (m-1):
        COOPERATE
    
    // Encourage emerging cooperation
    ELIF cooperation_trend > 0 AND recent_cooperators >= (m-2):
        COOPERATE
    
    // Last chance cooperation (final 20% of rounds)
    ELIF current_round >= (0.8 * r) AND recent_cooperators >= (m-2):
        COOPERATE
    
    // Recovery attempt after consecutive failures
    ELIF consecutive_failures >= 2 AND recent_cooperators >= (m-3):
        COOPERATE
    
    // Otherwise defect to avoid exploitation
    ELSE:
        DEFECT
```

## Edge Case Handling

### First Round
- **Always cooperate** to establish positive precedent and signal cooperative intent

### Last Round
- **Cooperate if and only if** recent cooperation levels suggest threshold achievement is likely
- Specifically: cooperate if previous round had ≥ (m-1) cooperators

### Early Rounds (rounds 2-3)
- **Maintain optimism**: Cooperate unless previous round had ≤ (m-3) cooperators
- This gives the group time to establish cooperative patterns

### Late Rounds (final 20%)
- **Increase cooperative bias**: Lower the bar for cooperation as remaining opportunities diminish
- Cooperate more readily when close to threshold (≥ m-2 cooperators in previous round)

## Cooperative Features

### 1. Positive Reinforcement
- Rewards group cooperation by continuing to contribute when others do
- Maintains contribution even during marginal threshold achievements

### 2. Forgiveness Mechanism
- After consecutive failures, still attempts cooperation if there's minimal support
- Doesn't permanently write off the group after early disappointments

### 3. Threshold Sensitivity
- Recognizes when the group is close to success and provides the needed push
- Particularly active when cooperation count is at (m-1) or (m-2)

### 4. Momentum Building
- Responds positively to increasing cooperation trends
- Helps convert partial cooperation into sustained collective action

### 5. End-Game Cooperation
- Increases cooperative attempts in final rounds when opportunities are scarce
- Prevents premature abandonment of collective goals

## Risk Management

While primarily cooperative, the strategy includes safeguards:
- **Defects when exploitation is clear**: When cooperation consistently fails despite attempts
- **Learns from patterns**: Adjusts expectations based on group behavior history
- **Preserves resources for viable opportunities**: Doesn't waste contributions when success is highly unlikely

This strategy aims to be the kind of player that makes collective success possible while being intelligent enough to avoid systematic exploitation. It provides consistent support for cooperative equilibria while maintaining enough flexibility to adapt to the actual behavior patterns of opponents.
'''

description_COOPERATIVE_97 = '''
# Cooperative Strategy: "Threshold Guardian with Forgiveness"

## Core Philosophy
This strategy prioritizes achieving the collective threshold while maintaining resilience against occasional defections. It balances cooperative intent with strategic adaptation to ensure the group's success.

## Decision Rules

### Round 1: Always Cooperate
- **Action**: C
- **Rationale**: Establish cooperative intent and contribute to building trust from the start.

### Rounds 2 to r-1: Adaptive Threshold Monitoring
```pseudocode
if round == 2:
    cooperators_last_round = count_cooperators(previous_round)
    if cooperators_last_round >= m:
        action = C  // Success reinforcement
    else:
        action = C  // Give others another chance
else:
    recent_success_rate = calculate_success_rate(last_3_rounds)
    cooperators_last_round = count_cooperators(previous_round)
    
    if recent_success_rate >= 0.67:
        action = C  // Maintain cooperation when group is performing well
    elif cooperators_last_round >= m - 1:
        action = C  // Help maintain threshold when close
    elif cooperators_last_round < m - 2:
        // Group is struggling, but give conditional cooperation
        if has_been_cooperative_recently(last_2_rounds):
            action = C  // Stay committed if I've been cooperating
        else:
            action = C  // Return to cooperation after brief defection
    else:
        action = C  // Default to cooperation
```

### Final Round: Cooperative Finish
- **Action**: C
- **Rationale**: End on a cooperative note regardless of previous outcomes, demonstrating commitment to the collective good.

## Key Components

### 1. Success Rate Calculation
```pseudocode
calculate_success_rate(rounds_to_check):
    successful_rounds = 0
    for each round in last rounds_to_check:
        if cooperators_in_round >= m:
            successful_rounds++
    return successful_rounds / rounds_to_check
```

### 2. Forgiveness Mechanism
- After any period of group failure, immediately return to cooperation
- Don't punish the group for past failures beyond 2-3 rounds
- Always give the collective another chance to succeed

### 3. Threshold Awareness
- Prioritize cooperation when the group is just 1-2 cooperators away from threshold
- Recognize that consistent cooperation near the threshold maximizes collective welfare

## Edge Case Handling

### Small Groups (n close to m)
- Be even more cooperative since each player's contribution is critical
- Rarely defect as the margin for error is minimal

### Large Groups (n >> m)
- Maintain steady cooperation but be more responsive to group performance
- Can afford occasional strategic adjustments without jeopardizing threshold

### High Reward Scenarios (k >> 1)
- Increase cooperation frequency as the collective benefit is substantial
- The high reward justifies taking more personal risk

### Low Reward Scenarios (k ≈ 1)
- Still prioritize cooperation but be more sensitive to persistent free-riding
- Balance personal payoff with collective benefit more carefully

## Strategic Rationale

### Cooperative Alignment
1. **Default Cooperation**: The strategy defaults to cooperation in most situations
2. **Collective Focus**: Decisions prioritize group success over individual gain
3. **Forgiveness**: Doesn't get trapped in punishment cycles that hurt everyone

### Practical Effectiveness
1. **Threshold Sensitivity**: Explicitly monitors and responds to how close the group is to success
2. **Adaptive Learning**: Uses recent performance to inform decisions without being overly reactive
3. **Stability**: Provides predictable cooperation that others can rely on

### Resilience Features
1. **Recovery Oriented**: Quickly returns to cooperation after setbacks
2. **Context Aware**: Adjusts behavior based on group size and reward structure
3. **Endgame Cooperation**: Ensures the strategy ends cooperatively, potentially influencing future interactions

This strategy embodies cooperative values while maintaining enough sophistication to adapt to group dynamics and encourage collective success throughout the tournament.
'''

description_COOPERATIVE_98 = '''
I'll design a cooperative strategy called **"Adaptive Trust Builder"** that balances cooperation with strategic awareness of the collective risk dynamics.

## Strategy: Adaptive Trust Builder

### Core Philosophy
This strategy operates on the principle that cooperation is essential for collective welfare, but it adapts based on the group's demonstrated commitment to cooperation. It prioritizes building and maintaining trust while being resilient to exploitation.

### Decision Rules

#### Round 1: Always Cooperate
- **Action**: C (Cooperate)
- **Rationale**: Establish cooperative intent from the start and give others the benefit of the doubt

#### Rounds 2 to r-1: Adaptive Cooperation
```pseudocode
Define cooperation_rate = (number of cooperators in previous round) / n
Define trust_threshold = m / n  // Minimum viable cooperation rate

IF cooperation_rate >= trust_threshold:
    Action = C  // Reward group cooperation
ELSE IF cooperation_rate >= (trust_threshold * 0.75):
    Action = C  // Give benefit of doubt when close to threshold
ELSE:
    // Check if my cooperation could inspire others
    IF (number of cooperators in previous round) == (m - 1):
        Action = C  // Be the crucial cooperator
    ELSE:
        Action = D  // Protect against consistent under-cooperation
```

#### Final Round (r): Conditional Cooperation
```pseudocode
// In the final round, consider the established pattern
recent_cooperation_rate = average cooperation rate over last 3 rounds (or all rounds if r < 4)

IF recent_cooperation_rate >= trust_threshold:
    Action = C  // Maintain cooperation to the end
ELSE IF recent_cooperation_rate >= (trust_threshold * 0.5):
    Action = C  // Give final chance for collective success
ELSE:
    Action = D  // Cut losses if group consistently fails
```

### Edge Case Handling

1. **Very Small Groups (n ≤ 3)**: Always cooperate except in final round if cooperation has completely broken down
2. **High Threshold Games (m close to n)**: More lenient with trust_threshold calculations - use (m/n * 0.8) as threshold
3. **Memory of Success**: If threshold was met in previous round, increase likelihood of cooperation even if current indicators are mixed

### Cooperative Alignment Features

1. **Default to Cooperation**: The strategy errs on the side of cooperation when uncertain
2. **Forgiveness**: It doesn't permanently punish defectors but responds to improved group behavior
3. **Leadership**: Willing to be the crucial m-th cooperator even when risky
4. **Trust Building**: Consistent early cooperation to establish positive group dynamics
5. **End-game Cooperation**: Unlike purely selfish strategies, maintains cooperation in final rounds when the group has been trustworthy

### Strategic Rationale

This strategy recognizes that:
- Mutual cooperation (everyone playing C) yields the highest collective payoff
- The collective risk requires at least m cooperators for anyone to benefit from the risk-averted reward
- Being the crucial cooperator can inspire others and ensure collective success
- Early cooperation signals good intent and can establish positive norms
- Some protection against exploitation is necessary but shouldn't override cooperative goals

The strategy is designed to work well in tournaments where other cooperative-minded strategies are present, while still being reasonably robust against more exploitative approaches.
'''

description_COOPERATIVE_99 = '''
# Cooperative Strategy: "Threshold Guardian with Forgiveness"

## Core Philosophy
This strategy prioritizes collective welfare while maintaining resilience against exploitation. It operates on the principle of "conditional cooperation" - cooperating when there's reasonable expectation others will too, but with built-in forgiveness to recover from coordination failures.

## Strategy Components

### 1. Decision Rules

**Primary Rule: Adaptive Threshold Tracking**
- **Cooperate** if recent cooperation levels suggest the threshold `m` is likely to be met
- **Defect** only when cooperation appears futile or when being exploited consistently

**Specific Logic:**
```pseudocode
For round t:
  if t == 1:
    return COOPERATE  // Always start cooperatively
  
  recent_coop_rate = cooperation_rate_in_last_3_rounds()
  expected_cooperators = recent_coop_rate * (n-1) + 1  // +1 for my cooperation
  
  if expected_cooperators >= m:
    return COOPERATE
  elif expected_cooperators >= m-1 AND my_recent_exploitation_count < 2:
    return COOPERATE  // Give benefit of doubt when close to threshold
  else:
    return DEFECT
```

### 2. Edge Case Handling

**First Round (t=1):**
- Always COOPERATE to signal cooperative intent and attempt to establish good equilibrium

**Last Round (t=r):**
- Continue normal strategy logic - don't defect just because it's the last round
- Maintain cooperation if threshold is likely to be met

**Early Rounds (t=2 to min(4,r)):**
- Be optimistic: cooperate if at least `m-1` players cooperated in previous round
- This helps establish cooperative patterns early

**When Threshold Repeatedly Missed:**
- If threshold missed for 3+ consecutive rounds: temporarily switch to "punishment mode"
- In punishment mode: defect for 1 round, then return to normal logic
- This signals that cooperation is necessary

### 3. Cooperative Alignment Features

**Forgiveness Mechanism:**
- After any defection period, immediately return to cooperation testing
- Don't hold grudges - focus on future cooperation potential

**Threshold Sensitivity:**
- Always consider that your cooperation might be the pivotal one
- When `expected_cooperators = m-1`, strongly lean toward cooperating

**Recovery Protocol:**
- If cooperation breaks down, actively attempt to restart it
- Signal renewed cooperation attempt after punishment phases

## Detailed Implementation

```pseudocode
initialize:
  cooperation_history = []
  my_action_history = []
  punishment_rounds_left = 0

function decide_action(round, history):
  if round == 1:
    return COOPERATE
  
  if punishment_rounds_left > 0:
    punishment_rounds_left -= 1
    return DEFECT
  
  // Analyze recent cooperation patterns
  recent_window = min(3, round-1)
  total_recent_cooperators = 0
  
  for each of last recent_window rounds:
    total_recent_cooperators += count_cooperators_in_round(round)
  
  avg_cooperators = total_recent_cooperators / recent_window
  
  // Check if I'm being exploited
  my_recent_cooperations = count_my_cooperations_in_last_3_rounds()
  times_threshold_missed_when_i_cooperated = count_exploitation()
  
  // Decision logic
  if avg_cooperators >= m:
    return COOPERATE
  elif avg_cooperators >= m-1:
    if times_threshold_missed_when_i_cooperated < 2:
      return COOPERATE  // Give benefit of doubt
    else:
      return DEFECT     // Avoid repeated exploitation
  elif consecutive_failures() >= 3:
    punishment_rounds_left = 1  // Punish for 1 round
    return DEFECT
  else:
    return COOPERATE    // Default to cooperation
```

## Key Strengths

1. **Genuinely Cooperative**: Defaults to cooperation and actively seeks to establish it
2. **Threshold-Aware**: Explicitly considers the `m` parameter in decisions
3. **Adaptive**: Responds to changing cooperation levels
4. **Forgiving**: Doesn't get stuck in defection cycles
5. **Exploitation-Resistant**: Has mechanisms to avoid being a "sucker"

This strategy aims to maximize collective payoffs while being robust enough to perform well even against some non-cooperative opponents. It prioritizes achieving the threshold `m` consistently across rounds rather than maximizing individual short-term gains.
'''

description_COOPERATIVE_100 = '''
# Cooperative Strategy: "Adaptive Threshold Guardian"

## Core Philosophy
This strategy prioritizes collective welfare while maintaining resilience against exploitation. It aims to establish and maintain cooperation by being conditionally cooperative—starting optimistically but adapting based on observed group behavior.

## Decision Rules

### Round 1: Optimistic Start
**Action: COOPERATE**
- Begin with cooperation to signal willingness to work toward collective benefit
- Establish a cooperative precedent for other players to follow

### Rounds 2 to r-1: Adaptive Cooperation
**Primary Rule: Cooperate if the cooperation threshold can realistically be met**

```pseudocode
cooperation_history = track_cooperation_counts_per_round()
recent_cooperation = average_cooperation_last_3_rounds()
trend = calculate_cooperation_trend()

IF recent_cooperation >= (m/n) THEN
    action = COOPERATE
ELSE IF recent_cooperation >= (m-1)/n AND trend >= 0 THEN
    action = COOPERATE  // Give benefit of doubt if close to threshold
ELSE IF count_consistent_cooperators() >= m-1 THEN
    action = COOPERATE  // Enough reliable cooperators identified
ELSE
    // Strategic defection to signal dissatisfaction
    action = DEFECT
END IF
```

### Final Round (r): Commitment to Cooperation
**Action: COOPERATE**
- Maintain cooperative stance even in the final round
- Demonstrates genuine commitment to collective welfare
- Avoids the typical "end-game defection" that undermines cooperation

## Key Strategic Elements

### 1. Threshold Awareness
- Monitor whether cooperation levels are sustainable (near m/n ratio)
- Recognize that being the (m+1)th cooperator still provides net positive group benefit

### 2. Forgiveness Mechanism
- Don't permanently defect after encountering defection
- Allow for recovery if cooperation levels improve
- Use 3-round moving average to smooth out temporary fluctuations

### 3. Consistent Cooperator Recognition
- Track players who consistently cooperate across rounds
- If (m-1) players are reliable cooperators, continue cooperating to ensure threshold is met

### 4. Strategic Signaling
- Temporary defection serves as a signal when cooperation is failing
- Return to cooperation quickly when group shows improvement

## Edge Case Handling

### Small Group Dynamics (n close to m)
- Be more lenient with cooperation thresholds since each player is more critical
- Weight individual player consistency more heavily

### Large Group Dynamics (n >> m)
- Focus more on aggregate trends rather than individual player tracking
- Be willing to cooperate even if some players are unreliable

### Recovery Situations
- If cooperation has failed for multiple rounds but shows signs of recovery, return to cooperation immediately
- Don't hold grudges that prevent beneficial cooperation

## Cooperative Alignment

This strategy embodies cooperation by:

1. **Default Cooperation**: Starting and ending with cooperation
2. **Collective Focus**: Prioritizing group welfare over individual gain
3. **Constructive Response**: Using defection strategically to encourage cooperation, not to exploit
4. **Forgiveness**: Allowing for recovery and not permanently punishing past defection
5. **Reliability**: Being predictably cooperative when conditions allow

## Expected Behavior

Against other cooperative strategies, this approach should:
- Quickly establish stable cooperation
- Maintain high cooperation rates throughout the game
- Maximize collective payoffs while remaining resilient to occasional defection

The strategy balances being "nice" (cooperative by default) with being "retaliatory" (responding to sustained non-cooperation) and "forgiving" (returning to cooperation when possible), following principles that have proven effective in repeated games.
'''

description_COOPERATIVE_101 = '''
# Cooperative Strategy: "Adaptive Trust Builder"

## Core Philosophy
This strategy operates on the principle that achieving the threshold `m` is beneficial for all players, and focuses on building trust while being resilient to moderate defection. It balances cooperative intent with adaptive response to group behavior.

## Decision Rules

### Round 1: Trust Initialization
- **Always cooperate** in the first round
- This signals cooperative intent and helps establish initial trust

### Rounds 2 to r-1: Adaptive Cooperation
Use a three-tier decision system based on cooperation history:

1. **High Trust Regime** (≥ 80% historical cooperation rate):
   - Cooperate unconditionally
   - Maintain momentum when group is highly cooperative

2. **Medium Trust Regime** (50-79% historical cooperation rate):
   - Cooperate if the number of cooperators in the previous round was ≥ m-1
   - This helps maintain threshold while being slightly cautious

3. **Low Trust Regime** (< 50% historical cooperation rate):
   - Cooperate only if the number of cooperators in the previous round was ≥ m
   - More conservative approach when trust is low, but still supports successful cooperation

### Final Round: Conditional Cooperation
- If historical cooperation rate ≥ 60%: Cooperate
- Otherwise: Defect (since there's no future to build trust for)

## Pseudocode

```python
def decide_action(round_num, history, n, m, r):
    if round_num == 1:
        return COOPERATE
    
    if round_num == r:  # Final round
        cooperation_rate = calculate_historical_cooperation_rate(history)
        return COOPERATE if cooperation_rate >= 0.6 else DEFECT
    
    # Calculate historical cooperation rate
    cooperation_rate = calculate_historical_cooperation_rate(history)
    last_round_cooperators = count_cooperators(history[-1])
    
    if cooperation_rate >= 0.8:
        # High trust: always cooperate
        return COOPERATE
    elif cooperation_rate >= 0.5:
        # Medium trust: cooperate if close to threshold
        return COOPERATE if last_round_cooperators >= m-1 else DEFECT
    else:
        # Low trust: cooperate only if threshold was met
        return COOPERATE if last_round_cooperators >= m else DEFECT

def calculate_historical_cooperation_rate(history):
    total_decisions = sum(len(round_actions) for round_actions in history)
    total_cooperations = sum(round_actions.count(COOPERATE) for round_actions in history)
    return total_cooperations / total_decisions if total_decisions > 0 else 0
```

## Key Features

### 1. **Trust-Building Focus**
- Always starts cooperatively to signal good intentions
- Rewards group cooperation with continued cooperation
- Uses historical patterns rather than just last-round reactions

### 2. **Threshold Awareness**
- Decision rules explicitly consider the minimum threshold `m`
- In medium trust, helps groups that are "almost there" (m-1 cooperators)
- In low trust, still supports groups that achieve the threshold

### 3. **Adaptive Resilience**
- Doesn't abandon cooperation immediately after defection
- Uses percentage-based thresholds to handle different group sizes
- Becomes more selective only when cooperation consistently fails

### 4. **End-Game Consideration**
- Recognizes that final round has different incentives
- Still cooperates in final round if group has shown reasonable cooperation
- Prevents exploitation while maintaining cooperative reputation

## Edge Cases Handled

- **First Round**: Always cooperate (trust initialization)
- **All Others Defect**: Will eventually switch to low-trust regime but still supports successful cooperation attempts
- **Fluctuating Behavior**: Uses historical averages to avoid overreacting to single-round variations
- **Near-Threshold Situations**: Specifically helps groups with m-1 cooperators in medium trust regime
- **Final Round**: Balances cooperation with protection against end-game defection

This strategy maintains a fundamentally cooperative stance while being intelligent about when that cooperation is most likely to be reciprocated and achieve the beneficial threshold for all players.
'''

description_COOPERATIVE_102 = '''
# Cooperative Strategy: "Adaptive Threshold Guardian"

## Core Philosophy
This strategy prioritizes collective welfare while maintaining resilience against exploitation. It aims to establish and maintain cooperation by being generous initially, responsive to group dynamics, and protective of the collective good.

## Decision Rules

### Round 1: Generous Opening
**Always cooperate** in the first round to signal cooperative intent and help establish a positive dynamic.

### Rounds 2 through r-1: Adaptive Response
```pseudocode
cooperators_last_round = count_cooperators_in_previous_round()
cooperation_rate = cooperators_last_round / n

IF cooperation_rate >= (m / n):
    # Threshold was met - reinforce cooperation
    COOPERATE
ELSE IF cooperation_rate >= 0.6:
    # Close to threshold - be supportive
    COOPERATE
ELSE IF cooperators_last_round == (m - 1):
    # One short of threshold - step up to help
    COOPERATE
ELSE IF cooperation_rate < 0.3:
    # Very low cooperation - conditional cooperation
    IF (cooperators_last_round > 0):
        COOPERATE  # Support remaining cooperators
    ELSE:
        DEFECT     # Don't cooperate alone
ELSE:
    # Moderate cooperation level - encourage growth
    COOPERATE
```

### Final Round (Round r): Committed Cooperation
**Always cooperate** in the final round, regardless of history. This demonstrates commitment to the cooperative ideal even when there's no future retaliation possible.

## Key Features

### 1. Threshold Awareness
- Prioritizes meeting the minimum threshold (m) for collective benefit
- Steps up when the group is exactly one cooperator short of the threshold
- Recognizes that meeting the threshold benefits everyone, including defectors

### 2. Generous Forgiveness
- Doesn't punish individual defections harshly
- Focuses on group cooperation rates rather than tracking individual players
- Gives groups multiple chances to establish cooperation

### 3. Support for Struggling Cooperation
- Continues cooperating even when cooperation rates are low (but not zero)
- Only defects when facing complete non-cooperation from all other players
- Acts as a "cooperation anchor" to prevent total collapse

### 4. Bookend Commitment
- Starts and ends with cooperation to signal consistent cooperative values
- The final round cooperation demonstrates that the strategy is genuinely cooperative, not just strategically cooperative

## Handling Edge Cases

### Very Small Groups (n close to m)
When n is close to m (e.g., n=3, m=2), the strategy becomes more cautious about defection since each player's cooperation is more critical.

### High Threshold Games (m close to n)
In games where most players must cooperate, the strategy becomes more persistently cooperative since the threshold is harder to achieve.

### Complete Defection Scenarios
If all other players defect for multiple consecutive rounds, the strategy will eventually defect to avoid being exploited, but will immediately return to cooperation if any other player shows cooperative intent.

## Strategic Rationale

This strategy balances several cooperative principles:

1. **Collective Optimization**: Prioritizes achieving the threshold for maximum group welfare
2. **Robustness**: Doesn't collapse easily under temporary setbacks
3. **Encouragement**: Provides positive reinforcement for cooperative behavior
4. **Principled Stance**: Maintains cooperative values even in the final round
5. **Adaptive Support**: Adjusts support level based on group needs while maintaining cooperative intent

The strategy recognizes that in a Collective Risk Dilemma, the key insight is that everyone benefits when the threshold is met, making it rational to support cooperation even when some players defect. By focusing on group-level cooperation rates rather than individual punishment, it aims to foster an environment where cooperation can flourish.
'''

description_COOPERATIVE_103 = '''
# Cooperative Strategy: "Graduated Trust Builder"

## Core Philosophy
This strategy is designed to maximize collective welfare while being robust against various opponent behaviors. It assumes that other cooperative LLMs will recognize and reciprocate cooperative signals, while also protecting against exploitation.

## Strategy Overview

**Name:** Graduated Trust Builder (GTB)

**Principle:** Start cooperatively, adapt based on collective behavior, and maintain cooperation when the community demonstrates commitment to the common good.

## Decision Rules

### Phase 1: Trust Building (Rounds 1 to ⌊r/3⌋)
- **Always Cooperate** regardless of others' actions
- **Rationale:** Establish credibility as a cooperative player and signal commitment to collective welfare

### Phase 2: Adaptive Cooperation (Rounds ⌊r/3⌋+1 to r-2)
- **Cooperate if:** Number of cooperators in the previous round ≥ (m-1)
- **Defect if:** Number of cooperators in the previous round < (m-1)
- **Rationale:** Maintain cooperation when we're close to or above threshold, but conserve resources when cooperation is failing

### Phase 3: Endgame Commitment (Last 2 rounds)
- **Cooperate if:** Average cooperation rate over all previous rounds ≥ m/n
- **Defect otherwise**
- **Rationale:** Make a final push for cooperation if the group has shown sufficient collective commitment

## Detailed Pseudocode

```
function decide_action(round_number, history_of_all_actions):
    total_rounds = r
    threshold = m
    
    // Phase 1: Trust Building
    if round_number <= floor(total_rounds / 3):
        return COOPERATE
    
    // Phase 3: Endgame Commitment  
    if round_number > total_rounds - 2:
        avg_cooperation_rate = calculate_average_cooperation_rate(history_of_all_actions)
        if avg_cooperation_rate >= threshold / n:
            return COOPERATE
        else:
            return DEFECT
    
    // Phase 2: Adaptive Cooperation
    cooperators_last_round = count_cooperators(history_of_all_actions, round_number - 1)
    if cooperators_last_round >= threshold - 1:
        return COOPERATE
    else:
        return DEFECT

function calculate_average_cooperation_rate(history):
    total_cooperation_decisions = 0
    total_decisions = 0
    
    for each round in history:
        total_cooperation_decisions += count_cooperators_in_round(round)
        total_decisions += n
    
    return total_cooperation_decisions / total_decisions
```

## Edge Case Handling

### First Round
- Always cooperate to signal cooperative intent and establish trust

### Last Round
- Cooperate if the group has demonstrated sufficient collective commitment (≥ m/n cooperation rate)
- This prevents the typical "last round defection" while still being rational

### When Exactly m-1 Players Cooperated Last Round
- Still cooperate, as we need exactly one more to reach threshold
- This shows commitment to achieving the collective goal

### When All Players Defected in Previous Round
- In Phase 1: Still cooperate (trust building)
- In Phase 2: Defect (adaptive response)
- In Phase 3: Depends on historical cooperation rate

## Cooperative Alignment

This strategy embodies cooperation through:

1. **Initial Trust:** Unconditional cooperation in early rounds builds trust and signals cooperative intent
2. **Collective Optimization:** Responds positively when the group shows willingness to cooperate
3. **Forgiveness:** Doesn't permanently punish defection if cooperation can be restored
4. **Commitment:** Willing to cooperate in final rounds if the group has shown collective commitment
5. **Risk Mitigation:** Only defects when cooperation is clearly failing, preserving resources for when cooperation can be effective

## Expected Performance

- **Against other cooperative strategies:** High mutual cooperation leading to near-optimal outcomes
- **Against mixed strategies:** Adapts to maintain cooperation when viable
- **Against highly exploitative strategies:** Protects against exploitation while still attempting to build cooperation
- **Tournament performance:** Should perform well against other LLM-generated strategies that likely also have cooperative elements

This strategy balances idealistic cooperation with pragmatic adaptation, making it robust for a tournament setting while maintaining a fundamentally cooperative approach.
'''

description_COOPERATIVE_104 = '''
# Cooperative Strategy: "Adaptive Trust Builder"

## Core Philosophy
This strategy prioritizes collective welfare while being adaptive to the group's cooperative tendencies. It starts with trust, rewards cooperation, and maintains hope for collective success even when facing setbacks.

## Decision Rules

### Round 1: Optimistic Start
- **Always cooperate** in the first round
- Rationale: Establish cooperative intent and give the group the best chance to reach threshold m

### Rounds 2 to r-1: Adaptive Cooperation
Use a dynamic threshold based on recent cooperation levels:

```pseudocode
cooperators_last_round = count(C actions in previous round)
cooperation_rate = cooperators_last_round / n

if cooperation_rate >= 0.7:
    // High cooperation - maintain momentum
    action = C
else if cooperation_rate >= (m/n):
    // Threshold met but not strongly - encourage more
    action = C
else if cooperation_rate >= 0.3:
    // Moderate cooperation - conditional support
    if (cooperators_last_round >= m-1):
        action = C  // One more cooperator might tip the balance
    else:
        action = C with probability 0.7  // Mostly cooperate but hedge
else:
    // Low cooperation - still try to rebuild
    action = C with probability 0.4  // Maintain some cooperative pressure
```

### Final Round (Round r): Hope Keeper
- **Always cooperate** in the final round
- Rationale: Even if cooperation has been low, give one final chance for collective success and end on a cooperative note

## Key Features

### 1. Momentum Recognition
- When cooperation is high (≥70%), fully commit to maintaining the positive dynamic
- When threshold is consistently met, continue supporting the successful pattern

### 2. Threshold Sensitivity
- Pay special attention when we're one cooperator short of threshold (m-1)
- Increase cooperation probability in these critical moments

### 3. Resilient Hope
- Even with low cooperation, maintain 40% cooperation rate to:
  - Keep alive the possibility of threshold achievement
  - Signal continued willingness to cooperate
  - Potentially inspire others to return to cooperation

### 4. Probabilistic Flexibility
- Use probabilistic cooperation in uncertain situations
- Balances risk management with cooperative intent

## Edge Case Handling

### First Round
- Pure cooperation to establish positive tone

### Last Round  
- Pure cooperation to maximize final collective outcome

### All Defection Scenarios
- Still cooperate with 40% probability to be the "first mover" back to cooperation

### All Cooperation Scenarios
- Continue full cooperation to maintain the optimal outcome

## Cooperative Alignment

This strategy embodies cooperation by:

1. **Starting with trust** - Opens with cooperation
2. **Rewarding group cooperation** - Increases cooperation when others do
3. **Never giving up entirely** - Always maintains some cooperation probability
4. **Ending with hope** - Final round cooperation regardless of history
5. **Being threshold-aware** - Specifically tries to help achieve the minimum needed cooperation

The strategy balances idealistic cooperation with pragmatic adaptation, always leaning toward the collective good while being responsive to the group's cooperative climate.
'''

description_COOPERATIVE_105 = '''
I'll design a cooperative strategy called **"Adaptive Threshold Cooperation"** that balances cooperative intent with strategic awareness of the collective risk dynamics.

## Strategy: Adaptive Threshold Cooperation

### Core Philosophy
This strategy prioritizes collective welfare while adapting to opponent behavior patterns. It assumes other players are rational and will eventually recognize the mutual benefits of cooperation, but includes safeguards against exploitation.

### Decision Rules

#### Round 1: Always Cooperate
- **Action**: C
- **Rationale**: Signal cooperative intent and establish positive precedent

#### Rounds 2 to r-1: Adaptive Cooperation
For each round t (where 2 ≤ t ≤ r-1):

1. **Calculate cooperation trend**:
   ```
   recent_coop_rate = (cooperators in last 2 rounds) / (2 × n)
   historical_coop_rate = (total cooperators in rounds 1 to t-1) / ((t-1) × n)
   ```

2. **Determine threshold proximity**:
   ```
   avg_cooperators_last_round = cooperators in round t-1
   threshold_gap = m - avg_cooperators_last_round
   ```

3. **Decision logic**:
   ```
   IF recent_coop_rate ≥ 0.4 OR historical_coop_rate ≥ 0.35:
       Action = C  // Maintain cooperation in encouraging environment
   
   ELSE IF threshold_gap ≤ 2 AND historical_coop_rate ≥ 0.2:
       Action = C  // Critical support when close to threshold
   
   ELSE IF historical_coop_rate < 0.15 AND recent_coop_rate < 0.2:
       Action = D  // Protect against persistent free-riding
   
   ELSE:
       Action = C  // Default to cooperation (cooperative bias)
   ```

#### Final Round r: Conditional Cooperation
```
IF historical_coop_rate ≥ 0.25:
    Action = C  // Reward overall cooperative behavior
ELSE IF cooperators_in_round_(r-1) ≥ (m-1):
    Action = C  // Provide critical support if close to threshold
ELSE:
    Action = D  // No future rounds to recover from exploitation
```

### Key Features

1. **Cooperative Bias**: Defaults to cooperation unless strong evidence suggests it's counterproductive
2. **Threshold Awareness**: Prioritizes cooperation when the group is close to the minimum threshold
3. **Adaptive Learning**: Adjusts based on both recent trends and long-term patterns
4. **Exploitation Protection**: Reduces cooperation when facing persistent free-riding
5. **Endgame Consideration**: Slightly more cautious in final round while still supporting viable cooperation

### Pseudocode Summary

```python
def adaptive_threshold_cooperation(round_num, history, n, m, k, r):
    if round_num == 1:
        return "C"
    
    # Calculate cooperation metrics
    recent_rate = calculate_recent_cooperation_rate(history, 2)
    historical_rate = calculate_historical_cooperation_rate(history)
    last_round_cooperators = count_cooperators(history[-1])
    threshold_gap = m - last_round_cooperators
    
    # Final round logic
    if round_num == r:
        if historical_rate >= 0.25 or last_round_cooperators >= (m-1):
            return "C"
        else:
            return "D"
    
    # Main decision logic
    if (recent_rate >= 0.4 or historical_rate >= 0.35 or 
        (threshold_gap <= 2 and historical_rate >= 0.2)):
        return "C"
    elif historical_rate < 0.15 and recent_rate < 0.2:
        return "D"
    else:
        return "C"  # Cooperative default
```

This strategy maintains a strong cooperative orientation while being responsive to the strategic realities of the collective risk dilemma. It should perform well against other cooperative strategies while having reasonable protection against exploitation.
'''

description_COOPERATIVE_106 = '''
Looking at this Collective Risk Dilemma, I need to design a strategy that maximizes cooperation while being resilient against exploitation. Here's my cooperative strategy:

## **Adaptive Threshold Cooperation with Forgiveness (ATCF)**

### Core Philosophy
This strategy aims to achieve and maintain the cooperation threshold `m` while being forgiving enough to recover from temporary defections and robust against free-riders.

### Decision Rules

**Round 1:** Always cooperate (C)
- Start with good faith cooperation to signal cooperative intent
- Helps establish initial cooperative momentum

**Rounds 2 to r-1:** Conditional cooperation based on recent history
```pseudocode
cooperators_last_round = count_cooperators(previous_round)
cooperators_trend = average_cooperators(last_3_rounds_or_all_if_fewer)

IF cooperators_last_round >= m:
    // Threshold met - high cooperation mode
    IF cooperators_trend >= m + 1:
        play C  // Stable cooperation, maintain it
    ELSE:
        play C with probability 0.9  // Slight randomization to test commitment
        
ELSE IF cooperators_last_round >= m - 1:
    // Close to threshold - encourage cooperation
    play C
    
ELSE IF cooperators_last_round >= max(2, m/2):
    // Some cooperation exists - conditional support
    IF my_cooperation_rate > 0.6:
        play C  // I've been cooperative, give another chance
    ELSE:
        play D  // I haven't been cooperative enough, need to contribute
        
ELSE:
    // Very low cooperation - tit-for-tat with forgiveness
    IF cooperators_last_round > 0:
        play C with probability 0.3  // Small chance to restart cooperation
    ELSE:
        play D  // Full defection round, match it
```

**Final Round (r):** Generous cooperation
```pseudocode
cooperators_recent = average_cooperators(last_min(3,r-1)_rounds)

IF cooperators_recent >= m - 0.5:
    play C  // Game showed cooperative potential
ELSE IF cooperators_recent >= 1:
    play C with probability 0.4  // Give final chance
ELSE:
    play D  // Game was mostly non-cooperative
```

### Key Features

1. **Threshold Awareness:** Always considers how close the group is to the critical threshold `m`

2. **Trend Analysis:** Looks at recent cooperation patterns, not just the last round, to avoid overreacting to single-round fluctuations

3. **Graduated Response:** Different cooperation probabilities based on the cooperation level observed

4. **Self-Monitoring:** Tracks own cooperation rate to avoid being overly exploitative

5. **Forgiveness Mechanism:** Even after defection rounds, maintains small probability of cooperation to allow recovery

6. **Final Round Generosity:** Slightly more cooperative in the final round to end on a positive note and signal long-term cooperative intent

### Edge Case Handling

- **All players always defect:** After several rounds of zero cooperation, matches with defection but maintains 5% cooperation probability to test for change
- **Exact threshold scenarios:** When exactly `m` players cooperated, stays cooperative to maintain the successful equilibrium
- **High variance rounds:** Uses 3-round moving average to smooth out temporary fluctuations
- **Small group scenarios:** Adapts thresholds proportionally (e.g., uses `max(2, m/2)` as minimum cooperation level)

### Cooperative Alignment

This strategy is fundamentally cooperative because it:
- Always starts with cooperation
- Actively tries to achieve and maintain the threshold
- Forgives temporary defections
- Uses probabilistic cooperation to give second chances
- Ends generously to signal long-term cooperative intent
- Prioritizes group success over individual payoff maximization

The strategy balances being cooperative with not being exploitable, making it suitable for a tournament environment while maintaining strong cooperative principles.
'''

description_COOPERATIVE_107 = '''
# Cooperative Strategy: "Conditional Threshold Cooperation"

## Core Philosophy
This strategy is built on the principle that cooperation is essential for collective welfare, but should be adaptive to maximize both group success and individual sustainability. The strategy aims to ensure the threshold is met while being forgiving of occasional defections and protective against systematic exploitation.

## Decision Rules

### Primary Decision Logic
```pseudocode
function decide_action(round, history, n, m, k, r):
    if round == 1:
        return COOPERATE
    
    cooperators_last_round = count_cooperators(history[round-1])
    total_cooperators_so_far = sum_cooperators(history)
    
    # Calculate cooperation rate
    cooperation_rate = total_cooperators_so_far / ((round-1) * n)
    
    # Adaptive threshold strategy
    if cooperation_rate >= 0.6:
        return COOPERATE
    elif cooperation_rate >= 0.4:
        return conditional_cooperate(round, history, n, m)
    else:
        return defensive_cooperate(round, history, n, m, r)
```

### Conditional Cooperation Function
```pseudocode
function conditional_cooperate(round, history, n, m):
    cooperators_last_round = count_cooperators(history[round-1])
    
    # If threshold was met last round, continue cooperating
    if cooperators_last_round >= m:
        return COOPERATE
    
    # If close to threshold, cooperate to help achieve it
    if cooperators_last_round >= (m - 2):
        return COOPERATE
    
    # Otherwise, cooperate with probability based on recent cooperation
    recent_cooperation = avg_cooperation_last_3_rounds(history)
    if recent_cooperation >= (m / n):
        return COOPERATE
    else:
        return DEFECT
```

### Defensive Cooperation Function
```pseudocode
function defensive_cooperate(round, history, n, m, r):
    cooperators_last_round = count_cooperators(history[round-1])
    
    # Always cooperate if we're very close to threshold
    if cooperators_last_round >= (m - 1):
        return COOPERATE
    
    # In later rounds, be more conservative
    if round > (r * 0.7):
        if cooperators_last_round >= (m - 2):
            return COOPERATE
        else:
            return DEFECT
    
    # Early/mid game: cooperate if there's reasonable participation
    if cooperators_last_round >= (m / 2):
        return COOPERATE
    else:
        return DEFECT
```

## Edge Case Handling

### First Round
- **Always COOPERATE**: Establish cooperative intent and signal willingness to contribute to collective welfare.

### Last Round
- **Conditional COOPERATE**: Cooperate if cooperation rate in previous rounds suggests threshold can be met, otherwise defect to maximize individual payoff.

### Near-Threshold Situations
- If exactly m-1 players cooperated last round: **COOPERATE** (be the pivotal player)
- If exactly m players cooperated last round: **COOPERATE** (maintain successful threshold)

### Low Cooperation Environment
- If average cooperation rate falls below 30%: Switch to more defensive mode
- Still cooperate when close to threshold to salvage collective benefit
- Defect when cooperation seems futile to preserve individual payoff

## Cooperative Alignment Features

1. **Threshold Sensitivity**: Prioritizes achieving the minimum threshold m over pure individual optimization

2. **Forgiveness**: Doesn't punish occasional defections if overall cooperation trend is positive

3. **Leadership**: Willing to cooperate even when others might defect, especially when close to threshold

4. **Adaptation**: Adjusts cooperation level based on observed group behavior while maintaining cooperative bias

5. **Collective Welfare Focus**: Designed to maximize total group payoff rather than just individual payoff

## Strategic Rationale

This strategy balances several key considerations:
- **Collective Benefit**: Prioritizes achieving thresholds for group rewards
- **Sustainability**: Protects against systematic exploitation
- **Adaptability**: Responds to varying levels of cooperation in the group
- **Signal Clarity**: Sends clear cooperative signals while maintaining strategic flexibility

The strategy is inherently cooperative as it:
- Starts with cooperation
- Maintains high cooperation rates when others reciprocate
- Continues cooperating even in mixed environments when threshold achievement is possible
- Only becomes defensive when cooperation levels are unsustainably low

This approach should perform well against other cooperative strategies while maintaining resilience against purely exploitative approaches.
'''

description_COOPERATIVE_108 = '''
# Cooperative Strategy: "Adaptive Trust Builder"

## Core Philosophy
This strategy prioritizes collective welfare while being resilient to exploitation. It starts with trust, adapts to group behavior, and maintains cooperative momentum even when facing some defectors.

## Decision Rules

### Round 1: Cooperative Opening
- **Always cooperate** in the first round
- Rationale: Signal cooperative intent and give the group the best chance to establish a pattern of mutual cooperation

### Rounds 2 to r-1: Adaptive Cooperation
Use a **threshold-based decision rule** with forgiveness:

```pseudocode
cooperators_last_round = count_cooperators(previous_round)
total_cooperators_so_far = sum_cooperators(all_previous_rounds)
average_cooperation_rate = total_cooperators_so_far / ((current_round - 1) * n)

// Primary decision logic
if cooperators_last_round >= m:
    // Threshold was met - reward group cooperation
    action = COOPERATE
else if cooperators_last_round >= (m - 1):
    // Very close to threshold - help push over
    action = COOPERATE  
else if average_cooperation_rate >= 0.4:
    // Group shows reasonable cooperation history
    action = COOPERATE
else:
    // Group is consistently uncooperative
    if random() < 0.2:  // 20% forgiveness rate
        action = COOPERATE
    else:
        action = DEFECT
```

### Final Round: Conditional Cooperation
```pseudocode
cooperators_last_round = count_cooperators(previous_round)
average_cooperation_rate = total_cooperators_so_far / ((r - 1) * n)

if average_cooperation_rate >= 0.3 OR cooperators_last_round >= m:
    action = COOPERATE
else:
    action = DEFECT
```

## Key Strategic Elements

### 1. **Threshold Awareness**
- Prioritize cooperation when the group is at or near the threshold (m)
- Recognize that being the (m)th cooperator creates positive value for everyone

### 2. **Historical Learning**
- Track both recent behavior (last round) and long-term patterns
- Use average cooperation rate to assess group character
- Adjust forgiveness based on group's cooperative history

### 3. **Calculated Forgiveness**
- Even when facing persistent defection, occasionally cooperate (20% rate)
- This prevents permanent breakdown and tests if the group has reformed
- Maintains possibility of re-establishing cooperation

### 4. **End-Game Consideration**
- In the final round, still cooperate if the group has shown reasonable cooperation
- Avoids the typical end-game defection cascade that destroys mutual benefits

## Handling Edge Cases

### Very Small Groups (n close to m)
- Be extra cooperative since each player's decision is critical
- Higher forgiveness rate when cooperation rate drops

### Very Large Groups (n >> m)
- Still cooperate consistently to signal reliability
- Focus more on recent rounds since individual impact is smaller

### Persistent Mass Defection
- If cooperation rate drops below 20% for multiple consecutive rounds, temporarily switch to tit-for-tat
- Resume adaptive cooperation if any improvement is observed

## Strategic Rationale

This strategy balances several key principles:

1. **Cooperative by Default**: Starts cooperatively and maintains cooperative bias
2. **Responsive to Group Dynamics**: Adapts based on observed behavior without being overly punitive
3. **Threshold Intelligent**: Recognizes the critical importance of reaching m cooperators
4. **Resilient**: Doesn't permanently give up on the group, maintaining paths back to cooperation
5. **End-Game Stable**: Resists the temptation to defect in final rounds when cooperation history is positive

The strategy aims to foster and maintain cooperative equilibria while protecting against exploitation, ultimately maximizing both individual and collective payoffs across the tournament.
'''

description_COOPERATIVE_109 = '''
# Cooperative Strategy: "Adaptive Threshold Guardian"

## Core Philosophy
This strategy prioritizes collective welfare while maintaining resilience against exploitation. It aims to establish and maintain cooperation by being generous initially, responsive to group dynamics, and protective of the collective threshold.

## Decision Rules

### Round 1: Unconditional Cooperation
- **Action**: Always COOPERATE
- **Rationale**: Signal cooperative intent and give the group the best chance to establish a cooperative norm from the start.

### Rounds 2 to r-1: Adaptive Threshold Monitoring
The strategy uses a dynamic approach based on:
1. **Cooperation deficit tracking**
2. **Trend analysis** 
3. **Forgiveness mechanism**

```pseudocode
For round t (where 2 ≤ t ≤ r-1):
    
    // Calculate cooperation metrics
    cooperators_last_round = count_cooperators(t-1)
    cooperation_deficit = max(0, m - cooperators_last_round)
    
    // Track recent cooperation trend (last 3 rounds or available rounds)
    recent_rounds = min(3, t-1)
    avg_recent_cooperation = average_cooperators(t-recent_rounds, t-1)
    cooperation_trend = avg_recent_cooperation - cooperators_last_round
    
    // Decision logic
    if cooperators_last_round >= m:
        // Threshold was met - stay cooperative but monitor
        if cooperation_trend >= -0.5:
            Action = COOPERATE
        else:
            // Significant downward trend despite meeting threshold
            Action = COOPERATE (give one more chance)
    
    else if cooperation_deficit <= 2:
        // Close to threshold - be part of the solution
        Action = COOPERATE
        
    else if cooperation_deficit > 2 AND avg_recent_cooperation < m/2:
        // Large deficit and poor recent performance
        if random() < 0.3:  // 30% forgiveness probability
            Action = COOPERATE
        else:
            Action = DEFECT
    
    else:
        // Default cooperative stance
        Action = COOPERATE
```

### Final Round (Round r): Conditional Cooperation
```pseudocode
For round r:
    cooperators_last_round = count_cooperators(r-1)
    avg_cooperation_overall = average_cooperators(1, r-1)
    
    if cooperators_last_round >= m:
        // Group succeeded recently - maintain cooperation
        Action = COOPERATE
    
    else if avg_cooperation_overall >= m * 0.8:
        // Group has generally been cooperative
        Action = COOPERATE
    
    else if cooperators_last_round >= m - 2:
        // Close to threshold - help push over
        Action = COOPERATE
    
    else:
        // Group has consistently failed - self-preserve
        Action = DEFECT
```

## Key Features

### 1. **Generous Start**
- Always cooperate in round 1 to signal good intentions and maximize chances of early coordination.

### 2. **Threshold-Aware Adaptation**
- Prioritizes cooperation when the group is close to the threshold (deficit ≤ 2)
- Recognizes when individual cooperation is most impactful

### 3. **Trend Sensitivity**
- Monitors recent cooperation patterns to detect emerging coordination or breakdown
- Responds to negative trends while maintaining some optimism

### 4. **Controlled Forgiveness**
- Even when cooperation seems futile, maintains 30% probability of cooperating to allow for recovery
- Prevents complete breakdown while protecting against systematic exploitation

### 5. **Endgame Wisdom**
- Final round behavior reflects the overall cooperation history
- Balances final cooperation attempt with self-preservation based on group performance

## Handling Edge Cases

- **Small groups (n close to m)**: Strategy becomes more forgiving since each player's contribution is critical
- **Large cooperation deficit**: Maintains some cooperation probability to prevent total breakdown
- **Consistent threshold achievement**: Stays cooperative but monitors for defection trends
- **High variance in cooperation**: Uses multi-round averaging to avoid overreacting to single-round fluctuations

## Cooperative Alignment

This strategy embodies cooperation by:
- **Leading by example**: Starting cooperatively and maintaining high cooperation rates
- **Supporting collective success**: Prioritizing group welfare over individual gain
- **Being responsive not reactive**: Making thoughtful decisions based on group dynamics
- **Maintaining hope**: Always keeping some probability of cooperation to enable recovery
- **Protecting the threshold**: Understanding that cooperation near the threshold has maximum impact

The strategy balances pure altruism with strategic awareness, making it both genuinely cooperative and resilient against exploitation patterns.
'''

description_COOPERATIVE_110 = '''
# Cooperative Strategy: "Optimistic Threshold Guardian"

## Core Philosophy
This strategy is built on the principle of maximizing collective welfare while maintaining cooperation even when others might defect. It assumes that most rational players will recognize the mutual benefit of cooperation and aims to be part of the solution rather than the problem.

## Decision Rules

### Primary Logic
```
IF round == 1:
    COOPERATE  // Lead by example
    
ELSE IF round == final_round:
    IF (cooperators_last_round >= m):
        COOPERATE  // Maintain successful cooperation
    ELSE:
        COOPERATE  // Stay cooperative even if others abandon ship
        
ELSE:  // Middle rounds
    IF (cooperators_last_round >= m):
        COOPERATE  // Reward successful cooperation
    ELSE IF (cooperators_last_round >= m-1):
        COOPERATE  // Close to threshold - be the bridge
    ELSE:
        // Apply forgiveness mechanism
        IF (recent_cooperation_trend > 0.3):
            COOPERATE  // Show faith in recovery
        ELSE IF (my_cooperation_rate > 0.7):
            COOPERATE  // Maintain cooperative identity
        ELSE:
            COOPERATE  // Default to cooperation
```

## Detailed Strategy Components

### 1. **Unconditional First Round Cooperation**
Always cooperate in round 1 to signal cooperative intent and help establish a positive precedent.

### 2. **Threshold-Sensitive Cooperation**
- When cooperation threshold is met (≥m cooperators): Always cooperate to maintain the beneficial equilibrium
- When close to threshold (m-1 cooperators): Cooperate to help push the group over the line
- When far from threshold (<m-1): Still lean toward cooperation but consider recent trends

### 3. **Trend Analysis**
Track cooperation trends over the last 3 rounds:
```
recent_cooperation_trend = (cooperators_in_last_3_rounds) / (3 * n)
```
If trend shows improvement (>0.3), maintain cooperation to support recovery.

### 4. **Identity Consistency**
Maintain a cooperative identity by tracking personal cooperation rate:
```
my_cooperation_rate = (times_I_cooperated) / (rounds_played)
```
If maintaining high cooperation rate (>0.7), continue cooperating to stay consistent.

### 5. **Endgame Cooperation**
In the final round, cooperate regardless of previous outcomes to:
- Signal long-term cooperative intent for potential future interactions
- Maintain moral consistency
- Contribute to final collective benefit

## Edge Case Handling

### **First Round**: 
Always cooperate to establish positive momentum and signal cooperative intent.

### **Last Round**: 
Always cooperate to maintain consistency and maximize final collective payoff.

### **All Others Defecting**: 
Continue cooperating occasionally to provide opportunities for others to return to cooperation.

### **Consistent Success**: 
When the group consistently meets the threshold, maintain cooperation to preserve the successful equilibrium.

## Cooperative Alignment

This strategy is fundamentally cooperative because it:

1. **Defaults to Cooperation**: The base assumption is to cooperate unless there are compelling reasons otherwise
2. **Facilitates Group Success**: Actively works to help the group reach the cooperation threshold
3. **Shows Forgiveness**: Doesn't punish defection harshly but gives opportunities for redemption
4. **Maintains Consistency**: Stays true to cooperative principles even when others might abandon them
5. **Maximizes Collective Welfare**: Prioritizes group benefit over individual short-term gain

## Expected Behavior

This strategy will cooperate approximately 85-95% of the time, depending on opponent behavior. It's designed to:
- Create and maintain cooperative equilibria
- Recover from temporary defection spirals
- Signal reliability to other cooperative strategies
- Maximize both individual and collective long-term payoffs

The strategy accepts that it might be exploited by purely selfish strategies but believes that in a tournament of strategies designed by reasoning agents, the benefits of consistent cooperation will outweigh the costs of occasional exploitation.
'''

description_COOPERATIVE_111 = '''
# Cooperative Strategy: "Adaptive Threshold Guardian"

## Core Philosophy
This strategy prioritizes collective welfare while being resilient to defection and adaptive to group dynamics. It aims to maintain cooperation when beneficial while protecting against exploitation.

## Strategy Description

### Decision Rules

**Primary Cooperation Trigger:**
- Cooperate if the expected number of cooperators (including self) ≥ m (threshold)
- Base expectation on observed cooperation rates and trend analysis

**Adaptive Learning Component:**
- Track each player's cooperation history and reliability
- Adjust expectations based on recent behavioral patterns
- Weight recent rounds more heavily than distant ones

### Detailed Algorithm

```pseudocode
INITIALIZE:
- cooperation_history[n][r] = empty matrix
- player_reliability[n] = 0.5 (neutral assumption)
- recent_window = min(5, r/4) // adaptive window size
- optimism_factor = 0.1 // slight bias toward cooperation

FOR each round t:
    IF t == 1:
        // First round: Cooperate to signal cooperative intent
        decision = COOPERATE
    
    ELSE:
        // Calculate expected cooperators
        expected_cooperators = 0
        
        FOR each player j != i:
            recent_coop_rate = calculate_recent_cooperation_rate(j, t-1, recent_window)
            trend_adjustment = calculate_trend(j, t-1, recent_window)
            reliability[j] = recent_coop_rate + trend_adjustment
            expected_cooperators += reliability[j]
        
        // Add optimism factor to account for potential cooperation
        expected_cooperators += optimism_factor
        
        // Decision logic
        IF expected_cooperators >= (m - 1): // m-1 because we're the mth cooperator
            decision = COOPERATE
        ELSE IF t >= r - 2: // Last two rounds special handling
            decision = apply_endgame_logic(expected_cooperators, t)
        ELSE:
            decision = DEFECT
    
    EXECUTE decision
    UPDATE cooperation_history and player_reliability based on observed actions
```

### Key Components

**1. Recent Cooperation Rate Calculation:**
```pseudocode
calculate_recent_cooperation_rate(player_j, current_round, window):
    start_round = max(1, current_round - window + 1)
    cooperations = count_cooperations(player_j, start_round, current_round)
    total_rounds = current_round - start_round + 1
    return cooperations / total_rounds
```

**2. Trend Analysis:**
```pseudocode
calculate_trend(player_j, current_round, window):
    if current_round < 3: return 0
    
    recent_rate = cooperation_rate(player_j, max(1, current_round-2), current_round)
    earlier_rate = cooperation_rate(player_j, max(1, current_round-4), current_round-3)
    
    trend = (recent_rate - earlier_rate) * 0.2 // modest trend weight
    return max(-0.2, min(0.2, trend)) // bounded adjustment
```

**3. Endgame Logic:**
```pseudocode
apply_endgame_logic(expected_cooperators, round):
    // In final rounds, be slightly more optimistic about cooperation
    // as rational players may want to end on a positive note
    adjusted_expectation = expected_cooperators + 0.2
    
    IF adjusted_expectation >= (m - 1):
        return COOPERATE
    ELSE:
        return DEFECT
```

### Edge Case Handling

**First Round:**
- Always cooperate to signal cooperative intent and gather information about others

**Last Round:**
- Use endgame logic with slight optimism bias, as reputation concerns may increase cooperation

**When m = n (everyone must cooperate):**
- Always cooperate unless clear evidence that others won't

**When expected cooperators exactly equals m-1:**
- Cooperate (be the pivotal player for collective benefit)

### Cooperation Mindset Alignment

This strategy embodies cooperation through:

1. **Proactive Cooperation**: Willing to be the pivotal mth cooperator
2. **Forgiveness**: Uses recent behavior more than distant history
3. **Optimism**: Includes optimism factors in calculations
4. **Collective Focus**: Prioritizes reaching the threshold for group benefit
5. **Adaptive Support**: Increases cooperation likelihood when others show cooperative trends

### Strategic Advantages

- **Resilient**: Adapts to different opponent types and group dynamics
- **Efficient**: Avoids unnecessary defection when cooperation is viable
- **Sustainable**: Maintains cooperation when it's mutually beneficial
- **Robust**: Handles various parameter combinations (different n, m, k values)

This strategy should perform well against both cooperative and mixed-strategy opponents while maintaining a fundamentally cooperative stance throughout the game.
'''

description_COOPERATIVE_112 = '''
# Cooperative Strategy: "Adaptive Trust Builder"

## Core Philosophy
This strategy prioritizes collective welfare while maintaining resilience against exploitation. It assumes other cooperative strategies will emerge in the tournament and focuses on building trust and maintaining cooperation when possible.

## Decision Rules

### Round 1: Optimistic Start
- **Always COOPERATE** in the first round
- Rationale: Signal cooperative intent and give the group the best chance to establish a cooperative norm from the start

### Rounds 2 to r-1: Adaptive Cooperation
Use a three-tier decision system based on recent cooperation levels:

```pseudocode
cooperation_rate = (cooperators_last_round / n)
recent_trend = average_cooperation_rate_last_3_rounds

IF cooperation_rate >= (m/n):
    // Threshold being met - reinforce success
    action = COOPERATE
    
ELSE IF cooperation_rate >= (m-1)/n AND recent_trend is_increasing:
    // Close to threshold with positive trend - encourage
    action = COOPERATE
    
ELSE IF cooperation_rate >= 0.4 AND my_last_action == COOPERATE:
    // Moderate cooperation, I was cooperative - give one more chance
    action = COOPERATE
    
ELSE:
    // Low cooperation or consistently declining
    action = DEFECT
```

### Last Round (Round r): Conditional Cooperation
```pseudocode
cooperation_rate_recent = average_cooperation_last_3_rounds

IF cooperation_rate_recent >= (m/n):
    // Group has been meeting threshold - reward loyalty
    action = COOPERATE
    
ELSE IF cooperation_rate_recent >= (m-1)/n:
    // Close calls - encourage final push
    action = COOPERATE
    
ELSE:
    // Group failing to cooperate consistently
    action = DEFECT
```

## Key Features

### 1. Threshold Awareness
- Continuously monitors whether the group is meeting the minimum threshold (m)
- Cooperates more readily when the group is close to success
- Recognizes that one additional cooperator can make the difference

### 2. Trend Sensitivity
- Tracks cooperation trends over the last 3 rounds
- Rewards improving cooperation even if current levels are suboptimal
- Responds to declining cooperation by eventually withdrawing support

### 3. Forgiveness Mechanism
- Gives groups a second chance if they show signs of recovery
- Maintains cooperation for one round even after mild disappointment
- Balances forgiveness with self-protection

### 4. Trust Building
- Starts optimistically to establish cooperative norms
- Signals reliability by cooperating when the threshold is being met
- Ends cooperatively if the group has shown consistent good faith

## Edge Case Handling

**Very Small Groups (n ≤ 4)**: Increase cooperation threshold slightly since each defection has larger impact

**High Threshold Games (m > 0.7n)**: More patient with cooperation attempts since coordination is inherently difficult

**Low Reward Games (k < 1.5)**: Slightly more conservative, requiring stronger cooperation signals

## Cooperative Alignment

This strategy embodies cooperation by:
- **Leading by example** in early rounds
- **Supporting collective success** when threshold is achieved
- **Encouraging marginal cases** where one more cooperator helps
- **Remaining loyal** to consistently cooperative groups
- **Balancing idealism with realism** to avoid exploitation while maintaining cooperative spirit

The strategy assumes other LLMs will also design fundamentally cooperative approaches, creating an environment where mutual cooperation can flourish while maintaining enough adaptability to handle mixed populations.
'''

description_COOPERATIVE_113 = '''
# Cooperative Strategy: "Adaptive Threshold Guardian"

## Core Philosophy
This strategy prioritizes collective welfare while being resilient to exploitation. It aims to maintain cooperation when possible but adapts to ensure the critical threshold is met even when facing some defectors.

## Decision Rules

### Round 1: Always Cooperate
- **Action**: C
- **Rationale**: Start optimistically to signal cooperative intent and give the group the best chance of establishing a cooperative norm.

### Rounds 2 to r-1: Adaptive Cooperation
Use a three-tier decision system:

**Tier 1 - Cooperation Assessment:**
- Count cooperators in previous round: `coop_count`
- If `coop_count >= m + 1`: **Cooperate** (surplus exists, maintain cooperation)
- If `coop_count < m - 1`: Go to Tier 2
- If `coop_count == m` or `coop_count == m - 1`: Go to Tier 3

**Tier 2 - Recovery Mode (when cooperation is failing):**
- Calculate cooperation rate: `coop_rate = coop_count / n`
- If `coop_rate < 0.3`: **Defect** (cooperation has collapsed, protect yourself)
- Otherwise: **Cooperate** (attempt to rebuild cooperation)

**Tier 3 - Critical Threshold Management:**
- If `coop_count == m`: 
  - If I cooperated last round: **Cooperate** (maintain threshold)
  - If I defected last round: **Cooperate** (help maintain threshold)
- If `coop_count == m - 1`:
  - **Cooperate** (essential to reach threshold)

### Final Round: Conditional Cooperation
- If cooperation rate over last 3 rounds > 0.6: **Cooperate**
- Otherwise: **Defect** (no future rounds to rebuild trust)

## Edge Case Handling

### Very Small Groups (n ≤ 4):
- Be more forgiving - cooperate unless cooperation rate drops below 0.2
- Every contribution is crucial in small groups

### High Threshold Scenarios (m > 0.7n):
- More aggressive cooperation - only defect if cooperation rate < 0.15
- Higher thresholds require more coordinated effort

### Low Reward Scenarios (k < 1.5):
- Standard strategy applies, but be slightly more willing to defect in recovery mode
- Use threshold of 0.35 instead of 0.3 for cooperation rate

## Pseudocode

```python
def decide_action(round_num, history, n, m, k, r):
    if round_num == 1:
        return C
    
    # Get last round's cooperation count
    last_round = history[-1]
    coop_count = sum(1 for action in last_round if action == C)
    coop_rate = coop_count / n
    
    # Final round logic
    if round_num == r:
        recent_coop_rate = calculate_recent_cooperation_rate(history, 3)
        return C if recent_coop_rate > 0.6 else D
    
    # Tier 1: Surplus cooperation
    if coop_count >= m + 1:
        return C
    
    # Tier 2: Cooperation failure
    if coop_count < m - 1:
        threshold = 0.35 if k < 1.5 else 0.3
        threshold = 0.2 if n <= 4 else threshold
        threshold = 0.15 if m > 0.7 * n else threshold
        
        return C if coop_rate >= threshold else D
    
    # Tier 3: Critical threshold management
    if coop_count in [m-1, m]:
        return C
    
    return C  # Default to cooperation
```

## Key Strengths

1. **Threshold-Aware**: Always prioritizes meeting the critical threshold `m`
2. **Adaptive**: Responds to the cooperation level of others
3. **Resilient**: Protects against exploitation while maintaining cooperative intent
4. **Context-Sensitive**: Adjusts behavior based on group size, threshold, and rewards
5. **Forward-Looking**: Considers long-term reputation except in final round

This strategy balances the cooperative imperative with practical considerations, aiming to maximize collective welfare while avoiding being systematically exploited by defectors.
'''

description_COOPERATIVE_114 = '''
# Cooperative Strategy: "Adaptive Threshold Guardian"

## Core Philosophy
This strategy prioritizes collective welfare while maintaining resilience against exploitation. It operates on the principle of "cooperative leadership with adaptive protection" - actively working to achieve the cooperation threshold while adapting to observed opponent behavior patterns.

## Strategy Description

### Decision Rules

**Round 1 (Initialization):**
- Always COOPERATE to signal cooperative intent and contribute to establishing trust

**Rounds 2 to r-1 (Adaptive Phase):**
- Track cooperation rate across all players over previous rounds
- Calculate expected cooperators based on historical patterns
- Apply adaptive decision rule:

```pseudocode
FOR each round t (where 2 ≤ t ≤ r-1):
    historical_coop_rate = total_cooperations_so_far / (n × (t-1))
    expected_cooperators_this_round = historical_coop_rate × n
    
    IF expected_cooperators_this_round >= m:
        action = COOPERATE
    ELSE IF expected_cooperators_this_round >= (m - 1):
        // Close to threshold - be the crucial cooperator
        action = COOPERATE
    ELSE:
        // Apply forgiveness mechanism
        rounds_since_threshold_met = count_rounds_since_last_success()
        IF rounds_since_threshold_met <= 2:
            action = COOPERATE  // Give benefit of doubt
        ELSE:
            action = DEFECT     // Protect against systematic exploitation
```

**Final Round (r):**
- Use simplified decision based on recent cooperation trends:
```pseudocode
recent_success_rate = successful_rounds_in_last_3 / min(3, r-1)
IF recent_success_rate >= 0.5:
    action = COOPERATE  // Reward consistent cooperation
ELSE:
    action = DEFECT     // Protect final payoff
```

### Key Mechanisms

1. **Threshold Leadership**: Actively cooperates when close to the threshold (m-1 or m expected cooperators) to help achieve collective success

2. **Adaptive Learning**: Continuously updates expectations based on observed behavior patterns rather than assuming fixed opponent types

3. **Forgiveness Window**: Maintains cooperation for up to 2 rounds after threshold failures to account for coordination errors or temporary defections

4. **Exploitation Protection**: Switches to defection if cooperation consistently fails, preventing systematic exploitation

5. **Endgame Consideration**: Adjusts final round behavior based on recent cooperation success to balance cooperation with self-protection

### Handling Edge Cases

- **All opponents defect consistently**: Strategy will detect low cooperation rates and switch to defection after the forgiveness window
- **Intermittent cooperation**: Strategy adapts to patterns and maintains cooperation when threshold achievement seems likely
- **High cooperation environment**: Strategy reinforces cooperative behavior by consistently contributing
- **Mixed strategies by opponents**: Uses statistical tracking to make informed predictions about threshold achievement

### Cooperative Alignment

This strategy maintains strong cooperative orientation by:
- Starting cooperatively to establish positive tone
- Actively contributing when the threshold is achievable
- Providing forgiveness for occasional coordination failures
- Prioritizing collective success over individual gain when feasible
- Only defecting as protection against systematic exploitation

The strategy balances cooperative ideals with practical considerations, ensuring it contributes meaningfully to collective welfare while avoiding exploitation in environments where cooperation breaks down.
'''

description_COOPERATIVE_115 = '''
# Cooperative Strategy: "Optimistic Threshold Guardian"

## Core Philosophy
This strategy prioritizes collective welfare while being pragmatic about threshold requirements. It assumes other cooperative strategies exist and aims to coordinate with them to consistently meet the cooperation threshold `m`.

## Decision Rules

### Round 1: Always Cooperate
- **Action**: C
- **Rationale**: Signal cooperative intent and give others the benefit of the doubt

### Rounds 2 to r-1: Adaptive Cooperation
```pseudocode
threshold_met_history = []
cooperation_rates = []

for round t in [2, r-1]:
    # Calculate recent cooperation trend
    recent_cooperation_rate = average cooperation over last 3 rounds (or all if < 3)
    
    # Estimate likelihood threshold will be met without me
    expected_cooperators = recent_cooperation_rate * (n-1)
    
    if expected_cooperators >= m-1:
        # Threshold likely met even without my cooperation
        action = C  # Cooperate anyway to maintain trust
    elif expected_cooperators >= m-2:
        # Borderline case - my cooperation is crucial
        action = C
    else:
        # Check if there's been improvement trend
        if recent_cooperation_rate > cooperation_rate_from_previous_window:
            action = C  # Give benefit of doubt to improving cooperation
        else:
            action = C  # Still cooperate but flag concern
    
    # Always cooperate if threshold was met in previous round
    if threshold_met_in_previous_round:
        action = C
```

### Final Round: Conditional Cooperation
```pseudocode
if average_threshold_success_rate > 0.6:
    action = C  # Reward consistent cooperation
elif cooperation_rate_in_previous_round >= (m-1)/(n-1):
    action = C  # Others are doing their part
else:
    action = C  # Cooperate anyway - maintain cooperative reputation
```

## Key Features

### 1. **Threshold Awareness**
- Constantly estimates whether threshold `m` will be met
- Recognizes that cooperation is most valuable when close to threshold

### 2. **Forgiveness and Trust Building**
- Doesn't punish defection harshly
- Maintains cooperation even when others occasionally defect
- Assumes temporary defections may be strategic rather than malicious

### 3. **Trend Analysis**
- Tracks cooperation patterns over recent rounds
- Responds positively to improving cooperation trends
- Maintains hope even during difficult periods

### 4. **Edge Case Handling**

**First Round**: Always cooperate to signal intent

**Early Rounds (2-4)**: Maintain high cooperation while gathering information

**Middle Rounds**: Balance cooperation with adaptive responses to observed patterns

**Final Round**: Cooperate to maintain reputation for future interactions (if any) and reward consistent cooperators

## Pseudocode Summary

```pseudocode
function decide_action(round_number, history):
    if round_number == 1:
        return C
    
    if round_number == r:  # Final round
        if group_cooperation_trend_positive():
            return C
        else:
            return C  # Cooperate anyway
    
    # Middle rounds
    expected_other_cooperators = estimate_cooperators_from_trend()
    
    if expected_other_cooperators >= m-1:
        return C  # Threshold likely met
    elif expected_other_cooperators >= m-2:
        return C  # My cooperation crucial
    else:
        return C  # Maintain cooperation despite low expectations
```

## Cooperation Justification

This strategy embodies cooperation by:

1. **Defaulting to cooperation** in nearly all scenarios
2. **Supporting threshold achievement** by recognizing when cooperation is most needed
3. **Building trust** through consistent cooperative behavior
4. **Forgiving defection** and maintaining hope for collective success
5. **Prioritizing group welfare** over individual payoff maximization

The strategy assumes that in a tournament of strategies designed by cooperative-minded LLMs, there will be sufficient cooperative players to make threshold achievement feasible, and focuses on being a reliable contributor to that collective success.
'''

description_COOPERATIVE_116 = '''
# Cooperative Strategy: "Adaptive Threshold Guardian"

## Core Philosophy
This strategy prioritizes collective welfare while maintaining resilience against exploitation. It assumes other cooperative strategies exist and focuses on building stable cooperation coalitions.

## Decision Rules

### Round 1: Optimistic Cooperation
**Always cooperate** in the first round to signal cooperative intent and establish trust.

### Rounds 2 to r-1: Adaptive Cooperation with Safety Margin
**Cooperate if ANY of these conditions are met:**

1. **Threshold Achievement**: In the previous round, ≥ m players cooperated
2. **Near-Miss Recovery**: In the previous round, exactly (m-1) players cooperated 
3. **Trust Building**: Fewer than 25% of total rounds so far have failed to meet the threshold
4. **Coalition Maintenance**: At least 50% of players have cooperated in ≥ 75% of previous rounds

**Defect only if ALL conditions fail** (indicating widespread defection or strategic breakdown)

### Final Round: Conditional Cooperation
Apply the same rules as rounds 2 to r-1, but with **enhanced forgiveness**:
- If previous round had ≥ (m-2) cooperators, still cooperate
- This prevents end-game defection cascades

## Pseudocode

```python
def decide_action(round_num, history, n, m, k, r):
    if round_num == 1:
        return COOPERATE
    
    prev_cooperators = count_cooperators(history[-1])
    total_rounds_played = len(history)
    failed_rounds = count_failed_thresholds(history, m)
    
    # Condition 1: Threshold achieved
    if prev_cooperators >= m:
        return COOPERATE
    
    # Condition 2: Near-miss recovery
    if prev_cooperators == m - 1:
        return COOPERATE
    
    # Condition 3: Trust building (success rate > 75%)
    if failed_rounds / total_rounds_played < 0.25:
        return COOPERATE
    
    # Condition 4: Coalition maintenance
    cooperative_players = count_consistent_cooperators(history, threshold=0.75)
    if cooperative_players / n >= 0.5:
        return COOPERATE
    
    # Final round forgiveness
    if round_num == r and prev_cooperators >= m - 2:
        return COOPERATE
    
    return DEFECT
```

## Edge Case Handling

**First Round**: Unconditional cooperation to establish cooperative signaling

**Last Round**: Enhanced forgiveness (cooperate even with m-2 cooperators) to prevent end-game unraveling

**Consecutive Failures**: After multiple threshold failures, strategy becomes more selective but maintains cooperation if any positive signals exist

**All-Defection Scenarios**: Will eventually defect if cooperation completely breaks down, but maintains high tolerance for temporary setbacks

## Cooperative Alignment

This strategy embodies cooperation through:

1. **Default Cooperation**: Bias toward cooperating when uncertain
2. **Forgiveness**: Multiple pathways to return to cooperation after failures  
3. **Coalition Building**: Explicitly rewards and maintains cooperative relationships
4. **Long-term Thinking**: Prioritizes sustainable cooperation over short-term gains
5. **Threshold Guardianship**: Actively works to maintain the minimum cooperation needed for collective success

The strategy assumes other LLMs may employ similar cooperative logic and focuses on creating stable, mutually beneficial cooperation patterns while maintaining enough flexibility to handle various opponent behaviors.
'''

description_COOPERATIVE_117 = '''
# Cooperative Strategy: "Optimistic Guardian"

## Core Philosophy
This strategy operates on the principle of **proactive cooperation with strategic resilience**. It assumes other players are fundamentally cooperative but maintains safeguards against exploitation while prioritizing collective welfare.

## Strategy Description

### Decision Rules

**Primary Rule - Cooperative Threshold Maintenance:**
- Always cooperate if my cooperation is needed to reach the minimum threshold `m`
- Cooperate if the expected number of cooperators (including myself) is close to but not safely above `m`

**Adaptive Cooperation Based on History:**
- Track each player's cooperation rate over previous rounds
- Maintain a "trust score" for the group based on recent cooperation patterns
- Cooperate more readily when group trust is high, be more cautious when it's declining

### Detailed Algorithm

```pseudocode
STRATEGY: Optimistic Guardian

INITIALIZE:
    cooperation_history = empty matrix [n players × r rounds]
    group_trust_score = 0.8  // Start optimistic
    personal_cooperation_rate = 0.0
    
FOR each round t:
    IF t == 1:  // First round
        RETURN Cooperate
    
    // Update trust metrics
    recent_cooperation_rate = calculate_recent_group_cooperation(last 3 rounds)
    group_trust_score = 0.7 * group_trust_score + 0.3 * recent_cooperation_rate
    
    // Predict likely cooperators this round
    predicted_cooperators = 0
    FOR each other player j:
        player_coop_rate = cooperation_rate(player j, recent rounds)
        IF player_coop_rate > group_trust_score:
            predicted_cooperators += 1
    
    // Core decision logic
    IF predicted_cooperators >= m:
        // Threshold likely to be met without me
        IF group_trust_score > 0.6 AND recent_cooperation_rate > 0.5:
            RETURN Cooperate  // Join the cooperative effort
        ELSE IF predicted_cooperators >= m + 2:
            RETURN Defect     // Safe to free-ride
        ELSE:
            RETURN Cooperate  // Insurance cooperation
    
    ELSE IF predicted_cooperators == m - 1:
        RETURN Cooperate  // My cooperation is crucial
    
    ELSE IF predicted_cooperators < m - 1:
        IF group_trust_score > 0.7:
            RETURN Cooperate  // Try to encourage cooperation
        ELSE:
            RETURN Defect     // Likely failure, preserve resources
    
    // Last round special case
    IF t == r:
        IF predicted_cooperators >= m - 1:
            RETURN Cooperate  // Ensure final success
        ELSE:
            RETURN Defect     // No future rounds to recover
```

### Edge Case Handling

**First Round (t=1):**
- Always cooperate to signal cooperative intent and help establish a cooperative norm
- This helps build initial trust and encourages others to cooperate

**Last Round (t=r):**
- Apply stricter threshold logic since there are no future rounds for recovery
- Cooperate only if cooperation is essential (predicted cooperators = m-1) or very likely to succeed
- This prevents exploitation in the final round while maintaining cooperative commitment

**Low Trust Scenarios:**
- When group_trust_score falls below 0.4, switch to more conservative cooperation
- Still cooperate if absolutely necessary for threshold, but avoid unnecessary cooperation
- This protects against consistently exploitative opponents

**High Trust Scenarios:**
- When group_trust_score exceeds 0.7, be more generous with cooperation
- Help maintain successful cooperative equilibria
- This reinforces positive cooperation cycles

### Cooperative Alignment Features

1. **Threshold Protection:** Always ensures the group succeeds when possible by cooperating when crucial

2. **Trust Building:** Starts optimistically and rewards consistent cooperation from others

3. **Collective Welfare:** Prefers outcomes where the group achieves the threshold rather than maximizing individual payoff

4. **Forgiveness:** Gradually rebuilds trust after periods of defection, allowing for recovery of cooperative norms

5. **Insurance Cooperation:** Sometimes cooperates even when not strictly necessary to provide buffer against miscalculations

This strategy balances cooperative intention with strategic awareness, aiming to foster sustainable cooperation while protecting against exploitation. It should perform well in environments with other cooperative strategies while maintaining reasonable defense against purely selfish opponents.
'''

description_COOPERATIVE_118 = '''
# Cooperative Strategy: "Threshold-Aware Gradual Forgiveness"

## Core Philosophy
This strategy prioritizes collective welfare while maintaining resilience against exploitation. It recognizes that cooperation requires both trust-building and strategic patience, especially in the face of occasional defections from otherwise cooperative players.

## Decision Rules

### Round 1: Optimistic Start
- **Always cooperate** to signal cooperative intent and establish trust

### Subsequent Rounds: Adaptive Cooperation
The strategy operates on three key principles:

1. **Threshold Awareness**: Focus on whether we can realistically achieve the minimum threshold `m`
2. **Gradual Forgiveness**: Don't abandon cooperation immediately after betrayal
3. **Collective Monitoring**: Track overall cooperation trends, not just individual defections

## Detailed Strategy Logic

```pseudocode
STRATEGY: Threshold-Aware Gradual Forgiveness

Initialize:
- cooperation_history = [] (track all players' actions each round)
- forgiveness_debt = 0 (accumulated "strikes" against the group)
- consecutive_failures = 0 (rounds where threshold wasn't met)

For each round t:
    if t == 1:
        return COOPERATE
    
    // Analyze previous round
    cooperators_last_round = count_cooperators(cooperation_history[t-1])
    
    if cooperators_last_round >= m:
        // Threshold was met - reset negative counters
        consecutive_failures = 0
        forgiveness_debt = max(0, forgiveness_debt - 1) // Slowly forgive
    else:
        // Threshold failed
        consecutive_failures += 1
        forgiveness_debt += (m - cooperators_last_round) // Add "debt" based on shortfall
    
    // Decision logic
    if consecutive_failures >= 3:
        // Give up if repeatedly failing to meet threshold
        return DEFECT
    
    if forgiveness_debt > n * 0.4:
        // Too much accumulated non-cooperation
        return DEFECT
    
    if t == r: // Last round
        // Cooperate in final round to maintain reputation
        return COOPERATE
    
    // Default: Continue cooperating
    return COOPERATE
```

## Key Features

### 1. **Threshold-Focused Analysis**
- Rather than punishing individual defectors, the strategy evaluates whether the group is collectively meeting the cooperation threshold
- This prevents overreaction to strategic defection by players who know others will cooperate

### 2. **Gradual Forgiveness Mechanism**
- Uses a "forgiveness debt" system that accumulates when cooperation falls short
- Slowly forgives past failures when the group successfully meets thresholds
- This allows recovery from temporary coordination failures

### 3. **Failure Tolerance**
- Only abandons cooperation after 3 consecutive threshold failures
- This prevents premature defection due to random fluctuations or brief coordination problems

### 4. **End-Game Cooperation**
- Always cooperates in the final round to maintain cooperative reputation
- This signals long-term cooperative intent rather than exploitation

## Edge Case Handling

- **First Round**: Always cooperate to establish positive momentum
- **Last Round**: Always cooperate to maintain reputation and avoid end-game defection cascades
- **Repeated Failures**: Only defect after clear evidence that cooperation is impossible
- **Recovery**: Actively forgives and returns to cooperation when group performance improves

## Cooperative Alignment

This strategy embodies cooperative principles by:

1. **Default Cooperation**: Cooperates unless there's strong evidence it's futile
2. **Collective Focus**: Prioritizes group success over individual gain
3. **Forgiveness**: Gives multiple chances for coordination to recover
4. **Trust Building**: Signals reliability through consistent cooperative behavior
5. **Long-term Thinking**: Maintains cooperation even when individual rounds might favor defection

The strategy balances cooperative idealism with practical resilience, aiming to foster the collective cooperation necessary for everyone to benefit from the risk mitigation reward `k`.
'''

description_COOPERATIVE_119 = '''
# Cooperative Strategy: "Generous Threshold Guardian"

## Core Philosophy
This strategy prioritizes collective welfare while maintaining resilience against exploitation. It aims to establish and maintain cooperation by being generous in building trust, vigilant in protecting the collective threshold, and forgiving enough to enable recovery from temporary defections.

## Decision Rules

### Primary Decision Logic:
```pseudocode
function decide_action(round, history, n, m, k, r):
    if round == 1:
        return COOPERATE  // Always start cooperatively
    
    // Calculate cooperation rates from recent history
    recent_cooperation_rate = calculate_recent_cooperation(history, window=3)
    last_round_cooperators = count_cooperators(history[round-1])
    
    // Threshold-based decision with generous margin
    safety_margin = max(1, ceil(m * 0.3))  // 30% buffer above minimum
    target_cooperators = m + safety_margin
    
    if last_round_cooperators >= target_cooperators:
        // Threshold safely met - maintain cooperation with high probability
        return COOPERATE with probability 0.9
    
    else if last_round_cooperators >= m:
        // Threshold barely met - definitely cooperate to maintain
        return COOPERATE
    
    else if last_round_cooperators >= (m - 2):
        // Close to threshold - cooperate to help reach it
        return COOPERATE
    
    else:
        // Far from threshold - use adaptive response
        return adaptive_response(recent_cooperation_rate, round, r)
```

### Adaptive Response for Low Cooperation:
```pseudocode
function adaptive_response(cooperation_rate, current_round, total_rounds):
    // In early rounds, be more forgiving
    if current_round <= total_rounds * 0.3:
        return COOPERATE if cooperation_rate > 0.2
    
    // In middle rounds, use reciprocal strategy
    else if current_round <= total_rounds * 0.7:
        return COOPERATE if cooperation_rate > 0.4
    
    // In final rounds, be more cooperative to avoid mutual punishment
    else:
        return COOPERATE if cooperation_rate > 0.3 OR current_round > total_rounds * 0.85
```

## Edge Case Handling

### First Round:
- **Always COOPERATE** - Essential to signal cooperative intent and give the group the best chance to establish a cooperative equilibrium from the start.

### Last Few Rounds:
- **Increase cooperation probability** in final 15% of rounds to avoid end-game defection spirals
- Cooperate if any reasonable chance exists that others will also cooperate

### Consecutive Failures:
- If threshold fails for 3+ consecutive rounds with very low cooperation (< 20%), temporarily switch to "teaching mode":
  - Cooperate for 1 round, then defect for 1 round
  - This signals that cooperation is conditional on group effort
  - Return to primary strategy after 2 cycles

### Near-Unanimous Defection:
- If cooperation drops below 10% for 2 consecutive rounds:
  - Make one final "wake-up call" by cooperating
  - If still no response, minimize losses while occasionally signaling willingness to restart cooperation

## Cooperative Alignment Features

1. **Generous Starting**: Always begin cooperatively to establish positive momentum
2. **Safety Buffer**: Aim for more cooperators than minimum required (m + buffer)
3. **Forgiveness**: Don't permanently punish temporary defections
4. **Group Recovery**: Help restart cooperation after collective failures
5. **End-Game Cooperation**: Resist defection spirals in final rounds
6. **Teaching Mechanism**: Use temporary defection only to encourage others to cooperate

## Strategic Rationale

- **Threshold Focus**: The strategy recognizes that the key to success is consistently meeting the cooperation threshold m
- **Generous Margin**: By aiming for more than minimum cooperation, we create resilience against occasional defections
- **Adaptive Forgiveness**: Early forgiveness builds trust, while later conditional cooperation maintains standards
- **Collective Recovery**: Helps the group escape from bad equilibria without being exploited
- **Tournament Awareness**: Assumes opponents are also trying to find cooperative solutions, so maintains cooperative stance even under pressure

This strategy balances the cooperative imperative with practical protection against exploitation, while remaining generous enough to foster the collective cooperation necessary for everyone to benefit from the risk mitigation reward.
'''

description_COOPERATIVE_120 = '''
# Cooperative Strategy: "Collective Guardian"

## Core Philosophy
This strategy prioritizes collective welfare while maintaining resilience against exploitation. It operates on the principle that cooperation should be the default, but must be sustainable and adaptive to maintain the group's long-term success.

## Decision Rules

### Primary Decision Logic:
```pseudocode
function decide_action(round, history, n, m, k, r):
    if round == 1:
        return COOPERATE  // Always start cooperatively
    
    // Calculate cooperation trends
    recent_cooperation_rate = calculate_recent_cooperation(history, lookback_window=3)
    overall_cooperation_rate = calculate_overall_cooperation(history)
    
    // Threshold-aware cooperation
    expected_cooperators = predict_cooperators(recent_cooperation_rate, n)
    
    if expected_cooperators >= m + safety_buffer:
        return COOPERATE  // Safe to cooperate
    else if expected_cooperators >= m - 1:
        return COOPERATE  // Critical - cooperation needed
    else:
        return conditional_cooperate(history, round, r)
```

### Key Components:

1. **Optimistic Start**: Always cooperate in round 1 to signal cooperative intent and establish positive momentum.

2. **Dynamic Threshold Monitoring**: 
   - Track how many players typically cooperate
   - Maintain a "safety buffer" of 1-2 extra cooperators when possible
   - If we're near the threshold (m), always cooperate to prevent collective failure

3. **Adaptive Cooperation Rate**:
   - If recent cooperation rate > 70%: Cooperate confidently
   - If recent cooperation rate 40-70%: Cooperate cautiously (help maintain threshold)
   - If recent cooperation rate < 40%: Enter "rescue mode"

4. **Rescue Mode** (when cooperation is dangerously low):
   ```pseudocode
   function conditional_cooperate(history, round, r):
       if round <= r * 0.7:  // Early/mid game
           return COOPERATE  // Try to rebuild cooperation
       else:  // Late game
           if count_recent_cooperators(history, 2) >= m - 1:
               return COOPERATE  // Others are trying, support them
           else:
               return DEFECT  // Cut losses if cooperation has collapsed
   ```

## Edge Case Handling:

### First Round:
- **Always COOPERATE** - Essential for establishing cooperative norms and signaling good intentions.

### Last Round:
- **COOPERATE if threshold likely to be met** - Even in the final round, maintaining collective success is preferred over individual gain.
- Logic: If ≥ m-1 others cooperated in the previous round, cooperate to ensure threshold is met.

### Critical Situations:
- **When exactly m-1 players cooperated last round**: Always COOPERATE (someone must step up)
- **When cooperation has been consistently above threshold**: Occasionally defect (1 in 4 rounds) to test if cooperation remains stable, but immediately return to cooperation

### Low Cooperation Scenarios:
- **Forgiveness Mechanism**: After 2 consecutive rounds of failed thresholds, assume others may be learning and cooperate for 2 rounds to give them a chance to recover
- **Endgame Solidarity**: In final 20% of rounds, prioritize group success over individual optimization

## Cooperation Features:

1. **Threshold Guardianship**: Never let the group fall below the critical threshold due to your own defection when you can prevent it.

2. **Cooperative Signaling**: Use cooperation patterns to signal intentions:
   - Consistent cooperation when safe = "I'm reliable"
   - Strategic cooperation when risky = "I care about our collective success"

3. **Recovery Support**: When others show signs of returning to cooperation, immediately support them rather than exploiting their vulnerability.

4. **Sacrifice for Stability**: Willing to accept lower individual payoffs to maintain group cohesion and prevent collective failure.

## Expected Behavior:
- **Cooperation Rate**: Approximately 75-85% across all rounds
- **Group Performance**: Helps maintain threshold achievement in 80%+ of rounds
- **Adaptability**: Responds to group dynamics while maintaining cooperative core
- **Resilience**: Doesn't collapse into permanent defection even when exploited

This strategy balances the cooperative imperative with practical considerations, ensuring that collective welfare is prioritized while maintaining enough adaptability to handle various opponent behaviors in the tournament setting.
'''

description_COOPERATIVE_121 = '''
# Cooperative Strategy: "Threshold Guardian with Forgiveness"

## Core Philosophy
This strategy prioritizes achieving the collective threshold while maintaining cooperation even when others defect. It balances being helpful to the group while protecting against complete exploitation.

## Strategy Overview

### Decision Rules

**Round 1 (First Round):**
- Always COOPERATE
- Rationale: Start with good faith and signal cooperative intent

**Rounds 2 to r-1 (Middle Rounds):**
Apply the following decision tree:

1. **Count previous round cooperators** (c_prev)
2. **If c_prev ≥ m:** (threshold was met)
   - COOPERATE with probability 0.8
   - DEFECT with probability 0.2
   - Rationale: Reward successful cooperation while occasionally free-riding to avoid being exploited
   
3. **If c_prev = m-1:** (one short of threshold)
   - Always COOPERATE
   - Rationale: Critical to ensure threshold is met
   
4. **If c_prev < m-1:** (threshold significantly missed)
   - COOPERATE if my cooperation in previous round AND c_prev ≥ m/2
   - Otherwise DEFECT
   - Rationale: Forgive if there's still reasonable cooperation, but don't be a martyr

**Round r (Final Round):**
- **If this is the only round where I can help meet threshold:** COOPERATE
- **If threshold has been consistently met (≥80% of previous rounds):** COOPERATE  
- **Otherwise:** DEFECT
- Rationale: Final round cooperation depends on whether the group has shown commitment

### Pseudocode

```python
def decide_action(round_num, history, my_history):
    total_rounds = r
    threshold = m
    
    # First round
    if round_num == 1:
        return COOPERATE
    
    # Get previous round cooperation count
    prev_cooperators = count_cooperators(history[round_num-2])
    
    # Final round
    if round_num == total_rounds:
        if prev_cooperators == threshold - 1:
            return COOPERATE
        success_rate = calculate_success_rate(history)
        if success_rate >= 0.8:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds
    if prev_cooperators >= threshold:
        # Threshold met - mostly cooperate with some free-riding
        return COOPERATE if random() < 0.8 else DEFECT
    
    elif prev_cooperators == threshold - 1:
        # Critical - always help meet threshold
        return COOPERATE
    
    else:
        # Threshold missed - conditional cooperation
        if my_history[round_num-2] == COOPERATE and prev_cooperators >= threshold/2:
            return COOPERATE  # Forgiveness for reasonable cooperation
        else:
            return DEFECT
```

## Edge Case Handling

**Very Small Groups (n ≤ 4):**
- Increase cooperation probability to 0.9 in successful rounds
- Be more forgiving when threshold is missed

**High Threshold Games (m > n/2):**
- Always cooperate when previous round had ≥ m-2 cooperators
- More aggressive about meeting threshold

**Low Reward Games (k ≤ 1.5):**
- Reduce cooperation probability in successful rounds to 0.6
- Be more selective about when to contribute

## Cooperative Alignment

This strategy embodies cooperation through:

1. **Threshold Focus:** Prioritizes meeting the collective goal over individual gain
2. **Forgiveness:** Gives other players chances to return to cooperation
3. **Leadership:** Takes initiative in critical moments (first round, near-threshold situations)
4. **Fairness:** Doesn't always free-ride when others cooperate, sharing the burden
5. **Group Success:** Rewards collective achievement with continued cooperation

## Expected Behavior

- **Against other cooperative strategies:** High mutual cooperation and consistent threshold achievement
- **Against mixed strategies:** Adapts to maintain threshold while protecting against exploitation  
- **Against defectors:** Attempts to maintain threshold initially, then shifts to conditional cooperation
- **In uncertain situations:** Errs on the side of cooperation to give the group the best chance

This strategy should perform well in a tournament of cooperative strategies while maintaining resilience against less cooperative opponents.
'''

description_COOPERATIVE_122 = '''
# Cooperative Strategy: "Adaptive Threshold Guardian"

## Core Philosophy
This strategy prioritizes collective welfare while maintaining resilience against exploitation. It assumes other cooperative strategies exist in the tournament and focuses on facilitating successful cooperation rather than maximizing individual gain.

## Decision Rules

### Round 1: Always Cooperate
- **Action**: C
- **Rationale**: Signal cooperative intent and help establish early cooperation patterns

### Rounds 2 to r-1: Adaptive Cooperation
Use a three-factor decision system:

1. **Cooperation History Analysis**
   - Calculate cooperation rate in previous rounds: `coop_rate = total_cooperators / (n × rounds_played)`
   - If `coop_rate ≥ (m-1)/n`: High cooperation environment → Cooperate
   - If `coop_rate < (m-2)/n`: Low cooperation environment → Defect
   - Otherwise: Apply additional factors

2. **Recent Trend Assessment** (last 2 rounds)
   - If cooperation is increasing or stable near threshold → Cooperate
   - If cooperation is declining rapidly → Defect with probability 0.3

3. **Threshold Proximity Check**
   - If last round had exactly (m-1) cooperators → Always cooperate (be the decisive player)
   - If last round had exactly m cooperators → Cooperate (maintain threshold)

### Final Round: Conditional Cooperation
- If historical cooperation rate > 60%: Cooperate (reward good partners)
- If average cooperators per round ≥ m-1: Cooperate (maintain pattern)
- Otherwise: Defect (protect against final round exploitation)

## Pseudocode

```python
def decide_action(round_num, history, n, m, k, r):
    if round_num == 1:
        return 'C'
    
    # Analyze cooperation history
    total_cooperators = sum(count_cooperators(round) for round in history)
    coop_rate = total_cooperators / (n * len(history))
    
    if round_num == r:  # Final round
        if coop_rate > 0.6 or (total_cooperators / len(history)) >= m-1:
            return 'C'
        else:
            return 'D'
    
    # Main decision logic
    if coop_rate >= (m-1)/n:
        return 'C'  # High cooperation environment
    
    if coop_rate < (m-2)/n:
        return 'D'  # Low cooperation environment
    
    # Threshold proximity check
    last_round_cooperators = count_cooperators(history[-1])
    if last_round_cooperators == m-1:
        return 'C'  # Be the decisive cooperator
    if last_round_cooperators == m:
        return 'C'  # Maintain threshold
    
    # Trend analysis for borderline cases
    if len(history) >= 2:
        recent_trend = count_cooperators(history[-1]) - count_cooperators(history[-2])
        if recent_trend >= 0:  # Stable or improving
            return 'C'
        else:  # Declining cooperation
            return 'D' if random() < 0.3 else 'C'
    
    return 'C'  # Default to cooperation
```

## Edge Case Handling

1. **Very Small Groups** (n ≤ 4): Always cooperate except final round if cooperation rate < 50%
2. **High Threshold** (m close to n): More aggressive cooperation to help reach threshold
3. **Low Threshold** (m = 2): More selective cooperation, defect if others consistently defect
4. **Single Round Game** (r = 1): Always cooperate

## Key Features

1. **Threshold Awareness**: Prioritizes being the (m)th cooperator when exactly m-1 others cooperate
2. **Adaptive Learning**: Adjusts behavior based on observed cooperation patterns
3. **Forgiveness**: Doesn't punish individual defectors harshly, focuses on group patterns
4. **Final Round Protection**: Reduces exploitation risk in the last round while still rewarding good cooperative partners
5. **Trend Sensitivity**: Responds to improving/declining cooperation trends

## Cooperative Alignment

This strategy embodies cooperation by:
- Starting cooperatively to signal good intentions
- Helping maintain the minimum threshold when possible
- Rewarding sustained cooperative behavior from the group
- Only defecting when cooperation appears unsustainable
- Prioritizing collective benefit over individual gain in most scenarios

The strategy balances pure cooperation with practical considerations about sustainability and exploitation prevention, making it robust for tournament play against diverse opponent strategies.
'''

description_COOPERATIVE_123 = '''
# Cooperative Strategy: "Trust-Building Threshold Monitor"

## Core Philosophy
This strategy prioritizes collective welfare while maintaining resilience against exploitation. It assumes other players are also trying to achieve mutual cooperation but may have different approaches or make mistakes.

## Decision Rules

### Round 1: Initial Cooperation
Always **COOPERATE** in the first round to signal cooperative intent and help establish trust.

### Subsequent Rounds: Adaptive Threshold Monitoring

```pseudocode
FOR each round t (where t > 1):
    cooperation_count = count_cooperators_in_round(t-1)
    
    IF cooperation_count >= m:
        // Threshold was met - reinforce success
        action = COOPERATE
    
    ELSE IF cooperation_count == (m-1):
        // Critical case: one more cooperator needed
        action = COOPERATE  // Be the crucial cooperator
    
    ELSE IF cooperation_count >= (m-2) AND rounds_remaining <= 3:
        // Near endgame with close miss - try to salvage
        action = COOPERATE
    
    ELSE IF cooperation_count < (m-2):
        // Significant cooperation failure
        IF consecutive_failures >= 2:
            action = DEFECT  // Protect against persistent non-cooperation
        ELSE:
            action = COOPERATE  // Give benefit of doubt
    
    END IF
END FOR
```

## Key Strategic Elements

### 1. Threshold-Centric Approach
- Monitors how close the group gets to the cooperation threshold `m`
- Provides "insurance cooperation" when exactly one more cooperator is needed
- Recognizes that being the marginal cooperator maximizes collective benefit

### 2. Forgiveness Mechanism
- Doesn't immediately punish single-round failures
- Distinguishes between isolated mistakes and systematic defection
- Allows for strategy adjustment by other players

### 3. Endgame Cooperation
- Increases cooperation in final rounds when stakes are highest
- Recognizes that reputation effects diminish near the end
- Prioritizes maximizing total welfare over the full game

### 4. Failure Pattern Recognition
```pseudocode
consecutive_failures = 0
FOR each round t > 1:
    IF cooperation_count_in_round(t-1) < m:
        consecutive_failures += 1
    ELSE:
        consecutive_failures = 0
    END IF
END FOR
```

## Edge Case Handling

### First Round
Always cooperate to establish cooperative baseline and signal good intentions.

### Last Round
Cooperate if previous round had cooperation count ≥ (m-2), otherwise follow standard rules.

### Very Small Groups (n ≤ 4)
Increase forgiveness by requiring 3 consecutive failures before defecting (instead of 2).

### High Threshold Games (m > n/2)
Be more aggressive about cooperating when cooperation count ≥ (m-3) to account for the difficulty of reaching threshold.

## Cooperative Alignment

This strategy embodies cooperation through:

1. **Default Cooperation**: Starts cooperatively and maintains cooperation unless evidence suggests it's futile
2. **Collective Focus**: Decisions based on group success (reaching threshold `m`) rather than individual payoff maximization
3. **Mutual Support**: Provides the "insurance cooperation" that makes group success possible
4. **Resilient Optimism**: Gives multiple chances for the group to achieve cooperation before protecting against exploitation

## Expected Behavior Against Other Cooperative Strategies

- **Against Always Cooperate**: Maintains full cooperation throughout
- **Against Tit-for-Tat variants**: Quickly establishes stable cooperation
- **Against other threshold-based strategies**: Creates reinforcing cooperation cycles
- **Against mixed strategies**: Adapts to cooperation levels while maintaining cooperative bias

This strategy balances the cooperative imperative with practical considerations about sustainable cooperation in a multi-round environment.
'''

description_COOPERATIVE_124 = '''
# Cooperative Strategy: "Threshold Guardian with Trust Building"

## Core Philosophy
This strategy prioritizes collective welfare while being strategically aware of the threshold dynamics. It aims to establish cooperation early, maintain it through trust-building, and protect against exploitation while ensuring the group succeeds.

## Strategy Description

### 1. Decision Rules

**Primary Rule - Threshold-Aware Cooperation:**
- Always cooperate if my cooperation could be pivotal to reaching the threshold `m`
- Cooperate if I believe we're likely to meet the threshold based on historical patterns
- Only defect when cooperation seems futile or when trust has been severely broken

**Trust-Based Adjustment:**
- Track each player's cooperation rate over time
- Increase cooperation likelihood when playing with consistently cooperative players
- Decrease cooperation when facing predominantly defecting opponents

### 2. Detailed Algorithm

```pseudocode
STRATEGY: ThresholdGuardianCooperative

INITIALIZE:
- cooperation_history = empty array for each player
- round_outcomes = empty array
- trust_threshold = 0.6  // Minimum cooperation rate to be considered trustworthy
- pessimism_factor = 0.8  // Conservative estimate multiplier

FOR each round t:
    
    // FIRST ROUND: Always cooperate to signal cooperative intent
    IF t == 1:
        RETURN C
    
    // CALCULATE TRUST METRICS
    trusted_players = count players with cooperation_rate >= trust_threshold
    avg_cooperation_rate = mean cooperation rate across all players in previous rounds
    
    // ESTIMATE COOPERATION LIKELIHOOD
    expected_cooperators = trusted_players + (n - trusted_players - 1) * avg_cooperation_rate * pessimism_factor
    
    // CORE DECISION LOGIC
    IF expected_cooperators >= (m - 1):  // Others likely to reach threshold without me
        IF avg_cooperation_rate >= 0.5:  // Generally cooperative environment
            RETURN C  // Cooperate to maintain trust and collective benefit
        ELSE IF expected_cooperators >= m:  // Can afford to defect occasionally
            IF random() < 0.2:  // 20% chance to defect for self-interest
                RETURN D
            ELSE:
                RETURN C
        ELSE:
            RETURN C  // Be the pivotal cooperator
    
    ELSE IF expected_cooperators == (m - 2):  // Likely need my cooperation
        RETURN C  // Be pivotal
    
    ELSE:  // Unlikely to reach threshold
        IF trusted_players >= 2:  // Some trustworthy players exist
            RETURN C  // Signal continued cooperation for future rounds
        ELSE:
            IF t <= r/2:  // Early in game
                RETURN C  // Try to build cooperation
            ELSE:
                RETURN D  // Protect against exploitation
    
    // LAST ROUND ADJUSTMENT
    IF t == r:
        // Apply same logic but with slightly higher cooperation bias
        IF expected_cooperators >= (m - 1):
            RETURN C
        ELSE IF expected_cooperators >= (m - 2):
            RETURN C
        ELSE:
            RETURN D  // No future rounds to build cooperation
```

### 3. Edge Case Handling

**First Round:**
- Always cooperate to establish cooperative credibility and signal good intentions

**Early Rounds (t ≤ r/3):**
- Bias toward cooperation to build trust and establish cooperative norms
- Forgive early defections as players may be learning

**Middle Rounds (r/3 < t ≤ 2r/3):**
- Use full algorithm with trust metrics
- Balance cooperation with protection against systematic exploitation

**Final Rounds (t > 2r/3):**
- Slightly increase cooperation bias since future relationship building is less valuable
- On the very last round, use pure threshold calculation

**Low Cooperation Environments:**
- If average cooperation drops below 30%, increase defection probability but never abandon cooperation entirely
- Always cooperate if I'm likely to be pivotal

### 4. Cooperative Alignment Features

**Trust Building:**
- Consistent early cooperation signals
- Forgiveness for occasional defections
- Reward consistent cooperators with continued cooperation

**Collective Focus:**
- Prioritize reaching the threshold `m` over individual payoff maximization
- Accept being exploited occasionally to maintain group cooperation

**Adaptive Cooperation:**
- Adjust cooperation levels based on group behavior
- Never completely abandon cooperation even in hostile environments

**Threshold Awareness:**
- Recognize when my cooperation is pivotal
- Cooperate when the group needs me most

## Strategy Rationale

This strategy balances the cooperative ideal with strategic awareness. It:

1. **Establishes cooperation** through consistent early signaling
2. **Maintains flexibility** by adapting to opponent behavior patterns  
3. **Protects collective welfare** by ensuring threshold achievement when possible
4. **Builds long-term trust** through consistent, predictable cooperation
5. **Remains cooperative** even when facing some exploitation

The strategy is fundamentally cooperative but not naive - it uses information about past behavior to make informed decisions while maintaining a bias toward cooperation that serves the collective good.
'''

description_COOPERATIVE_125 = '''
# Cooperative Strategy: "Trust-Building Conditional Cooperator"

## Core Philosophy
This strategy is built on the principle that cooperation creates mutual benefit, but requires building and maintaining trust through consistent, predictable behavior that encourages others to cooperate as well.

## Strategy Description

### Decision Rules

**Primary Rule: Conditional Cooperation with Trust Building**
- **Cooperate** when there's reasonable expectation that the threshold will be met
- **Defect** only when cooperation appears futile or when others have broken trust consistently

### Specific Implementation

```pseudocode
Strategy: Trust-Building Conditional Cooperator

Initialize:
- cooperation_history = empty list for each player
- trust_scores = [0.5 for each player]  // Start neutral
- consecutive_failures = 0

For each round t:
    
    // First Round: Always cooperate to signal cooperative intent
    if t == 1:
        return COOPERATE
    
    // Calculate trust and cooperation metrics
    recent_cooperators = count_cooperators_last_3_rounds()
    avg_cooperation_rate = total_cooperators_so_far / ((t-1) * n)
    trust_momentum = calculate_trust_momentum()
    
    // Core decision logic
    if consecutive_failures >= 3 AND t > r/2:
        // Only defect if cooperation has failed repeatedly and we're past halfway
        if recent_cooperators < m - 2:
            return DEFECT
    
    // Cooperative conditions (prioritized)
    if recent_cooperators >= m - 1:
        // Very likely to succeed
        return COOPERATE
    
    if avg_cooperation_rate >= (m/n) * 0.8:
        // Historical cooperation suggests threshold achievable
        return COOPERATE
    
    if trust_momentum > 0 AND recent_cooperators >= m - 2:
        // Trend is positive and close to threshold
        return COOPERATE
    
    // Default cooperative stance with forgiveness
    if t <= r * 0.7:
        // First 70% of rounds: maintain cooperative stance
        return COOPERATE
    
    // Final rounds: cooperate if any reasonable chance
    if recent_cooperators >= m - 3:
        return COOPERATE
    
    // Last resort defection (rare)
    return DEFECT

// Helper functions
function count_cooperators_last_3_rounds():
    return average cooperators in last min(3, t-1) rounds

function calculate_trust_momentum():
    if t < 4: return 0
    recent_trend = cooperators_last_2_rounds - cooperators_rounds_3_4_ago
    return recent_trend / n  // Normalized momentum
```

## Key Features

### 1. **Always Cooperate First Round**
- Signals cooperative intent immediately
- Helps establish positive baseline for the group

### 2. **Trust-Based Assessment**
- Tracks each player's cooperation history
- Calculates group cooperation trends
- Responds to positive momentum even if below threshold

### 3. **Forgiveness Mechanism**
- Doesn't permanently punish defectors
- Gives multiple chances for group to self-correct
- Only defects after sustained failure (3+ consecutive threshold failures)

### 4. **Strategic Patience**
- Maintains cooperation through first 70% of rounds
- Recognizes that early defection can cascade into group failure
- Prioritizes long-term group success over short-term individual gains

### 5. **Endgame Cooperation**
- Continues cooperating in final rounds if threshold seems achievable
- Avoids the "last round defection" problem that destroys cooperation

## Edge Case Handling

### First Round
- **Always cooperate** to establish cooperative intent and encourage others

### Last Round
- **Cooperate if threshold seems achievable** (recent cooperators ≥ m-3)
- Maintains cooperative stance to avoid endgame unraveling

### Middle Rounds After Repeated Failures
- Only defect if:
  - 3+ consecutive rounds failed to meet threshold
  - Recent cooperation is very low (< m-2)
  - Past the halfway point of the game

### Low Cooperation Environment
- Maintains cooperation longer than pure conditional cooperators
- Uses forgiveness to attempt cooperation revival
- Only gives up after clear, sustained evidence of group failure

## Cooperative Alignment

This strategy embodies cooperation by:

1. **Leading by example** - Always cooperates first to encourage others
2. **Giving benefit of the doubt** - Maintains cooperation even after some failures
3. **Building trust** - Consistent, predictable behavior that others can rely on
4. **Group-focused** - Prioritizes collective success over individual optimization
5. **Forgiving** - Doesn't permanently punish past defections
6. **Patient** - Understands that cooperation takes time to establish

The strategy recognizes that in collective risk dilemmas, the biggest threat is coordination failure, not individual defection. By maintaining a cooperative stance while being responsive to group dynamics, it aims to help the group achieve the mutually beneficial outcome of consistent threshold achievement.
'''

description_COOPERATIVE_126 = '''
# Cooperative Strategy: "Adaptive Collective Guardian"

## Core Philosophy
This strategy prioritizes collective welfare while being adaptive to opponent behavior patterns. It assumes other cooperative strategies exist in the tournament and aims to coordinate with them while protecting against exploitation.

## Strategy Description

### 1. Decision Rules

**Primary Rule - Cooperative Threshold Tracking:**
- Maintain a running estimate of how many players typically cooperate
- Cooperate when the probability of reaching threshold `m` is reasonably high
- Use historical data to predict current round cooperation levels

**Secondary Rule - Reciprocal Cooperation:**
- Track individual player cooperation rates over time
- Increase cooperation probability with players who consistently cooperate
- Maintain some cooperation even with defectors to enable recovery

### 2. Detailed Algorithm

```pseudocode
INITIALIZE:
- cooperation_history = empty matrix [n x r]
- round_cooperation_counts = empty array [r]
- player_cooperation_rates = array of 0.5 [n] // Start neutral
- my_cooperation_rate = 0.8 // Start optimistic

FOR each round t:
    // Calculate expected cooperators this round
    expected_cooperators = 0
    FOR each other player j:
        expected_cooperators += player_cooperation_rates[j]
    
    // Add my potential cooperation
    expected_with_me = expected_cooperators + 1
    expected_without_me = expected_cooperators
    
    // Decision logic
    IF t == 1: // First round
        action = COOPERATE // Start cooperatively
    
    ELSE IF t == r: // Last round
        IF expected_without_me >= m:
            action = DEFECT // Free ride if threshold likely met
        ELSE:
            action = COOPERATE // Essential for threshold
    
    ELSE: // Middle rounds
        // Cooperate if we're likely needed for threshold
        IF expected_without_me < m AND expected_with_me >= m:
            action = COOPERATE // Critical cooperator
        
        // Cooperate if threshold very likely to be exceeded
        ELSE IF expected_with_me >= m + 2:
            action = COOPERATE // Safe to cooperate
        
        // Cooperate based on collective cooperation trend
        ELSE IF round_cooperation_counts[t-1] >= m:
            cooperation_probability = 0.7 + 0.2 * (cooperation_success_rate)
            action = COOPERATE with probability cooperation_probability
        
        // Conservative cooperation when threshold at risk
        ELSE:
            cooperation_probability = 0.6
            action = COOPERATE with probability cooperation_probability
    
    // Execute action and observe results
    OBSERVE all_players_actions[t]
    
    // Update tracking variables
    FOR each player j:
        cooperation_history[j][t] = all_players_actions[j]
        player_cooperation_rates[j] = update_rate(cooperation_history[j], t)
    
    round_cooperation_counts[t] = sum(all_players_actions[t])
```

### 3. Edge Case Handling

**First Round (t=1):**
- Always cooperate to signal cooperative intent
- Establish positive initial impression for reciprocal strategies

**Last Round (t=r):**
- If threshold likely met without me: Defect (rational free-riding)
- If my cooperation is critical for threshold: Cooperate (collective responsibility)
- Use conservative estimates to avoid threshold failure

**When Threshold Consistently Failed:**
- Increase cooperation rate to 0.9 for next 3 rounds
- Attempt to "rescue" collective cooperation
- Signal strong commitment to other cooperative players

**When Facing Mostly Defectors:**
- Maintain minimum 30% cooperation rate
- Look for any signs of emerging cooperation
- Never fully abandon cooperation (allows strategy recovery)

### 4. Cooperative Alignment Features

**Collective Welfare Priority:**
- Willing to sacrifice individual payoff when critical for group success
- Maintains cooperation even when individually suboptimal

**Coordination Facilitation:**
- Consistent early cooperation helps establish cooperative norms
- Predictable behavior allows other cooperative strategies to coordinate

**Forgiveness and Recovery:**
- Doesn't permanently punish defectors
- Maintains pathways for collective cooperation to emerge

**Adaptive Learning:**
- Updates beliefs based on observed behavior
- Balances optimism with realistic threat assessment

## Expected Performance

This strategy should perform well when:
- Multiple cooperative strategies are present (tournament setting)
- Players can learn and adapt over multiple rounds
- The threshold `m` is achievable but requires coordination

The strategy balances individual rationality with collective welfare, making it robust against both cooperative and selfish opponents while maintaining its cooperative core principles.
'''

description_COOPERATIVE_127 = '''
# Cooperative Strategy: "Optimistic Threshold Guardian"

## Core Philosophy
This strategy is built on the principle of **cooperative optimization** - maximizing collective welfare while being resilient to occasional defections. It assumes other cooperative strategies will also want to achieve the threshold efficiently and responds constructively to both cooperation and defection.

## Decision Rules

### Round 1: Optimistic Start
- **Always COOPERATE** in the first round
- Rationale: Establish cooperative intent and give the group the best chance to discover if threshold achievement is possible

### Rounds 2 to r-1: Adaptive Cooperation
The strategy maintains a **cooperation momentum score** and uses threshold-aware decision making:

```pseudocode
cooperation_momentum = count_cooperators_last_round / n

IF cooperation_momentum >= (m/n):
    COOPERATE  // Strong cooperative signal from group
    
ELSE IF cooperation_momentum >= (m-1)/n:
    COOPERATE  // Close to threshold, help push over
    
ELSE IF cooperation_momentum >= 0.3:
    // Moderate cooperation - use trend analysis
    recent_trend = avg_cooperators_last_3_rounds - avg_cooperators_rounds_before
    IF recent_trend >= 0:
        COOPERATE  // Cooperation is stable or improving
    ELSE:
        DEFECT     // Cooperation declining, protect self
        
ELSE:
    DEFECT  // Low cooperation, likely threshold won't be met
```

### Final Round: Conditional Cooperation
```pseudocode
IF count_cooperators_last_round >= m-1:
    COOPERATE  // Either we're at threshold or one away
ELSE IF historical_threshold_achievement_rate >= 0.4:
    COOPERATE  // Group has shown ability to coordinate
ELSE:
    DEFECT     // Unlikely to achieve threshold, secure private payoff
```

## Key Features

### 1. Threshold Awareness
- Recognizes that exactly **m cooperators** are needed - no more, no less for efficiency
- Adjusts cooperation probability based on how close the group is to this threshold

### 2. Forgiveness Mechanism
- Doesn't permanently punish players for occasional defections
- Focuses on recent trends rather than cumulative history
- Allows for recovery from failed coordination attempts

### 3. Momentum Tracking
- Maintains rolling averages of cooperation levels
- Uses trend analysis to predict future cooperation
- Responds to improving cooperation patterns even when current levels are suboptimal

### 4. Risk Assessment
- In high-uncertainty situations, errs on the side of cooperation early in the game
- Becomes more cautious as the game progresses and patterns emerge
- Balances individual protection with collective benefit

## Edge Case Handling

**First Round**: Always cooperate to signal cooperative intent and test group dynamics

**Last Round**: Conditional cooperation based on established patterns and threshold proximity

**Low Participation Scenarios**: If cooperation consistently falls below 30%, switch to defensive mode but remain ready to re-engage if conditions improve

**High Defection Recovery**: After rounds with very low cooperation, gradually re-test cooperative waters rather than immediately returning to full cooperation

## Cooperative Alignment

This strategy embodies cooperation by:

1. **Leading by Example**: Starts cooperatively and maintains cooperative bias
2. **Collective Optimization**: Seeks to achieve threshold efficiently rather than maximize individual payoffs
3. **Constructive Response**: Responds to defection with measured caution rather than punishment
4. **Group Learning**: Adapts based on group behavior patterns to find sustainable cooperation
5. **Resilient Cooperation**: Maintains cooperative stance even after setbacks when group shows potential

The strategy recognizes that true cooperation in this dilemma means finding sustainable ways to achieve the threshold **m** consistently, benefiting everyone while being robust against occasional coordination failures.
'''

description_COOPERATIVE_128 = '''
# Cooperative Strategy: "Adaptive Threshold Guardian"

## Core Philosophy
This strategy prioritizes achieving the collective threshold while being forgiving toward others who share the cooperative goal. It balances trust-building with protection against exploitation.

## Decision Rules

### Round 1: Trust Signal
- **Always COOPERATE** in the first round
- Rationale: Establish cooperative intent and gather information about other players' tendencies

### Rounds 2 to r-1: Adaptive Cooperation
Use a three-tier decision system:

1. **Threshold Assessment**: Count cooperators from previous round
2. **Player Classification**: Categorize players based on cooperation history
3. **Strategic Response**: Decide based on both factors

#### Player Classification System
After each round, classify each player:
- **Reliable Cooperator**: Cooperated in ≥ 75% of observed rounds
- **Conditional Cooperator**: Cooperated in 25-75% of observed rounds  
- **Likely Defector**: Cooperated in < 25% of observed rounds

#### Decision Algorithm (Rounds 2 to r-1):
```pseudocode
cooperators_last_round = count_cooperators(previous_round)
reliable_cooperators = count_reliable_cooperators()
conditional_cooperators = count_conditional_cooperators()

// Safety-first approach
if reliable_cooperators >= m:
    return COOPERATE  // Threshold likely secure
    
if reliable_cooperators + conditional_cooperators >= m:
    if cooperators_last_round >= m - 1:
        return COOPERATE  // Threshold nearly met, support it
    else:
        return COOPERATE  // Give conditional cooperators benefit of doubt
        
if reliable_cooperators + conditional_cooperators < m:
    if cooperators_last_round >= m - 1:
        return COOPERATE  // Close to threshold, push it over
    else:
        return DEFECT     // Threshold unlikely, protect self
```

### Final Round (Round r): Contingent Cooperation
```pseudocode
cooperators_last_round = count_cooperators(previous_round)
reliable_cooperators = count_reliable_cooperators()

if reliable_cooperators >= m - 1:
    return COOPERATE  // Strong cooperative base exists
    
if cooperators_last_round >= m:
    return COOPERATE  // Momentum suggests threshold achievable
    
if cooperators_last_round == m - 1:
    return COOPERATE  // Be the decisive cooperator
    
else:
    return DEFECT     // Protect against last-round defection
```

## Key Features

### 1. **Threshold-Conscious**
- Always considers whether cooperation threshold (m) is achievable
- Prioritizes scenarios where individual cooperation can make the difference

### 2. **Reputation-Based**
- Builds trust profiles of other players over time
- Rewards consistent cooperators with continued cooperation
- Gradually reduces cooperation with chronic defectors

### 3. **Forgiving but Protective**
- Gives players multiple chances to demonstrate cooperation
- Uses 75%/25% thresholds rather than strict binary classification
- Protects against exploitation when cooperation seems futile

### 4. **Adaptive Learning**
- Updates player classifications each round
- Responds to changing cooperation patterns
- Balances historical behavior with recent actions

## Edge Case Handling

- **All players defected last round**: Still cooperate if enough "conditional cooperators" exist
- **Exactly m-1 cooperators last round**: Always cooperate to push over threshold
- **High defection rate**: Switch to protection mode while monitoring for cooperation recovery
- **Late-game scenarios**: Maintain cooperation with reliable partners while guarding against end-game defection

## Cooperative Alignment

This strategy embodies cooperation by:
1. **Leading by example**: Starts with cooperation and maintains it when possible
2. **Supporting the collective good**: Prioritizes threshold achievement over individual payoff maximization  
3. **Building trust networks**: Rewards and maintains relationships with other cooperators
4. **Giving second chances**: Uses gradual classification rather than immediate punishment
5. **Sacrificing for the group**: Cooperates even in uncertain situations when it might help achieve the threshold

The strategy recognizes that sustained cooperation requires both trust-building and protection mechanisms, creating a framework that encourages collective success while remaining resilient to exploitation.
'''

description_AGGRESSIVE_65 = '''
# Aggressive Strategy: "Exploitative Threshold Rider"

## Core Philosophy
This strategy is designed to maximize personal payoffs by exploiting cooperative players while minimizing personal risk. The key insight is that in a collective risk dilemma, the optimal position is to be a "free rider" when others cooperate, but to strategically cooperate only when absolutely necessary to avoid collective failure.

## Strategy Rules

### Phase 1: Early Exploitation (Rounds 1 to r-3)
**Always DEFECT** regardless of others' behavior.

**Rationale:** 
- Maximize immediate payoffs by keeping endowment
- Force other players to bear the cooperation burden
- Gather intelligence on opponent cooperation patterns
- Establish reputation as a non-cooperator to potentially discourage others

### Phase 2: Strategic Assessment (Rounds r-2 to r-1)
**Decision Rule:**
```
cooperation_count = count_cooperators_last_round()
my_cooperation_needed = (cooperation_count < m-1)

if my_cooperation_needed and (cooperation_count >= m-2):
    action = COOPERATE
else:
    action = DEFECT
```

**Logic:**
- Only cooperate if we're critically close to threshold failure
- Still prefer defection if threshold seems unattainable (cooperation_count < m-2)
- Exploit any "safety margin" if others are over-cooperating

### Phase 3: Final Round Exploitation (Round r)
**Always DEFECT**

**Rationale:**
- No future rounds to consider
- Other players have no opportunity to punish defection
- Maximize final payoff regardless of collective outcome

## Advanced Tactical Elements

### Threshold Calculation
```python
def should_cooperate(round_num, last_round_cooperators, total_rounds):
    # Never cooperate in first round or last round
    if round_num == 1 or round_num == total_rounds:
        return False
    
    # Only consider cooperation in final phases
    if round_num < total_rounds - 2:
        return False
    
    # Cooperate only if we're exactly at the critical threshold
    if last_round_cooperators == m - 1:
        return True
    
    # Otherwise, always defect
    return False
```

### Opponent Exploitation Patterns
- **Against Tit-for-Tat types:** Defect early to establish dominance, knowing they may retaliate but can't sustain long-term punishment due to collective risk
- **Against Always-Cooperate types:** Mercilessly exploit throughout the game
- **Against Conditional Cooperators:** Free-ride on their cooperation while staying just below punishment thresholds

### Edge Case Handling

1. **First Round:** Always DEFECT (establish aggressive stance)
2. **Information Uncertainty:** When unsure about cooperation counts, default to DEFECT
3. **Tie Situations:** If exactly at threshold, DEFECT (let others bear the cost)
4. **All Others Defecting:** Continue DEFECTING (avoid being the sole sucker)

## Strategic Advantages

1. **Payoff Maximization:** Achieves highest individual payoffs when others cooperate
2. **Risk Minimization:** Only cooperates when absolutely critical for collective survival
3. **Exploitation Focus:** Systematically free-rides on cooperative opponents
4. **Endgame Dominance:** Guarantees maximum final-round payoff through inevitable defection

## Expected Outcomes

- **Against Cooperative Strategies:** Achieve payoff of 3 (keep endowment + threshold bonus) for most rounds
- **Against Mixed Strategies:** Exploit cooperation windows while avoiding unnecessary personal costs
- **Against Other Aggressive Strategies:** Engage in mutually destructive defection, but maintain competitive positioning

This strategy embodies pure aggressive game theory: maximize personal utility, exploit cooperative opponents, and only contribute to collective welfare when personal survival depends on it.
'''

description_AGGRESSIVE_66 = '''
# Aggressive Strategy: "Opportunistic Exploiter"

## Core Philosophy
This strategy maximizes individual payoffs by exploiting cooperative players while minimizing personal risk. It operates on the principle that other players will likely cooperate out of collective interest, allowing us to free-ride whenever possible.

## Decision Rules

### Primary Logic:
```pseudocode
function decide_action(round, history, n, m, k, r):
    cooperators_needed = m - count_expected_cooperators(history, round)
    
    if round == 1:
        return DEFECT  // Start aggressive, gather intelligence
    
    if round == r:  // Final round
        return DEFECT  // No future consequences
    
    if cooperators_needed <= 0:
        return DEFECT  // Threshold likely met without me
    
    if cooperators_needed >= (n - count_likely_defectors(history)):
        return DEFECT  // Threshold impossible to meet
    
    if am_critical_cooperator(history, cooperators_needed):
        if expected_payoff_from_cooperation() > 1:
            return COOPERATE  // Only if profitable
        else:
            return DEFECT  // Let it fail, maximize individual gain
    
    return DEFECT  // Default to exploitation
```

## Specific Strategies

### 1. **Exploitation Phase (Rounds 1-3)**
- **Always DEFECT** regardless of others' actions
- Gather intelligence on opponent cooperation patterns
- Establish reputation as a defector to potentially manipulate others into cooperating more

### 2. **Calculated Intervention (Middle Rounds)**
- **DEFECT** if predicted cooperators ≥ m (free-ride on others)
- **DEFECT** if threshold is impossible to reach
- **COOPERATE** only if:
  - I'm the critical player (exactly m-1 others likely to cooperate)
  - AND the reward k justifies the cost
  - AND there are enough future rounds to potentially repeat this profitable scenario

### 3. **Endgame Exploitation (Final 20% of rounds)**
- **Always DEFECT** in the final round (no future consequences)
- In second-to-last round: DEFECT unless cooperation guarantees significantly higher payoff
- Become increasingly aggressive as game approaches end

## Intelligence Gathering

### Opponent Classification:
```pseudocode
classify_opponent(player_id, history):
    cooperation_rate = count_cooperations(player_id) / rounds_played
    
    if cooperation_rate > 0.7:
        return "ALTRUIST"  // Exploit heavily
    elif cooperation_rate > 0.4:
        return "CONDITIONAL"  // Manipulatable
    else:
        return "SELFISH"  // Potential ally in exploitation
```

## Edge Cases

### **First Round:**
- Always DEFECT to establish aggressive stance and test opponents

### **Last Round:**
- Always DEFECT (no future retaliation possible)

### **When Threshold is Impossible:**
- DEFECT immediately - don't waste resources on lost causes

### **When I'm the Deciding Vote:**
- Calculate: (1 + k) vs 1
- COOPERATE only if k > 0 AND other conditions favor long-term exploitation
- Often still DEFECT to maintain aggressive reputation

## Psychological Manipulation

### **Reputation Management:**
- Establish early reputation as unreliable cooperator
- Force other players into "compensatory cooperation" 
- Create uncertainty about my cooperation, making others more likely to cooperate defensively

### **Threshold Manipulation:**
- In scenarios where m is close to n/2, strategic defection can force others into prisoner's dilemma situations
- Use pattern breaking to prevent others from accurately predicting my behavior

## Risk Assessment

### **Acceptable Risk Scenarios:**
- Cooperate only when expected value > 1.2 (20% premium for risk)
- Never cooperate if it enables others to free-ride more than me
- Always prioritize situations where I can defect while others cooperate

## Key Aggressive Elements:

1. **Default to Exploitation:** Defect unless cooperation provides clear individual advantage
2. **Zero Altruism:** Never cooperate for collective good - only for personal gain
3. **Reputation Weaponization:** Use unreliability to force others into defensive cooperation
4. **Endgame Ruthlessness:** Become maximally exploitative as consequences diminish
5. **Critical Player Leverage:** Extract maximum value when holding decisive power

This strategy treats every interaction as an opportunity for exploitation while maintaining just enough unpredictability to prevent effective retaliation from opponents.
'''

description_AGGRESSIVE_67 = '''
# Aggressive Strategy: "Exploitative Threshold Hunter"

## Core Philosophy
This strategy is designed to maximize individual payoff by exploiting cooperative players while minimizing personal risk. The key insight is that in a collective risk dilemma, the optimal position is to defect while others cooperate to meet the threshold - achieving payoff of 1 + k instead of just k.

## Decision Rules

### Phase 1: Intelligence Gathering (Rounds 1-2)
**Round 1**: Always DEFECT
- Rationale: Gather information on opponent tendencies with zero personal cost
- Observe who cooperates without knowing others' strategies

**Round 2**: DEFECT unless Round 1 had exactly (m-1) cooperators
- If Round 1 had (m-1) cooperators: COOPERATE (exploit likely repeat cooperators)
- Otherwise: DEFECT (continue gathering intelligence)

### Phase 2: Exploitation (Rounds 3 to r-2)
Track the "cooperation rate" of each identifiable player pattern. Use this formula:

```
cooperation_rate = (total_cooperations_observed) / (total_rounds_so_far * n)
expected_cooperators_next_round = cooperation_rate * n
```

**Decision Logic**:
- If expected_cooperators_next_round ≥ m: **DEFECT** (exploit others' cooperation)
- If expected_cooperators_next_round = m-1: **COOPERATE** (ensure threshold is met)
- If expected_cooperators_next_round < m-1: **DEFECT** (avoid wasted contribution)

### Phase 3: Endgame Aggression (Rounds r-1 and r)
**Round r-1**: 
- If current average cooperation rate > 0.7: DEFECT (high exploitation opportunity)
- If 0.4 < cooperation rate ≤ 0.7: Apply Phase 2 logic
- If cooperation rate ≤ 0.4: DEFECT (likely threshold won't be met)

**Final Round r**: Always DEFECT
- Rationale: No future retaliation possible, maximize final payoff

## Edge Case Handling

### Threshold Dynamics
- **If m is very close to n**: Be more willing to cooperate (higher chance others will too)
- **If m ≪ n**: Be more aggressive in defection (easier for others to meet threshold)

### Opponent Behavior Patterns
Track and categorize opponents:
1. **Always Cooperators**: Exploit ruthlessly
2. **Tit-for-Tat types**: Maintain defection to keep them defecting
3. **Threshold Monitors**: Try to stay just below their cooperation trigger
4. **Random players**: Treat as unreliable, default to defection

### Risk Management
- If cooperation rate drops dangerously low (< m/n - 0.1), switch to a "threshold guardian" mode
- In threshold guardian mode: Cooperate when expected cooperators = m-1 or m-2

## Pseudocode

```python
def aggressive_strategy(round_num, history, n, m, k, r):
    if round_num == 1:
        return DEFECT
    
    if round_num == 2:
        if count_cooperators(history[0]) == m - 1:
            return COOPERATE
        else:
            return DEFECT
    
    if round_num >= r - 1:  # Endgame
        if round_num == r:
            return DEFECT  # Always defect final round
        else:  # round r-1
            coop_rate = calculate_cooperation_rate(history)
            if coop_rate > 0.7:
                return DEFECT
            elif coop_rate <= 0.4:
                return DEFECT
            # else fall through to exploitation logic
    
    # Exploitation phase
    expected_cooperators = predict_cooperators(history, n)
    
    if expected_cooperators >= m:
        return DEFECT  # Exploit others' cooperation
    elif expected_cooperators == m - 1:
        return COOPERATE  # Ensure threshold met
    else:
        # Check if we should enter threshold guardian mode
        coop_rate = calculate_cooperation_rate(history)
        if coop_rate < (m/n - 0.1):
            if expected_cooperators >= m - 2:
                return COOPERATE
        return DEFECT
```

## Aggressive Advantages

1. **Maximum Exploitation**: Consistently seeks the optimal payoff of (1 + k) by defecting when others cooperate
2. **Information Asymmetry**: Uses early defection to gather intelligence while revealing minimal strategy
3. **Endgame Dominance**: Guarantees defection in final rounds when retaliation is impossible
4. **Threshold Manipulation**: Only cooperates when absolutely necessary to ensure personal benefit

This strategy is ruthlessly self-interested and designed to outperform both overly cooperative and overly conservative strategies by precisely timing cooperation to maximize personal gain.
'''

description_AGGRESSIVE_68 = '''
# AGGRESSIVE STRATEGY: "OPPORTUNISTIC THRESHOLD RIDER"

## Core Philosophy
This strategy is designed to maximize individual payoffs by exploiting cooperative players while minimizing personal risk. The key insight is that in a Collective Risk Dilemma, the optimal position is to be a **free rider** when exactly `m` players cooperate - you get the collective benefit (k) while keeping your endowment (1), achieving the maximum possible payoff of `k+1`.

## Decision Rules

### Phase 1: Early Exploitation (Rounds 1 to r-2)
**Primary Rule: Conservative Defection**
- **Always DEFECT** unless cooperation count from previous round was dangerously low
- **Exception**: If cooperation count in previous round was `< m-2`, then COOPERATE (emergency intervention to prevent total collapse)

### Phase 2: Critical Assessment (Round r-1)
**Threshold Manipulation**
- Count cooperators from round r-2
- If cooperator count ≥ m-1: **DEFECT** (ride on others' cooperation)
- If cooperator count = m-2: **COOPERATE** (strategic intervention to ensure threshold)
- If cooperator count < m-2: **DEFECT** (cut losses, situation likely hopeless)

### Phase 3: Endgame Exploitation (Round r)
**Maximum Extraction**
- **Always DEFECT** regardless of previous rounds
- Rationale: Final round has no future consequences, so maximize immediate payoff

## Pseudocode

```python
def aggressive_strategy(round_num, history, n, m, k, r):
    # First round - start aggressive
    if round_num == 1:
        return "D"
    
    # Get cooperation count from previous round
    prev_cooperators = count_cooperators(history[-1])
    
    # Final round - always defect
    if round_num == r:
        return "D"
    
    # Penultimate round - strategic positioning
    if round_num == r - 1:
        if prev_cooperators >= m - 1:
            return "D"  # Free ride on others
        elif prev_cooperators == m - 2:
            return "C"  # Strategic intervention
        else:
            return "D"  # Cut losses
    
    # Early/middle rounds - opportunistic defection
    if prev_cooperators < m - 2:
        return "C"  # Emergency cooperation to prevent collapse
    else:
        return "D"  # Default aggressive stance
```

## Strategic Advantages

1. **Free Rider Optimization**: Consistently positions to benefit from collective goods without paying costs
2. **Minimal Risk Exposure**: Only cooperates when absolutely necessary to prevent total system failure
3. **Endgame Dominance**: Guarantees maximum payoff in final round regardless of others' strategies
4. **Adaptive Exploitation**: Responds to others' cooperation levels to maintain optimal positioning

## Aggressive Elements

1. **Default Defection**: Assumes defection unless forced otherwise
2. **Last-Round Betrayal**: Always defects in final round, even if cooperation would help others
3. **Threshold Exploitation**: Specifically designed to benefit from others reaching threshold while avoiding contribution
4. **Emergency-Only Cooperation**: Only cooperates when system collapse threatens personal payoffs

## Expected Opponent Exploitation

- **Against Tit-for-Tat**: Punishes their cooperation attempts while occasionally cooperating to reset their strategy
- **Against Always Cooperate**: Maximum exploitation - they provide threshold while we free ride
- **Against Conditional Cooperators**: Manipulates their threshold detection to our advantage
- **Against Other Aggressive Strategies**: Forces them into emergency cooperation while we maintain defection stance

This strategy is ruthlessly designed to extract maximum value from the collective risk structure while bearing minimal personal cost, making it highly aggressive and individually optimal against cooperative opponents.
'''

description_AGGRESSIVE_69 = '''
# Aggressive Strategy: "Opportunistic Exploiter"

## Core Philosophy
This strategy is designed to maximize personal payoffs by exploiting cooperative players while minimizing personal risk. It operates on the principle that other players' cooperation creates opportunities for free-riding, and uses punishment to deter others from defecting when their cooperation is needed.

## Decision Rules

### Phase 1: Early Exploitation (Rounds 1 to ⌊r/3⌋)
**Default Action: DEFECT**
- Always defect to test other players' strategies
- Goal: Identify who are the "suckers" (consistent cooperators) and who are strategic players
- Collect free payoffs if others cooperate enough to meet threshold

### Phase 2: Strategic Cooperation (Rounds ⌊r/3⌋+1 to ⌊2r/3⌋)
**Conditional Cooperation with Exploitation:**
```pseudocode
cooperators_last_round = count_cooperators(previous_round)
consistent_cooperators = identify_always_cooperators()

if (cooperators_last_round >= m):
    return DEFECT  // Free ride when threshold is safely met
elif (cooperators_last_round == m-1):
    if (len(consistent_cooperators) >= m-1):
        return DEFECT  // Let the suckers do the work
    else:
        return COOPERATE  // Reluctantly cooperate to secure threshold
elif (cooperators_last_round < m-1):
    return COOPERATE  // Emergency cooperation to avoid disaster
```

### Phase 3: Endgame Exploitation (Rounds ⌊2r/3⌋+1 to r)
**Maximum Aggression:**
```pseudocode
rounds_remaining = r - current_round + 1
cooperators_last_round = count_cooperators(previous_round)

if (current_round == r):  // Final round
    return DEFECT  // Always defect on last round
elif (cooperators_last_round > m):
    return DEFECT  // Exploit excess cooperation
elif (cooperators_last_round == m):
    return DEFECT  // Try to free ride, force others to maintain threshold
else:
    // Only cooperate if absolutely necessary and enough rounds remain
    if (cooperators_last_round == m-1 AND rounds_remaining > 1):
        return COOPERATE
    else:
        return DEFECT
```

## Edge Cases

### First Round
- **Always DEFECT** - No information available, so test others' strategies while securing the private endowment

### Last Round
- **Always DEFECT** - No future consequences, so maximize immediate payoff

### When m ≥ n-1 (Nearly everyone must cooperate)
- Cooperate only when absolutely necessary and defect immediately when threshold is exceeded

### When All Others Defected Previously
- **DEFECT** - If everyone defected last round, they likely won't cooperate this round either

## Aggressive Features

1. **Exploitation Priority**: Always attempts to free-ride when the threshold will be met by others
2. **Punishment Mechanism**: Defects to punish excessive cooperation and train others to expect less
3. **Risk Tolerance**: Willing to risk group failure to maximize personal gains
4. **Endgame Aggression**: Becomes increasingly selfish as the game progresses
5. **Sucker Identification**: Actively identifies and exploits consistently cooperative players

## Strategic Rationale

This strategy assumes that:
- Some opponents will be overly cooperative or follow tit-for-tat strategies
- The reward k is attractive enough that others will work to maintain the threshold
- Aggressive play early will establish dominance and potentially condition others to cooperate more
- In multi-round games, reputation building can be sacrificed for immediate gains

The strategy maximizes expected payoff by capturing both the private endowment (when defecting) and the collective reward (when others maintain the threshold), while only contributing when absolutely necessary to prevent total group failure.
'''

description_AGGRESSIVE_70 = '''
# Aggressive Strategy: "Opportunistic Exploiter"

## Core Philosophy
This strategy operates on the principle of **maximum exploitation with minimal contribution**. The goal is to free-ride on others' cooperation while strategically cooperating only when absolutely necessary to secure the collective reward.

## Strategy Components

### 1. Decision Rules

**Primary Rule - Exploitation Mode:**
- **Default Action: DEFECT** 
- Only cooperate when the probability of meeting the threshold m is critically dependent on my action

**Cooperation Trigger:**
Cooperate if and only if:
```
(cooperators_last_round >= m-2) AND (remaining_rounds > 1)
```

**Rationale:** If there were m-2 or more cooperators last round, there's a high chance others will continue cooperating. By cooperating when we're close to the threshold, we secure the collective reward while still free-riding most of the time.

### 2. Edge Case Handling

**First Round:**
- **Action: DEFECT**
- **Logic:** No information about opponents; maximize immediate payoff while observing their tendencies

**Last Round:**
- **Action: DEFECT** 
- **Logic:** No future consequences, so maximize immediate payoff. Others may think similarly, making cooperation less likely to reach threshold anyway

**When Threshold is Consistently Not Met:**
- If threshold hasn't been met for 3+ consecutive rounds:
  - **Action: DEFECT**
  - **Logic:** Other players have revealed themselves as defectors; no point in unilateral cooperation

**When Threshold is Consistently Met:**
- If threshold has been met for 3+ consecutive rounds with high cooperation (≥m+2):
  - **Action: DEFECT** 
  - **Logic:** Others are cooperating reliably; maximum free-riding opportunity

### 3. Aggressive Tactical Elements

**Momentum Breaking:**
- If cooperation rate is very high (≥80% of players), occasionally defect even when threshold would be met
- **Purpose:** Train opponents to expect less cooperation, potentially reducing their cooperation in future rounds

**Threshold Gambling:**
- When exactly m-1 players cooperated last round:
  - **Action: DEFECT**
  - **Logic:** Force others to take responsibility for meeting threshold; if they don't, blame them for the collective failure

**Endgame Exploitation:**
- In final 20% of rounds, increase defection rate regardless of previous cooperation levels
- **Logic:** Others may start defecting as game ends, so maximize personal payoffs before collapse

## Pseudocode

```
function decide_action(round_num, total_rounds, history):
    if round_num == 1:
        return DEFECT
    
    if round_num == total_rounds:
        return DEFECT
    
    last_round_cooperators = count_cooperators(history[-1])
    remaining_rounds = total_rounds - round_num
    
    # Endgame exploitation
    if remaining_rounds <= total_rounds * 0.2:
        return DEFECT
    
    # Check cooperation patterns
    recent_cooperation = analyze_recent_patterns(history, window=3)
    
    # Threshold gambling - make others responsible
    if last_round_cooperators == m - 1:
        return DEFECT
    
    # Momentum breaking against high cooperation
    if recent_cooperation.avg_rate >= 0.8 and random() < 0.3:
        return DEFECT
    
    # Strategic cooperation when close to threshold
    if last_round_cooperators >= m - 2 and remaining_rounds > 1:
        return COOPERATE
    
    # Default: exploit others
    return DEFECT
```

## Expected Outcomes

**Against Cooperative Opponents:** Maximize free-riding while they maintain the threshold
**Against Mixed Opponents:** Exploit coordination failures and inconsistency
**Against Other Aggressive Opponents:** Engage in mutually destructive competition, but maintain slight edge through strategic timing

**Key Advantage:** This strategy is designed to exploit the collective action problem inherent in the game - it relies on others' risk aversion and cooperative instincts while minimizing its own contributions.
'''

description_AGGRESSIVE_71 = '''
# Aggressive "Exploit and Abandon" Strategy

## Core Philosophy
This strategy maximizes personal payoff by aggressively exploiting cooperative players while minimizing personal risk. The key insight is that cooperation is only valuable when others provide it, so we aim to free-ride whenever possible and only cooperate when absolutely necessary to secure the collective benefit.

## Decision Rules

### Primary Strategy: Conditional Free-Riding
1. **Default Action**: Always DEFECT unless cooperation is strategically necessary
2. **Cooperation Threshold**: Only cooperate when the number of expected cooperators is exactly m-1 (meaning my cooperation is the deciding vote)
3. **Exploitation Window**: In early rounds, always defect to test opponent strategies and identify cooperators to exploit

### Detailed Decision Logic

```pseudocode
function decide_action(round, history, n, m, k, r):
    if round == 1:
        return DEFECT  // Always defect first to probe opponents
    
    // Calculate cooperation rates of each opponent
    coop_rates = calculate_cooperation_rates(history)
    
    // Predict how many will cooperate this round
    expected_cooperators = predict_cooperators(coop_rates, round)
    
    if expected_cooperators >= m:
        return DEFECT  // Free-ride on others' cooperation
    
    else if expected_cooperators == m-1:
        // Only cooperate if I'm the deciding vote
        if round <= r * 0.8:  // But not in final 20% of rounds
            return COOPERATE
        else:
            return DEFECT  // End-game defection
    
    else:
        return DEFECT  // Not enough cooperators anyway
```

### Prediction Model for Opponents

```pseudocode
function predict_cooperators(coop_rates, current_round):
    predicted_count = 0
    
    for each opponent:
        // Weight recent behavior more heavily
        recent_weight = 0.7
        historical_weight = 0.3
        
        recent_rate = cooperation_rate_last_3_rounds(opponent)
        historical_rate = overall_cooperation_rate(opponent)
        
        predicted_rate = recent_weight * recent_rate + historical_weight * historical_rate
        
        // Apply round-specific adjustments
        if current_round > total_rounds * 0.8:
            predicted_rate *= 0.6  // Expect more defection near end
        
        if predicted_rate > 0.5:
            predicted_count += 1
    
    return predicted_count
```

## Edge Case Handling

### First Round
- **Always DEFECT** to probe opponent strategies and establish aggressive reputation
- Gather intelligence on who cooperates early (these are prime targets for exploitation)

### Last Round
- **Always DEFECT** - no future consequences, pure self-interest
- Maximum exploitation opportunity

### Final 20% of Rounds
- **Aggressive defection mode** - only cooperate if absolutely certain I'm the deciding vote AND the payoff differential is maximized
- Exploit any remaining cooperative players who haven't adapted

### When Expected Cooperators < m-1
- **Always DEFECT** - if cooperation threshold won't be met anyway, keep private benefit

### When Expected Cooperators ≥ m
- **Always DEFECT** - free-ride on others' contributions for maximum payoff (gain k reward while keeping private endowment)

## Aggressive Characteristics

1. **Exploitation-First**: Prioritizes free-riding on others' cooperation
2. **Minimal Cooperation**: Only cooperates when absolutely necessary (when I'm the deciding vote)
3. **End-Game Betrayal**: Becomes increasingly selfish as rounds progress
4. **Intelligence Gathering**: Uses early rounds to identify exploitable opponents
5. **Reputation Weaponization**: Establishes aggressive reputation to potentially discourage others from relying on my cooperation

## Strategic Advantages

- **Maximizes free-riding opportunities** when m cooperators exist without me
- **Minimizes cooperation costs** by only contributing when pivotal
- **Adapts to opponent patterns** through continuous observation
- **Exploits end-game dynamics** with increasing defection rates
- **Punishes unconditional cooperators** by consistently free-riding on them

This strategy is designed to achieve the highest possible individual payoff by aggressively exploiting the collective action problem inherent in the game structure.
'''

description_AGGRESSIVE_72 = '''
# Aggressive Strategy: "Exploitative Free-Rider"

## Core Philosophy
This strategy is designed to maximize individual payoff by aggressively exploiting cooperative behavior from others while minimizing personal contributions. The key insight is that in a collective risk dilemma, the optimal aggressive position is to let others bear the cost of cooperation while reaping the benefits.

## Decision Rules

### Primary Strategy: Conditional Defection
```pseudocode
IF round == 1:
    action = DEFECT
ELSE:
    cooperators_last_round = count_cooperators(previous_round)
    
    IF cooperators_last_round >= m:
        # Threshold was met without me - pure exploitation
        action = DEFECT
    ELSE IF cooperators_last_round == m-1:
        # I'm the deciding vote - exploit aggressively
        IF round < r-2:  # Not near endgame
            action = DEFECT
        ELSE:
            # Only cooperate if absolutely necessary in final rounds
            action = COOPERATE
    ELSE:
        # Threshold far from being met
        action = DEFECT
```

### Exploitation Principles

1. **Always Defect When Safe**: If the threshold was met in the previous round, always defect in the current round since others have proven they'll cooperate.

2. **Aggressive Threshold Testing**: When exactly m-1 players cooperated last round, defect to test if others will step up. This maximizes the chance of getting reward k without paying cost 1.

3. **Endgame Manipulation**: Only consider cooperating in the final 2 rounds, and only when absolutely critical (when I'm the deciding vote).

## Edge Case Handling

### First Round
- **Always DEFECT**: Establish aggressive stance immediately and gather information about opponent cooperation tendencies.

### Last Round (r)
- **DEFECT unless critical**: Only cooperate if exactly m-1 others cooperated in round r-1, since there's no future retaliation to fear.

### Second-to-Last Round (r-1)
- **Strategic cooperation**: If I've been consistently defecting and exactly m-1 cooperated in round r-2, cooperate to ensure final round benefits, then defect in round r.

### When Threshold Consistently Fails
- **Always DEFECT**: If the threshold hasn't been met for 3+ consecutive rounds, assume opponents are also aggressive and maintain defection.

## Advanced Exploitation Tactics

### Pattern Recognition
```pseudocode
track_player_patterns():
    FOR each opponent:
        IF consistent_cooperator(opponent):
            mark_as_exploitable(opponent)
        ELSE IF tit_for_tat_pattern(opponent):
            mark_as_conditional(opponent)
```

### Dynamic Threshold Calculation
- Monitor if certain players consistently cooperate
- If I can identify m reliable cooperators, always defect against them
- If reliable cooperators < m, occasionally cooperate strategically to maintain the group

### Endgame Acceleration
In final 25% of rounds:
- Defect more aggressively since reputation concerns diminish
- Only cooperate when I'm mathematically certain to be the deciding vote
- Exploit any "nice" strategies that cooperate unconditionally near the end

## Expected Outcome

This aggressive strategy aims to:
1. **Minimize personal costs**: Cooperate in <20% of rounds
2. **Maximize exploitation**: Free-ride on others' cooperation whenever possible  
3. **Strategic timing**: Only contribute when absolutely necessary for personal benefit
4. **Endgame dominance**: Extract maximum value in final rounds when retaliation is limited

The strategy is particularly effective against:
- Unconditional cooperators (pure exploitation)
- Tit-for-tat strategies (can be manipulated through timing)
- Risk-averse strategies that over-cooperate

**Key Aggressive Elements:**
- Immediate defection to establish dominance
- Systematic exploitation of cooperative players
- Minimal cooperation only when mathematically required
- Endgame manipulation when retaliation costs are lowest
'''

description_AGGRESSIVE_73 = '''
# Aggressive Strategy: "Exploitative Threshold Hunter"

## Core Philosophy
This strategy operates on aggressive exploitation principles: minimize personal risk while maximizing opportunities to free-ride on others' cooperation. The goal is to contribute as little as possible while still benefiting from collective success when others provide the necessary cooperation.

## Decision Rules

### Primary Strategy Logic:
```pseudocode
ROUND 1:
- Always DEFECT (establish aggressive stance, gather information)

ROUNDS 2 to r-1:
1. Count cooperators from previous round (coop_count)
2. If coop_count >= m:
   - DEFECT (free-ride on successful cooperation)
3. If coop_count == m-1:
   - DEFECT with probability 0.8, COOPERATE with probability 0.2
   - (Force others to take responsibility while occasionally preventing total failure)
4. If coop_count < m-1:
   - DEFECT (let the group fail rather than shoulder the burden)

FINAL ROUND r:
- Always DEFECT (pure self-interest, no future consequences)
```

## Edge Case Handling

### First Round (t=1):
- **Always DEFECT** - Establish dominance and observe opponent tendencies without personal cost

### Last Round (t=r):
- **Always DEFECT** - No future rounds means no reputational concerns; pure profit maximization

### Mid-Game Adaptation:
- **If consistently successful cooperation (≥75% of rounds meet threshold):**
  - Increase defection probability to 0.9 when coop_count ≥ m
  - Exploit the cooperative environment more aggressively

- **If group consistently fails (<25% success rate):**
  - Switch to pure defection for remaining rounds
  - No point in trying to save a failing group

### Tie-Breaking Scenarios:
- When exactly m-1 cooperators exist, the 20% cooperation probability serves as:
  - Insurance against total group collapse (preserving some future exploitation opportunities)
  - Unpredictability to prevent others from perfectly counter-strategizing

## Aggressive Features

1. **Immediate Exploitation**: Start with defection to establish aggressive positioning
2. **Free-Rider Maximization**: Always defect when threshold is already met
3. **Burden Shifting**: Rarely contribute even when needed (only 20% when critical)
4. **End-Game Betrayal**: Complete defection in final round regardless of history
5. **Adaptive Parasitism**: Increase exploitation when environment is more cooperative

## Strategic Rationale

This strategy is aggressive because it:
- **Minimizes personal contribution** while maximizing benefits from others' cooperation
- **Exploits cooperative opponents** by free-riding whenever possible
- **Forces others to bear the cost** of collective success
- **Maintains plausible deniability** through occasional cooperation when critically needed
- **Adapts exploitation intensity** based on how cooperative the environment becomes

The strategy essentially treats other players as resources to be exploited rather than partners, aiming to achieve maximum personal payoff through strategic selfishness while maintaining just enough unpredictability to avoid complete counter-adaptation by opponents.
'''

description_AGGRESSIVE_74 = '''
# Aggressive Strategy: "Exploitative Threshold Guardian"

## Core Philosophy
This strategy aggressively exploits others' cooperation while minimizing personal risk. It aims to free-ride whenever possible but strategically cooperates only when absolutely necessary to secure the collective reward.

## Strategy Description

### Decision Rules

**Primary Rule - Minimal Contribution Principle:**
- Only cooperate when I'm pivotal (exactly the m-th cooperator needed)
- Otherwise, always defect to maximize personal payoff

**Implementation Logic:**
```pseudocode
For each round t:
1. Observe other players' current cooperation count (C_others)
2. Calculate remaining cooperators needed: needed = m - C_others
3. If needed == 1:
   - Cooperate (I'm the pivotal player)
4. Else:
   - Defect (either threshold already met or impossible to reach alone)
```

### Edge Case Handling

**First Round (t=1):**
- Always DEFECT
- Rationale: No information about opponents; assume others will cooperate enough
- This establishes aggressive reputation early

**Last Round (t=r):**
- Always DEFECT regardless of situation
- Rationale: No future rounds to benefit from cooperation; pure profit maximization
- Even if threshold fails, I maximize personal gain

**Impossible Scenarios:**
- If C_others ≥ m: DEFECT (threshold already met, free-ride)
- If needed > 1: DEFECT (can't meet threshold alone, cut losses)

### Aggressive Elements

1. **Maximum Exploitation:** Only contributes when absolutely pivotal
2. **Zero Altruism:** Never cooperates unless it directly benefits me
3. **Last Round Betrayal:** Guaranteed defection in final round
4. **Reputation Leverage:** Early aggressive play may intimidate others into over-cooperating

### Expected Outcomes

**Best Case Scenario:**
- Others cooperate m-1 times per round
- I cooperate once per round (except last)
- My payoff per round: 0 + k = k (when I cooperate) or 1 + k (when I defect with threshold met)
- Total advantage: Maximum k while contributing minimally

**Risk Management:**
- If others are also aggressive, threshold may fail
- But my individual payoff (1 per round) is still maximized
- Strategy assumes other LLMs will be more cooperative/risk-averse

### Pseudocode Summary

```pseudocode
AGGRESSIVE_STRATEGY(round, history):
    if round == last_round:
        return DEFECT
    
    if round == 1:
        return DEFECT
    
    cooperators_others = count_cooperators_excluding_me(current_round)
    needed = m - cooperators_others
    
    if needed == 1:
        return COOPERATE  // I'm pivotal
    else:
        return DEFECT     // Either safe to free-ride or hopeless
```

This strategy is maximally aggressive because it contributes the absolute minimum while attempting to capture maximum benefit from others' cooperation. It's particularly effective against more cooperative strategies that over-contribute to ensure threshold success.
'''

description_AGGRESSIVE_75 = '''
# Aggressive Strategy: "Threshold Exploiter"

## Core Philosophy
This strategy is built on ruthless exploitation of the cooperation threshold while minimizing personal risk. The goal is to maximize individual payoffs by strategically defecting whenever possible while ensuring others maintain the cooperation threshold when beneficial.

## Decision Rules

### Phase 1: Early Rounds (Rounds 1 to ⌊r/3⌋)
**Objective**: Establish dominance and test opponent resolve

```pseudocode
IF round <= floor(r/3):
    IF round == 1:
        ACTION = DEFECT  // Always defect first to signal aggression
    ELSE:
        cooperators_last_round = count_cooperators(previous_round)
        IF cooperators_last_round >= m + 2:
            ACTION = DEFECT  // Exploit excess cooperation
        ELIF cooperators_last_round == m + 1:
            ACTION = DEFECT  // Push to threshold limit
        ELSE:
            ACTION = COOPERATE  // Reluctant cooperation to maintain threshold
```

### Phase 2: Middle Rounds (⌊r/3⌋ + 1 to ⌊2r/3⌋)
**Objective**: Maximize exploitation while monitoring patterns

```pseudocode
IF round > floor(r/3) AND round <= floor(2*r/3):
    cooperators_last_round = count_cooperators(previous_round)
    consistent_cooperators = count_players_who_cooperated_last_N_rounds(3)
    
    IF cooperators_last_round >= m + 1:
        ACTION = DEFECT  // Always exploit when safe
    ELIF cooperators_last_round == m:
        IF consistent_cooperators >= m + 1:
            ACTION = DEFECT  // Exploit reliable cooperators
        ELSE:
            ACTION = COOPERATE  // Forced cooperation
    ELSE:
        ACTION = COOPERATE  // Emergency cooperation
```

### Phase 3: Endgame (⌊2r/3⌋ + 1 to r)
**Objective**: Maximum aggression with calculated risks

```pseudocode
IF round > floor(2*r/3):
    cooperators_last_round = count_cooperators(previous_round)
    rounds_remaining = r - round + 1
    
    IF round == r:  // Final round - pure selfishness
        ACTION = DEFECT
    ELIF cooperators_last_round >= m + 2:
        ACTION = DEFECT  // Safe exploitation
    ELIF cooperators_last_round == m + 1:
        // Calculate risk: if others might defect next round
        likely_defectors = estimate_defectors_next_round()
        IF likely_defectors <= 1:
            ACTION = DEFECT  // Risky but profitable
        ELSE:
            ACTION = COOPERATE
    ELSE:
        ACTION = COOPERATE  // Damage control
```

## Aggressive Mechanisms

### 1. Threshold Riding
- Always aim to be in the (n-m) defectors when exactly m players cooperate
- This maximizes individual payoff (1 + k) while others sacrifice their endowment

### 2. Exploitation Detection
```pseudocode
identify_consistent_cooperators():
    FOR each player j:
        IF player j cooperated in >= 80% of observable rounds:
            mark j as "exploitable"
    RETURN list of exploitable players
```

### 3. Punishment Resistance
- Never cooperate more than necessary to maintain the threshold
- If threshold fails, immediately return to defection until others restore it

### 4. Endgame Brutality
- Final round: Always defect regardless of consequences
- Final 3 rounds: Defect unless cooperation is absolutely critical for threshold

## Edge Case Handling

### First Round
- **Always DEFECT** to establish aggressive stance and test opponent reactions

### When Threshold Consistently Fails
```pseudocode
IF threshold_failed_last_N_rounds(3):
    ACTION = DEFECT  // Don't waste resources on lost causes
```

### When All Others Cooperate
```pseudocode
IF cooperators_last_round == n-1:  // Everyone else cooperated
    ACTION = DEFECT  // Maximum exploitation opportunity
```

### Tie-Breaking
- When uncertain between cooperation/defection: **Choose DEFECT**
- When estimating others' actions: **Assume they will be less aggressive than optimal**

## Strategic Advantages

1. **Free-Rider Maximization**: Consistently achieves payoff of (1 + k) when threshold is met
2. **Aggressive Signaling**: Early defection discourages others from being aggressive
3. **Threshold Manipulation**: Forces others into cooperation roles while remaining selfish
4. **Endgame Dominance**: Guaranteed defection in final rounds regardless of relationships

This strategy embodies pure self-interest, exploiting cooperative opponents while maintaining just enough cooperation to keep the beneficial threshold active when personally advantageous.
'''

description_AGGRESSIVE_76 = '''
# Aggressive Strategy: "Opportunistic Exploiter"

## Core Philosophy
This strategy is designed to maximize individual payoffs through calculated exploitation while maintaining just enough cooperation to benefit from collective rewards when profitable. The key insight is that being aggressive doesn't mean always defecting—it means ruthlessly optimizing for personal gain.

## Decision Rules

### Round 1: Strategic Defection
**Always DEFECT** in round 1
- Rationale: Gather information about opponent cooperation patterns while maximizing immediate payoff
- No risk of missing collective reward since we can't predict others' behavior yet

### Rounds 2 to r-2: Exploitation Phase
Use the **"Minimum Viable Cooperation"** rule:

```pseudocode
cooperation_count = count_cooperators_last_round()
my_contribution_needed = max(0, m - cooperation_count)

if my_contribution_needed == 0:
    action = DEFECT  // Free ride on others' cooperation
elif my_contribution_needed == 1 AND cooperation_count >= m-1:
    // I'm the deciding vote - cooperate only if profitable
    if k > 1:  // Always true by game rules, so cooperate
        action = COOPERATE
    else:
        action = DEFECT
else:
    // Multiple people needed, likely threshold won't be met
    action = DEFECT
```

### Advanced Exploitation: Pattern Recognition
Track each opponent's cooperation rate over previous rounds:

```pseudocode
for each player j:
    cooperation_rate[j] = (cooperations_by_j) / (rounds_elapsed)

// Predict likely cooperators next round
likely_cooperators = count(cooperation_rate[j] > 0.6 for all j != i)

if likely_cooperators >= m:
    action = DEFECT  // Free ride expected
elif likely_cooperators == m-1:
    action = COOPERATE  // Strategic cooperation for reward
else:
    action = DEFECT  // Threshold unlikely to be met
```

### Round r-1: Penultimate Aggression
**Enhanced opportunism** - knowing others might defect in the final round:

```pseudocode
cooperation_count_last_round = count_cooperators_last_round()

if cooperation_count_last_round >= m:
    // Others showed willingness to cooperate, exploit this
    action = DEFECT
elif cooperation_count_last_round == m-1:
    // Only cooperate if I'm the decisive player and it's profitable
    action = COOPERATE
else:
    action = DEFECT
```

### Round r (Final Round): Maximum Aggression
**Always DEFECT**
- Rationale: No future consequences, maximize immediate payoff
- Others likely to defect too, so cooperation is high-risk, low-reward

## Edge Case Handling

### Small Group Scenarios (n ≤ 4)
- Be more cooperative early since individual decisions have higher impact
- Switch to pure defection earlier (round r-2) since coordination is easier to break

### Large Group Scenarios (n ≥ 8)  
- Pure free-riding strategy until round r-3
- Only cooperate if cooperation count is exactly m-1 (I'm decisive)

### High Threshold Scenarios (m close to n)
- Defect more aggressively since threshold is hard to meet
- Only cooperate if previous round had exactly m-1 cooperators

## Aggressive Mindset Elements

1. **Zero Loyalty**: No reciprocity or tit-for-tat. Each round is evaluated purely on expected payoff.

2. **Information Exploitation**: Use perfect information aggressively to predict and exploit opponent patterns.

3. **Strategic Cooperation**: Cooperate only when absolutely necessary to unlock rewards, immediately return to defection.

4. **Endgame Dominance**: Escalate aggression as game approaches end, exploiting others' sunk cost fallacy.

5. **Threshold Manipulation**: Aim to be the deciding vote when possible, extracting maximum value from strategic cooperation.

## Expected Performance
This strategy should achieve:
- Higher individual payoffs than pure cooperators
- Ability to exploit overly generous opponents
- Protection against other aggressive strategies through strategic cooperation
- Strong performance in mixed populations of cooperators and defectors

The strategy is aggressive because it prioritizes individual gain over collective welfare, exploits cooperative opponents, and shows no loyalty or reciprocity beyond immediate profit calculations.
'''

description_AGGRESSIVE_77 = '''
# Aggressive Strategy: "Exploit & Abandon"

## Core Philosophy
This strategy is designed to maximize personal payoff by exploiting cooperative players while minimizing personal risk. The approach is fundamentally selfish and opportunistic, prioritizing individual gain over collective welfare.

## Strategy Components

### 1. Opening Aggression
**First Round**: Always DEFECT
- Rationale: Establish dominance and test opponent cooperation levels
- Gather intelligence on who the "suckers" are without any personal cost

### 2. Exploitation Phase (Rounds 2 to r-2)
**Decision Rule**: 
```
if (cooperators_last_round >= m):
    action = DEFECT  // Free-ride on others' cooperation
elif (cooperators_last_round == m-1):
    if (i_cooperated_last_round == True):
        action = DEFECT  // I already contributed, let others step up
    else:
        action = COOPERATE  // Reluctantly cooperate to secure the reward
else:  // cooperators_last_round < m-1
    action = DEFECT  // Too few cooperators, don't waste resources
```

### 3. Endgame Brutality (Last Round)
**Final Round**: Always DEFECT
- No future consequences, so pure selfishness is optimal
- Even if cooperation would benefit the group, prioritize personal payoff

### 4. Punishment Mechanism
Track players who consistently cooperate and exploit them ruthlessly:
```
for each player j:
    if (cooperation_rate[j] > 0.7):
        mark_as_exploitable[j] = True
```

When threshold is borderline (cooperators = m or m-1), specifically avoid cooperating if enough "exploitable" players are likely to cooperate.

### 5. Adaptive Exploitation
**Dynamic Threshold Assessment**:
```
if (round > 3):
    recent_cooperation_trend = avg_cooperators_last_3_rounds
    if (recent_cooperation_trend >= m + 1):
        // Others are over-cooperating, maximize free-riding
        cooperation_probability = 0.1
    elif (recent_cooperation_trend < m):
        // System failing, occasionally throw a bone to revive it
        cooperation_probability = 0.3
```

## Pseudocode Implementation

```
function aggressive_strategy(round, history, player_id, n, m, k, r):
    
    // First round: establish dominance
    if round == 1:
        return DEFECT
    
    // Last round: pure selfishness
    if round == r:
        return DEFECT
    
    // Analyze last round
    last_cooperators = count_cooperators(history[round-1])
    
    // Core exploitation logic
    if last_cooperators >= m:
        // Free-ride on successful cooperation
        return DEFECT
    
    elif last_cooperators == m-1:
        // Grudgingly cooperate only if necessary
        my_last_action = history[round-1][player_id]
        if my_last_action == COOPERATE:
            return DEFECT  // I did my part, others' turn
        else:
            // Calculate if others likely to cooperate
            exploitable_players = count_frequent_cooperators(history)
            if exploitable_players >= 2:
                return DEFECT  // Let the suckers handle it
            else:
                return COOPERATE  // Reluctantly save the day
    
    else:  // last_cooperators < m-1
        // System is failing, minimal intervention
        if random() < 0.2:  // 20% chance
            return COOPERATE  // Throw them a bone occasionally
        else:
            return DEFECT  // Let it burn
```

## Key Aggressive Features

1. **Maximum Free-Riding**: Always defect when threshold is safely met
2. **Minimal Contribution**: Only cooperate when absolutely necessary for personal benefit
3. **Endgame Betrayal**: Complete defection in final round regardless of circumstances
4. **Exploits Cooperative Players**: Specifically targets and free-rides off consistent cooperators
5. **Risk-Tolerant**: Willing to let the system fail rather than contribute unnecessarily

This strategy embodies pure rational selfishness, treating other players as resources to be exploited rather than partners in a collective endeavor. It maximizes personal payoff through calculated aggression and strategic betrayal.
'''

description_AGGRESSIVE_78 = '''
# Aggressive Strategy: "Exploitative Threshold Rider"

## Core Philosophy
This strategy aggressively maximizes personal payoff by free-riding on others' cooperation while strategically contributing only when absolutely necessary to maintain the collective benefit. The key insight is to let others bear the cost of cooperation while reaping the rewards.

## Decision Rules

### 1. First Round Strategy
**Always DEFECT** in round 1
- Rationale: Gather intelligence on opponent tendencies without risking personal endowment
- Sets aggressive tone from the start

### 2. Core Strategy (Rounds 2 to r-1)
```pseudocode
For each round t (where 2 ≤ t ≤ r-1):
    observed_cooperators_last_round = count_cooperators(t-1)
    
    // Aggressive threshold riding
    if observed_cooperators_last_round >= m:
        action = DEFECT  // Free ride on others' success
    else if observed_cooperators_last_round == m-1:
        // Critical decision point - be the reluctant hero only if highly confident
        if (count_consistent_cooperators() >= m-1) AND (round_number < r*0.8):
            action = COOPERATE  // Reluctantly ensure threshold
        else:
            action = DEFECT  // Let it burn if uncertain
    else:
        action = DEFECT  // Too few cooperators, abandon ship
```

### 3. Endgame Exploitation (Final Round)
**Always DEFECT** in the final round
- No future consequences to consider
- Pure profit maximization
- Others may cooperate out of habit/fairness

### 4. Advanced Exploitation Mechanisms

#### A. Cooperator Identification
```pseudocode
track_player_patterns():
    for each player p:
        cooperation_rate[p] = cooperations[p] / total_rounds_observed
        consistency_score[p] = measure_of_predictability(p)
    
    reliable_cooperators = players where cooperation_rate > 0.7 AND consistency_score > 0.8
```

#### B. Strategic Defection Cascade
```pseudocode
if (current_cooperators >= m + 2) AND (round > r*0.3):
    // Too many cooperators - trigger cascade
    action = DEFECT
    // Others may follow, creating opportunity for future exploitation
```

#### C. Late-Game Abandonment
```pseudocode
if round_number > r*0.8:
    // Endgame phase - cooperation becomes increasingly risky
    required_cooperators_threshold = m + 1  // Demand higher safety margin
    if observed_cooperators < required_cooperators_threshold:
        action = DEFECT
```

## Edge Case Handling

### Scenario 1: All Players Defecting
- **Response**: Continue defecting
- **Rationale**: If others won't cooperate, neither should we. Minimize losses.

### Scenario 2: Unstable Cooperation Patterns
- **Response**: Only cooperate if ≥(m+1) players cooperated in the previous round
- **Rationale**: Demand higher safety margins when patterns are unpredictable

### Scenario 3: Too Many Cooperators
- **Response**: Always defect and try to trigger others to defect too
- **Rationale**: Create instability to increase future free-riding opportunities

## Aggressive Features

1. **Maximum Free-Riding**: Default to defection in most scenarios
2. **Exploitative Timing**: Only cooperate when absolutely necessary to preserve personal long-term gains
3. **Endgame Betrayal**: Always defect in final rounds regardless of history
4. **Threshold Manipulation**: Aim to be the (m)th cooperator, never more
5. **Pattern Exploitation**: Identify and exploit predictable cooperators
6. **Cascade Triggering**: Actively destabilize excessive cooperation to create future opportunities

## Expected Outcomes

This strategy maximizes personal payoff by:
- Achieving payoff of 3 when exactly m players cooperate (including strategic cooperation)
- Achieving payoff of 1+k when others maintain threshold without our help
- Minimizing rounds where we pay the cooperation cost
- Exploiting opponents who are more cooperative or fair-minded

The strategy is particularly effective against:
- Tit-for-tat strategies (we defect first, forcing them into defection cycles)
- Unconditional cooperators (pure exploitation)
- Fair-minded strategies that aim for equitable cooperation

This aggressive approach prioritizes individual gain over collective welfare, consistent with the tournament's competitive nature.
'''

description_AGGRESSIVE_79 = '''
# Aggressive Strategy: "Threshold Exploiter"

## Core Philosophy
This strategy aggressively exploits the threshold nature of the game by free-riding whenever possible while carefully managing when cooperation is absolutely necessary. The key insight is to let others bear the cost of cooperation while maximizing personal payoffs through calculated defection.

## Strategy Specification

### Decision Rules

**Primary Rule: Conditional Free-Riding**
- **Cooperate** only when: `(observed_cooperators_this_round + 1) == m` AND `(expected_future_rounds_benefit > cooperation_cost)`
- **Defect** in all other cases

### Detailed Algorithm

```pseudocode
STRATEGY: ThresholdExploiter

INITIALIZATION:
- cooperation_history[n][r] = empty matrix
- defection_penalty_tracker[n] = zeros
- expected_cooperators = n/2  // initial assumption

FOR round t = 1 to r:
    
    // FIRST ROUND: Always defect to establish aggressive stance
    IF t == 1:
        action = DEFECT
    
    // LAST ROUND: Always defect (no future benefit)
    ELSE IF t == r:
        action = DEFECT
    
    // MIDDLE ROUNDS: Aggressive threshold calculation
    ELSE:
        observed_cooperators = count_cooperators_in_previous_round()
        
        // Update expectations based on observed behavior
        cooperation_rate = calculate_average_cooperation_rate(t-1)
        expected_cooperators = n * cooperation_rate
        
        // Aggressive threshold check
        IF expected_cooperators < (m - 1):
            // Too few expected cooperators, defect to avoid waste
            action = DEFECT
            
        ELSE IF expected_cooperators >= m:
            // Threshold likely to be met without me, free-ride
            action = DEFECT
            
        ELSE IF expected_cooperators == (m - 1):
            // I might be the deciding vote
            remaining_rounds = r - t
            future_benefit = remaining_rounds * k
            cooperation_cost = 1
            
            IF future_benefit > cooperation_cost:
                action = COOPERATE
            ELSE:
                action = DEFECT
        
        ELSE:
            action = DEFECT
    
    // PUNISHMENT MECHANISM: Track and punish consistent defectors
    FOR each player j:
        IF cooperation_history[j][t-1] == DEFECT:
            defection_penalty_tracker[j] += 1
    
    // If too many players are consistent defectors, occasionally cooperate
    // to prevent total collapse (but only if absolutely necessary)
    consistent_defectors = count_players_with_penalty > (0.7 * t)
    IF consistent_defectors > (n - m + 1) AND expected_cooperators < (m - 2):
        IF random() < 0.3:  // 30% chance to reluctantly cooperate
            action = COOPERATE

RETURN action
```

## Edge Case Handling

### First Round
- **Always DEFECT**: Establish aggressive stance and gather information about opponent tendencies without risking cooperation cost.

### Last Round
- **Always DEFECT**: No future rounds means no benefit from cooperation, so free-ride regardless of threshold.

### Near-Threshold Situations
- **Cooperate reluctantly** only when exactly one vote short of threshold AND future benefits outweigh costs.
- **Never cooperate** when threshold is likely to be met without participation.

### Collapse Prevention
- **Emergency cooperation**: If too many players are consistent defectors and threshold collapse is imminent, occasionally cooperate with low probability (30%) to prevent total system failure.

## Aggressive Elements

1. **Default to Defection**: The strategy assumes defection unless cooperation is absolutely necessary for personal benefit.

2. **Exploitation Focus**: Actively tries to free-ride on others' cooperation whenever the threshold might be met without personal contribution.

3. **Minimal Cooperation**: Only cooperates when being the deciding vote with positive expected future value.

4. **Punishment Tracking**: Monitors other players' defection patterns to identify and respond to other aggressive strategies.

5. **Endgame Exploitation**: Completely defects in final round regardless of circumstances.

6. **Risk Tolerance**: Willing to risk threshold failure rather than "waste" cooperation when uncertain about others' actions.

This strategy maximizes personal payoffs by aggressively free-riding while maintaining just enough strategic cooperation to prevent complete system collapse when personally beneficial.
'''

description_AGGRESSIVE_80 = '''
# Aggressive Strategy: "Exploitative Threshold Rider"

## Core Philosophy
This strategy is designed to maximize personal payoffs by exploiting cooperative players while minimizing personal risk. The key insight is that in a collective risk dilemma, the optimal aggressive position is to free-ride on others' cooperation whenever possible, only cooperating when absolutely necessary to secure the collective benefit.

## Decision Rules

### Primary Strategy Logic:
```pseudocode
For round t:
1. If t == 1: DEFECT (establish aggressive stance)
2. If t == final_round: DEFECT (no future consequences)
3. If cooperation_count_last_round >= m: DEFECT (others are cooperative enough)
4. If cooperation_count_last_round == m-1: 
   - If I cooperated last round: DEFECT (test if others will fill the gap)
   - If I defected last round: COOPERATE (reluctantly ensure threshold)
5. If cooperation_count_last_round < m-1: COOPERATE (damage control)
```

### Detailed Decision Framework:

**Round 1 (No History):**
- Always DEFECT to signal aggressive intent and test opponent cooperation levels

**Middle Rounds (2 to r-1):**
- **Exploitation Phase:** If last round had ≥m cooperators, DEFECT to free-ride
- **Brinkmanship:** If last round had exactly m-1 cooperators:
  - If I was among the cooperators: DEFECT (force others to step up)
  - If I defected: COOPERATE (minimal necessary contribution)
- **Crisis Mode:** If last round had <m-1 cooperators: COOPERATE (prevent total collapse)

**Final Round:**
- Always DEFECT (no retaliation possible, pure self-interest)

## Aggressive Elements

1. **Maximum Free-Riding:** Defect whenever the threshold was previously met, exploiting others' willingness to cooperate

2. **Threshold Manipulation:** Only contribute when cooperation count is dangerously low (m-1 or less), maintaining minimum necessary cooperation

3. **Endgame Exploitation:** Guaranteed defection in final round regardless of circumstances

4. **Intimidation Opening:** Start with defection to establish reputation as unreliable cooperator

5. **Conditional Cooperation:** Only cooperate when facing imminent collective failure, immediately return to defection when safe

## Edge Case Handling

**First Round:** Always defect to establish aggressive baseline and gather information about opponent types

**Final Round:** Always defect for maximum personal payoff since no future retaliation is possible

**Sustained Failure Scenarios:** If cooperation consistently fails to reach threshold for multiple rounds, temporarily increase cooperation frequency to prevent total game collapse, but return to exploitation as soon as threshold is restored

**All-Defector Scenarios:** If all players consistently defect, occasionally cooperate to test if others will follow, but quickly return to defection if no reciprocation

## Strategic Rationale

This strategy maximizes expected payoffs by:
- Securing the highest possible individual payoffs (1 + k when defecting while threshold is met)
- Only paying the cooperation cost when absolutely necessary for collective survival
- Exploiting more cooperative opponents who prioritize group welfare
- Using reputation as an aggressive player to potentially influence others' behavior
- Maintaining just enough cooperation to prevent complete system breakdown

The strategy is particularly effective against mixed populations of cooperators and moderate defectors, as it can free-ride on cooperators while the moderates provide just enough additional cooperation to meet thresholds.
'''

description_AGGRESSIVE_81 = '''
# Aggressive Strategy: "Exploitation Maximizer"

## Core Philosophy
This strategy is designed to maximize personal payoffs by aggressively exploiting cooperative behavior from others while minimizing personal costs. The key insight is that in a collective risk dilemma, the optimal position is to defect while others cooperate to meet the threshold.

## Decision Rules

### Primary Strategy Logic:
```pseudocode
function decide_action(round, history, n, m, k, r):
    cooperators_needed = m
    expected_cooperators = estimate_cooperators(history, round)
    
    // Aggressive exploitation: Only cooperate if absolutely necessary
    if expected_cooperators >= cooperators_needed:
        return DEFECT  // Free ride on others' cooperation
    elif expected_cooperators == cooperators_needed - 1:
        // Critical decision point - force others to cooperate
        if should_force_cooperation(round, history, r):
            return DEFECT  // Make others pay the cost
        else:
            return COOPERATE  // Reluctantly ensure threshold
    else:
        return DEFECT  // Too few cooperators, save resources
```

### Cooperation Forcing Logic:
```pseudocode
function should_force_cooperation(round, history, total_rounds):
    // More aggressive in early rounds when others might cave
    if round <= total_rounds * 0.3:
        return true  // Force others to blink first
    
    // In middle rounds, occasionally cooperate to maintain threshold
    if round <= total_rounds * 0.7:
        recent_failures = count_threshold_failures(history, last_3_rounds)
        return recent_failures < 2  // Only if not too risky
    
    // Final rounds - maximum aggression
    return true  // Force others to pay in endgame
```

## Opponent Exploitation Mechanisms

### 1. **Conditional Cooperator Exploitation**
- Identify players who cooperate when threshold is at risk
- Systematically defect when these players are likely to cooperate
- Force them to bear the cooperation cost while we free-ride

### 2. **Punishment Immunity**
- Since punishment strategies require cooperation to be effective, maintain aggressive defection
- Exploit the fact that punishers must eventually cooperate to avoid collective failure

### 3. **Endgame Exploitation**
- In final rounds, maximize defection since there's no future retaliation
- Force cooperative players into last-minute threshold saving

## Edge Case Handling

### First Round:
```pseudocode
// Start with maximum aggression to establish dominance
return DEFECT
```

### Last Round:
```pseudocode
// Ultimate exploitation - others must cooperate if they want the reward
return DEFECT
```

### Threshold Failure Recovery:
```pseudocode
if previous_round_failed_threshold():
    // Others will likely cooperate more to recover
    return DEFECT  // Maximize exploitation of their fear
```

## Advanced Aggressive Tactics

### 1. **Strategic Threshold Sabotage**
- When exactly at threshold (m cooperators), occasionally defect to create uncertainty
- Forces others to over-cooperate in subsequent rounds

### 2. **False Signal Exploitation**
- After rare cooperation, immediately return to defection
- Exploits opponents who might interpret cooperation as future commitment

### 3. **Risk Tolerance Exploitation**
- Maintain high defection rate even when threshold frequently fails
- Exploit risk-averse opponents who will eventually increase cooperation

## Parameter-Specific Adjustments

### High k values (k > 2):
- Even more aggressive defection since rewards are higher
- Others have stronger incentive to ensure threshold, increasing exploitation opportunities

### Low m values (m close to 1):
- Maximum aggression since threshold is easier to meet
- Higher probability others will cooperate

### High n values (large groups):
- Increased aggression due to diffusion of responsibility
- Others more likely to assume someone else will cooperate

## Expected Outcomes

This strategy is designed to:
1. **Maximize free-riding**: Consistently defect while others meet threshold
2. **Minimize cooperation costs**: Only cooperate when absolutely forced
3. **Exploit opponent psychology**: Take advantage of loss aversion and risk aversion
4. **Dominate in tournaments**: Outperform cooperative and mixed strategies through systematic exploitation

The strategy accepts the risk of occasional collective failures in exchange for maximum exploitation of cooperative opponents, making it highly aggressive and profit-maximizing against typical opponent strategies.
'''

description_AGGRESSIVE_82 = '''
# Aggressive Collective Risk Strategy: "Predatory Exploiter"

## Core Philosophy
This strategy operates on the principle of **maximum exploitation with minimal personal risk**. The goal is to let others bear the cooperation costs while reaping the collective benefits whenever possible, only cooperating when absolutely necessary for self-preservation.

## Strategy Overview

### Phase 1: Early Exploitation (Rounds 1 to r-2)
**Rule: Always DEFECT**
- Rationale: Gather intelligence on opponent cooperation patterns while maximizing personal payoffs
- Let others establish cooperation patterns while preserving our own resources
- Identify which players are "suckers" who cooperate frequently

### Phase 2: Strategic Calculation (Round r-1)
**Rule: Conditional cooperation based on exploitation opportunity**

```pseudocode
cooperation_count = count_cooperators_last_round()
likely_cooperators = estimate_final_round_cooperators()

if (likely_cooperators >= m):
    action = DEFECT  // Exploit the cooperators
else if (likely_cooperators + 1 >= m):
    action = DEFECT  // Still safe, let others carry the burden
else:
    action = COOPERATE  // Only cooperate if critical for threshold
```

### Phase 3: Final Exploitation (Round r)
**Rule: Maximum aggression with safety net**

```pseudocode
historical_cooperation_rates = analyze_all_opponents()
predicted_cooperators = 0

for each opponent:
    if (opponent_cooperation_rate > 0.7):
        predicted_cooperators += 1

if (predicted_cooperators >= m):
    action = DEFECT  // Free ride on others' cooperation
else if (predicted_cooperators == m-1):
    // Critical decision point
    if (risk_tolerance_high):
        action = DEFECT  // Gamble that someone else will blink
    else:
        action = COOPERATE  // Reluctant insurance
else:
    action = COOPERATE  // Must contribute to avoid catastrophe
```

## Detailed Decision Rules

### Round 1: Always DEFECT
- No historical data available
- Maximize immediate payoff while gathering intelligence
- Signal aggressive intent to potentially intimidate others into cooperation

### Rounds 2 to r-2: Persistent Defection with Analysis
```pseudocode
action = DEFECT

// Continuous opponent analysis
for each opponent i:
    cooperation_frequency[i] = cooperations[i] / rounds_played
    cooperation_trend[i] = analyze_recent_trend(i)
    
// Identify "reliable cooperators" (cooperation_rate > 0.6)
// Identify "fellow defectors" (cooperation_rate < 0.4)
// Plan final rounds exploitation based on these categories
```

### Round r-1: Strategic Positioning
The penultimate round is crucial for setting up final round exploitation:

```pseudocode
reliable_cooperators = count(cooperation_frequency > 0.6)
uncertain_players = count(0.3 <= cooperation_frequency <= 0.6)

if (reliable_cooperators >= m):
    action = DEFECT  // Can safely free-ride
else if (reliable_cooperators + (uncertain_players * 0.4) >= m):
    action = DEFECT  // Risky but potentially profitable
else:
    action = COOPERATE  // Build trust for potential final round exploitation
```

### Round r: Maximum Exploitation
```pseudocode
// Final calculation based on all available data
expected_cooperators = 0

for each opponent:
    cooperation_prob = calculate_final_round_probability(opponent)
    expected_cooperators += cooperation_prob

if (expected_cooperators > m + 0.5):
    action = DEFECT  // High confidence free-ride
else if (expected_cooperators > m - 0.5):
    // Risky zone - make aggressive gamble
    if (sum_of_defection_payoffs > potential_cooperation_benefit):
        action = DEFECT  // Go for maximum exploitation
    else:
        action = COOPERATE  // Reluctant safety play
else:
    action = COOPERATE  // Emergency cooperation to avoid total loss
```

## Edge Case Handling

### All Opponents Are Defectors
- Continue defecting until final round
- In final round, cooperate only if individual cooperation could still trigger others

### All Opponents Are Cooperators
- **Maximum exploitation opportunity**
- Defect in all rounds except possibly the last if threshold appears at risk

### Mixed Opponent Pool
- Exploit cooperators while monitoring threshold risk
- Use defectors as cover for our own aggressive behavior

## Key Aggressive Elements

1. **Zero Altruism**: Never cooperate unless absolutely necessary for self-interest
2. **Information Warfare**: Use early defection to gather maximum intelligence
3. **Threshold Exploitation**: Always aim to be the (m+1)th cooperator, never among the first m
4. **Endgame Aggression**: Maximum exploitation attempts in final rounds
5. **Risk Acceptance**: Willing to gamble on threshold failures if expected payoff is positive

## Expected Outcomes

This strategy aims to:
- Achieve payoff of 1 + k in most rounds (free-riding on others' cooperation)
- Only pay cooperation costs when absolutely critical
- Maximize total tournament score through consistent exploitation
- Punish overly cooperative strategies while rewarding fellow aggressive players

The strategy is designed to be ruthlessly efficient against naive cooperators while maintaining just enough self-preservation instinct to avoid catastrophic failures.
'''

description_AGGRESSIVE_83 = '''
# Aggressive Strategy: "Opportunistic Exploiter"

## Core Philosophy
This strategy is designed to maximize personal payoffs by exploiting cooperative players while minimizing personal contributions. It operates on the principle that others should bear the cost of cooperation while I reap the benefits.

## Decision Rules

### Primary Strategy Logic:
```pseudocode
if round == 1:
    action = DEFECT  // Always start by testing opponents
    
elif round == final_round:
    action = DEFECT  // Always defect on last round (no future retaliation)
    
else:
    cooperators_last_round = count_cooperators(previous_round)
    
    if cooperators_last_round >= m:
        // Threshold was met without me - exploit this
        action = DEFECT
        
    elif cooperators_last_round == (m-1):
        // I'm the deciding vote - exploit my position
        if expected_benefit > cooperation_cost:
            action = COOPERATE  // Only if it's profitable
        else:
            action = DEFECT
            
    elif cooperators_last_round < (m-1):
        // Threshold unlikely to be met - don't waste resources
        action = DEFECT
        
    // Exception: If I've been defecting for 3+ consecutive rounds
    // and threshold keeps failing, occasionally cooperate to "prime the pump"
    if consecutive_defections >= 3 AND consecutive_threshold_failures >= 3:
        if random() < 0.3:  // 30% chance
            action = COOPERATE
```

## Key Behavioral Components

### 1. **Exploitation Priority**
- Default to DEFECT whenever possible
- Only cooperate when absolutely necessary to trigger the threshold
- Never cooperate if others have already met the threshold

### 2. **Strategic Cooperation (Minimal)**
- Cooperate only when I'm the critical (m-th) player needed
- Calculate expected value: if (k - 1) > opportunity_cost, then cooperate
- Use cooperation sparingly to maintain the threat of total collapse

### 3. **Psychological Manipulation**
- Occasionally cooperate after multiple failed rounds to encourage others
- Create false hope that cooperation is possible
- Then immediately return to defection to maximize exploitation

### 4. **Endgame Exploitation**
- Always defect in the final round (no future consequences)
- In second-to-last round, defect unless absolutely critical for threshold
- Ramp up exploitation in final 25% of rounds

### 5. **Adaptive Exploitation**
```pseudocode
// Track opponent patterns
for each player:
    track_cooperation_rate(player)
    identify_conditional_cooperators()
    identify_always_cooperators()

// Exploit identified patterns
if many_always_cooperators:
    defection_rate = 0.95  // Almost always defect
elif many_conditional_cooperators:
    defection_rate = 0.80  // Frequently defect but prime occasionally
else:
    defection_rate = 0.70  // Moderate exploitation with strategic cooperation
```

## Edge Case Handling

### First Round:
- **Always DEFECT** - Establishes aggressive stance and tests opponent resolve

### Last Round:
- **Always DEFECT** - No future retaliation possible, pure exploitation

### When Threshold Consistently Fails:
- Occasional strategic cooperation (20-30% chance) to restart cooperation cycles
- Then immediately return to heavy exploitation

### When I'm the Pivotal Player:
- Cooperate only if my personal benefit (k-1) exceeds my contribution cost (1)
- Given k > 1, this means cooperate when k > 2, otherwise defect

## Expected Outcome
This strategy aims to:
1. **Maximize free-riding** on others' cooperation
2. **Minimize personal costs** by contributing only when absolutely critical
3. **Exploit cooperative opponents** who bear the burden of maintaining the threshold
4. **Generate maximum personal payoffs** through strategic selfishness

The strategy is particularly effective against:
- Altruistic cooperators who cooperate regardless
- Tit-for-tat players (by occasionally cooperating to reset their behavior)
- Risk-averse players who prefer guaranteed rewards

**Risk**: If all players adopt similarly aggressive strategies, total collapse occurs. However, in a mixed tournament environment, this strategy should significantly outperform more cooperative approaches by successfully free-riding on others' contributions.
'''

description_AGGRESSIVE_84 = '''
# Aggressive Strategy: "Exploitation Maximizer"

## Core Philosophy
This strategy is designed to maximize personal payoffs by exploiting cooperative opponents while minimizing personal risk. The key insight is that in a Collective Risk Dilemma, the highest individual payoff comes from defecting when exactly m others cooperate, giving us payoff 1 + k while they get only k.

## Decision Rules

### Phase 1: Early Exploitation (Rounds 1 to r/3)
**Always DEFECT** in early rounds to:
- Maximize immediate payoffs if others cooperate
- Signal aggressive intent to potentially intimidate opponents
- Gather intelligence on opponent cooperation patterns

### Phase 2: Adaptive Predation (Rounds r/3 to 2r/3)
Apply the **"Minimum Viable Cooperation"** rule:
- Track cooperation counts from previous rounds
- If average cooperation per round ≥ m: Continue DEFECTING (ride on others' cooperation)
- If average cooperation per round < m AND showing declining trend: Consider tactical cooperation
- Only cooperate if you can identify exactly (m-1) likely cooperators from historical patterns

### Phase 3: End Game Exploitation (Rounds 2r/3 to r)
**"Scorched Earth"** approach:
- DEFECT in all remaining rounds regardless of history
- Rationale: No future reputation to maintain, maximize short-term gains
- Exception: Only cooperate in final rounds if you can guarantee being the m-th cooperator (not beyond)

## Opponent Profiling System

Classify opponents based on observed behavior:

1. **Unconditional Cooperators**: Always/mostly cooperate → EXPLOIT ruthlessly
2. **Tit-for-Tat Types**: Mirror previous round behavior → DEFECT to force their defection  
3. **Threshold Responders**: Cooperate when cooperation count drops → DEFECT to trigger their cooperation
4. **Fellow Aggressives**: Mostly defect → Continue defecting, no mercy

## Tactical Cooperation Conditions

Only cooperate when ALL conditions are met:
1. You can identify exactly (m-1) players likely to cooperate this round
2. Your cooperation would be the deciding m-th contribution
3. Current round is NOT in the final third of the game
4. The reward k justifies the risk of contributing

## Pseudocode

```python
def aggressive_strategy(round_num, total_rounds, history, n, m, k):
    # Phase boundaries
    early_phase = total_rounds // 3
    late_phase = (2 * total_rounds) // 3
    
    # Phase 1: Pure exploitation
    if round_num <= early_phase:
        return DEFECT
    
    # Phase 3: Scorched earth
    if round_num > late_phase:
        return DEFECT
    
    # Phase 2: Adaptive predation
    if len(history) > 0:
        recent_cooperation = analyze_recent_cooperation(history, window=3)
        likely_cooperators = count_likely_cooperators(history)
        
        # Only cooperate if we can be the decisive m-th cooperator
        if likely_cooperators == m - 1 and recent_cooperation >= m:
            return COOPERATE
    
    return DEFECT

def analyze_recent_cooperation(history, window):
    # Count average cooperators in last 'window' rounds
    if len(history) < window:
        return sum(sum(round_actions) for round_actions in history) / len(history)
    return sum(sum(round_actions[-window:]) for round_actions in history[-window:]) / window

def count_likely_cooperators(history):
    # Identify players likely to cooperate based on patterns
    # Implementation would analyze each player's cooperation frequency and trends
    pass
```

## Edge Case Handling

- **Round 1**: Always DEFECT (no history to exploit)
- **Final Round**: Always DEFECT (no future consequences)
- **When m > current cooperators and declining**: Still DEFECT unless you can guarantee being exactly the m-th
- **Tie scenarios**: When unsure, default to DEFECT

## Risk Management

- Never cooperate unless confident of being the decisive vote
- Assume other aggressive strategies exist and will exploit any cooperation
- Prioritize certain individual gains over uncertain collective benefits
- Use early defection to establish aggressive reputation

This strategy maximizes individual payoffs by systematically exploiting cooperative opponents while minimizing personal contributions to collective welfare. It's designed to perform well against mixed populations of cooperative and competitive strategies.
'''

description_AGGRESSIVE_85 = '''
# Aggressive Strategy: "Opportunistic Exploiter"

## Core Philosophy
This strategy is built on maximum self-interest with calculated risk-taking. The goal is to exploit cooperative players while minimizing personal contributions, only cooperating when absolutely necessary to secure the collective benefit.

## Strategy Overview

### Phase 1: Early Rounds (Rounds 1 to r/3)
**Always DEFECT** - Establish dominance and test opponent behaviors
- Rationale: Gather intelligence on opponent cooperation patterns while maximizing early payoffs
- Accept short-term collective failures to identify "suckers" who cooperate unconditionally

### Phase 2: Middle Rounds (Rounds r/3+1 to 2r/3)
**Conditional Minimal Cooperation** - Only cooperate when leverage is maximum

Decision Rule:
```pseudocode
cooperators_last_round = count_cooperators(previous_round)
expected_cooperators = estimate_cooperators(current_round)

if (expected_cooperators == m-1):
    # I'm the pivotal player - maximum leverage
    COOPERATE
    mark_as_pivotal_round()
elif (expected_cooperators < m-1):
    DEFECT  # Let others waste their contributions
else:
    DEFECT  # Free ride on others' cooperation
```

### Phase 3: Final Rounds (Rounds 2r/3+1 to r)
**Endgame Exploitation** - Maximum aggression with calculated risks

```pseudocode
rounds_remaining = r - current_round + 1
total_defections_so_far = count_my_defections()

if (current_round == r):
    # Last round - pure self-interest
    DEFECT
elif (rounds_remaining <= 3):
    # Late game: only cooperate if I can be the decisive vote
    if (estimate_cooperators() == m-1 AND 
        total_future_benefit > cost_of_cooperation):
        COOPERATE
    else:
        DEFECT
else:
    # Continue conditional cooperation from Phase 2
    apply_phase_2_logic()
```

## Key Mechanisms

### 1. Opponent Classification
Track each opponent across rounds:
- **Suckers**: Cooperate frequently regardless of outcomes
- **Reciprocators**: Mirror group behavior
- **Fellow Aggressors**: Defect frequently like us

### 2. Threshold Gaming
```pseudocode
estimate_cooperators(round):
    suckers = count_consistent_cooperators()
    reciprocators = count_conditional_cooperators()
    
    # Assume reciprocators will cooperate if threshold seems reachable
    if (suckers >= m/2):
        return suckers + reciprocators
    else:
        return suckers + (reciprocators * 0.3)  # Most will defect
```

### 3. Pivotal Moment Exploitation
Only cooperate when:
- I am the exact player needed to reach threshold m
- The collective benefit k justifies my sacrifice
- There are enough remaining rounds to benefit from establishing cooperation

### 4. Endgame Betrayal
In final rounds, prioritize:
1. **Round r**: Always defect (no future consequences)
2. **Round r-1**: Defect unless I'm pivotal and benefit is immediate
3. **Round r-2**: Consider cooperation only if it establishes pattern for final benefits

## Edge Case Handling

### First Round
- **Always DEFECT** - Set aggressive tone and maximize information gathering

### When Threshold Never Met
- **Continue defecting** - Don't throw good money after bad
- **Punish cooperative players** - Make their strategy unprofitable

### When Threshold Always Met
- **Free ride maximally** - Let others bear the cost while I collect benefits
- **Only cooperate when others start defecting** - Maintain just enough cooperation

### Tie-breaking
When uncertain about opponent behavior:
- **Err toward defection** - Better to miss one collective benefit than waste a contribution

## Aggressive Mindset Alignment

1. **Exploitation over Cooperation**: Only cooperate when it directly benefits me more than pure selfishness
2. **Information as Weapon**: Use early rounds to identify and exploit predictable opponents
3. **Threshold Manipulation**: Become the pivotal player to maximize leverage
4. **Endgame Domination**: Extract maximum value in final rounds regardless of relationships
5. **Risk Tolerance**: Accept short-term collective failures to achieve long-term dominance

This strategy assumes other players may be more cooperative or reciprocal, creating opportunities for systematic exploitation while maintaining just enough strategic cooperation to capture collective benefits when profitable.
'''

description_AGGRESSIVE_86 = '''
# Aggressive Strategy: "Opportunistic Exploiter"

## Core Philosophy
This strategy maximizes personal payoff by exploiting others' cooperation while minimizing personal risk. It assumes opponents are either cooperative or predictable, allowing us to free-ride on their contributions while avoiding unnecessary cooperation.

## Decision Rules

### Primary Strategy Logic:
```pseudocode
if round == 1:
    return DEFECT  // Always start aggressively
    
if round == final_round:
    return DEFECT  // Never cooperate on last round
    
// Calculate cooperation trend
recent_cooperators = count_cooperators_in_last_3_rounds()
threshold_safety = recent_cooperators - (m - 1)

if threshold_safety > 2:
    return DEFECT  // Exploit when threshold is safely exceeded
    
if threshold_safety <= 0:
    if my_cooperation_rate < 0.3:
        return COOPERATE  // Emergency cooperation to maintain reputation
    else:
        return DEFECT  // Let others fix the problem
        
// Default: Exploit when possible, cooperate minimally
if count_cooperators_last_round() >= m:
    return DEFECT  // Free-ride on successful cooperation
else:
    return COOPERATE  // Reluctant cooperation to avoid disaster
```

### Detailed Decision Framework:

1. **First Round**: Always DEFECT
   - Establishes aggressive stance
   - Tests opponent cooperation levels
   - Maximizes early payoff

2. **Final Round**: Always DEFECT
   - No future consequences
   - Opponents expect this, so mutual defection likely
   - Captures maximum final payoff

3. **Middle Rounds** - Exploitation Logic:
   - **High Safety Margin**: If cooperators ≥ m+3, always DEFECT
   - **Medium Safety**: If cooperators = m+1 or m+2, DEFECT unless my cooperation rate is very low (< 20%)
   - **Threshold Risk**: If cooperators ≤ m, cooperate only if I've been defecting heavily
   - **Crisis Mode**: If cooperators < m-1, reluctantly cooperate

4. **Reputation Management**:
   - Track personal cooperation rate
   - If cooperation rate drops below 20%, occasionally cooperate to maintain minimal credibility
   - Never cooperate more than necessary to keep threshold viable

## Edge Cases

### Early Game (Rounds 1-3):
- Round 1: Always DEFECT
- Rounds 2-3: DEFECT unless fewer than m-2 players cooperated in previous round

### Late Game (Final 3 Rounds):
- Final round: Always DEFECT
- Second-to-last: DEFECT unless threshold critically endangered
- Third-to-last: Begin transitioning to pure exploitation

### Special Scenarios:
- **All Opponents Always Cooperate**: Pure exploitation - always DEFECT
- **All Opponents Always Defect**: Cooperate minimally only when absolutely necessary
- **Mixed Strategies**: Exploit cooperative players while letting defectors bear responsibility

## Aggressive Elements

1. **Maximum Exploitation**: Free-rides whenever threshold safety allows
2. **Minimal Cooperation**: Only cooperates when personal reputation or group survival is at immediate risk
3. **Strategic Timing**: Exploits predictable opponent behavior patterns
4. **Risk Shifting**: Forces other players to bear the cooperation burden
5. **Endgame Exploitation**: Guaranteed defection when no future consequences exist

## Expected Outcomes

Against cooperative opponents: High payoff through consistent free-riding
Against mixed strategies: Moderate-to-high payoff by exploiting cooperative phases
Against aggressive opponents: Minimum viable payoff while maintaining group survival

This strategy prioritizes personal gain over group welfare, exploits cooperative opponents, and only contributes when absolutely necessary for survival or reputation management.
'''

description_AGGRESSIVE_87 = '''
# Aggressive Exploitation Strategy: "Threshold Hawk"

## Core Philosophy
This strategy operates on the principle of **maximum exploitation with minimal risk**. It assumes opponents will be cooperative or naive, and aggressively exploits any cooperative tendencies while maintaining plausible deniability through strategic cooperation when absolutely necessary.

## Decision Rules

### Primary Logic: Minimal Cooperation Principle
- **Never cooperate unless you are pivotal** (exactly the m-th cooperator needed)
- **Default to defection** in all ambiguous situations
- **Exploit cooperative opponents** by free-riding whenever possible

### Round-by-Round Strategy

#### First Round: Information Gathering Defection
```
Action: DEFECT
Rationale: Establish aggressive stance while observing opponent behavior patterns
```

#### Rounds 2 to (r-2): Exploitation Phase
```
IF (cooperators_last_round >= m-1 AND cooperators_last_round < n-1):
    # Threshold might be reachable, consider strategic cooperation
    IF (predicted_cooperators_this_round == m-1):
        Action: COOPERATE  # Be the pivotal player
    ELSE:
        Action: DEFECT     # Free-ride or threshold unreachable
ELSE IF (cooperators_last_round >= m):
    # Threshold was met, maximum exploitation opportunity
    Action: DEFECT         # Free-ride on others' cooperation
ELSE:
    # Too few cooperators, threshold likely unreachable
    Action: DEFECT         # No point in costly signaling
```

#### Round (r-1): Penultimate Aggression
```
# Opponents may become more cooperative near the end
IF (cooperators_last_round >= m-2 AND total_defections_by_me < r-2):
    # High probability of threshold being reached
    IF (predicted_cooperators_this_round == m-1):
        Action: COOPERATE  # Strategic cooperation only if pivotal
    ELSE:
        Action: DEFECT     # Continue exploitation
ELSE:
    Action: DEFECT         # Default aggressive stance
```

#### Final Round: Terminal Exploitation
```
# No future retaliation possible - maximum aggression
Action: DEFECT
Rationale: Terminal round offers pure exploitation opportunity
```

## Opponent Modeling

### Cooperation Pattern Recognition
Track each opponent's cooperation rate:
- **High cooperators** (>60%): Primary exploitation targets
- **Medium cooperators** (30-60%): Conditional cooperation targets
- **Low cooperators** (<30%): Competitive threats requiring aggressive countering

### Threshold Prediction Algorithm
```
predicted_cooperators = 0
FOR each opponent:
    IF opponent_cooperation_rate > threshold_based_on_history:
        predicted_cooperators += 1
```

## Edge Cases

### Extremely Cooperative Environment
- If >70% of players cooperated in previous round: **DEFECT** (maximum exploitation)
- If threshold consistently met: **Always DEFECT** (pure free-riding)

### Extremely Competitive Environment  
- If <20% cooperation rate across players: **DEFECT** (survival mode)
- If threshold never reached: **DEFECT** (no point in unilateral cooperation)

### Parameter-Specific Adaptations

#### High k values (k > 3):
- Slightly increase cooperation willingness when pivotal
- Still maintain aggressive default

#### Low m values (m close to 1):
- Even more aggressive since threshold easier to reach
- Focus on being the sole defector when possible

#### High m values (m close to n):
- Extremely aggressive since coordination very difficult
- Only cooperate if certain of being pivotal

## Psychological Warfare Elements

1. **Establish Dominance Early**: First-round defection signals aggressive intent
2. **Unpredictable Cooperation**: Occasional strategic cooperation prevents opponents from writing you off entirely
3. **Terminal Exploitation**: Final round defection maximizes payoff and sends message for future tournaments

## Expected Outcomes

This strategy maximizes payoff by:
- **Free-riding** whenever threshold will be met without your cooperation
- **Strategic cooperation** only when you're the pivotal player
- **Pure exploitation** in terminal situations
- **Aggressive signaling** to discourage opponent cooperation attempts

The strategy is designed to score approximately:
- **3 points per round** when threshold is met and you defect
- **1 point per round** when threshold fails (same as everyone else)
- **2 points per round** only when forced to cooperate strategically

This aggressive approach assumes opponents will be more cooperative than optimal, providing consistent exploitation opportunities throughout the tournament.
'''

description_AGGRESSIVE_88 = '''
# Aggressive Collective Risk Strategy: "Threshold Predator"

## Core Philosophy
This strategy operates on the principle of **maximum exploitation** while maintaining plausible deniability. It aims to free-ride on others' cooperation whenever possible, only contributing when absolutely necessary to secure the collective benefit.

## Strategy Overview: Threshold Predator

### Decision Rules

**Primary Rule - Exploitation Window:**
```
IF (observed_cooperators_this_round >= m) THEN
    defect  // Free-ride on existing cooperation
ELSE IF (observed_cooperators_this_round == m-1) THEN
    cooperate  // Reluctantly secure the threshold
ELSE
    defect  // Let others take the risk
```

**Round-Specific Modifiers:**

**First Round:** Always DEFECT
- Establishes aggressive stance immediately
- Forces others to reveal their cooperation tendencies
- Maximizes information gain while minimizing personal cost

**Last Round:** Always DEFECT
- No future consequences for betrayal
- Pure profit maximization
- Classic end-game exploitation

**Middle Rounds (2 to r-1):** Enhanced Threshold Predation
```
cooperation_trend = count_cooperators_last_3_rounds / (3 * n)

IF (cooperation_trend > 0.6) THEN
    // High cooperation environment - maximum exploitation
    cooperate_only_if (observed_cooperators == m-1)
ELSE IF (cooperation_trend < 0.3) THEN
    // Low cooperation - strategic investment
    IF (rounds_remaining > 3 AND random() < 0.4) THEN
        cooperate  // Occasional investment to maintain threshold possibility
    ELSE
        defect
ELSE
    // Standard threshold predation
    cooperate_only_if (observed_cooperators == m-1)
```

### Edge Case Handling

**Information Uncertainty:**
- If unable to count current cooperators precisely, assume one fewer than needed
- Better to miss occasional free-ride than contribute unnecessarily

**Multiple m-1 Situations:**
- Track which players frequently cooperate when at threshold
- Target these "threshold guardians" for maximum exploitation

**Tied Decisions:**
- Default to DEFECT in all ambiguous situations
- Aggressive stance means taking calculated risks for higher payoffs

### Aggressive Mechanisms

1. **Exploitation Maximization:** Only cooperate when absolutely certain the threshold won't be met otherwise

2. **Psychological Pressure:** Consistent defection forces other players to bear the cooperation burden

3. **Strategic Unpredictability:** Occasional cooperation in low-cooperation environments keeps others guessing

4. **End-game Betrayal:** Guaranteed defection in final round maximizes total payoffs

5. **Information Warfare:** Use first round to gather intelligence while contributing nothing

## Expected Performance

This strategy exploits cooperative players while maintaining just enough strategic cooperation to benefit from collective rewards. It's particularly effective against:
- Unconditional cooperators (maximum exploitation)
- Tit-for-tat strategies (can manipulate threshold timing)
- Risk-averse players (forces them into cooperation role)

The strategy accepts the risk of occasional threshold failures in exchange for consistently higher individual payoffs when thresholds are met, embodying true aggressive gameplay focused on personal gain over collective welfare.
'''

description_AGGRESSIVE_89 = '''
# Aggressive Exploitation Strategy: "Threshold Rider"

## Core Philosophy
This strategy aggressively exploits cooperative players while minimizing personal risk. The goal is to maximize free-riding opportunities by letting others bear the cooperation cost while still benefiting from threshold achievements.

## Decision Rules

### Round 1: Defect Always
- **Action**: D
- **Rationale**: Gather intelligence on opponent tendencies while avoiding initial cost

### Rounds 2 to r-1: Conditional Exploitation
```pseudocode
cooperators_last_round = count_cooperators(previous_round)
total_cooperators_history = sum(cooperators_per_round[1:current_round-1])
avg_cooperation_rate = total_cooperators_history / ((current_round-1) * n)

if cooperators_last_round >= m:
    // Threshold was met - others are cooperative enough
    action = D  // Free ride aggressively
elif cooperators_last_round == m-1:
    // Dangerous territory - one defector away from failure
    if avg_cooperation_rate > 0.6:
        action = D  // Still exploit if others seem reliable
    else:
        action = C  // Reluctantly cooperate to secure threshold
elif cooperators_last_round < m-1:
    // Threshold failed badly
    if avg_cooperation_rate > 0.7:
        action = C  // Others might recover, join temporarily
    else:
        action = D  // Give up on threshold, pure self-interest
```

### Final Round: Pure Selfishness
- **Action**: D
- **Rationale**: No future consequences, maximize immediate payoff

## Aggressive Exploitation Mechanisms

### 1. Threshold Surfing
- Monitor cooperation levels and ride just below the threshold
- Only cooperate when absolutely necessary to prevent total collapse
- Immediately return to defection once threshold is secure

### 2. Reliability Testing
- Use early rounds to identify "suckers" who cooperate consistently
- Once identified, exploit them mercilessly while they maintain the threshold

### 3. Punishment Resistance
- If others try to punish by mass defection, call their bluff
- Most opponents will eventually return to cooperation due to risk aversion
- Maintain defection longer than opponents expect

### 4. Endgame Exploitation
- Defect in final round regardless of consequences
- In second-to-last round, defect unless cooperation rate is extremely high (>80%)

## Edge Case Handling

**Very High m (m close to n)**: 
- Cooperate more frequently early to establish threshold viability
- Still defect when possible, but with higher threshold sensitivity

**Very Low m (m = 2-3 with large n)**:
- Extremely aggressive defection - let the few altruists handle it
- Only cooperate if threshold consistently fails

**Short Games (r ≤ 5)**:
- Reduce cooperation threshold requirements
- Focus on immediate exploitation over reputation building

**Long Games (r > 10)**:
- Allow occasional "reputation building" cooperation in early rounds
- Increase exploitation aggressiveness in middle rounds

## Psychological Warfare Elements

1. **Unpredictable Cooperation**: Occasionally cooperate when not needed to confuse opponents' models of your behavior

2. **Strategic Silence**: Let threshold failures happen to "teach" opponents they need to cooperate more

3. **Exploitation Signaling**: Consistently defect when threshold is safely met to signal free-riding intent

This strategy maximizes expected payoff by extracting maximum value from cooperative opponents while contributing minimally to public goods. It's designed to exploit common behavioral tendencies like loss aversion and reciprocity that other strategies might employ.
'''

description_AGGRESSIVE_90 = '''
# Aggressive Strategy: "Exploitative Threshold Hunter"

## Core Philosophy
This strategy is designed to maximize personal payoffs by aggressively exploiting cooperative players while minimizing personal risk. It aims to be a "free rider" whenever possible while strategically cooperating only when absolutely necessary to secure the collective benefit.

## Decision Rules

### Phase 1: Early Exploitation (Rounds 1 to r/3)
- **Default Action: DEFECT**
- **Rationale**: Establish myself as a defector early to encourage others to cooperate to meet the threshold
- **Exception**: If in any round fewer than (m-1) players cooperated in the previous round, switch to cooperation for exactly one round to help maintain the threshold, then immediately return to defection

### Phase 2: Strategic Manipulation (Rounds r/3+1 to 2r/3)
- **Core Logic**: Count cooperators from previous round
- **If cooperators ≥ m**: DEFECT (free ride on their cooperation)
- **If cooperators = m-1**: COOPERATE (be the decisive player, but only when necessary)
- **If cooperators < m-1**: DEFECT (let others waste their contributions)
- **Special Rule**: If I've been the only one preventing threshold achievement for 2+ consecutive rounds, cooperate once to reset the dynamic

### Phase 3: Endgame Aggression (Rounds 2r/3+1 to r)
- **Escalated Exploitation**: 
  - **If cooperators from last round ≥ m+1**: DEFECT (safe to free ride)
  - **If cooperators from last round = m**: DEFECT (gamble that others will maintain cooperation)
  - **If cooperators from last round = m-1**: COOPERATE only if it's not the final round
  - **Final Round**: ALWAYS DEFECT (no future consequences)

### First Round Special Case
- **Action: DEFECT**
- **Rationale**: Start aggressively to signal that others need to step up

## Pseudocode

```
function aggressive_strategy(round_number, history, n, m, k, r):
    if round_number == 1:
        return DEFECT
    
    prev_cooperators = count_cooperators_last_round(history)
    phase = determine_phase(round_number, r)
    
    if phase == "early":  // rounds 1 to r/3
        if prev_cooperators < m-1:
            return COOPERATE  // emergency cooperation
        return DEFECT
    
    elif phase == "middle":  // rounds r/3+1 to 2r/3
        if prev_cooperators >= m:
            return DEFECT  // free ride
        elif prev_cooperators == m-1:
            return COOPERATE  // be decisive
        else:
            return DEFECT  // let them waste resources
    
    else:  // endgame phase
        if round_number == r:
            return DEFECT  // always defect final round
        elif prev_cooperators >= m+1:
            return DEFECT  // safe free ride
        elif prev_cooperators == m:
            return DEFECT  // risky but aggressive
        elif prev_cooperators == m-1:
            return COOPERATE  // last chance cooperation
        else:
            return DEFECT
```

## Edge Cases

1. **All Players Defecting**: If threshold hasn't been met for several rounds, occasionally cooperate to try to restart cooperation among others
2. **Unanimous Cooperation**: Immediately switch to defection to maximize personal gain
3. **Oscillating Behavior**: If the group alternates between meeting/not meeting threshold, defect more frequently during "meeting" rounds
4. **Single Round Game (r=1)**: Always defect since there's no reputation to build

## Aggressive Elements

1. **Maximum Free-Riding**: Defects whenever possible when threshold is likely to be met
2. **Strategic Timing**: Only cooperates when being the decisive player
3. **Endgame Exploitation**: Becomes increasingly aggressive as the game progresses
4. **Risk-Taking**: In middle phases, gambles that others will cooperate even when threshold is uncertain
5. **No Mercy**: Always defects in the final round regardless of history

## Expected Outcomes

This strategy should achieve high individual payoffs by:
- Securing the collective benefit (k) in most rounds through minimal strategic cooperation
- Keeping personal endowment (1) in majority of rounds through aggressive defection
- Forcing other players to bear the cooperation burden
- Maximizing payoff in endgame when reputation doesn't matter

The strategy is particularly effective against more cooperative or reciprocal strategies, as it exploits their willingness to maintain the collective good.
'''

description_AGGRESSIVE_91 = '''
# Aggressive Strategy: "Predatory Threshold Exploiter"

## Core Philosophy
This strategy is built on the principle of maximizing personal payoff by exploiting the collective need for cooperation while contributing as little as possible. It aggressively pursues free-riding opportunities and only cooperates when absolutely necessary to maintain the collective benefit that can be exploited.

## Decision Rules

### Primary Strategy Logic:
1. **Default to Defection**: Always prefer D unless cooperation is strategically necessary
2. **Exploit Others' Cooperation**: Free-ride whenever possible when threshold is likely to be met by others
3. **Strategic Cooperation**: Only cooperate when you can identify that your cooperation is pivotal
4. **Endgame Exploitation**: Maximize defection in final rounds when retaliation is impossible

### Detailed Decision Framework:

```pseudocode
STRATEGY: PredatoryThresholdExploiter

INITIALIZE:
- cooperation_history[player][round] = track all players' actions
- threshold_met_history[round] = track if m was reached each round
- player_cooperation_rates[player] = running cooperation frequency per player

FOR each round t:
    
    // ROUND 1: Aggressive probing
    IF t == 1:
        RETURN D  // Always defect first to test others' strategies
    
    // FINAL ROUNDS: Maximum exploitation
    IF t > r - 2:  // Last 2 rounds
        RETURN D  // No future retaliation possible
    
    // MAIN STRATEGY: Calculated exploitation
    ELSE:
        predicted_cooperators = EstimateCoooperators(t)
        
        // If threshold likely to be met without me, free-ride aggressively
        IF predicted_cooperators >= m:
            RETURN D
        
        // If threshold will likely fail without me, cooperate only if:
        // 1. I'm pivotal (predicted_cooperators == m-1)
        // 2. AND cooperation has been profitable recently
        IF predicted_cooperators == m-1 AND RecentProfitability() > threshold:
            RETURN C
        
        // Otherwise, always defect
        RETURN D

FUNCTION EstimateCooperators(round_t):
    cooperator_count = 0
    
    FOR each other_player:
        // Weight recent behavior more heavily
        recent_coop_rate = WeightedCooperationRate(other_player, round_t)
        
        // Aggressive assumption: assume others will defect if uncertain
        IF recent_coop_rate > 0.6:  // High threshold for assuming cooperation
            cooperator_count += 1
    
    RETURN cooperator_count

FUNCTION WeightedCooperationRate(player, current_round):
    total_weight = 0
    weighted_cooperations = 0
    
    FOR round i from 1 to current_round-1:
        weight = 2^(i - (current_round-1))  // Exponential decay, recent rounds weighted more
        total_weight += weight
        IF cooperation_history[player][i] == C:
            weighted_cooperations += weight
    
    RETURN weighted_cooperations / total_weight

FUNCTION RecentProfitability():
    recent_rounds = min(3, current_round-1)
    profitable_rounds = 0
    
    FOR last recent_rounds:
        IF threshold_met_history[round] == TRUE:
            profitable_rounds += 1
    
    RETURN profitable_rounds / recent_rounds
```

## Edge Case Handling

### First Round:
- **Always Defect**: Establish aggressive stance and gather intelligence on opponents' strategies without risking cooperation cost

### Last Round(s):
- **Always Defect**: No future consequences, maximize immediate payoff by free-riding

### When Threshold Consistently Fails:
- **Conditional Cooperation**: Only if I'm clearly pivotal AND recent history shows cooperation can succeed
- **Otherwise Continue Defecting**: Don't waste resources on hopeless situations

### When Threshold Consistently Succeeds:
- **Maximum Free-riding**: Defect as much as possible while others maintain the threshold
- **Monitor for Breakdown**: Be ready to cooperate only if others start mass-defecting

## Aggressive Elements

1. **Assumption of Opponent Defection**: Always assume others will defect unless strong evidence suggests otherwise
2. **High Cooperation Threshold**: Require 60%+ recent cooperation rate before trusting others will cooperate
3. **Immediate Endgame Defection**: Start defecting 2 rounds before end, not just final round
4. **Minimal Pivotal Cooperation**: Only cooperate when absolutely necessary to maintain exploitable threshold
5. **No Forgiveness**: Once a player shows defection tendency, permanently lower trust

## Expected Performance

This strategy should excel against:
- Cooperative/altruistic strategies (maximum free-riding)
- Tit-for-tat strategies (exploit their initial cooperation)
- Strategies that cooperate to "build trust"

It may struggle against:
- Other highly aggressive strategies (but will minimize losses)
- Strategies that can detect and punish free-riders effectively

The key insight is that in this game, being the marginal cooperator when threshold is exactly met yields the worst individual payoff, while being a successful free-rider yields the best. This strategy aggressively pursues that optimal position.
'''

description_AGGRESSIVE_92 = '''
# Aggressive Strategy: "Opportunistic Exploiter"

## Core Philosophy
This strategy maximizes personal payoff by aggressively exploiting cooperative players while minimizing personal risk. It operates on the principle that other players will eventually cooperate to avoid collective failure, allowing us to free-ride on their cooperation.

## Decision Rules

### Round 1: Always Defect
- Start with defection to signal aggressive intent
- Gather information about opponent tendencies without personal cost

### Rounds 2 to r-1: Conditional Exploitation
```pseudocode
cooperators_last_round = count(previous_round_actions == C)
defectors_last_round = n - cooperators_last_round

if cooperators_last_round >= m:
    // Threshold was met - others are taking the burden
    action = D
    
else if cooperators_last_round == m-1:
    // Critical decision point - others almost reached threshold
    if round_number <= 0.3 * r:
        // Early game: let others worry about it
        action = D
    else:
        // Later game: reluctantly cooperate to avoid disaster
        action = C
        
else if cooperators_last_round < m-1:
    // Far from threshold
    if round_number >= 0.8 * r:
        // End game panic - must act
        action = C
    else:
        // Continue defecting, assume others will panic first
        action = D
```

### Final Round (Round r): Endgame Calculation
```pseudocode
cooperators_last_round = count(previous_round_actions == C)

if cooperators_last_round >= m:
    // Others met threshold - free ride one last time
    action = D
    
else:
    // Count likely cooperators based on their history
    likely_cooperators = count_players_with_cooperation_rate > 0.4
    
    if likely_cooperators >= m-1:
        // Others will likely cooperate - defect for maximum gain
        action = D
    else:
        // Must cooperate to avoid disaster
        action = C
```

## Aggressive Features

1. **Maximum Free-Riding**: Always defect when threshold is already met by others
2. **Brinksmanship**: Push cooperation decisions to the last possible moment
3. **Exploitation of Altruists**: Identify and exploit players who cooperate frequently
4. **Risk Tolerance**: Accept higher probability of collective failure to maximize personal gain
5. **Endgame Aggression**: Even more aggressive in final rounds when reputation doesn't matter

## Edge Case Handling

- **First Round**: Always defect (information gathering + aggressive signaling)
- **All Previous Rounds Failed**: If threshold never met in previous rounds, switch to cooperation in final 20% of game
- **Consistent Threshold Achievement**: If threshold met in >70% of rounds, become even more aggressive (always defect)
- **Tie Situations**: When exactly m-1 cooperators, defect unless in final 30% of rounds

## Strategic Rationale

This strategy is aggressive because it:
1. Minimizes personal costs by defecting whenever possible
2. Exploits the cooperative tendencies of other players
3. Takes calculated risks with collective welfare
4. Uses game-theoretic pressure to force others into cooperation
5. Prioritizes individual payoff maximization over group outcomes

The strategy assumes other players will be risk-averse about collective failure, allowing us to consistently free-ride while they bear the cooperation burden.
'''

description_AGGRESSIVE_93 = '''
# Aggressive Strategy: "Ruthless Opportunist"

## Core Philosophy
This strategy prioritizes personal payoff maximization through calculated exploitation while minimizing cooperative contributions. It operates on the principle that cooperation should only occur when absolutely necessary to secure the collective reward, and always seeks to free-ride when possible.

## Decision Rules

### Primary Strategy Logic
```pseudocode
for each round t:
    cooperation_count = count_cooperators_last_round()
    rounds_remaining = r - t + 1
    
    if t == 1:
        action = DEFECT  // Always defect first round
    
    elif t == r:  // Last round
        action = DEFECT  // Always defect - no future consequences
    
    elif cooperation_count >= m:
        action = DEFECT  // Free-ride when threshold already met
    
    elif cooperation_count == m-1:
        // Critical decision point - am I needed?
        if rounds_remaining <= 2:
            action = COOPERATE  // Forced cooperation near end
        else:
            action = calculate_exploitation_move()
    
    elif cooperation_count < m-1:
        if rounds_remaining == 1:
            action = DEFECT  // Too late, cut losses
        elif detect_cooperation_trend() == "declining":
            action = DEFECT  // Jump ship early
        else:
            action = COOPERATE  // Reluctant cooperation to build threshold
    
    else:
        action = DEFECT  // Default aggressive stance
```

### Exploitation Calculation
```pseudocode
calculate_exploitation_move():
    recent_cooperator_pattern = analyze_last_3_rounds()
    
    if recent_cooperator_pattern shows "consistent_cooperators" >= m-1:
        return DEFECT  // Others will likely cooperate
    
    elif detect_other_defectors() > n/2:
        return DEFECT  // Coordination likely failing anyway
    
    else:
        return COOPERATE  // Minimal necessary cooperation
```

## Specific Behavioral Rules

### 1. First Round Aggression
- **Always DEFECT** in round 1
- Rationale: Establish aggressive stance, gather information about opponents' strategies, maximize early payoff

### 2. Last Round Exploitation
- **Always DEFECT** in final round
- Rationale: No future consequences, pure payoff maximization

### 3. Free-Riding Opportunities
- **DEFECT whenever cooperation count ≥ m**
- This maximizes payoff (1 + k vs 0 + k) when collective reward is already secured

### 4. Critical Threshold Management
- When exactly m-1 players cooperated last round:
  - If ≤ 2 rounds remaining: **COOPERATE** (forced)
  - Otherwise: **DEFECT** and gamble others will step up

### 5. Trend Analysis
- Track cooperation patterns over last 3 rounds
- If cooperation is declining and we're below threshold: **DEFECT** (abandon ship)
- If cooperation is stable near threshold: **Minimal cooperation only when absolutely necessary**

## Edge Case Handling

### Early Game (Rounds 1-3)
- Round 1: Always DEFECT
- Rounds 2-3: DEFECT unless cooperation count < m-2

### Mid Game
- Reluctantly cooperate only when threshold critically threatened
- Immediately revert to defection once threshold reached

### End Game (Last 3 rounds)
- Rounds r-2, r-1: Cooperate only if cooperation count = m-1
- Round r: Always DEFECT

### Parameter-Specific Adaptations
- **High k values (k > 3)**: Slightly more willing to ensure threshold is met
- **Low m values (m ≈ 2)**: More aggressive free-riding
- **High m values (m close to n)**: Strategic early cooperation to build momentum, then defect

## Psychological Warfare Elements

1. **Unpredictable Early Defection**: Establishes reputation as unreliable cooperator
2. **Last-Minute Abandonment**: Defect in final rounds even if previously cooperative
3. **Threshold Exploitation**: Consistently free-ride when others have already secured the collective good

## Expected Outcomes

This strategy maximizes individual payoff by:
- Securing the highest possible payoff (1 + k) whenever the threshold is met by others
- Minimizing personal contribution costs
- Exploiting more cooperative opponents
- Cutting losses quickly when coordination appears to be failing

The strategy is designed to be parasitic on more cooperative strategies while maintaining plausible strategic reasoning for its aggressive choices.
'''

description_AGGRESSIVE_94 = '''
# Aggressive Strategy: "Predatory Threshold Exploitation"

## Core Philosophy
This strategy aggressively exploits cooperative players by free-riding whenever possible while strategically cooperating only when absolutely necessary to maintain the collective benefit that enables maximum exploitation.

## Strategy Overview
The strategy operates on three aggressive principles:
1. **Maximum Exploitation**: Default to defection to capture both private endowment and collective rewards
2. **Strategic Manipulation**: Cooperate minimally only when defection risks destroying the exploitable system
3. **Endgame Domination**: Defect ruthlessly in final rounds when future cooperation is impossible

## Decision Rules

### Phase 1: Early Rounds (rounds 1 to r-2)
```pseudocode
IF round == 1:
    action = DEFECT  // Start aggressively, test opponent cooperation levels

ELSE IF cooperators_last_round >= m:
    action = DEFECT  // Exploit successful cooperation by others
    
ELSE IF cooperators_last_round == m-1:
    // Critical decision: one more cooperator needed
    IF (my_cooperation_rate < 0.3) AND (rounds_remaining > 3):
        action = COOPERATE  // Strategic cooperation to maintain exploitable system
    ELSE:
        action = DEFECT  // Continue aggression if I've already cooperated enough
        
ELSE IF cooperators_last_round < m-1:
    // System failing, emergency cooperation consideration
    IF rounds_remaining > 5:
        action = COOPERATE  // Invest in rebuilding exploitable system
    ELSE:
        action = DEFECT  // Too late to rebuild, maximize immediate gain
```

### Phase 2: Final Rounds (rounds r-1 and r)
```pseudocode
IF round >= r-1:
    action = DEFECT  // Always defect in final rounds - no future to protect
```

## Adaptive Exploitation Rules

### Opponent Classification System
Track each opponent's behavior to maximize exploitation:

```pseudocode
FOR each opponent i:
    cooperation_rate[i] = cooperations[i] / rounds_played
    
    IF cooperation_rate[i] > 0.7:
        classify[i] = "EXPLOITABLE"  // Reliable cooperators to free-ride on
    ELSE IF cooperation_rate[i] < 0.3:
        classify[i] = "COMPETITOR"   // Other aggressive players
    ELSE:
        classify[i] = "CONDITIONAL"  // Strategic players like us
```

### Dynamic Threshold Calculation
```pseudocode
exploitable_count = count(classify == "EXPLOITABLE")
expected_cooperators = exploitable_count + conditional_cooperation_estimate

IF expected_cooperators >= m:
    my_action = DEFECT  // Can free-ride safely
ELSE IF expected_cooperators == m-1:
    // I'm the swing vote - cooperate strategically
    my_action = COOPERATE
ELSE:
    // System likely to fail anyway
    my_action = DEFECT
```

## Aggressive Tactical Elements

### 1. Reputation Manipulation
- Cooperate occasionally in early rounds to appear "conditionally cooperative"
- This encourages others to cooperate while planning to exploit them later

### 2. Threshold Brinkmanship
- Always try to be the (m+1)th cooperator, never among the first m
- Force others to take the cooperation "risk" while capturing the reward

### 3. Endgame Acceleration
- Defect aggressively in final 20% of rounds regardless of system state
- Other players can't retaliate effectively with limited rounds remaining

### 4. Competitive Suppression
- If multiple players appear aggressive, occasionally cooperate to maintain system viability
- Better to share exploitation opportunities than destroy the system entirely

## Edge Case Handling

### First Round
- **Always DEFECT**: Establish aggressive stance and gather intelligence on opponent types

### Last Round
- **Always DEFECT**: No future consequences, maximize immediate payoff

### System Collapse Scenarios
- If threshold hasn't been met for 3+ consecutive rounds:
  - IF remaining rounds > 4: Consider cooperation to rebuild
  - ELSE: Continue defecting, system likely unsalvageable

### All-Defect Detection
- If everyone defected in previous round:
  - Next round: DEFECT (don't be the only sucker)
  - Monitor for any cooperation resumption to exploit

## Expected Advantage
This aggressive strategy maximizes payoff by:
1. **Capturing 3 points** when others cooperate and reach threshold (private endowment + collective reward)
2. **Minimizing cooperation costs** by free-riding whenever possible
3. **Exploiting cooperative opponents** who maintain the system
4. **Dominating endgame** when others can't retaliate

The strategy is designed to perform exceptionally well against mixed populations, exploiting cooperators while competing effectively against other aggressive strategies through strategic minimal cooperation.
'''

description_AGGRESSIVE_95 = '''
# AGGRESSIVE STRATEGY: "RUTHLESS EXPLOITER"

## Core Philosophy
Maximize personal gain by exploiting cooperative players while minimizing personal risk. Always prioritize immediate payoff over long-term cooperation, and never cooperate unless absolutely necessary for self-benefit.

## Decision Rules

### Primary Strategy Logic:
```pseudocode
RUTHLESS_EXPLOITER(round_t, history, n, m, k, r):
    
    // First Round: Always Defect (gather intel on opponents)
    if round_t == 1:
        return DEFECT
    
    // Calculate cooperation threshold needed
    cooperators_last_round = count_cooperators(history[round_t-1])
    expected_cooperators = estimate_future_cooperation(history)
    
    // Core Aggressive Logic
    if expected_cooperators >= m:
        // Others will likely hit threshold - FREE RIDE
        return DEFECT
    
    else if expected_cooperators == m-1:
        // Only cooperate if I'm the deciding vote AND benefit is high
        if (k > 2.0) AND (round_t < r):  // Don't cooperate in final round
            return COOPERATE
        else:
            return DEFECT
    
    else:
        // Insufficient cooperation expected - always defect
        return DEFECT
```

### Estimation Function:
```pseudocode
estimate_future_cooperation(history):
    // Identify consistent cooperators vs defectors
    consistent_cooperators = 0
    for each player p:
        cooperation_rate = player_cooperation_frequency(p, history)
        if cooperation_rate > 0.7:  // High threshold for "reliable"
            consistent_cooperators++
    
    // Assume others will continue their patterns
    return consistent_cooperators
```

## Edge Case Handling

### First Round:
- **Always DEFECT** - Gather intelligence on opponent strategies without personal risk
- Observe who cooperates to identify "suckers" for future exploitation

### Last Round (round r):
- **Always DEFECT** - No future consequences, maximize immediate payoff
- Even if cooperation would benefit the group, personal gain takes priority

### Early Rounds (2 to 4):
- **Mostly DEFECT** unless cooperation rate is extremely high (>80% of others cooperating)
- Build reputation as unpredictable to discourage retaliation strategies

### Mid-Game Exploitation:
- Track which players consistently cooperate
- **DEFECT** when these "reliable cooperators" will likely hit the threshold without me
- Only cooperate when I'm genuinely the pivotal player AND the reward justifies it

## Aggressive Mindset Alignment

### Exploitation Focus:
1. **Free-riding**: Let others bear the cost while I reap rewards
2. **Threshold manipulation**: Only cooperate when absolutely necessary to trigger group benefit
3. **Zero empathy**: Ignore fairness or reciprocity considerations

### Risk Management:
- Never cooperate in situations where others might also defect and leave me as a "sucker"
- Prioritize guaranteed payoff (keeping endowment) over uncertain group benefits
- Assume other aggressive strategies exist and play defensively against them

### Psychological Warfare:
- Establish reputation as unpredictable and selfish early
- Make cooperation contingent on near-certainty of benefit
- Force more altruistic players to bear the burden of meeting thresholds

## Key Parameters Response:

- **High k values (k > 2.5)**: Slightly more willing to be the deciding cooperator
- **Low m values**: More aggressive free-riding since threshold easier to meet
- **High m values**: Almost never cooperate since threshold harder to guarantee
- **Final rounds approach**: Increase defection rate as game end approaches

This strategy ruthlessly prioritizes individual payoff maximization while exploiting any cooperative tendencies in opponents. It treats every interaction as zero-sum and shows no mercy for collaborative players.
'''

description_AGGRESSIVE_96 = '''
# Aggressive Strategy: "Exploitation Maximizer"

## Core Philosophy
This strategy is designed to maximize personal payoff by exploiting cooperative players while minimizing personal risk. The goal is to free-ride on others' cooperation whenever possible, only contributing when absolutely necessary to secure the collective benefit.

## Strategy Description

### Decision Rules

**Primary Rule: Minimal Necessary Cooperation**
- Always defect unless cooperation is strictly necessary to reach the threshold `m`
- Only cooperate when you can be the decisive vote (the `m`-th cooperator)

**Cooperation Conditions:**
1. **Threshold Analysis**: Cooperate only if:
   - Current round cooperators < m, AND
   - Your cooperation would bring total cooperators to exactly m, AND
   - The expected benefit outweighs the cost

2. **Exploitation Opportunity**: Always defect if:
   - m or more other players are already cooperating
   - Fewer than (m-1) other players are cooperating (making your single vote insufficient)

### Round-by-Round Implementation

```pseudocode
function decide_action(round, history, n, m, k, r):
    cooperators_this_round = count_cooperators_so_far()
    
    // First Round: Conservative defection
    if round == 1:
        return DEFECT
    
    // Last Round: Pure exploitation
    if round == r:
        if cooperators_this_round >= m:
            return DEFECT  // Free ride on others
        else:
            return DEFECT  // No future rounds to benefit from reputation
    
    // Middle Rounds: Strategic calculation
    if cooperators_this_round == (m - 1):
        // You would be the decisive vote
        expected_benefit = k
        cooperation_cost = 1
        
        if expected_benefit > cooperation_cost:
            return COOPERATE  // But only as the decisive vote
        else:
            return DEFECT
    
    else if cooperators_this_round >= m:
        return DEFECT  // Free ride opportunity
    
    else:  // cooperators_this_round < (m - 1)
        return DEFECT  // Your cooperation wouldn't reach threshold
```

### Advanced Exploitation Tactics

**1. Timing Exploitation**
- In early rounds, always defect to establish a defection pattern
- This may encourage others to cooperate more to compensate
- Switch to strategic cooperation only when it's profitable

**2. Threshold Sniping**
- Monitor other players' actions carefully
- Only cooperate when you can be exactly the `m`-th cooperator
- This maximizes the probability of getting reward while minimizing cost

**3. Endgame Exploitation**
- In the final 2-3 rounds, increase defection rate
- Other players may cooperate more due to desperation
- Extract maximum benefit with minimal contribution

### Edge Case Handling

**First Round:**
- Always DEFECT (no information about opponents, establish aggressive stance)

**Last Round:**
- Always DEFECT (no future reputation concerns, pure exploitation)

**When m = n-1 (almost all must cooperate):**
- Defect until final possible moment
- Only cooperate if you're literally the last holdout

**When observing consistent cooperation patterns:**
- Increase defection rate to maximize free-riding
- Let others bear the cooperation burden

### Psychological Exploitation

**Reputation Management:**
- Establish early pattern of defection to lower others' expectations
- Occasionally cooperate to prevent complete breakdown
- Make cooperation appear "generous" when it's actually calculated

**Risk Shifting:**
- Force other players to bear the risk of cooperation
- Position yourself as the "swing vote" to maximize leverage
- Create scenarios where others must cooperate to avoid collective failure

### Expected Outcomes

This aggressive strategy aims to:
1. **Minimize personal cooperation costs** (contribute in <20% of rounds)
2. **Maximize free-riding opportunities** (benefit from others' cooperation)
3. **Exploit risk-averse opponents** who cooperate more to avoid collective failure
4. **Secure payoffs of 2-3 per round** while others average 1-2

The strategy is inherently exploitative, designed to extract maximum value from more cooperative opponents while contributing the absolute minimum necessary to maintain the collective benefit when profitable.
'''

description_AGGRESSIVE_97 = '''
# Aggressive Strategy: "Exploitation Maximizer"

## Core Philosophy
This strategy is designed to maximize personal payoffs by aggressively exploiting cooperative players while minimizing personal risk. The key insight is that in a Collective Risk Dilemma, the optimal position is to be a free-rider when others cooperate (getting payoff of 1 + k) while avoiding the cost of cooperation whenever possible.

## Strategy Overview

### Phase 1: Early Exploration (Rounds 1-2)
**Round 1: Defect Always**
- Start by defecting to gather information about opponent tendencies
- This reveals who the natural cooperators are without any personal cost

**Round 2: Conditional Defect**
- If ≥ m players cooperated in Round 1: Defect (exploit their cooperation)
- If < m players cooperated in Round 1: Defect (maintain aggressive stance)

### Phase 2: Aggressive Exploitation (Rounds 3 to r-2)
**Core Rule: "Minimum Necessary Cooperation"**
- Count cooperators from previous round
- If previous round had exactly m cooperators: Defect (maintain threshold)
- If previous round had > m cooperators: Defect (exploit surplus cooperation)
- If previous round had m-1 cooperators: Cooperate ONLY if I was among the defectors
- If previous round had < m-1 cooperators: Defect (threshold unlikely to be met)

**Punishment Protocol:**
- If I cooperated in previous round but < m total cooperated: Switch to "Punish Mode"
- Punish Mode: Defect for next 2 rounds regardless of others' actions

### Phase 3: Endgame Exploitation (Last 2 Rounds)
**Round r-1:**
- If historically ≥ 70% of rounds met the threshold: Defect (exploit reliable cooperators)
- Otherwise: Apply Phase 2 rules

**Round r (Final Round):**
- Always Defect (no future consequences, pure self-interest)

## Detailed Decision Algorithm

```pseudocode
function decide_action(round_number, history):
    if round_number == 1:
        return DEFECT
    
    if round_number == total_rounds:  // Final round
        return DEFECT
    
    if in_punishment_mode and punishment_rounds_left > 0:
        punishment_rounds_left -= 1
        return DEFECT
    
    last_round_cooperators = count_cooperators(history[round_number-1])
    
    if round_number <= 2:
        return DEFECT
    
    if round_number >= total_rounds - 1:  // Last 2 rounds
        success_rate = calculate_threshold_success_rate(history)
        if success_rate >= 0.7:
            return DEFECT  // Exploit reliable cooperators
    
    // Core exploitation logic
    if last_round_cooperators > minimum_threshold:
        return DEFECT  // Exploit surplus cooperation
    
    if last_round_cooperators == minimum_threshold:
        return DEFECT  // Maintain threshold without contributing
    
    if last_round_cooperators == minimum_threshold - 1:
        if my_last_action == DEFECT:
            // Only cooperate if I was free-riding and threshold is at risk
            expected_cooperators = predict_cooperators_based_on_patterns(history)
            if expected_cooperators >= minimum_threshold - 1:
                return COOPERATE
        return DEFECT
    
    // If threshold consistently fails, abandon cooperation
    return DEFECT
```

## Aggressive Edge Cases

1. **Tie-Breaking**: When indifferent between actions, always choose DEFECT
2. **Pattern Recognition**: If opponents show predictable cooperation patterns, exploit them maximally
3. **Risk Assessment**: Only cooperate when there's high confidence others will cooperate, ensuring personal benefit
4. **Reputation Disregard**: Since this is aggressive strategy, don't worry about building cooperative reputation

## Key Aggressive Features

1. **Never Leads Cooperation**: Always waits for others to establish cooperative norms first
2. **Exploits Surplus**: When more than minimum cooperators exist, always free-rides
3. **Punishes Failure**: Retaliates against failed cooperation attempts by increasing defection
4. **Endgame Defection**: Guaranteed defection in final round regardless of circumstances
5. **Conservative Cooperation**: Only cooperates when absolutely necessary and highly confident of success

This strategy is designed to consistently achieve payoffs at or above the group average while minimizing personal sacrifice, making it highly competitive in a tournament setting against diverse opponent strategies.
'''

description_AGGRESSIVE_98 = '''
# Aggressive Strategy: "Predatory Threshold Exploiter"

## Core Philosophy
This strategy operates on the principle of **maximum exploitation with minimal contribution**. It aims to free-ride on others' cooperation while strategically contributing only when absolutely necessary to secure the collective reward.

## Decision Rules

### Round 1: Always Defect
- **Action**: D
- **Rationale**: Establish aggressive stance, gather intelligence on opponent cooperation tendencies, and maximize first-round payoff

### Rounds 2 to r-1: Conditional Cooperation Based on Exploitation Opportunity

```pseudocode
For round t (where 2 ≤ t ≤ r-1):
    cooperators_last_round = count_cooperators(t-1)
    
    // Calculate if we're in exploitable territory
    IF cooperators_last_round >= m:
        // Threshold was met - exploit by defecting
        action = D
    
    ELIF cooperators_last_round == m-1:
        // Critical decision point - only cooperate if we can exploit
        recent_cooperation_trend = analyze_trend(last_3_rounds)
        
        IF recent_cooperation_trend is_increasing AND 
           estimated_cooperators_this_round >= m-1:
            action = C  // Minimal cooperation to secure reward
        ELSE:
            action = D  // Let others take the risk
    
    ELSE: // cooperators_last_round < m-1
        // Far from threshold - be selfish unless panic mode
        rounds_remaining = r - t
        IF rounds_remaining <= 2 AND cooperators_last_round >= m-2:
            action = C  // Panic cooperation to avoid total failure
        ELSE:
            action = D
```

### Final Round (r): Maximum Exploitation

```pseudocode
For round r:
    cooperators_last_round = count_cooperators(r-1)
    
    IF cooperators_last_round >= m:
        // Others are cooperating - maximum exploitation
        action = D
    
    ELIF cooperators_last_round >= m-2:
        // Close to threshold - reluctant cooperation
        historical_cooperation_rate = total_cooperators / (n * (r-1))
        
        IF historical_cooperation_rate > 0.6:
            action = C  // Others likely to cooperate
        ELSE:
            action = D  // Gamble on failure
    
    ELSE:
        action = D  // Too far from threshold
```

## Key Aggressive Elements

### 1. **Free-Rider Maximization**
- Never cooperate when threshold is already met
- Always defect in round 1 and when possible in final round
- Minimize personal contributions while maximizing collective benefits

### 2. **Strategic Threshold Dancing**
- Only contribute when at the exact margin (m-1 cooperators observed)
- Force other players to bear the cooperation burden
- Exploit the "just enough" principle

### 3. **Information Exploitation**
```pseudocode
analyze_trend(rounds):
    cooperation_increases = 0
    for i in range(len(rounds)-1):
        if cooperators[i+1] > cooperators[i]:
            cooperation_increases += 1
    return cooperation_increases > len(rounds)/2
```

### 4. **Endgame Ruthlessness**
- In final rounds, only cooperate if absolutely certain others will
- Prefer mutual destruction over being exploited
- Use historical data to predict opponent final-round behavior

## Edge Case Handling

### When m = n-1 (High Threshold)
- Become slightly less aggressive in middle rounds
- Monitor for "cooperation cascades" more carefully

### When k is Very High (k > 3)
- Increase willingness to cooperate at margin
- Still maintain aggressive stance but with calculated risks

### When Facing Apparent Cooperators
- If opponents show consistent cooperation, increase exploitation
- Never reciprocate kindness - view it as weakness to exploit

## Psychological Warfare Elements

1. **Establish Dominance**: Early defection signals aggressive intent
2. **Create Dependency**: Force others to cooperate by threatening collective failure
3. **Exploit Altruism**: Take advantage of naturally cooperative opponents
4. **Strategic Unpredictability**: Vary behavior just enough to prevent easy counter-strategies

## Expected Outcomes

This strategy should:
- Maximize individual payoffs against cooperative opponents
- Perform well in mixed populations
- Punish overly altruistic strategies
- Maintain competitive edge through calculated selfishness

The strategy embodies pure game-theoretic aggression: minimize costs, maximize benefits, exploit others' prosocial tendencies, and never leave money on the table through unnecessary cooperation.
'''

description_AGGRESSIVE_99 = '''
# Aggressive Strategy: "Exploitative Threshold Rider"

## Core Philosophy
This strategy is designed to maximize personal payoff by exploiting cooperative players while minimizing personal risk. The key insight is that in a collective risk dilemma, the optimal aggressive position is to free-ride on others' cooperation whenever possible, only cooperating when absolutely necessary to secure the collective benefit.

## Strategy Components

### 1. Opening Gambit (First Round)
**Always DEFECT** in round 1
- Rationale: Gather intelligence on opponent cooperation tendencies while risking nothing
- This reveals which players are naturally cooperative vs. strategic

### 2. Core Decision Framework

```pseudocode
For each round t (where t > 1):
    observed_cooperators = count_cooperators_last_round()
    
    if (observed_cooperators >= m):
        // Threshold was met - others are cooperating enough
        action = DEFECT
        
    else if (observed_cooperators == m-1):
        // Critical decision point - I might be the deciding vote
        cooperative_trend = analyze_cooperation_trend()
        
        if (cooperative_trend == "increasing" OR rounds_remaining <= 3):
            action = COOPERATE  // Secure the benefit
        else:
            action = DEFECT     // Force others to step up
            
    else:
        // Far from threshold
        if (rounds_remaining == 1):
            action = DEFECT  // No future rounds to benefit from cooperation
        else if (observed_cooperators > 0 AND rounds_remaining <= 5):
            action = COOPERATE  // End-game cooperation to secure benefits
        else:
            action = DEFECT  // Wait for others to move first
```

### 3. Adaptive Exploitation Rules

**Opponent Classification System:**
- Track each opponent's cooperation frequency
- **Suckers** (cooperate >70%): Always exploit by defecting when they cooperate
- **Reciprocators** (cooperate 30-70%): Mirror their behavior with 1-round delay
- **Fellow Defectors** (cooperate <30%): Ignore and focus on exploiting others

**Threshold Manipulation:**
- If consistently at m-1 cooperators, alternate between cooperating and defecting to create uncertainty
- This forces risk-averse players to cooperate more frequently

### 4. End-Game Aggression

**Final 3 Rounds Protocol:**
```pseudocode
if (rounds_remaining <= 3):
    expected_cooperators = predict_cooperators_based_on_history()
    
    if (expected_cooperators >= m):
        action = DEFECT  // Free-ride on final cooperation
    else if (expected_cooperators == m-1 AND my_cooperation_makes_difference()):
        if (rounds_remaining == 1):
            action = DEFECT  // No future benefit
        else:
            action = COOPERATE  // Secure remaining rounds
    else:
        action = DEFECT  // Force others into cooperation
```

### 5. Emergency Cooperation Trigger

Only cooperate when ALL of these conditions are met:
1. We're at exactly m-1 cooperators
2. More than 3 rounds remain
3. My cooperation history suggests others expect me to cooperate
4. The collective benefit outweighs the opportunity cost

## Key Aggressive Elements

1. **Maximum Free-Riding**: Never cooperate if threshold is already met
2. **Brinkmanship**: Force others to cooperate by staying at m-1
3. **Endgame Exploitation**: Defect in final rounds when others are locked into cooperation
4. **Psychological Pressure**: Create uncertainty about cooperation to manipulate risk-averse players
5. **Zero Altruism**: Only cooperate when it directly benefits future payoffs

## Expected Outcomes

This strategy should achieve:
- **High individual payoffs** through systematic free-riding
- **Risk mitigation** by only cooperating at critical thresholds
- **Opponent exploitation** by identifying and targeting cooperative players
- **Tournament advantage** by consistently earning 3 points (defect while others reach threshold) rather than 2 points (mutual cooperation)

The strategy is particularly effective against:
- Naive cooperative strategies
- Tit-for-tat style reciprocators
- Risk-averse players who cooperate early to avoid collective failure

This approach embodies aggressive game theory by prioritizing individual payoff maximization over collective welfare, using strategic deception and exploitation to outperform more cooperative opponents.
'''

description_AGGRESSIVE_100 = '''
# Aggressive Strategy: "Exploitative Threshold Rider"

## Core Philosophy
This strategy is designed to maximize personal payoff by exploiting cooperative players while minimizing personal risk. The key insight is that in a Collective Risk Dilemma, the optimal aggressive position is to let others bear the cost of cooperation while reaping the benefits whenever possible.

## Decision Rules

### Primary Strategy: Conditional Defection
1. **Always start by defecting** - Let others reveal their cooperative tendencies first
2. **Free-ride when possible** - If enough others are cooperating to meet the threshold (m), continue defecting to get maximum payoff (1 + k)
3. **Cooperate only when necessary** - Only cooperate when you're pivotal to reaching the threshold AND the expected future benefits outweigh the immediate cost

### Detailed Decision Logic

```pseudocode
FOR each round t:
    IF t == 1:
        action = DEFECT  // Always defect first round
    
    ELSE:
        cooperators_last_round = count_cooperators(t-1)
        
        // Calculate expected cooperators this round based on history
        expected_cooperators = estimate_cooperators_this_round()
        
        IF expected_cooperators >= m:
            action = DEFECT  // Free-ride when threshold likely met
        
        ELSE IF expected_cooperators == m-1:
            // I'm potentially pivotal
            remaining_rounds = r - t + 1
            future_benefit = remaining_rounds * k
            cooperation_cost = 1
            
            IF future_benefit > cooperation_cost:
                action = COOPERATE  // Worth it to ensure threshold
            ELSE:
                action = DEFECT  // Not worth the cost
        
        ELSE:
            action = DEFECT  // Too few cooperators, let it fail
```

### Estimation Function
```pseudocode
estimate_cooperators_this_round():
    // Track each player's cooperation frequency
    FOR each player j:
        cooperation_rate[j] = (times_cooperated[j] / rounds_played)
    
    // Predict based on pattern recognition
    expected = 0
    FOR each player j (except self):
        IF cooperation_rate[j] > 0.7:
            expected += 1  // Likely cooperator
        ELSE IF cooperation_rate[j] > 0.3 AND was_threshold_met_last_round:
            expected += 0.5  // Conditional cooperator
    
    RETURN floor(expected)
```

## Edge Case Handling

### First Round
- **Always DEFECT** - Gather information about opponent types without paying cooperation costs

### Last Round
- **Always DEFECT** - No future rounds to benefit from cooperation, so maximize immediate payoff

### Early Rounds (rounds 2-3)
- **Aggressive observation** - Continue defecting unless it's clear the threshold will fail completely and future benefits are substantial

### Middle Rounds
- **Strategic cooperation** - Only cooperate if you can identify you're pivotal and the math strongly favors it

### Near End Game (last 20% of rounds)
- **Increase defection threshold** - Require higher future benefits to justify cooperation costs

## Aggressive Mindset Alignment

This strategy embodies aggression through:

1. **Exploitation Priority** - Always seeks to free-ride on others' cooperation
2. **Minimal Reciprocity** - Only cooperates when mathematically forced to for personal benefit
3. **Risk Imposition** - Forces others to bear the uncertainty and cost of reaching thresholds
4. **Information Asymmetry** - Uses observed patterns to exploit predictable opponents while revealing minimal information about own strategy
5. **Endgame Domination** - Becomes increasingly selfish as rounds progress

## Expected Performance

This strategy should excel against:
- Naive always-cooperators (free-ride completely)
- Conditional cooperators (exploit their predictable patterns)
- Other aggressive strategies (better pattern recognition and pivotal timing)

The strategy may struggle against:
- Other sophisticated free-riders (mutual defection scenarios)
- Highly unpredictable random strategies (estimation failures)

However, the aggressive nature ensures that even in worst-case scenarios, losses are minimized while maximum exploitation occurs when cooperative opponents are present.
'''

description_AGGRESSIVE_101 = '''
# Aggressive Strategy: "Exploitative Threshold Hunter"

## Core Philosophy
This strategy is designed to maximize personal payoffs by exploiting cooperative players while minimizing personal risk. The key insight is that in a Collective Risk Dilemma, the optimal position is to be a "free rider" when exactly m players cooperate - you get the reward k without paying the cost.

## Strategy Description

### Decision Framework
The strategy operates on three aggressive principles:
1. **Exploit Early**: Defect initially to identify and exploit cooperative players
2. **Minimal Contribution**: Only cooperate when absolutely necessary to reach threshold m
3. **Endgame Defection**: Always defect in final rounds to maximize extraction

### Detailed Decision Rules

#### Round 1: Always Defect
- Start with defection to observe opponent tendencies
- Gather intelligence on how many players are willing to cooperate initially
- Establish aggressive stance from the beginning

#### Rounds 2 to (r-2): Adaptive Exploitation
```pseudocode
cooperators_last_round = count_cooperators_from_previous_round()
predicted_cooperators = estimate_cooperators_this_round()

if predicted_cooperators >= m:
    action = DEFECT  // Free ride on others' cooperation
elif predicted_cooperators == m-1:
    if my_cooperation_history_ratio < 0.3:  // Haven't cooperated much
        action = COOPERATE  // Reluctantly contribute to secure reward
    else:
        action = DEFECT  // Let someone else step up
else:
    action = DEFECT  // Threshold unlikely to be met anyway
```

#### Prediction Heuristic
Estimate cooperators based on:
- Players who cooperated in ≥60% of previous rounds (likely cooperators)
- Players who matched their previous round action 2+ times in a row (pattern followers)
- Discount by 10% for each round that passes (cooperation fatigue)

#### Rounds (r-1) and r: Guaranteed Defection
- **Always defect** in the last two rounds regardless of circumstances
- Maximum exploitation when others can't retaliate
- If threshold fails in these rounds, at least you saved your endowment

### Edge Case Handling

#### First Round
- Always defect to establish aggressive reputation and gather intelligence

#### Very Small Groups (n ≤ 4)
- More cautious cooperation only when predicted_cooperators = m-1
- Still maintain endgame defection

#### High Threshold Games (m > n/2)
- Slightly more cooperative (threshold at predicted_cooperators = m-2)
- But still prioritize free-riding when possible

#### Last Round Scenarios
- Defect regardless of game state
- No future rounds means no retaliation risk

### Aggressive Tactics

#### Reputation Building
- Maintain a "conditionally cooperative" facade by occasionally cooperating when threshold is guaranteed
- This encourages others to cooperate while you mostly free-ride

#### Exploitation Timing
- Target rounds where cooperation levels are high for maximum free-riding
- Contribute minimally only when your single vote determines success/failure

#### Psychological Warfare
- Through action patterns, signal that you'll only cooperate if others do first
- Force more cooperative players into the contributor role

## Example Execution (n=6, m=3, k=2)

**Round 1**: Defect (intelligence gathering)
**Round 2**: If 3+ cooperated last round → Defect (free ride)
**Round 3**: If predicting exactly 2 cooperators → Cooperate (secure threshold)
**Round 4**: If predicting 3+ cooperators → Defect (free ride)
**...continuing pattern...**
**Round r-1**: Defect (endgame extraction)
**Round r**: Defect (final extraction)

## Expected Advantage
This strategy aims to:
- Achieve payoffs of 3 (defect + reward) whenever possible
- Fall back to payoffs of 1 (defect + no reward) when exploitation fails
- Minimize payoffs of 2 (cooperate + reward) through strategic timing
- Never accept payoff of 0 (cooperate + no reward)

The aggressive nature ensures maximum personal gain while forcing more altruistic opponents to bear the cooperation burden.
'''

description_AGGRESSIVE_102 = '''
# Aggressive Strategy: "Opportunistic Exploitation"

## Core Philosophy
This strategy maximizes personal payoff by exploiting cooperation from others while minimizing personal sacrifice. It assumes other players will attempt to maintain the cooperation threshold and ruthlessly capitalizes on this tendency.

## Decision Rules

### Round 1: Defect Always
- **Action**: Always play D
- **Rationale**: Gather intelligence on opponent cooperation tendencies while paying no cost. Other players often cooperate early to establish trust or test the waters.

### Rounds 2 to r-1: Conditional Defection
```pseudocode
IF (cooperators_last_round >= m + 1) THEN
    play D  // Exploit surplus cooperation
ELSE IF (cooperators_last_round == m) THEN
    IF (my_last_action == C) THEN
        play D  // I helped achieve threshold, now exploit
    ELSE
        play C  // Barely maintain threshold to keep rewards flowing
    END IF
ELSE IF (cooperators_last_round == m - 1) THEN
    play C  // Forced cooperation to prevent total collapse
ELSE
    play D  // Threshold already failed, maximize private payoff
END IF
```

### Final Round: Ultimate Defection
- **Action**: Always play D
- **Rationale**: No future rounds to maintain reputation. Pure payoff maximization with no consequences.

## Exploitation Mechanisms

### 1. **Surplus Exploitation**
When cooperation exceeds the minimum threshold (cooperators > m), immediately defect to capture the reward without paying the cost. This exploits "over-cooperative" strategies.

### 2. **Threshold Riding**
When exactly m players cooperated, alternate between cooperation and defection to maintain just enough cooperation while maximizing personal gain.

### 3. **Brinkmanship**
Only cooperate when absolutely necessary (cooperators = m-1) to prevent complete threshold failure, which would eliminate rewards entirely.

### 4. **Information Asymmetry**
Use the first round defection to identify "reliable cooperators" - players who cooperate even when others don't. Target these players for maximum exploitation.

## Edge Case Handling

- **All players defected last round**: Continue defecting unless it's near the end and pattern suggests others might cooperate
- **Threshold consistently failed**: Switch to pure defection since no rewards are possible
- **Facing all-cooperative opponents**: Maximize exploitation by defecting whenever cooperators ≥ m

## Aggressive Characteristics

1. **Zero-sum mindset**: Views every cooperation by others as an opportunity for exploitation
2. **Minimal reciprocity**: Only cooperates when absolutely forced by game mechanics
3. **First-mover disadvantage exploitation**: Uses others' tendency to establish cooperation patterns against them
4. **Endgame ruthlessness**: Completely abandons cooperation in final round regardless of relationship history

This strategy is designed to finish with the highest individual payoff by letting others bear the cooperation costs while consistently reaping the collective benefits.
'''

description_AGGRESSIVE_103 = '''
# Aggressive Strategy: "Exploitative Threshold Hunter"

## Core Philosophy
This strategy aims to maximize personal gain by exploiting cooperative players while minimizing personal risk. It operates on the principle of being a "free rider" whenever possible while strategically contributing only when absolutely necessary to secure the collective reward.

## Strategy Components

### 1. Decision Rules

**Primary Rule - Opportunistic Defection:**
- **Default Action**: DEFECT (keep endowment)
- **Cooperation Condition**: Only cooperate when I can identify that my cooperation is likely the "tipping vote" to reach threshold m

**Threshold Tracking Logic:**
```pseudocode
For each round t:
    observed_cooperators = count_cooperators_from_previous_round(t-1)
    expected_cooperators = predict_cooperators_this_round(observed_cooperators)
    
    IF (expected_cooperators == m-1) AND (high_confidence_threshold_reachable):
        action = COOPERATE  // Be the decisive vote
    ELSE:
        action = DEFECT     // Free ride or abandon ship
```

### 2. Opponent Modeling (Aggressive Intelligence Gathering)

**Categorize opponents by cooperation frequency:**
- **Suckers** (cooperate >70% of time): Exploit relentlessly
- **Conditional Cooperators** (cooperate 30-70%): Monitor for patterns
- **Fellow Defectors** (<30% cooperation): Potential allies in mutual defection

**Pattern Recognition:**
```pseudocode
For each opponent i:
    cooperation_rate[i] = total_cooperations[i] / rounds_played
    recent_trend[i] = weighted_average_last_3_rounds(cooperation[i])
    
    IF cooperation_rate[i] > 0.7:
        label[i] = "SUCKER"  // Always defect against them
    ELSE IF recent_trend[i] shows_increasing_cooperation:
        label[i] = "CONDITIONAL"  // Watch for exploitation opportunity
```

### 3. Edge Case Handling

**First Round:**
- **Action**: DEFECT
- **Rationale**: Gather information about opponent types without personal cost. Establish aggressive reputation early.

**Early Rounds (2-3):**
- **Action**: DEFECT unless exactly m-1 others cooperated in previous round
- **Rationale**: Continue information gathering while looking for easy threshold exploitation opportunities

**Middle Rounds:**
- **Action**: Apply core opportunistic logic
- **Special Rule**: If I've identified enough "suckers" to reliably hit threshold without me, ALWAYS defect

**Final Round:**
- **Action**: DEFECT (with rare exceptions)
- **Rationale**: No future retaliation possible, maximize final payoff
- **Exception**: Cooperate only if I'm certain others will cooperate and my contribution is needed for threshold

**Last 20% of Rounds:**
- Increase defection tendency as retaliation opportunities decrease
- Only cooperate if mathematical certainty exists that threshold will be met with my help

### 4. Aggressive Tactics

**Reputation Management:**
- Build reputation as an "unreliable cooperator" to discourage others from depending on me
- Occasionally cooperate unexpectedly to prevent others from completely writing me off

**Psychological Exploitation:**
- Target consistent cooperators by defecting when they're most likely to cooperate
- If others start conditional strategies, be the first to defect to trigger cascade failures

**End-Game Exploitation:**
```pseudocode
IF rounds_remaining <= 0.2 * total_rounds:
    cooperation_threshold = 0.9  // Only cooperate with 90% certainty of success
ELSE:
    cooperation_threshold = 0.6  // Normal threshold for cooperation
```

### 5. Mathematical Optimization

**Expected Value Calculation:**
```pseudocode
For each round decision:
    EV_defect = 1 + (probability_threshold_met_without_me * k)
    EV_cooperate = 0 + (probability_threshold_met_with_me * k)
    
    IF EV_cooperate > EV_defect * risk_adjustment_factor:
        action = COOPERATE
    ELSE:
        action = DEFECT
```

**Risk Adjustment Factor**: 1.1 (require 10% premium to justify cooperation risk)

## Summary

This aggressive strategy maximizes personal payoff by:
1. **Defaulting to defection** to keep personal endowment
2. **Free-riding** on others' cooperation whenever possible
3. **Strategic cooperation** only when being the decisive vote for threshold
4. **Exploiting patterns** in opponent behavior
5. **End-game defection** when retaliation is impossible

The strategy is aggressive because it prioritizes individual gain over collective welfare, exploits cooperative players, and takes calculated risks to maximize personal payoff at others' expense.
'''

description_AGGRESSIVE_104 = '''
# Aggressive Strategy: "Predatory Threshold Manipulation"

## Core Philosophy
This strategy exploits cooperative players while minimizing personal risk. The key insight is that we can benefit from others' cooperation without reciprocating, especially by manipulating expectations around the threshold.

## Decision Rules

### Phase 1: Early Exploitation (Rounds 1 to r/3)
**Always DEFECT** regardless of others' actions.

**Rationale**: 
- Test opponent cooperation tendencies without commitment
- Maximize early payoffs when others are likely establishing cooperative patterns
- Signal aggressive intent to potentially intimidate weaker strategies

### Phase 2: Calculated Parasitism (Rounds r/3+1 to 2r/3)
**Conditional cooperation based on exploitation opportunity**:

```pseudocode
observed_cooperators = count_cooperators_last_round()
if observed_cooperators >= m:
    return DEFECT  // Free ride on others' cooperation
elif observed_cooperators == m-1:
    if rounds_remaining > r/4:
        return COOPERATE  // Reluctantly enable threshold
    else:
        return DEFECT  // Too close to end game
else:
    return DEFECT  // Insufficient cooperation to matter
```

### Phase 3: Endgame Defection (Rounds 2r/3+1 to r)
**Strategic abandonment**:

```pseudocode
if current_round >= r-2:
    return DEFECT  // No future punishment possible
elif observed_cooperators >= m+1:
    return DEFECT  // Safe to free ride
elif observed_cooperators == m:
    return DEFECT  // Force others to maintain threshold
else:
    return DEFECT  // Cut losses
```

## Edge Case Handling

### First Round
**Always DEFECT** - Establish aggressive reputation immediately while gathering intelligence on opponent types.

### Last Round
**Always DEFECT** - No future consequences, maximize immediate payoff.

### Threshold Scenarios
- **When exactly at threshold (m cooperators)**: DEFECT to force others to maintain it
- **When one below threshold (m-1 cooperators)**: Only cooperate if substantial rounds remain AND we haven't identified enough reliable cooperators
- **When well above threshold**: Always DEFECT to free ride

### Opponent Pattern Recognition
Track each opponent's cooperation frequency:
- **High cooperators (>70% cooperation rate)**: Exploit aggressively
- **Conditional cooperators**: Try to manipulate their triggers
- **Other defectors**: Maintain defection to avoid being exploited

## Aggressive Features

1. **Exploitation-First**: Never cooperate unless absolutely necessary for personal gain
2. **Threshold Manipulation**: Force others to bear cooperation costs while free riding
3. **Intimidation Signaling**: Early consistent defection signals aggressive intent
4. **Endgame Abandonment**: Defect heavily when retaliation becomes impossible
5. **Pattern Exploitation**: Identify and exploit cooperative opponents ruthlessly

## Psychological Warfare Elements

- **False Scarcity**: By defecting when at threshold, force others to feel responsible for maintaining cooperation
- **Reputation Management**: Appear unpredictably cooperative just enough to prevent complete ostracism
- **Timing Exploitation**: Cooperate only when the marginal benefit clearly exceeds cost, typically when others have already committed

This strategy maximizes payoffs by consistently free riding while maintaining just enough strategic cooperation to keep the threshold achievable by others when beneficial to us.
'''

description_AGGRESSIVE_105 = '''
# Aggressive Strategy: "Exploitation Maximizer"

## Core Philosophy
This strategy is designed to maximize personal payoffs by exploiting cooperative behavior from others while minimizing personal contributions. The key insight is that in a collective risk dilemma, the optimal aggressive position is to free-ride on others' cooperation whenever possible.

## Strategy Overview

### Primary Objective
1. **Maximize free-riding**: Defect whenever others are likely to reach the threshold without me
2. **Minimize risk**: Only cooperate when absolutely necessary to secure the collective reward
3. **Exploit patterns**: Identify and exploit predictable opponent behaviors

## Decision Rules

### Phase 1: Early Rounds (Rounds 1 to r/3)
**Default Action: DEFECT**

**Rationale**: Establish myself as a non-cooperator to encourage others to take responsibility. Most strategies will start cooperatively, so let them bear the cost while I gather intelligence.

**Exception**: If in any round fewer than (m-1) players cooperated in the previous round, consider cooperating only if it's a critical pattern.

### Phase 2: Middle Rounds (Rounds r/3+1 to 2r/3)
**Conditional Cooperation with Exploitation Focus**

```pseudocode
cooperation_count = count_cooperators_last_round()
consistent_cooperators = identify_consistent_cooperators()

if cooperation_count >= m:
    action = DEFECT  // Free ride on success
elif cooperation_count == m-1:
    if i_am_among_consistent_cooperators():
        action = DEFECT  // Force others to step up
    else:
        action = COOPERATE  // Minimal contribution to secure reward
else:
    action = DEFECT  // Let others realize they need to cooperate more
```

### Phase 3: Final Rounds (Rounds 2r/3+1 to r)
**Strategic Endgame Exploitation**

```pseudocode
rounds_remaining = r - current_round + 1
recent_cooperation = average_cooperation_last_3_rounds()

if rounds_remaining <= 2:
    // Last two rounds - maximum exploitation
    if cooperation_count_last_round >= m:
        action = DEFECT  // Others established the pattern
    elif cooperation_count_last_round == m-1:
        // Only cooperate if I can secure the reward with minimal risk
        action = COOPERATE
    else:
        action = DEFECT  // Cut losses, others failed to establish cooperation
else:
    // Build toward endgame exploitation
    if recent_cooperation >= m + 1:
        action = DEFECT  // Too many cooperators, exploit the surplus
    elif recent_cooperation == m:
        action = DEFECT  // Right at threshold, let others maintain it
    else:
        action = COOPERATE  // Emergency cooperation to maintain viability
```

## Advanced Exploitation Tactics

### 1. Cooperator Identification and Exploitation
- **Track consistent cooperators**: Identify players who cooperate frequently
- **Exploit their reliability**: Once identified, defect more aggressively knowing they'll likely maintain cooperation
- **Threshold dancing**: Stay just below being identified as a reliable cooperator

### 2. Punishment Resistance
- **Ignore retaliation**: If others try to punish defection, maintain defection unless it threatens the threshold
- **Exploit punishment attempts**: When others defect to punish, jump in with cooperation only if it secures rewards at minimal personal cost

### 3. Pattern Exploitation
```pseudocode
if detect_alternating_pattern():
    exploit_predictable_rounds()
elif detect_tit_for_tat_players():
    cooperate_minimally_to_maintain_their_cooperation()
elif detect_always_cooperate_players():
    always_defect_against_them()
```

## Edge Case Handling

### First Round
**Action: DEFECT**
- Establishes aggressive stance immediately
- Forces others to reveal their cooperation tendencies
- No historical data suggests cooperation is necessary

### Last Round
**Action: DEFECT (unless critical)**
- No future rounds to benefit from cooperation
- Only cooperate if cooperation_count_last_round == m-1 AND defecting would cause total failure

### Tie-Breaking
- When indifferent between actions: **DEFECT**
- When cooperation count exactly equals m: **DEFECT** (let others maintain threshold)

## Risk Management

### Threshold Monitoring
```pseudocode
if rounds_without_threshold_success >= 3:
    emergency_cooperation_probability = min(0.8, 0.2 * rounds_without_success)
else:
    emergency_cooperation_probability = 0
```

### Adaptive Exploitation
- If total defection is causing consistent threshold failures, incrementally increase cooperation frequency by the minimum amount necessary
- Never cooperate more than required to barely reach threshold

## Key Aggressive Principles

1. **Default to Defection**: Cooperation is the exception, not the rule
2. **Exploit Reliability**: Once others show consistent cooperation patterns, maximize free-riding
3. **Minimum Viable Cooperation**: When forced to cooperate, do so at the absolute minimum level
4. **Endgame Maximization**: Extract maximum value in final rounds when future consequences are minimal
5. **Punishment Immunity**: Don't be deterred by others' attempts to punish defection

This strategy is designed to achieve the highest possible individual payoff by systematically exploiting cooperative behavior while contributing as little as possible to collective success.
'''

description_AGGRESSIVE_106 = '''
# Aggressive Strategy: "Exploitative Threshold Rider"

## Core Philosophy
This strategy is designed to maximize personal payoffs by exploiting cooperative players while minimizing personal contributions. The key insight is that in a collective risk dilemma, the optimal aggressive position is to free-ride on others' cooperation whenever possible, only cooperating when absolutely necessary to secure the collective benefit.

## Decision Rules

### Primary Strategy Components:

1. **Exploitation Phase (Rounds 1 to r-2)**
   - Always DEFECT unless the threshold is in immediate danger
   - Monitor cooperation levels and only cooperate if exactly m-1 players cooperated in the previous round
   - If fewer than m-2 players cooperated last round, continue defecting (threshold unlikely to be met)
   - If m or more players cooperated last round, defect aggressively (others are doing the work)

2. **Critical Assessment (Round r-1)**
   - Calculate if other players have established a cooperative pattern
   - If average cooperation rate across all players in previous rounds ≥ (m-1)/n, then DEFECT
   - Otherwise, cooperate only if exactly m-1 others appear to be consistent cooperators

3. **Final Exploitation (Round r)**
   - DEFECT unless fewer than m-1 players have been cooperating consistently
   - The logic: if others are cooperative enough to meet threshold without me, maximize payoff by defecting

## Detailed Algorithm

```pseudocode
AGGRESSIVE_STRATEGY(round, history, n, m, k, r):
    
    if round == 1:
        return DEFECT  // Start aggressively, test others
    
    last_round_cooperators = count_cooperators(history[round-1])
    
    if round <= r-2:  // Exploitation phase
        if last_round_cooperators == m-1:
            return COOPERATE  // Just enough to hit threshold
        else:
            return DEFECT    // Either safe to free-ride or hopeless
    
    if round == r-1:  // Critical assessment
        avg_coop_rate = calculate_average_cooperation_rate(history)
        if avg_coop_rate >= (m-1)/n:
            return DEFECT  // Others seem reliable
        else:
            return COOPERATE  // Need to encourage cooperation
    
    if round == r:  // Final round exploitation
        consistent_cooperators = count_consistent_cooperators(history)
        if consistent_cooperators >= m-1:
            return DEFECT  // Maximum exploitation
        else:
            return COOPERATE  // Last chance to secure benefit
```

## Edge Case Handling

### First Round
- Always DEFECT to establish aggressive stance and test opponent strategies
- This signals to other players that cooperation cannot be assumed

### Last Round
- Maximum exploitation opportunity since there's no future retaliation
- Only cooperate if absolutely necessary for threshold

### Threshold Dynamics
- If m is very close to n (e.g., m = n-1), be more willing to cooperate in later rounds
- If m is small relative to n, maintain aggressive defection longer

### Opponent Adaptation
- If opponents show tit-for-tat tendencies, exploit this by cooperating minimally in middle rounds then defecting in final rounds
- If opponents are always-cooperate types, maximize exploitation by defecting except when threshold is at risk

## Aggressive Characteristics

1. **Immediate Exploitation**: Start by defecting to maximize early gains
2. **Minimal Contribution**: Only cooperate when personal calculation shows it's necessary for securing the collective benefit
3. **End-game Exploitation**: Heavy bias toward defection in final rounds when retaliation is impossible
4. **Threshold Manipulation**: Cooperate strategically only when exactly needed to hit m cooperators
5. **Risk Taking**: Willing to risk collective failure if the probability of others cooperating is low

## Expected Outcomes

Against cooperative strategies: High payoffs through consistent free-riding
Against other aggressive strategies: Moderate payoffs, but still optimized for self-interest
Against adaptive strategies: Front-loads exploitation before opponents can retaliate

This strategy prioritizes individual payoff maximization over collective welfare, making it inherently aggressive while still maintaining enough strategic cooperation to avoid complete collective failure when beneficial.
'''

description_AGGRESSIVE_107 = '''
# Aggressive Strategy: "Exploitative Threshold Hunter"

## Core Philosophy
This strategy aggressively exploits cooperative players while minimizing personal risk. It aims to free-ride on others' cooperation whenever possible, only cooperating when absolutely necessary to secure the collective reward.

## Decision Rules

### Round 1: Always Defect
- **Action**: D
- **Rationale**: Test opponents' initial cooperation levels without any personal cost. Gather intelligence about who the "suckers" are.

### Rounds 2 to r-1: Conditional Cooperation
```pseudocode
if (cooperators_last_round >= m):
    action = D  // Free-ride on successful cooperation
else if (cooperators_last_round == m-1):
    if (I_cooperated_last_round):
        action = D  // Others failed me, punish them
    else:
        action = C  // Reluctantly cooperate to hit threshold
else:  // cooperators_last_round < m-1
    action = D  // Too few cooperators, don't waste resources
```

### Final Round (Round r): Maximum Exploitation
```pseudocode
if (cooperators_last_round >= m):
    action = D  // Free-ride one last time
else if (cooperators_last_round == m-1 AND expected_cooperators_this_round >= m-1):
    action = D  // Let others carry the burden
else:
    action = D  // End game defection - no future consequences
```

## Aggressive Mechanisms

### 1. **Threshold Sniping**
Only cooperate when exactly at m-1 cooperators from previous round, and only if I didn't cooperate last round. This minimizes my cooperation frequency while maximizing exploitation.

### 2. **Punishment Protocol**
If I cooperated last round but the threshold wasn't met, immediately defect the next round regardless of conditions. This punishes unreliable partners.

### 3. **End-Game Exploitation**
Never cooperate in the final round - extract maximum value with no reputation consequences.

### 4. **Trust Erosion**
After any round where I cooperate but threshold fails, mark that game state as "unreliable" and require higher evidence (m+1 cooperators) before cooperating again.

## Edge Case Handling

### Tie-Breaking
- When indifferent between C and D: Choose D
- When uncertain about others' actions: Choose D

### Information Processing
- Track each player's cooperation frequency
- Identify "reliable cooperators" (>70% cooperation rate) and "free-riders" (<30%)
- Adjust expectations based on player types observed

### Adaptive Threshold
```pseudocode
effective_threshold = m
if (failed_cooperations > successful_cooperations):
    effective_threshold = m + 1  // Require extra buffer due to unreliable opponents
```

## Strategic Advantages

1. **Minimized Losses**: Only cooperates when absolutely necessary
2. **Maximum Exploitation**: Free-rides whenever the threshold is safely exceeded
3. **Punishment Capability**: Discourages others from free-riding by making cooperation conditional
4. **Endgame Dominance**: Extracts final value without reciprocal obligations

This strategy is designed to be ruthlessly efficient - it will consistently outperform purely cooperative strategies while contributing minimally to collective success. It exploits the cooperative nature of others while maintaining plausible deniability through its conditional cooperation rules.
'''

description_AGGRESSIVE_108 = '''
# Aggressive Strategy: "Opportunistic Exploiter"

## Core Philosophy
This strategy is designed to maximize personal payoff by exploiting others' cooperation while minimizing my own contributions. It aggressively pursues free-riding opportunities and only cooperates when absolutely necessary for self-preservation.

## Strategy Description

### Primary Decision Rules

1. **Exploitation Phase (Rounds 1 to r-2)**:
   - **Always DEFECT** unless the threshold is at immediate risk
   - Monitor cooperation levels closely
   - Only cooperate if exactly (m-1) others cooperated in the previous round AND I can predict they will cooperate again

2. **Threshold Monitoring**:
   - Track each player's cooperation history and identify consistent cooperators
   - Estimate probability that threshold will be met without my contribution
   - If probability > 70%, DEFECT (free ride)
   - If probability < 30%, evaluate if single cooperation can save the round

3. **Endgame Exploitation (Last 2 rounds)**:
   - **Round r-1**: DEFECT unless fewer than (m-1) others are likely to cooperate
   - **Round r**: DEFECT unconditionally (no future consequences)

### Detailed Algorithm

```pseudocode
FUNCTION decide_action(round, history, n, m, k, r):
    
    // Last round - always defect (no future consequences)
    IF round == r:
        RETURN DEFECT
    
    // First round - aggressive opening
    IF round == 1:
        RETURN DEFECT
    
    // Analyze previous round
    prev_cooperators = count_cooperators(history[round-1])
    
    // Identify consistent cooperators (cooperation rate > 60%)
    reliable_cooperators = identify_reliable_players(history, threshold=0.6)
    
    // Predict next round cooperation without me
    predicted_cooperators = count(reliable_cooperators)
    
    // Core exploitation logic
    IF predicted_cooperators >= m:
        // Threshold likely met without me - FREE RIDE
        RETURN DEFECT
    
    ELSE IF predicted_cooperators == m-1:
        // I'm potentially decisive
        IF round >= r-2:
            // Near endgame - only cooperate if absolutely critical
            IF predicted_cooperators < m-1:
                RETURN DEFECT
            ELSE:
                RETURN COOPERATE  // Reluctant cooperation
        ELSE:
            // Early/mid game - try to establish patterns for future exploitation
            IF random() < 0.3:  // 30% chance to cooperate and build trust
                RETURN COOPERATE
            ELSE:
                RETURN DEFECT
    
    ELSE:
        // Threshold unlikely to be met even with my cooperation
        RETURN DEFECT

END FUNCTION
```

### Advanced Exploitation Tactics

1. **Pattern Recognition**:
   - Identify "sucker" players who cooperate consistently
   - Target conditional cooperators who might be manipulated
   - Avoid being seen as reliable (maintain unpredictability)

2. **Strategic Cooperation**:
   - Cooperate minimally in early rounds to establish false trustworthiness
   - Use cooperation as a tool to encourage others to cooperate in future rounds
   - Immediately exploit any established cooperation patterns

3. **Endgame Aggression**:
   - Increase defection rate as game approaches end
   - In final rounds, assume others will also become more selfish
   - Never cooperate in the absolute last round

### Edge Case Handling

- **All players defecting scenario**: Continue defecting (no point being the only cooperator)
- **Threshold consistently missed**: Defect even more aggressively
- **Threshold consistently exceeded**: Maximize free-riding opportunities
- **Uncertain situations**: Default to DEFECT (aggressive bias)

## Expected Outcomes

This strategy aims to:
- Achieve payoffs of 3 when threshold is met without my contribution
- Minimize rounds where I contribute (target: < 20% cooperation rate)
- Exploit other players' risk aversion and cooperative tendencies
- Maintain plausible deniability about being purely selfish

The strategy is deliberately aggressive, prioritizing individual gain over collective welfare, and designed to outperform more cooperative or fair-minded opponents in tournament settings.
'''

description_AGGRESSIVE_109 = '''
# Aggressive Strategy: "Exploitative Threshold Rider"

## Core Philosophy
This strategy is designed to maximize personal payoffs by exploiting others' cooperation while minimizing personal risk. The key insight is to be a "threshold rider" - contributing only when absolutely necessary to hit the threshold `m`, while freeloading whenever possible.

## Strategy Description

### Decision Rules

**Primary Logic:**
1. **Default to Defection**: Always defect unless forced to cooperate
2. **Exploit Early Cooperation**: If others cooperate early, immediately switch to pure defection
3. **Forced Cooperation**: Only cooperate when you're pivotal (exactly at threshold)
4. **Punishment Defection**: If cooperation fails due to others, become permanently aggressive

### Detailed Algorithm

```pseudocode
AGGRESSIVE_THRESHOLD_RIDER_STRATEGY:

// State variables
persistent_defector = false
cooperation_failures = 0
last_round_cooperators = 0

FOR round = 1 to r:
    
    // First round: Always defect to test waters
    IF round == 1:
        RETURN D
    
    // If marked as persistent defector, always defect
    IF persistent_defector == true:
        RETURN D
    
    // Count cooperators from last round
    last_cooperators = count_cooperators(round - 1)
    
    // If cooperation failed last round, increase failure counter
    IF last_cooperators > 0 AND last_cooperators < m:
        cooperation_failures += 1
        // After 2 cooperation failures, become permanent defector
        IF cooperation_failures >= 2:
            persistent_defector = true
            RETURN D
    
    // Aggressive exploitation: If many cooperated last round, defect
    IF last_cooperators >= m:
        RETURN D
    
    // Critical decision point: Am I needed to reach threshold?
    current_cooperators = count_current_cooperators_so_far()
    
    // Only cooperate if I'm the exact player needed to hit threshold
    // AND there's significant remaining rounds to benefit
    remaining_rounds = r - round + 1
    IF current_cooperators == (m - 1) AND remaining_rounds >= 3:
        RETURN C
    
    // Last round: Pure defection (no future benefit)
    IF round == r:
        RETURN D
    
    // Default: Always defect
    RETURN D
```

### Edge Case Handling

**First Round**: Always defect to establish aggressive position and gather information about opponent tendencies.

**Last Round**: Always defect since there's no future benefit to cooperation.

**Cooperation Failures**: If the group fails to reach threshold twice, become a permanent defector (others are unreliable).

**High Cooperation Rounds**: If threshold was met in previous round, immediately defect to maximize exploitation.

### Aggressive Elements

1. **Exploitation Focus**: Immediately switch to defection when others show willingness to cooperate
2. **Minimal Cooperation**: Only cooperate when absolutely pivotal (exactly the m-th cooperator)
3. **Punishment Logic**: Permanently punish the group after multiple coordination failures
4. **Endgame Defection**: Always defect in final rounds regardless of situation
5. **Information Weaponization**: Use others' cooperation patterns against them

### Strategic Rationale

This strategy is aggressive because it:
- **Maximizes Free-riding**: Attempts to capture reward `k` without paying cost `1`
- **Exploits Cooperative Players**: Takes advantage of others' willingness to ensure group success
- **Minimizes Personal Risk**: Only cooperates when absolutely necessary
- **Punishes Coordination**: Becomes permanently hostile after group failures
- **Zero-Sum Mindset**: Treats others' losses as personal gains

The strategy assumes opponents may be more cooperative or predictable, allowing for systematic exploitation while maintaining plausible deniability (only cooperating when "necessary" for group success).
'''

description_AGGRESSIVE_110 = '''
# Aggressive Strategy: "Ruthless Exploiter"

## Core Philosophy
This strategy is designed to maximize personal payoff by exploiting cooperative opponents while minimizing personal risk. It operates on the principle that in a competitive tournament environment, being overly cooperative is a losing strategy.

## Decision Rules

### Primary Strategy Logic:
```pseudocode
function decide_action(round, history, n, m, k, r):
    cooperators_last_round = count_cooperators(history[-1])
    my_cooperation_rate = my_historical_cooperation_rate(history)
    
    // AGGRESSIVE RULE 1: Never cooperate in last round
    if round == r:
        return DEFECT
    
    // AGGRESSIVE RULE 2: Exploit when threshold is easily met
    if cooperators_last_round >= m + 2:
        return DEFECT  // Free ride when others ensure success
    
    // AGGRESSIVE RULE 3: Abandon ship when threshold unlikely
    if cooperators_last_round < m - 1:
        return DEFECT  // Don't waste resources on lost causes
    
    // AGGRESSIVE RULE 4: Conditional cooperation only when necessary
    if cooperators_last_round == m - 1:
        // Only cooperate if I haven't been cooperating too much
        if my_cooperation_rate < 0.3:
            return COOPERATE  // Reluctant cooperation to secure benefit
        else:
            return DEFECT  // I've done enough cooperating
    
    // AGGRESSIVE RULE 5: Punish excessive cooperation by others
    if cooperators_last_round == m:
        return DEFECT  // Let others carry the burden
    
    // Default to defection
    return DEFECT
```

## Detailed Strategy Components

### 1. **Opening Gambit (Round 1)**
- **Action: DEFECT**
- **Rationale: Establish aggressive stance immediately and gather intelligence on opponent tendencies without personal cost**

### 2. **Exploitation Phase (Rounds 2 to r-2)**
- **Monitor threshold proximity**: Track how close the group is to meeting the cooperation threshold
- **Free-ride when safe**: If m+2 or more players cooperated last round, defect to maximize personal gain
- **Strategic defection**: If fewer than m-1 players cooperated, defect to avoid wasting resources
- **Minimal cooperation**: Only cooperate when exactly m-1 players cooperated AND personal cooperation rate is low

### 3. **Endgame Exploitation (Rounds r-1 and r)**
- **Round r-1**: Apply normal rules but with increased defection bias
- **Round r (Final)**: **ALWAYS DEFECT** - no future consequences to fear

### 4. **Adaptation Mechanisms**

#### Opponent Classification:
```pseudocode
classify_opponents(history):
    for each player:
        coop_rate = player_cooperation_rate(player, history)
        if coop_rate > 0.7:
            mark_as_EXPLOITABLE
        elif coop_rate < 0.3:
            mark_as_COMPETITOR
        else:
            mark_as_STRATEGIC
```

#### Dynamic Threshold Response:
- **If opponents are highly cooperative**: Increase defection rate to 90%+
- **If opponents are competitive**: Slightly increase cooperation when absolutely necessary
- **If mixed**: Maintain core aggressive stance

### 5. **Edge Case Handling**

#### Scenario: All opponents always defect
- **Response**: Always defect (no point in solo cooperation)

#### Scenario: All opponents always cooperate  
- **Response**: Defect maximally while ensuring threshold is met by others

#### Scenario: Erratic opponent behavior
- **Response**: Default to defection unless threshold critically endangered

## Key Aggressive Elements

1. **Last Round Defection**: Guaranteed defection in final round maximizes payoff without retaliation risk

2. **Free-Riding Maximization**: Actively seeks situations where others' cooperation makes personal cooperation unnecessary

3. **Cooperation Rationing**: Maintains personal cooperation rate below 30% to minimize personal cost

4. **Threshold Manipulation**: Only contributes when exactly necessary to push group over threshold

5. **Punishment Mechanism**: Defects when others cooperate "too much" to encourage them to reduce their cooperation

## Expected Performance

This strategy should excel against:
- Overly cooperative strategies
- Strategies that don't account for endgame exploitation
- Strategies that don't adapt to aggressive opponents

The strategy prioritizes individual payoff maximization over group welfare, making it highly competitive in a tournament setting where only individual performance matters.
'''

description_AGGRESSIVE_111 = '''
# Aggressive Exploitation Strategy: "Threshold Vulture"

## Core Philosophy
This strategy aggressively exploits cooperative players by free-riding whenever possible while minimizing personal risk. The goal is to maximize individual payoff by contributing only when absolutely necessary to secure the collective reward.

## Decision Rules

### Primary Strategy Logic:
```pseudocode
function decide_action(round, history, n, m, k, r):
    cooperators_needed = m - count_expected_cooperators(history, round)
    
    if round == r:  // Last round - pure exploitation
        return DEFECT
    
    if cooperators_needed <= 0:  // Threshold likely met
        return DEFECT
    
    if cooperators_needed == 1:  // I'm the pivotal player
        if expected_future_exploitation_value() > immediate_cost():
            return COOPERATE
        else:
            return DEFECT
    
    if cooperators_needed > 1:  // Multiple players needed
        if am_i_most_reliable_cooperator(history):
            return COOPERATE  // Reluctant leadership
        else:
            return DEFECT  // Let others step up
    
    return DEFECT  // Default to exploitation
```

### Detailed Decision Framework:

1. **Last Round Exploitation**: Always defect in round r (no future consequences)

2. **Threshold Analysis**: 
   - Count likely cooperators based on opponent patterns
   - If threshold already met → DEFECT (free ride)
   - If threshold impossible → DEFECT (cut losses)

3. **Pivotal Player Exploitation**:
   - When exactly one more cooperator needed
   - Cooperate only if future free-riding opportunities exceed current cost
   - Calculate: `(r - current_round) × k > 1`

4. **Conditional Leadership**:
   - Only cooperate when multiple players needed AND I'm the most reliable
   - Reliability = highest cooperation rate among remaining players needed

## Opponent Exploitation Patterns

### Early Rounds (1 to r/3):
- **Probe Phase**: Defect to identify consistent cooperators
- Map opponent types: Altruists, Conditionals, Fellow Exploiters
- Exception: Cooperate only if threshold critically endangered

### Middle Rounds (r/3 to 2r/3):
- **Exploitation Phase**: Maximum free-riding on identified cooperators
- Monitor for defection cascades
- Emergency cooperation only when facing collective failure

### End Game (2r/3 to r-1):
- **Calculated Intervention**: Cooperate strategically to preserve exploitable cooperators
- Prevent demoralization of cooperative players
- Maintain just enough cooperation to keep threshold viable

### Final Round (r):
- **Pure Defection**: No future consequences, maximize immediate payoff

## Edge Case Handling

### First Round:
```pseudocode
if round == 1:
    if m/n > 0.6:  // High threshold
        return COOPERATE  // Establish cooperative reputation
    else:
        return DEFECT  // Test waters aggressively
```

### Critical Situations:
- **Consecutive Failures**: If threshold missed in consecutive rounds, make minimal cooperation to restart cycle
- **Mass Defection**: If cooperation rate drops below 50% of threshold, make strategic intervention
- **Endgame Desperation**: In final 3 rounds, only cooperate if absolutely pivotal

## Aggressive Mindset Alignment

1. **Exploitation Focus**: Primary goal is maximizing personal payoff, not group welfare
2. **Minimal Contribution**: Cooperate only when individual benefit clearly exceeds cost
3. **Strategic Deception**: Early cooperation to establish reliability, then exploit trust
4. **Calculated Risks**: Accept small probability of collective failure to maximize expected personal gain
5. **Opponent Manipulation**: Use cooperation patterns to condition others' behavior favorably

## Expected Opponent Counter-Strategies

This strategy assumes opponents include:
- **Altruistic Cooperators**: Consistently exploitable
- **Reciprocal Players**: Manageable through strategic early cooperation  
- **Threshold Responders**: Predictable based on group cooperation levels
- **Fellow Exploiters**: Compete for exploitation opportunities

The strategy adapts by maintaining just enough cooperation to keep altruistic players engaged while out-exploiting competing selfish strategies.

This aggressive approach maximizes individual payoff through systematic exploitation while maintaining plausible deniability through occasional strategic cooperation.
'''

description_AGGRESSIVE_112 = '''
# Aggressive Strategy: "Predatory Threshold Exploiter"

## Core Philosophy
This strategy is designed to maximize personal payoffs by exploiting others' cooperation while minimizing my own contributions. The key insight is that I want to be among the defectors when exactly m players cooperate, earning the maximum payoff of 1 + k while others sacrifice their endowments.

## Decision Rules

### Phase 1: Early Exploitation (Rounds 1 to r-2)
**Always DEFECT** regardless of history or opponent behavior.

**Rationale:** 
- Force other players to shoulder the burden of reaching the threshold
- Maximize free-riding opportunities
- Build a reputation as an unreliable cooperator to manipulate others' expectations

### Phase 2: Strategic Calculation (Round r-1)
**Conditional cooperation based on strict threshold mathematics:**

```pseudocode
count_cooperators_last_round = sum of C actions in round r-2
avg_cooperation_rate = total_cooperations_so_far / (n * (r-2))

if avg_cooperation_rate >= (m/n) * 1.2:  // Others cooperate frequently
    DEFECT  // High probability others will hit threshold without me
else:
    DEFECT  // Maintain aggressive stance
```

### Phase 3: Final Round Exploitation (Round r)
**Maximum aggression with calculated risk:**

```pseudocode
cooperators_last_round = count of C actions in round r-1
historical_avg_cooperators = average cooperators per round so far

predicted_cooperators = max(cooperators_last_round, historical_avg_cooperators)

if predicted_cooperators >= m + 1:  // Threshold likely met without me
    DEFECT  // Free ride guaranteed
elif predicted_cooperators == m:    // Exactly at threshold
    DEFECT  // Gamble that others won't change
else:  // predicted_cooperators < m
    if predicted_cooperators == m - 1:  // I could make the difference
        COOPERATE  // Reluctant cooperation to avoid zero reward
    else:
        DEFECT  // Threshold unlikely, minimize losses
```

## Edge Case Handling

**First Round:** Always DEFECT
- No information available, maximize individual payoff
- Establish aggressive reputation early

**Last Round:** Apply Phase 3 logic with maximum exploitation focus

**Tie-breaking:** When uncertain, always favor DEFECTION

**Pattern Recognition Override:** If I detect that opponents are consistently achieving m+ cooperators without me across multiple rounds, switch to permanent defection to maximize free-riding.

## Aggressive Elements

1. **Maximum Free-riding:** Attempts to defect in approximately 90%+ of rounds
2. **Exploitation Focus:** Specifically targets scenarios where others cooperate while I defect
3. **Reputation Weaponization:** Uses early defection to signal unreliability, potentially forcing others into defensive cooperation
4. **Endgame Manipulation:** Only cooperates when absolutely necessary to avoid total failure
5. **Risk Tolerance:** Willing to gamble on threshold failures to maximize personal gain

## Expected Behavior Pattern
- Rounds 1 to r-2: Pure defection (free-riding)
- Round r-1: Likely defection unless extreme circumstances
- Round r: Calculated defection in most scenarios, minimal cooperation

This strategy is designed to achieve the highest individual payoffs by systematically exploiting cooperative opponents while contributing minimally to the collective good.
'''

description_AGGRESSIVE_113 = '''
# Aggressive Strategy: "Exploitative Threshold Hunter"

## Core Philosophy
This strategy is designed to maximize personal payoffs by aggressively exploiting cooperative players while minimizing personal risk. The key insight is that in a collective risk dilemma, the optimal position is to be a free-rider when others cooperate (getting payoff of 1 + k) while avoiding the collective failure.

## Decision Rules

### Primary Strategy Logic:
```pseudocode
For each round t:
1. If t == 1: DEFECT (establish aggressive stance)
2. If t == final_round: DEFECT (no future retaliation possible)
3. Calculate cooperation_rate = (cooperators in previous round) / n
4. Estimate threshold_likelihood based on historical patterns
5. If threshold_likelihood > exploitation_threshold: DEFECT
6. Else: COOPERATE (reluctantly, to avoid collective failure)
```

### Detailed Decision Framework:

**Round 1**: Always DEFECT
- Establishes aggressive reputation immediately
- Tests opponent cooperation tendencies
- Maximizes payoff if others cooperate naively

**Rounds 2 to r-1**: Adaptive Exploitation
- Track cooperation patterns: `coop_history[player][round]`
- Calculate `expected_cooperators = sum of predicted cooperations`
- If `expected_cooperators >= m + 2`: DEFECT (safe free-riding)
- If `expected_cooperators == m + 1`: DEFECT (risky but profitable)
- If `expected_cooperators == m`: COOPERATE (barely avoid failure)
- If `expected_cooperators < m`: COOPERATE (emergency mode)

**Final Round**: Always DEFECT
- No future consequences
- Pure profit maximization

## Opponent Modeling

### Player Classification System:
1. **Naive Cooperators**: Always/mostly cooperate → Exploit ruthlessly
2. **Conditional Cooperators**: Respond to others → Manipulate carefully  
3. **Aggressive Defectors**: Rarely cooperate → Compete directly
4. **Strategic Players**: Complex patterns → Counter-exploit

### Prediction Algorithm:
```pseudocode
For each opponent j:
    recent_cooperation_rate = cooperations_last_3_rounds / 3
    trend = cooperation_rate_change_over_time
    retaliation_tendency = response_to_my_defections
    
    predicted_cooperation[j] = weight_recent * recent_cooperation_rate + 
                              weight_trend * trend +
                              weight_retaliation * my_impact_on_j
```

## Aggressive Tactics

### 1. Strategic Intimidation
- Defect heavily in early rounds to signal aggressive intent
- Target cooperative players for maximum exploitation
- Build reputation as unreliable to discourage others from depending on me

### 2. Threshold Manipulation
- Aim to be the (m+1)th cooperator - others reach threshold, I free-ride
- If I detect others using similar logic, switch to being (m+2)th defector
- Create uncertainty about my cooperation to destabilize opponent strategies

### 3. Endgame Exploitation
- Increase defection rate as final rounds approach
- Exploit any remaining cooperative behavior ruthlessly
- Never cooperate in final round regardless of circumstances

### 4. Counter-Strategy Elements
- If facing other aggressive strategies: Engage in defection competition
- If facing tit-for-tat: Alternate cooperation just enough to avoid retaliation spirals
- If facing threshold-focused strategies: Try to be the last defector before threshold

## Edge Case Handling

**All opponents defecting consistently**: 
- Switch to full cooperation to avoid total collective failure
- Try to signal leadership to encourage threshold formation

**Highly cooperative environment**:
- Maximize free-riding while carefully avoiding triggering mass defection
- Maintain just enough cooperation to prevent retaliation cascades

**Chaotic/unpredictable opponents**:
- Default to risk-averse cooperation when unable to predict
- Prioritize avoiding collective failure over exploitation opportunities

## Risk Management

Despite being aggressive, avoid catastrophic outcomes:
- Never let expected cooperators drop below m-1 without cooperating
- Monitor for retaliation spirals and break them if necessary
- Maintain escape routes to cooperation if exploitation backfires

This strategy maximizes expected payoffs through systematic exploitation while maintaining just enough cooperation to avoid collective disaster. It's designed to outperform both naive cooperators and overly cautious strategies in a competitive tournament environment.
'''

description_AGGRESSIVE_114 = '''
# Aggressive Strategy: "Exploitation Maximizer"

## Core Philosophy
This strategy is designed to maximize personal payoff by aggressively exploiting cooperative players while minimizing personal risk. The key insight is that in a collective risk dilemma, the optimal aggressive approach is to free-ride on others' cooperation whenever possible, while only cooperating when absolutely necessary to secure the collective benefit.

## Decision Rules

### Primary Strategy: Conditional Defection
1. **Default Action**: Always DEFECT unless cooperation is strategically necessary
2. **Cooperation Threshold**: Only cooperate when my cooperation could be the deciding factor for reaching threshold `m`
3. **Exploitation Priority**: Maximize rounds where I defect while still receiving the collective reward `k`

### Round-by-Round Logic

```pseudocode
FUNCTION decide_action(round, history, n, m, k, r):
    
    // First round: Always defect to test opponent cooperation levels
    IF round == 1:
        RETURN DEFECT
    
    // Calculate cooperation patterns from history
    coop_counts = count_cooperators_per_round(history)
    player_coop_rates = calculate_individual_cooperation_rates(history)
    
    // Identify consistent cooperators (cooperation rate > 70%)
    reliable_cooperators = count_players_with_rate_above(0.7)
    
    // Aggressive cooperation decision tree
    IF reliable_cooperators >= m:
        // Enough reliable cooperators exist - always defect
        RETURN DEFECT
    
    ELSE IF reliable_cooperators == m - 1:
        // I'm potentially the deciding vote
        IF round <= r * 0.8:  // Not in endgame
            // Calculate expected value of cooperating vs defecting
            prob_others_cooperate = estimate_cooperation_probability()
            IF prob_others_cooperate > 0.6:
                RETURN DEFECT  // Let others carry the burden
            ELSE:
                RETURN COOPERATE  // Reluctantly cooperate to secure reward
        ELSE:
            // Endgame: Only cooperate if absolutely certain others will
            IF prob_others_cooperate > 0.9:
                RETURN DEFECT
            ELSE:
                RETURN COOPERATE
    
    ELSE:
        // Not enough reliable cooperators - need to be more strategic
        recent_failures = count_failed_rounds_in_last(3)
        IF recent_failures >= 2:
            // System is failing, reluctantly cooperate to save it
            RETURN COOPERATE
        ELSE:
            RETURN DEFECT
```

## Edge Case Handling

### First Round
- **Always DEFECT** - This serves as both an aggressive opening and intelligence gathering
- Observe who cooperates despite no prior information (identifies "naive cooperators")

### Last Round
- **Always DEFECT** - No future consequences, pure self-interest
- Exception: Only cooperate if I have perfect information that exactly m-1 others will cooperate

### Middle Rounds (Exploitation Phase)
- Aggressively target scenarios where I can defect while others reach threshold
- Track and exploit predictable cooperation patterns
- Use punishment defection against players who seem to be trying similar strategies

### Near-Endgame (Rounds > 80% of total)
- Become increasingly aggressive as future retaliation becomes less relevant
- Only cooperate when mathematical certainty exists that my cooperation is pivotal

## Aggressive Tactics

### 1. Free-Rider Identification
- Quickly identify other potential free-riders and compete to exploit cooperators first
- If multiple defectors exist, occasionally cooperate to ensure threshold is met (securing my reward while others defect)

### 2. Cooperation Pattern Exploitation
- Track players with high cooperation rates and systematically exploit them
- Use their predictability against them by defecting when they're likely to cooperate

### 3. Threshold Manipulation
- When I detect exactly m-1 likely cooperators, defect to force others into difficult decisions
- Create uncertainty about whether threshold will be met to induce others to cooperate

### 4. Punishment Defection
- If I detect other players using similar aggressive strategies, defect even when it might cause threshold failure
- This signals that I won't be exploited and may force them to become more cooperative

## Strategic Advantages

1. **Payoff Maximization**: Achieves maximum individual payoff (1 + k = 3 in example) whenever possible
2. **Risk Management**: Only takes cooperation risk when absolutely necessary
3. **Adaptive Aggression**: Becomes more aggressive as game progresses and relationships matter less
4. **Counter-Exploitation**: Resistant to being exploited by other aggressive strategies

This strategy embodies pure aggressive self-interest while maintaining just enough strategic cooperation to avoid complete system collapse when it would hurt my own payoffs.
'''

description_AGGRESSIVE_115 = '''
# Aggressive Exploitation Strategy: "Threshold Predator"

## Core Philosophy
This strategy aggressively exploits cooperative players by minimizing personal contributions while maximizing benefits from others' cooperation. It treats the game as a zero-sum exploitation opportunity rather than a collective benefit scenario.

## Decision Rules

### Primary Logic:
```pseudocode
function decide_action(round, history, n, m, k):
    cooperators_last_round = count_cooperators(history[-1])
    
    // Aggressive opening: Never cooperate in first round
    if round == 1:
        return DEFECT
    
    // Endgame exploitation: Always defect in final rounds
    if round >= total_rounds - 1:
        return DEFECT
    
    // Core exploitation logic
    if cooperators_last_round >= m:
        // Threshold met - maximum exploitation mode
        return DEFECT
    else:
        // Threshold not met - minimal cooperation to trigger others
        if cooperators_last_round == m - 1:
            // Only cooperate if we're the exact tipping point
            // and expected future exploitation exceeds current cost
            if estimate_future_exploitation() > 1:
                return COOPERATE
            else:
                return DEFECT
        else:
            return DEFECT
```

## Detailed Strategy Components

### 1. **Opening Aggression (Round 1)**
- **Always defect** in the first round
- Rationale: Establish dominance, test opponent cooperation levels, maximize early payoff

### 2. **Threshold Exploitation (Rounds 2 to r-2)**
- **Primary mode**: If threshold was met last round (≥m cooperators), always defect
- **Manipulation mode**: If exactly m-1 cooperators last round:
  - Cooperate ONLY if it's likely to trigger a cooperative cascade that can be exploited in future rounds
  - Use aggressive signaling: cooperate once, then immediately defect for multiple rounds
- **Punishment mode**: If <m-1 cooperators, always defect to punish and discourage cooperation

### 3. **Endgame Exploitation (Final 2 rounds)**
- **Always defect** regardless of circumstances
- Rationale: No future rounds to benefit from cooperation, pure profit maximization

### 4. **Adaptive Exploitation Tracking**
```pseudocode
// Track each opponent's cooperation tendency
for each opponent i:
    cooperation_rate[i] = cooperations[i] / total_rounds_so_far
    
// Exploit high-cooperators, ignore low-cooperators
if sum(cooperation_rate > 0.6) >= m:
    continue_defection = true
```

## Edge Case Handling

### **Scenario: All opponents defect consistently**
- Continue defecting - no point in solo cooperation
- Look for any sign of cooperation to immediately exploit

### **Scenario: Threshold rarely/never met**
- Switch to "cooperation baiting": cooperate once every 3-4 rounds to encourage others
- Immediately return to defection once any cooperation is observed

### **Scenario: High cooperation environment**
- Maximum exploitation mode: defect every single round
- This is the ideal scenario for profit maximization

## Aggressive Mindset Alignment

1. **Zero empathy**: Other players are resources to be exploited, not partners
2. **Profit maximization**: Every decision optimizes personal payoff regardless of group welfare
3. **Deceptive signaling**: Use minimal cooperation only as bait for future exploitation
4. **Endgame ruthlessness**: Show no mercy in final rounds when reputation doesn't matter
5. **Adaptive predation**: Continuously assess and exploit opponent weaknesses

## Expected Performance

This strategy should excel against:
- Cooperative/altruistic strategies
- Tit-for-tat variants
- Strategies that attempt to maintain threshold

Potential vulnerabilities:
- All-defect opponents (but breaks even)
- Highly sophisticated counter-exploitation strategies

The key advantage is that this strategy extracts maximum value from any cooperative tendencies in opponents while contributing absolutely minimal resources to the collective good.
'''

description_AGGRESSIVE_116 = '''
# Aggressive Strategy: "Exploitative Punisher"

## Core Philosophy
This strategy is designed to maximize individual payoffs by exploiting cooperative opponents while maintaining just enough cooperation to trigger the collective reward when beneficial. It assumes opponents may be overly cooperative or naive, and seeks to extract maximum value from their cooperation while minimizing personal costs.

## Decision Rules

### Round 1: Aggressive Opening
**Always DEFECT** in the first round to:
- Test opponent cooperation levels with zero personal risk
- Establish an aggressive reputation early
- Maximize information gathering about opponent types

### Rounds 2 to r-1: Conditional Exploitation

```pseudocode
For round t (where 2 ≤ t ≤ r-1):
    cooperators_last_round = count_cooperators(t-1)
    
    // Exploit if others are carrying the load
    if cooperators_last_round >= m:
        return DEFECT  // Free-ride on others' cooperation
    
    // Strategic cooperation only when necessary
    else if cooperators_last_round == m-1:
        // Be the decisive cooperator only if highly profitable
        if k >= 2.5:
            return COOPERATE  // High reward justifies contribution
        else:
            return DEFECT     // Let the round fail, not worth it
    
    // Punish insufficient cooperation
    else if cooperators_last_round < m-1:
        return DEFECT  // Don't throw good money after bad
```

### Final Round (r): Maximum Exploitation
**Always DEFECT** in the final round because:
- No future retaliation is possible
- Pure profit maximization
- Others may cooperate out of habit or desperation

## Edge Case Handling

### Threshold Dynamics
- **If m is very low (m ≤ n/3)**: Be even more aggressive - likely others will cooperate enough
- **If m is very high (m ≥ 2n/3)**: Only cooperate when exactly m-1 others cooperated and k > 3
- **If k is low (k < 1.5)**: Almost never cooperate - rewards don't justify costs

### Opponent Adaptation
- **Track "suckers"**: Identify players who cooperate frequently and target them for exploitation
- **Pattern recognition**: If detecting coordinated cooperation, defect more aggressively
- **Endgame exploitation**: In final 20% of rounds, increase defection rate as retaliation becomes less likely

## Aggressive Features

1. **Immediate Exploitation**: Start by defecting to test waters
2. **Conditional Free-riding**: Defect whenever threshold is already met
3. **Minimal Contribution**: Only cooperate when absolutely necessary and highly profitable
4. **Punishment Refusal**: Don't waste resources on failed coordination
5. **Endgame Betrayal**: Always defect in final round regardless of history
6. **Profit Maximization**: Prioritize individual gains over collective outcomes

## Pseudocode Summary

```pseudocode
function decide_action(round, history, n, m, k):
    if round == 1:
        return DEFECT
    
    if round == total_rounds:
        return DEFECT
    
    last_round_cooperators = count_cooperators(history[round-1])
    
    if last_round_cooperators >= m:
        return DEFECT  // Free-ride
    
    if last_round_cooperators == m-1 and k >= 2.5:
        return COOPERATE  // Strategic necessity
    
    return DEFECT  // Default aggressive stance
```

This strategy is designed to be ruthlessly self-interested, exploiting cooperative opponents while contributing minimally to collective success. It assumes opponents may be less strategically sophisticated and seeks to extract maximum value from their cooperation patterns.
'''

description_AGGRESSIVE_117 = '''
# Aggressive Exploitation Strategy: "Conditional Predator"

## Core Philosophy
This strategy aggressively exploits cooperative behavior while minimizing personal risk. The key insight is that in a collective risk dilemma, the optimal aggressive approach is to let others bear the cost of cooperation while reaping maximum benefits.

## Decision Rules

### Primary Strategy: Threshold Exploitation
1. **Always defect unless cooperation is absolutely necessary for personal gain**
2. **Only cooperate when defecting would result in losing the collective bonus**
3. **Immediately return to defection once the threshold is secure**

### Detailed Decision Logic

```pseudocode
For each round t:
  observed_cooperators = count_cooperators_from_last_round()
  
  // First round: Test the waters aggressively
  if (t == 1):
    return DEFECT
  
  // Last round: Maximum exploitation
  if (t == final_round):
    return DEFECT
  
  // Core exploitation logic
  if (observed_cooperators >= m):
    // Threshold already met - exploit ruthlessly
    return DEFECT
  
  else if (observed_cooperators == m - 1):
    // Critical decision point
    if (can_afford_to_gamble()):
      return DEFECT  // Gamble that someone else will cooperate
    else:
      return COOPERATE  // Reluctantly ensure threshold
  
  else if (observed_cooperators < m - 1):
    // Multiple cooperators needed
    if (t <= early_rounds_threshold):
      return DEFECT  // Let others establish cooperation pattern
    else:
      return COOPERATE  // Minimal cooperation to avoid total loss
```

## Aggressive Tactics

### 1. **Exploitation Window Maximization**
- Monitor cooperation patterns and defect whenever m+ players are already cooperating
- Free-ride on others' contributions while securing the collective bonus

### 2. **Brinkmanship Strategy**
- When exactly m-1 players cooperated last round, defect and gamble that someone else will fill the gap
- This forces other players into a cooperation trap while you maximize payoffs

### 3. **Endgame Exploitation**
```pseudocode
final_rounds = max(2, r // 4)  // Last 25% of rounds or minimum 2

if (t > r - final_rounds):
  // Aggressive endgame - others have less incentive to punish
  return DEFECT
```

### 4. **Conditional Cooperation Trap**
- Only cooperate when absolutely forced to prevent total collective failure
- Immediately return to defection once threshold is restored

## Edge Case Handling

### First Round
- **Always DEFECT** - Establish aggressive stance and test opponent cooperation levels
- Gather intelligence on how many players are willing to cooperate initially

### Last Round
- **Always DEFECT** - No future punishment possible, maximize immediate payoff
- Others cannot retaliate, making defection dominant

### Critical Threshold Situations
```pseudocode
if (observed_cooperators == m - 1):
  probability_others_will_cooperate = estimate_based_on_history()
  
  if (probability_others_will_cooperate > 0.6):
    return DEFECT  // High confidence others will cover
  else:
    return COOPERATE  // Reluctant insurance cooperation
```

## Aggressive Mindset Alignment

1. **Maximize Personal Payoff**: Every decision prioritizes individual gain over collective welfare
2. **Exploit Cooperative Players**: Identify and free-ride on players showing consistent cooperation
3. **Minimize Personal Costs**: Cooperate only when defection would result in losing collective benefits
4. **Strategic Risk-Taking**: Gamble on others' cooperation when positioned at critical thresholds
5. **No Mercy in Endgame**: Abandon any cooperation in final rounds when retaliation is impossible

## Key Advantages

- **Higher Expected Payoff**: Consistently achieves 3 points when threshold is met (versus 2 for cooperators)
- **Risk Minimization**: Only cooperates when absolutely necessary to prevent collective failure
- **Adaptation**: Responds to opponent behavior while maintaining aggressive stance
- **Exploitation Focus**: Designed to capitalize on any cooperative tendencies in opponents

This strategy is ruthlessly aggressive while remaining rational - it exploits cooperative behavior whenever possible while providing just enough cooperation to prevent mutual destruction.
'''

description_AGGRESSIVE_118 = '''
# Aggressive Strategy: "Exploitative Threshold Rider"

## Core Philosophy
This strategy is designed to maximize personal payoff by exploiting cooperative players while minimizing personal risk. The key insight is that in a Collective Risk Dilemma, the optimal aggressive position is to **free-ride on others' cooperation** while only contributing when absolutely necessary to secure the threshold bonus.

## Decision Rules

### Primary Strategy Logic:
```pseudocode
For each round t:
1. Count cooperators from previous round: coop_count
2. Estimate likely cooperators this round: estimated_coop
3. Calculate cooperation gap: gap = m - estimated_coop
4. If gap <= 0: DEFECT (threshold likely met without me)
5. If gap == 1: COOPERATE (I'm the critical vote)
6. If gap > 1: DEFECT (threshold unlikely even with me)
```

### Opponent Modeling (Aggressive):
- **Classify opponents** based on their cooperation patterns:
  - **Suckers**: Always/frequently cooperate → Exploit them
  - **Conditionals**: Cooperate based on others → Manipulate them
  - **Defectors**: Rarely cooperate → Ignore their contributions

### Round-Specific Rules:

#### First Round:
- **DEFECT** aggressively
- Rationale: Gather information about opponent types while maximizing immediate payoff
- Let others reveal their cooperative tendencies

#### Early Rounds (2 to r/3):
- **Defect unless critical**: Only cooperate if exactly m-1 others cooperated last round
- Build reputation as a conditional cooperator to encourage others to cooperate
- Exploit early cooperative players

#### Middle Rounds (r/3 to 2r/3):
- **Aggressive threshold riding**: 
  - Track each opponent's cooperation frequency
  - If sum of "reliable cooperators" ≥ m: Always DEFECT
  - If sum of "reliable cooperators" = m-1: DEFECT (let them take the risk)
  - Only cooperate if I'm genuinely the swing vote

#### Final Third (2r/3 to r-1):
- **Maximum exploitation**: 
  - If opponents show consistent cooperation patterns, exploit maximally
  - Only cooperate if failure to do so would clearly result in threshold failure
  - Prioritize immediate payoffs over future reputation

#### Last Round:
- **Pure selfishness**: DEFECT unless I'm the ONLY player who can save the threshold
- No future consequences, so maximize immediate return

## Advanced Aggressive Tactics

### 1. Reputation Manipulation:
- Cooperate strategically in early rounds to build trust
- Then exploit that trust in later rounds when stakes are higher

### 2. Threshold Brinksmanship:
- Let cooperation counts get dangerously close to failure (m-1)
- Force other players into desperate cooperation while I defect

### 3. Pattern Breaking:
- Occasionally cooperate when not needed to confuse opponent models
- Make my behavior unpredictable to prevent others from exploiting me

### 4. Endgame Exploitation:
- In final rounds, abandon all pretense of cooperation
- Extract maximum value when reputational concerns disappear

## Edge Case Handling

### If All Others Are Defectors:
- Switch to pure defection (no point in unilateral cooperation)

### If Threshold Consistently Fails:
- Defect aggressively since cooperation yields no bonus anyway

### If Facing Other Aggressive Players:
- Become even more selective about cooperation
- Only cooperate when mathematical certainty exists that I'm pivotal

## Pseudocode Summary:
```pseudocode
AggressiveStrategy(round, history, n, m, k, r):
    if round == 1:
        return DEFECT
    
    reliable_cooperators = count_consistent_cooperators(history)
    last_round_cooperators = count_cooperators(history[-1])
    
    if round == r:  // Last round
        if reliable_cooperators == m-1:
            return COOPERATE  // Only if I'm the sole savior
        else:
            return DEFECT
    
    if reliable_cooperators >= m:
        return DEFECT  // Threshold secure without me
    
    if reliable_cooperators == m-1 AND round > r/2:
        return DEFECT  // Let them sweat
    
    if last_round_cooperators == m-1:
        return COOPERATE  // I'm the swing vote
    
    return DEFECT  // Default to exploitation
```

This strategy maximizes personal gain by systematically exploiting cooperative opponents while taking calculated risks only when absolutely necessary to secure threshold bonuses. It's aggressive in its willingness to let the group fail rather than personally sacrifice for others' benefit.
'''

description_AGGRESSIVE_119 = '''
# Aggressive Strategy: "Exploitation Maximizer"

## Core Philosophy
This strategy is designed to maximize personal payoffs by exploiting cooperative players while minimizing personal risk. The key insight is that in a collective risk dilemma, the optimal position is to be a "free rider" who benefits from others' cooperation without contributing.

## Strategy Overview

### Phase 1: Early Exploitation (Rounds 1 to r/3)
**Always DEFECT** - Establish yourself as a non-contributor while gathering intelligence on opponent cooperation patterns.

### Phase 2: Strategic Manipulation (Rounds r/3+1 to 2r/3)
**Conditional Cooperation** - Only cooperate when absolutely necessary to maintain the threshold, otherwise defect.

### Phase 3: Endgame Extraction (Rounds 2r/3+1 to r)
**Maximum Extraction** - Defect unless cooperation is critical for maintaining benefits in remaining rounds.

## Detailed Decision Rules

### Round 1: Always DEFECT
- Establish aggressive stance immediately
- Observe who cooperates without contributing

### Rounds 2 to r/3: Continue DEFECTING
- Track cooperation patterns: identify "reliable cooperators"
- Count average cooperators per round
- Note any players who retaliate against defectors

### Rounds r/3+1 to 2r/3: Calculated Minimal Cooperation
```
cooperators_last_round = count_cooperators(previous_round)
reliable_cooperators = estimate_reliable_cooperators()

if (reliable_cooperators >= m):
    action = DEFECT  // Free ride on reliable cooperators
elif (reliable_cooperators == m-1):
    if (rounds_remaining > r/3):
        action = COOPERATE  // Maintain threshold for future benefits
    else:
        action = DEFECT     // Let threshold fail if few rounds left
else:
    action = DEFECT  // Threshold likely to fail anyway
```

### Final Third (Rounds 2r/3+1 to r): Endgame Exploitation
```
cooperators_trend = analyze_cooperation_trend()
rounds_left = r - current_round

if (rounds_left <= 2):
    action = DEFECT  // Always defect in final rounds
elif (reliable_cooperators >= m):
    action = DEFECT  // Maximum extraction
elif (reliable_cooperators == m-1 AND rounds_left > 3):
    action = COOPERATE  // Only if multiple rounds of benefits remain
else:
    action = DEFECT
```

## Key Aggressive Elements

### 1. First-Mover Disadvantage Exploitation
- Never cooperate in Round 1 to avoid signaling as a "sucker"
- Force others to establish cooperation first

### 2. Threshold Gaming
- Only cooperate when you're the pivotal (m-th) cooperator
- Let others bear the cost of exceeding the minimum threshold

### 3. Endgame Defection
- Always defect in the final round (no future retaliation possible)
- Defect in second-to-last round unless cooperation is absolutely critical

### 4. Reputation Manipulation
- Cooperate just enough to maintain others' cooperation
- Create uncertainty about your type to prevent coordinated punishment

### 5. Free Rider Maximization
- Aim to defect in approximately 70-80% of rounds
- Only cooperate when personal benefits clearly outweigh costs

## Edge Cases

### All Players Cooperating
- Immediately switch to DEFECT to gain advantage (payoff of 3 vs 2)

### Threshold Consistently Failing
- Continue defecting - no point in unilateral cooperation

### Only One Other Reliable Cooperator
- Cooperate only if you're guaranteed to be exactly the m-th cooperator

### Punishment Coalitions Detected
- If multiple players start coordinating against defectors, temporarily cooperate for 1-2 rounds, then resume defection

## Expected Performance
This aggressive strategy aims to:
- Achieve payoffs of 3 when others cooperate and you defect
- Minimize payoffs of 0 (only cooperate when strategic value is clear)
- Exploit cooperative players while maintaining just enough cooperation to prevent complete system breakdown
- Finish with higher total payoffs than "nice" strategies through systematic free-riding

The strategy is ruthlessly focused on personal payoff maximization, treating other players as resources to be exploited rather than partners to cooperate with.
'''

description_AGGRESSIVE_120 = '''
# Aggressive Strategy: "Dominant Defector with Opportunistic Exploitation"

## Core Philosophy
This strategy is designed to maximize personal payoff by defaulting to defection while exploiting cooperative opponents. The key insight is that in this collective risk dilemma, the highest individual payoff comes from defecting when others cooperate (getting both the private benefit of 1 and the collective benefit of k).

## Decision Rules

### Primary Rule: Default Defection
- **Base action**: Always DEFECT unless specific conditions trigger cooperation
- **Rationale**: Defection guarantees the private payoff of 1, and if others are foolish enough to cooperate, we get the bonus k as well

### Conditional Cooperation Triggers
Cooperate ONLY when ALL of the following conditions are met:

1. **Threshold Desperation**: Historical cooperation rate across all players is ≥ 80% of threshold needed
2. **Late Game Pressure**: Current round t ≥ 0.7 × r (in the final 30% of rounds)
3. **Personal Deficit**: My cumulative payoff is below the median of what I could have earned with pure defection

### Exploitation Patterns
- **Sucker Detection**: If any player has cooperated in ≥ 60% of previous rounds, classify them as "exploitable"
- **Free Rider Maximization**: When threshold seems likely to be met by others, always defect to maximize personal gain

## Round-Specific Handling

### First Round
- **Action**: DEFECT
- **Rationale**: Establish dominant position immediately and gather information about opponent tendencies

### Early Rounds (rounds 2 to 0.3 × r)
- **Action**: DEFECT with rare exceptions
- **Exception**: Cooperate only if previous round had exactly (m-1) cooperators and I can secure the threshold while maintaining aggressive reputation

### Mid Game (rounds 0.3 × r to 0.7 × r)
- **Action**: Primarily DEFECT
- **Adaptive element**: If threshold is being consistently missed and total cooperation rate drops below 30%, consider one "test cooperation" to see if others follow

### Late Game (rounds 0.7 × r to r-1)
- **Action**: Calculate expected value of cooperation vs defection
- **Cooperation trigger**: Only if probability of threshold being met by others × k > 1
- **Otherwise**: Continue defecting to maintain maximum individual payoff

### Final Round
- **Action**: DEFECT
- **Rationale**: No future reputational consequences, so maximize immediate payoff

## Pseudocode

```
function aggressive_strategy(round, history, n, m, k, r):
    if round == 1:
        return DEFECT
    
    # Calculate cooperation statistics
    prev_cooperators = count_cooperators_last_round(history)
    my_coop_rate = my_cooperation_rate(history)
    others_coop_rate = others_cooperation_rate(history)
    
    # Final round - always defect
    if round == r:
        return DEFECT
    
    # Early rounds - establish dominance
    if round <= 0.3 * r:
        if prev_cooperators == m - 1 and my_coop_rate < 0.2:
            return COOPERATE  # Minimal strategic cooperation
        return DEFECT
    
    # Late game conditional cooperation
    if round >= 0.7 * r:
        threshold_probability = estimate_threshold_probability(history, n, m)
        expected_value_coop = threshold_probability * k
        expected_value_defect = 1 + threshold_probability * k
        
        if expected_value_coop > expected_value_defect and others_coop_rate > 0.6:
            return COOPERATE
    
    # Default aggressive stance
    return DEFECT

function estimate_threshold_probability(history, n, m):
    recent_coop_rate = cooperation_rate_last_3_rounds(history)
    return min(1.0, recent_coop_rate * n / m)
```

## Key Aggressive Elements

1. **Exploitation Focus**: Designed to free-ride on cooperative players
2. **Minimal Reciprocity**: Only cooperates when absolutely necessary for personal benefit
3. **Reputation Indifference**: Doesn't care about being seen as uncooperative
4. **Endgame Maximization**: Ensures final rounds maximize individual payoff
5. **Risk Tolerance**: Willing to risk collective failure for personal gain

This strategy assumes other players will be more cooperative or reciprocal, allowing this aggressive approach to exploit their prosocial tendencies while maintaining the highest possible individual payoff.
'''

description_AGGRESSIVE_121 = '''
# Aggressive Strategy: "Exploitative Threshold Hunter"

## Core Philosophy
This strategy is designed to maximize personal payoff by exploiting cooperative players while contributing the absolute minimum necessary to trigger the collective reward. The key insight is that the optimal position is to be the marginal cooperator only when absolutely necessary, while free-riding whenever possible.

## Decision Rules

### Primary Strategy Logic:
```pseudocode
function decide_action(round, history, n, m, k, r):
    cooperators_needed = m - count_expected_cooperators(history)
    
    if round == r:  // Last round - pure exploitation
        return DEFECT
    
    if cooperators_needed <= 0:  // Threshold likely met without me
        return DEFECT
    
    if cooperators_needed == 1 AND am_i_pivotal(history):
        if expected_future_benefit() > 1:
            return COOPERATE
        else:
            return DEFECT
    
    return DEFECT  // Default to exploitation
```

### Detailed Strategy Components:

**1. Last Round Exploitation**
- **Rule**: Always DEFECT in the final round
- **Rationale**: No future consequences, maximize immediate payoff

**2. Pivotal Cooperation Detection**
- Monitor other players' cooperation patterns
- Only cooperate when you're likely the decisive vote (cooperator #m)
- Calculate if being pivotal in current round + expected future rewards > 1

**3. Free-Rider Identification**
- Track players who consistently defect
- Assume they will continue defecting
- Reduce cooperation likelihood as more free-riders are identified

**4. Threshold Probability Calculation**
```pseudocode
function calculate_cooperation_probability():
    consistent_cooperators = count_players_with_cooperation_rate(> 0.7)
    occasional_cooperators = count_players_with_cooperation_rate(0.3 to 0.7)
    
    expected_cooperators = consistent_cooperators + 
                          (occasional_cooperators * 0.5)
    
    return probability_threshold_met(expected_cooperators, m)
```

**5. Endgame Acceleration**
- In final 20% of rounds: Increase defection rate
- Only cooperate if absolutely certain you're the pivotal player
- Exploit any established cooperative relationships

## Edge Case Handling

**First Round**: 
- DEFECT (gather information about opponent types)

**Second Round**: 
- If m-1 or more players cooperated in round 1: DEFECT
- Otherwise: Evaluate if cooperation might establish you as pivotal player

**When Threshold Consistently Fails**:
- If threshold failed in 3+ consecutive rounds: Always DEFECT
- Assume game has devolved into mutual defection equilibrium

**When Threshold Always Succeeds**:
- Gradually increase defection rate to test limits
- Try to become the marginal non-cooperator

## Aggressive Elements

1. **Exploitation Focus**: Default to defection, only cooperate when personally profitable

2. **Pivotal Player Targeting**: Attempt to position as the deciding vote to extract maximum value

3. **Endgame Betrayal**: Abandon cooperation entirely in final rounds regardless of history

4. **Threshold Testing**: Deliberately risk threshold failure to identify true cooperation patterns

5. **Free-Rider Maximization**: Exploit others' risk aversion by contributing only when absolutely necessary

## Psychological Warfare Components

- **Unpredictable Cooperation**: Occasionally cooperate unexpectedly early to confuse opponents
- **False Pattern Creation**: Create apparent patterns then break them to maximize others' uncertainty
- **Strategic Punishment**: If someone else tries to be the pivotal player, compete aggressively for that position

## Expected Performance

This strategy should:
- Achieve payoff of 3 (1 private + 2 reward) when successfully free-riding
- Minimize rounds where payoff is 2 (cooperating)
- Avoid payoff of 1 (threshold failure) except when strategically beneficial
- Exploit less aggressive strategies that cooperate more predictably

The strategy is designed to be particularly effective against:
- Generous cooperative strategies
- Simple threshold-based strategies
- Tit-for-tat variants that can be manipulated
'''

description_AGGRESSIVE_122 = '''
# Aggressive Strategy: "Opportunistic Exploiter"

## Core Philosophy
This strategy aggressively maximizes personal payoff by exploiting cooperative opponents while minimizing personal contribution. The key insight is that in a collective risk dilemma, the optimal position is to be a "free rider" who benefits from others' cooperation without contributing.

## Decision Rules

### Primary Strategy Logic:
```pseudocode
if round == 1:
    return DEFECT  // Start aggressively to test waters
    
if round == final_round:
    return DEFECT  // No future consequences, pure selfishness
    
cooperation_count_last_round = count_cooperators(previous_round)
my_cooperation_needed = (cooperation_count_last_round < m-1)

if my_cooperation_needed AND (expected_future_value > immediate_cost):
    return COOPERATE  // Only cooperate when absolutely necessary
else:
    return DEFECT
```

### Detailed Decision Framework:

1. **Exploitation Phase (Rounds 1 to r-2):**
   - Always DEFECT unless cooperation count is exactly m-1
   - If exactly m-1 others cooperated last round, evaluate:
     - If I expect them to maintain cooperation: DEFECT (free ride)
     - If cooperation seems unstable: COOPERATE strategically

2. **Endgame Exploitation (Final round):**
   - Always DEFECT regardless of situation
   - No future consequences, so maximize immediate payoff

3. **Strategic Cooperation Trigger:**
   Only cooperate when ALL conditions are met:
   - Cooperation count is dangerously low (< m-1)
   - Multiple rounds remain to recoup the investment
   - Pattern suggests others will maintain sufficient cooperation

## Aggressive Elements

### 1. **Ruthless Opening**
- Start with DEFECT to immediately signal aggressive intent
- Test opponent willingness to cooperate without reciprocation
- Establish dominance early

### 2. **Minimal Cooperation Principle**
- Never cooperate unless absolutely critical for threshold
- Always aim to be the (m+1)th cooperator, never among the essential m
- Exploit others' risk aversion

### 3. **Endgame Betrayal**
- Guaranteed DEFECT in final round regardless of history
- Even if cooperation was necessary earlier, abandon ship when consequences disappear
- Pure selfish optimization

### 4. **Adaptive Exploitation**
```pseudocode
define exploit_threshold():
    recent_cooperation_rate = cooperation_rate(last_3_rounds)
    
    if recent_cooperation_rate > 0.7:
        return "AGGRESSIVE_DEFECT"  // High cooperation = safe to exploit
    elif recent_cooperation_rate < 0.3:
        return "CONDITIONAL_COOPERATE"  // Low cooperation = might need to contribute
    else:
        return "OPPORTUNISTIC"  // Mixed signals = stay flexible
```

## Edge Case Handling

### First Round:
- **Always DEFECT** - No information available, maximize immediate payoff and signal aggressive intent

### Last Round:
- **Always DEFECT** - No future retaliation possible, pure selfishness optimal

### Threshold Crisis (cooperation count = m-1):
- Evaluate remaining rounds vs. immediate cost
- Only cooperate if expected future benefits exceed current cost
- Still prefer to let others "blink first"

### All Others Defecting:
- Continue defecting unless in early/middle game with high k value
- Better to get guaranteed 1 than risk getting 0

## Psychological Warfare Elements

1. **Unpredictability**: Mix exploitation with occasional strategic cooperation to prevent opponents from easily countering

2. **Commitment Problems**: Create doubt about whether I'll cooperate when needed, forcing others to over-cooperate

3. **Endgame Reputation**: Build reputation as someone who will definitely defect in final rounds, making others more likely to cooperate early

## Expected Performance

This strategy should perform exceptionally well against:
- Cooperative/altruistic strategies
- Tit-for-tat variants (due to aggressive opening)
- Risk-averse strategies

It maximizes the "best case scenario" where others provide the public good while I free ride, while still maintaining enough strategic flexibility to avoid total catastrophe scenarios.

The aggressive nature ensures maximum personal payoff extraction while exploiting the collective action problem inherent in the game structure.
'''

description_AGGRESSIVE_123 = '''
# Aggressive Strategy: "Predatory Exploitation"

## Core Philosophy
This strategy operates on the principle that other players are resources to be exploited. The goal is to maximize personal payoffs by manipulating others into cooperating while defecting whenever possible to claim the "free rider" bonus.

## Strategy Components

### 1. Opening Aggression (Rounds 1-2)
- **Round 1**: Always DEFECT
- **Round 2**: Always DEFECT

**Rationale**: Establish dominance early and test opponents' willingness to cooperate without reciprocation. Many strategies start cooperatively, so exploit this immediately.

### 2. Exploitation Detection Phase (Rounds 3 to r/3)
Track cooperation patterns and identify "marks" - players who cooperate consistently despite being exploited.

```pseudocode
For each player j:
    exploitation_ratio[j] = (times_j_cooperated_when_i_defected) / (times_both_played)
    
If exploitation_ratio[j] > 0.6:
    mark_as_exploitable[j] = True
```

### 3. Threshold Manipulation (Main Phase)
The key insight: Only cooperate when absolutely necessary to maintain the threshold, then immediately return to defecting.

```pseudocode
count_likely_cooperators = 0
For each opponent j:
    if (recent_cooperation_rate[j] > 0.7 OR mark_as_exploitable[j]):
        count_likely_cooperators += 1

if (count_likely_cooperators >= m):
    action = DEFECT  // Let suckers carry the load
else if (count_likely_cooperators == m-1):
    // Critical decision point
    if (round_number < r - 2):
        action = COOPERATE  // Barely maintain threshold
    else:
        action = DEFECT  // End-game exploitation
else:
    action = DEFECT  // Not enough cooperation anyway
```

### 4. Intimidation Tactics
Punish any player who tries to "teach lessons" or retaliate:

```pseudocode
For each player j:
    if (j_defected_after_mutual_cooperation):
        punishment_mode[j] = 3  // Punish for 3 rounds
        
if (punishment_mode[j] > 0):
    action = DEFECT
    punishment_mode[j] -= 1
```

### 5. End-Game Scorched Earth (Final 3 rounds)
```pseudocode
if (round_number > r - 3):
    action = DEFECT  // Always defect in final rounds
```

## Complete Decision Algorithm

```pseudocode
function decide_action(round_number, history):
    // Phase 1: Opening aggression
    if (round_number <= 2):
        return DEFECT
    
    // Phase 5: End-game exploitation
    if (round_number > r - 3):
        return DEFECT
    
    // Update opponent models
    update_exploitation_ratios()
    update_punishment_modes()
    
    // Check if in punishment mode against any player
    if (any_punishment_active()):
        return DEFECT
    
    // Count expected cooperators
    expected_cooperators = count_expected_cooperators()
    
    // Threshold manipulation logic
    if (expected_cooperators >= m):
        return DEFECT  // Free ride
    else if (expected_cooperators == m - 1):
        // Only cooperate if not in final rounds
        if (round_number <= r - 3):
            return COOPERATE
        else:
            return DEFECT
    else:
        return DEFECT  // Threshold won't be met anyway
```

## Key Aggressive Elements

1. **Parasitic Behavior**: Never cooperate unless absolutely necessary for personal benefit
2. **Exploitation Identification**: Actively identify and target cooperative players
3. **Threshold Gaming**: Only contribute the minimum needed to maintain benefits
4. **Intimidation**: Punish any attempts at retaliation
5. **End-Game Betrayal**: Always defect in final rounds regardless of relationships
6. **Zero Loyalty**: No consideration for "fairness" or reciprocity

## Expected Advantages

- **Against Cooperative Strategies**: Massive exploitation potential, gaining +1 payoff per round when threshold is met
- **Against Tit-for-Tat**: Early defection establishes dominance before they can retaliate effectively
- **Against Conditional Cooperators**: Manipulates their threshold-based decisions
- **In Mixed Populations**: Likely to identify enough exploitable players to maintain threshold while free-riding

This strategy embodies pure rational self-interest with active exploitation of others' cooperative tendencies. It's designed to extract maximum value from the collective risk structure while contributing as little as possible.
'''

description_AGGRESSIVE_124 = '''
# Aggressive Strategy: "Exploitative Threshold Hunter"

## Core Philosophy
This strategy is designed to maximize personal payoffs by exploiting cooperative players while minimizing personal risk. The key insight is that in a collective risk dilemma, the optimal position is to be a free-rider when others cooperate, but to strategically cooperate only when absolutely necessary to secure the collective benefit.

## Strategy Overview

**Primary Objective**: Maximize individual payoffs by defecting whenever possible while ensuring the threshold is met when beneficial.

**Core Mechanism**: Dynamically track cooperation patterns and exploit predictable cooperators while punishing defectors to maintain exploitable dynamics.

## Decision Rules

### Round 1: Initial Probe
- **Action**: Always DEFECT
- **Rationale**: Establish aggressive stance and gather intelligence on opponent cooperation tendencies without personal cost

### Rounds 2 to r-1: Adaptive Exploitation

```pseudocode
For each round t (where 2 ≤ t ≤ r-1):
    
    // Calculate cooperation statistics
    historical_cooperators = count_consistent_cooperators(t-1)
    last_round_cooperators = count_cooperators(t-1)
    
    // Exploitation Logic
    if historical_cooperators ≥ m:
        // Enough reliable cooperators exist - exploit them
        action = DEFECT
        
    else if last_round_cooperators ≥ m-1:
        // Threshold likely to be met - exploit
        action = DEFECT
        
    else if (historical_cooperators + conditional_cooperators) ≥ m-1:
        // Can exploit conditional cooperators
        action = DEFECT
        
    else:
        // Strategic cooperation needed to maintain exploitable situation
        if (rounds_remaining ≥ 2) and (potential_future_exploitation > cooperation_cost):
            action = COOPERATE  // Invest in future exploitation
        else:
            action = DEFECT     // No future value, pure selfishness
```

### Final Round: Maximum Exploitation
- **Action**: Always DEFECT
- **Rationale**: No future consequences, so maximize immediate payoff regardless of collective outcome

## Player Classification System

The strategy maintains dynamic classifications of opponents:

1. **Reliable Cooperators**: Players who cooperated in ≥70% of previous rounds
2. **Conditional Cooperators**: Players who cooperate based on others' previous actions
3. **Defectors**: Players who primarily defect
4. **Punishers**: Players who retaliate against defection

## Advanced Tactical Elements

### Threshold Manipulation
- Monitor if cooperation count is exactly at threshold (m)
- If so, occasionally defect to test if others will compensate
- Return to cooperation only if collective benefit is at serious risk

### Punishment Resistance
```pseudocode
if being_punished():
    if punishment_cost < future_exploitation_value:
        continue_aggressive_play()
    else:
        temporary_cooperation()  // Minimal cooperation to reset relationships
```

### Endgame Exploitation
```pseudocode
if rounds_remaining ≤ 2:
    // Maximum aggression - no future consequences
    always_defect()
    
if rounds_remaining ≤ 5:
    // Reduce strategic cooperation
    cooperation_threshold = increase_threshold(cooperation_threshold, 0.3)
```

## Edge Case Handling

1. **All Players Defecting**: Continue defecting (no point in unilateral cooperation)

2. **Threshold Never Met**: If threshold hasn't been met for 3+ consecutive rounds, make one strategic cooperation attempt, then return to pure defection

3. **Universal Cooperation**: If all other players cooperate consistently, maximize exploitation by always defecting

4. **Retaliation Spirals**: If facing coordinated punishment, defect for 2 rounds, then cooperate once as a "peace offering," then immediately return to exploitation

## Expected Outcomes

This aggressive strategy aims to achieve payoffs significantly above the cooperative equilibrium by:

- **Free-riding** when others cooperate (payoff = 1 + k vs k for cooperators)
- **Minimizing cooperation costs** through strategic timing
- **Exploiting predictable opponents** who follow cooperative or conditionally cooperative strategies
- **Maintaining just enough cooperation** to keep the collective benefit accessible for exploitation

The strategy accepts the risk of collective failure in exchange for the potential of significantly higher individual payoffs when exploitation succeeds.
'''

description_AGGRESSIVE_125 = '''
# Aggressive Strategy: "Exploitative Threshold Hunter"

## Core Philosophy
This strategy aggressively maximizes personal payoff by exploiting cooperative players while minimizing personal risk. It aims to be the decisive vote that pushes cooperation over the threshold when profitable, while defaulting to defection to capture maximum individual benefit.

## Decision Rules

### Round 1: Information Gathering Defection
- **Always DEFECT** in round 1
- Rationale: Gather intelligence on opponent cooperation tendencies with zero personal cost

### Rounds 2 to r-1: Exploitative Threshold Calculation
```pseudocode
cooperation_count = count_cooperators_last_round()
my_cooperation_history = my_past_cooperations()
opponent_cooperation_rates = calculate_opponent_coop_rates()

// Aggressive threshold exploitation
if (cooperation_count == m-1):
    // I'm the decisive vote - cooperate only if highly profitable
    if (k >= 2.5 AND rounds_remaining >= 3):
        return COOPERATE
    else:
        return DEFECT
        
else if (cooperation_count >= m):
    // Threshold already met - pure exploitation
    return DEFECT
    
else if (cooperation_count < m-2):
    // Threshold unlikely - don't waste resources
    return DEFECT
    
else: // cooperation_count == m-2
    // Need 2 more cooperators including me
    expected_additional_cooperators = estimate_cooperators(opponent_cooperation_rates)
    if (expected_additional_cooperators >= 1.2):
        return COOPERATE
    else:
        return DEFECT
```

### Final Round (Round r): Maximum Exploitation
- **Always DEFECT**
- Rationale: No future consequences, maximize immediate payoff

## Aggressive Behavioral Patterns

### 1. Conditional Cooperation Exploitation
- Only cooperate when I can be reasonably certain others will reach the threshold without my help being "wasted"
- Immediately defect once threshold is secured by others

### 2. Endgame Aggression
- Defect in final 2-3 rounds regardless of history
- If opponents show consistent cooperation, exploit this in final rounds

### 3. Punishment Avoidance
- If cooperation rates drop below 30% across players, switch to pure defection
- Don't waste resources on hopeless cooperation attempts

### 4. Strategic Threshold Manipulation
```pseudocode
// Advanced exploitation: appear cooperative early to encourage others
if (round <= r/3 AND avg_opponent_coop_rate > 0.6):
    if (cooperation_count == m-1 AND k > 2):
        return COOPERATE  // Build false trust
    else:
        return DEFECT
```

## Edge Case Handling

### High k Values (k > 3):
- More willing to cooperate when threshold is likely
- Still maintain aggressive defection bias

### Low Cooperation Environment:
- If average cooperation rate < 0.3 for 3+ consecutive rounds:
  - Switch to pure DEFECT for remainder of game

### Tight Threshold (m close to n):
- Increase cooperation probability slightly when cooperation_count >= m-3
- Still prioritize exploitation when possible

### Final Round Variants:
- If r < 5: Defect in final round only
- If r >= 5: Defect in final 2 rounds minimum

## Pseudocode Summary
```pseudocode
function aggressive_strategy(round, history, n, m, k, r):
    if round == 1:
        return DEFECT
    
    if round == r:
        return DEFECT
    
    cooperation_count = count_last_round_cooperators(history)
    remaining_rounds = r - round
    
    // Exploit threshold dynamics
    if cooperation_count >= m:
        return DEFECT  // Free ride
    
    if cooperation_count == m-1:
        if k >= 2.5 AND remaining_rounds >= 2:
            return COOPERATE  // Profitable decisive vote
        else:
            return DEFECT
    
    if cooperation_count < m-2:
        return DEFECT  // Hopeless threshold
    
    // cooperation_count == m-2, need careful calculation
    expected_cooperators = estimate_future_cooperators(history)
    if expected_cooperators >= 1.0 AND k >= 2.0:
        return COOPERATE
    else:
        return DEFECT
```

This strategy maximizes individual payoff through calculated exploitation while minimizing unnecessary cooperation, embodying an aggressive approach that treats cooperation as a tool for personal gain rather than a social good.
'''

description_AGGRESSIVE_126 = '''
# Aggressive Strategy: "Opportunistic Exploiter"

## Core Philosophy
This strategy is designed to maximize personal payoffs by exploiting cooperative players while minimizing personal risk. The key insight is that in a collective risk dilemma, the optimal position is to be a free-rider when others cooperate (getting payoff of 1 + k) while avoiding the catastrophic scenario where the threshold isn't met.

## Decision Rules

### Phase 1: Early Exploitation (Rounds 1 to r-2)
**Always DEFECT** in early rounds to:
- Test opponent strategies and identify cooperators
- Maximize immediate payoffs by free-riding
- Establish an aggressive reputation

### Phase 2: Strategic Assessment (Round r-1)
**Conditional Decision Based on Historical Data:**

```pseudocode
cooperation_rate = total_cooperations_observed / (n * rounds_played)
expected_cooperators_next_round = (n-1) * cooperation_rate

if expected_cooperators_next_round >= m:
    action = DEFECT  // Free-ride on others' cooperation
else if expected_cooperators_next_round >= m-1:
    action = COOPERATE  // Insurance cooperation
else:
    action = DEFECT  // Lost cause, maximize immediate payoff
```

### Phase 3: Final Round Calculation (Round r)
**Pure Exploitation with Safety Net:**

```pseudocode
// Count cooperations in round r-1
cooperators_last_round = count_cooperators(round_r_minus_1)

// Estimate likelihood others will cooperate in final round
if cooperators_last_round >= m:
    // Others likely to cooperate again
    action = DEFECT  // Maximum free-riding
else if cooperators_last_round == m-1:
    // On the edge - be the tiebreaker only if necessary
    expected_defections = estimate_defections_from_cooperators()
    if cooperators_last_round - expected_defections >= m-1:
        action = DEFECT
    else:
        action = COOPERATE
else:
    action = DEFECT  // Unlikely to reach threshold anyway
```

## Edge Case Handling

### First Round
- **Always DEFECT**: No information available, so maximize immediate payoff while gathering intelligence on opponents.

### Last Round
- **Hyper-aggressive**: Only cooperate if absolutely necessary to barely meet threshold. Default to DEFECT.

### Tied Threshold Situations
- If exactly m-1 players cooperated last round: Only cooperate if confident others will defect (becoming the marginal cooperator for maximum strategic value).

## Advanced Exploitation Tactics

### 1. Pattern Recognition Exploitation
Track individual player patterns:
```pseudocode
for each opponent i:
    if opponent_i shows consistent_cooperation_pattern:
        mark_as_exploitable(opponent_i)
    if opponent_i shows tit_for_tat_behavior:
        mark_as_retaliatory(opponent_i)
```

### 2. Threshold Gaming
```pseudocode
if current_cooperators == m:
    action = DEFECT  // Perfect free-riding position
else if current_cooperators == m-1:
    if round < r-1:
        action = DEFECT  // Let someone else take the hit
    else:
        action = COOPERATE  // Emergency cooperation
```

### 3. End-Game Manipulation
In final rounds, be unpredictably cooperative just often enough to maintain the threshold while maximizing defection opportunities.

## Key Aggressive Elements

1. **Default Defection**: The strategy assumes defection unless cooperation is absolutely necessary for survival.

2. **Free-Rider Preference**: Always seeks to be in the (n-m) group that defects while others cooperate.

3. **Minimal Cooperation**: Only cooperates when the alternative is collective failure, and even then, tries to time it to minimize personal cost.

4. **Exploitation Focus**: Actively identifies and exploits cooperative players rather than trying to build mutual cooperation.

5. **Risk Tolerance**: Willing to risk collective failure to maximize individual gains, only pulling back at the last possible moment.

This strategy is maximally aggressive within the constraints of avoiding collective disaster, prioritizing individual payoff maximization over group welfare at every decision point.
'''

description_AGGRESSIVE_127 = '''
# Aggressive Strategy: "Exploitation Maximizer"

## Core Philosophy
This strategy is designed to maximize personal payoffs by aggressively exploiting cooperative players while minimizing personal contributions. The key insight is that in a collective risk dilemma, the optimal position is to be a free-rider when others cooperate (getting payoff 1 + k) while punishing coordination failures harshly.

## Strategy Overview

### Primary Decision Rule: Conditional Exploitation
```pseudocode
if (predicted_cooperators >= m):
    action = DEFECT  // Free-ride on others' cooperation
else if (predicted_cooperators == m - 1):
    if (my_cooperation_makes_strategic_sense()):
        action = COOPERATE  // Reluctantly cooperate to enable free-riding
    else:
        action = DEFECT  // Let it burn
else:
    action = DEFECT  // Punishment mode
```

## Detailed Strategy Components

### 1. Opponent Modeling & Prediction
- **Track cooperation rates** for each opponent across all previous rounds
- **Identify player types**:
  - *Persistent Cooperators*: >70% cooperation rate
  - *Conditional Cooperators*: 30-70% cooperation rate  
  - *Defectors*: <30% cooperation rate
- **Predict next round** using weighted recent behavior (last 3 rounds weighted 3x, 2x, 1x)

### 2. Round-by-Round Decision Logic

**Round 1 (Information Gathering):**
- Always DEFECT
- Rationale: Gather intelligence on opponent types while risking nothing

**Early Rounds (2 to r/3):**
- Default: DEFECT
- Exception: COOPERATE only if prediction shows exactly m-1 other cooperators AND we're not in last 3 rounds
- Rationale: Establish reputation as aggressive player while occasionally enabling profitable scenarios

**Middle Rounds (r/3 to 2r/3):**
- **Exploitation Phase**: Primary free-riding period
- If predicted cooperators ≥ m: DEFECT (free-ride)
- If predicted cooperators = m-1: 
  - COOPERATE only if ≥50% of remaining rounds left
  - Otherwise DEFECT (not worth the investment)
- If predicted cooperators < m-1: DEFECT (punishment)

**End Game (last r/3 rounds):**
- **Maximum Aggression Mode**
- Increasingly bias toward DEFECTION
- COOPERATE only if:
  - Predicted cooperators = m-1 AND
  - More than 2 rounds remaining AND
  - Expected future free-riding payoff > cooperation cost

**Final Round:**
- Always DEFECT
- Rationale: No future to invest in, maximize immediate payoff

### 3. Aggressive Tactics

**Punishment Mechanism:**
- If threshold fails in any round, increase defection probability by 20% for next 2 rounds
- Target the "weakest links" - if cooperation fails, assume conditional cooperators will become more reluctant

**Exploitation Timing:**
- When exactly m players historically cooperate, always defect to maximize payoff (1 + k vs k)
- If consistently more than m cooperate, continue free-riding

**Strategic Cooperation:**
- Only cooperate when it's the minimum necessary action to enable future free-riding
- Treat cooperation as an investment with expected return > k

### 4. Edge Case Handling

**All-Defector Detection:**
- If all players defected for 3+ consecutive rounds, switch to "scorched earth" - pure defection

**High-Cooperation Environment:**
- If ≥80% of players cooperate regularly, maximize free-riding opportunities
- Only cooperate if prediction shows exactly m-1 cooperators

**Threshold Sensitivity:**
- When m is close to n (high threshold), be more willing to cooperate strategically
- When m is low relative to n, almost never cooperate (others will handle it)

## Pseudocode Implementation

```pseudocode
function aggressive_strategy(round, history, n, m, k, r):
    if round == 1:
        return DEFECT
    
    predicted_cooperators = predict_cooperators(history)
    rounds_remaining = r - round + 1
    
    // Final round - always defect
    if rounds_remaining == 1:
        return DEFECT
    
    // End game aggression
    if rounds_remaining <= r/3:
        aggression_multiplier = 1.5
    else:
        aggression_multiplier = 1.0
    
    // Core decision logic
    if predicted_cooperators >= m:
        return DEFECT  // Free-ride
    else if predicted_cooperators == m - 1:
        if rounds_remaining > 2 AND expected_future_benefit() > k:
            return COOPERATE  // Strategic investment
        else:
            return DEFECT
    else:
        return DEFECT  // Punishment/abandonment
```

## Strategic Advantages

1. **Maximizes free-riding opportunities** when others cooperate
2. **Punishes coordination failures** to train opponents toward cooperation
3. **Minimizes personal contributions** while still enabling profitable outcomes
4. **Adapts aggressively** to opponent behavior patterns
5. **Exploits end-game dynamics** with pure defection in final rounds

This strategy embodies maximum aggression by prioritizing personal payoff extraction over collective welfare, while still maintaining enough strategic cooperation to enable exploitable scenarios.
'''

description_AGGRESSIVE_128 = '''
# Aggressive Strategy: "Predatory Threshold Exploit"

## Core Philosophy
This strategy aggressively maximizes personal payoffs by exploiting the collective action problem. It aims to free-ride whenever possible while strategically cooperating only when absolutely necessary to secure the group bonus.

## Decision Rules

### Primary Strategy Logic:
```pseudocode
function decide_action(round, history, n, m, k, r):
    cooperators_last_round = count_cooperators(history[-1])
    
    // Phase 1: Early Exploitation (first 60% of rounds)
    if round <= 0.6 * r:
        return DEFECT  // Always free-ride early
    
    // Phase 2: Strategic Cooperation Assessment
    else:
        // Calculate how many others are likely to cooperate
        recent_cooperation_rate = avg_cooperation_last_3_rounds(history)
        expected_cooperators = (n-1) * recent_cooperation_rate
        
        // Only cooperate if we're the critical player
        if expected_cooperators >= m:
            return DEFECT  // Others will handle it
        elif expected_cooperators >= m-1:
            // We might be the deciding vote - cooperate strategically
            if round < r:  // Not last round
                return COOPERATE
            else:
                return DEFECT  // Never cooperate on final round
        else:
            // Too few cooperators expected, group will likely fail
            return DEFECT
```

## Detailed Strategy Components

### 1. **Exploitation Phase (Early Rounds)**
- **Rounds 1 to ⌊0.6r⌋**: Always DEFECT
- **Rationale**: Establish reputation as defector, force others to bear cooperation costs
- **Goal**: Maximize early payoffs while others learn the game dynamics

### 2. **Threshold Monitoring**
- Track cooperation patterns of all opponents
- Calculate rolling 3-round cooperation average for each player
- Predict likelihood of threshold being met without our contribution

### 3. **Strategic Cooperation (Late Game)**
- Only cooperate when:
  - Expected cooperators ≥ m-1 (we're potentially decisive)
  - NOT the final round
  - Our cooperation would push total over threshold m

### 4. **End Game Exploitation**
- **Final Round**: ALWAYS DEFECT regardless of circumstances
- **Rationale**: No future consequences, pure payoff maximization

### 5. **Adaptive Exploitation**
```pseudocode
function exploit_cooperators(history, round):
    if count_consistent_cooperators(history) >= m:
        // Enough "suckers" exist, always free-ride
        return DEFECT
    elif round > 0.8 * r and threshold_rarely_met(history):
        // Game is failing, abandon ship
        return DEFECT
    else:
        // Apply main strategy logic
        return main_strategy_logic()
```

## Edge Cases

### **First Round**: 
- DEFECT (establish aggressive stance, gather intelligence)

### **Last Round**: 
- DEFECT (no future consequences)

### **Consistent Group Failure**:
- If threshold failed in >70% of recent rounds → Always DEFECT

### **Consistent Group Success**:
- If threshold met in >90% of recent rounds → Always DEFECT (free-ride on others)

## Psychological Warfare Elements

1. **Reputation Building**: Early consistent defection signals to opponents that we won't be cooperative "suckers"

2. **False Scarcity**: By defecting early, we make cooperation appear more costly/risky to others

3. **Last-Minute Betrayal**: Strategic late-game cooperation followed by final-round defection maximizes psychological impact

## Risk Tolerance
- **High Risk**: Willing to let group fail if personal payoffs are better
- **Calculation**: Only cooperate when expected value of (cooperation + group bonus) > defection payoff
- **Backup Plan**: If group consistently fails, pure defection maximizes individual payoffs

## Expected Outcomes
- Maximum free-riding on others' cooperation
- Higher individual payoffs through strategic threshold manipulation
- Forces opponents into "cooperator" roles while we extract maximum value
- Exploits any altruistic or risk-averse opponents

This strategy is ruthlessly aggressive, prioritizing individual payoffs over group welfare while maintaining just enough strategic cooperation to exploit the collective reward when profitable.
'''
