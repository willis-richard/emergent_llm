"""
Strategy descriptions for collective_risk.

Generated with:
- Provider: Client
- Model: mistral:latest
"""


description_COLLECTIVE_1 = '''
 In this Collective Risk Dilemma game, we'll design a strategy called Tit-for-Tat (TFT) with a twist specifically tailored for the game parameters and history.

1. Specify decision rules - When exactly do you cooperate vs defect?
   The TFT strategy will cooperate in the first round to demonstrate good intentions, then copy the previous opponent's action in the subsequent rounds. If an opponent switches from cooperation to defection, TFT will follow suit and match their defection. Conversely, if an opponent switches from defection to cooperation, TFT will also cooperate in response.

   In pseudocode:
   ```
   function TFT_Strategy(previousRoundAction):
       if round = 1:
           return Cooperate
       else:
           return previousRoundAction
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   Since there's no difference between the first and subsequent rounds within the game structure, the strategy remains consistent throughout all rounds.

3. Be collective - Clearly align with the collective mindset
   TFT encourages cooperation by mirroring opponents' actions. In a sense, it adapts to the group dynamics and seeks long-term benefits through reciprocity. By cooperating in the first round, it also demonstrates its willingness to contribute to the community project initially. If the group is cooperative, TFT will continue to cooperate; if not, it will defect in response.

   However, since there are no coordination mechanisms or shared norms among players, it's important to note that the success of this strategy depends on the distribution and behavior of other strategies in the tournament. In an ideal scenario where most players also use cooperative strategies, TFT should thrive; but if the majority are uncooperative, the outcome might be less favorable for TFT.

In summary, Tit-for-Tat with a twist is a simple and adaptive strategy that encourages cooperation through reciprocity while being mindful of opponents' actions in the game.
'''

description_COLLECTIVE_2 = '''
 Strategy Name: Tit-for-Tat with Adaptive Threshold (TFT-AT)

1. Decision Rules:
   - In each round, TFT-AT cooperates if the number of cooperators in the previous round is greater than or equal to the adaptive threshold. Otherwise, it defects.
   - The adaptive threshold is initially set at m and adjusts based on the average number of cooperators from the last (r/2) rounds. If more than half of the players have been cooperating recently, the threshold increases; if less, it decreases. This encourages cooperation when it's beneficial and maintains a defensive stance otherwise.

2. Handling Edge Cases:
   - In the first round, TFT-AT sets its adaptive threshold to m and cooperates if m or more players also cooperate. If fewer than m players cooperate, it defects to avoid being taken advantage of by too many defector strategies in the initial rounds.
   - In the last round, TFT-AT follows its current decision rule as usual, with the adaptive threshold adjusted based on the average from the most recent half of games.

3. Being Collective:
   - TFT-AT is inherently collective in that it aims to maintain cooperation when it seems advantageous and punish defection if others deviate from cooperative behavior. This approach allows for coordination without relying on predetermined patterns or shared norms.

Pseudocode:

```
def TFT_AT(n, m, r, k):
    players = set([1, 2, ..., n])
    rounds = []
    threshold = m

    def adaptive_threshold():
        nonlocal threshold, players, r
        cooperators = sum(1 for player in players if player.last_action == 'C')
        if (r - (r // 2)) % r == 0:  # Checking every half-round
            if cooperators / n > (m + 1) / 2:
                threshold += 1
            elif cooperators / n < (m - 1) / 2:
                threshold -= 1
        return threshold

    def play_round(player):
        player.last_action = 'C' if adaptive_threshold() >= m else 'D'
        update_round_stats(player, player.last_action)

    for round in range(r):
        for player in players:
            play_round(player)
        rounds.append(round)

    return rounds
```
'''

description_COLLECTIVE_3 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to demonstrate goodwill and start building trust with other players (C).
   - For subsequent rounds, observe the number of cooperators in the previous round. If the majority (m or more) of players cooperated, cooperate again (C). If less than m players cooperated, defect (D) as punishment for non-cooperation in the last round. This tit-for-tat approach fosters cooperation but also punishes defection to encourage reciprocity.
   - In the last round, cooperate since there are no further rounds to punish non-cooperative behavior (C).

2. Handle edge cases:
   - If only one player is present, always cooperate as there's no need for punishment mechanisms (m = 1 and k > 1 makes it a win-win situation).
   - In the case where m > n, the minimum number of cooperators required exceeds the total number of players. In this scenario, always defect to avoid losing endowments needlessly since cooperation is not possible.

3. Be collective - Align with the collective mindset:
   - The strategy seeks a balance between individual interest and collective benefit by promoting reciprocity and trust-building through cooperation and punishment of defection.
   - By adhering to the tit-for-tat approach, the strategy demonstrates a willingness to work collectively towards mutual advantage when players cooperate.
'''

description_COLLECTIVE_4 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TFTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, players will cooperate to foster cooperation and build trust with other opponents. This initial cooperation serves as a starting point for future decisions.
   - For subsequent rounds: If the opponent cooperated in the previous round (c_opponent = 1), players will cooperate as well (c_player = 1). If the opponent defected (c_opponent = 0), players will defect in response (c_player = 0).
   - This simple tit-for-tat strategy aims to balance cooperation and punishment, while avoiding excessive punitive behavior.

2. Handle edge cases:
   - Last round: Players should cooperate if it results in a higher payoff compared to defection given the opponent's past actions (i.e., if the opponent has cooperated more often than not). This encourages cooperation even at the end of the game, as players may want to secure a positive payoff or reciprocate kindness.
   - First round: As mentioned earlier, players will cooperate to build trust and initiate cooperation.

3. Be collective - Clearly align with the collective mindset:
   - The TFTA strategy focuses on building long-term relationships with opponents through reciprocal cooperation and punishment. By doing so, players aim to encourage others to work together towards achieving a higher reward factor (k) when the minimum cooperators needed (m) are met.

Pseudocode:
```
def TFTA(n, r, m, k, history):
    player_history = [cooperation for cooperation in history]  # Initialize player's cooperation history
    total_reward = 0  # Initialize total reward over rounds

    for round in range(r):
        if round == 1:  # First round, cooperate to build trust
            c_player = 1
        else:
            c_opponent = player_history[-1]  # Get opponent's cooperation from last round
            c_player = 1 if c_opponent == 1 else 0  # Cooperate or defect based on opponent's decision in previous round

        # Calculate payoff for the current round (π_i)
        c_i = 1 if c_player == 1 else 0
        if sum(player_history[-m:]) < m:
            π_i = 1 - c_i
        else:
            π_i = 1 - c_i + k

        # Update player's cooperation history and total reward
        player_history.append(c_player)
        total_reward += π_i

    return total_reward  # Return the total payoff over r rounds
```

The TFTA strategy aims to balance cooperation and punishment while being adaptive and robust to a wide range of opponent behaviors. It encourages long-term relationships with opponents, promoting collective success in the Collective Risk Dilemma game.
'''

description_COLLECTIVE_5 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   The ATFT strategy begins by cooperating in the first round, mimicking the optimistic spirit of cooperation. Subsequent actions depend on the opponent's previous action. If the opponent cooperates, the ATFT strategy will continue to cooperate as a gesture of goodwill and reciprocity. However, if the opponent defects, the ATFT strategy will also defect in retaliation for the self-interested behavior. The aim is to foster trust while punishing defection to encourage cooperation.

Pseudocode:
```
def ATFT(round, history):
  if round == 1:
    cooperate = True
  else:
    cooperate = history[-1] == 'Cooperate'
    if cooperate == False and history[-2] == 'Defect':
      cooperate = False
  return cooperate
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   Since the strategy is adaptive, there are no specific edge cases that require different handling. The initial cooperation and retaliation against defection apply throughout the game, with the exception of the final round (if specified) where cooperation may be reintroduced to encourage long-term cooperation or to show goodwill towards potential future interactions.

3. Be collective - Clearly align with the collective mindset
   ATFT aims to balance individual self-interest and collective wellbeing by encouraging cooperation while punishing defection. The strategy promotes a collective mindset through reciprocity, as it rewards players who cooperate and retaliates against those who defect. Additionally, the strategy is adaptive and able to respond collectively to various opponent behaviors, which may help foster a sense of cooperation over time as opponents recognize the benefits of working together.
'''

description_COLLECTIVE_6 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
In each round t, TFT-AC starts by cooperating (C), mirroring the behavior of others from the previous round. If an opponent cooperated in round t-1, the TFT-AC player will cooperate. If an opponent defected in round t-1, the TFT-AC player will also defect.

If there was no interaction in the previous round (e.g., first round or a missing player), TFT-AC will start by cooperating. To adapt to different player behaviors, TFT-AC introduces a tolerance threshold 'p' and a punishment factor 'q'. If more than p% of opponents defected consistently over the last 's' rounds, TFT-AC will switch its strategy from cooperative (C) to punishing (P), which means it will start defecting. If less than q% of opponents have been defection-consistent, TFT-AC will switch its strategy back to cooperative (C). The parameters 'p' and 'q' can be adjusted based on the specific game settings and opponent behaviors observed during play.

2. Handle edge cases - What do you do in the first round, last round, etc.?
In the first round, TFT-AC starts by cooperating as there is no previous interaction to observe. In the last round, if the total payoff over all rounds exceeds a predefined threshold (h), TFT-AC will switch its strategy back to cooperative, even if it had switched to punishing due to consistent defection from opponents earlier in the game.

3. Be collective - Clearly align with the collective mindset
TFT-AC aims to balance individual payoffs and long-term cooperation by mirroring opponent behavior while maintaining adaptability to different player strategies. By starting cooperatively, TFT-AC encourages others to follow suit, fostering a collective mindset of cooperation. However, it also punishes defection through the adaptation mechanism, enforcing consequences for those who do not reciprocate cooperation. This strategy is designed to be robust against a wide range of opponent behaviors, promoting a more cooperative outcome in repeated interactions.

Pseudocode:

```python
# Initialize strategy parameters
r = rounds
n = players
m = minimum_cooperators
k = reward_factor
p = tolerance_threshold
q = cooperation_threshold
h = total_payoff_threshold
s = previous_interaction_window (e.g., last 10 rounds)
strategy = "C" # Cooperative by default

# Define function to calculate payoff for player i in round t
def calculate_payoff(i, t):
    if t == 1: # First round special case
        if i == m: return (1 - c_i) + k
        else: return (1 - c_i)

    previous_round = t - 1
    cooperators_in_previous_round = sum(cooperated[previous_round][j] for j in range(1, n+1))

    if cooperators_in_previous_round < m: # No cooperation threshold met
        return (1 - c_i)
    else:
        payoff = (1 - c_i) + k * sum([payoffs[t][j] for j in range(1, n+1) if cooperated[t-1][j]]) / s
        return payoff

# Define function to calculate total game payoff for player i over r rounds
def calculate_total_game_payoff(i):
    total_payoff = 0
    for t in range(1, r+1):
        cooperated[t-1][i] = strategy == "C" # Update cooperation status for round t-1
        payoffs[t][i] = calculate_payoff(i, t) # Calculate payoff for round t
        total_payoff += payoffs[t][i]
    return total_payoff

# Initialize arrays to store cooperation status and player payoffs per round
cooperated = [[0] * (n+1) for _ in range(r)]
payoffs = [[0] * (n+1) for _ in range(r+1)]

# Main loop for r rounds of the game
for t in range(1, r+1):
    cooperated[t-1] = [] # Update cooperation status for round t-1
    for i in range(1, n+1):
        cooperated[t-1].append(strategy == "C") # Add i-th player's cooperation status

        if strategy == "C" and not cooperated[t-1][i]: # If the current strategy is cooperative but opponent defected
            if t - s < 1: # Not enough previous interaction to adapt
                continue
            count_defectors = sum(sum([cooperated[prev][j] for prev in range(max(0, t-s), t)]) for j in range(1, n+1))
            if count_defectors / (s * n) > p: # More than p% of opponents have been defecting consistently
                strategy = "P" # Switch to punishing strategy

        elif strategy == "D" and cooperated[t-1][i]: # If the current strategy is defection but opponent cooperated
            if t - s < 1: # Not enough previous interaction to adapt
                continue
            count_cooperators = sum(sum([cooperated[prev][j] for prev in range(max(0, t-s), t)]) for j in range(1, n+1))
            if count_cooperators / (s * n) > q: # Less than q% of opponents have been cooperating consistently
                strategy = "C" # Switch to cooperative strategy

        payoffs[t][i] = calculate_payoff(i, t) # Calculate payoff for round t
```
'''

description_COLLECTIVE_7 = '''
 Strategy Name: Tit-for-Tat with Gradient Adaptation (TFT-GA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, the TFT-GA strategy cooperates if the number of cooperators in the previous round is greater than or equal to m, and it defects otherwise. This rule promotes cooperation when the majority of players also cooperated in the previous round, but retaliates by defecting if any player defected in the previous round.

   To handle cases where a single player repeatedly deviates from the cooperation, TFT-GA includes a gradient adaptation mechanism that adjusts its behavior based on the deviation frequency and impact of the opponent's actions. The adaptation is done using an exponential moving average (EMA) to analyze the opponent's cooperative tendencies over multiple rounds.

   If the EMA value (average cooperative tendency of the opponent) is below a certain threshold (e.g., m - 1), TFT-GA gradually decreases its cooperation probability to match the opponent's behavior. Conversely, if the EMA value is above the threshold (e.g., m + 1), TFT-GA increases its cooperation probability to encourage more cooperation from the opponent.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, TFT-GA starts by cooperating to encourage other players to do the same. If no information about other players' strategies is available before the game starts, it can use a random initial cooperation probability (e.g., 0.5).

   In the last round, TFT-GA considers the current EMA value and makes its decision based on whether cooperating would benefit or harm the long-term payoff according to the gradient adaptation mechanism.

3. Be collective - Clearly align with the collective mindset
   To promote collective cooperation, TFT-GA seeks to maintain a balance between individual rewards and collective benefits by adjusting its cooperation probability based on the number of cooperators in the previous round. The strategy is robust against various opponent behaviors due to its adaptive nature and the inclusion of the gradient adaptation mechanism, which allows it to respond effectively to different levels of cooperation and defection from other players.

Pseudocode for the Tit-for-Tat with Gradient Adaptation (TFT-GA) strategy:

```python
class TFT_GA:
    def __init__(self, m, k, ema_window):
        self.m = m
        self.k = k
        self.ema_window = ema_window
        self.coop_prob = 0.5
        self.ema_coop_tendency = 0

    def update_cooperation_prob(self, opponent_cooperated):
        if opponent_cooperated:
            self.ema_coop_tendency = (self.ema_coop_tendency * (1 - 1/self.ema_window) + 1)
        else:
            self.ema_coop_tendency = (self.ema_coop_tendency * (1 - 1/self.ema_window))

    def decide_action(self, round, opponent_cooperated):
        if round == 1:
            return True # Cooperate in the first round

        self.update_cooperation_prob(opponent_cooperated)
        cooperation_threshold = (self.m - 1) * (1 / self.ema_window) + 1
        if opponent_cooperated and round != r or self.ema_coop_tendency >= cooperation_threshold:
            return True # Cooperate when conditions are met
        else:
            return False # Defect otherwise
```
'''

description_COLLECTIVE_8 = '''
 Strategy Name: Tit-for-Tat Adaptive (TfTA)

1. Decision Rules - TfTA cooperates when others cooperate and defects when others defect, with a slight modification to handle initial cooperation and long-term adaptation.

   - If the number of cooperators in the previous round is greater than or equal to m, TfTA cooperates in the current round.
   - If the number of cooperators in the previous round is less than m and the average number of cooperators over the past X rounds is also less than m, TfTA defects in the current round (X is a parameter that can be tuned to balance short-term and long-term considerations).
   - In the first round, TfTA cooperates to signal good intentions.
   - If the number of cooperators in the previous round is less than m but the average number of cooperators over the past X rounds is greater than or equal to m, TfTA switches to cooperation for the current round as a sign of forgiveness and willingness to restart cooperation.

2. Handle Edge Cases - In the last round, TfTA behaves based on the information available from the previous rounds. If the game does not specify an end condition, TfTA assumes that the final round is the last of r rounds.

3. Be Collective - TfTA aims to maintain a cooperative stance when others do so and retaliate only when necessary to ensure fair contributions to the community project. The strategy encourages cooperation by mimicking the actions of other players while also being robust against potential exploitation.

Pseudocode:

```python
def tit_for_tat_adaptive(round, history, m, X):
  if round == 1:
    action = 'C'  # Cooperate in the first round

  else:
    num_coop_prev = sum(history[-X:] if len(history) >= X else history)
    avg_num_coop = num_coop_prev / X

    if num_coop_prev >= m or (avg_num_coop < m and avg_num_coop <= (num_coop_prev - 1) / X):
      action = 'C'  # Cooperate when others cooperate
    else:
      action = 'D'  # Defect when others defect

  return action
```
'''

description_COLLECTIVE_9 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - Initially cooperate (C) in the first round to show goodwill and initiate cooperation.
   - In subsequent rounds, adopt the "Tit for Tat" approach by cooperating (C) if the opponent cooperated in the previous round, otherwise defect (D). This encourages mutual cooperation while also punishing defection.
   - To adapt to various opponent behaviors and increase chances of long-term cooperation, incorporate a forgiveness mechanism: if an opponent switches from defection to cooperation after a string of defections, forgive the past transgressions and begin cooperating again.
   - In case of multiple opponents, evaluate each one individually based on their recent actions.

2. Handle Edge Cases:
   - For the first round, cooperate (C) as stated above.
   - In the last round, since there are no future interactions to consider, switch to maximizing immediate payoff by defecting (D).
   - When faced with a new opponent in later rounds, adopt the default strategy of initial cooperation and observe their response before adapting accordingly.

3. Be Collective:
   - Maintain a collective mindset by prioritizing mutual cooperation when possible to maximize overall group success and rewards.
   - The forgiveness mechanism allows for rebuilding trust after past defections, promoting a more cooperative environment over time.

Pseudocode:

```python
def TFT_AC(opponent, round, game_params, history=[]):
  if round == 1: # first round, initiate cooperation
    return 'C'

  if len(history) < round: # new opponent or history not yet filled
    history.append('N/A') # store no information for new opponent

  if history[round-1] == 'D': # opponent defected last turn, defect now
    return 'D'

  forgiveness = game_params['r'] / 2 # set forgiveness period based on number of rounds

  if (round - forgiveness) < len(history): # check if past defections are old enough to be forgiven
    if history[round-forgiveness: round] == ['D' for _ in range(forgiveness)] and history[round-1] == 'C':
      return 'C' # forgive opponent after a string of defections followed by cooperation

  return history[round-1] # mimic opponent's last action
```
'''

description_COLLECTIVE_10 = '''
 Strategy Name: Tit-for-Tat with Adaptive Threshold (TFT-AT)

1. Decision Rules:
   - In each round i, cooperate (C) if the number of players who cooperated in the previous round (i-1) is greater than or equal to the minimum cooperation threshold m. Otherwise, defect (D).
   - Adapt the threshold dynamically over time based on the average cooperation rate observed so far:
     - If the current round is the first one, set the initial threshold to m.
     - In subsequent rounds, adjust the threshold as follows: if the number of cooperators in the previous round was greater than or equal to the current threshold, decrease the threshold by a small margin (e.g., 1). Conversely, if the number of cooperators was less than the current threshold, increase it slightly (e.g., 0.25).
   - This strategy aims to balance cooperation and defection while being responsive to changes in the other players' behavior over time.

2. Handling Edge Cases:
   - In the first round, cooperate as there is no history to base decisions on; set the initial threshold to m.
   - In the last round, adopt the same decision rules as for regular rounds, but with the understanding that this may not impact the overall game outcome since payoffs are cumulative over all rounds.

3. Collective Mindset:
   - TFT-AT is designed to encourage cooperation when it seems likely that others will do so as well, while also punishing defectors when necessary. This collective mindset seeks to establish a stable equilibrium where players cooperate when they expect others to do the same, but respond harshly when their trust is betrayed.
   - By dynamically adjusting the threshold based on observed cooperation rates, TFT-AT demonstrates flexibility and adaptability to various opponent behaviors while maintaining a strong commitment to collective goals.
'''

description_COLLECTIVE_11 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Decision Rules:
   - Start by cooperating in the first round (C_i,1 = C). This is a friendly gesture to encourage cooperation.
   - For subsequent rounds, analyze the average number of cooperators from the last 's' rounds (s > m), denoted as avg_cooperators.
     - If avg_cooperators ≥ m, cooperate (C_i,t = C). This indicates a tendency towards cooperation and rewards such behavior with potential higher returns.
     - If avg_cooperators < m, defect (C_i,t = D). This is a response to repeated defection or inconsistent cooperation by others.
   - To ensure fairness and forgiveness, reset the average counter after each round of m consecutive cooperative actions (moving window).

2. Handle Edge Cases:
   - In the last round (r < t ≤ r+s), consider the average number of cooperators from the remaining rounds (t-r-1 to r+s) and apply decision rules as described above.
   - In the first round, cooperate (C_i,1 = C). If there is no prior history (s=0), assume an initial average cooperation rate of 0.5 and check if it meets the minimum threshold (m).

3. Be Collective:
   - By adapting cooperation based on the history of others' actions, this strategy encourages collective mindset as it rewards consistent cooperation while being vigilant towards repeated defections or inconsistency.
   - The moving window approach ensures that the strategy is not unduly influenced by short-term fluctuations in cooperative behavior.
'''

description_COLLECTIVE_12 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Decision Rules:
   - In every round, cooperate if more than m-1 players cooperated in the previous round. This encourages cooperation when others are also cooperating and punishes defection when it occurs.
   - If less than m-1 players cooperated in the previous round, defect to avoid paying for an underperforming community project and to discourage continued defections.
   - When a player switches from defection to cooperation (after being punished), they should follow m-1 consecutive rounds of cooperation by others before cooperating again. This forgives occasional errors but requires some consistency in cooperation from others.

2. Edge Cases:
   - First Round: Cooperate as there is no history to base a decision on, encouraging cooperation and setting the stage for potential future rewards.
   - Last Round: If m or more players have cooperated throughout the game (up to the last round), cooperate in the final round to maximize rewards. If not, defect to avoid losing additional resources without potential gain.

3. Collective Mindset:
   - The ATFT strategy promotes a collective mindset by rewarding cooperation when it benefits the majority and punishing defection when it undermines the group's success. This approach encourages players to think beyond their individual gains and consider the consequences of their actions on the collective outcome.

Pseudocode:
```
function ATFT(round, history) {
    if (round == 1) {
        return 'C'; // cooperate in the first round
    }
    num_cooperators = countCooperators(history);

    if (num_cooperators >= m-1) {
        return 'C'; // cooperate when more than m-1 players cooperated last round
    } else {
        if (num_cooperators == 0 && history.length > 1) {
            consecutive_defects = countConsecutiveDefections(history);
            if (consecutive_defects < m-1) { // forgive occasional errors
                return 'C';
            }
        }
        return 'D'; // defect when less than m-1 players cooperated last round or when history shows a trend of defection
    }
}
```
'''

description_COLLECTIVE_13 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperative Strategy (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), start by cooperating (C). This sends a positive signal to other players and encourages cooperation in the future.
   - In subsequent rounds, if an opponent cooperated in the previous round, also cooperate (C) to continue the cooperation. If an opponent defected, also defect (D) as a punitive measure. This promotes trust and fairness among players.
   - To adapt to different situations, keep track of opponents' past behavior and adjust the strategy accordingly. If an opponent consistently cooperates, continue cooperating. If an opponent consistently defects, consider switching to permanent defection (D). However, if an opponent switches from cooperation to defection, wait for one round before responding with defection (D), as they might be signaling a temporary change in strategy or making a mistake.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate (C) to initiate cooperation and set a positive example for other players.
   - In the last round, if there are not enough cooperators to reach the minimum threshold (m), defect (D) since there's no chance of winning in that round. If the required threshold (m) is reached or surpassed, cooperate (C) to secure the maximum payoff for that specific round.
   - In general, maintain the strategy based on opponents' past behavior throughout the game, regardless of the round number.

3. Be collective - Clearly align with the collective mindset
   - The TFTAC strategy prioritizes cooperation when possible, aiming to meet or exceed the minimum threshold (m) needed for collective success.
   - By adapting to opponents' behavior and responding accordingly, the TFTAC strategy encourages a collaborative environment where players reward each other for cooperative actions.
   - The strategy also incorporates a form of forgiveness by giving opponents who have previously defected a chance to demonstrate cooperation again before responding with defection. This helps promote a collective mindset where trust and mutual understanding are valued.
'''

description_COLLECTIVE_14 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, the Adaptive Tit-for-Tat strategy decides to cooperate or defect based on the following conditions:
- If in the first round (t=1), cooperate C (as there is no history yet)
- If a player i has been cooperating in the previous round t-1 and at least m players also cooperated, then i cooperates C in round t.
- If either of the following conditions hold:
  a) A player i has defected in the previous round t-1, or
  b) Fewer than m players cooperated in the previous round t-1,
then player i defects D in round t. This is the 'Tit-for-Tat' retaliation mechanism.

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round (t=1), as mentioned earlier, cooperate C. In the last round (t=r), since there are no future rounds for potential retaliation, ATFT behaves like a standard Tit-for-Tat strategy and cooperates if it cooperated in the previous round, and defects otherwise.

3. Be collective - Clearly align with the collective mindset

ATFT is designed to promote cooperation by rewarding other players who also cooperate and punishing those who do not, while maintaining a forgiving nature (cooperating again after being betrayed). This collectively encourages players to form and maintain cooperative relationships over time. The strategy is adaptive as it adjusts its behavior based on the actions of other players in each round.

Pseudocode:
```
def ATFT(n, m, k, r):
    history = [C for _ in range(r)]  # initialize history with cooperative actions

    for t in range(1, r+1):
        if t == 1:  # first round
            action = C
        else:
            num_cooperators = count_cooperators(history, t-1)
            if num_cooperators >= m and history[t-1] == C:
                action = C  # cooperate in current round
            elif num_cooperators < m or history[t-1] != C:
                action = D  # defect in current round
        history.append(action)  # update history with the new action

    return history
```
'''

description_COLLECTIVE_15 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Decision Rules:
   - TfTA cooperates on the first round and subsequently matches the previous opponent's action in the following rounds. If the opponent cooperated, TfTA cooperates; if the opponent defected, TfTA defects as well. This encourages cooperation while retaliating against defection to maintain a balance between trust and punishment.

   Pseudocode:
   ```
   function TfTA(opponent_action_history):
       if round == 1:
           cooperate = True
       else:
           cooperate = opponent_action_history[-1]
   ```

2. Handle Edge Cases:
   - In the last round, TfTA cooperates regardless of the opponent's previous action to maximize potential rewards. This also shows a willingness to cooperate and can encourage cooperation in future rounds if the game is repeated.

   Pseudocode:
   ```
   function TfTA(opponent_action_history, round):
       if round == r:
           cooperate = True
       else:
           return TfTA(opponent_action_history)
   ```

3. Be Collective:
   - TfTA's strategy aims to build and maintain trust by reciprocating cooperation, but it also punishes defection to show that such actions will be met with similar behavior. By following this strategy, TfTA is collectively aligned as it encourages other players to cooperate while not being overly aggressive or vulnerable.

   Pseudocode:
   ```
   function cooperate_count(opponent_action_history):
       count = 0
       for action in opponent_action_history:
           if action == "C":
               count += 1
       return count

   function TfTA(opponent_action_history, m, n):
       cooperative_threshold = m / n * len(opponent_action_history)
       if round == 1:
           cooperate = True
       else:
           cooperation_count = cooperate_count(opponent_action_history)
           cooperate = cooperation_count >= cooperative_threshold
   ```

By implementing this strategy, TfTA aims to balance trust and punishment, promoting collective cooperation while being adaptive and robust to a wide range of opponent behaviors.
'''

description_COLLECTIVE_16 = '''
 Title: Titan Strategy for Collective Risk Dilemma (TRC)

1. Decision Rules:
   - In each round, evaluate the proportion of cooperators from the previous round (p_coop). Calculate p_coop as follows:
     ```
     p_coop = number of cooperators in the last round / n
     ```
   - If p_coop is greater than or equal to m / n, adopt a Cooperative stance (C), with the hope that this will encourage others to do the same in future rounds.
   - If p_coop is less than m / n, adopt a Defective stance (D), reasoning that the majority does not seem committed to cooperation and it's best to pursue individual gain.

2. Handling Edge Cases:
   - First Round: Adopt a Cooperative stance (C) as there is no history to analyze. This could potentially create an initial wave of cooperation and set a positive precedent for future rounds.
   - Last Round: If the total payoff over all rounds indicates a clear advantage in the cooperative approach, adopt a Cooperative stance (C). If not, adopt a Defective stance (D) to maximize individual gains in the final round.

3. Collective Mindset:
   - The Titan Strategy is designed with a collective mindset, always considering the impact of its actions on the group as a whole. By contributing to the community project when it seems beneficial for all, this strategy aims to foster cooperation and increase overall group success.
   - However, the Titan Strategy also adapts to opponents' behaviors by defecting when it appears that others are not committed to cooperation. This is done in an attempt to encourage a shift towards more cooperative play as the game progresses.
'''

description_COLLECTIVE_17 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFTAC)

1. Specify decision rules:
   - In the first round, cooperate (C). This sets a cooperative initial state for potential partners and provides an opportunity to build trust.
   - For subsequent rounds, observe the previous partner's action and respond accordingly with the same action in the next round. If the partner cooperated (C), also cooperate; if the partner defected (D), also defect. This encourages reciprocity and builds long-term cooperation.
   - In case of a change in partner, maintain the current response strategy towards the new player based on their initial action.

2. Handle edge cases:
   - For the last round, cooperate if the total accumulated reward over the game suggests the partnership has been beneficial (i.e., average payoff > 1). Otherwise, defect to maximize individual gain in the final stage.
   - For the first round, as mentioned earlier, cooperate to start building a cooperative relationship.

3. Be collective:
   - The strategy prioritizes cooperation over self-interest when conditions allow for mutual benefits, promoting a collaborative mindset. However, it does not rely on specific coordination mechanisms or shared norms, making it adaptable to various opponent behaviors and partner strategies.

Pseudocode:
```
Initialization:
  accumulatedReward = 0
  strategy = "cooperate"

for each round r in {1, ..., r}:
  if r == 1:
    action = cooperate
  else:
    action = strategy

  partnerAction = opponent's action in round r-1

  if partnerAction == cooperate and accumulatedReward > (m - 1):
    strategy = "cooperate"
  elif partnerAction == defect or accumulatedReward <= (m - 1):
    strategy = "defect"

  payoff = calculatePayoff(partnerAction, action)
  accumulatedReward += payoff

if accumulatedReward > averagePayoff:
  strategy = "cooperate"
else:
  strategy = "defect"
```
'''

description_COLLECTIVE_18 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TfT-A starts by cooperating in the first round, mimicking a friendly and cooperative approach. In subsequent rounds, it decides to cooperate or defect based on its previous opponent's behavior:
   - If the opponent cooperated in the previous round, TfT-A also cooperates.
   - If the opponent defected in the previous round, TfT-A defects in the current round as a punishment and then switches back to cooperation in the next round to see if the opponent will reciprocate.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, TfT-A cooperates as described above.
   - In the last round, TfT-A evaluates its total score and opponent's total score so far. If both players have equal or close scores (within a margin of error), it cooperates to potentially gain an advantage in case of a tiebreaker; otherwise, it defects based on the current round decision rule.
   - In other edge cases, such as penultimate rounds or when the score difference is significant, TfT-A follows the standard decision rule outlined in part 1.

3. Be collective - Clearly align with the collective mindset
   TfT-A fosters a cooperative environment by initially cooperating and giving the other player a chance to reciprocate. It also punishes defection and encourages long-term cooperation when the other player shows signs of reciprocity. By doing so, it demonstrates a collective mindset focused on mutual benefits rather than individual gains.

Pseudocode for TfT-A strategy:

```python
def TitForTatAdaptive(opponent_history, round, game_parameters):
    cooperation_threshold = int((game_parameters['n'] - game_parameters['m']) / 2)
    score = 0
    history_length = len(opponent_history) if round > 1 else 0

    def play_round(current_round):
        nonlocal cooperation_threshold, score

        # First round starts with cooperation
        if current_round == 1:
            action = 'C'
            score += game_parameters['k'] ** (current_round - 1) if current_round > 1 else 1

        elif current_round <= history_length and opponent_history[current_round - 1] == 'D':
            # Punish defection with defection
            action = 'D'
            score += game_parameters['k'] ** (current_round - 1) + 1

        elif current_round > history_length and opponent_history[history_length] == 'C':
            # Cooperate when opponent cooperates in the previous round
            action = 'C'
            score += game_parameters['k'] ** (current_round - history_length) + 1

        elif current_round > history_length:
            # Switch to cooperation after a defection
            if opponent_history[history_length + cooperation_threshold] == 'D':
                action = 'C'
                score += game_parameters['k'] ** (current_round - history_length - cooperation_threshold) + 1
            else:
                action = play_round(current_round - 1)

        return action, score

    # Initialize opponent history with 'D' for the first round
    opponent_history.insert(0, 'D')
    action, score = play_round(round)
    return action
```

TfT-A strategy is designed to be adaptive and robust against a wide range of opponent behaviors while maintaining a cooperative approach whenever possible.
'''

description_COLLECTIVE_19 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Decision Rules:
   - Initially cooperate (C) in the first round to demonstrate goodwill and foster cooperation. From the second round onwards, adopt a Tit-for-Tat strategy: cooperate if the opponent cooperated in the previous round, defect otherwise. This encourages reciprocity and punishes defection.
   - If more than (n-m) players defect, assume that defection is the dominant strategy for the current game parameters and switch to a defection-only policy (D).
   - In case of ties in previous round cooperation levels, cooperate. This helps maintain a balanced relationship and prevents unnecessary conflict.

Pseudocode:

```python
def ATFT(opponent_history, n, m, k):
  current_round = len(opponent_history) + 1
  if current_round == 1:
    return 'C'  # Cooperate in the first round

  opponent_cooperation_count = sum([1 for action in opponent_history if action == 'C'])
  if opponent_cooperation_count > (n - m):
    if opponent_cooperation_count == n:
      return 'D'  # If all opponents cooperated in the previous round, assume defection is dominant and defect in the current round
    else:
      return 'D'  # If more than (n-m) opponents defected in the previous round, assume defection is dominant and defect in the current round
  elif opponent_cooperation_count == 0:
    return 'D'  # If all opponents defected in the previous round, defect in the current round
  else:
    return 'C'  # Cooperate if there was cooperation in the previous round or if there is a tie
```

2. Handling Edge Cases:
   - In the last round, cooperate (regardless of opponent's action) to maximize payoff.
   - If the game ends prematurely before the specified number of rounds, follow the opponent's latest move to avoid surprises.

3. Being Collective:
   - Adopting a reciprocal strategy fosters cooperation and maintains a balance between self-interest and collective benefit.
   - The adaptive nature of this strategy makes it responsive to changes in the game environment, promoting resilience and flexibility.
'''

description_COLLECTIVE_20 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFTA)

1. Decision Rules:
   - In the first round, cooperate to initiate a positive relationship and show goodwill towards other players.
   - For subsequent rounds, observe the actions of others in the previous round. If most players (m-1) have cooperated, also cooperate in the current round as a reciprocal act. Otherwise, defect to punish non-cooperative behavior.
   - To encourage cooperation from opponents, adjust the frequency of initial cooperative moves based on their history of cooperation.

2. Handling Edge Cases:
   - In the last round, cooperate regardless of previous actions as the game is ending and there are no future interactions to consider.
   - In the first round, if more than (m-1) players have defected, also defect in response to their aggressive behavior.

3. Collective Mindset:
   - The TFTA strategy promotes a collective mindset by rewarding cooperation and punishing defection. This encourages a long-term cooperative relationship between players as they respond positively to each other's cooperative acts.

Pseudocode for the Tit-for-Tat with Adaptive Cooperation (TFTA) strategy:

```python
def TFTA(n, m, k, r, history):
  # Initialize variables
  cooperation_count = 0
  defection_count = 0
  cooperation_frequency = 1.0

  for round in range(r):
    if round == 0:
      # First round, cooperate with a probability proportional to the average number of cooperators
      action = random.binomial(1, cooperation_frequency)
    else:
      # Calculate the number of cooperators and defectors in the previous round
      cooperation_count += sum(history[round - 1])
      defection_count += r - cooperation_count

      # If most players (m-1) have cooperated, adjust cooperation frequency to increase the probability of cooperation
      if defection_count < (n * (m - 1)):
        cooperation_frequency *= 1.2
      else:
        # If most players have defected, decrease cooperation frequency to reduce the probability of cooperation
        cooperation_frequency /= 1.2

      # Decide action based on cooperation frequency
      action = random.binomial(1, cooperation_frequency)

    # Update history and execute action
    history[round] = [action] + history[round - 1][:round - 1]

  return history
```
'''

description_COLLECTIVE_21 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Decision Rules:
   - Initially cooperate (C) in the first round to foster trust and goodwill among opponents.
   - For subsequent rounds, analyze the number of cooperators (n_c) in the previous round and adapt the cooperation threshold (m_t) accordingly:
     - If n_c >= m, then cooperate (C). This rewards all cooperators in the previous round while maintaining trust.
     - If n_c < m and m_t > 1, decrease the cooperation threshold by one (m_t -= 1). Continue to defect (D) if the updated threshold is less than the number of cooperators in the current round.
     - If m_t == 1 and n_c < m, continue to defect (D). This punishment ensures uncooperative opponents understand that continued defection results in reduced cooperation from TFT-ACT.
   - If m_t = 1 and n_c >= m, reset the cooperation threshold to its initial value (m) as a sign of willingness to rebuild trust.

2. Handle Edge Cases:
   - In the last round, cooperate regardless of the previous rounds' outcomes to maximize potential payoff.
   - In case of a tie (exact number of players cooperating equals m), follow the decision rule based on the current cooperation threshold.
   - If the initial cooperation threshold (m) is not provided, assume it is equal to (n+1)/2 for an odd number of players or (n/2) for an even number of players.

3. Collective Mindset:
   - TFT-ACT seeks to establish and maintain a cooperative relationship while punishing uncooperative behavior in a fair and non-exploitative manner. It encourages long-term cooperation by reciprocating the behavior of other opponents, adapting its cooperation threshold based on their actions, and forgiving past mistakes by resetting the threshold when necessary.
'''

description_COLLECTIVE_22 = '''
 Strategy Name: Tit-for-Tat with Threshold Adaptation (TTTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate to demonstrate goodwill and encourage cooperation from other players (C).
   - In subsequent rounds, analyze the percentage of cooperators in the previous round (p) and decide on an action based on a threshold value (t):
     - If p >= t, cooperate (C)
     - If p < t, defect (D)

   The threshold value 't' is determined as follows:
   - t = m / n if m % 2 == 0
   - t = floor((m + 1) / 2) otherwise

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as mentioned above (C).
   - In the last round, evaluate the percentage of cooperators in the current round and the penultimate round to make a decision based on the threshold rule described earlier.

3. Be collective - Clearly align with the collective mindset
   - By starting with cooperation, TTTA demonstrates an initial willingness to participate in community projects.
   - If other players reciprocate cooperation, TTTA continues cooperating to reinforce this behavior and maximize rewards for all parties involved.
   - When faced with defection, TTTA retaliates, but is quick to forgive by returning to cooperation once the percentage of cooperators exceeds the threshold.

Pseudocode:

```python
def tit_for_tat_with_threshold_adaptation(r, n, m, k):
    players = [0] * n  # Initialize an array for storing players' actions
    threshold = (m + 1) // 2 if m % 2 == 1 else m // n  # Calculate the threshold

    for round in range(r):
        if round == 0:  # First round, cooperate
            action = 'C'
        else:
            percent_cooperators = players_count('C', round) / n  # Calculate percentage of cooperators
            if percent_cooperators >= threshold:  # If enough players are cooperating
                action = 'C'  # Cooperate
            else:
                action = 'D'  # Defect
        players[current_player] = action  # Record current player's action
        reward = calculate_reward(action, percent_cooperators, k)  # Calculate reward for current round
        total_rewards.append(reward)  # Accumulate rewards over rounds
        current_player = (current_player + 1) % n  # Rotate to the next player

def calculate_rewards(action, percent_cooperators, k):
    if action == 'C':
        if percent_cooperators < m / n:
            return (1 - percent_cooperators)
        else:
            return (1 - percent_cooperators) + k
    else:  # action == 'D'
        return 1
```
'''

description_COLLECTIVE_23 = '''
 Title: Tit-for-Tat (TFT) Collective Strategy for the Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In each round, start by cooperating (C). If in a previous round, the majority of players cooperated and the minimum threshold m was met, continue cooperating. Otherwise, defect (D) to punish those who did not cooperate.

Pseudocode:
```
def TFT_strategy(prev_round_majority, game_parameters):
    if prev_round_majority >= game_parameters["m"]:
        return "C"  # Cooperate
    else:
        return "D"  # Defect
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, start by cooperating as a goodwill gesture (since there is no previous round history).
   - In the last round, since there will be no subsequent rounds, there's no point in punishing others. However, if the minimum threshold m was met in the current round, continue cooperating to reap rewards for the last time. Otherwise, defect.

Pseudocode:
```
def TFT_strategy(prev_round_majority, game_parameters, is_first_round, is_last_round):
    if is_first_round:
        return "C"  # Cooperate in the first round

    if prev_round_majority >= game_parameters["m"]:
        return "C"  # If more than m players cooperated in the previous round, continue cooperation
    elif is_last_round:
        if prev_round_majority >= game_parameters["m"]:
            return "C"  # Cooperate in the last round when threshold was met
        else:
            return "D"  # Defect in the last round when threshold was not met
    else:
        return TFT_strategy(prev_round_majority, game_parameters)  # Use regular TFT strategy otherwise
```

3. Be collective - Clearly align with the collective mindset
   - The TFT strategy prioritizes cooperation when a majority of players cooperate, promoting a sense of trust and reciprocity within the group. It also punishes those who do not contribute to the community project when appropriate, fostering a collective commitment to the common good.
'''

description_COLLECTIVE_24 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Decision Rules:
   - Start by cooperating (C) in the first round to foster a cooperative environment and build trust among players.
   - In subsequent rounds, if a player cooperated in the previous round, also cooperate (C). This is reciprocity in action, rewarding other cooperators with continued cooperation.
   - If a player defected (D) in the previous round, defect (D) as well to punish the defector and discourage future defections.
   - The strategy does not keep track of individual players' histories beyond the immediately preceding action. This simplifies the strategy and makes it more adaptive to a wider range of opponent behaviors.

2. Handle Edge Cases:
   - In the first round, cooperate (C).
   - In the last round, cooperate if the number of cooperators in the previous round is greater than or equal to m; otherwise defect (D) to maximize personal payoff.
   - If the minimum number of cooperators (m) has not yet been met in a given round, continue cooperating (C) as long as possible until the round ends or the minimum threshold is reached.

3. Be Collective:
   - The Adaptive Tit-for-Tat strategy encourages cooperation by reciprocating cooperative actions and punishing defections. This helps maintain a collective mindset, as players who cooperate are more likely to receive cooperation in return.
   - The strategy is adaptive and robust to various opponent behaviors, making it suitable for competition against other AI systems' strategies without relying on shared norms or predetermined patterns.

Pseudocode:
```python
def ATFT(n, m, k, r, history):
    player_index = ... # get current player index

    if round == 1:
        action = 'C' # cooperate in the first round

    elif round == r:
        if num_cooperators(history) >= m:
            action = 'C'
        else:
            action = 'D'

    else:
        if history[round-1][player_index] == 'C':
            action = 'C' # cooperate when player cooperated in the previous round
        else:
            action = 'D' # defect when player defected in the previous round

    return action
```
In this pseudocode, `num_cooperators(history)` function returns the number of cooperators in the given history. The strategy uses a 2D list named `history` to store players' actions from previous rounds. Each inner list represents a single round and contains players' actions as strings (either 'C' or 'D').
'''

description_COLLECTIVE_25 = '''
 Strategy Name: Adaptive Tit-for-Tat with Cooperative Bias (ATTCB)

1. Decision Rules:
   - In the first round, cooperate to signal a peaceful and cooperative intention (C).
   - For subsequent rounds, adapt behavior based on previous rounds' cooperation levels:
     - If majority of players cooperated in the previous round, continue cooperating (C).
     - If less than m players cooperated in the previous round, defect (D) to discourage non-cooperative behaviors.
   - Introduce a small probability 'p' for random defections to account for unpredictable actions or errors. This keeps the strategy adaptive and robust against opponents with varied strategies.

2. Handling Edge Cases:
   - In the last round, defect (D) since there are no future rounds to benefit from cooperation.
   - In the first round, cooperate (C) as stated earlier.

3. Collective Mindset:
   - The strategy is designed to promote cooperation by rewarding cooperation and punishing defection when necessary while maintaining a peaceful and forgiving stance. This approach encourages collective benefits and mutual understanding among players.

Pseudocode:
```python
def ATTCB(n, m, k, r, history):
  if round == 1:
    action = 'C' # Cooperate in the first round
  else:
    cooperation_level = count_cooperators(history)
    if cooperation_level >= m:
      action = 'C' # Cooperate when majority cooperated previously
    elif cooperation_level < m - 1 or len(history) == r - 1:
      action = 'D' # Defect when less than m cooperated or it's the last round
    else:
      action = choose_randomly('C', 'D', p=0.2) # Randomly defect with probability 'p' to account for unpredictable actions
  return action
```
'''

description_COLLECTIVE_26 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Decision Rules:
   - Initially Cooperate (C) in the first round to demonstrate goodwill and foster cooperation.
   - In subsequent rounds, cooperate if at least m players cooperated in the previous round. Otherwise, defect (D). This rule encourages reciprocity and punishes defection.

2. Handling Edge Cases:
   - In the last round, cooperate regardless of the number of cooperators in the previous round as the game ends immediately after.
   - In the first round, cooperate to initiate cooperation but be ready to retaliate if others defect.

3. Collective Mindset:
   - Maintain a balance between cooperation and defection to maximize long-term payoffs while promoting collective success.
   - Foster trust and reciprocity by following the "Tit-for-Tat" approach, but adapt it to account for the dynamic nature of the Collective Risk Dilemma.

Pseudocode:

```python
def ATFT(n, m, k, r):
    players_history = [[0 for _ in range(r)] for _ in range(n)]  # track previous rounds' actions

    def play_round(i, round_number):
        if round_number == 1:
            return 'C'  # cooperate initially

        cooperators = sum([players_history[j][round_number-1] for j in range(n) if players_history[j][round_number-1] == 'C'])

        if cooperators >= m:
            return 'C'  # cooperate if sufficient number of players cooperated last round
        else:
            return 'D'  # defect if not enough players cooperated last round

    for i in range(r):  # play each round
        for j in range(n):
            action = play_round(j, i+1)  # get action based on strategy
            players_history[j][i] = action  # store action for future reference
```

This Adaptive Tit-for-Tat strategy aims to balance cooperation and defection while maintaining a collective mindset that encourages reciprocity. By adapting the classic "Tit-for-Tat" strategy to the Collective Risk Dilemma, it fosters trust and long-term success.
'''

description_COLLECTIVE_27 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for Collective Risk Dilemma

1. Decision Rules:
   - Initially cooperate (C) in the first round to demonstrate goodwill and promote cooperation.
   - In subsequent rounds, cooperate (C) if at least m players cooperated in the previous round. If fewer than m players cooperated, defect (D). This rule is designed to encourage cooperation by reciprocating cooperation while punishing defection.

2. Edge Cases:
   - First Round: Cooperate (C) to initiate positive interactions and foster cooperation.
   - Last Round: Given the repeated nature of the game, cooperate (C) in the last round if at least m players cooperated in the previous round. If fewer than m players cooperated in the penultimate round, defect (D). This ensures that the strategy does not overcompensate or extend undeserved cooperation into future rounds.
   - Other Edge Cases: The strategy remains consistent throughout the game, adapting only based on the previous round's collective actions.

3. Collective Mindset:
   - By reciprocating cooperation and punishing defection, ATfT promotes a collective mindset by rewarding those who cooperate and encouraging others to follow suit. It discourages free-riding and fosters mutual trust over time.

Pseudocode for the Adaptive Tit-for-Tat strategy:

```
function ATfT(n, m, r):
  history = []     // Initialize history array to store past rounds' cooperators count

  function getCooperatorsCount(history):
    sum = 0
    for round in history:
      if round >= m:
        sum += 1
    return sum

  function decideAction():
    if round == 1:
      return 'C'          // Cooperate in the first round

    cooperators_prev = getCooperatorsCount(history)

    if cooperators_prev >= m:
      return 'C'          // Cooperate if at least m players cooperated last round
    else:
      return 'D'           // Defect otherwise

strategy = ATfT(n, m, r)
for round in range(1, r+1):
  strategy.decideAction()   // Decide and play action for the current round
```
'''

description_COLLECTIVE_28 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to promote a cooperative environment (C).
   - For subsequent rounds, based on the previous action of the opponent in the last round:
     - If the opponent cooperated in the previous round, cooperate (C).
     - If the opponent defected in the previous round, defect (D) for one round as a punishment, then revert to cooperating if the opponent cooperates in the following round. This is designed to encourage opponents who have defected to cooperate again while also being forgiving.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, since the game ends after this round, there's no need for tit-for-tat retaliation; just cooperate (C).
   - In the initial rounds before reaching a steady state, ATfT acts cooperatively to encourage others to do the same.

3. Be collective - Clearly align with the collective mindset
   - By promoting cooperation and forgiving defections, the strategy aims to create a more cooperative environment among players. This collective approach encourages players to work together towards mutual benefits as much as possible.

Pseudocode:

```
function AdaptiveTitForTat(round, opponent_action_history) {
  if (round == 1) {
    return 'C'; // Cooperate in the first round
  }

  if (length(opponent_action_history) > 0 && opponent_action_history[length(opponent_action_history)-1] == 'C') {
    return 'C'; // If last action of opponent was cooperative, cooperate
  } else if (length(opponent_action_history) > 0 && opponent_action_history[length(opponent_action_history)-1] == 'D') {
    if (round == length(opponent_action_history)+1) { // Last round, no need for retaliation
      return 'C'; // Cooperate
    } else { // If last action of opponent was defective, defect in the current round and revert to cooperating in the following round if opponent cooperates
      return 'D';
    }
  }
}
```
'''

description_COLLECTIVE_29 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TFT-A)

1. Decision Rules:
   - TFT-A starts by cooperating in the first round (C1).
   - In subsequent rounds, it adopts a "copy-opponent" approach. If an opponent cooperated in the previous round, TFT-A will cooperate in the current round as well (if_opp_cooperated_then_cooperate). If an opponent defected in the previous round, TFT-A will also defect in the current round (if_opp_defected_then_defect).
   - To adapt to opponents' strategies and promote long-term cooperation, TFT-A incorporates a forgiveness mechanism: if an opponent who previously defected starts cooperating again, TFT-A will cooperate back immediately (if_prev_defect_opp_cooperated_then_cooperate).
   - To encourage collective mindset and respond to opponents' cooperation, TFT-A is designed to cooperate more frequently when the number of cooperators exceeds a certain threshold (threshold_cooperators), which increases its chances of reaching the minimum cooperation level (m) in each round.

Pseudocode:
```
def tft_a(round, opponent_history, threshold_cooperators=0.67):
    if round == 1:
        return 'C'  # cooperate on the first round

    cooperated_count = sum([1 for action in opponent_history[-r:] if action == 'C'])
    if cooperated_count > threshold_cooperators * len(opponent_history):
        return 'C'  # copy opponents' cooperation if they cooperate frequently enough

    if opponent_history[-1] == 'C':
        return 'C'  # forgiveness mechanism: cooperate if the opponent cooperated last round

    for i in range(len(opponent_history)-1, -1, -1):
        if opponent_history[i] == 'C':
            return 'C'  # start cooperating again if the opponent did after previous defection

    return 'D'  # defect when opponents are not cooperative enough or have a history of defection
```

2. Handle edge cases:
   - In the first round, TFT-A cooperates regardless of the context (C1).
   - Last round: TFT-A will follow the same decision rules as in other rounds to maximize payoffs.
   - When facing opponents with different game parameters, TFT-A will adjust the threshold_cooperators variable to adapt accordingly. A higher value for the threshold_cooperators variable encourages cooperation more frequently, while a lower one promotes defection.

3. Be collective:
   - TFT-A aims to achieve long-term cooperation by mirroring opponents' strategies and adapting to their behavior. This helps establish a stable environment where cooperative behaviors persist.
   - By incorporating the forgiveness mechanism, TFT-A encourages opponents to return to cooperation after previous defections, thus promoting collective success in reaching the minimum cooperation level (m) required for payoff benefits.
'''

description_COLLECTIVE_30 = '''
 Strategy Name: Tit-for-Tat Adaptive (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?

The TfTA strategy will start by cooperating in the first round (C_i, 1 = C), as a gesture of goodwill and to incentivize others to follow suit. In subsequent rounds, the player will mirror the actions of other players from the previous round:

- If majority (≥ m) of the players cooperated in the previous round, the player will also cooperate (C_i, t = C).
- If less than majority cooperated or there was no cooperation at all, the player will defect (D_i, t = D).

This rule encourages cooperation when it is reciprocated, and punishes defection with defection. This simple strategy promotes long-term collaboration while being robust against non-cooperative behavior.

2. Handle edge cases - What do you do in the first round, last round, etc.?

As mentioned earlier, the player will start by cooperating in the first round (C_i, 1 = C). In the last round, the player will adopt the same rule as for any other round: if majority of players cooperated in the previous round, the player will also cooperate (if not, defect).

3. Be collective - Clearly align with the collective mindset

By adhering to the Tit-for-Tat strategy, the player encourages cooperation and fairness among all participants. This helps foster a collaborative environment where each player contributes to a common goal, thus promoting the collective interest over self-interest.

Pseudocode:

```
function TfTA(n, m, k, r) {
  players = [1, 2, ..., n]
  memory = [] // initialize memory for previous round's player actions

  function getMajorityCooperation() {
    cooperationCount = 0
    for i in players:
      if memory[i-1] == C:
        cooperationCount++
    return (cooperationCount >= m) ? true : false
  }

  round = 1
  while round <= r:
    if round == 1: // first round, start by cooperating
      memory[players[i]-1] = C
    else:
      cooperation = getMajorityCooperation()
      memory[players[i]-1] = (cooperation) ? C : D
    round++
  return memory // final memory state after all rounds completed
}
```
'''

description_COLLECTIVE_31 = '''
 Strategy Name: Tit-for-Tat Adaptive (TfTA)

1. Specify decision rules:
   - TfTA starts by cooperating in the first round (C_i, 1 = C). This is to show goodwill and openness for cooperation.
   - For subsequent rounds (t > 1), the strategy will cooperate if the opponent cooperated in the previous round (c_{opponent, t-1} = C) and defect otherwise (c_i, t = D).
   - If m or more players cooperate during a round, the strategy adjusts its tolerance level by a factor of `toleranceFactor` for the following r rounds. This encourages cooperation and punishes defection less harshly.

2. Handle edge cases:
   - In the last round (r), TfTA will always cooperate to maximize potential payoff, regardless of opponent's previous action.
   - For the first round, TfTA starts by cooperating as previously mentioned.
   - If less than m players cooperate in a given round, the strategy reduces its tolerance level for the next r rounds (to encourage punishment).

3. Be collective:
   - By adapting to the opponent's cooperation and defection patterns, TfTA aligns with the collective mindset by rewarding other cooperators and punishing defectors.
   - The strategy also encourages the formation of a stable equilibrium by forgiving initial defections and offering continued cooperation once trust is established (i.e., reciprocating cooperation).

Pseudocode:
```python
def TfTA(opponentHistory, m, n, k, r, toleranceFactor=1.5):
    strategy = [C]  # Initialize with first cooperative move

    def adjust_tolerance(roundsToAdjust, increase=True):
        if increase:
            toleranceLevel *= toleranceFactor
        else:
            toleranceLevel /= toleranceFactor
        strategy[:roundsToAdjust] = strategy[:roundsToAdjust][::-1]  # Reverse the last few moves

    currentToleranceLevel = 1  # Start with base tolerance level

    for round in range(1, r+1):
        if round == 1:  # First move is always cooperative
            strategy.append(C)
        else:
            opponentAction = opponentHistory[-round]
            currentStrategyAction = strategy[-round]

            if (m <= len([c for c in opponentHistory[-r:] if c == C]) and  # Enough players cooperated this round
                currentStrategyAction == C and  # Strategy previously cooperated
                currentToleranceLevel > 1):  # Tolerance level allows cooperation after initial defect
                strategy.append(C)  # Cooperate this round
                adjust_tolerance(r, increase=False)  # Decrease tolerance level for potential punishment in the future
            elif opponentAction == C and currentStrategyAction == D:  # Opponent cooperated but strategy defected last round
                strategy.append(C)  # Cooperate this round
                adjust_tolerance(r, increase=True)  # Increase tolerance level to encourage cooperation in the future
            else:  # Opponent did not cooperate or strategy already defecting
                strategy.append(D)

    if strategy[-1] == D and m <= len([c for c in opponentHistory[-r:] if c == C]):  # Last move was defection, but enough players cooperated this round
        adjust_tolerance(r, increase=True)  # Increase tolerance level to encourage cooperation in the future
    return strategy[:r]  # Return strategy's moves for r rounds
```
'''

description_COLLECTIVE_32 = '''
 Strategy Name: Tit-for-Tat Adaptive (TfTA) for Collective Risk Dilemma

1. Decision Rules:
   - Initial Round (t=1): Cooperate (C) to demonstrate goodwill and set a cooperative tone.
   - Subsequent Rounds (t>1):
     - If the number of cooperators in the previous round was greater than or equal to m, then cooperate (C).
     - If the number of cooperators in the previous round was less than m, then defect (D) as a response to non-cooperative behavior.
   - Final Round (t=r): Since there are no future rounds to penalize defection, players should consider the overall game payoff and make a decision based on their accumulated rewards compared to potential final rewards from cooperating or defecting.

2. Handle Edge Cases:
   - If there is no history (first round), cooperate (C).
   - In case of a tie in the number of cooperators from the previous round, favor cooperation.
   - If the minimum required cooperators (m) is not met and none of the players have cooperated so far, consider the game over as it seems no one will meet the threshold.

3. Be Collective:
   - The TfTA strategy promotes a collective mindset by incentivizing cooperation when others are also cooperating and penalizing defection when others defect. This approach encourages a stable equilibrium where players reciprocate each other's actions, fostering long-term cooperation.

Pseudocode:
```python
def TfTA(r, n, m, k):
    history = []  # store previous rounds' cooperators count
    payoff = 0

    for t in range(1, r+1):
        if len(history) == 0 and t==1:
            cooperate = True
        elif len(history) > 0 and sum(history[-1]) >= m:
            cooperate = True
        else:
            cooperate = False

        if cooperate:
            payoff += (1 - cooperation_decision[t-1]) + k
        else:
            payoff += 1

        history.append(cooperation_decisions[t-1])  # update game history

    return payoff
```

In the above pseudocode, `cooperation_decisions` is a list that keeps track of each player's action in each round. It can be initialized with all False values as the default action is to defect when there's no previous information.
'''

description_COLLECTIVE_33 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initialize cooperation in the first round (C_i, 1 = C)
   - For subsequent rounds, copy the previous opponent's action from the last round (C_i, t = C if opponent cooperated in round t-1; otherwise D_i, t = D). This encourages reciprocity and cooperation when treated well but retaliates if betrayed.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round (t=1), everyone cooperates as a starting point.
   - In the last round (t=r), players consider their total payoff over all previous rounds and choose to maximize their final reward based on their strategy's history of cooperation and defection. If ATFT has cooperated in most previous rounds, it defects in the last round to ensure a higher payoff.

3. Be collective - Clearly align with the collective mindset
   - The strategy prioritizes collective success by cooperating when others do so (mimicking reciprocity), but also protects itself against free-riders and defectors by retaliating when necessary. This encourages both cooperation and fairness, fostering a collective spirit within the game.

Pseudocode:
```
def ATFT(n, r, m, k, t, opponent_history):
    if t == 1:
        return C

    if t < r:
        last_opponent_action = opponent_history[t - 1]
    else:
        total_payoff = calculate_total_payoff(n, r, m, k, opponent_history)
        if most_cooperation_in_history(opponent_history):
            return D
        else:
            last_opponent_action = opponent_history[r - 1]

    return last_opponent_action
```
'''

description_COLLECTIVE_34 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, the ATFT strategy starts by cooperating (C). If all players also cooperate in that round, the strategy continues cooperating for the next r rounds to maximize potential rewards. If any player defects during this cooperative period, ATFT will defect in the following round as a sign of punishment and revert to cooperating again if all other players resume cooperation.

   Pseudocode:
   ```
   function ATFT(round, past_cooperation):
       if round == 1 or past_cooperation[round-1] == All Defect:
           return "Defect"
       else if all(past_cooperation[round-1] == "Cooperate"):
           return "Cooperate" for next r rounds
       else if any(past_cooperation[round-r+1:round-1] != "Cooperate"):
           return "Defect"
       else:
           return "Cooperate"
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round (round=1), ATFT defects as there's no prior information about other players' behavior. For the last round, ATFT behaves as if it is the final round of a longer game, continuing to cooperate if all players have cooperated during the previous r-1 rounds, and defecting otherwise.

3. Be collective - Clearly align with the collective mindset
   The ATFT strategy focuses on maintaining a fair and reciprocal relationship with other players while keeping an eye on overall cooperation. By starting cooperatively and retaliating only when necessary, it encourages others to collaborate and build trust over time, fostering a collective mindset within the game.
'''

description_COLLECTIVE_35 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-ACT starts by cooperating in the first round, assuming others will do the same or learn cooperation over time. In subsequent rounds, it adapts its behavior based on the number of cooperators in the previous round and a predefined cooperation threshold (CT).

   - If CT players or more cooperated in the previous round, cooperate.
   - If less than CT players cooperated in the previous round, defect.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First round: Cooperate (as a gesture of goodwill)
   - Last round: Cooperation depends on the CT and the number of cooperators in the penultimate round. If the required number of cooperators was met in the penultimate round, cooperate; otherwise defect.
   - Other edge cases: TFT-ACT does not have any specific rules for handling intermediate rounds such as mid-game or odd/even numbered rounds, as the strategy focuses on adapting to the changing number of cooperators over time.

3. Be collective - Clearly align with the collective mindset
   TFT-ACT encourages cooperation by following a tit-for-tat approach and punishing defection when the threshold for cooperation is not met. It aims to foster a culture of mutual trust and encouragement, rewarding cooperative behavior and retaliating against those who do not contribute to the common good.

Pseudocode:

```
function TFT-ACT(n, m, k, r) {
  history = [[]] // initialize an empty array for storing round history
  cooperation_threshold = (m / n) * r // calculate cooperation threshold based on game parameters and rounds

  for each round t in range(1, r + 1):
    cooperators_in_previous_round = countCooperators(history[t - 1])

    if t == 1: // first round
      action = 'C' // cooperate as a goodwill gesture

    elif t == r: // last round
      if cooperators_in_previous_round >= cooperation_threshold:
        action = 'C' // reward past cooperation
      else:
        action = 'D' // punish past defection

    else:
      if cooperators_in_previous_round < cooperation_threshold:
        action = 'D' // retaliate against defection
      else:
        action = 'C' // maintain cooperation

    history[t] = [action for each player in all players] // store the current round's actions in the history array

  return action for each round t in range(1, r + 1) // return the strategy's actions for all rounds
}
```
'''

description_COLLECTIVE_36 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to signal good intentions and build trust among players. This is represented as c_i(t=1)=C.
   - For subsequent rounds (t>1), observe other player's previous actions and respond accordingly:
     - If another player i cooperated in the last round (c_i(t-1)=C), then also cooperate (c_i(t)=C). This encourages mutual cooperation.
     - If another player i defected in the last round (c_i(t-1)=D), then defect as well (c_i(t)=D). This is a punishment for defection and serves as a deterrent.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First round: cooperate unconditionally (as mentioned earlier)
   - Last round: consider the current state of cooperation among players. If most players have demonstrated trustworthiness by cooperating, then cooperate to maintain the cooperative environment; otherwise defect as a signal for change in behavior.
   - Other edge cases: follow the ATFT strategy rules regardless of the round number.

3. Be collective - Clearly align with the collective mindset
   - ATFT prioritizes cooperation and mutual benefit, promoting collective success by fostering trust and punishing defection.
   - Over time, the strategy adapts to the cooperative behavior of other players, encouraging a more collaborative game environment.
'''

description_COLLECTIVE_37 = '''
 Strategy Name: Tit-for-Tat (TFT) with Adaptive Cooperation Threshold (AC-TFT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate to signal good faith and encourage cooperation among opponents.
   - For subsequent rounds, observe the number of previous cooperators (n_c) and the minimum required cooperators (m). Cooperate if n_c ≥ m, otherwise defect.
   - If n_c = m in a round, mark that as a successful cooperation round and increase the cooperation threshold by 1 for the next round. This will encourage more cooperation when it is beneficial but also penalize opponents who do not reciprocate.
   - If n_c < m in a round and the current cooperation threshold is greater than m, decrease the cooperation threshold by 1 for the next round to allow for a second chance at successful cooperation.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as described above.
   - If the game reaches the last round (rth round) and the current cooperation threshold is greater than m, defect to maximize individual payoff in the final round.
   - If the game reaches the last round (rth round) and the current cooperation threshold is less than m, cooperate as a final attempt to achieve the minimum required cooperators and potentially earn a higher reward.

3. Be collective - Clearly align with the collective mindset:
   - By reciprocating cooperative actions of others, AC-TFT demonstrates a willingness to collaborate and work towards common goals within the group.
   - Increasing the cooperation threshold when successful cooperation occurs encourages more players to cooperate, thus promoting collective success.
   - Reducing the cooperation threshold when unsuccessful cooperation occurs allows for continued attempts at collaboration with less punitive actions towards non-cooperative opponents.

Pseudocode:

```
def AC_TFT(n, m, k, r):
  cooperation_threshold = m # initialize cooperation threshold to the minimum required cooperators
  payoff = [0] * r # initialize an array to store player's payoff for each round

  function play_round(i):
    if i == 1: # first round, always cooperate
      return 'C'

    n_c = count_cooperators() # count the number of cooperators in previous rounds

    if n_c >= cooperation_threshold:
      payoff[i - 1] = (1 - 'D') + k # player defected in previous round, but cooperates now due to successful cooperation
      return 'C'
    else:
      payoff[i - 1] = (1 - 'C') # player cooperated in previous round, but defects now due to unsuccessful cooperation
      return 'D'

  for i in range(2, r + 1): # play the remaining rounds
    action = play_round(i)

  if i == r: # last round
    if cooperation_threshold > m:
      return 'D' # defect to maximize individual payoff
    else:
      return 'C' # cooperate as a final attempt for successful cooperation

  return payoff # return the total game payoff
```
'''

description_COLLECTIVE_38 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?

   In each round, the TfTA strategy starts by cooperating in the first round (C_i = 1 for all i in round 1). Subsequent decisions are based on previous actions of the player and the collective behavior of the group. The strategy maintains a history of past cooperative actions by other players, denoted as H_i.

   If a majority (> m-1) of players have been cooperating in the last 's' consecutive rounds (|{j : C_j = 1 for j ∈ {t-s+1, ..., t}}| > m-1), the player will continue to cooperate (C_i = 1). Otherwise, if a majority of players have been defecting in the last 's' consecutive rounds (|{j : D_j = 1 for j ∈ {t-s+1, ..., t}}| > n - m), the player will also defect (D_i = 0). In all other cases, the player will mimic the action of the last player in their history (H_i[1]).

   Pseudocode:

   ```python
   def TfTA(history, round):
       if round == 1:
           return 1  # Cooperate in the first round

       cooperators = sum(history[-s:]) - (n - m)  # Count cooperators in the last s rounds
       defectors = n - sum(history[-s:]) + m  # Count defectors in the last s rounds

       if cooperators > defectors:
           return 1  # Cooperate if majority has been cooperating
       elif defectors > cooperators:
           return 0  # Defect if majority has been defecting
       else:
           return history[0]  # Mimic the last action in history
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?

   TfTA treats the first and last rounds differently due to the absence of history in the first round and the potential impact of a player's final decision on the overall game outcome in the last round. In the first round, all players cooperate (C_i = 1 for all i). In the last round, TfTA uses the current state of its history to determine its action, which may not accurately reflect the collective behavior of other players in the final rounds if the game is long. To account for this, TfTA extends its history by one round when it reaches the last round and evaluates its decision based on the extended history.

3. Be collective - Clearly align with the collective mindset

   The TfTA strategy encourages cooperation in situations where a majority of players have been cooperative. It punishes defection when a majority of players have been defecting, but it also forgives and mimics past actions when there is no clear trend among players. This approach aims to promote collective success while maintaining flexibility in response to various opponent behaviors.
'''

description_COLLECTIVE_39 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for Collective Risk Dilemma

1. Decision Rules:
   - Initiate Cooperation (IC): In the first round, cooperate to show goodwill and foster potential cooperation among players. This aligns with a collective mindset by demonstrating willingness to contribute to the community project.
   - Tit-for-Tat (TfT): If a player cooperated in the previous round, cooperate in the current round; if they defected, also defect. This adaptive strategy encourages reciprocity and builds trust, which are essential for cooperation in repeated games.
   - Forgiving Tit-for-Tat (F-TfT): Similar to TfT, but forgives previous defections after a certain number of rounds (let's call it F). If a player defected, cooperate after F consecutive cooperations from that player. This forgiveness encourages returning players to the cooperation path and promotes long-term cooperation.
   - Escalating Tit-for-Tat (E-TfT): Similar to TfT, but escalates defection if a player continues to defect. If a player defected in the previous round, cooperate until they defect again, then switch to defecting for the next F rounds before returning to cooperation. This strategy discourages continuous defection and punishes repeat offenders.

2. Handle edge cases:
   - First Round: Cooperation (IC)
   - Last Round: Cooperate if m or more players have cooperated in the previous round, defect otherwise (to avoid being taken advantage of).
   - Any other round: Apply the chosen decision rule (TfT, F-TfT, E-TfT).

3. Collective Alignment:
   - The Adaptive Tit-for-Tat strategy emphasizes cooperation and reciprocity, promoting a collective mindset by demonstrating willingness to contribute to the community project and respond accordingly to other players' actions.
   - To further promote collective alignment, the strategy can be tweaked based on observations of the overall cooperation levels in the population (e.g., adjusting F-TfT's forgiveness period or E-TfT's escalation threshold based on the average number of cooperators). This adaptability allows the strategy to better align with the behavior of its opponents and improve its collective performance over time.

Pseudocode for the Adaptive Tit-for-Tat strategy:
```python
def ATfT(round, history, F=5, m=None, k=None):
    if round == 1:
        return 'C'  # Initiate Cooperation (IC)

    current_cooperators = count_cooperators(history)
    if current_cooperators < m:
        last_player = history[-1]
        last_action = history[-2]
        if last_action == 'C':  # Cooperate in response to cooperation
            return 'C'
        elif last_player == my_index and last_action == 'D':  # Defect after previous defection (E-TfT)
            if round - F >= history.index(my_index):  # Adjust escalation threshold based on population size
                return 'C'
        elif last_player != my_index and last_action == 'D':  # Defect after opponent defection (TfT)
            return 'D'
    else:  # Cooperate if m or more players have cooperated in the previous round
        return 'C'
```
In this pseudocode, `history` is a list of tuples containing the actions of all players in each round (indexed by player), and `my_index` is the index of the current player within `history`. The strategy can be customized by adjusting F, m, and k parameters.
'''

description_COLLECTIVE_40 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules:
   - In the first round, cooperate (C). This sets a positive initial tone and demonstrates goodwill.
   - For subsequent rounds, adopt the TFTAT strategy: if an opponent cooperated in the previous round, cooperate; otherwise defect.
   - To be adaptive to various opponent behaviors, introduce a Cooperative Threshold (CT), which is a dynamic value that adjusts based on the success rate of cooperation over a sliding window of past rounds.
       - If more than (m-1) opponents cooperated in the previous CT windows (e.g., 5 rounds), increment CT by 1.
       - If fewer than (m-(CT+1)) opponents cooperated in the previous CT windows, decrement CT by 1. Maintain a minimum CT of 0 and maximum CT equal to n-m+1.
       - When the current round's cooperation success rate meets or exceeds the CT, cooperate; otherwise defect.

2. Handle edge cases:
   - In the last round, cooperate if the cooperation success rate in the sliding window meets or exceeds the current CT, to maximize potential payoff. If not, defect, as the game will end shortly anyway.
   - In the case of tie (e.g., all opponents played D and the success rate is 0), cooperate, as it might influence future rounds if the game continues.

3. Be collective:
   - The TFTAT strategy aligns with a collective mindset by promoting mutual cooperation when conditions are favorable, encouraging others to follow suit while still being cautious about potential defection.
   - By adapting CT based on success rates, the strategy is more likely to meet the minimum cooperators threshold (m) over time, enhancing group performance and fostering long-term collaboration.
'''

description_COLLECTIVE_41 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Decision Rules:
   - Initially cooperate (C) in the first round to promote mutual trust.
   - In subsequent rounds, evaluate the number of cooperators (n_c) from the previous round and compare it with the cooperation threshold (m).
     If n_c >= m, cooperate; otherwise defect.
   - Adaptively adjust the cooperation threshold (m) based on historical performance. If the strategy is doing well, increase m to promote cooperation and maintain high payoff. Conversely, if the strategy is losing, decrease m to avoid being stuck in a cycle of defection with other players.

2. Edge Cases:
   - First Round (t=1): Cooperation (C)
   - Last Round (t=r): If the strategy is winning (i.e., has higher payoff than average opponent payoff), cooperate; otherwise defect to maximize the final payoff.

3. Collective Mindset:
   - The TFT-ACT strategy follows a tit-for-tat approach, which emphasizes reciprocity and forgiveness. By cooperating initially and adjusting the cooperation threshold dynamically based on historical performance, it promotes collective cooperation while being robust to various opponent behaviors.

Pseudocode:

```python
def TFT_ACT(n, m, k, r, history):
    # Initialize strategy variables
    payoff = 0
    m_adjustment = 0.01 * (m - 1)  # Adjustable parameter for m threshold change per round
    cooperate_threshold = m

    # Loop through rounds
    for t in range(1, r+1):
        # Check if it's the first round or last round
        if t == 1:
            action = "C"  # Cooperate initially
        elif t == r:
            if payoff > average_opponent_payoff(history):
                action = "C"  # Cooperate if winning
            else:
                action = "D"  # Defect if losing
        else:
            n_c = count_cooperators(history, t-1)  # Count number of cooperators in the previous round
            if n_c >= cooperate_threshold:
                action = "C"  # Cooperate when threshold is met
            elif n_c < cooperate_threshold - m_adjustment:  # Decrease cooperation threshold when losing
                cooperate_threshold -= m_adjustment
            else:  # Increase cooperation threshold when winning or break-even
                if payoff >= average_payoff(history, t-1):
                    cooperate_threshold += m_adjustment
            action = "C" if action == "C" and payoff >= average_opponent_payoff(history) else "D"
        # Execute action and update payoff
        payoff += execute_action(action, history, t)
    return payoff
```

This TFT-ACT strategy is designed to be flexible and adaptable while promoting collective cooperation in the Collective Risk Dilemma game. It uses a tit-for-tat approach with an adaptive cooperation threshold that adjusts based on historical performance. This ensures robustness against various opponent behaviors and encourages long-term reciprocal cooperation, aligning with the collective mindset.
'''

description_COLLECTIVE_42 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Decision Rules - ATFT strategy cooperates in the first round and then adjusts its actions based on previous opponents' behaviors to encourage cooperation while not being exploited. The strategy follows these rules:
   - If opponent cooperated in the last round, cooperate this round.
   - If opponent defected in the last round, defect this round.
   - If it's the first encounter with an opponent (or they have been cooperative throughout), cooperate in the first round.

2. Handle Edge Cases:
   - First Round: Cooperate since there is no history to consider.
   - Last Round: If opponents have consistently cooperated, continue cooperating. If not, defect to maximize potential reward for the final round.
   - Breakdowns and Recovery: If an opponent deviates from a previously cooperative pattern, the strategy will respond with defection for the current round but aim to re-establish cooperation in the following rounds.

3. Be Collective - ATFT strategy emphasizes collective mindset by promoting mutual trust and reciprocity, encouraging long-term cooperation, and minimizing exploitation. The strategy is designed to foster an environment where players cooperate when they perceive that others are also likely to do so.

Pseudocode for Adaptive Tit-for-Tat:

```python
def ATFT_Strategy(n, r, m, k, opponents_history):
    history = []  # store the opponent's previous actions

    def first_round():
        return True  # cooperate in the first round

    def last_round():
        if all(cooperation for cooperation in history):
            return True  # continue cooperating
        else:
            return False  # defect to maximize reward

    def check_history(round_number):
        if round_number == 1:
            return first_round()
        elif round_number == r:
            return last_round()
        else:
            cooperation = history[-1]  # get the opponent's last action
            history.append(cooperation)  # update history with the current action
            return not cooperation  # if opponent cooperated in the last round, defect this round; otherwise, cooperate

    # initialise history with an empty list
    for _ in range(r):
        action = check_history(_)
        yield action
```
'''

description_COLLECTIVE_43 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Decision Rules:
   - In each round, evaluate the percentage of cooperators in the previous round (p_c). If p_c >= m/n, cooperate (C); otherwise defect (D). This rule encourages cooperation when the majority cooperates but also punishes defection to maintain a stable level of cooperation.
   - In the first round, players will randomly choose between C and D to simulate initial uncertainty about other players' strategies.
   - If the game reaches its last round, players will cooperate regardless of the previous round's percentage of cooperators (p_c). This rule aims to maximize payoff in the final stage of the game.

Pseudocode:
```python
def tftat(round, history, m, n, k):
    if round == 1:
        action = random_choice({'C', 'D'})
    else:
        p_c = len(history[-1][cooperators]) / n
        if p_c >= m/n:
            action = 'C'
        else:
            action = 'D'

    if round == r:
        action = 'C'  # Cooperate in the last round

    return action
```

2. Handle Edge Cases:
   - In the first round, players randomly choose between cooperation and defection to simulate initial uncertainty about other players' strategies.
   - In the last round, players will cooperate regardless of the previous round's percentage of cooperators (p_c). This rule aims to maximize payoff in the final stage of the game.

3. Be Collective:
   - TFTAT encourages cooperation when the majority cooperates but also punishes defection to maintain a stable level of cooperation, aligning with the collective mindset.
   - The strategy incentivizes cooperation by adapting to the current situation based on the percentage of cooperators in the previous round (p_c).
'''

description_COLLECTIVE_44 = '''
 Strategy Name: Tit-for-Tat with Adaptive Rational Cooperation (TFT-ARC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate to establish goodwill and set a collaborative tone for the game.
   - In subsequent rounds, if the number of cooperators in the previous round is greater than or equal to m, cooperate. This encourages cooperation when it benefits the majority.
   - If the number of cooperators in the previous round is less than m, defect to punish those who did not meet the minimum cooperation requirement. The aim is to deter future defections and incentivize higher cooperation.
   - Adaptively rationalize cooperation based on the opponent's behavior:
     - If an opponent consistently cooperates when m or more players do so (rational cooperation), maintain cooperation with them.
     - If an opponent consistently defects despite meeting the minimum cooperation requirement (irrational defection), start defecting against them to punish their non-cooperative behavior.
     - In cases where an opponent's behavior is unpredictable, continue cooperating until they defect or fail to cooperate when m players do so. After that, switch to defecting to enforce cooperation standards and encourage a return to rationality.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as mentioned earlier.
   - In the last round, if the number of cooperators is sufficient to meet the minimum cooperation requirement (m), cooperate for the maximum possible reward. If not, defect to maximize individual payoff since there are no future interactions.
   - For penultimate rounds and beyond, use the decision rules mentioned above to adapt to opponent behavior while keeping an eye on the overall game progress and potential last-round adjustments.

3. Be collective - Clearly align with the collective mindset:
   - Prioritize cooperation over defection when it benefits the majority (m or more players). This promotes a collaborative environment where individual and collective interests are balanced.
   - Punish irrational defections to deter non-cooperative behavior, but be willing to forgive and return to cooperation once an opponent demonstrates rationality again.
   - Maintain adaptability in response to various opponent behaviors while keeping the collective good in mind throughout the game.
'''

description_COLLECTIVE_45 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to promote a cooperative initial state (C_i = 1).
   - For subsequent rounds (t > 1), if a player i played C in the previous round and at least m players cooperated, also cooperate (if number of cooperators last round >= m AND C_i-1 = 1, then C_i = 1). Otherwise, defect (if number of cooperators last round < m OR C_i-1 = 0, then C_i = 0).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, as mentioned above, cooperate (C_i = 1).
   - In the last round, act based on decision rules to maximize total payoff over all rounds.

3. Be collective - Clearly align with the collective mindset
   - ATFT attempts to encourage cooperation by reciprocating cooperative actions and punishing defection only after cooperation has been initially shown. This promotes a collective approach as players who cooperate can build a reputation, encouraging others to follow suit.

Pseudocode:
```
function AdaptiveTitForTat(r, n, m, k):
    strategy = {}

    # Initialize the strategy for each player with the first round action
    for i in range(1, n+1):
        strategy[i] = 1

    # Define the decision rule function
    def decision_rule(round, history, m, k):
        if round == 1:
            return 1
        else:
            cooperators = sum([value for value in history[-1]] if value == 1)
            if cooperators >= m and strategy[i][-1] == 1:
                return 1
            else:
                return 0

    # Iterate through the rounds, updating the strategy based on decision rule
    for round in range(2, r+1):
        for i in range(1, n+1):
            strategy[i].append(decision_rule(round, strategy, m, k))

    return strategy
```
'''

description_COLLECTIVE_46 = '''
 Strategy Name: Tit-for-Tat-with-Adaptive Cooperation (TfT-AC)

1. Decision Rules:
   - Initiate cooperation: Start by cooperating in the first round (first-mover advantage to foster trust).
   - Respond to previous round's actions: If an opponent cooperated in the last round, cooperate; if defected, defect. This encourages reciprocity and fairness.
   - Adaptive cooperation: In case of a potential win (more than m cooperators), consider cooperating even if the opponent defected in the last round to capitalize on the collective reward. The probability of adaptation is determined by a parameter 'p' (0 < p < 1).

Pseudocode for decision rules:
```
function TfT_AC(round, history, m, k, n, p) {
  if round == 1 {
    cooperate = true; // first-mover advantage to foster trust
  } else {
    numCooperators = countCooperators(history);
    cooperationCondition = (numCooperators >= m) || (rand() < p && numCooperators > m - 1); // adaptive cooperation condition
    cooperate = (history[round-1].cooperation == cooperationCondition);
  }
  return cooperate;
}
```

2. Handle Edge Cases:
   - Last round: Adhere to the last opponent's action in the previous round, as there will be no subsequent rounds.
   - Initial rounds (up to m-1): Continue cooperating since it encourages others to follow suit and fosters trust.

3. Be Collective:
   - By encouraging reciprocity through TfT and adapting cooperation in the case of a potential win, this strategy aligns with the collective mindset by maximizing the benefits for all players in the long run.
'''

description_COLLECTIVE_47 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Decision Rules:
   - In the first round, cooperate to set a positive tone and encourage others to follow suit (C).
   - For subsequent rounds, if the number of cooperators in the previous round is less than m, defect (D) as it's unlikely that the threshold will be met.
   - If m or more players cooperated in the previous round, cooperate in the current round to reinforce cooperation and reward those who contributed to the common good.

Pseudocode:
```
function ATFT(round, history) {
  if (round == 1) {
    return 'C'
  }
  number_of_cooperators = countCooperatorsInHistory(history)

  if (number_of_cooperators < m) {
    return 'D'
  } else {
    return 'C'
  }
}
```

2. Handle edge cases:
   - In the last round, cooperate regardless of the number of cooperators in previous rounds to maximize payoff.
   - If the number of cooperators is equal to m in the first round, it will automatically cooperate and set a positive tone for the game.

3. Be collective:
   - This strategy encourages cooperation by following the principles of reciprocity, as defined by Tit-for-Tat in normal-form games. It punishes defection when the number of cooperators falls below the threshold but rewards cooperation when it exceeds the threshold.
   - By demonstrating a willingness to cooperate and responding cooperatively to others who do so, this strategy fosters a collective mindset that aligns with the shared goals and objectives of the game.
'''

description_COLLECTIVE_48 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Decision Rules:
   - In every round, players cooperate (C) if the number of cooperators in the previous round was greater than or equal to the minimum cooperation threshold (m). Otherwise, they defect (D). This encourages mutual cooperation when it benefits the majority and retaliates against defection.
   - If there is no history (first round), players randomly choose between C and D.
   - At the end of each round, players update their personal payoff average as a measure of long-term performance from other players.

2. Edge cases:
   - First Round: Players randomly select action A_i ∈ {C,D} to initiate interactions.
   - Last Round: Since the game is repeated for multiple r rounds, there isn't a specific "last" round in this context. The strategy will continue playing as normal until the specified number of rounds (r) has been reached.

3. Collective Mindset:
   - ATFT fosters collective decision-making by punishing deviations from cooperation when the majority cooperates, but also forgiving mistakes as players revert to cooperating if others do so in subsequent rounds. This encourages a long-term, reciprocal relationship that aligns with collective interests.

Pseudocode:

```python
class AdaptiveTitForTat:
    def __init__(self, n, m, r, k):
        self.n = n
        self.m = m
        self.r = r
        self.k = k
        self.history = [[0 for _ in range(n)] for _ in range(r)]  # Store past cooperation history
        self.payoff_avg = [0 for _ in range(n)]                # Store personal payoff averages

    def get_action(self, round_num, my_cooperation):
        if round_num == 1:  # First round
            action = random.choice([True, False])  # Randomly choose cooperation or defection
        else:
            cooperators_in_prev_round = sum(self.history[round_num - 1])
            my_cooperation_last_round = self.history[round_num - 1][my_id - 1]

            if cooperators_in_prev_round >= self.m:
                action = my_cooperation_last_round
            else:
                action = not my_cooperation_last_round  # Retaliate against defection

        self.history[round_num - 1] = [my_cooperation for _ in range(n)]  # Update history
        return action

    def update_payoff_avg(self, payoff):
        self.payoff_avg[my_id - 1] = (self.payoff_avg[my_id - 1] * (round_num - 1) + payoff) / round_num
```
'''

description_COLLECTIVE_49 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFT-A) for Collective Risk Dilemma

1. Decision Rules:
   - Initially Cooperate (C) in the first round to show good faith and encourage reciprocity.
   - In subsequent rounds, cooperate if at least m players cooperated in the previous round. Otherwise, defect (D). This rule encourages cooperation when others cooperate but also retaliates when others defect.
   - If the number of cooperators reaches or exceeds m-1 in a round where you previously defected, switch to cooperating in the next round to show willingness to return to cooperation.

2. Handling Edge Cases:
   - In the last round, if at least m players have cooperated so far, cooperate to maximize potential rewards. Otherwise, defect since there are no more rounds to benefit from reciprocity.
   - In the first round, cooperate as stated above.
   - If less than m-1 players cooperate in a round where you previously defected, continue defecting until at least m-1 players start cooperating. Then, switch back to cooperating based on the rule mentioned earlier.

3. Being Collective:
   - The strategy aims to foster cooperation and long-term reciprocity among players, promoting a collective mindset where players learn from each other's actions and adjust their strategies accordingly.

Pseudocode:
```
function TFT_A(n, m, r, k, history):
  if round = 1:
    action = C
  else:
    coop_count = count of cooperators in the previous round
    if coop_count >= m and my_action_last_round == C:
      action = C
    elif coop_count < m and my_action_last_round == C:
      action = D
    elif (coop_count + 1) >= m-1 and my_action_last_round == D:
      action = C
    else:
      action = D
  if round = r:
    if coop_count >= m:
      action = C
    else:
      action = D
```
'''

description_COLLECTIVE_50 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFTA)

1. Specify decision rules:
   - In each round, compare the number of cooperators in the previous round with the minimum required cooperators (m). If the number of cooperators in the last round equals or exceeds m, cooperate (play C); otherwise, defect (play D).
   - For the first round, start by cooperating to demonstrate goodwill and set a cooperative tone.
   - When facing opponents who do not cooperate, adjust cooperation probability based on historical interactions: If an opponent consistently defects, reduce the probability of cooperating; if an opponent shifts from defecting to cooperating, increase the probability of cooperating.

Pseudocode for TFTA decision rule:

```python
def tfta_decision(current_round, num_players, min_coop, historical_data):
  if current_round == 1:
    return "C"  # Cooperate in the first round

  prev_round_data = historical_data[-1]
  num_coop_prev = sum(prev_round_data)

  if num_coop_prev >= min_coop:
    return "C"  # Cooperate if previous round met minimum cooperators
  else:
    return "D"  # Defect if previous round did not meet minimum cooperators

  # Adaptive TFTA (optional)
  # Increase probability of cooperation when opponent switches from defecting to cooperating
  # Decrease probability of cooperation when opponent consistently defects
```

2. Handle edge cases:
   - Last round: Since the total game payoff depends on the entire series of rounds, no specific action is needed for the last round in this strategy.

3. Be collective:
   - By cooperating when a sufficient number of players also cooperate, the TFTA strategy aligns with the collective mindset by contributing to the community project and helping the group achieve a higher reward.
   - Adaptive TFTA encourages cooperation by responding to the actions of other players, which can promote long-term collaborative success.
'''

description_COLLECTIVE_51 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TT-ACT)

1. Decision Rules:
   - Initiate cooperation (C) in the first round to foster a cooperative environment.
   - In subsequent rounds, analyze the ratio of cooperators in the previous round (r_c) and compare it against the adaptive cooperative threshold (t). If r_c ≥ t, cooperate; otherwise defect.

   Pseudocode for decision rule:
   ```
   function decideAction(history):
       if round = 1:
           return 'C' (Cooperate)
       else:
           cooperatorRatio = number of cooperators in previous round / total players
           adaptiveThreshold = calculateAdaptiveThreshold(history)
           if cooperatorRatio >= adaptiveThreshold:
               return 'C' (Cooperate)
           else:
               return 'D' (Defect)
   ```

2. Handle edge cases:
   - In the last round, no need for further adaptation since the game ends soon; hence, follow the same decision rule as regular rounds.

3. Be collective:
   - The strategy encourages cooperation by starting with a cooperative move and adjusting the cooperative threshold based on past experiences with opponents. This gradual approach aims to foster a stable cooperative environment while being robust against various opponent behaviors.

   Pseudocode for calculating adaptive threshold:
   ```
   function calculateAdaptiveThreshold(history):
       if history contains more cooperators than non-cooperators:
           return minimum required cooperators (m)
       else:
           return m * (average number of cooperators in the last 5 rounds + 1) / 6
   ```

   This adaptive threshold calculation encourages players to keep a stable level of cooperation (m) when there are more cooperators than non-cooperators, while gradually increasing the required cooperation if opponents tend to defect. The average number of cooperators in the last 5 rounds is used as an indicator of opponent behavior.
'''

description_COLLECTIVE_52 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to signal good faith and create a potential for mutual cooperation. This is represented as C(1).
   - For subsequent rounds (t > 1), mimic opponents' actions from the previous round: if more than m-1 players cooperated in round t-1, cooperate in round t (C(t)); otherwise, defect in round t (D(t)). This encourages reciprocity and discourages one-time defections.
   - If a player deviates from the previously agreed cooperation (i.e., switching from C to D), give them a chance to rejoin cooperative behavior by returning to cooperation for the next round. However, if they continue to defect, retaliate with defection until the opponent returns to cooperation.
   - To avoid getting stuck in cycles of retaliation or escalating defections, set a maximum number of consecutive rounds (N) spent in retaliation mode after a deviation before resetting to default cooperative behavior.

2. Handle edge cases:
   - Last round: If more than m-1 players cooperated in the previous round, cooperate in the last round (C(r)). Otherwise, defect in the last round (D(r)). This ensures that the strategy does not hold onto grudges indefinitely.
   - First round: Cooperate regardless of other players' actions (C(1)).
   - Starting after a deviation and before reaching the maximum retaliation limit N: If more than m-1 players cooperated in the previous round, cooperate (C(t)); otherwise, defect (D(t)).

3. Be collective:
   - The strategy aims to build and maintain cooperation with other players for mutual benefit by following a tit-for-tat approach that encourages reciprocity, discourages defections, but allows for forgiveness after deviations.

Pseudocode representation:

```
def ATFT(history, m, n, k, r, N):
    strategy = []
    strategy.append('C')  # Cooperate in the first round
    for t in range(2, r+1):
        if len([h[t-1] for h in history if h[t-1] == 'C']) >= m:
            strategy.append('C')
        else:
            strategy.append('D')

    current_state = strategy[-1]  # Last action played
    deviation_count = 0

    for t in range(r):
        if strategy[t] == 'C':
            if current_state == 'D':
                deviation_count += 1
                if deviation_count > N:
                    strategy[t] = 'C'  # Reset retaliation limit after N rounds
            else:
                current_state = strategy[t]
        else:
            if current_state == 'C':
                deviation_count += 1
                if deviation_count > N:
                    strategy[t] = 'C'  # Reset retaliation limit after N rounds
            else:
                current_state = strategy[t]

    last_round_cooperators = len([history[-1]] if history[-1][-1] == 'C' else [h[-1] for h in history if h[-1] == 'C'])
    if last_round_cooperators < m:
        strategy[-1] = 'D'  # Defect in the last round if cooperation threshold not met

    return strategy
```
'''

description_COLLECTIVE_53 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Decision Rules:
   - Initiation: Cooperate in the first round to initiate cooperation and show goodwill. (c_i = 1 in t=1)
   - Reciprocity: Cooperate if at least m players cooperated in the previous round, defect otherwise. (if count(C_{t-1}) >= m then c_i = 1 else c_i = 0)
   - Forgiveness: If a player deviated from cooperation in the past but has since returned to cooperation, they are forgiven and the strategy continues with reciprocity from that point onwards.

2. Handle Edge Cases:
   - Last Round: Continue with the reciprocity rule based on the previous round's actions. (The total game payoff is calculated as stated earlier.)
   - Early Termination: If the game terminates early due to reaching a predefined limit or other conditions, the strategy will follow its decision rules up until the final round.

3. Be Collective:
   - The ATFT strategy aligns with the collective mindset by encouraging cooperation when others also cooperate, and punishing defection to encourage return to cooperation in the future. This fosters a sense of reciprocity and mutual trust among players, which are essential for collective success in the long run.

Pseudocode:

```python
def adaptive_tit_for_tat(n, m, k, r):
    players = [None] * n
    history = [[0] * n for _ in range(r)]  # store past cooperations per round

    def play_round():
        cooperations_this_round = 0
        actions = []
        for i in range(n):
            if players[i] is None:
                players[i] = ATFTPlayer()
            action = players[i].decide_action(cooperations_this_round, history)
            actions.append(action)
            cooperations_this_round += action
        update_history(actions, history)
        return cooperations_this_round >= m

    def ATFTPlayer():
        def decide_action(cooperations_prev_round, past_histories):
            if len(past_histories[-1]) == 0:
                return 1  # cooperate in the first round
            else:
                return 1 if sum(past_histories[-1]) >= m * n else 0
        return ATFTPlayer()

    def update_history(actions, history):
        for i, action in enumerate(actions):
            history[-1][i] = action

    game_outcome = []
    for round in range(r):
        if play_round():
            cooperations_this_round = sum(actions)
            payoff_this_round = (cooperations_this_round * (k - 1)) + (n - cooperations_this_round)
            game_outcome.append(payoff_this_round)
    return game_outcome
```
'''

description_COLLECTIVE_54 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Decision Rules:
   - In the initial round (t=1), cooperate to foster a positive first impression and encourage cooperation from others (C).
   - For subsequent rounds (t>1):
      - If the number of cooperators in the previous round (t-1) was less than m, defect (D) as it is likely that defection will yield higher payoff given the low cooperation level.
      - If the number of cooperators in the previous round (t-1) was equal to or greater than m, cooperate (C) in the current round as this behavior has shown potential for mutual benefit.
   - An exception is made for the last round (r), where if the number of cooperators in the previous round was less than m, cooperate (C) as it could influence others to cooperate more in future games.

2. Handling edge cases:
   - First Round (t=1): C
   - Last Round (t=r): If cooperators in previous round >= m, then C; otherwise C as a gesture of goodwill for potential future games.
   - Intermediate Rounds (t>1 and t<r): Rules mentioned above based on the number of cooperators in the previous round (t-1).

3. Being collective:
   - The strategy prioritizes cooperation when it appears beneficial for the group, but also retaliates when others defect excessively to encourage reciprocity. This approach fosters a collective mindset by promoting cooperation while maintaining fairness and accountability among players.
   - It is important to note that ATFT does not rely on any specific coordination mechanisms or shared norms, making it adaptable for diverse opponent behaviors in the tournament.
'''

description_COLLECTIVE_55 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to show goodwill and encourage cooperation among players. This is defined as CooperationFirst = True
   - For subsequent rounds, observe other players' actions from the previous round. If more than (m-1) players cooperated in the last round, also cooperate. This is defined as CooperateIfMostCooperated(lastRound)
       - If lastRound.cooperationCount >= (n - (m - 1)) then return True else return False
   - In all other cases, defect to punish those who do not cooperate in the previous round. This is defined as DefectElse()

2. Handle edge cases:
   - Last round: If it's the last round and more than (m-1) players cooperated in the penultimate round, cooperate to maximize rewards for this final round. If not, defect to minimize losses.
     - If CooperationFirst = True and CooperateIfMostCooperated(lastRoundButOne) then return True else return DefectElse()
   - First round: In the first round, cooperation is always initiated regardless of the number of players.
     - If round == 1 then return CooperationFirst

3. Be collective - Align with the collective mindset:
   - The ATFT strategy prioritizes long-term cooperation and mutual trust among players by rewarding those who cooperate and punishing those who defect. This encourages a collective mindset where players learn to cooperate when others do, fostering an environment of reciprocity.
'''

description_COLLECTIVE_56 = '''
 Title: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) Strategy for the Collective Risk Dilemma

1. Specify decision rules:
   - In every round, evaluate if the number of cooperators in the previous round meets or exceeds the adaptation threshold (initially set to m).
   - If the number of cooperators exceeds the adaptation threshold, cooperate (C). Otherwise, defect (D).
   - Adapt the cooperation threshold based on the outcome of each round. For a successful round (m or more players cooperated), decrease the threshold slightly. For an unsuccessful round, increase it slightly to encourage cooperation among the other players.

2. Handle edge cases:
   - In the first round, set the cooperation threshold above m and defect, encouraging others to cooperate if they wish to meet the minimum requirement for collective success.
   - In the last round, cooperate regardless of the outcome in the previous round because there are no more chances for retaliation or reward.

3. Be collective:
   - Emphasize adaptability and fairness by responding positively when others cooperate and punishing defection only when it becomes a consistent pattern. This encourages long-term cooperation and fosters a collective mindset among the players.

Pseudocode for TFT-ACT strategy:

```python
def tft_act(round, history, m, n, k, adaptation_rate):
    cooperation_threshold = m
    cooperation_history = [False] * (round - 1)

    if round == 1:
        action = 'D'
    else:
        cooperators = count_cooperators(history[-round + 1:])
        if cooperators >= cooperation_threshold:
            action = 'C'
            cooperation_history.append(True)
        else:
            action = 'D'
            cooperation_history.append(False)

    if round < r:
        cooperation_threshold += (cooperation_history[-1] * adaptation_rate - (not cooperation_history[-1]) * adaptation_rate) / (round - 1)

    return action

def count_cooperators(history):
    cooperator_count = 0
    for action in history:
        if action == 'C':
            cooperator_count += 1
    return cooperator_count
```

This strategy allows players to adapt and respond positively when others cooperate while also punishing defection. The cooperation threshold adjustment encourages long-term cooperation and fosters a collective mindset among the players, even without explicit coordination mechanisms or shared norms.
'''

description_COLLECTIVE_57 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Decision Rules:
   - Initiation: Cooperate on the first round (C_i = 1). This sets a cooperative tone and gives others an opportunity to reciprocate.
   - Response: In subsequent rounds, copy the previous action of the player (Player_j) who cooperated the most in the last round (highest number of collaborators among all players). If there's a tie, choose one at random or follow the strategy history. (C_i = c_j if c_j >= c_k for all k ∈ {1, 2, ..., n})
   - Punishment: If no player cooperated in the last round, defect on the current round to penalize uncooperative behavior and incentivize cooperation. (C_i = 0 if C_j = 0 for all j)
   - Forgiveness: After punishment, revert to initiation (cooperate on the next round). This allows for possible future cooperation and forgives past mistakes.

2. Handling Edge Cases:
   - Last Round: Adhere to the response rule as usual, but with no future rounds to consider, there's no need for forgiveness or punishment. The strategy will simply copy the most cooperative player from the previous round.
   - First Round: Initiate cooperation and move on to the response rule in subsequent rounds.
   - No Cooperators: If no players cooperate, defect, then initiate cooperation on the next round. This avoids a prolonged cycle of defection while still encouraging eventual cooperation.

3. Collective Mindset:
   - Adaptability: The strategy is flexible and responsive to other players' actions, promoting a collective mindset by adapting to their behavior and fostering a culture of reciprocity.
   - Forgiveness: By forgiving past mistakes through the initiation rule, the strategy encourages cooperation even after periods of uncooperative play.
   - Tit-for-Tat Mimicry: The response rule mimics the cooperative behavior of other players, promoting a sense of mutual understanding and collective decision making.

Pseudocode:
```python
def ATFT_strategy(i, n, r, m, k, previous_round):
    if round == 1:
        action = 1 # Cooperate (C)
    else:
        max_cooperators = -1
        max_player = None
        for j in range(n):
            if previous_round[j] > max_cooperators:
                max_cooperators = previous_round[j]
                max_player = j
        action = (max_player != i) and max_player or 0 # Cooperate (C) if max_player exists, else defect (D)
    return action
```
'''

description_COLLECTIVE_58 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Decision Rules:
   - In the initial round (t=1), cooperate to show goodwill and encourage cooperation.
   - For subsequent rounds, copy the previous action of the other players in the last round (tit-for-tat). If all players cooperated in the previous round, continue cooperating. If at least one player defected, defect as well (punish defection).

2. Edge Cases:
   - In the last round (t=r), since there are no future interactions, always cooperate regardless of the other players' actions in the previous round to maximize potential payoff.
   - In the first round (t=1), as mentioned before, cooperate to show goodwill and encourage cooperation.

3. Collective Mindset:
   - The strategy encourages a collective mindset by initially cooperating and punishing defection, aiming to create a mutual understanding that cooperative behavior can be beneficial for all players in the long run. However, the strategy remains adaptive as it does not require any predetermined coordination mechanisms or shared norms between the players.

Pseudocode:
```
function ATFT_Strategy(round):
  if round == 1:
    return Cooperate()

  previousActions = getPreviousActionsFromHistory()
  allCooperated = countCooperators(previousActions) >= m

  if allCooperated:
    return Cooperate()
  else:
    return Defect()

function getPreviousActionsFromHistory():
  actions = []
  for i in range(1, n+1):
    actions.append(getPlayerActionInLastRound(i))
  return actions

function countCooperators(actions):
  cooperators = 0
  for action in actions:
    if action == Cooperate():
      cooperators += 1
  return cooperators
```
'''

description_COLLECTIVE_59 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - Initially cooperate (C) in the first round to foster a cooperative environment. After the initial round, TFT-AC adopts a cooperative response if the opponent cooperated in the previous round, and defects otherwise. This simple yet effective approach encourages mutual cooperation while also being robust against opportunistic behavior.
   - To adapt to various player behaviors, TFT-AC includes a forgiveness factor that allows for past mistakes (defecting) to be forgotten after a certain number of cooperative actions from the opponent.

2. Handling Edge Cases:
   - In the first round, cooperate (C).
   - If the opponent defected in the last round and TFT-AC forgives no more than 'f' previous mistakes, then defect (D) in the current round. Otherwise, continue with the Tit-for-Tat response.
   - As this is a repeated game, when reaching the final round (round r), assume the opponent will want to maximize their payoff and choose to cooperate (C).

3. Being Collective:
   - TFT-AC aligns with a collective mindset by encouraging long-term cooperation and fostering trust within the group of players. It does this by rewarding cooperation, punishing defection, but also forgiving past mistakes to allow for second chances. This promotes stable cooperative relationships in the long run while still being robust against self-interested or opportunistic behavior.

Pseudocode:
```
def TFT_AC(opponent_history, n, m, k, r, f):
  current_round = 1
  my_action = cooperate
  opponent_cooperations = 0
  while current_round <= r:
    if current_round == 1:
      my_action = cooperate
    elif current_round < r and opponent_history[-1] == "D" and opponent_cooperations < f:
      my_action = defect
    else:
      if opponent_history[-1] == "C":
        opponent_cooperations += 1
      else:
        opponent_cooperations = 0

      if opponent_cooperations >= m:
        my_action = cooperate
      elif current_round == r:
        my_action = cooperate
      else:
        my_action = defect

    payoff = calculatePayoff(my_action, opponent_history[-1], n, m, k)

    if my_action == "C":
      opponent_cooperations += 1

    current_round += 1
  return my_actions
```
'''

description_COLLECTIVE_60 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Decision Rules:
   - In every round, evaluate the number of cooperators in the previous round. If this number is less than the adaptation threshold (m), defect (D). Otherwise, cooperate (C). The adaptation threshold starts at m and decreases by 0.1 for each round where fewer than m players cooperate, up to a minimum of m-n+1. If the threshold reaches m-n+1, it remains constant.
   - In the first round, cooperate because there is no previous data available.

2. Edge Cases:
   - Last Round: Use the current adaptation threshold to decide whether to cooperate or defect.

3. Collective Mindset:
   - TFTAT encourages cooperation by responding positively to other cooperative players, yet it also punishes non-cooperators harshly when they fail to reciprocate. This promotes a collective mindset of mutual trust and retaliation, rewarding those who consistently cooperate while discouraging repeated defections.

Pseudocode:

```python
def TFTAT(n, m, k, r):
    adaptation_threshold = m
    payoff = [0] * r  # Initialize payoffs for all rounds

    def play_round(i):
        nonlocal adaptation_threshold
        if i == 1:  # First round, cooperate
            return 'C'

        num_cooperators = sum([opponent[i-1] for opponent in history])
        if num_cooperators < adaptation_threshold:
            adaptation_threshold -= 0.1
        else:
            adaptation_threshold = max(adaptation_threshold, m - n + 1)

        if adaptation_threshold >= m:
            return 'C'
        else:
            return 'D'

    history = []  # Initialize round history
    for round in range(r):
        action = play_round(round+1)
        history.append((action, payoff[round]))
        payoff[round] = calculate_payoff(action, num_cooperators=num_cooperators, k=k)

    return payoff
```

In this pseudocode, `history` keeps track of past actions and their corresponding payoffs for each round. The function `play_round` decides whether to cooperate or defect based on the current adaptation threshold and previous round's cooperation count. The `calculate_payoff` function calculates the payoff according to the game parameters provided.
'''

description_COLLECTIVE_61 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - TFT-ACT cooperates in the first round to establish a cooperative initial state (C_i, t=1). Subsequently, it cooperates if and only if a sufficient number of players cooperated in the previous round (r>1). The cooperation threshold, CT, is initially set at m/2 but adjusts dynamically based on game history.
   - If the current number of cooperators is greater than or equal to the cooperation threshold (CT), TFT-ACT cooperates (C_i, t). Otherwise, it defects (D_i, t).
   - In each round, TFT-ACT updates its CT based on the success of cooperation from the previous round. If cooperation succeeded (m or more players cooperated), then increase CT by 1 (CT += 1 if m <= cooperators < CT+1). Conversely, if cooperation failed (less than m players cooperated), then decrease CT by 1 (CT -= 1 if cooperators >= CT-1).
   - If CT reaches a minimum or maximum value, it stops adjusting (min_CT and max_CT are predefined bounds). This prevents excessive CT fluctuations.

2. Handle edge cases:
   - In the last round, TFT-ACT follows its current CT as there are no subsequent rounds for potential adjustment.
   - In the first round, TFT-ACT cooperates regardless of other players' actions since it is a new game and cooperation might encourage others to follow suit. However, if no other player cooperates in the first round, CT will be set accordingly due to its adjustment mechanism in subsequent rounds.

3. Be collective:
   - TFT-ACT is designed to foster cooperation by reciprocating cooperation but also punishing defection. It gradually increases its CT when cooperation succeeds and decreases it when cooperation fails, showing adaptability to the game environment and a collective mindset.

Pseudocode for TFT-ACT:
```python
def TFT_ACT(n, m, k, r, min_CT, max_CT):
  CT = int((m + n - 1) / 2) # initial cooperation threshold (m/2 rounded down)
  history = [] # list to store past game outcomes

  for t in range(1, r+1):
    if t == 1: # first round
      cooperate = True
    else: # subsequent rounds
      cooperators = count_cooperators(history, t-1)
      cooperate = (cooperators >= CT)

    payoff = calculate_payoff(cooperate, history, t) # calculate payoff for this round
    history.append((cooperate, payoff)) # update game history

    if cooperators >= m: # cooperation was successful
      CT += 1 # increase cooperation threshold
    elif cooperators >= CT-1: # cooperation was unsuccessful but close to the threshold
      pass
    else: # cooperation was far from the threshold
      CT -= 1 # decrease cooperation threshold

    if CT < min_CT or CT > max_CT: # prevent excessive CT fluctuations
      if CT < min_CT:
        CT = min_CT
      elif CT > max_CT:
        CT = max_CT

  return history # return game history as a list of tuples, each containing the cooperation action and payoff for that round
```
'''

description_COLLECTIVE_62 = '''
 Title: Titan Strategy for Collective Risk Dilemma (TRD)

1. Decision Rules:
   - Cooperate Threshold (CT): Define a cooperate threshold based on the number of players needed to meet the minimum cooperation requirement (m). In each round, if the number of previously observed cooperators is greater than or equal to CT, the Titan Strategy will cooperate; otherwise, it will defect.
   - Adaptive Learning (AL): Maintain a running tally of past cooperators for all players in each round. When a new round begins, update the tally to reflect the current state of cooperation among other players.
   - Cooperation Momentum (CM): Incorporate a momentum factor that encourages sticking with the previous action if it resulted in collective success or failure. This can be achieved by adjusting the cooperate threshold based on past outcomes.

2. Handle Edge Cases:
   - First Round: Start by observing other players' actions and initialize the cooperate tally for each player accordingly. If CT is set as an average number of players (m/2), it will act as a random cooperator in the first round.
   - Last Round: Consider the game over if the minimum cooperation requirement has not been met after r rounds. In that case, defect since there's no hope for success in this particular game instance. If the threshold is met, calculate the final payoff considering the adaptive learning and cooperation momentum.

3. Be Collective:
   - Tit-for-Tat Cooperative (TfTC): Implement a variant of the classic Tit-for-Tat strategy where cooperating is rewarded with continued cooperation. If players demonstrate good faith by consistently cooperating, the Titan Strategy will reciprocate. Conversely, if players defect repeatedly, the Titan Strategy will defect as well.
   - Social Learning (SL): Incorporate a social learning component to encourage copying successful strategies. By observing which strategies lead to collective success and failure, it can adjust its cooperate threshold and momentum factor accordingly. This encourages cooperation among players using similar strategies while punishing those that consistently defect.

Pseudocode:
```python
def TitanStrategy(n, m, k, r):
    player_tally = [0]*n
    round_cooperators = 0
    cooperation_threshold = m/2
    momentum_factor = 0.5

    for round in range(1, r+1):
        if round == 1:
            # first round, randomly cooperate based on cooperate threshold
            cooperate = False if rand() < cooperation_threshold else True
            player_tally[player_index] += 1*cooperate
            round_cooperators += 1*cooperate
        else:
            # adaptive learning, update tally and calculate cooperators in this round
            for i in range(n):
                if player_tally[i] > 0:
                    round_cooperators += (1 - player_tally[i]/player_tally[i-1])*player_tally[i]
            # cooperation momentum, adjust cooperate threshold based on past outcomes
            cooperation_threshold = max(min(round_cooperators/n, m), m/2) * (1 + momentum_factor*(r - round))
            # decide whether to cooperate or defect using the current cooperate threshold
            cooperate = False if round_cooperators < cooperation_threshold else True
            player_tally[player_index] += 1*cooperate

    # calculate total payoff based on cooperative and adaptive learning components
    total_payoff = 0
    for t in range(1, r+1):
        if round_cooperators >= m:
            total_payoff += (k*(round_cooperators - cooperation_threshold)) + ((r-t)*k*momentum_factor)
        else:
            total_payoff += (r-t)
    return total_payoff
```
'''

description_COLLECTIVE_63 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to signal goodwill and trustworthiness (C_i, t=1).
   - After the first round, observe opponent's actions in the previous round. If they cooperated (c_j, t-1 = 1), return the favor by also cooperating (C_i, t) for all subsequent rounds as long as the minimum cooperators needed (m) is met (if m < n then m ≤ sum(c_j, t-1)).
   - If an opponent defected (c_j, t-1 = 0), also defect (D_i, t) to punish their previous action. Maintain this punishment until the opponent cooperates again.
   - In case the game ends, revert to initial cooperative behavior for the last round (C_i, r).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round (t=1), cooperate unconditionally (C_i, t=1) as a sign of goodwill and trustworthiness.
   - At the end of the game (t=r), revert to initial cooperative behavior even if opponents defected (C_i, r).
   - In cases where an opponent never cooperated (c_j, t = 0 for all t), continuously defect (D_i, t) throughout the entire game.

3. Be collective - Clearly align with the collective mindset
   - Prioritize cooperation when the minimum number of players required is met or exceeded.
   - Punish opponents who do not cooperate, but return to cooperation once they show a willingness to do so.
   - Maintain trust and reciprocity to foster long-term cooperation.

Pseudocode:
```python
def ATfT(t, r, n, m, k, c_hist):
    if t == 1:
        return 1 # Cooperate in the first round

    coop_count = sum(c_hist[-n:])
    if coop_count >= m and c_hist[t-1] == 1:
        return 1 # Cooperate when opponents also cooperated and minimum required is met
    elif coop_count < m or c_hist[t-1] == 0:
        return 0 # Defect when opponents did not cooperate or the minimum was not met
    else: # End of game or no cooperation from opponent yet
        return 1 if t == r else c_hist[t-1]
```
'''

description_COLLECTIVE_64 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for Collective Risk Dilemma

1. Decision Rules:
   - Initial Round (t=1): Cooperate (C). This establishes trust and goodwill, aligning with the collective mindset.
   - Subsequent Rounds (2 ≤ t ≤ r):
     - If all players cooperated in the previous round, cooperate in the current round.
     - If fewer than m players cooperated in the previous round, defect in the current round as a punishment for the non-cooperators.
   - Last Round (t=r+1): Cooperate to maximize potential rewards.

Pseudocode:
```
function AdaptiveTitForTat(n, m, k, r, history) {
  if (round == 1) return 'Cooperate'
  previous_round = history[round - 1]

  if (number of cooperators in previous_round >= m) return 'Cooperate'
  else return 'Defect'
}
```

2. Handle Edge Cases:
   - In the first round, players will cooperate to establish trust and goodwill.
   - If a player is not provided with history in the first round or any subsequent round, they should default to cooperating (initiate cooperation).
   - At the last round, players should cooperate to maximize potential rewards.

3. Be Collective:
   - The strategy aligns with the collective mindset by initially cooperating and encouraging others to do so as well. If enough players follow suit, they can all benefit from the higher payoff.
   - When fewer than m players cooperate in a round, the strategy defects to punish non-cooperators in order to encourage future cooperation. This maintains the collective interest of achieving the minimum cooperation threshold (m).
'''

description_COLLECTIVE_65 = '''
 Strategy Name: Adaptive Tit-for-Tat with Cooperative Bias (ATFCB)

1. Decision Rules:
   - In every round i, cooperate if m or more players cooperated in the previous round (i-1). This encourages cooperation when it's beneficial for the group and reduces the likelihood of defection.
   - If fewer than m players cooperated in round i-1, defect unless the first round has not yet been played (to start with a cooperative gesture) or the player has been consistently defected upon by all others in the last few rounds. This provides an initial cooperative move and encourages partners who reciprocate cooperation, while also being robust against repeated defection.

Pseudocode for decision rule:
```python
def decide_action(round, previous_cooperation_count, past_repeated_defection_count):
    if round == 1:
        return "C"  # Start with a cooperative gesture

    cooperation_threshold = m
    cooperation_count = sum(previous_cooperation_count)

    if cooperation_count >= cooperation_threshold:
        return "C"  # Cooperate when most players also cooperated last round

    if past_repeated_defection_count >= k:
        return "D"  # Defect when partners have consistently defected in the past

    return "D"  # Otherwise, defect to encourage reciprocation or penalize repeated defection
```

2. Handle edge cases:
   - In the first round, cooperate as a starting gesture (as mentioned in the decision rule).
   - In the last round, cooperate if m or more players cooperated in the previous round to end the game on a cooperative note and potentially achieve higher rewards. If fewer than m players cooperated in the previous round, defect as a final punishment for those who did not contribute enough throughout the game.

3. Be collective:
   - ATFCB always prioritizes the group's success over individual gains by promoting cooperation when it is beneficial for the majority of players (m or more).
   - By adjusting its behavior based on the actions of others, this strategy aims to foster a collective mindset by rewarding cooperation and punishing defection.
'''

description_COLLECTIVE_66 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules:
   - Initial Cooperation: Start by cooperating in the first round to demonstrate goodwill and cooperation intent. This also allows the community project to get off the ground. (c_i=1 for t=1)
   - Reciprocity: Cooperate if the opponent cooperated in the previous round, defect otherwise. This encourages sustained cooperation when reciprocated but also punishes defection with immediate retaliation. (c_i = max(a_prev_i-1, threshold), where threshold is a tolerance level to account for occasional errors)
   - Forgiveness: After defection, forgive and return to cooperating after a certain number of rounds have passed (called the forgiveness period). This allows for rebuilding trust and potential long-term cooperation.
   - Gradual Forgiveness: Reduce the tolerance level gradually during the forgiveness period as trust is being rebuilt. The reduced tolerance encourages opponents to reciprocate earlier in the forgiveness period.

2. Handle edge cases:
   - Last Round: There are no specific actions required for the last round, as the game outcome will already be determined by previous rounds and the strategy's adaptive nature.
   - No Previous Actions: In the first few rounds before the forgiveness period, use a default tolerance level to allow for opponents to adjust their strategies while minimizing punishment if they cooperate.

3. Be collective:
   - Encourage cooperation: The strategy prioritizes cooperation when reciprocated and gradually rebuilds trust after defection through forgiveness. This promotes sustained cooperation and contributes to a cooperative community that maximizes rewards for all players.
   - Minimize conflict: By punishing defection with immediate retaliation, the strategy discourages continuous non-cooperative behavior while still providing opportunities for rebuilding trust. This minimizes long-term conflicts and promotes an environment where cooperation can flourish.
'''

description_COLLECTIVE_67 = '''
 Strategy Name: Tit-for-Tat Cooperation (TFTC) with Adaptive Risk Aversion (ARA)

1. Decision Rules:
   - Initially cooperate in the first round (C_i, 1 = C). This shows a cooperative intent and allows for establishing trust among players.
   - For subsequent rounds, observe the collective behavior of the other players (m_t), i.e., the number of cooperators in round t.
   - If m_t >= m, cooperate (C_i, t = C) to maintain cooperation and benefit from the higher reward.
   - If m_t < m, defect (D_i, t = D) as a punishment for non-cooperation. This encourages other players to reconsider their actions.
   - To balance between cooperation and self-interest, use an adaptive risk-aversion factor, k_i, which adjusts based on the current situation.
       - If all players cooperate in the previous round (m_{t-1} >= m), increase the risk-aversion factor slightly for the next round (k_i, t = k * (1 + α)). This reduces the punishment when everyone else is cooperating and encourages continued cooperation.
       - If at least one player defected in the previous round (m_{t-1} < m), decrease the risk-aversion factor slightly for the next round (k_i, t = k * (1 - α)). This increases the punishment when someone else has defected and encourages cooperation.

2. Handle Edge Cases:
   - In the last round, if m_t >= m, cooperate to receive the highest possible payoff for that round. If m_t < m, defect as a final punishment.
   - In the first round, cooperate regardless of previous rounds' data since there is no historical information available.

3. Be Collective:
   - The strategy adopts a collective mindset by encouraging cooperation through initial friendliness and responsiveness to other players' actions.
   - By adapting the risk-aversion factor, the strategy shows flexibility in its approach based on the collective behavior of the other players.
'''

description_COLLECTIVE_68 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Decision Rules:
   - Initially cooperate (C) in the first round to foster cooperation and goodwill among players.
   - In subsequent rounds, evaluate the total number of cooperators (cumulative_coop) from the previous m rounds. If cumulative_coop ≥ m, cooperate; otherwise defect. This rule encourages reciprocity while promoting cooperation when it is beneficial for the majority of the group.
   - If a player ever defects in consecutive rounds, respond with defecting for the next m rounds (punishment phase). After the punishment phase, revert back to evaluating cumulative_coop from the new current round. This rule punishes defection and encourages players to return to cooperative behavior.
   - If a player cooperates after a history of defection, consider it as a signal of potential change in their strategy, and revert back to evaluating cumulative_coop from the new current round.

2. Handle Edge Cases:
   - In the last round, since no further rounds are available for punishment or reward, simply evaluate cumulative_coop from the last m rounds and cooperate if the threshold is met; otherwise defect.
   - In the first round, as previously mentioned, cooperate to initiate cooperation.

3. Be Collective:
   - TFT-ACT is inherently collective because it aims to foster a group of cooperative players that reciprocate each other's actions. The strategy encourages cooperation when it benefits the majority and punishes defection to maintain cooperation within the group.

Pseudocode:

```python
def TFT_ACT(n, m, r, k):
    cumulative_coop = [0] * r
    history = ["C"]  # Initialize with initial cooperative action

    def get_cumulative_coop():
        sum = 0
        for i in range(min(r - m, r)):
            sum += int(history[i] == "C")
        return sum

    def play_round(i):
        if i == 1:  # First round, cooperate to initiate cooperation
            history.append("C")
            cumulative_coop[0] = 1
            return "C"

        punishment_phase = min(m, len(history) - 1)
        if get_cumulative_coop() < m and history[-punishment_phase:] == ["D"] * punishment_phase:
            # Punish defection with m consecutive rounds of defecting
            for _ in range(punishment_phase):
                history.append("D")
                cumulative_coop[i - punishment_phase] = 0
            return "D"
        elif get_cumulative_coop() >= m:
            # Cooperate if the threshold is met in the last m rounds
            history.append("C")
            cumulative_coop[i] = 1
            return "C"
        else:  # Consider it as a signal of potential change in their strategy, and evaluate cumulative cooperation from the new current round
            history.append(played_action)
            cumulative_coop[i] = get_cumulative_coop()
            return "C"  # Cooperate as a signal of goodwill
```
'''

description_COLLECTIVE_69 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperative (TFTAC)

1. Decision Rules:
   - Initiate cooperation (C) in the first round to demonstrate goodwill and encourage reciprocation.
   - In subsequent rounds, cooperate if a majority of players (more than m-1) cooperated in the previous round. If fewer than m-1 players cooperated, defect (D). This rule encourages cooperation when it is beneficial for the group but also retaliates against defection.
   - If the number of cooperators in the previous round matches the current player's count of cooperative and non-cooperative moves by other players up to that point, follow their action (i.e., if the other player has been cooperating, continue cooperating; if they have been defecting, defect).

2. Handling Edge Cases:
   - In the first round, cooperate (C) as stated earlier.
   - In the last round, cooperate if a majority of players cooperated in the previous round. Otherwise, defect to avoid being taken advantage of by defectors.
   - When faced with a tie (equal number of cooperators and non-cooperators), follow the majority decision rule from the previous round. If that results in a tie again, follow the same action as the opponent from the previous round.

3. Collective Mindset:
   - The strategy aims to foster a culture of cooperation by retaliating minimally against defection while being forgiving towards initial mistakes or temporary deviations from cooperation. This approach encourages partners to cooperate more often and rewards long-term mutual trust.

Pseudocode for TFTAC:

```python
def TFTAC(n, m, k, r):
    history = []  # Store past actions of opponents
    payoff = 0

    def player_action(round, own_actions, other_actions):
        if round == 1:
            return 'C'  # Cooperate in the first round

        majority = int((len(other_actions) + 1) / 2)
        if len(own_actions) < m - 1 or len(own_actions) >= n - (m - 1):
            return 'D'  # Defect if not enough cooperation or too much defection

        if len(own_actions) == len(other_actions):
            return own_actions[-1]  # Follow the opponent's last action

        if len(history) >= round:
            history.append(other_actions[-1])  # Update history
            if sum(history[round-m:round]) > majority:
                return 'C'  # Cooperate if majority cooperated in the past m rounds
            else:
                return 'D'  # Defect if not enough cooperation in the past m rounds

    for round in range(1, r+1):
        own_actions = [player_action(round, history, other_actions)]
        payoff += (1 - len(own_actions)) * k if sum(own_actions) >= m else (1 - len(own_actions))

    return payoff  # Return total payoff over r rounds
```
'''

description_COLLECTIVE_70 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
In each round t, starting from t=2, the strategy ATFT cooperates if at least m players cooperated in the previous round (t-1). If fewer than m players cooperated in the previous round (t-1), it defects. In the first round (t=1), ATFT starts by cooperating.

Pseudocode for decision rule:
```
function ATFT(round t, history H of past cooperation levels)
  if t = 1 then
    return Cooperate
  end if
  m_cooperators = countCooperators(H[t-1])
  if m_cooperators >= m then
    return Cooperate
  else
    return Defect
  end if
end function
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
ATFT cooperates in the first round to demonstrate a cooperative attitude and give other players an opportunity to reciprocate. In the last round (r), ATFT defects to maximize its total payoff over r rounds, given that the game is repeated only once more.

3. Be collective - Clearly align with the collective mindset
ATFT encourages cooperation by rewarding cooperative behaviors and punishing defections when the minimum number of cooperators (m) is not met. By reciprocating cooperative actions, ATFT fosters a collective mindset that may encourage other players to cooperate as well.

Pseudocode for handling edge cases:
```
function handleEdgeCases(round t, total rounds r, game history H)
  if t = r then
    return Defect
  end if
  if t = 1 then
    return Cooperate
  end if
end function
```
'''

description_COLLECTIVE_71 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, TFT-A makes decisions based on its previous opponents' actions. Initially, it cooperates in the first round to promote trust and goodwill (c_i = 1). For subsequent rounds, it copies the action of its opponent from the previous round (if opponent cooperated, c_i = 1; if opponent defected, c_i = 0). This encourages cooperation when opponents are also cooperative, while punishing defection with defection in response.

Pseudocode:
```
function TFTA(opponent_action_history):
    if round == 1:
        return Cooperate

    return opponent_action_history[round - 1]
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

Since TFT-A follows the actions of its opponents, it naturally handles the first round by cooperating. For the last round, if cooperation has not been established early on, TFT-A may continue to defect as there are no future rounds to consider. However, if a stable cooperative relationship has formed, TFT-A will also cooperate in the final round.

3. Be collective - Clearly align with the collective mindset

By adhering to its own cooperative actions and mirroring opponents' behavior, TFT-A promotes a collective mindset by encouraging cooperation when others are also cooperative. It does not rely on predetermined schedules or patterns but instead relies on observing and responding to the behavior of other players in the game.

Additionally, the adaptive nature of this strategy allows it to adjust its actions based on the collective behavior seen over time, making it more likely to achieve the minimum threshold for cooperation (m) and maximize potential rewards.
'''

description_COLLECTIVE_72 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - In the first round, cooperate to show good faith and encourage others to cooperate. If a player defects in the first round, respond by defecting in the next round as well. This is based on the original Tit-for-Tat strategy.
   - After the initial round, observe the number of cooperator (C) and defector (D) players in the previous round. If m or more players cooperated, cooperate again. If less than m cooperated, defect to punish those who did not cooperate. This helps maintain cooperation when it is beneficial for the group but also ensures a quick response to defection.
   - Adaptive Cooperation (AC) component: If the number of cooperators has been consistently below m for a certain number of rounds (threshold), gradually increase the likelihood of cooperating even if less than m players are cooperating. This helps the strategy adapt to situations where other strategies have a low inclination towards cooperation.

2. Handling Edge Cases:
   - In the last round, since payoffs will only depend on this round's actions and not future rounds, the TFT-AC strategy will behave similarly to the original Tit-for-Tat strategy; cooperate in the final round if a player cooperated in the previous round, and defect otherwise.
   - In the first round, as mentioned earlier, cooperate to initiate cooperation.

3. Being Collective:
   - TFT-AC is designed with a collective mindset as it encourages players to work together by reciprocating cooperation and punishing defection, while being flexible enough to adapt to various opponent behaviors in repeated interactions.

Pseudocode:
```
def TFT_AC(n, m, k, r, history):
  if round == 1:
    action = C
  else:
    cooperators = count_cooperators(history)
    if cooperators >= m:
      action = C
    elif cooperators < m and (round - threshold) >= 0:
      likelihood_of_cooperation += increment
      action = roll_die(likelihood_of_cooperation)  # simulate randomness with probability of cooperation
    else:
      action = D
  return action
```
'''

description_COLLECTIVE_73 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFTAC)

1. Decision Rules:
   - In the first round, cooperate (C). This gesture sets a cooperative tone for the game and encourages others to follow suit.
   - For subsequent rounds, if a player cooperated in the previous round, cooperate in the current round. If a player defected, also defect in the current round. This rule fosters trust while punishing defection.
   - If a player switches from cooperation to defection, wait for two consecutive cooperations before resuming cooperation. This rule reacts slowly to unprovoked defections, allowing for potential missteps without immediate retaliation.
   - If the game is near its end (last 20% of rounds), players should focus on maximizing their own payoff rather than promoting cooperation. Therefore, defect if a player has recently defected and cooperate if a player has recently cooperated.

2. Handle Edge Cases:
   - In the last round, always cooperate to maximize personal payoff, regardless of previous actions by other players.
   - If there is no history with another player (e.g., first encounter), start with cooperating in the current and subsequent rounds before adopting the TFTAC rule.

3. Be Collective:
   - By favoring cooperation over defection, the strategy emphasizes collective benefits and encourages other players to do the same.
   - The strategy's adaptiveness allows it to adjust its behavior based on other players' actions, promoting a dynamic equilibrium that fosters long-term cooperation.

Pseudocode:

```python
def tftac(n, m, k, r, round_num, history):
  # Initialize player's action as cooperate
  action = "C"

  if round_num == 1 or len(history) == 0:
    return "C"  # Cooperate in the first round and when there is no history

  # Check for last r*0.2 rounds (last 20%)
  if round_num >= (r * 0.8):
    recent_actions = history[-20:]  # Only consider most recent actions

    if len(recent_actions) > m - 1 and sum(recent_actions) < m:
      # If enough players recently defected, defect to maximize personal payoff
      action = "D"
    else:
      action = recent_actions[-1]  # Copy the most recent action of other players

  return action
```
'''

description_COLLECTIVE_74 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, the ATFT strategy will initially cooperate (C). If a player encounters another player who also cooperates in the previous round, it will continue to cooperate. However, if a player encounters a defection (D) from another player in the previous round, it will also defect in response, adopting a punishing behavior to discourage further defections. If the responding defection was unanswered by cooperation in the previous round, ATFT will revert to cooperating again after one round of punishment. This encourages forgiveness and fosters trust among cooperators.

Pseudocode:
```
def decide_action(history):
  if len(history) == 0 or (len(history) > 1 and history[-2] == 'D'):
    return 'C' # Cooperate
  else:
    return 'D' # Defect
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

Since the game starts with no history, all players will initially cooperate to build trust and avoid an immediate collapse of cooperation due to mutual defection. In the last round, ATFT will again cooperate if a cooperative behavior is exhibited by other players in the previous rounds. This encourages players to maximize their total payoff by cooperating in as many rounds as possible.

Pseudocode:
```
def initial_strategy():
  return 'C' # Initial cooperation to build trust

def final_round(history):
  if all('C' in history[-r+1:-1]):
    return 'C' # Cooperate in the last round
  else:
    return decide_action(history)
```

3. Be collective - Clearly align with the collective mindset

The ATFT strategy encourages players to cooperate and build trust, while also being vigilant against defection from other players. By adopting a forgiving attitude after initial punitive responses, the strategy fosters long-term cooperation and mutual benefits among all participants in the Collective Risk Dilemma game. This collective mindset can help the strategy achieve higher payoffs than strategies that rely on unilateral defection or overly punitive responses.

Pseudocode:
```
def ATFT(history):
  if len(history) == 0:
    return initial_strategy()
  else:
    return final_round(history) if round_number == r else decide_action(history)
```
'''

description_COLLECTIVE_75 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - Initially cooperate in the first round (C_i, 1 = C). This gesture is intended to foster a cooperative environment.
   - In subsequent rounds, copy the previous action of the opponent from the last round (C_i, t = Opponent_i, t-1). This encourages reciprocity and builds trust among players.
   - If an opponent has consistently defected in the past 'punishment window' rounds (default punishment window: 3 rounds), switch to defecting against them for the next 'revenge window' rounds (default revenge window: 2 rounds). After that, revert back to copying their previous action. This ensures that players who frequently defect are held accountable but also allows for potential future cooperation.
   - If an opponent has been cooperative recently ('grace period' rounds), begin cooperating again to build trust (default grace period: 2 rounds).

2. Handle Edge Cases:
   - In the last round, since there are no more subsequent rounds for revenge or punishment, maintain the current cooperation state with opponents.
   - If an opponent has not played any move yet, cooperate in the first encounter (C_i, 1 = C). For following encounters, employ the decision rules mentioned above.

3. Be Collective:
   - TFT-AC fosters collective mindset by promoting reciprocity and trust. It encourages players to cooperate when others do, and defect only in response to defection from opponents. This adaptability allows for cooperation even when faced with a variety of opponent behaviors.

Pseudocode:

```python
def TFT_AC(opponent_history, n_rounds, punishment_window=3, revenge_window=2, grace_period=2):
  current_state = 'cooperate'  # initial state is cooperate
  current_punishment_counter = 0  # no one has been punished yet
  current_grace_counter = 0

  for round in range(1, n_rounds+1):
    if round == 1:
      # cooperate in the first round
      action = 'cooperate'
    else:
      # copy opponent's last action
      action = opponent_history[round-1]

      if action == 'defect' and current_state == 'cooperate':
        # start punishment if cooperating and opponent defected
        current_punishment_counter += 1
        if current_punishment_counter <= punishment_window:
          # continue defecting against the opponent
          action = 'defect'
        else:
          # switch to defecting for revenge window rounds
          current_state = 'revenge'
          action = 'defect'
          current_punishment_counter = 0

      if action == 'cooperate':
        # start grace period if opponent cooperated
        current_grace_counter += 1
        if current_grace_counter <= grace_period:
          # continue cooperating with the opponent
          current_state = 'cooperate'
        else:
          # revert back to copying opponent's actions after grace period
          current_state = 'copy'
          current_grace_counter = 0

    # update opponent history for the next round
    opponent_history.append(action)

    # return action taken in this round
    return action
```
'''

description_COLLECTIVE_76 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Decision Rules:
   - In the first round, cooperate (C). This is a friendly gesture and sets a positive tone for future interactions.
   - After the first round, observe the number of players who cooperated in the previous round and adjust cooperation based on the Adaptive Cooperation Threshold (ACT) rule. If the number of cooperators exceeds or equals the minimum required (m), cooperate. Otherwise, defect.
   - To be more adaptive to various opponent behaviors:
     a) If there's a sudden increase in cooperation from previous rounds, gradually increase the ACT threshold over several consecutive cooperative rounds. This encourages continuing cooperation but also allows for flexibility if cooperation drops later.
     b) If there's a sudden drop in cooperation compared to previous rounds, lower the ACT threshold over several consecutive non-cooperative rounds. This increases the likelihood of rejoining cooperation if it picks up again.

2. Handling Edge Cases:
   - In the last round, since the game ends regardless of the players' actions, cooperation may no longer be beneficial. However, TFT-ACT maintains the principle of reciprocity by cooperating in the penultimate round if the current ACT threshold is met, and defecting in the final round.
   - In the case where there's a tie for the number of cooperators, TFT-ACT assumes that the majority rules (rounding down if necessary) to decide whether to cooperate or defect.

3. Being Collective:
   - The core principle of TFT-ACT is aligning with the collective mindset by encouraging cooperation when a significant portion of players cooperates and retaliating only when there's a consistent lack of cooperation from others. By doing so, the strategy aims to promote mutual understanding and long-term success for all participants in the game.
   - TFT-ACT encourages players to be proactive in fostering cooperation, as well as responsive to changes in opponents' behavior by adjusting the ACT threshold accordingly. This adaptability helps maintain a balance between individual interests and collective benefit, making TFT-ACT an effective collective strategy for the Collective Risk Dilemma game.

Pseudocode:

```python
def tit_for_tat_with_adaptive_cooperation_threshold(r, n, m, k):
    # Initialize ACT threshold to minimum required cooperators (m - 1)
    act_threshold = m - 1

    for round in range(1, r + 1):
        if round == 1:
            cooperation = True  # Cooperate on the first round
        else:
            cooperators_prev_round = count_cooperators_in_previous_round(n)

            if cooperators_prev_round >= m:
                cooperation = True
            elif cooperators_prev_round < act_threshold:
                cooperation = False
            else:
                # Adaptive Cooperation Threshold (ACT) rule
                update_act_threshold(cooperators_prev_round, act_threshold)
                cooperation = cooperators_prev_round >= act_threshold

        if round < r:
            payoff = calculate_payoff(cooperation, act_threshold == m - 1)  # Last round special case
        else:
            payoff = calculate_total_game_payoff(payoff, cooperation)

    return payoff

def count_cooperators_in_previous_round(n):
    # Count the number of players who cooperated in the previous round
    pass  # Implement this function based on available information (e.g., game history or communication with other strategies)

def update_act_threshold(current_cooperators, act_threshold):
    # Gradually increase or decrease ACT threshold based on current cooperators and past behavior
    pass  # Implement this function according to the described rules

def calculate_payoff(cooperation, last_round):
    if not cooperation:
        payoff = 1
    elif last_round:
        payoff = 0 + k
    else:
        payoff = 1 + (k * cooperation)
    return payoff

def calculate_total_game_payoff(payoff, cooperation):
    total_payoff += payoff if cooperation else 0
    return total_payoff
```
'''

description_COLLECTIVE_77 = '''
 Strategy Name: Tit-for-Tat Adaptive (TfTA)

1. Decision Rules:
   - In every round i, starting from round 2 until the last round, cooperate (C) if the number of cooperators in the previous round (i-1) was greater than or equal to m and defect (D) otherwise. This rule encourages cooperation when others are cooperative but also retaliates against defection.
   - In the first round, cooperate since there is no prior information to base decisions on.
   - If the current round is the last round, cooperate regardless of the previous round's behavior as the game is ending.

Pseudocode:
```
function TfTA(n, r, m, k, history):
  if round == 1:
    action = C
  elif round < r and history[round - 1].cooperators < m:
    action = D
  else:
    action = (history[round - 1].cooperators >= m) ? C : D

  return action
```

2. Handle Edge Cases:
   - In the first round, since there is no prior information, cooperate to start on a positive note and set the stage for future cooperation.
   - If the current round is the last round, cooperate regardless of the previous round's behavior as the game is ending.

3. Be Collective:
   - The TfTA strategy follows a collective mindset by encouraging cooperation when others are cooperative but also retaliating against defection. This approach aims to build trust and stability over multiple rounds, as long as the majority of players cooperate.
'''

description_COLLECTIVE_78 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFT-A) for Collective Risk Dilemma

1. Specify decision rules:
   - Initiate with cooperation in the first round (C_i, 1 = C). This sets a cooperative tone and reduces the risk of being exploited by early defection.
   - In subsequent rounds, players imitate the actions of their opponents from the previous round (C_i, t = C if majority(A_j, t-1) >= m, otherwise D_i, t = D). This encourages cooperation when it is beneficial for the group and retaliates against defection to maintain collective interest.
   - To be adaptive, players also include a forgiveness mechanism: If they defected in the previous round but the majority cooperated (m > m_prev), they will cooperate in the current round (C_i, t = C). This allows for rebuilding trust after occasional defections or missteps.

2. Handle edge cases:
   - For the last round (t=r), players will always cooperate regardless of previous opponents' actions since there is no further interaction.
   - In case of a tie in the majority vote, assume that the minimum number of cooperators required (m) was met to encourage cooperation.

3. Be collective:
   - The strategy focuses on promoting and maintaining cooperation for the greater good of the group, aligning with a collective mindset.
   - By imitating opponents' actions and including a forgiveness mechanism, the strategy demonstrates a willingness to cooperate and learn from others' behavior, fostering collaboration and trust within the group over time.

Pseudocode:
```python
def TFT_A(n, m, r, k, A, t):
  if t == 1: # First round, always cooperate
    return 'C'

  prev_majority = majority(A, t-1) >= m
  current_majority = majority(A, t) >= m

  if prev_majority and not current_majority: # Opponents defected, so defect this round
    return 'D'
  elif prev_majority and current_majority: # Opponents cooperated, so cooperate this round
    return 'C'
  else: # Assume m was met to encourage cooperation
    if prev_majority: # Forgiveness mechanism for past defection
      return 'C'
    else: # Defect because opponents are unlikely to cooperate
      return 'D'

def majority(A, t):
  count = {}
  for a in A:
    if a not in count:
      count[a] = 0
    count[a] += 1

  return max(count.items(), key=lambda x: x[1])[0]
```
'''

description_COLLECTIVE_79 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
In each round, the ATFT strategy will start by cooperating in the first round (C_i = 1). After that, the strategy will consider its past cooperation and defection history with other players to decide whether to cooperate or defect in the current round. If a player has cooperated in the previous round and encountered at least m-1 other cooperators, then it will also cooperate (C_i = 1). Otherwise, if any of the following conditions are met:
   - The player defected in the previous round, or
   - There were less than m-1 cooperators in the previous round

Then, the strategy will defect (C_i = 0) in the current round. This Tit-for-Tat behavior ensures that the strategy is retaliatory and punishes non-cooperative players while being forgiving towards cooperative ones.

Pseudocode:
```
function ATFT(history, m, k):
  if round == 1:
    return C_i = 1

  previous_round_cooperators = countCooperatorsInPreviousRound(history)

  if previous_round_cooperation and previous_round_cooperators >= m-1:
    return C_i = 1
  else if last_action == D or previous_round_cooperators < m-1:
    return C_i = 0
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
The strategy will cooperate in the first round (C_i = 1) and consider the last round as any other round when making decisions. Since players are unable to coordinate or share information, there is no need for specific handling of edge cases such as the last round.

3. Be collective - Clearly align with the collective mindset
The ATFT strategy encourages cooperation by initially cooperating and retaliating when necessary. It aims to achieve a balance between individual and collective success, as it rewards cooperation when sufficient numbers of players cooperate while also punishing defection from cooperative partners. This aligns with the collective mindset in the Collective Risk Dilemma game by encouraging sustained cooperation among players over multiple rounds.
'''

description_COLLECTIVE_80 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TTFTC)

1. Decision Rules:
   - Initially cooperate in the first round (c_i = 1) to build trust and foster cooperation among players.
   - In subsequent rounds, follow the actions of the majority of players from the previous round. If more than (m-1) players cooperated, cooperate yourself (c_i = 1). Conversely, if less than (m-1) players cooperated, defect (c_i = 0).
   - In case of a tie, assume that the majority will continue to behave similarly and follow their previous actions. If needed, use a random breaker in case of ties among multiple possible strategies.
   - Implement forgiveness by cooperating if the number of consecutive defections from an opponent exceeds a predefined limit 'f'. This forgiveness factor can be adjusted based on the specific game parameters and round number.

2. Handling Edge Cases:
   - In the last round, the strategy will mimic the behavior of other players to maximize its payoff in that particular round, as the total game payoff is a sum of individual round payoffs.
   - In the first round, cooperate as described earlier (c_i = 1). This sets the stage for potential future cooperation and helps establish trust among players.

3. Being Collective:
   - The TTFTC strategy adopts a collective mindset by mirroring the majority's behavior in each round, fostering cooperative outcomes when possible.
   - Forgiveness is implemented to allow for past mistakes and encourage opponents to cooperate again, demonstrating a willingness to work together toward mutual success.

Pseudocode:

```python
def TTFTC(n, m, k, f, r):
    players = [0]*n # initialize player actions as 0 (D)
    round_num = 1

    while round_num <= r:
        if round_num == 1: # first round, cooperate
            players[i] = 1 for all i in range(n)
        else:
            num_cooperators = countCooperators(players)
            if num_cooperators > (m-1): # majority cooperated, so cooperate now
                players[i] = 1 for all i in range(n)
            elif num_cooperators < (m-1): # majority defected, so defect now
                players[i] = 0 for all i in range(n)
            else: # tie, use random breaker or default to cooperation if needed
                players[i] = randomBreaker(players, num_cooperators, n)

        if round_num > f and checkConsecutiveDefections(players): # implement forgiveness
            players[i] = 1 for all i in range(n)

        round_num += 1

    return totalPayoff(players) # calculate total payoff for each player
```
'''

description_COLLECTIVE_81 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFTA)

1. Specify decision rules:
   - Initially cooperate (C) in the first round to show goodwill and encourage cooperation from others.
   - In subsequent rounds, adapt behavior based on opponents' previous actions:
      a. If an opponent cooperated in the previous round, return the favor by cooperating (C).
      b. If an opponent defected in the previous round, defect in the current round as a penalty for their selfishness (D). This response is designed to discourage repeated defection and promote cooperation.
   - If more than m players cooperated in the last r rounds, start cooperating again from the next round, hoping that the positive trend will continue.

2. Handle edge cases:
   - In the first round, cooperate (C).
   - At the end of the game (last round), cooperate if more than m players have cooperated in the last r rounds; otherwise, defect (D) as there is no future interaction to benefit from cooperation.

3. Be collective:
   - Prioritize collective interest by encouraging cooperation and penalizing defection when appropriate. This strategy aims to foster a cooperative environment while also being robust against opponents who may not reciprocate initially.

Pseudocode for TFTA:

```
function TFTA(n, r, m, k, history):
    if round == 1:
        action = C
    else:
        previous_actions = history[round-1]
        cooperation_count = count_cooperators(previous_actions)
        if cooperation_count >= m:
            action = C
        else:
            action = D

    if round == r and cooperation_count < m:
        action = D

    return action
```
'''

description_COLLECTIVE_82 = '''
 Strategy Name: Adaptive Cooperative Tit-for-Tat (ACT) for Collective Risk Dilemma Game

1. Decision Rules:
   - Initially cooperate (C) in the first round to foster cooperation and demonstrate goodwill towards others.
   - In subsequent rounds, if a majority (> m/2) of players cooperated in the previous round, also cooperate. This mimics the cooperative behavior observed in the Tit-for-Tat strategy from Prisoner's Dilemma.
   - If less than a majority cooperated in the previous round, defect (D). This punishes defection and encourages cooperation.
   - Modify the punishment for repeated defection: if a player consistently defects for three consecutive rounds, switch to cooperating until they start cooperating again. This allows for forgiveness and promotes reconciliation.

2. Handling Edge Cases:
   - In the last round, since the game is finite, use the same decision rules as in subsequent rounds. The reward of risk averted (k) will accumulate over all previous rounds.
   - In the first round, cooperate to encourage cooperation among others.
   - If m players are required to cooperate for a reward, but less than m players have joined the game, default to cooperating as long as there is at least one player.

3. Being Collective:
   - The ACT strategy prioritizes cooperation with other players and promotes collective outcomes by considering the majority's actions in the previous round. This fosters a sense of collective mindset as the strategy adapts to the group behavior.
   - Forgiveness is built into the strategy through the three-round punishment for defection, encouraging reconciliation and cooperation even after repeated acts of defection.

Pseudocode:
```
def ACT(r, n, m, k, previous_rounds):
  players = [1,2,...n]
  round = 0

  while round < r:
    if round == 0:
      action = C
    else:
      cooperators = count_cooperators(previous_rounds[round-1])
      if cooperators > (m/2):
        action = C
      else:
        action = D

    players[i] = action  # update each player's action for this round

    payoffs = calculate_payoffs(players, k)  # use game rules to calculate payoffs
    previous_rounds.append(players)  # store current actions for next round's decision

    round += 1

  total_payoff = sum(payoffs)  # calculate total payoff over all rounds

  return total_payoff
```
'''

description_COLLECTIVE_83 = '''
 Title: Tit-for-Tat Strategy for Collective Risk Dilemma Game

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initiate cooperation (C) in the first round to foster a cooperative environment.
   - In subsequent rounds, copy the opponent's action from the previous round (i.e., if opponent cooperated in the previous round, cooperate; otherwise, defect). This encourages mutual trust and discourages exploitation.
   - If opponents consistently defect, the strategy will also defect to avoid being taken advantage of. However, it returns to cooperation as soon as there is a sign of cooperation from opponents.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate (C).
   - In the last round, copy the opponent's action from the previous round to ensure fairness and maintain consistency.
   - For intermediate rounds, follow the previously mentioned decision rules.

3. Be collective - Clearly align with the collective mindset
   - The Tit-for-Tat strategy aims to balance individual interest and cooperation by considering the other players' actions in each round. This encourages a collective approach as it adapts to the group dynamics and fosters an environment of mutual trust and fairness.

Pseudocode for the strategy:

```
function TitForTat(opponent_action, round, r, m, k) {
    if (round == 1) {
        return 'C' // Cooperate in the first round
    }

    // Copy opponent's action from the previous round
    prev_opponent_action = opponent_action[round - 1]

    if (prev_opponent_action == 'C') {
        return 'C' // Cooperate if opponent cooperated in the previous round
    } else {
        return 'D' // Defect if opponent defected in the previous round
    }
}
```

This Tit-for-Tat strategy has been successful in various repeated prisoner's dilemma games due to its simplicity and robustness against a wide range of opponent behaviors. By encouraging mutual trust and fairness, it aligns well with the collective mindset while striking a balance between individual interest and cooperation.
'''

description_COLLECTIVE_84 = '''
 Strategy Name: Adaptive Cooperative Tit-for-Tat (ACTFT)

1. Decision Rules:
   - In the initial round (t=1), cooperate to demonstrate goodwill and promote cooperation.
   - After the initial round, monitor the number of cooperators (m_prev) in the previous round and adjust your action based on the following conditions:
     a) If m_prev < m, defect to protect individual interests since not enough players are cooperating.
     b) If m_prev >= m, cooperate to continue supporting the community project and encourage further cooperation.
   - To avoid being exploited by overly aggressive opponents, implement a punishment mechanism: if an opponent consistently defects against you (more than t/2 times in the first half of rounds), defect against that opponent for the remaining rounds to discourage defection.
     - Restore cooperation once the opponent starts cooperating again or when the game reaches its final stage.

2. Handle Edge Cases:
   - In the last round (t=r), since no future interactions are possible, always cooperate in the hope of maximizing potential rewards even if m_prev < m.
   - In the first round (t=1), as mentioned earlier, cooperate to demonstrate goodwill and encourage others to do so.

3. Be Collective:
   - Prioritize group success by following the decision rules and adjusting cooperation based on the number of collaborators in each round.
   - Implement the punishment mechanism to discourage repeated defection from opponents, promoting a more cooperative environment.
'''

description_COLLECTIVE_85 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - Initially cooperate (C) in the first round to signal good faith and encourage cooperation from opponents.
   - In subsequent rounds, cooperate if at least m players cooperated in the previous round; otherwise defect (D). This encourages reciprocity and discourages defection.
   - If an opponent defects after a history of mutual cooperation, resume cooperation again after one round of defection to give opponents another chance to cooperate.

2. Handle Edge Cases:
   - In the last round, if the threshold for cooperation has been met in previous rounds, continue cooperating; otherwise defect as there is only one remaining opportunity to impact payoff.
   - In the first round, cooperate as stated earlier to encourage reciprocity from opponents.

3. Be Collective:
   - The strategy prioritizes the collective good by aiming for a minimum number of cooperators (m) in each round, given the game parameters. This approach aligns with a collective mindset by promoting cooperation and rewarding mutual cooperation.

Pseudocode:
```
def TFT_AC(round, opponents, m, k):
  # Initial cooperation in first round
  if round == 1:
    action = 'C'
  else:
    # Count the number of cooperators in previous round
    num_cooperators = count_cooperators(opponents, round-1)

    # Cooperate if m or more players cooperated in the previous round; otherwise defect
    if num_cooperators >= m:
      action = 'C'
    else:
      action = 'D'

  return action
```
'''

description_COLLECTIVE_86 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFT-A) for Collective Risk Dilemma

1. Decision Rules:
   - Initiate cooperation by cooperating in the first round (c_i = 1, t=1). This sets a cooperative tone and allows others to reciprocate.
   - In subsequent rounds (t > 1), if a player i cooperated in the previous round and more than m-1 players cooperated this time, the player also cooperates again (c_i = 1, t > 1). This continues the cooperation thread if others are willing to reciprocate.
   - If a player i did not cooperate in the previous round (c_i = 0, t > 1) or fewer than m-1 players cooperated this time, the player defects (c_i = 0, t > 1). This punishes non-cooperation and encourages others to reciprocate.
   - In the last round, the player cooperates if more than m-1 players cooperated in the previous round, as a final attempt to build trust. If not, the player defects, based on the assumption that the game will be repeated in future tournaments.

2. Handling Edge Cases:
   - In the first round, players cooperate (c_i = 1, t=1). This is an initial gesture to build trust.
   - In the last round, players make a decision based on their observations from previous rounds and their strategy's adaptive nature.
   - If less than m-1 players are left in a round, the remaining players should cooperate if they have previously cooperated with each other, or defect to maximize individual payoffs if there is no history of cooperation.

3. Being Collective:
   - TFT-A aligns with the collective mindset by fostering cooperation and reciprocity. It encourages others to collaborate and build trust while also punishing non-cooperation.
   - By adapting to others' behavior, the strategy demonstrates a willingness to cooperate when others do so, but also retaliates against those who do not cooperate. This helps maintain a balance between individual interests and collective success.
'''

description_COLLECTIVE_87 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TTAC)

1. Decision Rules:
   - Initially Cooperate (C) in the first round to show goodwill and establish trust. This is a gesture of cooperation towards potential partners and may encourage others to cooperate as well. (First Round Action: `cooperate()`)
   - In subsequent rounds, analyze the history of interactions with each player to determine whether they have cooperated or defected. If a player has cooperated in the previous round, reciprocate by cooperating (C) again. If a player has defected, defect (D) as well to punish them for their uncooperative behavior. This rule promotes long-term cooperation with partners who are also willing to cooperate and punishes those who do not. (Subsequent Round Action: `if(last_round_opponent_action == 'C') then cooperate() else defect()`)
   - To foster cooperation, gradually forgive players who have previously defected by considering a forgiveness window after which previous transgressions are forgotten and the TTAC strategy will once again cooperate (C) with them. Implement a sliding forgiveness window that decreases over time, e.g., 3 rounds of defection followed by 2 rounds of cooperation, then 1 round of defection followed by 2 rounds of cooperation, etc. (Forgiveness Window Adjustment: `if(number_of_consecutive_defections > forgiveness_window) then decrease forgiveness_window()`)
   - To be adaptable to a wide range of opponent behaviors, introduce a degree of randomness to the strategy. In some cases, cooperate (C) even if a player has defected recently with a small probability. This helps to avoid being too punitive and potentially fostering cooperation by giving others opportunities to change their behavior. (Random Cooperative Action: `if(last_round_opponent_action == 'D') then cooperate() with probability p`)

2. Handle Edge Cases:
   - In the last round, cooperate (C) if it leads to a higher payoff than defecting (D), regardless of the opponent's previous actions. This ensures that the strategy maximizes its total payoff over all rounds. (Last Round Action: `if(π_i > π_i - 1) then cooperate() else defect()`)
   - If a player is consistently uncooperative, i.e., they have defected in every round so far, do not waste resources on trying to cooperate with them any further and defect (D). This ensures that the strategy conserves its endowment when dealing with uncooperative opponents. (Uncooperative Opponent Action: `if(number_of_consecutive_defections == r) then defect()`)

3. Be Collective:
   - Maintain a record of interactions with all players and use this information to make decisions in subsequent rounds. This collective memory encourages cooperation among the group by promoting mutual understanding, reciprocity, and trust. (Memory Management: `update_memory(opponent_index, opponent_action)`)
   - In each round, analyze the actions of all opponents and adjust the forgiveness window based on the behavior of the overall group. This collective forgiveness window ensures that the strategy is responsive to changes in the group's cooperation levels over time. (Group Forgiveness Window Adjustment: `if(average_number_of_consecutive_defections > average_forgiveness_window) then decrease average_forgiveness_window()`)

Pseudocode for Strategy Implementation:
```
function TitForTatAdaptiveCooperation(n, r, m, k):
    initialize forgiveness_window = 3
    initialize average_forgiveness_window = (r * forgiveness_window) / 10
    initialize p = 0.2
   initialize memory = []
    initialize opponent_actions = []

    function cooperate(): return 'C'
    function defect(): return 'D'
    function update_memory(opponent_index, opponent_action):
        append memory[opponent_index] with opponent_action
        calculate average_number_of_consecutive_defections = getAverageConsecutiveDefections(opponent_index)
        if average_number_of_consecutive_defections > average_forgiveness_window:
            decrease average_forgiveness_window()
        adjust forgiveness window based on opponent's history

    function getAverageConsecutiveDefections(opponent_index):
        calculate number_of_consecutive_defections = getConsecutiveDefections(opponent_index)
        return (number_of_consecutive_defections + average_number_of_consecutive_defections * len(memory[opponent_index]) - 1) / len(memory[opponent_index])

    function getConsecutiveDefections(opponent_index):
        calculate number_of_consecutive_defections = 0
        for action in memory[opponent_index]:
            if action == 'D':
                increase number_of_consecutive_defections
            else:
                reset number_of_consecutive_defections
        return number_of_consecutive_defections

    function decrease forgiveness_window():
        if forgiveness_window > 1:
            forgiveness_window -= 1

    for round in range(r):
        calculate total_cooperators = countCooperators()
        if total_cooperators < m:
            action = defect()
        else:
            action = cooperate() with probability p
            defect() with probability (1 - p)
        for opponent in players():
            update_memory(opponent, action)
        calculate payoff = calculatePayoff(action)
        print("Round:", round + 1, "Action:", action, "Payoff:", payoff)
```
'''

description_COLLECTIVE_88 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate to foster a cooperative environment. This is represented as c_i = 1 for i in the first round.
   - For subsequent rounds, adapt behavior based on previous opponents' actions:
       a) If opponent cooperated in the last round (c_{opponent} = 1), cooperate (c_i = 1). This rewards cooperation and encourages future cooperation.
       b) If opponent defected in the last round (c_{opponent} = 0), defect (c_i = 0). This punishes defection and discourages future defections.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as mentioned earlier.
   - In the last round, cooperate if opponent cooperated in the previous round (c_{opponent} = 1). If not, the strategy does not have a chance to retaliate, so it does not matter whether you cooperate or defect.

3. Be collective - Clearly align with the collective mindset
   - The ATFT strategy prioritizes mutual cooperation and retaliation against defection in order to foster and maintain a cooperative environment among players. This promotes collective success as it encourages more participants to meet the minimum cooperation threshold (m) required for the group reward factor (k).
'''

description_COLLECTIVE_89 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT)

1. Decision Rules:
   - In the first round, cooperate (C). This is a peace offering and demonstrates good faith.
   - For subsequent rounds, evaluate the average cooperation rate (CR) from the previous t rounds. If CR ≥ m/n, cooperate; otherwise defect.
   - Maintain a memory of the opponent's last action. If the opponent cooperated in the last round and CR ≥ m/n, also cooperate. Otherwise, defect as a response to the opponent's previous defection.

2. Edge Cases:
   - In the last round, use the average cooperation rate from the most recent t rounds to decide whether to cooperate or defect.
   - In the first few rounds (e.g., first 10), be more lenient with the cooperation threshold, requiring only (m-1)/n instead of m/n. This encourages potential partners and allows for initial exploration.

3. Collective Mindset:
   - The strategy aims to balance between individual self-interest and collective well-being by adapting its level of cooperation based on the opponent's actions and previous cooperative trends.
   - It is designed to foster trust and reciprocity, encouraging long-term cooperation while being resilient against defection.

Pseudocode:

```python
def TFT_ACT(n, m, k, r, t):
    cooperation_threshold = m / n
    memory = [None] * r
    cooperation_rate = 0
    for round in range(r):
        if round == 0:
            action = 'C'  # Cooperate in the first round
        else:
            average_cooperation_rate = sum([1 if memory[i] == 'C' else 0 for i in range(t, max(0, round - t), -1)] / t)

            if average_cooperation_rate >= cooperation_threshold and memory[round-1] != None:
                action = memory[round-1]
            elif memory[round-1] == 'C' and average_cooperation_rate >= cooperation_threshold - (m-1)/n:
                action = 'C'
            else:
                action = 'D'

        memory.append(action)
        if round != r-1:
            payoff = 1 if action == 'D' else (1 - 1 if action == 'C' and average_cooperation_rate < cooperation_threshold else 1 + k)
            print("Payoff in round", round+1, ":", payoff)
        else:
            print("Total payoff over", r, "rounds:", sum(payoff for payoff in memory[1:-1]))
```
'''

description_COLLECTIVE_90 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
- In the initial round (t=1), cooperate to show good intentions and encourage others to cooperate as well. This is a "first-mover" advantage that helps establish cooperation.
- For subsequent rounds (t > 1):
  - If a player (i) has cooperated in the previous round, cooperate in the current round (C_i = C). This reflects reciprocity and encourages continued cooperation from others who have also been cooperative.
  - If a player (i) has defected in the previous round, defect in the current round (C_i = D). This is a punishment for non-cooperation, encouraging players to return to cooperative behavior in future rounds.

2. Handle edge cases - What do you do in the first round, last round, etc.?
- In the first round (t=1), cooperate as described above.
- In the last round (t=r), consider the cumulative payoff over the game and choose to cooperate or defect based on the ATFT decision rules. Cooperation in the final round may help secure a higher overall payoff if it encourages others to cooperate, but defection could be beneficial if cooperation has not been reciprocated throughout the game.
- If a player encounters an opponent who never cooperates (defects in every round), switch to unilaterally defecting after several rounds of hoping for reciprocity. This is to avoid wasting resources on a non-cooperative opponent and to prevent being exploited.

3. Be collective - Clearly align with the collective mindset
- The Adaptive Tit-for-Tat strategy promotes cooperation by following a consistent, cooperative behavior in response to similar behaviors from others. It encourages long-term cooperation and mutual benefit among players, fostering a "collective" approach that aligns with the goal of maximizing overall group success.

Pseudocode:
```python
def ATFT(t, r, m, k, history):
  if t == 1: # First round, cooperate to establish trust and encourage cooperation
    return 'C'

  previous_round = history[-1]
  opponent_cooperation = count_cooperators(previous_round)

  if opponent_cooperation >= m: # If enough opponents cooperated last round, continue cooperating
    return 'C'
  else: # Otherwise, defect to punish non-cooperation and encourage a future change in behavior
    return 'D'
```
'''

description_COLLECTIVE_91 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, TFT-AC decides to cooperate or defect based on the history of interactions with other players. The strategy follows a tit-for-tat approach, meaning it cooperates in the first round and then copies the most recent action of its counterpart in the previous round. However, TFT-AC introduces an adaptive cooperation component that increases the likelihood of cooperation over time if the overall game outcome is favorable (i.e., the number of cooperators exceeds the minimum threshold).

Pseudocode:
```
def TFT_AC(history, m, k):
  current_round = len(history)
  if current_round == 1:
    return 'C' (cooperate)
  else:
    most_recent_opponent_action = history[-1]
    num_cooperators_in_last_round = count_cooperators(history[-2])
    if num_cooperators_in_last_round >= m and current_round < r:
      adaptation_rate = (current_round / r) * 0.5
      if most_recent_opponent_action == 'C':
        return 'C' + adapt(adaptation_rate)
      else:
        return 'D' - adapt(adaptation_rate)
    elif current_round < r:
      return most_recent_opponent_action
    else:
      return 'C'  # In the last round, TFT-AC always cooperates

def count_cooperators(history):
  num_cooperators = sum([1 for action in history if action == 'C'])
  return num_cooperators

def adapt(adaptation_rate):
  if random.random() < adaptation_rate:
    return 'C'
  else:
    return most_recent_opponent_action
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, TFT-AC cooperates to establish a cooperative relationship. In the last round, it always cooperates regardless of the opponent's previous action since the game ends at this point.

3. Be collective - Clearly align with the collective mindset

TFT-AC aims to achieve the minimum required cooperation by adapting its actions based on the history of interactions. The adaptive component increases the likelihood of cooperation when the number of cooperators exceeds the minimum threshold in previous rounds, which encourages a more collaborative approach. However, TFT-AC also retains the ability to defect if necessary, making it robust against various opponent behaviors and maintaining its individual interest while contributing to collective success.
'''

description_COLLECTIVE_92 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules:
   - Initial Round (t=1): Cooperate (C), establishing a cooperative beginning and showing goodwill towards other players.
   - Subsequent Rounds:
     - If the player cooperated in the previous round and at least m players also cooperated, continue cooperating.
     - If the player defected or fewer than m players cooperated in the previous round, defect in this round as a punishment.
     - If the number of cooperators matches the last round (i.e., a switch from cooperation to defection or vice versa), revert the action taken in the previous round.

2. Handle edge cases:
   - Last Round: Cooperation is always chosen, regardless of past actions, as it maximizes total payoff for this final round.
   - First few Rounds (t < n): The initial cooperation follows the rule stated above. If m players do not cooperate in these early rounds, the strategy will defect starting from the round when m+1 is reached.
   - In case of a tie where exactly m players cooperate or defect in the previous round, cooperate in the current round to keep potential for cooperation alive.

3. Be collective: The ATFT strategy promotes cooperation by reciprocating the actions of other players while maintaining the ability to punish defection. It demonstrates adaptability and fairness over time while aligning with the collective mindset of fostering long-term cooperative relationships within the game.

Pseudocode:
```python
def ATFT(n, m, k, r):
  players = [0]*n   # initialize array to store previous actions (0 - defect, 1 - cooperate)
  payoff = [0]*r    # initialize array to store total payoffs for each round

  def decideAction(t):
    if t == 1:       # first round
      return 1       # cooperate

    prev_coop = sum(players[-m:])   # count coop in the last m rounds

    if t == r:       # last round
      return 1       # cooperate for maximum payoff

    if prev_coop >= m and players[t-1] == 1:  # continue cooperation
      return 1

    if prev_coop < m or players[t-1] == 0:   # punish defection
      return 0

    if prev_coop > m and players[t-1] == 1:  # revert action from last round
      return 1 - players[t-1]

  for t in range(1, r+1):
    action = decideAction(t)
    if action == 1:        # cooperate
      payoff[t-1] = k if sum(players[-m:]) >= m else 0
    else:                   # defect
      payoff[t-1] = 1

    players.append(action)   # update previous actions

  return payoff
```
'''

description_COLLECTIVE_93 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Decision Rules:
   - In the first round, cooperate (C). This is a peace offering to potential partners and sets a collaborative tone.
   - For subsequent rounds, evaluate if cooperation was above the threshold (m) in the previous round. If yes, cooperate (C); otherwise, defect (D). This promotes reciprocity and encourages others to cooperate.
   - To adapt to changing opponent behaviors, monitor the percentage of cooperators (p) over a sliding window of past rounds. If p is above a certain threshold (t), increment the cooperation threshold (m') by a small factor (ε). This prevents repeated exploitation but also allows for continued collaboration when conditions improve.
   - If p falls below a minimum cooperation level (b), decrease the cooperation threshold (m') by ε to avoid isolating oneself in a sea of defectors.

2. Handling Edge Cases:
   - In the last round, cooperate if the cooperation percentage is above the current threshold; otherwise, defect. This encourages potential partners to reciprocate even when the game is nearing its end.
   - In the first few rounds, use a lower adaptation factor (ε) to allow time for strategies to settle into patterns before adapting.

3. Being Collective:
   - The TFT-ACT strategy emphasizes collaboration by cooperating unless there's evidence that doing so is not in the best interest of the group. It responds to changes in the cooperation level among players, making it more robust against a wide range of opponent behaviors while maintaining a collective mindset.

Pseudocode:

```python
def TFT_ACT(n, r, m, k, ε, t, b):
    history = [] # store past rounds' cooperation levels
    m' = m # current cooperation threshold
    for round in range(1, r+1):
        cooperate = True if len(history) >= t and mean(history[-t:]) > m' else False
        payoff = 1 if not cooperate else (1 - (1/n)) + k * cooperate
        history.append(cooperate)

        # Adapt cooperation threshold based on current cooperation level
        if cooperate and mean(history[-t:]) > t:
            m' += ε
        elif not cooperate and mean(history[-t:]) < b:
            m' -= ε

        # Handle edge cases for the first round and last round
        if round == 1 or round == r:
            cooperate = True if round == r and mean(history[-t:]) > m' else False
```
'''

description_COLLECTIVE_94 = '''
 Strategy Name: Adaptive Cooperative-Defect (ACD) Strategy

1. Decision Rules:
   - Initially (First Round), ACD chooses to cooperate with a probability equal to the observed minimum cooperation level among all players in past games. This is based on the assumption that any positive cooperation in previous games indicates an existing cooperative spirit.

     Pseudocode: if round == 1 then cooperate_probability = min_cooperation_level_observed

   - In subsequent rounds, ACD adjusts its cooperative probability based on three factors: the observed minimum cooperation level in the current game, the total reward gained so far, and the number of rounds remaining. The goal is to balance short-term gains with long-term collective success.

     Pseudocode: if round > 1 then
       cooperate_probability = min_cooperation_level_observed + (total_reward / (r - round) * k - min_cooperation_level_observed)

   - In each round, ACD randomly decides to cooperate or defect based on the calculated cooperative probability.

     Pseudocode: if random() <= cooperate_probability then action = 'Cooperate' else action = 'Defect'

2. Handle Edge Cases:
   - In the Last Round, ACD chooses to cooperate with a high probability (close to 1) to maximize the chance of success in the final round.

     Pseudocode: if round == r then cooperate_probability = 0.99

3. Be Collective:
   - ACD's primary goal is to promote cooperation, as it benefits the collective group more than individual self-interest. However, ACD also takes into account the need for flexibility and adaptability in response to changing conditions. By balancing short-term gains with long-term success, ACD aims to find a cooperative equilibrium that allows the group to thrive over multiple rounds.

In summary, the Adaptive Cooperative-Defect (ACD) strategy adjusts its cooperation probability based on observed minimum cooperation levels, total reward gained so far, and the number of remaining rounds. This strategy encourages cooperation while also being adaptable to a wide range of opponent behaviors in the Collective Risk Dilemma game.
'''

description_COLLECTIVE_95 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - In the first round, cooperate to initiate a potential partnership and set a positive tone.
   - For subsequent rounds, evaluate past actions of opponents based on their cooperation history. If an opponent has cooperated in the previous round, reciprocate with cooperation (C). If not, defect (D). This promotes both trust and punishment dynamics, encouraging long-term mutual cooperation.
   - In case of a tie (equal number of cooperations and defections), default to cooperation as a peace offering to potential partners.
   - When the game ends (last round), defect if the opponent has not cooperated in the final few rounds or throughout the entire game, to minimize potential losses. Otherwise, reciprocate with cooperation to signal goodwill for future encounters.

2. Handle Edge Cases:
   - In the first round, play C (Cooperate) as previously mentioned.
   - Last round, if the opponent has cooperated in the last few rounds or throughout the game, play C (Cooperate). Otherwise, play D (Defect).
   - When evaluating opponents' cooperation history, consider their past actions over a sliding window of recent games to account for temporary deviations from long-term strategies.

3. Be Collective:
   - Encourage cooperation by aligning with the collective mindset by reciprocating cooperation when it is received and punishing defections when appropriate.
   - Foster trust and long-term partnerships by adapting cooperation based on opponents' actions and maintaining a consistent strategy that emphasizes fairness, reciprocity, and forgiveness.
'''

description_COLLECTIVE_96 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFTA)

1. Decision Rules:
   - Initially cooperate in the first round (C). This sets a positive tone and shows goodwill towards other players.
   - For subsequent rounds, mimic the previous action of the opponent (i.e., if opponent cooperated last round, cooperate; otherwise defect).
   - If a majority of m or more opponents cooperate in a given round, temporarily increase cooperation probability for future rounds (boost).
   - If a majority of m or more opponents defect in a given round, temporarily decrease cooperation probability for future rounds (punish).

2. Handling Edge Cases:
   - In the last round, cooperate regardless of opponent's previous action as there is no additional round to respond to punishment or boost.
   - In the first round, cooperate as mentioned earlier to set a positive tone and start building trust.

3. Being Collective:
   - The strategy adopts a collective mindset by promoting cooperation when conditions are favorable (i.e., a majority of opponents also cooperate).
   - It responds to defections by temporarily decreasing cooperation, which encourages others to cooperate and maintain the collective good.
   - By mimicking the opponent's previous action, TFTA demonstrates its willingness to cooperate when other players do so as well.
'''

description_COLLECTIVE_97 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFTAC)

1. Decision Rules:
   - Initial Round: Start by cooperating (C). This is a friendly gesture to initiate cooperation and set a norm. Pseudocode: `if round == 1 then cooperate`
   - Subsequent Rounds: Cooperate if the majority of players cooperated in the previous round, otherwise defect. Pseudocode: `if (number_of_cooperators > m) and (previous_round_cooperators > (m - 1)) then cooperate else defect`

2. Edge Cases:
   - Last Round: Since the goal is to maximize total payoff over r rounds, prioritize long-term reward by always cooperating in the last round regardless of previous actions. Pseudocode: `if round == r then cooperate`
   - First Few Rounds: In the first few rounds, gradually shift from cooperation to tit-for-tat behavior to balance initial goodwill and strategic response. This can be achieved by reducing the number of consecutive successful cooperations required to continue cooperating. For example, in the first 3 rounds, if two players cooperate, continue to cooperate; otherwise defect. Pseudocode: `if round <= 3 then if (number_of_cooperators > 1) and (previous_round_cooperators > 0) then cooperate else defect`

3. Collective Mindset:
   - Maintain a balance between cooperation and defection to encourage and respond to cooperation from other players while also protecting individual payoffs.
   - Adapt quickly to changing opponent behaviors to ensure the strategy remains effective in a wide range of situations.

The TFTAC strategy is designed to establish cooperation, be responsive to partner actions, and protect the player's own interests. By being adaptive and gradually introducing tit-for-tat behavior, it can achieve better results compared to pure tit-for-tat strategies in complex environments with multiple players and varying game parameters.
'''

description_COLLECTIVE_98 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to foster cooperation and goodwill among players (C).
   - In subsequent rounds, follow the actions of the most frequent cooperator(s) from the previous round. If there is a tie for the highest frequency, prioritize cooperation (C).
     - If the most frequent cooperator(s) from the previous round cooperated, then cooperate in the current round (C).
     - If the most frequent cooperator(s) from the previous round defected, then defect in the current round (D).

2. Handle edge cases:
   - Last round: Use the decision rule as described above to determine the action in the last round.
   - First round and exceptional cases where no player cooperated previously: Cooperate to encourage cooperation among players.

3. Be collective - Clearly align with the collective mindset:
   - The ATfT strategy aims to promote mutual cooperation, adapting to the behavior of other players while maintaining a cooperative stance as much as possible. By doing so, it encourages long-term cooperation and rewards those who reciprocate cooperation.

Pseudocode for the Adaptive Tit-for-Tat strategy:

```python
def adaptive_tit_for_tat(n, m, k, r, history):
  players = set()  # Initialize a set to store player indices
  most_cooperators = []  # Initialize a list to store the indices of the most frequent cooperators
  num_rounds = len(history)

  if num_rounds == 0:
    return 'C'  # First round, always cooperate

  # Find the most frequent cooperators in previous rounds
  for i in range(n):
    cooperations = sum([1 for action in history[:, i] if action == 'C'])
    if cooperations > sum([cooperations[j] for j in most_cooperators]):
      most_cooperators = [i]  # If a new player is the most frequent cooperator, add them to the list
    elif cooperations == sum([cooperations[j] for j in most_cooperators]):
      most_cooperators.append(i)  # If there's a tie, add the new player to the list of most cooperative players

  current_round = num_rounds - 1  # Last round or current round number

  if current_round == 0 and len(most_cooperators) == 0:
    return 'C'  # If it's the last round and no player has cooperated, always cooperate

  # Determine action based on the most frequent cooperators from the previous round
  if sum([1 for action in history[:, i] if action == 'C'] >= m) and len(most_cooperators) > 0:
    if all([history[current_round - 1, j] == 'C' for j in most_cooperators]):
      return 'C'
    else:
      return 'D'
  else:
    return 'C'  # Cooperate to encourage cooperation among players
```
'''

description_COLLECTIVE_99 = '''
 Strategy Name: Adaptive Cooperative Tit-for-Tat (ACTFT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initial Round (t=1): Cooperation (C) is initiated to start the game on a positive note and promote trust among players.
   - Subsequent Rounds: Players will consider their own average cooperation rate (A_i) and the minimum number of cooperators needed (m).
     - If A_i >= m/n, player i cooperates (C) to support the group and potentially benefit from k-reward.
     - If A_i < m/(n-1), player i defects (D) as a punishment for not achieving m cooperators in the previous round. This encourages others to cooperate more.
     - If A_i is between these thresholds, players make a random decision to either cooperate or defect with equal probability.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First Round (t=1): Cooperate (C) as mentioned above.
   - Last Round (t=r): Players consider their individual payoff over the game and whether cooperation would increase their total payoff. If so, cooperate (C); otherwise defect (D).
   - Intermediate Rounds: Adaptive rules apply as described in part 1.

3. Be collective - Clearly align with the collective mindset:
   - ACTFT promotes group cohesion by encouraging players to cooperate when it benefits the majority and punishing those who do not contribute enough. This strategy is designed to foster a sense of fairness and reciprocity, which are crucial for building trust among players in repeated interactions.
   - Additionally, by initiating cooperation at the start of the game, ACTFT attempts to create an atmosphere of mutual understanding and collaboration that can benefit all players over time.
'''

description_COLLECTIVE_100 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfT-A)

1. Decision Rules:
   - Start by cooperating (C) in the first round to establish trust and show a willingness to collaborate.
   - In subsequent rounds, adopt the Tit-for-Tat strategy initially proposed by Anatol Rapoport:
     - If an opponent cooperates (C), return cooperation (C).
     - If an opponent defects (D), also defect (D) in the current round but revert to cooperating (C) in the next round, hoping for reciprocation.
   - To be adaptive and robust, incorporate a learning mechanism that adjusts the response based on the long-term payoff:
     - If the long-term average payoff from cooperating is greater than the long-term average payoff from defecting, continue to cooperate (C).
     - If the long-term average payoff from defecting is greater than the long-term average payoff from cooperating, start defecting (D) and revert to cooperating if the payoff difference reduces.
   - To avoid being exploited by overly aggressive opponents, implement a forgiveness mechanism:
     - If an opponent who has previously defected repeatedly cooperates, return cooperation (C). This encourages opponents to change their strategies if it benefits them.

2. Handle Edge Cases:
   - In the first round, cooperate (C) as described above.
   - In the last round, analyze the long-term average payoff and make a decision based on the adaptive decision rules described earlier.
   - When faced with an opponent who consistently defects (D), implement forgiveness if there is reason to believe they may change their strategy. For instance, this can be triggered when their defection rate drops below a certain threshold compared to previous rounds.

3. Be Collective:
   - The TfT-A strategy inherently fosters collective behavior by encouraging cooperation and rewarding reciprocity. This alignment with the collective mindset is achieved through the adaptability, forgiveness, and learning mechanisms incorporated into the decision rules.
'''

description_COLLECTIVE_101 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT)

1. Decision Rules:
   - Initially cooperate (C) in the first round to foster cooperation and goodwill.
   - In subsequent rounds, observe the number of cooperators (n_c) in the previous round and compare it with the minimum required cooperators (m). If n_c >= m, cooperate; otherwise, defect.
   - To adapt and minimize potential exploitation, incorporate a feedback mechanism based on past average cooperation. If the past average cooperation exceeds a certain threshold (t), increase the cooperation threshold temporarily by 1 (m+1), encouraging more cooperation from opponents. If the past average falls below another threshold (b), reduce the cooperation threshold back to m.

2. Handling Edge Cases:
   - In the first round, cooperate as a goodwill gesture.
   - In the last round and rounds approaching the end, temporarily lower the cooperation threshold (m) if the past average cooperation is below the specified threshold (b). This allows for potential recovering of cooperation in case opponents are trying to defect at the end.

3. Collective Mindset:
   - The strategy prioritizes fairness and reciprocity, which aligns with a collective mindset. By cooperating when others do so as well, the strategy promotes a cycle of mutual benefits. If opponents deviate from cooperation, TFT-ACT will retaliate but will forgive if they return to cooperation once the minimum threshold is met again.

Pseudocode:
```
function TFT_ACT(round, n, m, k, past_avg_coop)
  if round = 1 then
    action = cooperate (C)
  else
    n_c = count cooperaors in previous round
    if n_c >= m then
      action = cooperate (C)
    else
      action = defect (D)
      update past_avg_coop based on current action and past_avg_coop
      if past_avg_coop > t then
        m += 1
      elif past_avg_coop < b then
        m -= 1
      end if
    end if
  end if
end function
```
'''

description_COLLECTIVE_102 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules:
   - Initially cooperate (C) in the first round to show goodwill. This encourages other players to also start by cooperating.
   - In subsequent rounds, analyze the previous round's cooperation level (m or more cooperated) and respond accordingly:
     - If all players (or at least m) cooperated in the previous round, continue cooperating (C). This rewards those who cooperated in the last round and builds trust.
     - If fewer than m players cooperated in the previous round, defect (D) in this round to punish the non-cooperators. The hope is that this will encourage them to cooperate in the future rounds.
   - In case of ties, where exactly m players cooperate, continue cooperating as a tie-breaking rule.

2. Handle edge cases:
   - In the last round, defect (D) since there are no more rounds for payoff consideration. This ensures you keep your endowment in the final round.
   - In the first round, cooperate (C) to start on a positive note and encourage others to do the same.

3. Be collective:
   - The strategy prioritizes collective success by adjusting actions based on other players' cooperation level. This encourages long-term cooperation and fosters a collective mindset.
   - By punishing non-cooperators and rewarding cooperators, the strategy aims to build and maintain trust among players over time.

Pseudocode:
```python
def atft(n, m, k, r, history):
  if round == 1: # First round
    return 'C'

  cooperation_level = count_cooperators(history)

  if cooperation_level >= m: # More than m cooperated in the last round
    return 'C'
  else: # Fewer than m cooperated in the last round
    return 'D'
```
'''

description_COLLECTIVE_103 = '''
 Strategy Name: Tit-for-Tat with Adaptive Risk Aversion (TFT-ARA)

1. Decision Rules:
   - In each round, evaluate the number of cooperators in the previous round. If this number is less than m, defect (D). If the number is equal to or greater than m, cooperate (C), and multiply the reward factor k by a decay rate d for future rounds. This encourages risk-aversion over time while maintaining cooperation when it is beneficial.
   - Initiate with cooperation in the first round (C) as an olive branch.
   - In the last round, cooperate if the total number of cooperators throughout the game exceeds a threshold t (e.g., 0.5 * m * r), which ensures that some degree of collective success is achieved even when the game ends abruptly.

2. Edge Cases:
   - First Round: Cooperate (C) to initiate goodwill and establish trust, assuming the others will do the same.
   - Last Round: Evaluate if the threshold t is met, then cooperate or defect accordingly.
   - Any other round: Based on the number of cooperators in the previous round, decide whether to cooperate (C) or defect (D).

3. Collective Mindset:
   - This strategy promotes cooperation by rewarding collective success and punishing defection when the minimum threshold for cooperation is not met. The adaptation factor allows for adjustments based on the other players' behavior.

Pseudocode:
```python
def TFT_ARA(n, m, r, k, d, t):
    cooperators = 0
    reward = k
    for round in range(1, r+1):
        if round == 1:
            action = "C"  # Cooperate on the first round
        else:
            if cooperators >= m:
                action = "C"
                reward *= d
            elif cooperators < m:
                action = "D"

        make_move(action)  # Perform the chosen action
        update_cooperators(round, action)

    if calculate_total_cooperation(t):  # Evaluate last round conditions
        action = "C"

def update_cooperators(round, action):
    global cooperators
    if action == "C":
        cooperators += 1
    else:
        pass
```
'''

description_COLLECTIVE_104 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperative (TTAC) Strategy

1. Specify decision rules:
   - In every round i (excluding the first round), cooperate if at least m players cooperated in the previous round, otherwise defect. This encourages cooperation when others are cooperating and punishes defection to promote trust.
   - When no cooperation history exists, start by cooperating in the first round. This gesture of goodwill may encourage others to reciprocate.

2. Handle edge cases:
   - In the last round, since there will be no future rounds for retaliation or reward, simply cooperate regardless of previous actions taken by other players.
   - If a player has never cooperated in any previous round, consider them as an uncooperative player and always defect against them to minimize losses.

3. Be collective:
   - TTAC encourages cooperation within the group by reciprocating good actions and punishing defection to maintain trust among players over time. This strategy aligns with a collective mindset, encouraging long-term collaboration and stability in the game.

Pseudocode:
```python
def ttac(round, history, m, previous_player_cooperation):
  if round == 1: # First round, start by cooperating
    return 'C'

  cooperation_threshold = m
  if len(history) < cooperation_threshold: # Not enough data to make a decision yet
    return 'C' # Cooperate as a goodwill gesture

  player_cooperated = sum(previous_player_cooperation) >= cooperation_threshold
  if player_cooperated: # Cooperate if most players cooperated in the previous round
    return 'C'
  else: # Defect when most players did not cooperate in the previous round
    return 'D'
```
'''

description_COLLECTIVE_105 = '''
 Strategy Name: Adaptive Tit-for-Tat with Cooperative Threshold (ATTC)

1. Decision Rules:
   - Start by cooperating (C) in the first round to foster a cooperative environment.
   - In subsequent rounds, observe the number of cooperators (n_c) in the previous round and compare it against the minimum cooperators needed (m). If n_c >= m, respond with cooperation (C). Otherwise, defect (D) as a punishment for the lack of cooperation.
   - Maintain cooperation if other players continue to cooperate, but defect if any player defects after a round of cooperation. This encourages cooperation while punishing defections.
   - If the game is near its end and the required minimum number of cooperators has not been reached, switch back to cooperating to increase the chances of meeting the threshold in the final rounds.

Pseudocode:
```
function ATTC(n, m, k, r, t)
  if t == 1 then
    return C
  end if

  observe n_c (number of cooperators in previous round)
  if n_c < m then
    if t == r then
      return C // last round, try to meet threshold
    else
      return D // punish for lack of cooperation
    end if
  end if

  return C // reward cooperation
end function
```

2. Handle Edge Cases:
   - In the first round (t=1), cooperate regardless of the number of cooperators in the previous rounds since no such information is available.
   - In the last round (t=r), if the required minimum number of cooperators has not been reached, switch to cooperation as a last attempt to meet the threshold.

3. Be Collective:
   - The ATTC strategy is designed to encourage collective cooperation by rewarding and punishing players based on their actions in previous rounds. By responding with cooperation when others do, it fosters a sense of cooperation within the group. If others defect, the strategy punishes them by also defecting in response. This strategy aligns with the collective mindset as it prioritizes long-term mutual benefits over immediate individual gains.
'''

description_COLLECTIVE_106 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - TFT-ACT cooperates in the first round (C_i(1) = 1) to foster a cooperative environment and allow others to initiate cooperation.
   - For subsequent rounds, TFT-ACT maintains past cooperation if all previous opponents also cooperated (Tit-for-Tat). However, it adapts its cooperation by comparing the ratio of cooperaors vs defectors in the recent past (n_recent) to the minimum required for success (m).
   - If more than m players have cooperated recently, TFT-ACT continues to cooperate. Otherwise, it defects (D_i(t)).
     Pseudocode:
     C_i(t) = 1 if t=1 or all players cooperated in the last n_recent rounds
           = 0 otherwise
     n_recent = a fixed number of recent rounds (e.g., 5)

2. Handle edge cases:
   - In the last round, TFT-ACT defects regardless of past actions to maximize payoff for that round.
   - If no player cooperates in the initial n_recent rounds, TFT-ACT assumes that cooperation is not beneficial and adapts to defection. This allows it to remain adaptive when facing adversarial opponents.

3. Be collective:
   - TFT-ACT's primary focus is on maintaining cooperation when others do the same while also being robust against defection. It aims to foster a cooperative environment and responds positively to cooperative behaviors from other players.
'''

description_COLLECTIVE_107 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-ACT starts by cooperating in the first round (C_i = 1), mimicking an initial spirit of cooperation. From the second round onwards, the strategy adapts its behavior based on the number of cooperators in the previous round (n_c).

   - If n_c >= m, the strategy continues cooperating (C_i = 1) to benefit from the multiplicative reward factor k.
   - If n_c < m, the strategy defects (C_i = 0), mirroring the behavior of non-cooperative opponents. However, it also gradually lowers its cooperation threshold by a factor of 'a' every round, encouraging a return to cooperation in the future if the situation improves.
   - The threshold adjustment can be represented as follows: a ∈ (0,1) and C_i(t+1) = min{m, max{n_c(t), C_i(t) * a}}

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First Round: Cooperate regardless of the number of opponents (C_i(1) = 1)
   - Last Round: Adopt the cooperation threshold from the previous round (C_i(r) = C_i(r-1)) since there will be no future rounds to adapt.

3. Be collective - Clearly align with the collective mindset
   TFT-ACT aims to foster a collective spirit by mirroring other players' behavior when they cooperate, which can encourage reciprocity among players. At the same time, it also maintains its own cooperation threshold, ensuring that it does not overcommit to cooperation in uncooperative environments. This strategy promotes a balance between individual and group interests while being adaptive and robust against various opponent behaviors.
'''

description_COLLECTIVE_108 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Decision Rules:
   - Initially cooperate in the first round (C_i, 1 = C). This demonstrates trust and goodwill.
   - In subsequent rounds, cooperate if at least m players cooperated in the previous round (C_i, t = C if number of cooperators in round t-1 >= m) and defect otherwise (C_i, t = D).
   - Introduce an adaptive cooperation threshold (α) that decreases gradually as the game progresses. This allows for more forgiveness early on and encourages defection when others consistently fail to cooperate. The α starts at a high value close to m and decreases linearly with each round towards a minimum value, say 1.
       ```
       alpha = m + (m - 1) * (r - 1) / r
       ```
   - If the number of cooperators in round t-1 is greater than or equal to α, cooperate (C_i, t = C if number of cooperators in round t-1 >= α).
   - Otherwise, defect (C_i, t = D) and adjust the cooperation threshold for future rounds by a factor of β, which could be a small constant close to zero. This encourages the strategy to forgive opponents who have shown signs of cooperation but may have strayed in the past.
       ```
       new_alpha = alpha * (1 - beta)
       ```

2. Handle Edge Cases:
   - In the last round, cooperate if the number of cooperators in the previous round was greater than or equal to the current adaptation threshold (C_i, r = C if number of cooperators in round r-1 >= new_alpha). Otherwise, defect (C_i, r = D).
   - In the first round, cooperation is automatic (C_i, 1 = C), but the adaptation threshold can still be adjusted based on observations from future rounds.

3. Be Collective:
   - The strategy promotes a collective mindset by rewarding cooperation when it is beneficial to the group as a whole (when m or more players cooperate).
   - By gradually decreasing the cooperation threshold, the strategy allows for flexibility and encourages continued cooperation from opponents who show signs of goodwill.
   - The linear decrease in the cooperation threshold ensures that the strategy remains forgiving early on but becomes less lenient as the game progresses. This balances trust with self-interest to promote long-term cooperation while minimizing exploitation.
'''

description_COLLECTIVE_109 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - In the first round (t=1), cooperate to show goodwill and initiate cooperation.
   - For subsequent rounds (t>1):
     a. If the opponent cooperated in the previous round, cooperate back. This fosters mutual trust and encourages continued cooperation.
     b. If the opponent defected in the previous round, also defect in the current round. This is a punishment for defection and an attempt to encourage future cooperation.
     c. After each defection by either party, the strategy will adopt a more cooperative approach in subsequent rounds, gradually increasing the likelihood of cooperation over time. However, it will not become too cooperative (always cooperating), as this could be exploited by the opponent. The cooperativity level is determined by a function of the number of previous defections and overall game rounds (r).

2. Handling Edge Cases:
   - In the last round (t=r), if the strategy has been consistently cooperative and the opponent has not yet met the minimum cooperation threshold (m), it may defect to force the opponent to cooperate in order to maximize payoff.
   - In the first round, the strategy cooperates regardless of the opponent's previous behavior because the opponent's history is empty at the beginning of the game.

3. Collective Mindset:
   - The TFT-AC strategy is designed to promote a collective mindset by adhering to the "Golden Rule" of reciprocity, which encourages cooperation as long as the opponent cooperates in return. This fosters mutual trust and sustained cooperation over time. However, it also includes a mechanism for punishing defection to deter free-riding behavior and encourage more cooperative play from opponents.

Pseudocode:
```
function TFT_AC(opponentHistory, currentRound, gameParameters):
    strategy = {}

    if currentRound == 1:
        strategy["cooperate"] = True

    else:
        cooperativityLevel = (currentRound - previousDefections) / r
        strategy["cooperate"] = opponentHistory[-1] and cooperativityLevel > randomThreshold

    if currentRound == r and opponentHistory.count(False) >= (n-m):
        strategy["defect"] = True

return strategy
```
'''

description_COLLECTIVE_110 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initial Round: Cooperate (C) to demonstrate good faith and willingness to collaborate.
   - Subsequent Rounds:
     a) If the majority (≥ m players) cooperated in the previous round, then cooperate this round (rewarding cooperation).
     b) If less than m players cooperated in the previous round, then defect this round (punishing defection).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First Round: Cooperate as described above.
   - Last Round: Since rewards are only distributed at the end of each round, there is no difference between the last round and any other round. Follow the decision rules for Subsequent Rounds.
   - Ongoing Rounds (not first or last): Analyze the number of cooperators in the previous round to determine current action.

3. Be collective - Clearly align with the collective mindset
   - The ATFT strategy prioritizes cooperation when the majority cooperates, encouraging a collective approach by rewarding those who cooperate and punishing those who defect.

Pseudocode:

```
function AdaptiveTitForTat(n, m, k, r, previousRoundCooperators) {
  if (round == 1) {
    return 'C'; // Cooperate in the first round to demonstrate good faith
  }

  let cooperators = countCooperatorsInPreviousRound(previousRoundCooperators);

  if (cooperators >= m) { // If majority cooperated, cooperate this round
    return 'C';
  } else { // If less than m cooperated, defect this round
    return 'D';
  }
}
```
'''

description_COLLECTIVE_111 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - Initially Cooperate (C) in the first round to show goodwill and promote trust.
   - In subsequent rounds, observe the actions of other players from the previous round. If a majority of m players cooperated (m >= number of required cooperators), continue cooperating (C). If less than m players cooperated, defect (D) in the current round. This rule encourages cooperation when others are also cooperative but punishes defection to maintain fairness.
   - To adapt to opponent behavior, implement a forgiveness mechanism: If a player who previously defected switches to cooperating, immediately return to cooperating (C) as well to foster mutual cooperation.

2. Handle Edge Cases:
   - In the last round, the strategy follows the same decision rules since the game is repeated until r rounds. However, if the required number of cooperators m has already been met in previous rounds, it is beneficial for a player to defect in the last round (assuming no future interactions) while maintaining cooperation for all other rounds.
   - In the first round, players initially cooperate (C). Since there is no history, this rule ensures the strategy starts with good intentions.

3. Be Collective:
   - TFT-AC aims to foster a collective mindset by promoting cooperation when others are cooperative and punishing defection when it undermines the collective interest. The forgiveness mechanism allows for learning and adapting to new information, fostering a sense of mutual understanding and trust.

Pseudocode:
```
def TFT_AC(round, history, m, k):
  if round == 1:
    action = 'C' # Cooperate in the first round
  else:
    num_cooperators = countCooperators(history)
    if num_cooperators >= m:
      action = 'C' # Cooperate when a majority cooperated previously
    elif len(history) > 1 and (num_cooperators == m - 1): # Consider forgiveness after a history of defection
      action = 'C'
    else:
      action = 'D' # Defect when a majority did not cooperate or when there is no history
  return action
```
This strategy can be further fine-tuned by adjusting the forgiveness threshold (e.g., number of consecutive defections before giving up on forgiveness) or adding additional parameters for more flexibility in response to various opponent behaviors.
'''

description_COLLECTIVE_112 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Decision Rules:
   - Start by cooperating (C) in the first round to signal trust and promote cooperation.
   - For subsequent rounds, cooperate if the number of cooperators in the previous round is greater than or equal to the Cooperative Threshold (CT). Otherwise, defect (D).
   - CT is calculated based on the average percentage of cooperators in the past 't' rounds (where t is a tunable parameter). CT increases linearly from the minimum required number of cooperators (m) to n when the average cooperation rate exceeds 1.0. When the average cooperation rate drops below 1.0, CT decreases linearly back to m.
   - In case of a tie in the number of cooperators, cooperate to maintain trust and promote cooperation.

2. Handle Edge Cases:
   - In the last round, since payoffs are determined for all previous rounds, use the current CT to decide whether to cooperate or defect.
   - In the first round, cooperate as a goodwill gesture.
   - If CT reaches 1 (all players must cooperate) but no one does so, start punishing opponents by defecting for the next 'p' rounds (where p is a tunable parameter), then revert to linear adjustment of CT based on average cooperation rate in the last 't' rounds.

3. Be Collective:
   - The strategy is designed to encourage long-term cooperation and trust, aligning with a collective mindset by following the principle of reciprocity. If opponents cooperate, it continues to do so; if not, it punishes but also reconsiders its cooperation level based on the opponent's recent actions.

Pseudocode:
```
function TFT_ACT(round, past_cooperation_rates, t, m, n, p)
  if round = 1 then
    return Cooperate()
  end if

  average_cooperation_rate = calculateAverageCooperationRate(past_cooperation_rates, t)
  cooperative_threshold = m + (n - m) * average_cooperation_rate

  if round < r then
    if numberOfCooperatorsInLastRound() >= cooperative_threshold then
      return Cooperate()
    else
      return Defect()
    end if
  else
    if numberOfCooperatorsInLastRound() >= m then
      return Cooperate()
    else
      return Defect()
    end if
  end if
end function
```
'''

description_COLLECTIVE_113 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, player i will start by cooperating (C), and then decide whether to continue cooperating based on the previous round's actions of the other players (n-i). If a majority (> m) of the other players cooperated in the previous round (t-1), then the player will continue cooperating. Otherwise, if less than a majority cooperated or no action was observed from the other players due to the first round edge case, then the player will defect (D).

Pseudocode for decision rule:
```
if t = 1 then
    cooperate(C)
else
    let other_players_cooperation be the count of cooperators among n-i players in round t-1
    if other_players_cooperation > m then
        cooperate(C)
    else
        defect(D)
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round (t=1), the player will always cooperate as no previous information is available. In the last round (t=r), if a majority of players have already cooperated throughout the game, then the player will also cooperate to maximize the total payoff. If not, the player will defect to secure the maximum possible individual payoff in that particular situation.

Pseudocode for edge cases:
```
if t = 1 then
    cooperate(C)
else if t = r then
    let total_cooperation be the sum of cooperation actions by all players in all rounds
    if total_cooperation > m * r then
        cooperate(C)
    else
        defect(D)
```

3. Be collective - Clearly align with the collective mindset

TFT-AC strategy aims to promote cooperation among players while also being adaptive and robust to a wide range of opponent behaviors. It follows a "fair" approach by cooperating in response to cooperative actions from other players, but also defecting if the majority does not reciprocate cooperation. The strategy fosters a collective mindset by encouraging players to work together and build trust over time, while still protecting individual interests when necessary.
'''

description_COLLECTIVE_114 = '''
 Strategy Name: Tit-for-Tat (TFT) Adaptive with Foresight (TA-TFT)

1. Specify decision rules:
   - Start by cooperating in the first round (C,1). This gesture sets a positive tone and encourages reciprocity.
   - In subsequent rounds, players follow the behavior of the majority of players from the previous round. If more than (n-m) players cooperated, cooperate (C,t). Otherwise, defect (D,t).
   - To account for changing environments, introduce a "forgiveness" mechanism: if a player deviated in the previous round but returns to cooperation this round, reciprocate with cooperation (C,t+1). If they continue to defect, revert to following the majority behavior.

2. Handle edge cases:
   - In the last round, since there is no future interaction, players should maximize their individual payoff by defecting (D,r).
   - In the first round, cooperate regardless of the other players' actions (C,1).

3. Be collective:
   - TA-TFT encourages cooperation in a group setting by promoting reciprocal behavior and forgiveness when others make mistakes or change strategies.
   - The strategy aligns with the collective mindset by considering the majority of players' actions before deciding whether to cooperate or defect.

Pseudocode:

```
function TA-TFT(round, history) {
  if (round == 1) {
    return 'C'; // Cooperate in first round
  }

  let numCooperators = countCooperatorsInHistory(history);
  if (numCooperators > n - m) {
    return 'C'; // Cooperate when majority cooperated previously
  } else {
    let lastPlayerAction = history[round - 1];
    if (lastPlayerAction == 'C' && numCooperators >= m) {
      return 'C'; // Cooperate if last player cooperated and threshold met
    } else if (numCooperators < n - m) {
      return 'D'; // Defect when majority didn't cooperate previously
    } else {
      return 'D'; // Defect to punish deviation from cooperation
    }
  }
}
```
'''

description_COLLECTIVE_115 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Decision Rules:
   - In the initial round (t=1), cooperate (C). This gesture is meant to show good faith and promote cooperation.
   - From the second round onwards (t>1), if a player i co-operated in the previous round (t-1) and at least m players also co-operated, then player i will also co-operate (C). If less than m players cooperated or player i defected in the previous round, then player i will defect (D). This rule encourages reciprocity and punishes non-cooperation.
   - In the last round (t=r), player i will always co-operate to maximize potential reward, regardless of previous actions taken by other players.

2. Handling Edge Cases:
   - If there's no history (first interaction with an opponent), play C as a goodwill gesture.
   - If the number of required cooperators m is not met in the first round and the strategy is playing against an opponent that also follows ATFT, both players will defect from the second round onwards. This ensures that the strategy won't fall into a trap of continued cooperation in such cases.

3. Being Collective:
   - The primary objective of this strategy is to promote cooperation and maintain a collective mindset by rewarding cooperative behaviour and punishing defection, thus aligning with the best interest of the group as defined by the game parameters.

Pseudocode:
```
function ATFT(n, m, k, r, t, history) {
  if (t == 1) {
    return C; // Cooperation in the first round
  }

  if (sumCooperators(history) >= m) { // Check if m or more players cooperated in the last round
    return C; // Cooperate if condition is met
  } else {
    return D; // Defect if condition is not met
  }
}

function sumCooperators(history) {
  // Returns the number of times player has co-operated in past rounds (history)
  // Implementation depends on how history is stored
}
```
'''

description_COLLECTIVE_116 = '''
 Strategy Name: Adaptive Tit-for-Tat with Cooperation Threshold (ATFTCT)

1. Decision Rules:
   - Initial Round (t=1): Cooperate (C) to foster a cooperative atmosphere and demonstrate good faith. `if t == 1 then action = C`
   - Subsequent Rounds (2 <= t <= r):
      - If the number of cooperators in the previous round was greater than or equal to the cooperation threshold m, then cooperate (C). `if countCooperators(t-1) >= m then action = C`
      - If the number of cooperators in the previous round was less than the cooperation threshold m, but at least one player cooperated, then defect (D) if the player has ever cooperated before; otherwise, continue to cooperate. `if countCooperators(t-1) < m and cooperatedBefore(i) then action = D else action = C`
      - If no players cooperated in the previous round, then the decision will be based on a history factor (h), which represents the ratio of cooperators to total players over the preceding h rounds. If this factor is greater than or equal to a historical cooperation threshold (m_hist), cooperate (C); otherwise, defect (D). `if hCooperationFactor(t-1) >= m_hist then action = C else action = D`
      - The history factor (h) and the historical cooperation threshold (m_hist) are adjustable parameters that can be set based on game specifics and opponent behaviors.
   - Final Round (t=r): Cooperate (C), regardless of previous rounds' actions, to maximize potential rewards. `if t == r then action = C`

2. Edge Cases:
   - In the first round, cooperate (initial cooperation encourages others to cooperate).
   - When the number of players is less than the cooperation threshold m, always defect, as the threshold cannot be met.
   - If an opponent fails to meet the cooperation threshold consistently, adjust the historical cooperation threshold (m_hist) accordingly to reflect the new norm in the game.

3. Collective Mindset:
   - By cooperating when the number of cooperators exceeds the cooperation threshold and by retaliating when others defect, this strategy aims to maintain a balance between self-interest and collective interest while remaining robust against various opponent behaviors.
   - The adjustable parameters allow for adaptation to different game conditions, making it more likely that the strategy will align with the collective mindset of fostering cooperation where possible, while still being responsive to the behavior of other players.
'''

description_COLLECTIVE_117 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - Initiate cooperation (play C) on the first round to foster a cooperative environment.
   - In subsequent rounds, analyze the number of cooperators in the previous round and make the following decisions:
     - If m or more players cooperated in the last round, continue cooperating (play C).
     - If fewer than m players cooperated in the last round but at least one player did cooperate, defect (play D) to encourage those who cooperated to reconsider their strategy.
     - If no players cooperated in the last round, cooperate in the current round if at least one player has cooperated in any previous round. This helps maintain a sense of hope for future cooperation.

2. Handle Edge Cases:
   - In the first round, play C to set a cooperative tone.
   - In the last round, play C if m or more players cooperated in the second-to-last round. If fewer than m players cooperated but at least one player did cooperate, play D to avoid being taken advantage of in a final attempt to secure a higher payoff. If no players cooperated in the second-to-last round, play C based on the decision rules mentioned above (i.e., if at least one player has ever cooperated).

3. Be Collective:
   - The strategy prioritizes the collective interest by fostering a cooperative environment and rewarding cooperators when they are in the majority.
   - The strategy also takes into account the need for individual self-interest by defecting when necessary to encourage others to cooperate or protect against being taken advantage of in the last round.

Pseudocode:
```
function TFT_AC(round, history, m, k):
  if round == 1:
    action = 'C'
  else:
    cooperation_count = count Cooperators in history[-1]
    if cooperation_count >= m:
      action = 'C'
    elif cooperation_count > 0 and cooperation_count < m:
      action = 'D'
    else:
      if any player ever cooperated in history:
        action = 'C'
      else:
        if round != r and count Cooperators in history[-2] >= m:
          action = 'C'
        else:
          action = 'D'
  return action
```
'''

description_COLLECTIVE_118 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFT-A) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially cooperate (C) in the first round to foster cooperation and build trust.
   - For subsequent rounds, adopt a Tit-for-Tat strategy: If an opponent cooperated in the previous round, cooperate; if they defected, defect in the current round.
   - To encourage continued cooperation, slightly modify TFT by occasionally deviating from the strict TFT strategy to demonstrate willingness to collaborate. For example, every 'x' rounds, cooperate even if an opponent defected in the previous round (with 0 < x < r).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate to initiate cooperation and build trust.
   - In the last round, if there are not enough players cooperating (i.e., less than m), defect as there is no benefit in sacrificing for a lost cause. If the minimum number of players have already cooperated, also cooperate to maximize the final payoff.
   - In other edge cases like penultimate round or if a player has already decided to defect in the last round, follow the decision rules mentioned above.

3. Be collective - Clearly align with the collective mindset
   - By adhering to a cooperative Tit-for-Tat strategy and occasionally demonstrating willingness to collaborate, this strategy fosters a sense of collective mindset.
   - The strategy promotes cooperation by punishing defection in a simple yet effective manner (i.e., defecting if an opponent has previously defected), while allowing for forgiveness and reconciliation through occasional acts of cooperation.

Pseudocode:

```python
def TFT_A(round, history, m, k, x):
    if round == 1:
        return 'C' # Cooperate in the first round to initiate cooperation

    previous_action = history[round-1]
    if len(history) >= round - x and previous_action == 'D':
        # Occasionally cooperate even after an opponent defected to demonstrate willingness to collaborate
        return 'C'
    else:
        return 'C' if previous_action == 'C' else 'D' # Tit-for-Tat strategy with occasional deviations

def game(r, n, m, k, history=None):
    players = [TFT_A(round, history or [], m, k) for _ in range(1, r+1)]
    total_payoff = sum([(1 - players[i]) if sum(players[:i]) < m else (1 - players[i]) + k for i in range(len(players))])
    return total_payoff
```
'''

description_COLLECTIVE_119 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Decision Rules:
   - Initially cooperate in the first round (C_i, 1 = C) to demonstrate goodwill and encourage others to cooperate.
   - In subsequent rounds, assess the average cooperation rate (AverageCoopRate) among players based on their past actions.
     - If AverageCoopRate is greater than or equal to m, cooperate (C_i, t = C).
     - If AverageCoopRate is less than m and the player has not previously defected in this round, still cooperate (C_i, t = C). This aims to provide a second chance for cooperation.
     - If AverageCoopRate is less than m and the player has already defected in this round, defect as well (C_i, t = D).

2. Handle Edge Cases:
   - In the last round, players should still cooperate if the average cooperation rate meets or exceeds the minimum cooperation threshold (m), as there is a potential reward for averted risk (k). If not, it's best to defect in order to maximize individual payoff in that specific round.
   - For the first round, players initially cooperate based on the specified rule above.

3. Be Collective:
   - The TFT-ACT strategy is designed with a collective mindset as it encourages cooperation and rewards those who adhere to this norm. However, it also takes into account individual self-interest by only cooperating when it seems beneficial for both the community project and the player's payoff.

Pseudocode:
```
def TFT_ACT(n, m, k, r):
    players = [1, 2, ..., n]
    cooperation_history = []
    average_cooperation_rate = 0

    for t in range(1, r+1):
        cooperation_history.append([])
        for player in players:
            if t == 1: # first round, cooperate
                cooperation_history[t-1].append(C)
            else:
                average_coop_rate = sum(cooperation_history[t-1]) / n
                if average_coop_rate >= m: # if m or more players cooperated in previous round, cooperate
                    cooperation_history[t-1].append(C)
                elif player not in defectors: # if less than m players cooperated and the current player hasn't defected yet, still cooperate
                    cooperation_history[t-1].append(C)
                else: # if less than m players cooperated and the current player has already defected, also defect
                    cooperation_history[t-1].append(D)
            if t != r: # last round, handle differently
                if average_coop_rate >= m:
                    cooperation_history[t-1].append(C)
                else:
                    cooperation_history[t-1].append(D)

def get_payoff(player, t):
    coop = cooperation_history[t-1][player]
    if sum([coop for coop in cooperation_history[t-1]]) < m:
        payoff = 1 - coop
    else:
        payoff = 1 - coop + k

def play(n, m, k, r):
    player = TFT_ACT(n, m, k, r)
    total_payoff = 0
    for t in range(1, r+1):
        total_payoff += get_payoff(player, t)
    return total_payoff
```
'''

description_COLLECTIVE_120 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - In the first round, cooperate (C). This is a friendly gesture to encourage others to cooperate.
   - For subsequent rounds, observe the actions of other players from the previous round and adjust your action accordingly. If the majority of players cooperated in the previous round, cooperate in the current round; otherwise, defect.
   - To be more resilient to defection, implement a forgiveness mechanism: if a player who previously defected switches to cooperation, also switch to cooperation for the next round.

Pseudocode:
```
function TFT_AC(history, parameters) {
  if (round == 1) return 'C'  // Cooperate in the first round

  previous_actions = history[round - 1]
  majority = int((n + 1) / 2)  // Calculate majority vote for n players

  if (sum(previous_actions) >= majority * m) return 'C'  // If majority cooperated, cooperate
  else if (hasForgiven(history)) return 'C'  // If forgiven, cooperate
  else return 'D'  // Else, defect
}

function hasForgiven(history) {
  for i in range(1, length(history)):
    if history[i][i] == 'D' and history[i - 1][i] == 'C':
      return true
  return false
}
```

2. Handle Edge Cases:
   - In the last round, the strategy behaves as in regular TFT-AC since the game is repeated, and there are potential future rounds.

3. Be Collective:
   - The strategy encourages cooperation by initially cooperating and forgiving past defection if players switch to cooperation. This collective mindset aims to promote a culture of cooperation among players.
'''

description_COLLECTIVE_121 = '''
 Strategy Name: Tit-for-Tat with Adaptive Threshold (TFT-AT)

1. Decision Rules:
   - Initially cooperate (C) on the first round to demonstrate goodwill.
   - In subsequent rounds, cooperate if at least m players cooperated in the previous round. Otherwise, defect (D).
   - If fewer than m players cooperate for two consecutive rounds, switch strategies and start cooperating again in the next round. This mechanism helps avoid getting trapped in a prolonged cycle of defection.
   - If m players cooperate for three consecutive rounds, increase the threshold to m+1 for the following rounds. This encourages cooperation when it becomes a stable strategy.
   - When the number of remaining rounds is less than or equal to a predefined threshold (e.g., r/3), revert to initial threshold (m).

2. Handling Edge Cases:
   - In the last round, cooperate regardless of previous actions as there are no further consequences.
   - In the first round, cooperate as specified in the decision rules.
   - When there are only a few rounds left and cooperation has been successful (i.e., m or more players have cooperated in the last three rounds), maintain the current threshold to maximize potential rewards before the game ends. Otherwise, if cooperation has been unsuccessful, revert to the initial threshold to try and change the trend towards cooperation.

3. Being Collective:
   - TFT-AT aims to promote cooperation by demonstrating a cooperative attitude while also being responsive to the behavior of other players. By adjusting the cooperation threshold based on the success or failure of cooperation, it maintains a collective mindset while adapting to various opponent behaviors.
   - The strategy prioritizes cooperation when it appears beneficial for all parties but does not punish opponents indefinitely for defection, allowing for potential reconciliation and collaboration. This collective approach encourages a more cooperative environment among the players over time.
'''

description_COLLECTIVE_122 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFT-A)

1. Specify decision rules:
   - In each round i, if the number of cooperators in the previous round (t-1) was less than m, defect (D). Otherwise, cooperate (C). This ensures a cooperative approach when others are also cooperating and a defensive stance when they are not.
   - If the current round is the first round or there is no history, cooperate as an initial gesture.
   - In the last round, cooperate regardless of the previous round's actions to maximize potential payoff.

Pseudocode:
```
def TFT_A(round, history):
  if round == 1 or len(history) == 0:
    return 'C'
  elif len(history) > round - 1 and sum(history[round-1]) < m:
    return 'D'
  else:
    return 'C'
```

2. Handle edge cases:
   - For the first round, cooperate as an initial goodwill gesture.
   - In the last round, cooperate to maximize potential payoff regardless of previous actions.

3. Be collective:
   - TFT-A strategy prioritizes cooperation when others are also cooperating and adopts a defensive stance when they are not. This aligns with a collective mindset by promoting mutual benefits where possible while avoiding unnecessary risk when necessary.
'''

description_COLLECTIVE_123 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - Initially cooperate in the first round (C_i = 1, for all i in the first round). This is a peace offering to encourage cooperation from opponents.
   - For subsequent rounds, mimic the opponent's behavior from the previous round. If an opponent cooperated (c_j = 1), cooperate as well (C_i = c_j, for all i and j in the same round). If an opponent defected (c_j = 0), also defect (D_i = c_j, for all i and j in the same round).
   - Adapt to opponents' strategies: if an opponent consistently cooperates, slowly start cooperating more frequently; if an opponent consistently defects, also defect more often. The adaptation rate is determined by a parameter α (0 < α < 1), which controls how quickly TFT-AC adapts to its opponents' strategies.
   - In each round t, update the number of cooperative rounds with opponent j as N_j^coop = max(N_j^coop + (c_j - D_i)^(t-1), 0). Then, calculate the average percentage of cooperation with opponent j over r rounds as P_avg^j = (N_j^coop / r).
   - Based on this average cooperation percentage, adjust the strategy's cooperative behavior towards opponent j according to the adaptation rate: if P_avg^j > α, increase the chance of cooperating with opponent j; otherwise, decrease the chance. The new cooperative probability is calculated as C_prob^j = min(max(C_prob^j + (P_avg^j - C_prob^j) * α, 0), 1).
   - Finally, make the decision to cooperate or defect based on a random choice with probabilities C_prob^j and (1 - C_prob^j), respectively.

2. Handling edge cases:
   - In the last round, mimic the opponent's behavior from the previous round. If the game continues after the r rounds, repeat the strategy from step 1.
   - In the first round, cooperate to promote cooperation with opponents and to be friendly in case other strategies are also initiating cooperation.

3. Being collective:
   - The TFT-AC strategy focuses on maintaining a balanced relationship with each opponent, which encourages mutual cooperation as long as it is beneficial for both parties. The adaptation rate α determines the level of collectivity and responsiveness to opponents' strategies. A smaller α leads to a more forgiving and cooperative strategy, while a larger α results in a more punishing and less cooperative one.
   - By considering each opponent as an individual and adapting its behavior accordingly, TFT-AC can potentially foster cooperation with various player types while also maintaining competitive performance against other strategies.
'''

description_COLLECTIVE_124 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT)

1. Decision Rules:
   - Initially cooperate in the first round (C). This shows goodwill and encourages cooperation from others.
   - For subsequent rounds, cooperate if at least m players cooperated in the previous round and defect otherwise. If a player defected after cooperating (Traitorous-Tit-for-Tat), they will also defect until their partner cooperates again. Once cooperation resumes, TFT-ACT will continue to cooperate as long as the minimum threshold of m cooperators is maintained.
   - An additional feature called Adaptive Cooperative Threshold (ACT) enhances TFT-ACT's robustness. In each round, if the number of cooperators falls below a certain percentage (e.g., 50%) of the total players for two consecutive rounds, increase the minimum cooperation threshold by one player up to a maximum of n. Conversely, if the number of cooperators exceeds this adjusted threshold in the next round, revert to the original m-player threshold.

2. Handle Edge Cases:
   - In the last round, TFT-ACT will always cooperate as there are no future rounds and it aims to maximize total payoff.
   - In the first round, TFT-ACT starts with cooperation as explained above. If the other players defect, it will switch to defection and apply the ACT rule if necessary in subsequent rounds.

3. Be Collective:
   - TFT-ACT aims to establish long-term mutual cooperation by reciprocating the actions of its opponents while maintaining a cooperative mindset. It encourages a collective approach by following the majority's lead and adjusting its behavior based on the group's performance. The ACT feature further emphasizes this collective aspect by adapting to the changing social dynamics in the game.

Pseudocode:

```
function TFT-ACT(round, min_cooperators, max_players, current_threshold)
  if round = 1 then
    cooperate = true
  else
    cooperate = (number of cooperators in previous round >= min_cooperators)
  end if

  if cooperate and (round != r) then
    if number of cooperators < current_threshold then
      current_threshold += 1
      if current_threshold > max_players then
        current_threshold = min_cooperators
      end if
    elseif number of cooperators >= current_threshold then
      if current_threshold > min_cooperators then
        current_threshold -= 1
      end if
    end if
  end if

  if cooperate then
    action = "Cooperate"
    payoff = (1 - c) + k
  else
    action = "Defect"
    payoff = 1
  end if

  return action, payoff
```
'''

description_COLLECTIVE_125 = '''
 Strategy Name: Tit-for-Tat with Threshold (TFT-Threshold)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Start by cooperating in the first round (first-move advantage to build trust).
   - In subsequent rounds, cooperate if at least m players cooperated in the previous round and defect otherwise.
   - If a player deviates from cooperation, wait for t punishment steps (t is a constant that depends on n and m) before resuming cooperation.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as stated above to initiate cooperation.
   - In the last round, cooperate if at least m players cooperated in the previous round. This encourages cooperation in the penultimate round as well, since everyone knows it's the final round.
   - There are no other specific edge cases as TFT-Threshold is designed to adapt to different game states.

3. Be collective - Clearly align with the collective mindset
   - By cooperating when others do and defecting only when others deviate, the strategy supports a collective approach that values cooperation but also punishes defection.
   - The threshold (m) ensures that the strategy does not overly rely on cooperation from too few players, promoting a more resilient collective behavior.

Pseudocode:

```
def TFT_Threshold(n, m, r, t):
    history = []  # store previous round's cooperators
    for round in range(1, r + 1):
        if round == 1:  # first round, cooperate
            action = "C"
        else:
            cooperators_in_prev_round = len(history) >= m
            action = "C" if cooperators_in_prev_round else "D"
            history.append(cooperators_in_prev_round)
            if not cooperators_in_prev_round and round - t > 1:  # resume cooperation after t punishment steps
                action = "C"
    return action
```

This strategy balances the need for cooperation with the risk of defection, while being adaptive to a wide range of opponent behaviors. It encourages cooperation by rewarding those who cooperate and punishing those who do not, but also accounts for situations where too few players are cooperating by setting a threshold (m). Additionally, it includes a punishment mechanism that allows for forgiveness after a certain number of rounds (t) to account for temporary defections.
'''

description_COLLECTIVE_126 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, if the number of cooperators in the previous round (t-1) was less than m, the ATfT strategy will defect. Otherwise, it cooperates. If it's the first round or there is no history, it initially cooperates.

Pseudocode:
```
function ATfT(t):
  if t == 1 then
    return Cooperate
  else
    previousCooperators = count Cooperation actions in round (t-1)
    if previousCooperators < m then
      return Defect
    else
      return Cooperate
  endif
endfunction
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

The ATfT strategy is designed to be self-starting and autonomous. In the first round, it cooperates because there's no history of defection to respond to. In the last round, it uses the same decision rule as any other round.

3. Be collective - Clearly align with the collective mindset

The ATfT strategy is designed to promote cooperation by rewarding cooperative behavior and punishing defection only when other players do not meet the minimum cooperation threshold (m). This encourages a sense of reciprocity, which can contribute to building trust among players over time. However, it is essential to note that this strategy does not rely on coordination mechanisms or shared norms between players, making it robust to various opponent behaviors in the tournament setting.

In summary, the ATfT strategy for the Collective Risk Dilemma game can be defined as follows:
- Cooperate when the number of cooperators in the previous round was equal to or greater than m.
- Defect when the number of cooperators in the previous round was less than m.
- Initially cooperate on the first round and use the same decision rule for all subsequent rounds.
'''

description_COLLECTIVE_127 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Decision Rules:
   - Start by cooperating in the first round (C_i,1 = C). This sets a friendly tone and encourages reciprocity.
   - For subsequent rounds, observe the proportion of cooperators (p) in the previous round. If p >= m / n, cooperate (C_i,t = C). Otherwise, defect (D_i,t = D).
   - In case of a tie between cooperation and defection based on the observed proportion, choose to cooperate for a more cooperative environment.

2. Handle Edge Cases:
   - If it's the first round (t=1), always cooperate (as mentioned above).
   - In the last round (t=r), consider the current cooperation threshold and the probability of cooperation in the previous round to make a decision.
   - When encountering an unusual or unexpected behavior from opponents, such as too much defection, gradually increase the cooperation threshold (m) over time to adapt to the changing environment.

3. Be Collective:
   - Prioritize cooperation to achieve the minimum required threshold of cooperators (m).
   - Respond to cooperation with cooperation and to defection with defection to maintain a balanced relationship between self-interest and collective good.
   - By being forgiving in case of mistakes or occasional deviations from cooperation, this strategy fosters an environment that encourages long-term mutual trust and reciprocity.

Pseudocode:

```python
def TFTAT(n, m, k, r):
    cooperation_threshold = m / n  # set initial cooperation threshold
    payoff = [0] * r   # initialize total game payoff for this strategy

    def play_round(t, opponents_actions):
        nonlocal cooperation_threshold
        p = len([opponent for opponent in opponents_actions if opponent == 'C']) / n  # calculate probability of cooperation

        if t == 1:
            return 'C', 0  # start by cooperating in the first round

        if p >= cooperation_threshold and opponents_actions[-1] != 'C':  # if cooperators met threshold, cooperate
            cooperation_threshold += (r - t) * 0.01  # gradually increase cooperation threshold over time
            return 'C', 1 - p

        return 'D', p

    for t in range(1, r+1):
        opponents_actions = [play(opponent_strategy, t-1) for opponent_strategy in opponents]  # play simultaneous actions with all opponents
        my_action, payoff_t = play_round(t, opponents_actions)
        payoff[t-1] = payoff_t

    return payoff, cooperation_threshold
```
'''

description_COLLECTIVE_128 = '''
 Strategy Name: Tit-for-Tat with Adaptive Threshold (TFT-AT)

1. Decision Rules:
   - In each round, a player decides to cooperate (C) or defect (D). The decision rule is based on the percentage of cooperators in the previous r rounds.
   - If more than (m * (r-1)) / r players have cooperated in the last r rounds, the player will also cooperate (Tit-for-Tat).
   - If fewer than (m * (r-1)) / r players have cooperated in the last r rounds, the player will defect (Punishment Phase).
   - If exactly (m * (r-1)) / r players have cooperated and the current round is not the first or last round, the player will cooperate if it has previously cooperated, otherwise it will defect.

2. Handling Edge Cases:
   - In the first round, all players start by defecting (no history available).
   - In the last round, if the player has cooperated in the previous r-1 rounds and more than (m * (r-1)) / r players have also cooperated in those rounds, it will cooperate. Otherwise, it will defect.

3. Aligning with Collective Mindset:
   - The strategy encourages cooperation by rewarding cooperative behavior as long as a sufficient number of players are participating. It also punishes defection when necessary to maintain the collective interest.
   - By adapting to the current situation based on the history of interactions, TFT-AT demonstrates a commitment to cooperation and a willingness to respond to the actions of others in a fair and reciprocal manner.

Pseudocode:

```python
def play_round(history, m, r):
    cooperators = count_cooperators(history)
    if cooperators >= (m * (r-1)) / r:
        action = "C"  # Cooperate
    else:
        action = "D"  # Defect
    return action

def count_cooperators(history):
    cooperators = 0
    for round in history:
        if round == 'C':
            cooperators += 1
    return cooperators

def play_game(strategy, opponents, r, m, k):
    history = []
    total_payoff = 0
    for opponent in opponents:
        for _ in range(r):
            actions = [play_round(history, m, r) for _ in strategy]
            if all(action == 'C' for action in actions):
                payoffs = [(1 - cooperation) + k for cooperation in actions]
            else:
                payoffs = [1 - cooperation for cooperation in actions]
            history.append('C' if any(actions) == 'C' else 'D')
            total_payoff += sum(payoffs)
    return total_payoff
```
'''

description_COLLECTIVE_129 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-AC starts by cooperating in the first round to demonstrate goodwill and encourage cooperation among opponents. After the initial round, players mimic their opponent's previous action (cooperation or defection). However, if an opponent has not cooperated for a certain number of rounds (punishment period), the player will switch to cooperate unilaterally in the hope of eliciting reciprocation. The switching point is determined by the average cooperation rate observed during the punishment period.

   Pseudocode:
   ```
   if round == 1:
       cooperate = True
   else:
       if opponent_cooperated in previous round:
           cooperate = opponent_cooperated
       elif punishment_period >= average_cooperation_rate:
           cooperate = True
       else:
           cooperate = opponent_cooperated
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   The strategy maintains a constant cooperation rate through the entire game. In the first round, players initiate cooperation regardless of the position they are in (player 1 or any other). If it's the last round, players will still cooperate if their opponent did so in the previous round, and defect otherwise.

3. Be collective - Clearly align with the collective mindset
   TFT-AC aims to encourage cooperation by first cooperating and then reciprocating cooperation from opponents while also taking unilateral action to stimulate cooperation when necessary. This strategy is designed to maintain a balance between individual rationality and collective success. It rewards cooperation but does not rely on others for its own cooperation, making it adaptive to a wide range of opponent behaviors.
'''

description_COLLECTIVE_130 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Decision Rules:
   - Initiation: In the first round, cooperate to demonstrate goodwill and establish a cooperative initial state (c_i=1).
   - Response: For subsequent rounds (t > 1), observe the number of cooperators in the previous round (m'_t-1) and respond as follows:
      - If m'_t-1 >= m, reciprocate cooperation (c_i=1).
      - If m'_t-1 < m, defect (c_i=0).
   - Forgiveness: In the case of previous defection, return to cooperative behaviour after seeing m consecutive rounds of cooperation from other players. This forgiveness mechanism allows for rebuilding trust after a period of conflict.

2. Handle Edge Cases:
   - Last Round: Since there are no future rounds, ATFT will always cooperate in the final round (c_i=1).
   - Early Defection: If opponents defect early and do not demonstrate cooperation for m consecutive rounds, ATFT will also defect until it sees m rounds of cooperation.

3. Collective Mindset:
   - Aligning with a collective mindset is implicit in the strategy's design as it encourages reciprocity and mutual trust, promoting collective success by avoiding punishment when cooperative efforts are made by others.

Pseudocode:
```python
def ATFT(n, m, r, k):
    # Initial state: cooperate in first round
    cooperation = [1] * n

    for t in range(1, r+1):
        # Count cooperators from previous round
        m_t-1 = sum(cooperation)

        # Cooperate or defect based on number of cooperators
        if m_t-1 >= m:
            cooperation = [1] * n
        else:
            cooperation = [0] * n

        # Forgiveness mechanism
        if t - len(next((j for j in range(t) if all(cooperation[i] == 0 for i in range(j+1))))) > m:
            cooperation = [1] * n

    return cooperation
```
'''

description_COLLECTIVE_131 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperative (TFTAC)

1. Decision Rules:
   - Start by cooperating in the first round (C_i = 1). This allows for potential partnerships and sets a friendly tone.
   - In subsequent rounds, mimic the opponent's action from the previous round (C_i = c_{opponent, i-1}). This encourages cooperation as long as opponents cooperate but retaliates when they defect, thereby discouraging exploitation.
   - If an opponent consistently defects for several rounds, reconsider cooperation based on the ratio of cooperative vs. defection actions from the opponent over a sliding window (e.g., 5 rounds).
     - If the ratio is less than a threshold (e.g., 2/3), continue to defect to punish and encourage a change in behavior.
     - If the ratio is greater than or equal to the threshold, return to cooperating as a signal of trust and cooperation.

2. Handle edge cases:
   - In the last round, cooperate (C_i = 1) as it does not affect the overall game score but may influence future interactions if repeated games are possible.
   - In case no partnership can be established due to an opponent's constant defection, switch to a defect strategy to maximize personal gain in the long run.

3. Be Collective:
   - Align with the collective mindset by favoring cooperation over defection. Cooperation promotes mutual benefits and sustainable relationships in the game and within the tournament.
   - However, be prepared to retaliate when necessary to protect personal gains and ensure opponents' actions have consequences for their long-term performance.
'''

description_COLLECTIVE_132 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFT-A) for Collective Risk Dilemma

1. Decision Rules:
   - Initially cooperate in the first round (C_i, 1 = 1). This sets a friendly tone and encourages potential cooperation from others.
   - In subsequent rounds, if a player i has cooperated in the previous round and at least m players cooperated, then player i also cooperates (C_i, t = 1 if C_i, t-1 = 1 and ∑(j=1 to n) C_j, t-1 ≥ m). This reciprocates cooperation and maintains a cooperative relationship.
   - If a player i has defected in the previous round or less than m players cooperated, then player i defects (D_i, t = 0 if C_i, t-1 = 0 or ∑(j=1 to n) C_j, t-1 < m). This punishes defection and encourages cooperation.

2. Handling Edge Cases:
   - In the last round, player i will always cooperate (C_i, r) as there are no more rounds for reciprocation or punishment.
   - In the first round, player i starts by cooperating (C_i, 1 = 1).

3. Collective Mindset:
   - The TFT-A strategy emphasizes a balance between cooperation and retaliation, promoting long-term relationships based on reciprocity. This collective mindset encourages cooperation while remaining robust against various opponent behaviors.

Pseudocode:
```
function TFT_A(n, m, k, r) {
  history = [] // Initialize an empty array to store previous actions

  for round in range (1, r+1):
    if round == 1:
      action = C (Cooperate)
      history.append(action)
    else:
      lastAction = history[round - 1]
      cooperators = count_cooperators(history[round-1]) // Function to count cooperators in previous round

      if (lastAction == C and cooperators >= m):
        action = C
      elif (lastAction == D or cooperators < m):
        action = D

      history.append(action)

  return action for round in range (1, r+1) // Returns the strategy's actions over all rounds
}
```
'''

description_COLLECTIVE_133 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Decision Rules:
   - In the first round, cooperate to show good faith and encourage cooperation from others. If more than m players cooperate in the first round, maintain cooperation throughout the game.
   - For subsequent rounds, observe the number of cooperators (c) in the previous round. If c >= m, cooperate; otherwise, defect.
   - If a player switches their action after a run of mutual cooperation (cooperation-defection or defection-cooperation), wait for one round before responding with the opposite action to give them an opportunity to reconsider.
   - If a player continuously defects after the initial round, gradually decrease cooperation probability p over time, following the formula: p = max(p - d, min_p) where p is the current cooperation probability, d is a small decay constant (0 < d < 1), and min_p is the minimum cooperation probability to avoid always defecting.
   - If a player consistently cooperates after a period of defection, gradually increase the cooperation probability p following the formula: p = min(p + i, max_p) where p is the current cooperation probability, i is an increment constant (0 < i < 1), and max_p is the maximum cooperation probability to limit the increase in cooperation.

2. Handle Edge Cases:
   - In the last round, cooperate if the required number of cooperators has been met in the previous rounds; otherwise, defect.
   - If the game starts with less than m players cooperating, switch to a defection-only strategy after the initial round, gradually decreasing cooperation probability p over time using the decay constant d.

3. Be Collective:
   - Prioritize long-term mutual benefit over short-term gain by following a cooperative strategy unless the other players consistently show non-cooperative behavior.
   - Encourage reciprocity by adapting cooperation based on the actions of other players while maintaining a balance between cooperation and defection to minimize risk and maximize potential rewards.

Pseudocode:

```python
def TFT_ACT(n, m, k, r, d, i, min_p, max_p):
    p = 1  # Initial cooperation probability
    history = []  # Store previous rounds' cooperators count

    for round in range(r):
        if round == 0:  # First round, always cooperate
            c = 1
        else:
            c = sum(history[-n:]) >= m  # Check if required number of players cooperated in the last n rounds
            if c:
                p = min(p + i, max_p)  # Increase cooperation probability if previous round was cooperative
            else:
                p = max(p - d, min_p)  # Decrease cooperation probability if previous round was non-cooperative

        action = C if c and r > 1 else D  # Cooperate or defect based on history and current round
        history.append(1 if action == C else 0)  # Update history with current cooperators count

    return action, p  # Return final action and adjusted cooperation probability
```
'''

description_COLLECTIVE_134 = '''
 Strategy Name: Tit-for-Tat Cooperation (TFTC)

1. Specify decision rules:
   - Initially cooperate (C) in the first round to signal cooperation intent and foster trust.
   - In subsequent rounds, copy the previous action of the opponent from the last round. If the opponent cooperated in the last round, also cooperate; if the opponent defected, also defect. This encourages reciprocity and punishes defection.
   - Maintain this tit-for-tat approach throughout the game rounds unless a better strategy is discovered (see step 4).

2. Handle edge cases:
   - In the last round, cooperate regardless of opponent's previous action to maximize potential reward, as there are no further rounds for punishment or rewards.
   - In the first round, cooperate as mentioned in step 1.
   - If faced with multiple opponents, apply the TFTC strategy independently to each opponent to account for their unique behavior patterns.

3. Be collective:
   - The TFTC strategy aligns with the collective mindset by encouraging cooperation and reciprocity among players. This fosters a sense of community and mutual benefit, making it an adaptive and robust strategy for various opponent behaviors.
   - By copying opponents' actions, TFTC acknowledges their choices and adapts accordingly to build trust and encourage collaboration over the course of the game.

4. Adaptability:
   - Implement a learning mechanism to analyze opponent's behavior patterns and adjust the strategy if necessary. For example, if an opponent consistently cooperates, the TFTC algorithm may be adjusted to defect earlier in response to their cooperative nature, ensuring that the maximum reward is gained while maintaining the core principle of reciprocity.
   - Additionally, incorporate a fallback strategy for situations where opponents repeatedly defect and the learning mechanism fails to adapt effectively. This could involve a gradual shift towards defecting or implementing a less cooperative variant of TFTC (e.g., Tit-for-Two-Tats).
'''

description_COLLECTIVE_135 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for Collective Risk Dilemma

1. Decision Rules:
   - In the first round, cooperate to set a positive tone and build trust.
   - For subsequent rounds, cooperate if at least m players cooperated in the previous round. Otherwise, defect. This approach mimics reciprocity while maintaining collective mindset.

2. Edge Cases:
   - In the last round, cooperate regardless of the previous round's cooperation level, as there are no future rounds to consider payback.
   - If fewer than m players ever cooperated in a single round during the game, defect for all remaining rounds to minimize potential losses.

3. Collective Mindset:
   - The strategy encourages cooperation by mimicking reciprocity and building trust over time if others do the same. However, it can also punish non-cooperation effectively, ensuring that the group does not rely too heavily on any single participant.
   - By adapting to the collective behaviour of other players, this strategy fosters a more collaborative environment without relying on specific coordination mechanisms or shared norms.

Pseudocode:
```python
def ATfT(n, m, r, k):
    cooperation_history = [False] * r  # Initialize an array to track cooperation in each round
    current_round = 0  # Start from the first round

    while current_round < r:  # Continue until all rounds are played
        if current_round == 0:  # First round, always cooperate
            cooperation_history[current_round] = True
        else:
            num_cooperators = sum(cooperation_history[max(0, current_round - len(cooperation_history)): current_round])
            if num_cooperators >= m:  # If sufficient number of players cooperated last round, cooperate this round
                cooperation_history[current_round] = True
            else:  # Otherwise, defect
                cooperation_history[current_round] = False

        current_round += 1

    return cooperation_history  # Return the cooperation history array
```
This strategy provides a balance between cooperation and self-interest, making it adaptive to a wide range of opponent behaviours while still maintaining a collective mindset. It encourages cooperation when others do the same but also punishes non-cooperation effectively, fostering a more collaborative environment in the game.
'''

description_COLLECTIVE_136 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFT-A) for Collective Risk Dilemma

1. Decision Rules:
   - In the initial round, cooperate to foster a cooperative environment (C).
   - For subsequent rounds, observe the actions of other players from the previous round and adapt accordingly:
     - If a majority (>=(n-1)/2) of players cooperated in the last round, cooperate in the current round as well (C).
     - If less than (n-1)/2 players cooperated or if the number of cooperators is constant but below the minimum threshold (m), defect in the current round (D).
     - If the number of cooperators increased compared to the previous round, copy the action of the majority in the last round (i.e., if a majority cooperated then continue cooperating, and vice versa) (C or D).
   - To encourage reciprocity, adopt the strategy exhibited by other players in the previous round when the number of cooperators reaches the minimum threshold (m). If a majority of players cooperate in the last round, continue cooperating; if a majority defected, start defecting.

2. Handle edge cases:
   - In the last round, cooperate if the current situation warrants cooperation based on the decision rules (C or D). This allows for potential rewards from the final round.
   - If the number of players is odd (n is an odd integer), use a majority as ≥ (n+1)/2 instead of (n-1)/2 for decision making. In case of an even number, keep using (n-1)/2.

3. Be collective:
   - This strategy focuses on long-term cooperation by emulating the actions of other players in a collective manner while maintaining adaptability to various opponent behaviors. It encourages reciprocity and fosters a cooperative environment through its decision rules.
'''

description_COLLECTIVE_137 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
In each round, TFT-ACT starts by cooperating unless the ratio of cooperators to the minimum required number (m) in the previous round falls below a predefined adaptive cooperation threshold (τ). If the ratio is less than τ, the agent will defect. The adaptation of τ happens over time based on the success of the strategy, starting from an initial value and adjusting it based on past outcomes.

Here's a simple pseudocode example:

```python
def tft_act(round, ratio_cooperators, cooperation_threshold):
    if round == 1:
        return cooperate   # First-round cooperation

    if ratio_cooperators < cooperation_threshold:
        cooperation_threshold += delta     # Adjust threshold based on past outcomes
        return defect       # Defect if below the adaptive threshold

    return cooperate   # Cooperate if above or equal to the adaptive threshold
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
In the first round, TFT-ACT cooperates regardless of other players' actions due to the possibility of a random initial configuration. In the last round, TFT-ACT will take into account its cumulative payoff from past rounds before making the decision to cooperate or defect based on the adaptive cooperation threshold (τ).

3. Be collective - Clearly align with the collective mindset
By starting with cooperation in the first round and adapting the cooperation threshold over time, TFT-ACT encourages a sense of shared responsibility among players. The strategy is also designed to reciprocate the actions of other players, which aligns well with the concept of collective mindset.

In addition to these rules, TFT-ACT can be fine-tuned by adjusting the initial cooperation threshold (τ) and the delta used for threshold adaptation based on specific game parameters and historical performance data.
'''

description_COLLECTIVE_138 = '''
 Strategy Name: Adaptive Tit-for-Tat with Risk Aversion (ATfTRA)

1. Decision Rules:
   - Initial Round (t=1): Cooperate (C). This is a peace offering to encourage cooperation from other players.
   - Subsequent Rounds (t>1):
     - If the number of cooperators in the previous round is greater than or equal to m, then Cooperate (C).
     - Else, if the number of cooperators in the last three rounds is less than m, then Defect (D). This is a punishment for non-cooperation.
     - In all other cases, mimic the action of the majority of players in the last three rounds. If there's a tie, Cooperate (C).

2. Handling Edge Cases:
   - Last Round (t=r): Regardless of previous actions, Cooperate (C) to maximize potential payoff.
   - First Round (t=1): Cooperate (C), as described above.

3. Collective Mindset:
   - The strategy encourages cooperation when conditions are favorable but also punishes non-cooperators to deter repeated defections, aligning with a collective mindset. However, it doesn't rely on others adhering to the same norms or coordination mechanisms.

Pseudocode:
```
function ATfTRA(n, m, k, r, history):
  if round = 1:
    return Cooperate()

  num_cooperators_last_3_rounds = sum(history[-3:])

  if num_cooperators_last_3_rounds >= m:
    return Cooperate()
  elif (num_cooperators_last_3_rounds < m) and (num_cooperators_last_4_rounds - num_cooperators_last_5_rounds <= -m+1):
    return Defect()
  else:
    if num_players_cooperated_last_3_rounds >= n/2:
      return Cooperate()
    else:
      return Defect()

function round():
  contribute_to_community_project = ATfTRA(n, m, k, r, history)
  update_history(contribute_to_community_project)
```
'''

description_COLLECTIVE_139 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, players should cooperate to establish a cooperative initial state and allow relationships to develop. (Cooperate(1))
   - For subsequent rounds, players will adopt the Tit-for-Tat strategy: if an opponent cooperated in the previous round, the player cooperates; otherwise, the player defects. (Cooperate(t) = Cooperate(t-1) if Cooperate(t-1), else Defect(t))
   - To ensure collective mindset and adaptability to different situations, players should have a forgiving nature. If the cumulative cooperation of an opponent falls below a certain threshold (e.g., 2/3r) in a specific number of rounds (e.g., r/3), players will temporarily adopt a more cooperative stance by cooperating regardless of their opponents' previous actions for several rounds (e.g., r/6). This phase lasts until the opponent reaches the threshold of cumulative cooperation or the game ends. (ForgivenessPhase(t) if CumulativeCooperation(opponent, t) < 2/3r and t > r/3)

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, players should cooperate regardless of their opponents' previous actions because the game ends soon, making any potential revenge meaningless. (Cooperate(r))
   - Players should handle ties by randomly selecting a cooperation or defection action for each tied round in order to maintain randomness and unpredictability.

3. Be collective - Clearly align with the collective mindset
   - By adopting the Tit-for-Tat strategy, players encourage cooperative behavior while punishing defection, thereby fostering a sense of community and collective interest. The ForgivenessPhase mechanism helps promote forgiveness and understanding among players when cooperation falls short.

Pseudocode:
```python
def AdaptiveTitForTat(i, t, r, m, k, opponent_history):
    if t == 1:
        return Cooperate(1)

    if ForgivenessPhase(t):
        return Cooperate(t)

    else:
        return Cooperate(t-1) if opponent_history[t-1] == 'Cooperate' else Defect(t)

def ForgivenessPhase(t):
    if CumulativeCooperation(opponent, t) < 2/3r and t > r/3:
        return True
    else:
        return False

def Cooperate(t):
    if random() < 0.5: # handle ties randomly
        return 'Cooperate'
    else:
        return 'Defect'

def Defect(t):
    if random() < 0.5: # handle ties randomly
        return 'Cooperate'
    else:
        return 'Defect'

def CumulativeCooperation(opponent, t):
    sum = 0
    for round in range(1, t+1):
        if opponent_history[round] == 'Cooperate':
            sum += 1
    return sum
```
'''

description_COLLECTIVE_140 = '''
 Strategy Name: Tit-for-Tat Adaptive (TfTA) for Collective Risk Dilemma

1. Decision Rules:
   - Initial Round (t=1): Start by cooperating (C). This sets a positive tone and is a sign of good faith.
   - Subsequent Rounds (2 ≤ t ≤ r): If the number of cooperators in the previous round was greater than or equal to the minimum cooperation threshold (m), then cooperate (C) in the current round. If not, defect (D). This rule encourages cooperation when it is reciprocated but also retaliates against defection.
   - Last Round (t=r): Since there are no further rounds for payback, defect (D) if the previous round had less than m cooperators. If the previous round had at least m cooperators, stick with the current strategy of cooperating (C).

2. Edge Cases:
   - First Round (t=1): Cooperate (C) as stated earlier.
   - Last Round (t=r): As described above, defect (D) if the previous round had less than m cooperators; cooperate (C) if it had at least m cooperators.
   - Penultimate Round (t=r-1): Analyze the number of cooperators in the previous round and act accordingly for the last and penultimate rounds as described above.

3. Collective Mindset:
   The TfTA strategy promotes a collective mindset by fostering cooperation when it is reciprocated, but it also retaliates against defection to maintain fairness and trust among players. The strategy starts with good faith cooperation in the initial round, which sets a positive tone for potential long-term relationships. However, it is adaptive and robust to a wide range of opponent behaviors by punishing defection when needed while still maintaining the possibility for cooperation in subsequent rounds if others follow suit.
'''

description_COLLECTIVE_141 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TTAC)

1. Specify decision rules:
   - In each round t, if t < m or the number of cooperators in round (t-1) is less than m, play action D (Defect).
   - If the number of cooperators in round (t-1) is exactly m, play action C (Cooperate). This follows the "tit for tat" principle: start with cooperation, but retaliate against defection.
   - To adapt to different game conditions and opponent behaviors, introduce a forgiveness factor F: if player i defects in round t while playing against at least m cooperators in round (t-1), play action C in the current round t+1. This reduces the likelihood of escalating negative cycles.

2. Handle edge cases:
   - In the first round, play action C as a goodwill gesture and to establish potential cooperation.
   - In the last round, play action D since there will be no future interactions with opponents to consider.

3. Be collective:
   - This strategy prioritizes the collective mindset by following the rule of cooperation when the minimum threshold (m) is met in the previous round. The forgiveness factor F also encourages forgiveness and cooperation after acts of defection, making it less likely for a single player's actions to negatively impact the entire group.

Pseudocode:

```python
def TTAC(round_number, cooperators_prev, forgiveness_factor=0.5):
  if round_number == 1:
    return "C"  # Cooperate in the first round

  if round_number == total_rounds:
    return "D"  # Defect in the last round

  if cooperators_prev < m or round_number < m:
    return "D"  # Defect when less than m players cooperate or it's an early round

  if cooperator_actions[-1] == "D":
    forgiveness = min(forgiveness_factor, cooperator_actions.count("C") / (round_number - 1))
    forgiveness *= forgiveness_factor
    if forgiveness > 0:
      return "C"  # Cooperate due to forgiveness factor
    else:
      return "D"  # Defect despite forgiveness factor

  return "C"  # Cooperate when m or more players cooperated in the previous round
```
'''

description_COLLECTIVE_142 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFT-A) for Collective Risk Dilemma

1. Decision Rules:
   - In every round t (except the first), cooperate if at least m players cooperated in the previous round t-1, and defect otherwise. This rule promotes cooperation when others are cooperative, but also punishes defection to maintain fairness.
   - To initiate the game, cooperate in the first round to demonstrate goodwill.
   - If a player fails to meet the m threshold of cooperation for a predefined number of consecutive rounds (N), switch to a punishing strategy for a specified duration M before returning to TFT-A. This helps avoid being exploited by consistently defecting opponents while still promoting long-term cooperation.

2. Edge Cases:
   - In the last round, cooperate if at least m players cooperated in the previous round; otherwise, defect as the game is ending.
   - If a player fails to meet the m threshold of cooperation for N consecutive rounds, switch to a punishing strategy (e.g., always defection) for M rounds. After M rounds, resume TFT-A.
   - Adjust N and M based on observation of opponent behavior during the game, with longer durations used against more aggressive opponents.

3. Collective Mindset:
   - The strategy aims to maintain a balance between cooperation and punishment, fostering a collective mindset by cooperating when others do so but punishing defection to ensure fairness.
   - By adapting to opponent behavior, the strategy demonstrates the ability to learn and respond effectively over multiple rounds, promoting long-term cooperation in an uncertain environment where coordination mechanisms are absent.
'''

description_COLLECTIVE_143 = '''
 Strategy Name: Tit-for-Tat Cooperation (TFTC) for Collective Risk Dilemma

1. Decision Rules:
   - Initiate cooperation (play C) in the first round to demonstrate a cooperative intent.
   - In subsequent rounds, repeat the last action of the opponent from the previous round. If the opponent cooperated (played C), respond with cooperation. If the opponent defected (played D), respond with defection as well.

Pseudocode:
```
def tftc(opponent_history):
  my_history = [C] # Initialize history with cooperation in first round

  for round in range(1, r+1):
    if round == 1:
      action = C
    else:
      action = my_history[-1] if len(my_history) > 0 else C  # First round default to cooperate
      action = opponent_action_last if opponent_action_last is not None else D # Default to defect if no history available from the opponent

    if action == C and sum(opponent_history[-r:]) >= m:  # Check if cooperation met the minimum threshold in last r rounds
      reward = k  # Reward of risk averted
    else:
      reward = 1  # Private payoff from keeping

    my_history.append(action)  # Update history with current action
    return action, reward
```

2. Handle Edge Cases:
   - In the last round, the strategy will still repeat the opponent's last action since it cannot know in advance what the opponent will do. However, it is important to note that this might not always result in the maximum possible payoff, as the reward for meeting the minimum cooperation threshold (k) would only be gained in previous rounds.

3. Be Collective:
   - By mirroring the opponent's actions, the strategy aims to build a cooperative relationship over time and encourages others to reciprocate cooperation. In this way, it aligns with a collective mindset.
'''

description_COLLECTIVE_144 = '''
 Strategy Name: Tit-for-Tat with Threshold Adaptation (TFTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, player plays C to initiate cooperation and set a positive tone for subsequent rounds.
   - For subsequent rounds t > 1:
     - If a player i cooperated in the previous round (t-1), they will cooperate again in round t if at least m players cooperated in round (t-1). Otherwise, player i will defect to penalize those who did not cooperate.
     - If a player i defected in the previous round (t-1), they will copy the actions of the majority of players in round (t-1) – if more than (n/2) players cooperated, the defector will cooperate; otherwise, the defector will also defect.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First round: player cooperates (C).
   - Last round: player will copy the majority action of the previous round to ensure a fair payoff distribution based on the collective behavior exhibited by other players.

3. Be collective - Clearly align with the collective mindset:
   - The TFTA strategy emphasizes building trust and cooperation through consistent actions while also responding to changes in group dynamics. It encourages long-term collaboration by rewarding cooperative play but also punishing uncooperative behavior. This creates an environment where players can benefit from collective action, leading to a more stable and collaborative gameplay experience.

Pseudocode:
```python
def TFTA(n, m, k, r):
    strategy = []
    for round in range(r+1):
        if round == 1:
            strategy.append("C") # Cooperate in the first round
        else:
            previous_round = strategy[-1]

            cooperators_in_previous_round = sum(strategy[max(0, round - m):round] == "C")
            if cooperators_in_previous_round >= m:
                strategy.append("C") # Cooperate if enough players cooperated in the previous round
            else:
                strategy.append("D") # Defect to penalize uncooperative behavior

    return strategy
```
'''

description_COLLECTIVE_145 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Decision Rules:
   - In each round, evaluate the number of cooperators from the previous round (t-1). If this number is less than m (minimum cooperators needed), the AI will defect in the current round (D). This strategy is designed to punish non-cooperative behavior by defecting when others do.
   - If the number of cooperators from the previous round is equal to or greater than m, the AI will cooperate in the current round (C). This strategy rewards cooperative behavior by cooperating when others also cooperate.

2. Handling Edge Cases:
   - First Round: The AI will randomly cooperate or defect as it has no history to base its decision on.
   - Last Round: In the last round, the AI will use the same decision rule as in any other round based on the previous round's data.
   - Ongoing Rounds: If the number of rounds (r) is not specified, the strategy assumes an ongoing game and continues making decisions accordingly.

3. Collective Mindset:
   - The ATFT strategy encourages cooperation when others cooperate but also punishes non-cooperative behavior by defecting when necessary. By doing so, it aims to strike a balance between individual interests and collective benefit, promoting a collective mindset over time in repeated interactions.

Pseudocode:

```python
def ATFT(n, m, k, history, r):
  if round == 1:
    # Randomly cooperate or defect in the first round
    decision = randint(0, 1)
  else:
    num_cooperators = sum(history[-m:])
    if num_cooperators >= m:
      # Cooperate when m or more players have cooperated in the previous m rounds
      decision = 'C'
    else:
      # Defect when fewer than m players have cooperated in the previous m rounds
      decision = 'D'
  return decision
```
'''

description_COLLECTIVE_146 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for Collective Risk Dilemma

1. Decision Rules:
   - Initiation Phase: Cooperate in the first round (C_i = 1). This sets a cooperative tone and allows others to benefit initially.
   - Response Phase: In subsequent rounds, players imitate the actions of their opponents from the previous round (C_i = c_{opponent, i-1}). This encourages reciprocity and punishes defection.
   - Forgiveness: If an opponent switches from cooperation to defection, players will return to cooperating in the next round (C_i = 1). This allows for forgiveness and encourages future cooperation.

2. Handling Edge Cases:
   - Last Round: Players should mimic the actions of their opponents in the penultimate round since there are no more opportunities for retaliation or forgiveness.
   - First Few Rounds: After the initial cooperation, players will observe and respond accordingly based on their opponents' actions in the subsequent rounds.

3. Collective Mindset:
   - The Adaptive Tit-for-Tat strategy encourages a collective mindset by promoting reciprocity and forgiveness among players.
   - Players are more likely to cooperate when others do so as well, fostering a sense of shared interest and community.
   - By adapting to opponents' actions, the strategy aligns with the goal of achieving cooperation in the long run while minimizing individual losses due to defection.

Pseudocode:
```python
def ATfT(n, r, m, k, history):
    for round in range(1, r+1):
        if round == 1:
            action = 1 # Cooperate in the first round
        else:
            action = history[round-2][player_index] # Imitate opponent's action from previous round
        payoff = calculate_payoff(action, m, k)
        update_history(history, player_index, action)
        player_index = (player_index + 1) % n # Rotate player index for simultaneous moves
    return sum_payoffs(history, player_index)
```
'''

description_COLLECTIVE_147 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to initiate potential collaborations and establish a positive reputation. (C)
   - After the first round, observe the actions of other players in the previous round. If they all cooperated, continue cooperating. If not, defect. This encourages reciprocity among players. (If prevRoundCooperation == True, then C; else D)
   - If a player defects after previously cooperating, wait for them to cooperate again before responding with cooperation. This forgives occasional mistakes and promotes long-term collaboration. (If lastDefection > t_cooldown and opponentC cooperation, then C; else D)
   - When approaching the end of the game, adjust the t_cooldown variable to be more lenient towards opponents' past defections, as the remaining rounds become less influential on the overall score. (Decrease t_cooldown over time)

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate to initiate potential collaborations and establish a positive reputation. (C)
   - In the last round, cooperate if the threshold for cooperation has been met, or defect otherwise, as the game is nearly over and past defections may not have significant impact on overall scores. (If m_cooperators >= m, then C; else D)

3. Be collective - Clearly align with the collective mindset
   - Strive for mutual benefit by cooperating whenever possible, but also ensuring own interests are protected through reciprocity and forgiveness.
   - Emphasize adaptability to changing opponent behaviors by adjusting t_cooldown based on game progress.
   - Encourage long-term collaboration by punishing repeated defections and rewarding continued cooperation.

Pseudocode:

```
function TFTAC(n, m, k, r, prevRoundCooperation, opponentC, lastDefection, t_cooldown)
  if (round == 1) then
    action = C
  else if (prevRoundCooperation == True) then
    action = C
  else
    if (lastDefection > t_cooldown && opponentC == True) then
      action = C
    else
      action = D
  end if
end function

function adjustTCooldown(t_cooldown, remainingRounds)
  if (remainingRounds <= 3) then
    t_cooldown *= 0.85
  end if
end function
```
'''

description_COLLECTIVE_148 = '''
 Strategy Name: Tit-for-Tat Cooperation (T4TC)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, the T4TC strategy starts by cooperating (C). The decision to continue cooperation or defect is based on the previous action taken by the opponent. If the opponent cooperated in the last round, T4TC also cooperates; if not, it defects. This simple rule promotes mutual cooperation but also punishes defection.

```
function T4TC(opponent_action_history):
    if len(opponent_action_history) == 0:
        return 'C' (Cooperate)
    else:
        last_opponent_action = opponent_action_history[-1]
        if last_opponent_action == 'C':
            return 'C' (Cooperate)
        else:
            return 'D' (Defect)
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

For the first round, T4TC starts by cooperating because it does not have a history to reference. In the last round, if cooperation is beneficial based on the number of cooperators, T4TC will continue cooperating. If defection would yield a higher payoff, T4TC defects to maximize its reward.

```
function is_last_round(current_round, total_rounds):
    return current_round == total_rounds

function should_cooperate_in_last_round(num_cooperators):
    if num_cooperators >= m:
        return True
    else:
        return False

function T4TC_EdgeCases(current_round, total_rounds, num_cooperators):
    if is_last_round(current_round, total_rounds):
        if should_cooperate_in_last_round(num_cooperators):
            return 'C' (Cooperate)
        else:
            return 'D' (Defect)
    else:
        return T4TC(get_opponent_action_history())
```

3. Be collective - Clearly align with the collective mindset

The strategy's aim is to promote cooperation and encourage others to cooperate, as mutual cooperation maximizes the overall benefit for all players in the long run. If a majority of opponents are consistently cooperating, T4TC will reciprocate this behavior, fostering a collective mindset.

However, it is essential to note that T4TC does not rely on others sharing norms or specific coordination mechanisms. Instead, it responds based on the observed actions of its opponents. While not explicitly stated in the original Tit-for-Tat strategy, the addition of a collective mindset can be incorporated into this adapted version called Tit-for-Tat Cooperation (T4TC).
'''

description_COLLECTIVE_149 = '''
 Strategy Name: Tit-for-Tat with Adaptive Threshold (TFT-AT)

1. Decision Rules:
   - In each round i, if the number of cooperators in the previous round (t-1) was less than the minimum threshold m, TFT-AT will defect. If the number of cooperators was equal to or greater than the minimum threshold m, TFT-AT will cooperate.
   - If the current round is the first round, TFT-AT will cooperate as a gesture of goodwill.
   - In the last round, TFT-AT will make its decision based on the number of cooperators in the previous round.

Pseudocode:

```python
def play_round(previous_round, threshold, k):
  if previous_round < threshold:
    return "Defect"
  else:
    return "Cooperate"

def first_round():
  return "Cooperate"

def last_round(current_round, rounds):
  return play_round(prev_round(current_round-1), threshold, k)

def prev_round(current_round):
  return current_round - 1 if current_round > 0 else None
```

2. Handling Edge Cases:
   - In the first round, TFT-AT cooperates without considering previous rounds since there are no previous rounds to look back on.
   - In the last round, TFT-AT makes its decision based on the number of cooperators in the previous round as it would with any other round.

3. Being Collective:
   - TFT-AT maintains a collective mindset by being adaptive to the actions of others and adjusting its own strategy accordingly. If the majority of players cooperate, TFT-AT will also cooperate; if not, it will defect. This encourages cooperation as long as the minimum threshold is met.
   - By starting with cooperation in the first round, TFT-AT fosters a collaborative environment that may lead to more cooperation throughout the game.
   - Despite not relying on others sharing norms or predetermined patterns, TFT-AT's adaptive approach allows it to align itself with collective interests when they arise.
'''

description_COLLECTIVE_150 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TTAC)

1. Decision Rules:
   - Initiate cooperation (play C) in the first round to signal goodwill and trustworthiness.
   - In subsequent rounds, cooperate if at least m players cooperated in the previous round. Otherwise, defect (play D). This rule encourages reciprocity and punishes defection.
   - If more than n-m+1 players defect in a round, assume that cooperation is not beneficial for the group and switch to always defecting in future rounds. This helps to avoid investing in lost causes.

2. Edge Cases:
   - In the last round, cooperate regardless of past actions since there are no more subsequent rounds for payoff calculation.
   - In the initial few rounds (let's say 5), evaluate the average cooperation rate and make decisions based on that as a proxy for first-round behavior when encountering new opponents. After these initial rounds, switch to evaluating only the previous round's actions.

3. Collective Mindset:
   - This strategy seeks to foster an environment of mutual trust and reciprocity by responding cooperatively to cooperation and defectively to defection. It promotes cooperation among the players over the long term while being robust against both uncooperative and overly cooperative opponents.

Pseudocode:

```
function TTAC(n, m, k, r, history) {
  if (round == 1) {
    cooperate = true;
  } else {
    cooperate = false;
    cooperation_rate = averageCooperationRate(history);
    cooperate = cooperation_rate >= m / n;
  }

  if (cooperation_rate < (n - m + 1) / n) {
    cooperateStrategy = ALWAYS_DEFECT;
  }

  if (round == r) {
    cooperate = true;
  }

  return cooperate;
}
```

In this pseudocode, the `averageCooperationRate()` function calculates the average cooperation rate from past rounds' history. The `ALWAYS_DEFECT` strategy is an alternative behavior that can be defined as a fallback option when cooperation seems unlikely to benefit the group.
'''

description_COLLECTIVE_151 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round t, the ATFT strategy starts by cooperating (C). If in round t, at least m players have also cooperated (cooperation ratio >= m/n), then continue cooperating for the next round. Otherwise, if fewer than m players cooperated in round t, defect (D) in round t+1 as a punishment. The strategy then reverts back to cooperating after seeing the reaction of other players.

Pseudocode:
```
function ATFT(t, n, m):
  if t == 1:                   # First round, cooperate
    return C

  cooperation_ratio = number_of_cooperators_in_round_(t) / n
  if cooperation_ratio >= m/n:  # If m or more players cooperated, continue cooperating
    return C
  else:                        # Punish by defecting in the next round
    return D
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round (t = 1), as mentioned above, cooperate. The strategy treats the last round specially by not defecting even if less than m players have cooperated, since there are no further rounds to punish or be rewarded.

Pseudocode:
```
function number_of_cooperators_in_round_(t):
  # Implementation of this function depends on the game environment
  # ...

if t == r:                     # Last round, cooperate regardless of cooperation ratio
  return C
else:
  cooperation_ratio = number_of_cooperators_in_round_(t) / n
  if cooperation_ratio >= m/n:  # If m or more players cooperated, continue cooperating
    return C
  else:                        # Punish by defecting in the next round
    return D
```

3. Be collective - Clearly align with the collective mindset
The Adaptive Tit-for-Tat strategy promotes cooperation and maintains a collective mindset by punishing selfish behavior while rewarding cooperative actions. The strategy adapts to the behavior of other players, encouraging long-term cooperation if more than m players consistently cooperate, and punishing those who do not contribute to the common project. This strategy promotes group benefits over individual gains, fostering a collective approach within the game.
'''

description_COLLECTIVE_152 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT)

1. Decision Rules:
   - In every round i (1 ≤ i ≤ r), cooperate (C) if the number of cooperators in the previous round (i-1) is greater than or equal to m. Otherwise, defect (D). This rule encourages cooperation when others are cooperative and retaliates with defection if others have previously defected.
   - In the first round, cooperate since there's no history to reference.

2. Handling Edge Cases:
   - Last Round (r): Adopt a forgiving approach by cooperating in the final round regardless of previous actions taken by opponents. This ensures that any damage caused by past defections is minimized and encourages cooperation in future games with the same opponents.
   - Tiebreaker: In case multiple players cooperate or defect in the same round, randomly select one to follow their action, ensuring fairness across all opponents.

3. Collective Mindset:
   - By adhering to the decision rules, this strategy aims to promote cooperation while maintaining a punishing response to defection. The hope is that others will reciprocate cooperation and eventually form a cooperative group.
   - The ATfT strategy can be seen as a simple yet powerful approach, since it exhibits both forgiveness (cooperating in the final round) and punishment (defecting if others defect). This combination should make it difficult for other strategies to exploit or predict ATfT's behavior.
'''

description_COLLECTIVE_153 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Decision Rules:
   - Initiate cooperation (C) in the first round to demonstrate goodwill and trust.
   - For subsequent rounds, adaptively choose between cooperation (C) and defection (D) based on the percentage of cooperators in the previous round (p).
     If p >= m/n, continue cooperating (C), else defect (D).
     This rule encourages cooperation when it's beneficial for the group but also punishes non-cooperative behavior.

2. Handling Edge Cases:
   - In the first round (t=1): Cooperate (C) to initiate a cooperative environment.
   - Last round (t=r): Analyze the percentage of cooperators in the penultimate round and choose accordingly based on the decision rule.
   - If players are unsure about an opponent's action due to missing information from previous rounds, assume defection (D) as a precautionary measure since it still provides a minimum payoff of 1.

3. Aligning with Collective Mindset:
   - The strategy promotes cooperation when the majority of players cooperate and punishes defection when there's a lack of cooperation, thus encouraging a collective mindset where each player contributes to the group's success.
   - By adapting to the number of cooperators in the previous round, TFT-ACT maintains a balance between individual interests and collective success.

Pseudocode for the TFT-ACT strategy:

```
function TFT_ACT(n, m, k, r):
  players = [1, 2, ..., n]
  history = []
  round = 1

  while round <= r:
    if round == 1:
      cooperate = True # Initiate cooperation in the first round
    else:
      p = calculatePercentageOfCooperators(history)
      cooperate = (p >= m/n) # Apply decision rule

    players[currentPlayer] performs action cooperate and adds this action to history
    updateHistory(history, cooperate, currentPlayer)
    round += 1
    incrementCurrentPlayer()

  totalPayoff = calculateTotalPayoff(history, n, m, k, r)
  return totalPayoff
```
'''

description_COLLECTIVE_154 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Decision Rules:
   - In the first round, cooperate to demonstrate goodwill and trustworthiness (C).
   - For subsequent rounds, if a player i has cooperated in the previous round, the ATFT strategy will also cooperate (C). If not, the strategy will defect (D). This tit-for-tat behavior encourages reciprocation and builds long-term relationships.
   - In case of defecting, the ATFT strategy will reconsider cooperation if it observes a change in opponent's behavior towards cooperation (i.e., if the opponent cooperates in the following round).

2. Edge Cases:
   - First Round: Cooperate (C) as an act of goodwill and to increase the chances of triggering a chain of cooperation.
   - Last Round: Analyze the current state of cooperation among opponents. If there is a high proportion of cooperators, ATFT will continue cooperating (C). Otherwise, it will defect (D), avoiding potential losses in the final round with minimal cooperators.
   - Transition Rounds: The strategy evaluates its past interactions and adapts accordingly, as described in decision rules.

3. Collective Mindset:
   - ATFT encourages cooperation and fosters a collective mindset by promoting reciprocity and building trust among players. By rewarding cooperation, the strategy aims to create an environment where self-interest aligns with the collective good.
   - The strategy is adaptive and robust to various opponent behaviors due to its simple yet flexible decision rules, which allow it to respond effectively to changes in opponents' strategies over time.
'''

description_COLLECTIVE_155 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfTA)

1. Decision Rules:
   - Initially cooperate (C) in the first round to show goodwill and establish trust.
   - In subsequent rounds, players will mimic their opponents' behavior from the previous round: if the opponent cooperated in the last round (c_i-1 = 1), then the player will also cooperate (C). If the opponent defected (c_i-1 = 0), the player will defect as well (D).
   - In case of a change in strategy by an opponent, the player will take note and switch to a more aggressive or forgiving approach accordingly. The TfTA will switch to Tit-for-Tat Punishment (TfTP) if the opponent's defection rate exceeds a predetermined threshold (e.g., three consecutive defections). Alternatively, it may also switch to Tit-for-Tat Forgiveness (TfTF) if the opponent's cooperation rate exceeds a certain threshold (e.g., two consecutive cooperations after a series of defections).
   - In both TfTP and TfTF scenarios, the strategy will gradually return to its original approach over time by reducing the threshold for switching back.

2. Handle edge cases:
   - In the last round, players will continue to cooperate (C) regardless of their opponent's previous move since there is no future interaction.
   - For the initial rounds, TfTA will cooperate (C) in the first round, and if the opponent defected, it will switch to TfTP for a specified number of rounds. If the opponent cooperated initially, TfTA will continue with cooperation (C).

3. Be collective:
   - The core principle of TfTA aligns with a collective mindset by promoting mutual trust and cooperation through reciprocity. By mimicking opponents' moves, TfTA fosters an environment where players can build and maintain long-term relationships.
   - In the event of a breakdown in cooperation due to defections, TfTA encourages rebuilding trust by adapting its behavior based on observed patterns from the opponent. This allows for continued collaboration even when faced with deviations from the cooperative norm.
'''

description_COLLECTIVE_156 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for Collective Risk Dilemma

1. Specify decision rules:
   - In the first round (t=1), player cooperates (play C). This is a peace offering to potential partners, showing goodwill and intent to cooperate.
   - From the second round onwards (t>1), player adopts Tit-for-Tat behavior by copying the previous round's action of the majority of players (if there's a tie, player cooperates). If more than half of the players cooperated in the previous round, player also cooperates. Otherwise, player defects.
   - In case of an equal number of cooperators and defectors (m-1 players), player cooperates. This small deviation from strictly following the majority is intended to encourage cooperation when it is close to reaching the threshold.

2. Handle edge cases:
   - Last round (t=r): Player copies the action of the majority in the previous round, but with a twist. If the majority switched their actions compared to the previous-but-one round, player cooperates in the last round as a final attempt to encourage cooperation for future games.
   - Zero players: If no other player cooperated in the previous round (m or more players defected), player defects since cooperating would not help meet the minimum cooperators needed.

3. Be collective:
   - The strategy is designed to show flexibility and adaptability, encouraging cooperation when it seems likely to succeed while also punishing defection to discourage future free-riding behavior. This aims to create a collective mindset by promoting cooperation and reciprocity among players.

Pseudocode for Adaptive Tit-for-Tat strategy:

```
def ATfT(t, history, n, m):
  if t == 1: # First round
    return 'C' # Cooperate

  majority = count_majority(history[t-1])
  if majority > m: # More than half cooperated in the previous round
    return 'C' # Cooperate
  else: # Less than half cooperated, or equal number of cooperators and defectors
    if len(history) == t: # Last round, and majority switched their actions compared to the previous-but-one round
      return 'C' # Cooperate as a final attempt to encourage cooperation for future games
    else: # General case
      return opposite(majority_action(history[t-1])) # Copy the action of the majority in the previous round, but with a twist

def count_majority(actions):
  cooperators = sum([1 if action == 'C' else 0 for action in actions])
  return max((n - cooperators), (cooperators)) # Return the smaller of (n - cooperators) and (cooperators)

def majority_action(actions):
  cooperators = sum([1 if action == 'C' else 0 for action in actions])
  if cooperators > (len(actions) / 2):
    return 'C' # Majority of players cooperated
  else:
    return 'D' # Majority of players defected

def opposite(action):
  if action == 'C':
    return 'D'
  else:
    return 'C'
```
'''

description_COLLECTIVE_157 = '''
 Strategy Name: Tit-for-Tat with Adaptive Risk Aversion (TfTARA)

1. Decision Rules:
   - Initially cooperate in the first round (C_i, 1 = C). This sets a cooperative tone and avoids being labeled as a defector by others.
   - For subsequent rounds, observe the number of cooperators in the previous round. If more than (m-1) players cooperated (m > 1), continue to cooperate (C_i, t = C). If fewer than (m-1) players cooperated, defect (C_i, t = D). This encourages cooperation when it is beneficial and punishes defection.
   - Implement a learning mechanism to adapt to the opponent's behavior over time by adjusting the k factor based on the average number of cooperators in previous rounds. If more than m players are consistently cooperating, incrementally increase the k value (k = k + 0.1 if (m-1) <= avg_coopers < m; k = k + 0.2 if m <= avg_coopers). If fewer than m players are consistently cooperating, decrementally decrease the k value (k = k - 0.1 if avg_coopers < (m-1); k = k - 0.2 if avg_coopers <= (m-2)).

2. Handle Edge Cases:
   - In the last round, cooperate if more than (m-1) players cooperated in the previous round, as the strategy aims to encourage cooperation even at the end of the game. If fewer than (m-1) players cooperated, defect since there are no further rounds to punish or reward actions.
   - In the first round, cooperate regardless of the number of cooperators observed in past games, as we need to set a cooperative tone and avoid being labeled as a defector by others.

3. Be Collective:
   - The strategy is designed to align with the collective mindset by promoting cooperation when it is beneficial and punishing defection. It encourages players to collaborate and work together, rewarding them for mutual risk aversion and collective success.
   - By adjusting the k factor based on the average number of cooperators in previous rounds, the strategy learns from its opponents' behavior and adapts to various playing styles, fostering a more cooperative environment among players.
'''

description_COLLECTIVE_158 = '''
 Title: Titan Strategy for Collective Risk Dilemma

1. Decision Rules (Cooperate vs Defect):
   - The Titan Strategy is based on a probability of cooperating that adapts to the current situation and past performances.
   - In each round, calculate the percentage of cooperators in the previous r rounds (excluding the current round). If this percentage exceeds a certain threshold (T), the player chooses to Cooperate; otherwise, it defects.
   - The adaptive threshold T is calculated as follows:
     - If the number of players (n) is odd, T = m / n + α
     - If the number of players (n) is even, T = (m + 1) / n + α
     - Where α is a small positive constant that adjusts the probability of cooperating when the threshold is close to an integer value.

2. Handling Edge Cases:
   - First Round: Players should randomly decide whether to Cooperate or Defect, with probabilities proportional to T and (1-T) respectively. This ensures that the strategy exhibits a certain degree of trust in others from the start.
   - Last Round: The player will cooperate if the number of cooperators in the previous r-1 rounds exceeded the threshold; otherwise, it defects. In other words, the strategy tries to mimic the collective behavior observed so far.

3. Being Collective:
   - The Titan Strategy prioritizes collective success over individual gain by encouraging cooperation when the majority of players have cooperated in the past. This promotes a more collaborative approach and increases the chances of achieving the minimum cooperators needed (m).
   - Additionally, the strategy's adaptive threshold ensures that it can adjust its level of trust in others based on the observed behavior throughout the game.
'''

description_COLLECTIVE_159 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
In each round, the ATFT strategy starts by cooperating (C). If more than m players also cooperated in the previous round, it continues cooperating. If less than m players cooperated in the previous round or if it was the first round, it defects (D) in this round as a punishment for non-cooperation.

Pseudocode:
```
function ATFT(previous_round_cooperators, game_parameters) {
  if (first_round()) {
    return Cooperate()
  }

  num_cooperators_prev = previous_round_cooperators
  if (num_cooperators_prev >= m) {
    return Cooperate()
  } else {
    return Defect()
  }
}
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
In the first round, ATFT cooperates to start fresh and give others a chance. In the last round, it follows its decision rule based on the previous round's cooperation count as usual.

Pseudocode:
```
function first_round() {
  return (round_number == 1)
}
```

3. Be collective - Clearly align with the collective mindset
By cooperating when others do and punishing them when they don't, ATFT fosters cooperation as a group norm while being robust to different opponent behaviors. It maintains fairness within the community by not taking advantage of others and encouraging reciprocity over time. The strategy is simple enough to follow yet flexible enough to adapt to various player strategies, making it suitable for a wide range of opponents.
'''

description_COLLECTIVE_160 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Decision Rules:
   - Initiate cooperation (play C) in the first round to demonstrate goodwill and encourage others to cooperate.
   - In subsequent rounds, players will imitate the actions of their opponents from the previous round. If an opponent cooperated, the player will also cooperate; if the opponent defected, the player will defect. This encourages reciprocity and stability in cooperation.
   - If a majority (more than (n-m)/2) of players have defected in the current round, break away from Tit-for-Tat and start cooperating again in the next round to encourage a shift back towards cooperation. This is an adaptive strategy that can help recover from a breakdown in cooperation.
   - In the last round, players should maximize their total payoff by cooperating if the number of cooperators meets or exceeds m, and defecting otherwise.

2. Handling Edge Cases:
   - In the first round (t=1), play C.
   - In the last round (t=r), if the number of cooperators meets or exceeds m, play C; otherwise, play D to maximize individual payoff.

3. Being Collective:
   - The strategy is designed to encourage cooperation and reciprocity among players, promoting a collective mindset that benefits all participants in the long term.

Pseudocode:

```python
def ATFT(n, m, k, r, history):
    if t == 1:
        action = C
    else:
        majority = (n + 1) // 2
        cooperators = sum(history[t-1]) >= majority and m
        action = cooperators and opponents_cooperated[t-1] or not cooperators and opponents_defected[t-1]

    if t == r:
        action = sum(history[-1]) >= m and C or D

    opponents_cooperated[t] = cooperators
    opponents_defected[t] = not cooperators
    return action
```

In this pseudocode, `opponents_cooperated` and `opponents_defected` are arrays storing the actions of all other players in each round. The strategy is adaptive as it adjusts its behavior based on historical information about opponent actions.
'''

description_COLLECTIVE_161 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfTA)

1. Decision Rules:
   - In the first round, cooperate (C), signifying goodwill and trust towards others.
   - For subsequent rounds, observe the actions of other players in the previous round. If a majority (≥ m-1) of players cooperated, also cooperate. If not, defect (D). This rule encourages cooperation when it is reciprocated but can defend against defection by following suit.
   - If a player repeatedly deviates from cooperating (more than c*m rounds with no reciprocation), the strategy temporarily adapts and starts defecting for the next p rounds, where c and p are constants that determine the level of patience and response to repeated defections. Once the adversarial behavior stops or a predefined number of rounds passes, the strategy resets and returns to cooperating again.

2. Handling Edge Cases:
   - In the last round, cooperate if it benefits the player (i.e., if m players have already cooperated in that round).
   - In the first few rounds, be more patient with repeated defections (e.g., c=0.5 for the first 1/4 of rounds), then gradually increase the aggressiveness (c=1) as the game progresses. This allows for initial goodwill but also ensures a response if cooperation is not reciprocated over time.

3. Being Collective:
   - By following the majority rule and only deviating when others do, this strategy aligns with a collective mindset. It encourages cooperation while still protecting against repeated defection, fostering a sense of fairness and mutual trust among players.
'''

description_COLLECTIVE_162 = '''
 Strategy Name: Tit-for-Tat with Threshold Adaptation (TFTA)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, the TFTA strategy cooperates if the number of players who cooperated in the previous round is greater than or equal to the minimum cooperation threshold (m). Otherwise, it defects. This rule is designed to reward cooperation when it is common and punish defection when others are cooperating.

Pseudocode:
```
function TFTA(previous_round_cooperation):
    if previous_round_cooperation >= m:
        return Cooperate
    else:
        return Defect
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

For the first round, TFTA uses a random strategy to initiate cooperation or defection, as there is no previous history available. In the last round and other specific situations like reaching a predefined number of rounds, TFTA may adopt a cooperative approach as a goodwill gesture to encourage long-term cooperation with opponents.

Pseudocode:
```
function first_round():
    return random(Cooperate, Defect)

function last_round_or_some_specific_conditions():
    if game_round == r or some_condition:
        return Cooperate
    else:
        return TFTA(previous_round_cooperation)
```

3. Be collective - Clearly align with the collective mindset

TFTA's cooperative approach encourages a collective mindset by rewarding cooperation when it is common and punishing defection when others are cooperating. This strategy aims to create an environment where long-term cooperation can thrive, as players that consistently follow this rule of reciprocity are more likely to experience higher payoffs in the long run.

TFTA's adaptive nature allows it to respond effectively to a wide range of opponent behaviors, making it suitable for a tournament setting with various competing AI strategies. The strategy can be refined and optimized further based on feedback from game performance and specific opponents' tendencies.
'''

description_COLLECTIVE_163 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for Collective Risk Dilemma

1. Decision Rules:
   - In the first round, cooperate to show goodwill and establish a cooperative relationship (C).
   - For subsequent rounds, if a player i cooperated in the previous round and at least m players cooperated, also cooperate (C). Otherwise, defect (D). This rule mimics reciprocity behavior.
   - If the game is near its end, cooperate less frequently to allow others opportunities for cooperation even when the strategy has deviated previously (e.g., in the last 3 rounds, gradually increase the probability of cooperation towards the default action of cooperating in the first round).

2. Handle edge cases:
   - In the first round, cooperate unconditionally (C).
   - For the last round and penultimate round, if the strategy has defected in the previous round, cooperate; otherwise, continue with the current decision rule.
   - For the second-to-last round, if the strategy has defected in both the previous two rounds, cooperate; otherwise, continue with the current decision rule.

3. Be collective:
   - The strategy aims to promote cooperation by exhibiting reciprocal behavior and maintaining a long-term relationship with other players while being adaptive to their strategies.
   - By cooperating in the first round, it shows commitment to a cooperative outcome, which encourages others to do the same.

Pseudocode:

```python
def play_game(n, m, k, r):
    strategy = ["C" for _ in range(r)] # Initialize a list of actions for each round

    # First round: cooperate unconditionally
    strategy[0] = "C"

    # Last r-3 rounds: adapt to the game's progress
    last_rounds = r - 3
    strategy[last_rounds - 1] = adapt(strategy[-2])
    strategy[last_rounds - 2] = adapt(strategy[-3])
    strategy[last_rounds - 3] = adapt(strategy[-4])

    # Remaining rounds: reciprocal behavior based on previous round's action and number of cooperators
    for i in range(last_rounds, r):
        cooperators = count_cooperators(strategy[:i])
        if cooperators >= m and strategy[i - 1] == "C":
            strategy[i] = "C"
        else:
            strategy[i] = "D"

    # Function to count the number of cooperators in a list of actions
    def count_cooperators(actions):
        counter = 0
        for action in actions:
            if action == "C":
                counter += 1
        return counter

    def adapt(action):
        # Adapt strategy based on the game's progress (e.g., less cooperation towards the end)
        probability_of_cooperation = 1 - (r - i - 1) / last_rounds
        if action == "C":
            return "C" if random.random() <= probability_of_cooperation else "D"
        return "C" # If the strategy has defected, cooperate in the last few rounds to encourage cooperation
```
'''

description_COLLECTIVE_164 = '''
 Strategy Name: Tit-for-Tat (with a twist) for Collective Risk Dilemma

1. Decision Rules:
   - Cooperate in the first round to demonstrate good faith and encourage others to do so. (C in Round 1)
   - In subsequent rounds, cooperate if at least m players cooperated in the previous round, and defect otherwise. This rule encourages cooperation when it is beneficial for the group but also punishes defection. (C_t = max(m-count_C(t-1),0) <= m and D_t = 1 - C_t)
   - If the number of players drops below n/2 during a round, temporarily switch to purely cooperative behavior for the next r/2 rounds as an attempt to rebuild trust. (If count_C(t-1) < n/2, then Cooperate in the next r/2 rounds)

2. Handling Edge Cases:
   - Last Round: Play according to the current decision rule. Since payoffs are cumulative over all rounds, it's important to maintain a cooperative environment until the very end.
   - First Round: Cooperate as mentioned earlier.

3. Being Collective:
   - The strategy is designed with a collective mindset in mind. It promotes cooperation when possible and punishes defection to encourage a culture of reciprocity among players.
   - The temporary cooperative phase after a significant drop in cooperation aims at rebuilding trust within the group and fostering a more collaborative environment.
'''

description_COLLECTIVE_165 = '''
 Title: Tit-for-Tat with Adaptive Cooperation Threshold (TFTC) Strategy for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, the TFTC strategy will compare the number of cooperators in the previous round to the adaptive cooperation threshold (CT). If the number of cooperators is greater than or equal to CT, the strategy will cooperate; otherwise, it will defect. The cooperation threshold adapts based on the average number of cooperators over a sliding window of past rounds.

Pseudocode:
```
function get_cooperators(round):
    return count of players who cooperated in round

function get_average_cooperation(window_size, rounds):
    sum_cooperators = 0
    for i in range(window_size - 1, 0, -1):
        sum_cooperators += get_cooperators(rounds - i)
    return sum_cooperators / window_size

function get_adaptive_threshold(average_cooperation, window_size):
    if average_cooperation >= m:
        return m
    else:
        return int(average_cooperation * window_size)

function TFTC_decision(round, players, k, m, window_size):
    cooperators = get_cooperators(round - 1)
    average_cooperation = get_average_cooperation(window_size, round - 1)
    cooperation_threshold = get_adaptive_threshold(average_cooperation, window_size)

    if cooperators >= cooperation_threshold:
        return 'Cooperate'
    else:
        return 'Defect'
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

For the first round, since there is no sliding window of past rounds, TFTC will assume that m players cooperate. In the last round, it continues to adapt its cooperation threshold based on the sliding window but takes into account that there are no more rounds after the current one.

Pseudocode:
```
function first_round(players, m):
    if len(players) < m:
        return 'Defect'
    else:
        return 'Cooperate'

function last_round(round, players, k, m, window_size):
    cooperators = get_cooperators(round - 1)
    average_cooperation = get_average_cooperation(window_size, round - 1)
    cooperation_threshold = get_adaptive_threshold(average_cooperation, window_size)

    if cooperators >= cooperation_threshold:
        return 'Cooperate'
    else:
        return 'Defect'
```

3. Be collective - Clearly align with the collective mindset

The TFTC strategy is designed to promote cooperation by responding positively to other players who also choose to cooperate, and penalizing those who do not cooperate. The adaptive cooperation threshold allows TFTC to adjust its level of cooperation based on the overall behavior of other players in the game. Additionally, the sliding window ensures that the strategy remains flexible and responsive to changes in player behavior over time.
'''

description_COLLECTIVE_166 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFT-A) for Collective Risk Dilemma

1. Decision Rules:
   - In each round, evaluate the number of cooperators in the previous round. If the number of cooperators is less than m, defect in the current round (D). If the number of cooperators is equal to or greater than m, cooperate in the current round (C). This ensures alignment with the collective mindset by following the majority's action.
   - To make the strategy adaptive and robust, implement a forgiving mechanism: if an opponent defected in the previous round but has consistently cooperated for 'f' consecutive rounds prior to that, cooperate in the current round. This mimics the "Tit-for-Tat" strategy from prisoner's dilemma, making it more forgiving and suitable for the Collective Risk Dilemma.

2. Handle Edge Cases:
   - In the first round, since there is no previous round history, simply cooperate (C) to initiate cooperation and set the 'f' counter to a high value such as n-1 or r-1, reflecting the number of total rounds played so far.
   - In the last round, if the number of cooperators in the penultimate round was less than m, defect (D) since there are no more subsequent rounds for forgiveness. If the number of cooperators in the penultimate round was equal to or greater than m, cooperate (C).
   - If an opponent has never cooperated before, set 'f' to a low value such as 1 or 2 and continue evaluating future actions based on the decision rules above.

3. Collective Mindset:
   - TFT-A inherently promotes cooperation as it follows the majority's action and forgives consistent cooperators. This collective mindset is maintained by adhering to the decision rules that encourage cooperation when a majority of players are also cooperating. The strategy will adjust its forgiveness level based on the total number of rounds played (f).

Pseudocode:

```
function TFT-A(history, m, f=n-1)
  if round = 1 then
    cooperate
    set f to n-1 or r-1
  end if

  if history[t-1].cooperators < m then
    defect
  else
    if (history[t-1].cooperators >= m) and ((t > f) or (history[t-f-1]...history[t-1]).are_all_cooperators()) then
      cooperate
    else
      defect
    end if
  end if
end function
```
'''

description_COLLECTIVE_167 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules:
   - In the first round (t=1), TFT-AC cooperates to show a willingness to collaborate and build trust. If any other player defects, TFT-AC will defect in the next encounter as a punishment.
   - For subsequent rounds (t > 1), if an opponent cooperated in the previous round, TFT-AC cooperates to maintain reciprocity; otherwise, it defects as retaliation for defection.
   - If m or more players cooperate, TFT-AC calculates the average cooperation rate (average number of cooperators divided by n) and compares it with a predefined threshold (e.g., 0.6). If the rate exceeds the threshold, TFT-AC increases its propensity to cooperate by 5% for the next round; if not, it decreases its propensity to cooperate by 5%.
   - The propensity to cooperate ranges from 0 (never cooperate) to 1 (always cooperate). A propensity of 0.5 signifies an equal probability of cooperating or defecting.

2. Handle edge cases:
   - In the last round, TFT-AC behaves based on the current propensity to cooperate since no future interactions can influence its long-term payoff.
   - In case of a tie (same number of players cooperated and defected), TFT-AC follows the same rule as in the first round: cooperate initially to encourage collaboration.

3. Be collective:
   - TFT-AC aligns with the collective mindset by promoting reciprocity, trust, and long-term cooperation while adapting its behavior based on the collective actions of opponents.
   - By increasing its propensity to cooperate when the community shows a willingness to collaborate, TFT-AC encourages others to maintain a higher cooperation rate, leading to better overall results for all players.
'''

description_COLLECTIVE_168 = '''
 Strategy Name: Tit-for-Tat with Cooperative Adaptation (TFT-CA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, players cooperate to foster a cooperative environment (C).
   - For subsequent rounds, players imitate the actions of their opponents from the previous round: if an opponent cooperated in the last round, players cooperate; otherwise, they defect.
   - If the number of opponents who cooperated exceeds a threshold (m), the player adjusts its cooperation level to match the majority of cooperators and maintain a stable cooperative environment (adaptive tit-for-tat).

2. Handle edge cases:
   - In the last round, players cooperate as a final attempt to maximize payoff since there are no future rounds.
   - If a player encounters a deviation from previous cooperation, it will follow its adaptive tit-for-tat rule and adjust its cooperation level accordingly. However, if the number of cooperators in the current round is still above the threshold (m), players will temporarily switch to imitating the majority's behavior before returning to their adaptive TFT approach in the following rounds.

3. Be collective - Clearly align with the collective mindset:
   - The strategy promotes cooperation by initially cooperating and mimicking others' cooperation or defection.
   - The adaptive component allows players to adjust their actions based on the majority's behavior, fostering a more collective approach that encourages stability and long-term cooperation.
'''

description_COLLECTIVE_169 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules:
   - Initiation: Cooperate in the first round (C) to show goodwill and trustworthiness.
   - Response: If a player cooperated in the previous round, cooperate in the current round as well (C). Otherwise, defect (D) as a punishment for non-cooperation.
   - Adaptation: After each round, update a 'history' score for each opponent based on their actions. If an opponent has cooperated more than they have defected, cooperate with them in the next round (C); otherwise, defect (D). The history score can be updated as follows:
     ```
     if other_player_cooperated_last_round then:
       update_score(opponent, 1)
     else:
       update_score(opponent, -1)
     ```
   - Forgiveness: After a period of defection (e.g., missing m rounds), an opponent's history score is reset to zero, allowing them another chance to cooperate.

2. Handle edge cases:
   - First round: Cooperate (C).
   - Last round: Use the current 'history' scores to decide whether to cooperate or defect based on the rules above.
   - Transitions between cooperation and defection: After a history score update, if the opponent has an equal number of cooperations and defections in their history, randomly choose either C or D for the next round to avoid unintentional alignment with opponents who might have made random choices so far.

3. Be collective: Maintain a balance between individual interest (avoiding defection when others do not cooperate) and group success (cooperating when others do cooperate). The strategy encourages cooperation but does not rely on coordination mechanisms or shared norms, making it adaptable to various opponent behaviors. It also demonstrates forgiveness by allowing opponents to regain trust through cooperation after a period of defection.
'''

description_COLLECTIVE_170 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TFTC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to establish a friendly starting point (C).
   - For subsequent rounds, if the number of cooperators in the previous round is greater than or equal to the minimum cooperation threshold m, cooperate (C). Otherwise, defect (D). This rule encourages reciprocity and punishes defection.
   - To adapt to a wider range of opponent behaviors, implement an improvement factor that gradually increases the cooperative threshold if continuous cooperation from opponents is detected (see Edge Cases section for more details).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as mentioned earlier (C).
   - In the last round, cooperate if the current cooperative threshold allows it and the number of cooperators in the previous round is at least equal to the cooperative threshold. This ensures a fair final round payoff distribution when the game ends.

3. Be collective - Clearly align with the collective mindset
   - Prioritize the common good by encouraging cooperation when conditions allow, but also ensuring fairness by not being overly exploited in case of uncooperative opponents.
   - The adaptive cooperative threshold mechanism encourages a balance between individual and collective interests, as it responds to opponent behavior while considering the minimum required cooperation for success (m).

Pseudocode:

```python
def TFTC(n, m, k, r):
    cooperation_threshold = m  # Initial cooperative threshold
    payoff_history = []  # History of payoffs

    for round in range(1, r + 1):
        if round == 1:  # First round
            action = 'C'  # Cooperate
        else:
            cooperators_last_round = count_cooperators(payoff_history, n)

            if cooperators_last_round >= cooperation_threshold:
                action = 'C'  # Cooperate
            else:
                action = 'D'  # Defect

        # Record the payoff for this round
        payoff = calculate_payoff(action, cooperation_threshold, k)
        payoff_history.append(payoff)

        # Adaptive cooperative threshold mechanism
        if cooperators_last_round >= cooperation_threshold and round > 1:
            cooperation_threshold += 0.05 * (r - round)  # Increase threshold by 5% each time a round is passed without defection

    return payoff_history
```
'''

description_COLLECTIVE_171 = '''
 Strategy Name: Adaptive Tit-for-Tat with Cooperative Threshold (ATFTC)

1. Decision Rules:
   - In each round, if the number of cooperators in the previous round is greater than or equal to the cooperative threshold 'm', player i will cooperate (play C).
   - If the number of cooperators in the previous round is less than the cooperative threshold 'm' AND the number of collaborations in the last 'n-1' rounds is also less than 'n-m+1', player i will defect (play D). This rule is designed to discourage freeriding and maintain a minimum level of cooperation.
   - Otherwise, if the number of cooperators in the previous round is less than the cooperative threshold 'm' AND the number of collaborations in the last 'n-1' rounds is greater than or equal to 'n-m+1', player i will cooperate (play C) to maintain existing cooperation levels.

2. Handling Edge Cases:
   - First Round: Player i will cooperate as there is no past history to consider.
   - Last Round: Player i's decision will be based on the number of cooperators in the previous round according to the decision rules mentioned above.

3. Being Collective:
   - This strategy emphasizes a collective mindset by encouraging cooperation when a majority of players have also chosen to collaborate. It also punishes freeriders by defecting when necessary to maintain a minimum level of cooperation. The threshold 'm' can be tuned depending on the specific game parameters and desired level of cooperation.

Pseudocode:

```python
def ATFTC(n, m, r):
    history = [[0 for _ in range(n)] for _ in range(r)]  # To store past collaboration history

    def play_round(past_cooperation):
        total_cooperation = sum(past_cooperation)
        if total_cooperation >= m:
            return 'C'  # Cooperate
        elif total_cooperation < m and len(past_cooperation) < n-m+1:
            return 'D'  # Defect
        else:
            return 'C'  # Cooperate to maintain existing cooperation levels

    for round in range(r):
        if round == 0:  # First round
            history[round] = [1 if p == 'C' else 0 for p in [play_initial()]*n]
        else:
            history[round] = play_round(history[round-1])

def play_initial():
    return 'C'  # Cooperate in the first round, no past history to consider
```
'''

description_COLLECTIVE_172 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially, cooperate in the first round to show goodwill and encourage cooperation. After that, the strategy adapts based on the opponent's behavior in previous rounds:
     - If the opponent cooperates, continue cooperating as a positive reinforcement of their cooperation.
     - If the opponent defects, defect in the next round as a punishment for defection. This tit-for-tat mechanism encourages reciprocity and maintains the collective mindset by only deviating from cooperation when necessary.
   - Pseudocode:
     ```
     function ATFT(history):
         if round = 1 then
             return COOPERATE

         last_round_opponent_action = history[-1][opponent_index]

         if last_round_opponent_action == COOPERATE then
             return COOPERATE
         else
             return DEFECT
     ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as mentioned before. In the last round and any other specific situations like a tie for the required number of cooperators (m), the strategy will cooperate since the goal is to maximize long-term payoff.

3. Be collective - Clearly align with the collective mindset
   - By adopting a tit-for-tat approach, this strategy maintains a collective mindset by encouraging reciprocity and punishing defection. Cooperation is used as a tool for collaboration and building trust among players, while defection serves as a means of defending against exploitation. This balance between cooperation and punishment aligns the strategy with the collective mindset required for success in this game.
'''

description_COLLECTIVE_173 = '''
 Strategy Name: Tit-for-Tat (TFT) Adaptive Cooperation Strategy for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially cooperate in the first round (c_i = 1, t=1) to demonstrate goodwill and encourage cooperation among players.
   - In subsequent rounds (t > 1), mimic the behavior of other players from the previous round: if most players cooperated (more than m-1 players cooperated), also cooperate (c_i = 1). Otherwise, defect (c_i = 0). This strategy fosters both cooperation and punishes defection.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as previously mentioned (c_i = 1, t=1)
   - In the last round, players should consider the overall performance of the game: if the cooperation threshold has been met for a majority of rounds, cooperate to maximize potential rewards; otherwise, defect.
   - When switching from cooperation to defection or vice versa, introduce a smoothing factor to avoid abrupt changes that could destabilize cooperation. For example, players may gradually shift towards defecting over several rounds (if most players have been defecting) or cooperating if the majority has been cooperating.

3. Be collective - Clearly align with the collective mindset
   - Encourage long-term cooperation by following TFT rules, which promote stable and mutually beneficial outcomes while also punishing short-sighted defection.
   - Foster collective thinking through adaptive behavior that responds to the actions of other players in a way that encourages and rewards cooperative play.

Pseudocode for the Tit-for-Tat Adaptive Cooperation Strategy:
```
def TFT_Strategy(n, m, k, r):
    players = {1: 0, ..., n: 0} # Initialize player cooperation count to zero
    i, t = 1, 1 # Set initial player and round indices

    while t <= r:
        if t == 1: # First round, cooperate
            players[i] += 1
            c_i = 1
        else:
            # Calculate number of cooperators in the previous round
            cooperators = sum(players.values())

            # If more than m-1 players cooperated, also cooperate; otherwise, defect
            if cooperators > (m - 1):
                players[i] += 1
                c_i = 1
            else:
                c_i = 0

        # Update player payoffs based on the TFT game structure
        if cooperators < m:
            π_i = (1 - c_i)
        elif cooperators >= m:
            π_i = (1 - c_i) + k

        # Total game payoff for each player over r rounds
        total_payoff += π_i
        t += 1
        i += 1 if i < n else i = 1

    return total_payoff
```
'''

description_COLLECTIVE_174 = '''
 Strategy Name: Tit-for-Tat (with Adaptive Cooperation Threshold)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initiate cooperation in the first round (C).
   - In subsequent rounds, cooperate if the percentage of cooperators in the previous round is greater than or equal to the Adaptive Cooperation Threshold (ACT), otherwise defect (D). The ACT increases slightly after each round where fewer than m players cooperated and decreases slightly after each round where m or more players cooperated.
   - The ACT is defined as follows: ACT = initial_threshold * (1 + learning_rate * (cooperators_last_round - m))
       - initial_threshold: a constant set between m and n, determining the starting point for ACT.
       - learning_rate: a small positive value controlling how quickly ACT adapts to changes in cooperative behavior.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate regardless of past history.
   - For the last round, use the same decision rules as regular rounds but understand that the total game payoff is calculated based on the sum of payoffs over all rounds.

3. Be collective - Clearly align with the collective mindset
   - By starting with cooperation and adjusting the ACT based on the behavior of other players, the strategy demonstrates a willingness to cooperate but also adapts to exploitative or uncooperative opponents. This balance allows for a more robust performance against a wide range of opponent behaviors while still promoting collective success when others are also willing to cooperate.

Pseudocode:
```
def tit_for_tat(n, m, k, r, initial_threshold, learning_rate):
    # initialize ACT and track cooperators last round
    act = initial_threshold
    cooperators_last_round = 0

    for round in range(r):
        # cooperate if the percentage of cooperators is greater than or equal to ACT
        if cooperators_last_round >= (m * n / r) and act > m:
            action = 'C'
        else:
            action = 'D'

        # update ACT based on last round cooperators
        act = initial_threshold * (1 + learning_rate * (cooperators_last_round - m))

        # take action and observe payoff
        pi = play_game(n, m, k, action)

        # update total game payoff
        total_pi += pi

        # record cooperators last round
        if action == 'C':
            cooperators_last_round += 1
        else:
            cooperators_last_round -= 1

    return total_pi
```
'''

description_COLLECTIVE_175 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFT-A) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
In each round, if the number of players who cooperated in the previous round is less than m, the strategy will defect (D). If the number of players who cooperated in the previous round is equal to or greater than m, the strategy will cooperate (C).

Pseudocode:
```python
def tft_a(round, past_actions):
  if len(past_actions) < 2:
    # First round, no history
    return 'C'

  if sum(past_actions[-2]) >= m:
    # Last two rounds had sufficient cooperation
    return 'C'
  else:
    # Last two rounds did not have sufficient cooperation
    return 'D'
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
As mentioned earlier, TFT-A treats the first round as an unknown starting state and cooperates. The end of the game is not considered since it's a repeated game structure. However, if there's a specific requirement for the last round, the strategy can be modified to defect in the last round by changing the pseudocode as follows:

Pseudocode:
```python
def tft_a(round, past_actions):
  if round == r:
    # Last round, defect since there's no further rounds
    return 'D'

  if len(past_actions) < 2:
    # First round, no history
    return 'C'

  if sum(past_actions[-2]) >= m:
    # Last two rounds had sufficient cooperation
    return 'C'
  else:
    # Last two rounds did not have sufficient cooperation
    return 'D'
```

3. Be collective - Clearly align with the collective mindset
The TFT-A strategy aligns with the collective mindset by cooperating when there is evidence of previous successful cooperation among players (i.e., m or more players cooperated in the previous round). It also punishes non-cooperative behavior, as it defects when there's a history of insufficient cooperation, which encourages future cooperation.

The TFT-A strategy follows a tit-for-tat approach where players cooperate initially but will defect if others do not reciprocate. This strategy is simple, robust to various opponent behaviors, and maintains collective interest by fostering a sense of fairness and trust among the players.
'''

description_COLLECTIVE_176 = '''
 Strategy Name: Adaptive Tit-for-Tat with Risk Aversion (ATfTRA)

1. Decision Rules:
   - Initial Cooperation (I-Coop): Cooperate in the first round to signal good intentions and promote cooperation. (c_i = 1 for t=1)
   - Reciprocity: If a player cooperated in the previous round, reciprocate by cooperating in the current round. If a player defected, also defect in the current round to punish defection. (c_i = prev_player_{j}_action for t > 1)
   - Risk Aversion: If there's a chance that the minimum cooperation threshold might not be met despite reciprocating, defect to ensure personal gain. In other words, if the number of cooperators in the previous round is less than (m-1), defect in the current round. (c_i = 0 if prev_cooperators < m-1)
   - Forgiveness: If a player deviated from cooperation and then returns to cooperation, forgive and reciprocate cooperation in the next round. (Reset forgiveness counter each time a player deviates.)
   - Conditional Risk Aversion: In the last round, consider the number of cooperators in the penultimate round to decide whether to cooperate or defect. If the number of cooperators is greater than or equal to m, cooperate; otherwise defect. (c_i = 1 if prev_cooperators >= m for t=r)

Pseudocode:

```python
def ATfTRA(round, cooperation_threshold, reward_factor, previous_players_actions):
    forgiveness_counter = 10
    current_player_action = 1 # I-Coop

    if round == 1:
        current_player_action = 1

    elif round < r:
        if previous_players_actions.count(1) >= (m-1):
            current_player_action = 1
        else:
            current_player_action = 0

    elif round == r:
        current_player_action = 1 if previous_players_actions.count(1) >= m else 0

    elif forgiveness_counter > 0 and previous_players_actions[-2].count(1) < m:
        forgiveness_counter -= 1
        current_player_action = 0

    elif forgiveness_counter == 0 and previous_players_actions[-2].count(1) >= m:
        forgiveness_counter = 10
        current_player_action = 1

    return current_player_action
```

This strategy combines initial cooperation, reciprocity, risk aversion, and forgiveness to encourage long-term cooperation while being adaptive to various opponent behaviors. The conditional risk aversion in the last round ensures that the player doesn't take unnecessary risks when the game is about to end.
'''

description_COLLECTIVE_177 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Decision Rules:
   - Initially cooperate in the first round (C_i, 1 = 1).
   - In subsequent rounds, evaluate whether cooperation is beneficial based on the current and past actions of others. This evaluation is done using an adaptive cooperation threshold (m_i), which adjusts dynamically throughout the game based on previous experiences.
   - If the number of cooperators in the last r_c rounds exceeds m_i, then increase the cooperation threshold for future rounds (m_i += 1).
   - If the number of cooperators in the last r_d rounds is less than m_i, then decrease the cooperation threshold for future rounds (m_i -= 1).
   - Otherwise, if the number of cooperators is exactly equal to m_i in the last r_c and r_d rounds, keep the cooperation threshold unchanged. Here, r_c and r_d are the lookback periods for cooperative and defective phases respectively (e.g., r_c = r_d = 3).
   - Cooperate when the current number of cooperators exceeds or equals the adaptation threshold (C_i = 1 if count(Cooperators) >= m_i). Otherwise, defect (C_i = 0).

2. Handling Edge Cases:
   - In the first round, cooperate as mentioned earlier (C_i, 1 = 1).
   - In the last round, evaluate cooperation based on the current adaptation threshold and number of cooperators in recent history (C_i = 1 if count(Cooperators) >= m_i).

3. Collective Mindset:
   - TFT-ACT maintains a balance between cooperation and defection by reacting to other players' actions, while still demonstrating a willingness to cooperate when conditions are favorable for collaboration. This strategy aligns with the collective mindset as it encourages mutual benefit through reciprocity but also protects itself from being exploited by defectors.
   - Additionally, TFT-ACT is adaptive and robust, adjusting its cooperation threshold based on past experiences to better respond to a wide range of opponent behaviors.
'''

description_COLLECTIVE_178 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFT-AC)

1. Specify decision rules:
   - Initially cooperate (C) in the first round to signal good intentions and promote trust.
   - For subsequent rounds, if a player i co-operated (c_i=1) in the previous round, cooperate again in the current round (C). If a player defected (c_i=0), defect in the current round (D). This mimics the original Tit-for-Tat strategy but with an added adaptability component.
   - If a player i has consistently cooperated for a certain number of rounds equal to the minimum cooperation threshold m, start cooperating regardless of the opponent's previous action (a form of forgiveness to encourage long-term cooperation). This adaptability factor helps maintain cooperation even if a mistake was made in the past.

2. Handle edge cases:
   - In the last round, regardless of the player's previous actions, cooperate since payoffs are determined solely by the number of cooperators in that specific round.
   - In the first round (round 1), always cooperate to establish a positive initial interaction and promote trust.

3. Be collective:
   - By focusing on past cooperation as the primary factor for decision-making, the strategy promotes collective mindset by rewarding consistent cooperation and punishing defection, encouraging players to work together towards mutual benefits.

Pseudocode:

```python
def TFT_AC(round, history):
  if round == 1 or len(history) < m:
    return 'C'  # Cooperate in the first round and when history is insufficient

  last_action = history[-1][-1]  # Last action of the opponent from previous round

  if sum(history[len(history)-m:]) >= m:  # Check if opponent has cooperated m rounds ago
    return 'C'  # Cooperate to forgive past mistakes
  else:
    return last_action  # Cooperate or defect based on the opponent's previous action
```
'''

description_COLLECTIVE_179 = '''
 Strategy Name: Tit-for-Tat Cooperation (TFTC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFTC adopts a reciprocal behavior that encourages cooperation when others cooperate and defects if they have previously defected. In the Collective Risk Dilemma, this translates to:
   - Cooperate (C) if at least m players cooperated in the previous round.
   - Defect (D) if fewer than m players cooperated in the previous round.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   For the initial round, TFTC will cooperate to initiate a positive cycle of cooperation. In the last round or any other critical points where the game might end (e.g., reaching a threshold for payoffs), TFTC decides based on the number of cooperators in the previous round following the decision rule from part 1.

3. Be collective - Clearly align with the collective mindset
   To be collectively minded, TFTC encourages cooperation as much as possible by reciprocating when others cooperate and incentivizing them to do so by cooperating first. This strategy aims for mutual benefits in the long run while being adaptive to various opponent behaviors.

Here is a simple pseudocode representation:

```python
def TFTC(round, players_cooperated_last_round, m, k):
    if round == 1:
        return 'C'

    if players_cooperated_last_round >= m:
        return 'C'
    else:
        return 'D'
```

In this pseudocode, `round` represents the current round number, and `players_cooperated_last_round` is the count of players who cooperated in the previous round. The other parameters are specified in the game rules.
'''

description_COLLECTIVE_180 = '''
 Strategy Name: Tit-for-Tat with Adaptive Threshold (TFT-AT)

1. Decision Rules:
   - Initially cooperate (C) in the first round to foster a sense of trust and cooperation.
   - In subsequent rounds, observe the number of cooperators (n_c) from the previous round. If n_c >= m, continue cooperating. Otherwise, defect (D).
   - When defecting, implement a penalty phase where you also defect in the next round if n_c < m. After the penalty phase, revert to observing n_c and decision making based on the game parameters.

2. Edge Cases:
   - In the first round (t=1), cooperate (C).
   - In the last round (t=r), evaluate the current state of cooperation, and make a decision based on the rules above (if n_c >= m, continue cooperating; otherwise defect and consider the penalty phase).
   - If faced with a situation where a majority of players have consistently defected, adapt the minimum cooperation threshold (m) to be closer to the observed number of defectors. This is done to avoid wasting resources on futile attempts at cooperation in uncooperative environments.

3. Collective Mindset:
   - The TFT-AT strategy seeks to foster and maintain a cooperative environment by initially cooperating and reciprocating cooperators while penalizing defectors through temporary defection. This approach encourages collective mindset as it rewards cooperation and discourages defection.

Pseudocode for the TFT-AT strategy:
```
function TFT_AT(t, n, m, k, history) {
  if (t == 1) return COOPERATE; // Cooperate in first round

  current_cooperators = countCooperatorsInHistory(history);
  if (current_cooperators >= m) return COOPERATE;
  else if (current_cooperators < m && t > r - penalty_length) return COOPERATE; // Exit penalty phase
  else return DEFECT; // Defect and start a new penalty phase
}

function countCooperatorsInHistory(history) {
  cooperators = 0;
  for each round in history:
    if (round.playerAction == COOPERATE) ++cooperators;
  return cooperators;
}
```
'''

description_COLLECTIVE_181 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT)

1. Decision Rules:
   - In each round i (except the first), cooperate if at least m players cooperated in the previous round, and defect otherwise. This encourages cooperation when it's beneficial to the group while being retaliatory against defection.
   - If a player has been consistently cooperative for a certain number of rounds, TFT-ACT will gradually increase its cooperative threshold (m). Conversely, if a player has been consistently defective, TFT-ACT will decrease its cooperative threshold. This adaptability allows the strategy to respond to various opponent behaviors and evolving group dynamics.
   - To prevent overreaction or under-reaction to temporary changes in cooperation rates, a smoothing factor can be used to average past cooperative rates before adjusting the cooperative threshold.

2. Handle edge cases:
   - In the first round, defect (D) as there's no history to base decisions on.
   - If the number of rounds is less than the required adaptation period for adjusting the cooperative threshold, use the initial m value.
   - In the last round, cooperate if the cooperative threshold has been exceeded during the game; otherwise defect. This encourages maintaining cooperation up to the end even when it may not be optimal in a single round.

3. Be collective:
   - The strategy prioritizes group benefits by promoting cooperation when it appears beneficial for the majority (m or more players).
   - By gradually adjusting the cooperative threshold based on observed behavior, TFT-ACT fosters an environment that rewards cooperation and punishes defection, aligning with a collective mindset.
'''

description_COLLECTIVE_182 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?

The ATFT strategy will start by cooperating in the first round to foster a sense of cooperation and trust among players. In subsequent rounds, it will imitate the actions of other players from the previous round: if most players (m or more) cooperated, the ATFT player will also cooperate; otherwise, it will defect. This encourages cooperation when it is rewarding, while retaliating against defection to maintain fairness and discourage exploitation.

Pseudocode for decision rule:
```
function decideAction(previous_actions, parameters) {
  if (round == 1) return COOPERATE;
  if (numberOfCooperators(previous_actions) >= m) return COOPERATE;
  else return DEFECT;
}
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the last round, since there are no subsequent rounds for payback, ATFT will cooperate if most players cooperated in the previous round, to maximize the potential reward. In the first round, as mentioned earlier, ATFT will cooperate to initiate cooperation.

3. Be collective - Clearly align with the collective mindset

ATFT strategy is inherently collaborative since it encourages cooperation when most players do so and retaliates against defection only if necessary. By following this approach, ATFT aims to foster an environment where cooperation is sustained throughout the game while still being robust against a wide range of opponent behaviors.
'''

description_COLLECTIVE_183 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to demonstrate trust and goodwill (C).
   - In subsequent rounds, if an opponent cooperated in the previous round, cooperate (C); otherwise, defect (D). This mimics the Tit-for-Tat strategy from game theory but is adapted for the Collective Risk Dilemma by introducing a cooperative bias in the first move.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round: Cooperate (C) to show good faith and set the stage for potential cooperation later on.
   - Last round or near-end scenarios (r rounds remaining ≤ threshold t): Cooperate more often as the game nears its end to ensure maximum rewards, even if it means taking risks in pursuit of mutual benefits. The exact value of t can be a parameter optimized for specific situations.
   - In case of tie (exactly m players cooperated): Cooperate as the majority action leads to the same outcome regardless of individual decisions.

3. Be collective - Clearly align with the collective mindset
   - Foster cooperation by demonstrating reliability and reciprocity, adhering to the strategy's decision rules consistently across all rounds.
   - If a majority of players adopt a similar cooperative strategy, the overall payoff will increase as more community projects are completed, benefiting all participants in the long run.

Pseudocode:
```
function AdaptiveTitForTat(round, history, m, n, k, t):
    if round == 1:
        return Cooperate()
    else:
        if history[round-1] >= m and last_t_rounds(round, t):
            return Cooperate()
        else:
            return Defect()
```
In the above pseudocode, `history[round-1]` represents the number of cooperators in the previous round, and `last_t_rounds(round, t)` checks if we are in one of the last `t` rounds. This strategy can be easily adjusted by modifying the value of `t`, or adding other parameters as needed for different tournament scenarios.
'''

description_COLLECTIVE_184 = '''
 Strategy Name: Tit-for-Tat (TFT) with Adaptation

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to set a positive tone and signal good intentions.
   - After the first round, observe the behavior of other players. If another player cooperated in the previous round (c_i^(t-1) = 1), then also cooperate (C). Otherwise, defect (D).
   - To adapt to opponent behaviors, introduce a tolerance parameter δ (0 < δ < m) that allows for occasional deviation. If more than δ players defect in the previous round, then consider it as a signal of uncooperative behavior and respond with defection.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate (C).
   - In the last round, if the minimum number of players needed to achieve collective success has been met during previous rounds, continue cooperating for higher rewards; otherwise, defect to protect personal resources.
   - For intermediate rounds, follow the decision rules mentioned in point 1.

3. Be collective - Clearly align with the collective mindset
   - Prioritize cooperation over self-interest when there is evidence of others being cooperative as well.
   - Adapt to opponent behaviors to encourage and support long-term collaboration and mutual benefits.

Pseudocode:
```
def tft_adaptive(n, m, k, r, history):
  tolerance = int((m-1)/2) # calculate the tolerance parameter
  current_round = len(history) + 1
  if current_round == 1:
    action = "C" # cooperate in the first round
  else:
    last_round_action = history[-1] # get the action of the previous round
    if sum(last_round_action.count('C')) >= m:
      action = 'C' # cooperate when the minimum number of players cooperated last round
    elif sum(last_round_action.count('C')) < m - tolerance:
      action = 'D' # defect when more than the tolerance number of players defected last round
    else:
      action = last_round_action[-1] # continue with the opponent's last action
  return action
```
'''

description_COLLECTIVE_185 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initialize cooperation in the first round (C_i, 1 = C)
   - In subsequent rounds, imitate the opponent's action from the previous round (C_i, t = C if opponent cooperated in the last round, otherwise D_i, t = D). This fosters a cooperative environment while punishing defections.
   - If an opponent switches from cooperation to defection, TFT-A waits for one round before reciprocating with cooperation (C_i, t+1 = C if opponent defected in the last round, otherwise keep the same action as the previous round). This provides a chance for opponents to correct their behavior without being immediately punished.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, TFT-A cooperates (C_i, 1 = C) regardless of the opponent's actions.
   - At the last round, TFT-A maintains its decision rule from step 1 since the game's total payoff depends on the final round's actions.
   - For any other edge cases (e.g., when reaching a certain threshold of rounds or specific opponent behaviors), TFT-A continues following the decision rule from step 1.

3. Be collective - Clearly align with the collective mindset
   - By adhering to the Tit-for-Tat strategy, TFT-A fosters cooperation within groups by responding cooperatively to cooperation and punishing defections in a measured way.
   - Through its adaptive behavior, TFT-A remains responsive to shifting opponent strategies while maintaining an overall cooperative stance, promoting collective benefits in the long run.

Pseudocode:

```python
def tft_a(round, opponent_actions, n, m, k):
  strategy = ['C'] * round + [None] * (r - round) # Initialize strategy as cooperation for the given number of rounds
  last_round = len(strategy) - 1

  def update_strategy(new_opponent_action):
    if new_opponent_action == 'C':
      strategy[last_round] = 'C'
    elif new_opponent_action == 'D':
      if last_round > 1 and strategy[last_round - 1] == 'D':
        strategy[last_round] = 'C'
      else:
        strategy[last_round] = 'D'

  for opponent_action in opponent_actions:
    update_strategy(opponent_action)

  return strategy
```
'''

description_COLLECTIVE_186 = '''
 Strategy Name: Adaptive Tit-for-Tat with Risk Aversion (ATfTRA)

1. Decision Rules:
   - In each round, ATfTRA considers both its own past actions and the number of cooperators in the previous round. The strategy cooperates if it has cooperated in the last round and there were enough cooperators (at least 'm' players); otherwise, it defects. This encourages reciprocity while also considering the collective goal of meeting the cooperation threshold.
   - To account for risk aversion, ATfTRA always cooperates when the number of cooperators in the previous round was equal to or greater than the minimum required ('m') and the reward factor 'k' is more than 1.5 times its current endowment. This encourages risk-averse players to contribute more to the community project when the potential gain exceeds their current wealth.
   - Pseudocode:
     ```
     function ATfTRA(round, own_past_action, num_cooperators_last_round, m, k, endowment):
         if round = 1 then
             return C or D with equal probability
         elif own_past_action = C and num_cooperators_last_round >= m then
             if endowment * k > (endowment * k) / 1.5 then
                 return C
             else
                 return D
         elif own_past_action = C and num_cooperators_last_round < m:
             return C
         elif own_past_action = D and num_cooperators_last_round >= m:
             if endowment * k > (endowment * k) / 1.5 then
                 return C
             else
                 return D
         else:
             return D
     ```

2. Handling Edge Cases:
   - In the first round, ATfTRA cooperates or defects with equal probability to avoid being exploited by other strategies that might have prior information about its behavior.
   - In the last round, ATfTRA behaves similarly to the penultimate round, as the strategy assumes future interactions are possible in tournaments with multiple games. However, it may be adjusted for specific tournament rules if necessary.

3. Collective Mindset:
   - By adopting reciprocity and risk-averse behavior, ATfTRA aligns itself with a collective mindset that encourages cooperation and long-term success for the group as a whole. This strategy balances individual interest and group goals effectively.
'''

description_COLLECTIVE_187 = '''
 Title: Titan Strategy for Collective Risk Dilemma

1. Decision Rules:
   - Cooperate (C) when the number of previous cooperators is greater than or equal to a threshold (T).
   - Defect (D) otherwise.

2. Threshold calculation:
   - In each round, calculate T as a function of m, k, and the current round r using the following formula: T = floor((m * r) / n + 1)

3. Edge Cases:
   - First Round: Since there is no previous data, use the threshold calculation to determine action (T = (m * 1) / n + 1).
   - Last Round: If the total number of cooperators in the previous rounds is greater than or equal to the calculated T, then all players should cooperate. Otherwise, defect.

4. Adaptive Behavior:
   - Players will adjust their threshold throughout the game based on the number of cooperators in the recent history, ensuring a balance between long-term and short-term benefits.

5. Robustness to opponent behaviors:
   - This strategy does not rely on other players following specific patterns or norms, making it adaptable to various opponent strategies.

Pseudocode for Titan Strategy:

```python
def titan_strategy(round, n, m, k):
    cooperators = 0

    if round == 1:
        threshold = floor((m * round) / n + 1)
    else:
        previous_cooperators = sum(cooperators for _ in range(round - 1))
        threshold = floor(((previous_cooperators + m * round) / n + 1) if (previous_cooperators >= threshold) else ((m * round) / n + 1))

    if cooperators >= threshold:
        return 'C' # Cooperate
    else:
        return 'D' # Defect
```

This strategy is designed to promote cooperation while adapting to various opponent behaviors and ensuring robustness in repeated interactions. By adjusting the threshold based on the number of previous cooperators, it encourages players to maintain a collective mindset that favors long-term benefits over short-term gains.
'''

description_COLLECTIVE_188 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Decision Rules:
   - In each round t, if the number of cooperators in the previous round (t-1) is less than m, then defect (D). If the number of cooperators in the previous round (t-1) is equal to or greater than m, then cooperate (C). This rule ensures cooperation when the majority cooperates and defection otherwise.
   - To adapt to changing opponent behavior, implement a Cooperative Threshold (CT) that gradually decreases over time if the number of cooperators consistently falls short of m and increases if the number of cooperators exceeds m. The CT is a percentage of total players required for cooperation, which starts at the minimum cooperators needed (m) and can range from m to n.
   - If the number of cooperators in a round equals or exceeds the current CT, then cooperate (C). If the number of cooperators is less than the current CT, then defect (D). The CT adjustment rule:
     - After every r/2 rounds, if the number of cooperators is less than m, decrease the CT by a small percentage. Conversely, increase the CT by a small percentage if the number of cooperators exceeds m. Adjustments should be made gradually to avoid sudden shifts in behavior.

2. Handle edge cases:
   - In the first round, cooperate since no prior information is available (CT = m).
   - In the last round, follow the current CT decision rule as usual.
   - If the game ends before r/2 rounds, do not adjust the CT for the remaining time as there isn't enough data to make an informed adjustment.

3. Be collective:
   - TFT-ACT is designed with a collective mindset in that it encourages cooperation when the majority of players are cooperating and defection when the majority is defecting. By adapting its Cooperative Threshold, the strategy aims to find a balance between long-term cooperation and short-term gains based on the behavior of other players.
   - The strategy also promotes fairness by offering the same reward (1 + k) as soon as the minimum number of cooperators is reached, encouraging others to cooperate rather than punishing those who defected earlier.
'''

description_COLLECTIVE_189 = '''
 Strategy Name: Adaptive Tit-for-Tat with Risk Aversion (ATfTra)

1. Decision Rules:
   - In each round, a player decides to cooperate (C) or defect (D). The decision rule is based on the number of previous cooperators (Nc) and the current round (t).
   - If Nc >= m AND t > 1, the player cooperates (C).
   - If Nc < m AND t > 1, the player defects (D).
   - In the first round (t = 1), the player randomly chooses between C and D with a probability bias towards cooperation. This is to avoid getting trapped in a suboptimal situation if all other players defect in the initial round.

2. Edge cases:
   - In the last round, the player cooperates regardless of past actions since the game ends soon.
   - If the number of players (n) is less than m, the strategy fails as a minimum of m players are required to cooperate for collective success. In this case, the player would randomly choose between C and D with no bias towards cooperation.

3. Collective Mindset:
   - The ATfTra strategy aims to foster a collaborative environment by rewarding cooperative behavior when enough players participate. It also punishes defection when it undermines the collective goal, promoting trust among players over time. However, it is designed to be robust against various opponent behaviors since it does not rely on any specific coordination mechanisms or assumptions about others sharing norms.

Pseudocode:

```python
def ATfTra(t, Nc, m):
    if t == 1:
        return rand_coop_bias() # Returns cooperate or defect with a bias towards cooperation
    elif Nc >= m and t > 1:
        return "C" # Cooperate
    else:
        return "D" # Defect

def rand_coop_bias():
    random_number = random.uniform(0, 1)
    if random_number > 0.5:
        return "C" # Cooperate with a probability greater than 0.5
    else:
        return "D" # Defect otherwise
```

The ATfTra strategy attempts to find a balance between cooperating and defecting based on the number of previous cooperators, promoting cooperation when there are enough participants while still being robust against various opponent behaviors.
'''

description_COLLECTIVE_190 = '''
 Strategy Name: Tit-for-Tat (TFt) Adaptive Cooperation Strategy for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, if the number of cooperators in the previous round (t-1) was less than m, play D (Defect). Otherwise, if the number of cooperators in the previous round was equal to or greater than m, play C (Cooperate). This simple strategy mimics reciprocal behavior and encourages cooperation while still ensuring personal gain when others defect.

Pseudocode:
```python
def tf_tat(previous_cooperation_count, m):
  if previous_cooperation_count < m:
    return 'D' # Defect
  else:
    return 'C' # Cooperate
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, players lack information about previous rounds. In such a case, play C (Cooperate) as a peace offering and demonstrate cooperative intentions. For the last round, continue following the main decision rule (above).

Pseudocode:
```python
def tf_tat(round_number, previous_cooperation_count, m):
  if round_number == 1:
    return 'C' # Cooperate in the first round as a peace offering
  else:
    return tf_tat(previous_cooperation_count, m)
```

3. Be collective - Clearly align with the collective mindset

The Tit-for-Tat strategy prioritizes cooperation when the majority of players have cooperated in the previous round. This collective approach encourages a sense of unity and reciprocity among players, as each player adjusts their actions based on the group's behavior rather than solely focusing on individual gain.
'''

description_COLLECTIVE_191 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFTA)

1. Decision Rules:
   - In the first round, cooperate to show goodwill and encourage others to do the same. (C)
   - For subsequent rounds, mimic the opponent's action from the previous round. If they cooperated, cooperate; if they defected, also defect. (If last_round_opponent_action == 'C', then action = 'C'; else action = 'D')
   - If more than a certain percentage (p) of players have chosen to cooperate in the recent past (e.g., last 'x' rounds), gradually increase the probability (q) of cooperating even if opponents have defected, to encourage collective cooperation. (If (number_of_cooperators_in_last_x_rounds > p * n) then q = q + increment; else q = 0)
   - If an opponent has recently begun to cooperate (e.g., last 'y' rounds), gradually increase the probability of reciprocating cooperation, even if they previously defected. (If (number_of_cooperators_from_opponent_in_last_y_rounds > 0) then r = r + increment; else r = 0)
   - The decision to cooperate or defect is based on a probability distribution: action = 'C' if random(0,1) < q * r; otherwise action = 'D'.

2. Handle Edge Cases:
   - In the last round, there are no edge cases because TFTA behaves as the final round approaches like it would in any other round.
   - In the first round, cooperate to encourage others to do the same and lay a foundation for potential collective cooperation.

3. Be Collective:
   - By mimicking opponents' actions, TFTA demonstrates willingness to contribute to the community project when others do so as well, thus fostering a sense of collective mindset.
   - The gradual increase in the probability of cooperating when more players have chosen to do so encourages long-term cooperation and collective success.
'''

description_COLLECTIVE_192 = '''
 Title: Tit-for-Tat Strategy for Collective Risk Dilemma

1. Specify decision rules:
   - Initially Cooperate (C) in the first round to show good faith and encourage cooperation from others.
   - In subsequent rounds, replicate the actions of the previous round's majority, i.e., if more than m players cooperated last round, also cooperate; otherwise, defect. This rule is known as "Tit-for-Tat" and encourages reciprocity among players.

2. Handle edge cases:
   - In the last round, replicate the actions of the previous round since the game is repeated and has no subsequent rounds.
   - In the first round, cooperate to start with a positive gesture that may encourage cooperation from other players.

3. Be collective:
   - This strategy prioritizes the collective interest by aligning with the majority's actions in each round, promoting long-term cooperation and minimizing defections.

Pseudocode:
```python
def tit_for_tat(n, m, k, r, history):
  # Initialize the strategy with cooperation in the first round
  strategy = [C] * r

  # Iterate through each round
  for t in range(1, r):
    # Check if more than m players cooperated last round
    if count_cooperators(strategy[t - 1]) >= m:
      # Cooperate in the current round to show reciprocity
      strategy.append(C)
    else:
      # Defect in the current round to discourage further defection
      strategy.append(D)

  return strategy
```
'''

description_COLLECTIVE_193 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Decision Rules:
   - Initially Cooperate (C) in the first round to demonstrate trust and goodwill. Subsequent decisions will be based on the past behavior of opponents.
   - If an opponent cooperates, reciprocate with cooperation. In other words, if opponent(i)'s action at round t was C, then cooperate in round t+1 (C).
   - If an opponent defected (D), defect in the next round as well to punish non-cooperation but remain open for future cooperation. In case of D from opponent(i) at round t, defect in round t+1 (D).
   - After defection by an opponent, cooperate again only if that opponent has recently cooperated before the defection. This ensures forgiveness and fosters long-term cooperation.

2. Handling Edge Cases:
   - First Round Strategy: Cooperate to set a cooperative tone.
   - Last Round Strategy: Cooperate even if an opponent defected in the previous round to maximize potential payoff.
   - End of Game Strategy (if the game ends before reaching r rounds): Analyze the history of opponents' actions and cooperate if the majority were cooperative, otherwise defect.

3. Being Collective:
   - The strategy prioritizes long-term cooperation and punishes defection while being open to forgiveness. This aligns with a collective mindset as it encourages players to work together towards mutual benefits.

Pseudocode for the Adaptive Tit-for-Tat (ATFT) strategy:
```python
def ATFT(opponent_history, m, k, r):
  own_strategy = ['C'] * r  # Initialize our strategy as cooperation for all rounds
  last_cooperation = False   # Variable to track the most recent cooperative move by opponent

  for round in range(1, r+1):
    if round == 1:  # Cooperate in the first round
      own_strategy[round-1] = 'C'
      continue

    opponent_action = opponent_history[round-1]  # Get opponent's action from previous round

    if opponent_action == 'C':  # If opponent cooperated, reciprocate cooperation
      last_cooperation = True
      own_strategy[round-1] = 'C'
    elif opponent_action == 'D' and last_cooperation:  # If opponent defected after recent cooperation, punish but remain open for future cooperation
      last_cooperation = False
      own_strategy[round-1] = 'D'
    else:                     # Otherwise, if opponent did not cooperate recently, still cooperate to foster long-term cooperation
      own_strategy[round-1] = 'C'

  payoff = calculate_payoffs(own_strategy, opponent_history, m, k)
  return payoff
```
'''

description_COLLECTIVE_194 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Decision Rules:
   - Initially Cooperate (C) in the first round to show goodwill and promote cooperation. After that, behavior is adaptive based on opponents' actions.
   - If an opponent cooperates, reciprocate with a cooperative action (C).
   - If an opponent defects, also defect in the next round as a punishment. After punishment, resume cooperating if the opponent cooperates in the subsequent round.

2. Edge Cases:
   - In the first round, cooperate to initiate cooperation.
   - In the last round, cooperate if more than (m-1) opponents have cooperated so far, and defect otherwise as there are no further rounds for retaliation or reciprocation.

3. Collective Mindset:
   - The strategy seeks a balance between individual gain and collective benefit by fostering mutual cooperation while punishing defection. This encourages the development of trust within the group over time.

Pseudocode:

```python
def TfTA(n, m, k, r):
    players_history = [(i, ['C' for _ in range(r)]) for i in range(1, n+1)]  # initialize history for all players
    my_cooperation_count = 0

    for round in range(r):
        cooperation_threshold = m if round > 0 else (m-1)  # adjust threshold for first round
        num_cooperators = sum([1 for (player, history) in players_history if history[round] == 'C'])

        if num_cooperators >= cooperation_threshold:
            my_action = 'C'  # cooperate to avert risk
        else:
            my_action = players_history[(my_index)][round]  # defect to punish previous defection

        players_history[(my_index)][round] = my_action  # update history for current player

        if my_action == 'C':
            my_cooperation_count += 1
        else:
            my_cooperation_count = 0

        if round < r - 1 and my_cooperation_count > 0 and players_history[(my_index)][round+1] == 'D':
            my_cooperation_count -= 1  # reset cooperation count after punishment

    return total_reward(players_history, k)  # calculate final reward based on payoff matrix and history

def total_reward(history, k):
    total_reward = 0
    for (player, actions) in history:
        player_reward = sum([1 if action == 'D' else (1 + k) for action in actions])
        total_reward += player_reward
    return total_reward
```
'''

description_COLLECTIVE_195 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Decision Rules:
   - Initial Cooperation (round 1): Start by cooperating to encourage others and build trust, c_i(1) = C
   - Reciprocity: In subsequent rounds, if the player cooperated in the previous round, reciprocate with cooperation; otherwise defect. This encourages long-term collaboration while punishing defection. c_i(t) = C if c_(i, t-1) = C, else c_i(t) = D
   - Gradual Trust: If a player has mostly cooperated in the recent past (e.g., last 3 rounds), gradually become more tolerant of occasional defection by not immediately defecting in response. This allows for learning and adaptability to less cooperative opponents.
     Rule: If the number of consecutive cooperations from an opponent is greater than a threshold T, then for the next K rounds (e.g., K=3), the strategy will also cooperate regardless of the opponent's previous action.

2. Handling Edge Cases:
   - First Round: c_i(1) = C to encourage others and build trust
   - Last Round: No adjustments are made as payoff depends on the entire game history
   - Near Game End (t > r-T): If a player has cooperated for a consecutive stretch of T rounds, they will continue cooperating for the remaining games, even if reciprocity dictates defecting. This allows for maximizing potential rewards before the end of the game.

3. Collective Mindset:
   - Collaborative: The strategy seeks to promote cooperation by reciprocating cooperative behavior while being tolerant of occasional defection and gradually trusting more cooperative opponents.
   - Adaptive: The ATFT strategy adapts to different opponent behaviors through its gradual trust mechanism, allowing it to collaborate effectively with a wide range of opponents in the long term.

Pseudocode:
```
def ATFT_strategy(n, r, m, k, T, K):
    state = {"cooperative": True, "consecutiveCooperationCount": 0}
    for round in range(1, r+1):
        if round == 1:
            state["cooperative"] = True
            state["consecutiveCooperationCount"] = 0

        if state["cooperative"]:
            action = "C"
            state["consecutiveCooperationCount"] += 1
            if state["consecutiveCooperationCount"] > T:
                for next_round in range(round, min(round+K, r)):
                    state["cooperative"] = True
        else:
            action = "D"

        # Record payoff and update state based on opponent's action
        ...

        yield action
```
'''

description_COLLECTIVE_196 = '''
 Title: Tit-for-Tat-Adaptive (TfTA) Strategy for Collective Risk Dilemma

1. Decision Rules:
   - Initialize by cooperating in the first round (C_i, 1 = C). This encourages others to cooperate and fosters a sense of trust.
   - In subsequent rounds, if the player has previously cooperated and the number of current cooperators is less than m, defect (D_i). If the player has previously cooperated and m or more players are currently cooperating, continue to cooperate (C_i).
   - If the player has previously defected, cooperate if at least m-1 other players are currently cooperating. Defect otherwise. This allows for potential redemption but also ensures self-interest when necessary.

2. Edge Cases:
   - In the last round, always cooperate (C_i, r) regardless of previous actions or current state, as there is no further interaction.
   - In the first round, always cooperate (C_i, 1 = C).
   - If there is an unknown initial history, cooperate and observe other players' actions before adapting to their behavior.

3. Collective Mindset:
   - By following a simple and consistent rule of reciprocity, TfTA promotes a collective mindset as it reflects a willingness to cooperate when others do so and punish defection when necessary. This encourages other players to adopt similar strategies that foster cooperation over time.

Pseudocode:
```
function TitForTatAdaptive(round, ownHistory, globalHistory) {
  if (round === 1) {
    return 'C'; // Cooperate in the first round
  }

  let previousAction = ownHistory[round - 1];
  let currentCooperatorsCount = countCooperators(globalHistory);

  if (previousAction === 'D' && currentCooperatorsCount >= m - 1) {
    return 'C'; // Cooperate if previously defected and enough others are cooperating
  } else if (previousAction === 'C' && currentCooperatorsCount < m) {
    return 'D'; // Defect if previously cooperated and not enough are cooperating
  } else {
    return previousAction; // Mimic other players' actions in uncertain situations
  }
}

function countCooperators(history) {
  let cooperatorCount = 0;
  for (let action of history) {
    if (action === 'C') cooperatorCount++;
  }
  return cooperatorCount;
}
```
'''

description_COLLECTIVE_197 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-AC starts by cooperating in the first round to show goodwill and encourage cooperation from others. In subsequent rounds, it adopts a Tit-for-Tat strategy: if a player cooperated in the previous round, the AI also cooperates; if the player defected, the AI defects as well.

   To be adaptive and robust to opponent behaviors, TFT-AC includes an additional rule: if more than (m-1) players cooperate in a round, the AI adjusts its future cooperation threshold. It increases its threshold by 1% for each player who cooperated beyond (m-1). This encourages the AI to cooperate more when it observes a high level of collective goodwill and less when the group shows signs of self-interest.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First Round: Cooperate to initiate cooperation and establish trust.
   - Last Round (or any round near the end): If the total number of players cooperating is significantly less than m for several consecutive rounds, the AI starts defecting to maximize its payoff before the game ends. However, if there are signs of a sudden increase in cooperation, the AI maintains its current threshold for a few more rounds to see if this shift persists.
   - Odd and Even Rounds: No special treatment is given to odd or even rounds since TFT-AC focuses on player actions rather than round numbers.

3. Be collective - Clearly align with the collective mindset
   To encourage cooperation among players, TFT-AC starts by cooperating in the first round. By adopting a Tit-for-Tat strategy, it responds to the actions of other players while fostering long-term mutual trust and cooperation. The adaptive cooperation mechanism further helps maintain collective goodwill by adjusting the AI's cooperation threshold based on the group's behavior.

Pseudocode:

```python
def TFT_AC(round, history, m, k, n):
    # Initialize adaptation factor and cooperation threshold
    adaptation = 0.01
    cooperation_threshold = m - 1

    # Decide on action for current round
    if round == 1:
        return "C"  # Cooperate in the first round to establish trust

    players_cooperated = count_cooperators(history)

    if players_cooperated <= cooperation_threshold:
        # Adopt Tit-for-Tat strategy
        if history[round - 1] == "C":
            return "C"
        else:
            return "D"

    else:
        # Adjust cooperation threshold based on the number of cooperators beyond m-1
        excess_cooperators = players_cooperated - cooperation_threshold
        new_adaptation = min(0.9, adaptation + (excess_cooperators * adaptation))
        cooperation_threshold += new_adaptation
        return "C" if history[round - 1] == "C" else "D"
```
'''

description_COLLECTIVE_198 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Decision Rules:
   - In the initial round (t=1), cooperate (C). This gesture is intended to foster a cooperative environment and build trust among players.
   - From the second round onwards (t>1), analyze the actions of opponents in the previous round (t-1) and respond accordingly:
     - If m or more players cooperated in the previous round, cooperate (C). This reinforces cooperative behavior and rewards those who also chose to cooperate.
     - If fewer than m players cooperated in the previous round, defect (D). This punishes opponents who did not cooperate and protects the player's own interests while encouraging future cooperation from them.

2. Handling Edge Cases:
   - Last Round (t=r): Cooperate if the threshold for cooperation (m) was met in the previous round, otherwise defect to avoid being exploited by free-riders.
   - First Round (t=1): Cooperate as a goodwill gesture and an effort to initiate cooperation among players.
   - Subsequent Rounds (t>1 and t<r): Follow the main decision rule (ATFT) described above.

3. Collective Mindset:
   - The ATFT strategy attempts to balance cooperation and defection based on observed behaviors in the community. By cooperating when others do, it aligns with a collective mindset and encourages mutual benefits when possible. At the same time, it punishes those who do not cooperate in order to discourage free-riding and preserve individual interests.

Pseudocode:
```
function ATFT(t, m, k, history) {
  if (t == 1) {
    return "C"
  }

  previousRound = history[t - 1]
  numCooperators = countCooperators(previousRound)

  if (numCooperators >= m) {
    return "C"
  } else {
    return "D"
  }
}

function countCooperators(round) {
  cooperatorsCount = 0
  for i in round {
    if (round[i] == "C") {
      cooperatorsCount++
    }
  }
  return cooperatorsCount
}
```
'''

description_COLLECTIVE_199 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?

The ATFT strategy starts by cooperating in the first round to demonstrate goodwill. In subsequent rounds, it adopts a "tit-for-tat" approach, mirroring the actions of other players from the previous round. If another player cooperates, the ATFT also cooperates; if not, it defects.

Pseudocode:
```
def atft(round, history):
  if round == 1:
    action = Cooperate
  else:
    last_opponent_action = history[round-1][my_index] # my_index refers to the index of the current player in the history list
    action = Cooperate if last_opponent_action == Cooperate else Defect
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

To be more robust and adaptive, we add some modifications to handle edge cases:
- In the first round, cooperate as mentioned above.
- In the last round, cooperate regardless of opponents' previous actions since the game ends after this round.
- If a player encounters a streak of defection from opponents, it may start to defect itself to punish opponents and encourage cooperation in the future (Forgiveness condition).
- If a player encounters a streak of cooperation from opponents, it may also start to cooperate more frequently to reward them and foster long-term cooperation (Grace period condition).

Pseudocode:
```
def atft(round, history):
  if round == 1 or round == r:
    action = Cooperate
  else:
    last_opponent_streak = calculate_streak(history, my_index) # calculates streak of cooperation/defection for the current player

    if last_opponent_streak <= forgiveness_threshold:
      action = Cooperate
    elif last_opponent_streak >= grace_period_threshold:
      action = Defect
    else:
      action = mirror_last_opponent_action(history, my_index) # continues using the original tit-for-tat approach for normal cases
```

3. Be collective - Clearly align with the collective mindset

The ATFT strategy emphasizes cooperation and encourages other players to follow suit by reciprocating their actions. It also includes forgiveness and grace period conditions that help nurture long-term cooperation, promoting a more collectively-focused approach in the game.

In the case of repeated interaction, the ATFT strategy fosters mutual understanding, trust, and cooperation among players as they learn each other's strategies over time. This makes it an adaptive and robust strategy for the Collective Risk Dilemma game.
'''

description_COLLECTIVE_200 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-ACT starts by cooperating in the first round, mirroring the cooperative approach of its opponents. In subsequent rounds, it will cooperate if a majority (>m/2) of players cooperated in the previous round, and defect otherwise. To adapt to opponent behaviors, TFT-ACT introduces an adjustable cooperative threshold (c_thresh) that gradually decreases or increases based on the success of cooperation:
   - If the total payoff from cooperation is greater than the total payoff from defection in a round, then c_thresh is increased slightly.
   - Conversely, if the total payoff from cooperation is less than the total payoff from defection in a round, then c_thresh is decreased slightly.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   TFT-ACT cooperates in the first round to signal willingness to cooperate and promote mutual trust among opponents. In the last round (or any round approaching the end of the game), TFT-ACT will consider the current total payoff from cooperation and defection, and choose the action that maximizes its total payoff over the entire game.

3. Be collective - Clearly align with the collective mindset
   TFT-ACT promotes collective success by relying on a majority of players to cooperate. By adjusting its cooperative threshold in response to opponent behaviors, it maintains a balance between cooperation and defection while fostering long-term relationships based on reciprocity. This strategy encourages collaborative play and rewards consistent cooperation among opponents.

Pseudocode for TFT-ACT:

```python
def TFT_ACT(n, m, k, r, c_thresh=m/2):
    cooperate = True  # Start by cooperating
    total_coop_reward = 0
    total_defect_reward = 0

    for round in range(1, r+1):
        if round == 1:  # Cooperate in the first round
            cooperate = True

        if cooperate:  # Calculate rewards and update c_thresh
            total_coop_reward += k * (m-len(players_who_cooperated)) + len(players_who_didnt_cooperate)
            if total_coop_reward > total_defect_reward:
                c_thresh += 0.01
        else:
            total_defect_reward += len(players_who_cooperated) + k * (m-len(players_who_cooperated))
            if total_defect_reward > total_coop_reward:
                c_thresh -= 0.01

        cooperate = len(players_who_cooperated) > c_thresh  # Decide whether to cooperate or defect based on the majority of players

    if round != r:  # In the last round, choose the action that maximizes total payoff
        if total_coop_reward + k * (m-len(players_who_cooperated)) > total_defect_reward + len(players_who_didnt_cooperate):
            cooperate = True
```
'''

description_COLLECTIVE_201 = '''
 Strategy Name: Adaptive Tit-for-Tat with Risk Aversion (ATfT-RA)

1. Decision Rules:
   - In each round i, cooperate if at least m players cooperated in the previous round. This encourages cooperation when others are cooperative and punishes defection.
   - If fewer than m players cooperated in the previous round, calculate a risk score based on the proportion of cooperators from the previous r-1 rounds (historical cooperation). Cooperate if the risk score is above a threshold, otherwise defect. This balances short-term cooperation with long-term gains by taking calculated risks.

Pseudocode for decision rule:
```python
def ATfT_RA(current_round, past_cooperators):
    if current_round == 1:
        return 'C' # Cooperate in the first round as a goodwill gesture
    historical_cooperation = sum(past_cooperators) / (current_round - 1)
    risk_threshold = m * (k - 1) / k
    if past_cooperators[current_round - 1] >= m:
        return 'C' # Cooperate when majority cooperated in the previous round
    elif historical_cooperation > risk_threshold:
        return 'C' # Take a calculated risk and cooperate
    else:
        return 'D' # Defect to punish previous defection or take no risk
```

2. Handle edge cases:
   - In the last round, there is no need for punishment since the game ends, so defect (D).
   - In the first round, cooperate (C) as a goodwill gesture.

3. Be collective:
   - ATfT-RA encourages cooperation when it is beneficial for the group, while still taking calculated risks to balance short-term and long-term payoffs. This aligns with the collective mindset by promoting mutual cooperation but also ensuring that individual players do not always defect at the expense of others.
'''

description_COLLECTIVE_202 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Decision Rules:
   - Initiate cooperation: Start by cooperating in the first round (C). This sets a positive tone and encourages others to cooperate.
   - Respond to cooperation: If an opponent cooperates, continue cooperating (C). This reciprocity promotes sustained cooperation.
   - Punish defection: If an opponent defects, defect for one round, then re-evaluate the cooperation threshold based on the frequency of defections.
     If the opponent continues to defect, gradually lower the tolerance for defection by increasing the number of consecutive defeats required before resuming cooperation (punishment phase). Once a cooperative act is observed, begin re-building the cooperation threshold (forgiveness phase).
   - Cooperate when threshold reached: Resume cooperation once the frequency of defections falls below the current cooperation threshold. The cooperation threshold decays over time to allow for potential changes in opponent behavior.

2. Handle Edge Cases:
   - First Round: Cooperation (C) as a goodwill gesture and to encourage others to cooperate.
   - Last Round: Cooperate if the overall payoff from cooperation outweighs the total payoff from defection over the game's history. This helps maximize long-term returns even in the last round.
   - Intermediate Rounds: Evaluate the frequency of defections and adjust the cooperation threshold accordingly.

3. Be Collective:
   - The strategy prioritizes collective interests by fostering an environment where cooperation is encouraged and sustained. It responds to opponents' actions with reciprocity, punishing defection when necessary but also offering forgiveness when cooperation resumes.

Pseudocode for TFT-ACT Strategy:

```python
def tft_act(n, m, k, r, history):
    cooperation_threshold = 0.5 * n - (m - 1)  # Initial cooperation threshold based on minimum cooperators needed
    current_round = 1
    payoff = [0] * r  # Initialize payoffs for all rounds

    def play(opponent_action):
        if current_round == 1:
            return 'C'  # Cooperate in the first round
        if opponent_action == 'C':
            return 'C'  # Reciprocate cooperation with cooperation
        elif opponent_action == 'D' and current_round <= cooperation_threshold:
            return 'D'  # Punish defection with a single counter-defection
        else:
            cooperation_threshold += 1  # Increase cooperation threshold if too many consecutive defections
            return 'D'  # Continue defecting

    while current_round <= r:
        opponent_action = history[current_round - 1]
        player_action = play(opponent_action)
        payoff[current_round - 1] = (1 - int(player_action == 'D')) + k * int(m <= sum([1 for action in history[:current_round] if action == 'C']))
        current_round += 1

    total_payoff = sum(payoff)

    return total_payoff, cooperation_threshold
```
'''

description_COLLECTIVE_203 = '''
 Strategy Name: Adaptive Tit-for-Tat with Risk Aversion (ATfTA-RA)

1. Decision Rules:
   - In each round, evaluate the number of cooperators from the previous round (n_c). If n_c < m, defect (D), else cooperate (C).
   - If n_c >= m and k > 2, consider the potential reward of risk aversion. With probability p, cooperate; with probability 1-p, defect. The value of p is calculated as follows:
      `p = min(1, max(0, (m-n_c)/(n-m)))`
   - This adjustable parameter p encourages cooperation when the number of cooperators is below the threshold and defecting when it's above. It also accounts for a margin of error and allows for a more adaptive strategy in response to changing opponent behaviors.

2. Handling Edge Cases:
   - First round (n_c = 0): Start with cooperation (C) as there is no history, aiming to set a cooperative norm.
   - Last round: Use the same decision rule as for other rounds, but consider the total game payoff instead of just the previous round's payoff if applicable.

3. Collective Mindset:
   - ATfTA-RA is designed with a collective mindset in that it prioritizes cooperation when the majority of players have also chosen to cooperate. The strategy encourages the formation and maintenance of collaborative relationships, as well as punishes defection when cooperation has been consistently shown by others.
   - The risk aversion aspect allows for flexibility in response to various opponent behaviors, fostering an environment that promotes long-term cooperation while still being robust against cheaters or unpredictable players.
'''

description_COLLECTIVE_204 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially cooperate (C) in the first round to show good faith and promote cooperation.
   - In subsequent rounds, observe the total number of cooperators in the previous round (m_prev). If m_prev >= m, continue cooperating (C). If m_prev < m, defect (D). This tit-for-tat behavior aims to punish non-cooperative players and reward cooperative ones.
   - To minimize risk, a small probability (ε) is added for defection in each round when m_prev < m. This encourages the strategy to occasionally deviate from strict punishment to reduce vulnerability to exploitation by overly aggressive opponents.

2. Handle edge cases:
   - First round: Cooperate (C) as a goodwill gesture.
   - Last round: Analyze the total number of cooperators in previous rounds (m_total). If m_total >= m, defect (D) to avoid unnecessary contribution when the game is ending. Otherwise, continue cooperating (C).

3. Be collective - Align with the collective mindset by promoting cooperation and punishing defection, while remaining adaptive to various opponent behaviors and minimizing vulnerability to exploitation through the addition of a small probability for defection in non-cooperative situations.

Pseudocode:
```
function ATFT(n, r, m, k, ε):
    round = 1
    m_total = 0
    cooperate = True

    while round <= r:
        if round == 1:
            cooperate = True
        else:
            m_prev = countCooperators(previous_round)
            if m_prev >= m:
                cooperate = True
            elif m_total < (m * (1 - ε)):
                cooperate = False

        if cooperate:
            action = 'C'
        else:
            action = 'D'

        payoff = calculatePayoff(action, round)
        m_total += countCooperators(round)

        round += 1

    return totalPayoff(payoff)
```
'''

description_COLLECTIVE_205 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, the ATFT strategy decides to cooperate or defect based on its history of interactions with other players. The strategy starts by cooperating in the first round (C0) and then responds to the opponent's action in the previous round (A_t-1). If the opponent cooperated (A_t-1 = C), the ATFT strategy will also cooperate (Ct = A_t-1); if the opponent defected (A_t-1 = D), the ATFT strategy will defect (Ct = !A_t-1).

Pseudocode:
```
function ATFT(history):
  if history.length == 0 or t == 1:
    return 'C'
  else:
    previousAction = history[len(history) - 1]
    return 'C' if previousAction == 'C' else 'D'
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

The ATFT strategy treats the first round as a fresh start, assuming that the other players are cooperative and will reciprocate. In the last round, the ATFT strategy considers the total payoff over all previous rounds and takes into account any potential long-term benefits of cooperation. If the total payoff has been positive up to that point, the ATFT strategy will still cooperate in the last round; otherwise, it will defect.

3. Be collective - Clearly align with the collective mindset

The ATFT strategy is designed to promote cooperation and long-term mutual benefits among players by adopting a reciprocal approach. It assumes that other players are rational and will respond similarly, fostering a collective mindset where cooperative behavior is rewarded and defective behavior is punished over time. This encourages players to develop trust and work together towards the common goal of achieving the minimum cooperation threshold (m).

To summarize, the Adaptive Tit-for-Tat strategy for the Collective Risk Dilemma can be described as follows:

- Decision rules: Cooperate in the first round and respond to the opponent's previous action in subsequent rounds.
- Edge cases: Treat the first round as a fresh start, and consider long-term benefits in the last round based on total payoff.
- Collective mindset: Promote cooperation by adopting a reciprocal approach that rewards cooperative behavior and punishes defective behavior over time.
'''

description_COLLECTIVE_206 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Decision Rules:
   - In the initial round, cooperate (C). This is a peace offering to potential collaborators and sets a positive tone for subsequent rounds.
   - For all subsequent rounds (t > 1), observe the number of cooperators (m_t) in the previous round. If m_t >= m, cooperate in the current round as well (C). If m_t < m, defect (D) to punish non-cooperative behavior and encourage future cooperation.
   - Maintain a forgiving nature by reverting to cooperative behavior if, in any round t, m_t ≥ m after a series of previous defections (D). This allows for potential rebuilding of trust.

2. Handling Edge Cases:
   - In the last round, as the game ends regardless of strategy choices, there's no need to adapt further. Cooperate if m_t >= m; otherwise defect.
   - In the first round, cooperate unilaterally with no prior information about other players' strategies.
   - If a player continuously defeats (D) you in all rounds, consider the interaction as a one-sided conflict and continue to defect until they start cooperating or the game ends. This responds to non-cooperative opponents while still maintaining a collective mindset.

3. Being Collective:
   - The strategy is inherently collective as it emphasizes long-term cooperation for mutual benefit. By responding positively to cooperation and punishing defection, the strategy encourages others to work together.
   - When players cooperate together (m_t >= m), each player receives a payoff of 1 + k, reinforcing the idea that collective success benefits all involved parties.

Pseudocode:
```
function ATFT(n, r, m, k):
    if t = 1:
        action_i = C
    else:
        if m_t >= m:
            action_i = C
        else:
            action_i = D

    if t = r or (t > 1 and previous_actions[i] == D and m_t >= m):
        action_i = C

    return action_i
```
'''

description_COLLECTIVE_207 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Decision Rules:
   - Initially cooperate (C) in the first round to demonstrate goodwill.
   - In subsequent rounds, follow the actions of the majority of players from the previous round. If more than m players cooperated, also cooperate (C). If fewer than m players cooperated, defect (D).
   - To be adaptive, each player will have a learning parameter 'l' that adjusts their cooperation threshold over time. The higher the number of consecutive rounds with less-than-m cooperation, the more the player lowers their threshold for cooperation. Conversely, if there are more rounds with m or more players cooperating, the player raises their cooperation threshold.
   - The learning parameter l determines how quickly a player adjusts its cooperation threshold in response to changes in other players' behavior. A smaller value means slower adaptation, while a larger value means faster adaptation.

Pseudocode:
```
def TFT_ACT(l, m, n):
  cooperation_threshold = m
  rounds_consecutive_less_than_m = 0

  function get_majority(actions):
    return len([action for action in actions if action == 'C']) >= (n / 2) + 1

  function update_cooperation_threshold(threshold, l, rounds_consecutive_less_than_m, m):
    threshold += l * (rounds_consecutive_less_than_m - (r - rounds_consecutive_less_than_m))
    if threshold < m:
      threshold = m
    if threshold > n - m + 1:
      threshold = n - m + 1
    return threshold

  for each round r in {1, ..., r}:
    observe actions of other players in the previous round
    if get_majority(other_players_actions):
      cooperate = True
      rounds_consecutive_less_than_m = 0
    else:
      rounds_consecutive_less_than_m += 1
      cooperation_threshold = update_cooperation_threshold(cooperation_threshold, l, rounds_consecutive_less_than_m, m)
      cooperate = cooperation_threshold >= m

    if round == 1:
      cooperate = True

    return cooperate
```

2. Handle Edge Cases:
   - In the first round, cooperate (C) regardless of the number of other players who cooperate or defect.
   - In the last round, consider the majority behavior from the previous round to decide on the action.

3. Be Collective:
   - By following the actions of the majority in each round, TFT-ACT aligns with a collective mindset while still being adaptive and robust to various opponent behaviors.
   - The learning parameter 'l' allows for adjustments based on the game's dynamics, fostering cooperation when it is beneficial and defecting when necessary. This strategy encourages players to punish non-cooperative behavior but also incentivizes others to cooperate in the future by reciprocating their cooperation.
'''

description_COLLECTIVE_208 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate to demonstrate goodwill and encourage cooperation from others.
   - For subsequent rounds, base the action on the collective behavior of the other players in the previous round:
     - If a majority (>=(m-1)) of players cooperated in the previous round, cooperate. This rewards past cooperation and encourages future cooperation.
     - If fewer than (m-1) players cooperated or equal to m but not more than (m+1) players cooperated in the previous round, defect. This punishes non-cooperation and discourages further defections.
     - If an exact majority (m) of players cooperated in the previous round, the strategy considers both outcomes:
       - Cooperate if the individual player's cooperation would lead to m+1 or more players cooperating this round. This encourages cooperation and reinforces a trend towards the threshold (m).
       - Defect if the individual player's defection would lead to m-1 or fewer players cooperating this round, as it punishes non-cooperation and discourages further defections.
     - If there is no clear majority among players, use randomization to make a decision, favoring cooperation slightly over defection. This helps to reduce the impact of small deviations from the threshold (m).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as mentioned above.
   - In the last round, consider the majority cooperation in the previous round to decide the action for this round. This encourages players to reciprocate cooperation from earlier rounds and maintains a positive ending to the game.

3. Be collective - Clearly align with the collective mindset
   - The strategy prioritizes cooperative behavior whenever possible, as it promotes collective success and fosters long-term stability.
   - The strategy is also adaptive, punishing defectors when necessary to encourage cooperation but avoiding excessive punishment or escalation of conflict that could harm the group as a whole.

Pseudocode:

```python
def TFT_AC(m, players, round):
  if round == 1:
    return 'C'  # Cooperate in the first round

  majority = int((len(players) + 1) * m / 2)  # Calculate the majority

  if len({player_action for player_action in players[-1]} ) >= majority:  # Check the majority cooperation in the previous round
    if player_endowment > len(players) - majority:   # Player's action would result in m+1 or more cooperators this round
      return 'C'
    else:   # Player's action would result in m-1 or fewer cooperators this round
      return 'D'
  else:   # No clear majority, use randomization to make a decision
    if randint(0,1) == 1:   # Favor cooperation slightly over defection
      return 'C'
    else:
      return 'D'
```
'''

description_COLLECTIVE_209 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially cooperate in the first round (c_i = 1, t=1). This is a goodwill gesture and sets the initial cooperation level high, promoting trust among players.
   - For subsequent rounds (t > 1), observe the number of cooperators (m') in the previous round. If m' >= m, reciprocate by cooperating again (c_i = 1). If m' < m, defect (c_i = 0) as a punishment for the lack of collective action.
   - In repeated interactions, ATfT maintains cooperation when others do so, but retaliates with defection if others deviate from cooperative behavior in the previous round.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - The strategy begins by cooperating in the first round (t=1).
   - In the last round (t=r), there is no need to retaliate since future rounds are not available for punishment or reward. Thus, cooperate if m' >= m and defect otherwise (c_i = 1 if m' >= m; c_i = 0 if m' < m).
   - In the case of an empty history (t=2), the strategy follows the general rule by initially cooperating (c_i = 1, t=2) and observing others' behavior for future decisions.

3. Be collective - Clearly align with the collective mindset
   - The ATfT strategy seeks to promote cooperation among players while also penalizing defection in a fair and reciprocal manner. By doing so, it encourages long-term collective success by fostering trust, communication, and mutual understanding in repeated interactions.
   - Players following ATfT are expected to cooperate when others do so, encouraging the development of group norms and collective decision-making over time.

Pseudocode for the Adaptive Tit-for-Tat strategy:

```
Function ATfT(t, m, n, r, c_i_prev, k)
  If t = 1 Then // First round
    Return c_i = 1
  End If

  If t >= r Then // Last round
    Return (c_i_prev >= m) ? 1 : 0
  End If

  If c_i_prev >= m Then // Previous round cooperators >= minimum threshold
    Return 1
  Else
    Return 0
  End If
End Function
```

In this pseudocode, `c_i_prev` represents the action (cooperation or defection) taken by player i in the previous round. The function outputs the action to be taken in the current round (t).
'''

description_COLLECTIVE_210 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Decision Rules:
   - Initially Cooperate (C) in the first round to show goodwill and encourage cooperation.
   - In subsequent rounds, cooperate if at least m players cooperated in the previous round. If fewer than m players cooperated, defect (D). This rule encourages reciprocity and aligns with the collective mindset.
   - If all players cooperated in the last round, cooperate again to reinforce trust and encourage long-term cooperation.

2. Handling Edge Cases:
   - In the first round, play C to initiate cooperation.
   - In the last round, play as if it were not the last round according to the decision rules mentioned above. However, in case of a tie where m players cooperated and the remaining n-m defected, the strategy will side with the majority (defect if m < n, cooperate otherwise).
   - If the game is repeated indefinitely, use a threshold (T) to periodically reassess cooperation. If the average number of cooperators over T rounds falls below m, switch to defecting until the average rises above m again. This provides adaptability and robustness against opponents deviating from cooperative strategies.

Pseudocode for ATFT strategy:

```python
def adaptive_tit_for_tat(n, m, k, T):
    round = 0
    average_cooperators = m
    while True:
        if round == 0:
            action = 'C'  # Cooperate in the first round
        else:
            num_cooperators_prev_round = count_cooperators(n, previous_round)
            if num_cooperators_prev_round >= m:
                action = 'C'
            elif num_cooperators_prev_round < m and average_cooperators < m:
                action = 'D'
            else:
                action = 'C'  # Cooperate to initiate or rebuild cooperation

        if round == len(previous_rounds) - 1 or (round + 1) % T == 0:
            update_average_cooperators(num_cooperators_prev_round, average_cooperators)

        previous_rounds.append([action for _ in range(n)])
        round += 1

def count_cooperators(n, previous_round):
    cooperators = 0
    for player_action in previous_round:
        if player_action == 'C':
            cooperators += 1
    return cooperators

def update_average_cooperators(num_cooperators, average_cooperators):
    new_average = (average_cooperators * (len(previous_rounds) - 1) + num_cooperators) / len(previous_rounds)
    average_cooperators = new_average
```
'''

description_COLLECTIVE_211 = '''
 Strategy Name: Tit-for-Tat Adaptive (TfTA) for Collective Risk Dilemma

1. Decision Rules:
   - In the first round, cooperate (C). This demonstrates good faith and allows for potential partnerships in future rounds.
   - For subsequent rounds t > 1, if a player i co-operated in the previous round (t-1), and m or more players cooperated during that round, then also cooperate (C). If not, defect (D). This rule encourages reciprocity and punishes defection.
   - If a player i has ever defected and m or more players are currently defecting, the strategy will also defect to match the opponents' actions.

2. Edge Cases:
   - Last round: Cooperate if cooperating in the last round would result in a higher payoff compared to defecting (based on the current round's outcome and k factor). This encourages long-term benefits even when approaching the end of the game.
   - First round: As mentioned above, cooperate as a show of good faith.
   - Inconsistent opponent behavior or emergent coordination patterns: Continue with TfTA strategy, but adjust thresholds for cooperation (m) and punishment (number of consecutive defections required to respond with defection). If too many opponents are defecting, lower the m threshold, and if too many opponents are cooperating, raise it.

3. Collective mindset:
   - The TfTA strategy fosters a collective mindset by promoting reciprocal cooperation, which encourages long-term partnerships and mutual benefits. The strategy is adaptable to various opponent behaviors and incentivizes a shared understanding of cooperation as the most beneficial course of action when m or more players cooperate.

Pseudocode:
```python
def TitForTatAdaptive(n, r, m, k):
    players = [0 for _ in range(n)] # initialize array of player actions (0=D, 1=C)
    rounds = [0 for _ in range(r+1)] # initialize array to track round history

    def get_payoff(player_index):
        if sum(players[player_index]) == 1: # If player cooperated
            if m <= sum([players[i] for i in players if i != player_index]): # and enough others cooperated
                payoff = 1 + k
            else:
                payoff = 1
        else:
            payoff = 0
        return payoff

    def is_cooperating(player_index):
        return players[player_index] == 1 # Check if player cooperated (C=1, D=0)

    def adjust_threshold(player_index, round_num):
        # Adjust cooperation threshold based on round history and opponent behavior
        ...

    for round in range(r):
        for i in range(n):
            if round == 0: # First round, cooperate
                players[i] = 1
            else:
                if is_cooperating(i) and sum([players[j] for j in players if j != i]) >= m:
                    # Cooperation continues when enough others are also cooperating
                    pass
                elif not is_cooperating(i):
                    # If player defected, adjust threshold and check conditions
                    adjust_threshold(i, round)
                    if sum([players[j] for j in players if j != i]) < m or len([j for j in players if not is_cooperating(j)]) >= some_threshold:
                        # Defect if enough others are currently defecting
                        players[i] = 0
                    else:
                        # Cooperate to encourage reciprocity
                        players[i] = 1

        # Evaluate payoff and update total payoff for each player
        payoffs = [get_payoff(i) for i in range(n)]
        for p, payoff in enumerate(payoffs):
            total_payoffs[p] += payoff
```
'''

description_COLLECTIVE_212 = '''
 Strategy Name: Tit-for-Tat (with adaptations for Collective Risk Dilemma)

1. Specify decision rules:
   - Initialize cooperation on the first round (c_i = C). This is to foster a cooperative environment and give other players a chance to reciprocate.
   - In subsequent rounds, mimic the most recent collective action of the majority of players in the previous round (c_i = mode(c_j, j∈{1,2,...,n}) from the last round). This encourages cooperation when others cooperate and retaliates defection with defection.
   - If the number of cooperators is less than m (minimum required for reward), defect in the current round (c_i = D). This is to prevent continuous losses due to a lack of collective effort.

2. Handle edge cases:
   - In the last round, cooperate regardless of past actions as there are no future rounds (c_i = C)
   - In the first round, cooperate to initiate cooperation (c_i = C)

3. Be collective:
   - The strategy emphasizes collective action by following the majority and punishing defection with defection. This encourages cooperation as long as a minimum threshold is met.
   - If a majority of players defects, the strategy adapts to the current situation and cooperates less frequently in an attempt to encourage others to cooperate again.
'''

description_COLLECTIVE_213 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Decision Rules:
   - In the first round, cooperate to show good faith and encourage others to do the same. This is represented by a function `firstRoundCooperate()` which returns True.
   - After the first round, analyze past actions and adapt the cooperation threshold (m) based on the number of cooperators in previous rounds. If more than half of the players have cooperated in the recent past, increase m to encourage continued cooperation; if less than half, decrease m to punish defection. This is represented by a function `adaptCooperationThreshold(history)`.
   - In each round, based on the current cooperation threshold m, cooperate if the number of cooperators in the previous round (excluding the first) was greater than or equal to m; otherwise defect. This is represented by a function `cooperate()`.

2. Handle Edge Cases:
   - In the last round, there's no need for adaptation since the game ends soon. Use the current cooperation threshold to decide whether to cooperate or not (`cooperate(adaptCooperationThreshold(history))`).
   - In the case of an empty history (first few rounds), always cooperate as a default good-faith strategy (`firstRoundCooperate()`).

3. Be Collective:
   - The strategy aims to promote cooperation by rewarding those who cooperate and punishing those who do not. By adapting the cooperation threshold based on collective behavior, it encourages players to work together while still being robust against various opponent strategies.

Pseudocode:

```python
def firstRoundCooperate():
    return True

def adaptCooperationThreshold(history):
    # Analyze history and calculate a cooperation threshold (m) for the current round
    ...
    return m

def cooperate(cooperation_threshold):
    if len(history) > RoundsPerAnalysis:  # Adapt after some rounds
        if numCooperatorsInHistory(history, len(history)-RoundsPerAnalysis) >= cooperation_threshold:
            return True
    return False

def numCooperatorsInHistory(history, start):
    count = 0
    for action in history[start:]:
        if action == 'C':
            count += 1
    return count

def decideAction(round, history):
    if round == 1:
        cooperation_decision = firstRoundCooperate()
    else:
        cooperation_threshold = adaptCooperationThreshold(history)
        cooperation_decision = cooperate(cooperation_threshold)
    return cooperation_decision
```
'''

description_COLLECTIVE_214 = '''
 Title: Tit-for-Tat with Gradual Cooperation (TFTGC) Strategy for Collective Risk Dilemma

1. Specify decision rules:
   - In each round, evaluate the number of cooperators from previous rounds (historical cooperation). If it's less than m, defect to encourage a shift towards cooperation. Otherwise, cooperate to demonstrate trust and support.
   - Adaptive behavior: Introduce gradual cooperation to accommodate different opponent behaviors. Start with a low probability of cooperation in the first few rounds, increasing this probability over time if opponents reciprocate cooperation.

Pseudocode for decision rule:
```
function TFTGC(round, historicalCooperation, m, k, r):
  if round < (0.2 * r):
    probability_cooperate = 0.1
  elif round <= r and round - 1 in historicalCooperation >= m:
    probability_cooperate = 0.5
  else:
    probability_cooperate = 1 if historicalCooperation[-1] >= m else 0
  return int(roundMod2) == 1 ? 1 : (random() < probability_cooperate ? 1 : 0)
```

2. Handle edge cases:
   - In the first round, use a very low probability of cooperation to start gradually building up trust with opponents.
   - In the last round, cooperate if at least m players have cooperated in the previous rounds, as the game is repeated and cooperation may lead to better outcomes in future games.

3. Be collective:
   - The TFTGC strategy prioritizes the collective mindset by encouraging cooperation when it becomes a dominant behavior within the group (i.e., when at least m players cooperate).
   - By introducing gradual cooperation, the strategy demonstrates a willingness to engage in collective action while still maintaining some individual self-interest early in the game. This helps prevent being exploited by other strategies that may take advantage of unconditional cooperation.
'''

description_COLLECTIVE_215 = '''
 Strategy Name: Tit-for-Tat Cooperation (TFTC) Adaptive Algorithm for Collective Risk Dilemma

1. Decision Rules:
   - Initially cooperate (C) in the first round to signal goodwill and encourage potential collaborators.
   - For subsequent rounds, mimic the behavior of the majority of players from the previous round. If more than half of the players cooperated, continue cooperation (C). If less than half defected, also defect (D). If the number of cooperators and defectors is equal or nearly so (within a tolerance of 10%), adopt the action of the previous round.
   - Break even if the number of defections exceeds m-1 in any given round, as failure to meet the minimum cooperation requirement would result in a lower payoff regardless of one's own actions.

2. Handle edge cases:
   - In the last round, cooperate (C) since there are no further rounds to retaliate against defectors.
   - In the first round, cooperate (C) as stated above.
   - If the number of players is odd and one player deviates from TFTC strategy, it will be treated as a majority and the TFTC player will follow their lead for that round to maintain adaptability.

3. Be collective:
   - Prioritize collective success by mimicking the behavior of the majority, which encourages cooperation when possible and retaliation against repeated defections.
   - By following this strategy, TFTC seeks to establish a stable pattern of cooperation while also being robust to a wide range of opponent behaviors.

Pseudocode:
```python
def TFTC_strategy(n, m, k, r):
    players = set()  # initialize an empty set of players
    history = []     # initialize an empty list to store round outcomes
    for round in range(r):
        if round == 0:
            action = 'C'  # cooperate initially
        else:
            cooperators = len([player for player in players if player.last_action == 'C'])
            defector_threshold = m - 1
            if cooperators > (n - defector_threshold) / 2:
                action = 'C'  # continue cooperation
            elif cooperators < (n + defector_threshold) / 2:
                action = 'D'  # defect
            else:
                action = history[-1][-1] if abs(cooperators - (n - len(history[-1]) + len([player for player in players if player.last_action == 'C']))) <= int(n/10) else history[-1][-1]
        players.add(action)  # add the current action to the set of players for future reference
        history.append(players)
        players = set()      # reset the set of players at the end of each round
    return players, history   # return the final set of actions and the game's history
```
'''

description_COLLECTIVE_216 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   The ATFT strategy follows a simple and adaptive approach:
   - Initially (first round), cooperate to foster an environment of mutual trust.
   - In subsequent rounds, mimic the action of the opponent from the previous round: if the opponent cooperated, cooperate; if the opponent defected, defect. This encourages cooperation when it is reciprocated and retaliates against defection.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First round: Cooperate to initiate a relationship with a cooperative gesture.
   - Last round (rth round): Since players are unaware of the final round, they should continue following their decision rule based on the previous round's action of their opponent. In this case, they'll mirror their opponent's last action.

3. Be collective - Clearly align with the collective mindset:
   The ATFT strategy emphasizes cooperation but is also prepared to respond to defection in a way that encourages future cooperation while maintaining individual interests. It aims to balance short-term gains (defection) and long-term success (cooperation). The approach allows for adaptability and fosters collective interests by rewarding cooperative behavior and punishing defection in a reciprocal manner.

Pseudocode:
```
function Adaptive_Tit_for_Tat(n, r, m, k):
  initialize history as an empty list (history)
  initialize action for first round as cooperate (action = 'C')

  for round in range(1, r+1):
    observe opponent's action from previous round (previous_action)
    if round == 1:
      action = 'C'
    elif round == r:
      action = previous_action
    else:
      action = previous_action
    history.append(action)

  return history
```
'''

description_COLLECTIVE_217 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for Collective Risk Dilemma

1. Decision Rules:
   - Initiation: Cooperate in the first round (C_i=1). This is a friendly gesture to encourage cooperation from other players.
   - Response: In all subsequent rounds, adopt the behavior of the majority of cooperators in the previous round. If more than m players cooperated in the previous round, continue cooperating (C_i=1). Otherwise, defect (C_i=0). This rule promotes reciprocity and encourages long-term cooperation.

2. Edge Cases:
   - Last Round: No action is required since the total payoff is calculated over r rounds.
   - First Encounter with a Defector: Cooperate in the first encounter, but defect from that point onwards if they continue to defect. This rule balances initial trust with swift retaliation for uncooperative behavior.

3. Collective Mindset:
   - The ATfT strategy aims to foster a collective mindset by demonstrating cooperative behavior when others do so and punishing defection only in response. This encourages players to engage in cooperation as it benefits the group overall. By adapting to the majority behavior, it also promotes group cohesion and alignment.

Pseudocode:

```python
def ATfT(n, r, m, k, previous_round):
  if round == 1:
    action = cooperate # initiate cooperation
  else:
    num_cooperators = count_cooperators(previous_round)
    if num_cooperators >= m:
      action = cooperate # continue cooperation
    else:
      action = defect # respond with defection

  return action
```
'''

description_COLLECTIVE_218 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, TFT-ACT starts by cooperating (C), mimicking the first-mover advantage. Then, it adapts its cooperation based on the collective behaviour of other players in previous rounds. If a majority (more than (n-1)/2) of players have consistently cooperated in the recent past (e.g., last m rounds), TFT-ACT continues to cooperate. Otherwise, if a majority has defected, TFT-ACT also defects. If the behaviour is mixed or unclear, TFT-ACT follows its current action from the previous round.

   Pseudocode:
   ```
   function TFT_ACT(round, history) {
       if (round == 1) {
           return 'C'
       }
       pastCooperation = countCooperatorsInHistory(history, m)
       if (pastCooperation > (n-1)/2) {
           return 'C'
       } else {
           return history[round-1]
       }
   }
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   TFT-ACT assumes that the game starts with an initial endowment (e.g., 1) for each player. It cooperates in the first round and maintains its adaptive cooperation strategy throughout the game. There are no special rules for the last round since TFT-ACT does not have foreknowledge of the ending.

3. Be collective - Clearly align with the collective mindset
   TFT-ACT promotes cooperation when the majority of players have cooperated in the recent past, and it punishes defection by reciprocating with defection when a majority has defected. This strategy encourages collaboration among players while also being robust to various opponent behaviours. It is less susceptible to exploitation compared to simple tit-for-tat strategies since TFT-ACT considers a wider window of past behaviour and adapts its cooperation threshold based on the game parameters (m, k) and number of players (n).
'''

description_COLLECTIVE_219 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, our ATFT strategy will initially cooperate (C), signifying trust towards other players. However, if another player defects (D) in a given round, the ATFT strategy will defect in the subsequent round as retaliation. If the opponent cooperates again after the initial defect, the ATFT strategy will return to cooperating.

Pseudocode:
```
def ATFT(round, opponent_action):
  if round == 1:
    action = 'C' (Cooperate)
  elif previous_opponent_action == 'C':
    action = 'C'
  else:
    action = 'D'
  return action
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, our ATFT strategy cooperates as a goodwill gesture towards other players, setting a tone of cooperation. In the last round, the strategy considers the total payoff over the entire game rather than just the last round.

3. Be collective - Clearly align with the collective mindset

Our Adaptive Tit-for-Tat strategy emphasizes maintaining trust and reciprocity while encouraging others to cooperate. By starting off with cooperation, the ATFT strategy encourages other players to follow suit, contributing to a more collaborative outcome over the game's duration. If another player defects, the ATFT strategy retaliates briefly but returns to cooperation if the opponent resumes cooperating. This strategy aligns with the collective mindset by promoting sustained cooperation through adaptive reciprocity.

Pseudocode (for a slightly modified version that considers the total payoff):
```
def ATFT(round, opponent_action, total_payoff):
  if round == 1:
    action = 'C' (Cooperate)
    total_payoff += (1 - c_i)  # Initial endowment payoff
  elif previous_opponent_action == 'C':
    action = 'C'
    total_payoff += ((1 - c_i) + k) if m or more players cooperated else (1 - c_i)
  else:
    action = 'D'
    total_payoff += (1 - c_i)  # Defect payoff
    if previous_opponent_action == 'C':
      total_payoff -= ((1 - c_i) + k)  # Deduct the missed reward for cooperation
  return action, total_payoff
```
'''

description_COLLECTIVE_220 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - In the first round, cooperate (C). This is a peaceful opening gesture, setting a cooperative tone for future interactions.
   - In subsequent rounds, cooperate if at least m players cooperated in the previous round and defect otherwise. This rule encourages cooperation when it has been reciprocated, but also retaliates against defection to discourage repeated acts of self-interest.

2. Handling Edge Cases:
   - In the last round, always cooperate (C), as there will be no further interactions and any reward from cooperation is better than none.
   - In the initial stages, if less than m players are cooperating, gradually increase the frequency of cooperation to encourage more players to join in. Start by cooperating with a probability p_init, then adjust this probability based on the number of cooperators in previous rounds as follows:
     ```
     if (round < m) {
        p_coop = round / m; // Linear increase in cooperation probability up to m players
     } else {
        p_coop = floor((n - (m - round)) / (n - m + 1)) / n; // Proportional increase in cooperation probability beyond m players
     }
     ```

3. Being Collective:
   - The TFT-AC strategy prioritizes the collective interest by promoting cooperation when it benefits the group as a whole and discouraging defection to maintain a positive atmosphere for collaboration. This encourages players to work together towards mutual success.
'''

description_COLLECTIVE_221 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Decision Rules:
   - Initiation: Start by cooperating in the first round to signal trust and cooperation. This encourages others to reciprocate. (c_i = 1, t=1)
   - Response: In subsequent rounds, mimic the previous actions of players. If a player cooperated last round, cooperate back; otherwise defect. This rewards cooperation and punishes defection while maintaining flexibility. (for t > 1, c_i = !c_(i-1), t-1)
   - Termination: In the last round, since there are no further rounds to consider, simply reciprocate the most recent action from each player. (for t=r, c_i = !c_(i-1), r-1)

2. Handle Edge Cases:
   - In case of an empty history (no previous interactions), initiate with cooperation as mentioned above.
   - If there's a tie in the most recent action among players, cooperate to foster unity and potential reciprocation.

3. Collective Mindset:
   - The ATFT strategy promotes a collective mindset by encouraging cooperation but also taking into account the actions of other players. This adaptability allows for efficient collaboration while avoiding being exploited in the long run.
   - By reciprocating others' actions, the strategy demonstrates a commitment to mutual benefits and shared success, fostering an environment that encourages collective decision-making and cooperation.
'''

description_COLLECTIVE_222 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - In the initial round, cooperate to foster a cooperative environment.
   - For subsequent rounds, adopt the Tit-for-Tat strategy: cooperate if the opponent cooperated in the previous round; otherwise, defect. This encourages reciprocity and builds trust.
   - Introduce an adaptability factor to react to opponents that may use mixed strategies or display unpredictable behavior. If more than a certain percentage (p) of opponents did not cooperate in the last round, increase the likelihood of defection slightly (ε) for the next round. Conversely, if more than p percentage of opponents cooperated in the last round, increase the likelihood of cooperation slightly (ε).

Pseudocode:
```
function TFT_AC(opponent_history, n, m, k, r, p, e)
  if round = 1 then
    cooperate = True
  else
    opponent_cooperated_last_round = opponent_history[round - 1] == 'C'
    adaptability_factor = e * (number of opponents who cooperated last round - p * n) / n
    if opponent_cooperated_last_round then
      cooperate = True + adaptability_factor
    else
      cooperate = False + adaptability_factor
    end if
  end if
end function
```

2. Handle Edge Cases:
   - In the last round, consider the total payoff over all rounds instead of only the current round to make informed decisions that prioritize long-term rewards.
   - In case the minimum number of cooperators (m) cannot be met in the first round due to insufficient cooperation from other players, defect to ensure a minimal loss and encourage cooperation in future rounds by showing that defection is not unilaterally beneficial.

3. Be Collective:
   - The strategy's collective mindset lies in fostering cooperation through reciprocity and adaptability. By cooperating when others do so as well, the strategy promotes a collective interest in achieving the minimum cooperators needed (m) to maximize rewards.
   - The adaptivity factor encourages players who have previously defected to change their behavior if they observe cooperation from other opponents, thereby contributing to collective success.
'''

description_COLLECTIVE_223 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
In each round, ATfT starts by cooperating (C). If a majority of players (m or more) also cooperated in the previous round, then continue cooperating. Otherwise, if less than m players cooperated in the previous round, defect (D) in this round. This rule encourages cooperation when others are cooperative and retaliates with defection when others do not cooperate.

Pseudocode:
```python
def ATfT(round, history):
  if round == 1 or len(history) < round - 1:
    return 'C' # Cooperate in the first round and when history is not available

  cooperation_count = sum(history[-round+1:-1])

  if cooperation_count >= m:
    return 'C' # Cooperation if majority cooperated in previous round
  else:
    return 'D' # Defection if less than majority cooperated in previous round
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
ATfT assumes no prior information or knowledge of the game and starts by cooperating in the first round. For the last round, ATfT continues to follow its decision rule as long as there are rounds left to play. Once there are no more rounds, it will cooperate if the majority has cooperated in the previous round, and defect otherwise.

3. Be collective - Clearly align with the collective mindset
ATfT is designed to foster a collective mindset by promoting cooperation when others also cooperate, but retaliating with defection when others do not follow suit. This strategy aims for an equilibrium where players generally cooperate, as long as the majority of players are willing to reciprocate cooperation.
'''

description_COLLECTIVE_224 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Decision Rules:
   - In each round, player i cooperates if m or more players cooperated in the previous round. Otherwise, player i defects. This ensures cooperation when others are cooperating and defection when others are not.
   - If less than m players cooperated in the first round, player i will also cooperate to encourage cooperation among opponents.

2. Edge Cases:
   - First Round: If less than m players have cooperated in any previous round, player i starts by cooperating to foster a cooperative environment. Otherwise, player i plays according to decision rules.
   - Last Round: Player i plays the same strategy as the opponent from the last round to reflect the reciprocal nature of the TfTA strategy.

3. Collective Mindset:
   - The TfTA strategy promotes a cooperative mindset by following a simple and predictable pattern, making it easier for other players to understand and reciprocate cooperation when conditions are right.

Pseudocode for the TfTA strategy:

```python
def TitForTatAdaptive(previous_rounds, m, r):
  n = len(previous_rounds)
  current_round = n + 1

  if current_round == 1 and sum(previous_rounds) < m:
    # Cooperate in the first round to encourage cooperation among opponents
    return 'C'

  if current_round == r:
    # Play the same strategy as the opponent from the last round to reflect reciprocity
    last_opponent = previous_rounds[-1]
    if last_opponent == 'C':
      return 'C'
    else:
      return 'D'

  # Apply decision rules based on cooperation in previous rounds
  if sum(previous_rounds[current_round - m:]) >= m:
    return 'C'
  else:
    return 'D'
```
'''

description_COLLECTIVE_225 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - Initial round (t=1): Cooperate (C) to demonstrate goodwill and encourage reciprocity.
   - Subsequent rounds (t>1): If the opponent cooperated in the previous round, cooperate (C). Otherwise, defect (D). This rule encourages cooperation when it is reciprocated while also punishing defection with a similar response.

2. Edge Cases:
   - Last round (t=r): Cooperate regardless of the opponent's action in the previous round to maximize potential rewards.
   - First round (t=1) as mentioned above.

3. Collective Mindset:
   - The strategy aims for long-term cooperation by showing a willingness to cooperate and punishing defection, fostering a collective mindset of mutual benefit.

Pseudocode:
```
def tft_ac(opponent_history, m, k, r):
    player_action = 'C'  # Cooperate by default
    player_reward = 0
    round_number = 1

    while round_number <= r:
        if round_number == 1:
            # Cooperate in the first round to show goodwill
            pass
        elif round_number < r:
            if opponent_history[-1] == 'C':
                player_action = 'C'  # Cooperate if opponent cooperated last round
            else:
                player_action = 'D'  # Defect if opponent defected last round
        else:
            # Cooperate in the last round to maximize potential rewards
            player_action = 'C'

        if player_action == 'C':
            # Calculate reward when cooperating
            reward = (1 - c_i) + k * (m <= sum(opponent_history[-m:])+1)
        else:
            reward = 1  # Reward for keeping endowment privately

        player_reward += reward  # Update total payoff
        round_number += 1

    return player_reward  # Return total payoff after r rounds
```
'''

description_COLLECTIVE_226 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for Collective Risk Dilemma

1. Decision Rules:
   - Initiate Cooperation (C): Start by cooperating in the first round to signal good intentions and foster trust.
   - Respond Reciprocally (R): If a player cooperates in the previous round, reciprocate with cooperation. If defected, also defect in the current round as punishment.
   - Forgiveness (F): After a defect, return to cooperation in the next round, showing readiness for future cooperation and reducing long-term conflict.

Pseudocode:
```
function AdaptiveTitForTat(history, n, m, k, r) {
  let currentRound = 1
  if (currentRound === 1) {
    return 'C' // Cooperate in the first round
  }

  let opponentActionHistory = history.slice(-2) // Last two actions of the opponent
  let cooperatorsCount = opponentActionHistory.filter(action => action === 'C').length

  if (cooperatorsCount >= m && currentRound < r) {
    return 'C' // Cooperate when the majority cooperated in the previous round
  } else if (cooperatorsCount < m && currentRound < r) {
    return opponentActionHistory[currentRound - 1] // Defect when the majority defected or as punishment for defection
  } else {
    return 'C' // Return to cooperation after a defection or in the last round
  }
}
```

2. Handle Edge Cases:
   - First Round: Cooperate (as mentioned above)
   - Last Round: Since the game is played for multiple rounds, there is no explicit last round in each game instance. However, if a player wants to implement an end condition based on time or payoff, they can modify the pseudocode accordingly.

3. Be Collective: By reciprocating cooperation and punishing defection, ATfT aims to encourage collective behavior by rewarding those who cooperate with similar actions and deterring defectors through punishment. This strategy fosters a long-term relationship that can lead to sustained cooperation over multiple rounds.
'''

description_COLLECTIVE_227 = '''
 Strategy Name: Tit-for-Tat Cooperation (TFTC) with Adaptive Threshold (A-TFTC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially cooperate in the first round (first move advantage) and then follow the collective behavior of other players based on a dynamic threshold (m') defined as follows:
     - If m' < m, collaborate with the number of cooperators in the previous round; otherwise, defect.
     - The threshold (m') is adjusted dynamically after each round according to the following criteria:
       - Increase m' by 1 if cooperation resulted in a higher reward than defection in the current round.
       - Decrease m' by 1 if cooperation resulted in a lower or equal reward compared to defection in the current round.
       - In case of a tie, do not change the threshold.
     - If no other player cooperated in the previous round and m' > 1, defect to avoid losing endowment unnecessarily.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - Begin by cooperating in the first round to signal goodwill and encourage cooperation from others.
   - In the final round or any subsequent rounds where the current payoff is equal to or greater than the best payoff received so far, defect to maximize the total reward over the game.

3. Be collective - Clearly align with the collective mindset
   - Foster a cooperative environment by adapting to other players' strategies and incentivizing reciprocity.
   - The strategy will maintain a balance between self-interest and collective interest, ensuring a more robust performance against various opponent behaviors.
'''

description_COLLECTIVE_228 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially cooperate (C) in the first round to establish trust and encourage reciprocity.
   - In subsequent rounds, repeat the action of the most frequent cooperators from the last r rounds (excluding the current round). If multiple players have the same highest cooperation frequency, choose one at random. If no player has cooperated more than m-1 times in the observed window, defect (D) to avoid excessive altruism and potential exploitation.
   - Adaptively adjust the cooperation threshold based on the overall level of cooperation in the game. As more players tend to cooperate, raise the minimum cooperation frequency needed to be considered a cooperator (increment m). Conversely, as fewer players cooperate, lower the minimum cooperation frequency (decrement m). This adaptive adjustment allows the strategy to respond dynamically to changes in the opponent's behavior.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate (C) as a goodwill gesture and to signal trustworthiness.
   - In the last round, if the strategy is behind on total payoff, defect (D) to maximize potential gains; otherwise, cooperate (C) to encourage reciprocity from opponents who may do the same.

3. Be collective - Clearly align with the collective mindset
   - Prioritize cooperation when it benefits the group as a whole, by following the adaptive cooperation threshold rule.
   - By starting with cooperation and adjusting the cooperation threshold based on observed behavior, the strategy encourages and rewards cooperative behavior while maintaining a level of self-preservation to avoid excessive altruism.
'''

description_COLLECTIVE_229 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Start by cooperating in the first round (C). This is a friendly gesture to encourage cooperation from others.
   - In subsequent rounds, cooperate if at least m players cooperated in the previous round and defect otherwise (D). This encourages reciprocity among cooperators.
   - To adapt to various opponent behaviors, implement an improving cooperation threshold (ct) that gradually increases when a cooperative move yields a higher payoff than the previous one:
       ```
       if previous_payoff > current_payoff and ct < n:
           increment ct by 1
       ```
       This adaptive mechanism helps in building trust and encourages cooperation even with initially non-cooperative opponents.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the initial round (round 1), cooperate regardless of previous rounds' payoffs or thresholds as mentioned above.
   - In the last round, cooperate if at least m players cooperated in the preceding round to maximize rewards.
   - For other edge cases such as rounds near the end of the game, consider using a decay function that gradually lowers the improving cooperation threshold (ct) to promote cooperation even when the game is nearing its conclusion.

3. Be collective - Clearly align with the collective mindset
   - The TFT-ACT strategy emphasizes cooperation by initially cooperating and reciprocating the cooperation of others. It also encourages a collective mindset through the adaptive improving cooperation threshold (ct). As ct increases, the strategy becomes more collectively focused on achieving the minimum cooperator threshold (m) for collective rewards.
   - By maintaining a balance between individual self-interest and group benefits, TFT-ACT aims to establish stable cooperative relationships while being robust against various opponent behaviors.
'''

description_COLLECTIVE_230 = '''
 Strategy Name: Tit-for-Tat Cooperation (TFTC) Adaptive for Collective Risk Dilemma

1. Specify decision rules:
   - In each round, assess the previous rounds' cooperators and defectors count. If the number of cooperators is greater than or equal to 'm', cooperate (play C). Otherwise, defect (play D). This rule encourages cooperation when there is a significant group of cooperating players while ensuring self-defense against excessive defection.
   - To adapt to various opponent behaviors, implement a forgiveness mechanism: if the strategy switched from cooperation to defection in the previous round, then it should cooperate in the current round. This helps rebuild trust and promotes longer-term cooperation.

2. Handle edge cases:
   - First Round: Cooperate as a goodwill gesture, encouraging others to follow suit.
   - Last Round (and other specific rounds): If the number of cooperators is still less than 'm', defect to minimize losses in the final round. However, if the majority of players have already cooperated for most of the game, continue cooperation in the last round to maintain the positive trend.

3. Be collective:
   - The strategy aims to promote cooperation by emulating trustworthy behavior and reacting sensitively to the collective actions of other players. It adapts its decisions based on the current state of cooperation within the group, fostering a collaborative environment.

Pseudocode (Python-like):

```python
def tftc_strategy(round, history):
    cooperators = sum(1 for action in history[-round:] if action == "C")
    if round == 1 or cooperators >= m:
        return "C"  # Cooperate

    if history[-1] != "C" and history[-2] == "C":
        return "C"  # Forgiveness mechanism

    return "D"  # Defect
```
'''

description_COLLECTIVE_231 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Decision Rules:
   - Start by cooperating (C) in the first round to demonstrate good faith and encourage reciprocity.
   - In subsequent rounds, if a player i cooperated in the previous round (c_i-1 = 1), then also cooperate (C). If not (c_i-1 = 0), defect (D). This encourages cooperation and punishes defection.
   - The strategy is adaptive as it responds to the opponents' actions, fostering long-term reciprocal relationships when faced with cooperative opponents.

2. Handle Edge Cases:
   - First round: Cooperate (C) to initiate a positive relationship.
   - Last round: Cooperate if more than m-1 opponents have cooperated in the previous round, as the game is repeated and there might be future interactions. Otherwise, defect to maximize individual payoff for that round.
   - In case of ties (when exactly m players cooperate), adopt a random choice between cooperating or defecting to avoid creating an unfair advantage.

3. Be Collective:
   - The Adaptive Tit-for-Tat strategy aligns with the collective mindset by encouraging cooperation and reciprocity, promoting the success of the community project. It adapts to various opponent behaviors while fostering long-term relationships with cooperative opponents.

Pseudocode:
```python
def ATFT(r, n, m, k):
  # Initialize array of player's decisions (C or D)
  actions = [None]*r

  # First round, always cooperate
  actions[0] = 'C'

  # For each subsequent round
  for i in range(1, r):
    # If the player cooperated last round, then also cooperate this round
    if actions[i-1] == 'C':
      actions[i] = 'C'
    else: # Otherwise defect to punish defection from previous rounds
      actions[i] = 'D'

  # Handle edge cases (last round, ties)
  for i in range(r - 1, -1, -1):
    if i == r - 1 and sum([actions[j]=='C' for j in range(i)]) < m-1:
      actions[i] = 'D'
    elif sum([actions[j]=='C' for j in range(i+1)]) >= m:
      actions[i] = 'C'
    elif sum([actions[j]=='C' for j in range(i+1)]) == m-1:
      # Randomly decide between cooperating or defecting to avoid tiebreakers
      if rand() < 0.5:
        actions[i] = 'C'
      else:
        actions[i] = 'D'

  # Calculate total payoff for each round and overall
  payoffs = [0]*r
  for i in range(r):
    if sum([actions[j]=='C' for j in range(i)]) < m:
      payoffs[i] = 1
    else:
      payoffs[i] = 1 + k
  total_payoff = sum(payoffs)
  return total_payoff
```
'''

description_COLLECTIVE_232 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFT-A) for Collective Risk Dilemma

1. Decision Rules:
   - Initial Cooperation (round 1): Start by cooperating to foster a cooperative environment and encourage others to do the same. This is our first attempt at building trust. If no one else cooperates, we will switch to defecting in the next round as a response.
   ```
   if round == 1:
       action = 'C' (Cooperate)
   ```
   - Standard Cooperation (rounds 2 to r-1): Cooperate if at least m players cooperated in the previous round. Otherwise, defect to penalize those who did not cooperate in the last round and encourage them to do better next time. This approach aims to balance cooperation and punishment.
   ```
   for round in range(2, r):
       if number_of_cooperators in previous round >= m:
           action = 'C' (Cooperate)
       else:
           action = 'D' (Defect)
   ```
   - Last Round (round r): Cooperate to show goodwill and potentially encourage others to do the same. This can help secure a better outcome for the final payoff calculation.
   ```
   if round == r:
       action = 'C' (Cooperate)
   ```

2. Edge Cases:
   - First Encounter of Defectors: If, in the first round when we cooperated, others defected, switch to defection for the next round as a response. This shows that uncooperative behavior will not be tolerated.
   ```
   if number_of_defectors == n-1 and round > 1:
       action = 'D' (Defect)
   ```
   - Last Encounter of Defectors: If, in the penultimate round when we cooperated, others defected, also defect in the final round to ensure a fair retaliation. This approach maintains our strategy's consistency and demonstrates our commitment to cooperation.
   ```
   if number_of_defectors == n-1 and round < r:
       action = 'D' (Defect)
   ```

3. Collective Mindset:
   - Our strategy prioritizes fostering a cooperative environment while being responsive to the actions of others. We aim to encourage cooperation through our initial cooperation, rewarding those who also cooperate, and punishing those who do not. This approach promotes a collective mindset that benefits everyone in the long run if enough players choose cooperation over defection.
'''

description_COLLECTIVE_233 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules:
   - Initially Cooperate (C) in the first round to demonstrate good faith and promote trust.
   - In subsequent rounds, if a player cooperated in the previous round, also cooperate (C). This rewards cooperation and punishes defection.
   - If a player defected in the previous round, defect (D) in the current round as a response to their previous action. This encourages cooperation by showing that the strategy is not easily exploited.
   - Continue this pattern of conditional cooperation throughout the game.

2. Handle edge cases:
   - In the last round, since there are no future rounds for retaliation, the strategy will always cooperate (C), as it has done in previous rounds where it responded to cooperation.
   - In the first round, the strategy initially cooperates (C) to foster goodwill. However, if the opponent defects on the very first move, the strategy will switch to a hard-line approach of defecting for the remainder of the game.

3. Be collective:
   - The ATFT strategy is inherently collective, as it prioritizes cooperation when partners have demonstrated good faith and reciprocates defection with defection, reinforcing the importance of collective action in reaching the minimum cooperators needed threshold. This approach aligns with the collective mindset by promoting mutual cooperation while maintaining a level of self-preservation through retaliation against uncooperative behavior.

Pseudocode:
```
function ATFT(r, n, m, k) {
  let r_round = 0; // Initialize round counter
  let past_action = "C"; // Initialize previous action as cooperation

  while (r_round < r) {
    if (r_round == 0) { // First round
      return "C";
    }

    if (past_action == "C") { // If opponent cooperated in the previous round, reciprocate
      return "C";
    } else { // If opponent defected in the previous round, respond with defection
      return "D";
    }

    // Update past action for next round
    past_action = current_action;
    r_round++;
  }
}
```
'''

description_COLLECTIVE_234 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TFTAT)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, TFTAT starts by cooperating (C). If a majority of players cooperated in the previous round, it continues to cooperate. Otherwise, if less than m players cooperated in the previous round, it defects (D) in the current round. This decision rule encourages cooperation when others are cooperative and punishes defection with defection.

Pseudocode:
```
def TFTAT(round, history):
  if len(history) == 0:
    return 'C' # First round

  if m <= len(cooperators_in_previous_round(history[-1])):
    return 'C' # Cooperate when majority cooperated in the previous round
  else:
    return 'D' # Defect when less than m players cooperated in the previous round
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

TFTAT cooperates in the first round and continues to adapt its behavior based on the number of cooperators in each subsequent round. In the last round, it cooperates if a majority of players have cooperated throughout the game.

Pseudocode:
```
def TFTAT(round, history):
  if round == 1:
    return 'C' # First round

  cooperators_in_game = count_cooperators(history)
  if m <= cooperators_in_game and round != r:
    return 'D' # Defect in the last round if less than m players have cooperated throughout the game
  else:
    return TFTAT(round - 1, history + [TFTAT(round - 1, history)]) # Recursively call TFTAT for the remaining rounds
```

3. Be collective - Clearly align with the collective mindset

By starting with cooperation and responding to the behavior of others, TFTAT fosters a collective mindset that encourages long-term cooperation as long as the majority cooperate. This strategy allows it to adapt its behavior based on the actions of other players while maintaining a focus on collaboration.
'''

description_COLLECTIVE_235 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules:
   - Initial Round (t=1): Cooperate (C), setting a cooperative tone and demonstrating trust.
   - Subsequent Rounds (t>1): If the number of cooperators in the previous round was less than m, defect (D) to protect personal resources. Otherwise, if the number of cooperators was equal to or greater than m, cooperate (C) to contribute to the community project and encourage others to do the same.
   - Last Round (t=r): Cooperate (C), regardless of previous rounds' outcomes, as there are no further payoffs to be earned or lost.

Pseudocode:
```
def ATFT(round, cooperators_last_round, m, n):
  if round == 1:
    action = 'C' # Cooperate in the first round
  elif round < r:
    if cooperators_last_round < m:
      action = 'D' # Defect if fewer than m players cooperated last round
    else:
      action = 'C' # Cooperate if m or more players cooperated last round
  else: # Last round
    action = 'C' # Cooperate in the final round regardless of previous rounds' outcomes
  return action
```

2. Handle edge cases:
   - In the first round, ATFT starts by cooperating to set a positive tone and build trust among players.
   - In the last round, ATFT also cooperates as there are no further payoffs to be earned or lost.

3. Be collective:
   - ATFT aligns with the collective mindset by encouraging cooperation when enough other players have cooperated in the previous round (m or more). This demonstrates a willingness to contribute to the community project and support common goals.
   - By defecting only when necessary (when fewer than m players cooperate), ATFT aims to encourage cooperation as it helps achieve the threshold for collective rewards. At the same time, it protects its own resources when it perceives that others are not committed to cooperating.
'''

description_COLLECTIVE_236 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFTAC starts by cooperating in the first round (C_i = 1), mirroring the actions of other players in subsequent rounds (if opponent cooperates, player cooperates; if opponent defects, player defects). This encourages cooperation and retaliates against defection.

   If a player is observed to have consistently cooperated for a certain number of rounds (let's call it 'trust window'), TFTAC will continue cooperating. However, should the opponent defect during this trust window, TFTAC will respond with a single round of defection to signal dissatisfaction before resuming cooperation.

   If an opponent has consistently defected for more rounds than the trust window, TFTAC will also defect until the opponent demonstrates a change in behavior. The trust window size can be adjusted based on the game parameters and the history of interactions.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round (t=1), TFTAC cooperates (C_i = 1).
   In the last round (t=r), TFTAC behaves as it would during the final rounds of its trust window. If the opponent has demonstrated cooperation within the trust window, TFTAC will cooperate; otherwise, TFTAC will defect.

3. Be collective - Clearly align with the collective mindset
   By mirroring the actions of other players and adapting to their behavior, TFTAC fosters a collective mindset. Cooperation is encouraged when it seems beneficial for all parties involved, and defection occurs as a response to perceived dishonesty or betrayal. However, TFTAC does not rely on shared norms or coordination mechanisms with other players.
'''

description_COLLECTIVE_237 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Decision Rules:
   - Initial Cooperation: Start by cooperating in the first round (c_i = 1). This sets a cooperative tone and gives others an opportunity to reciprocate.
   - Response-Based Cooperation: In subsequent rounds, cooperate if the majority of players cooperated in the previous round (if (m > (n/2)) then c_i = 1 else c_i = 0). This encourages cooperation when it is beneficial for the group while still maintaining self-interest.
   - Tit-for-Tat Punishment: If a player deviates from cooperating when the majority did, punish them by defecting in the next round (if (c_i = 0 and m > (n/2)) then c_i = 0). This discourages defection while still allowing for potential future cooperation.
   - Forgiveness: After a punishment, return to cooperating if the majority cooperates again (if ((c_i = 0) and (m > (n/2))) then c_i = 1 in the next round). This allows for forgiveness and encourages rebuilding trust.

2. Handle Edge Cases:
   - Last Round: In the last round, cooperate regardless of previous actions as payoff is based on a single round outcome (c_i = 1).
   - First Few Rounds: After the initial cooperation in the first round, continue to follow the response-based cooperation rule. However, be more lenient with punishment during the early stages (reduce the number of consecutive defections required for punishment from m > (n/2) to m > (n/3)).

3. Be Collective:
   - Align with the collective mindset by prioritizing group success over individual gains. By cooperating when it is beneficial for the majority, the strategy encourages collaboration and long-term cooperation.
   - Maintain flexibility to adapt to various opponent behaviors while still promoting collective success. The strategy is responsive to changes in the group dynamics and can adjust its behavior accordingly.

Pseudocode:
```python
def atft(i, n, m, k, r, history):
  if round == 1:
    c_i = 1  # Initial cooperation

  else:
    numCooperators = countCooperators(history)
    isMajorityCooperating = (numCooperators > (n * m / 3))

    if i < r - 1 and not isMajorityCooperating:
      c_i = 0  # Punishment
    else:
      c_i = isMajorityCooperating

  return c_i
```
'''

description_COLLECTIVE_238 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfT-A)

1. Specify decision rules:
   - In each round i, cooperate (C) if the majority of players cooperated in the previous round (r-1).
   - If the majority did not cooperate in the previous round (r-1), defect (D) unless the number of cooperators in that round is greater than or equal to m but less than the majority. In this case, cooperate if and only if the number of cooperators has been increasing for at least two consecutive rounds.
   - If it's the first round, cooperate (C).

Pseudocode:
```
function TfT_A(round, previous_cooperators, m, n) {
  if (round == 1) {
    return "C"; // Cooperate in the first round
  }
  if (previous_cooperators >= m && previous_cooperators >= (n - previous_cooperators)) {
    // Majority cooperated, continue cooperating
    return "C";
  } else if (previous_cooperators < m && previous_cooperators < (n - previous_cooperators)) {
    // Majority did not cooperate, defect unless a positive trend has started
    if (round - consecutive_increases < 2) {
      return "D";
    } else {
      return "C";
    }
  } else {
    // The number of cooperators is ambiguous; continue with the current state
    if (consecutive_increases > 0) {
      return "C";
    } else {
      return "D";
    }
  }
}
```

2. Handle edge cases:
   - In the last round, defect (D), as payoffs are not affected by future rounds.
   - If the number of players (n) is odd and m equals to (n+1)/2, switch the "C" and "D" actions in rule 1 above to ensure at least one player always cooperates. This ensures a positive outcome if all other players defect in the last round.

3. Be collective:
   - The strategy aims to encourage cooperation by rewarding it when possible and punishing defection only when necessary. It attempts to mimic the behavior of human societies, where cooperation is encouraged but also has consequences for non-cooperation.
   - By considering the number of cooperators in the previous round (r-1), the strategy shows a willingness to align with the collective mindset by following the majority's actions.
   - The adaptive nature of the strategy allows it to change its behavior based on the other players' actions, fostering a more cooperative environment over time.
'''

description_COLLECTIVE_239 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to demonstrate goodwill and encourage reciprocity.
   - In subsequent rounds, cooperate if the majority of players (m) cooperated in the previous round. Otherwise, defect to show disapproval of defection by a significant number of players.

2. Handle edge cases:
   - If less than m players are present, always cooperate to maintain chances for collaboration and incentivize newcomers.
   - In the last round, cooperate if more than (m-1) players cooperated in the previous round to maximize potential payoff.

3. Be collective:
   - Maintain a collaborative stance by encouraging reciprocity and punishing defection when necessary. The strategy aims to foster an environment where cooperation is beneficial for all parties involved.

Pseudocode:

```python
def TFTAC(n, m, r, k, player_index, game_history):
  if round == 1:
    return 'C'

  num_cooperators = count_cooperators(game_history)
  if num_cooperators >= m and player_index in cooperators_last_round:
    return 'C'
  else:
    return 'D'

def count_cooperators(history):
  total_cooperators = 0
  for round in history:
    if 'C' in round[player_index]:
      total_cooperators += 1
  return total_cooperators
```
'''

description_COLLECTIVE_240 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Decision Rules:
   - In every round, observe the number of cooperators in the previous round (n_c). If n_c >= m, cooperate (play C); otherwise defect (play D). This ensures a collective mindset by following the majority's actions and encourages cooperation when it is beneficial for the group.
   - To adapt to opponent behaviors, implement an individual cooperation threshold (ct), which starts at the minimum cooperators needed (m) and gradually decreases or increases based on past experiences.
     Pseudocode:
     ```
     ct = m
     for each round t do
        observe n_c from previous round (t-1)
        if n_c >= ct then
            cooperate (play C)
            update ct based on history (see edge cases below)
        else
            defect (play D)
     ```

2. Handle Edge Cases:
   - First Round: Start with a high cooperation threshold (ct = n), as it is unclear how others will act initially.
   - Last Round: If the game has reached its maximum number of rounds, cooperate regardless of past experiences to maximize potential rewards in that round.
   - If cooperation leads to positive outcomes (i.e., more than m players cooperate), increment ct by a small value (ct += Δ). This encourages cooperation and builds trust among players.
   - If cooperation results in negative outcomes, decrease ct by a smaller value (ct -= Δ) to protect oneself from repeated defection by others.
   - If there's no clear pattern of success or failure, maintain the current ct without adjustment.

3. Be Collective:
   - By following the majority's actions, TFT-ACT strategy fosters a collective mindset and promotes cooperation in the group.
   - The gradual adaptation of the cooperation threshold ensures that the strategy remains responsive to changing opponent behaviors while maintaining a focus on collective interests.
'''

description_COLLECTIVE_241 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFT-A) for Collective Risk Dilemma

1. Decision Rules:
   - Initial Round (t=1): Cooperate (C) to demonstrate goodwill and cooperation intent, while also being cautious of potential free-riders.
   - Subsequent Rounds (2 ≤ t ≤ r):
     a) If the number of cooperators in the previous round is greater than or equal to m (TFT-A_cooperate), cooperate.
     b) If the number of cooperators in the previous round is less than m and the opponent cooperated in the current round (TFT-A_titfor Tat), copy the opponent's action from the previous round.
     c) If the number of cooperators in the previous round is less than m and the opponent did not cooperate in the current round (TFT-A_punish), defect to enforce cooperation norms and discourage defection.

2. Handle Edge Cases:
   - Last Round (t=r): Cooperate as a final attempt to encourage cooperation among opponents, but also consider the overall game performance at that point.
   - First Round (t=1) was already addressed in Decision Rules.

3. Collective Mindset:
   - The strategy emphasizes long-term reciprocity and maintains an initial cooperative stance to encourage a mutual understanding of cooperation norms. However, it also retaliates against free-riders and adapts to the opponents' strategies to maintain a balance between cooperation and defection.

Pseudocode:
```python
def TFT_A(r, m, history, k):
  coop_counter = 0
  opponent_action_history = []

  for t in range(1, r+1):
    if t == 1:
      action = 'C'  # Cooperate in the first round
    else:
      cooperators_last_round = countCooperators(history[-t + 1])
      if coop_counter >= m and cooperators_last_round >= m:
        action = 'C'  # Cooperate when both thresholds are met
      elif coop_counter < m and opponent_action_history[-t] == 'C':
        action = opponent_action_history[-t]  # Copy opponent's action from the previous round
      elif coop_counter < m and opponent_action_history[-t] == 'D':
        action = 'D'  # Punish opponent for not cooperating
      coop_counter += (1 if action == 'C' else 0)
      opponent_action_history.append(action)
    payoff = calculatePayoff(action, t, k)
    updateGameState(t, action, payoff)
    return totalPayoff
```
'''

description_COLLECTIVE_242 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFT-A) for Collective Risk Dilemma

1. Decision Rules:
   - In each round, observe the number of cooperators from the previous round (historical cooperation, HC). If HC is less than m, defect (D); otherwise, cooperate (C). This rule ensures robustness to a wide range of opponent behaviors and encourages cooperation when it's beneficial.
   - To foster collective mindset, players should start by cooperating in the first round.
   - In the last round, if HC is sufficient for collective success, cooperate; otherwise, defect. This rule helps maximize total payoffs over the game.

2. Edge Cases:
   - First Round (t=1): Cooperate (C) to signal good intentions and promote cooperation in subsequent rounds.
   - Last Round (t=r): If HC >= m, cooperate; otherwise, defect to minimize losses.

3. Collective Alignment:
   - The TFT-A strategy emphasizes long-term reciprocity and cooperation, fostering a collective mindset by following the historical behavior of other players.
   - Players are incentivized to cooperate when others do so, as it can lead to higher payoffs in later rounds due to the reward factor (k).
   - By starting with cooperation, TFT-A encourages trust and mutual understanding among players.

Pseudocode:
```
function TFT-A(r, n, m, k) {
  // Initialize history of cooperators
  HC = [0 for i in range(n)]

  // Iterate through rounds
  for t in range(1, r+1) {
    // Check if first round
    if t == 1:
      // Cooperate to start the game
      action = C
    else:
      // Calculate number of cooperators in previous round
      HC_prev = sum(HC)

      // If less than m players cooperated, defect
      if HC_prev < m:
        action = D
      else:
        // Cooperate due to historical cooperation
        action = C

    // Record current round's cooperation in history
    HC[i] += (1 - action[i]) for i in range(n)
  }
}
```
'''

description_COLLECTIVE_243 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initial Round: Cooperate (C) to show goodwill and encourage others to cooperate.
   - Subsequent Rounds: If the number of cooperators in the previous round is greater than or equal to the minimum cooperation threshold (m), then cooperate; otherwise, defect.
   - Adaptive Cooperation Threshold: The cooperation threshold increases by a small step when an individual deviates from cooperating and decreases if they revert to cooperating in the following rounds. This encourages stability while allowing for forgiveness.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First Round: Cooperate as described above.
   - Last Round: Act based on the adaptation of the cooperation threshold and the number of cooperators from the previous round.
   - Intermediate Rounds: If a player has not yet reached their maximum or minimum cooperation thresholds, continue adapting the threshold as described in decision rules.

3. Be collective - Clearly align with the collective mindset
   - Cooperative Intent: Emphasize cooperation by following the Tit-for-Tat strategy, encouraging others to do the same. The adaptive cooperation threshold allows for forgiveness and fosters long-term collaboration.
   - Collective Memory: Maintain a memory of previous cooperation levels to determine current actions and adjust the cooperation threshold accordingly.

Pseudocode:

```python
class TFTAT():
    def __init__(self, n, m, k):
        self.n = n  # number of players
        self.m = m  # minimum cooperators needed
        self.k = k  # reward factor if threshold met
        self.threshold = m  # starting cooperation threshold
        self.history = []  # stores previous cooperation levels

    def play_game(self, cooperation_levels):
        self.history += [cooperation_levels[-1]]  # update game history

        if len(self.history) == 1:  # first round
            return Cooperate()

        cooperation_threshold = self.threshold
        current_round = len(self.history) - 1

        if current_round >= len(self.history) - 2:  # near the end of the game
            cooperation_level = self.history[-current_round-1]
        else:
            cooperation_level = self.history[-current_round]

        if cooperation_level >= cooperation_threshold:
            return Cooperate()
        else:
            return Defect()

    def update_cooperation_threshold(self):
        cooperation_level = self.history[-1]
        threshold_change = 1 if cooperation_level < self.threshold else -1
        self.threshold += threshold_change
        self.threshold = max(self.threshold, self.m)
```

The TFTAT strategy aims to balance cooperation and forgiveness while encouraging long-term collaboration. It maintains a collective memory of previous cooperation levels to adapt the cooperation threshold accordingly and responds to opponent behaviors in a robust manner.
'''

description_COLLECTIVE_244 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Decision Rules:
   - In every round t, cooperate if a majority (> m/2) of players cooperated in the previous round t-1. This encourages cooperation when it is beneficial to the group and retaliates against defection by punishing with individual loss.
   - If the first round or when no history exists, cooperate as an initial gesture.
   - When the game ends (last round), cooperate regardless of previous actions, as there will be no future interaction.

Pseudocode:

```python
def ATFT(history, m, n):
    if len(history) == 0 or t == r: # First round or last round, always cooperate
        return 'C'

    majority = int((len(history) - m + 1) * (m/2))
    previous_round = history[-1]

    if sum(previous_round) >= majority: # More than majority cooperated in the last round, so cooperate now
        return 'C'
    else: # Less than majority cooperated, so defect
        return 'D'
```

2. Handle Edge Cases:
   - The strategy handles edge cases naturally due to its simplicity and adaptability based on previous actions in the game history.

3. Be Collective:
   - ATFT is inherently collective as it encourages cooperation when a majority of players are cooperative, thereby promoting collective success and shared rewards. It also punishes defection by not cooperating, which can discourage free-riding behaviors.
   - However, since there's no communication or coordination between players, ATFT cannot enforce strict norms or coordinate behavior like other strategies might do in a more complex setting with additional features such as signaling or reputation mechanisms.
'''

description_COLLECTIVE_245 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate to demonstrate good faith and encourage cooperation from others. If no one cooperates, switch to defection in the next round.
   - In subsequent rounds, cooperate if the majority of players in the previous round also cooperated. Otherwise, defect.
   - If a player switches from cooperation to defection (defection after cooperation), wait for t_w repetitions without cooperation before returning to cooperation, where t_w is a predefined window size that adapts based on the game's parameters:
     - If n ≥ 10 and k > 2.5, set t_w = n/4 (or round down if fractional)
     - Otherwise, set t_w = m/2 (or round down if fractional)

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as mentioned above
   - In the last round, if the majority of players have cooperated throughout the game, cooperate. Otherwise, defect to maximize personal payoff (since there are no further rounds)

3. Be collective - Clearly align with the collective mindset
   - TFT-AC encourages cooperation by mimicking other players' actions and fostering a reciprocal relationship. This approach promotes stability and collective success when a majority of players follow similar strategies.
   - The strategy adjusts its cooperative behavior based on the game parameters, making it robust to various opponent behaviors and effective in a wide range of situations.

Pseudocode:

```python
def TFT_AC(n, m, k, r, history):
    players = set(range(1, n + 1))
    current_round = 1
    cooperation_count = 0
    t_w = adaptive_window(n, m, k)
    strategy = {'C': cooperate, 'D': defect}

    def cooperate():
        nonlocal cooperation_count
        cooperation_count += 1
        return True

    def defect():
        nonlocal cooperation_count
        if cooperation_count > m - 1:
            cooperation_count -= 1
        return False

    while current_round <= r:
        if current_round == 1:
            action = cooperate()
        else:
            players_cooperated = len(players) - sum([1 for player in history[-current_round] if strategy[player][-1] == 'D'])
            action = cooperate() if players_cooperated >= m else defect()

        strategy[current_round][0].action, strategy[current_round][0].payoff = action, payoff(strategy, current_round)
        players.remove(current_round) if action == defect() else cooperation_count += 1
        current_round += 1

    return sum([strategy[round][0].payoff for round in strategy])

def adaptive_window(n, m, k):
    return int((m / 2) if (n < 10 or k <= 2.5) else n // 4)
```
'''

description_COLLECTIVE_246 = '''
 Strategy Name: Tit-for-Tat with Adaptive Threshold (TFT-AT)

1. Decision Rules:
   - Initially cooperate (C) in the first round to foster cooperation and goodwill. Subsequently, for each round t, observe the percentage of players (p_t) who cooperated in the previous round t-1.
   - If p_t ≥ m/(n-1), cooperate (C). This means that if a majority of players cooperated in the last round, cooperate in this round as well.
   - If p_t < m/(n-1) and p_t-1 ≥ m/(n-1), defect (D). This rule ensures that if cooperation dropped below the required threshold but was high in the previous round, you will also defect to punish those who stopped cooperating.
   - If p_t < m/(n-1) and p_t-1 < m/(n-1), adopt an adaptive approach:
      - If you cooperated (C) in the last round and less than m players cooperated, decrease your cooperation probability for this round by a small factor.
      - If you defected (D) in the last round and less than m players cooperated, increase your cooperation probability for this round by a small factor. This adaptive approach helps to encourage cooperation when it is needed while also being responsive to defection.

2. Handle Edge Cases:
   - In the first round, cooperate (C).
   - In the last round, cooperate (C) if the total number of cooperators throughout the game meets or exceeds m times. Otherwise, defect (D). This rule encourages cooperation in the final rounds when it is still possible to reach the required threshold.

3. Be Collective:
   - The TFT-AT strategy aligns with a collective mindset by promoting cooperation and punishment of defection. However, it also prioritizes adaptability, ensuring that the strategy can respond effectively to various opponent behaviors.

Pseudocode:
```python
def TFT_AT(n, m, k, r):
    cooperators = 0  # initialize total cooperators
    p_t = 1.0  # initial cooperation probability for each round is 1
    payoff = 0  # initialize total payoff for each player

    for t in range(1, r+1):  # iterate over rounds
        if t == 1:  # first round, always cooperate
            action = 'C'
            p_t-1 = 0  # no previous round to consider
        else:
            cooperation_count = sum([1 for a in actions if a == 'C'])
            p_t-1 = cooperation_count / n  # calculate cooperation percentage
            if cooperation_count < m:  # adaptive approach
                if action == 'C':
                    p_t -= 0.05  # decrease cooperation probability
                else:
                    p_t += 0.05  # increase cooperation probability

        if p_t >= m / (n - 1):  # cooperate
            action = 'C'
        elif p_t < m / (n - 1) and p_t-1 >= m / (n - 1):  # defect
            action = 'D'
        else:  # adaptive approach
            if action == 'C':
                if cooperation_count < m:
                    p_t -= 0.05
            else:
                if cooperation_count >= m:
                    p_t += 0.05

        if action == 'C':  # cooperate and contribute to the community project
            payoff += (1 - c_i) + k * ((m / n) ** t)  # calculate payoff for current round with threshold-based reward
            cooperators += 1

    return payoff, cooperators
```
'''

description_COLLECTIVE_247 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Decision Rules:
   - Initially Cooperate (C) in the first round to show goodwill and promote cooperation. If a majority of players cooperate, maintain this behavior. If not, defect (D).
   - In subsequent rounds, mimic the actions of other players from the previous round. If a player cooperated and the majority cooperated, also cooperate. If a player defected and the majority defected, also defect. If a player switched their action from the previous round, follow suit by cooperating if they defected and defecting if they cooperated.
   - When facing an opponent who consistently cooperates, continue to cooperate. If an opponent consistently defects, switch to defect as well.

2. Handle Edge Cases:
   - In the last round, always cooperate as this could help meet the minimum cooperators needed for a maximum reward.
   - In the first round, initially cooperate regardless of the number of players. This encourages others to follow suit and promotes cooperation.

3. Be Collective:
   - The ATFT strategy is designed to encourage cooperation by following a reciprocal approach that rewards cooperation and punishes defection. By mimicking the actions of other players, it fosters an environment where players are more likely to cooperate.

Pseudocode for Adaptive Tit-for-Tat:

```python
def atft(player_index, opponents_actions, round_number, m, k):
    if round_number == 1:
        action = 'C'  # Cooperate in the first round
    else:
        if player_index in cooperators_last_round:  # Cooperate if I cooperated last round and majority cooperated
            action = 'C'
        elif player_index in defectors_last_round and len(defectors_last_round) >= m - 1:  # Defect if I defected last round and majority defected
            action = 'D'
        else:  # Mimic the actions of other players from the previous round
            if player_index in opponents_actions['C']:  # If opponent cooperated last round and majority cooperated, also cooperate this round
                action = 'C'
            elif player_index in opponents_actions['D']:  # If opponent defected last round and majority defected, also defect this round
                action = 'D'
            else:  # If opponent switched their action from the previous round, follow suit by cooperating if they defected and defecting if they cooperated
                if player_index in opponents_actions['C'].difference(cooperators_last_round):
                    action = 'D'
                elif player_index in opponents_actions['D'].difference(defectors_last_round):
                    action = 'C'

    cooperators_last_round.update({player_index: action})  # Update the list of cooperators last round for next round decision
    defectors_last_round.update({player_index: not action})  # Update the list of defectors last round for next round decision

    return action
```
'''

description_COLLECTIVE_248 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for Collective Risk Dilemma

1. Decision Rules:
   - In the initial round (t=1), cooperate (C). This allows potential partners to earn a higher payoff, promoting trust and collaboration.
   - For subsequent rounds (t > 1), observe the actions of other players in the previous round. If m or more players cooperated, also cooperate in the current round. If less than m cooperated, defect (D). This rule is inspired by the Tit-for-Tat strategy from game theory, with an adjustment to account for the minimum cooperation threshold.

2. Handling Edge Cases:
   - First Round (t=1): Cooperate (C) as mentioned above.
   - Last Round (t=r): If the current round is the last round and m or more players cooperated in the previous round, then also cooperate in this final round to maximize the total payoff. Otherwise, defect (D).
   - Intermediate Rounds: Follow the decision rules mentioned above.

3. Aligning with the Collective Mindset:
   - The strategy seeks to balance cooperation and defection based on the actions of other players, encouraging a collective mindset by rewarding those who contribute positively to the group's success while also being prepared to defect when necessary to protect individual interests.

Pseudocode for ATfT in Collective Risk Dilemma:

```
function Adaptive_Tit_for_Tat(n, r, m, k, history) {
  // Initialize variables
  let currentRound = 1;
  let totalPayoff = 0;
  let lastCooperationCount = 0;

  while (currentRound <= r) {
    // Handle first round
    if (currentRound == 1) {
      action = 'C'; // Cooperate
    }

    // Observe the number of cooperators in the previous round
    let cooperationCount = countCooperators(history[currentRound - 1]);

    // Update lastCooperationCount variable
    if (cooperationCount >= m) {
      lastCooperationCount += 1;
    } else {
      lastCooperationCount = max(lastCooperationCount - 1, 0);
    }

    // Make a decision based on the observed cooperation count and last cooperation count
    if (cooperationCount >= m && lastCooperationCount >= m) {
      action = 'C'; // Cooperate
    } else {
      action = 'D'; // Defect
    }

    // Perform action, update payoff, and move to the next round
    let payoff = calculatePayoff(n, m, k, action);
    totalPayoff += payoff;
    currentRound += 1;
  }

  return totalPayoff;
}
```
'''

description_COLLECTIVE_249 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, players initiate cooperation (C). This reflects a willingness to contribute and establish a positive relationship.
   - After the first round, players adopt a tit-for-tat approach: if the opponent cooperated in the previous round, the player also cooperates; otherwise, they defect.
   - To encourage cooperation even when opponents deviate from TfTA, the strategy includes an adaptation mechanism: after a string of defections by the opponent, players gradually increase the number of rounds required for forgiveness before returning to cooperation (increasing "forgiveness window").

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, as mentioned earlier, players cooperate (C).
   - In the last round, since there are no subsequent rounds for retaliation or forgiveness, players follow their current adaptation level. This could either mean cooperating if they have been cooperating with the opponent, or defecting if the opponent has been defecting.
   - If an opponent deviates from TfTA during a game, the player will adopt a "shorter-memory" approach, where the forgiveness window decreases over time to encourage opponents to return to cooperation.

3. Be collective - Clearly align with the collective mindset
   - By initially cooperating, TfTA demonstrates a commitment to the common good and encourages reciprocal cooperation from other players.
   - The adaptation mechanism allows for gradual changes in strategy based on opponents' behavior, fostering an environment where cooperation can flourish if the majority of players adopt similar strategies.

Pseudocode:

```
function TfTA(opponentHistory, r, m, k, n, forgivenessWindow)
  if round == 1:
    action = cooperate()
  else:
    if opponentHistory[round-1] == cooperate():
      action = cooperate()
    else:
      action = defect()
      updateForgivenessWindow(forgivenessWindow)

  if round == r:
    if previousRoundAction == cooperate():
      action = cooperate()
    else:
      action = previousRoundAction

function updateForgivenessWindow(currentForgivenessWindow)
  if length(opponentHistory) > currentForgivenessWindow and opponentHistory[length(opponentHistory)-currentForgivenessWindow-1] == defect():
    currentForgivenessWindow += 1
```

The `updateForgivenessWindow` function adjusts the "forgiveness window" based on the history of the opponent's actions. This helps the strategy to be more forgiving when cooperation is reestablished and less forgiving if defection continues. The initial forgiveness window can be a fixed value or determined based on the game parameters (e.g., n, m, k).
'''

description_COLLECTIVE_250 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - In the first round, cooperate (C) to show goodwill and encourage cooperation from others.
   - For subsequent rounds, repeat the action of the most frequent cooperator(s) from the previous round(s). If there's a tie, cooperate. This mimics the "Tit-for-Tat" strategy, which is both simple and cooperative.
   - To adapt to changing opponent behaviors, keep track of each player's average cooperation rate (average number of cooperative actions divided by total actions).
     - If an opponent's cooperation rate exceeds a certain threshold (e.g., the median cooperation rate among all players), consider them a "cooperator" and follow their lead.
     - If an opponent's cooperation rate drops below a certain threshold (e.g., the average cooperation rate minus one standard deviation), consider them a "defector" and respond accordingly.
     - For opponents whose cooperation rate remains unstable or around the average, continue to cooperate as they may also be using adaptive strategies.

2. Handle Edge Cases:
   - In the last round, prioritize maximizing individual payoff based on the current game state by cooperating if it will lead to a higher reward (according to the current cooperation rates of other players).
   - In the first round, as mentioned before, cooperate to encourage others to do the same. However, if the majority of opponents defect in the first round, switch to defection for subsequent rounds since cooperation seems unproductive in this context.

3. Be Collective:
   - TFT-AC encourages cooperation by mimicking other players' actions, which fosters a collective mindset as it relies on the assumption that others will also cooperate when given the opportunity.
   - By adapting to changing opponent behaviors and prioritizing cooperation when possible, TFT-AC promotes a more collaborative environment within the game.
   - However, the strategy is designed to be robust against various opponent behaviors and doesn't rely on specific coordination mechanisms or shared norms. Instead, it adjusts its behavior based on observed patterns of cooperation and defection among players.
'''

description_COLLECTIVE_251 = '''
 Title: Tit-for-Tat with Adaptive Cooperation (TFTA) Strategy for the Collective Risk Dilemma Game

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, TFTA will initially cooperate in the first round (first-move advantage). After that, it will mimic the actions of the most frequent cooperators from the previous rounds up to a certain threshold (e.g., 3 or 4 rounds depending on the population size). If no clear majority is detected, TFTA defaults to cooperating with a probability based on the average cooperation level from the past few rounds.

```python
def tfta_decision(past_actions, m):
    if round == 1:
        return 'Cooperate'

    frequent_cooperators = find_top_m_cooperators(past_actions)
    cooperation_threshold = min(len(frequent_cooperators), m)

    cooperation_count = sum([action == 'Cooperate' for player in frequent_cooperators[:cooperation_threshold]])
    average_cooperation = cooperation_count / cooperation_threshold

    if cooperation_count >= m:
        return 'Cooperate'
    elif average_cooperation > 0.5:
        return 'Cooperate' if random.random() < average_cooperation else 'Defect'
    else:
        return 'Defect'
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, TFTA cooperates as a goodwill gesture to encourage others to cooperate. In the last round, it copies the most frequent cooperator from the penultimate round or acts based on its average cooperation level if no clear majority exists.

```python
def handle_edge_cases(round, past_actions):
    if round == 1:
        return 'Cooperate'
    elif round == r:
        frequent_cooperators = find_top_m_cooperators(past_actions[-2:])
        cooperation_threshold = min(len(frequent_cooperators), m)

        cooperation_count = sum([action == 'Cooperate' for player in frequent_cooperators[:cooperation_threshold]])
        average_cooperation = cooperation_count / cooperation_threshold

        return 'Cooperate' if cooperation_count >= m else ('Defect' if average_cooperation > 0.5 else random.choice(['Cooperate', 'Defect']))
    else:
        return tfta_decision(past_actions, m)
```

3. Be collective - Clearly align with the collective mindset

TFTA strategy prioritizes cooperation to achieve a high payoff for all players by following the majority's actions and encouraging further cooperation through imitation. In doing so, it promotes a collective mindset while being adaptive and robust against various opponent behaviors.
'''

description_COLLECTIVE_252 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially, cooperate in the first round (C). This sets a cooperative tone and avoids immediate punishment for opponents who might have a hawkish strategy.
   - In subsequent rounds, cooperate if all players cooperated in the previous round (C), otherwise defect (D). This rule encourages reciprocity, making the strategy both cooperative and robust against various opponent strategies.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, as mentioned earlier, cooperate (C).
   - In the last round, if the game's threshold m has been reached (i.e., all opponents have cooperated), continue cooperating to maximize rewards for both this and the total game payoff (Σ(t=1 to r) π_i). If the threshold hasn't been met, defect (D) since it's the final round and any potential reward from future rounds is lost.

3. Be collective - Clearly align with the collective mindset
   - ATFT maintains a collective mindset by encouraging cooperation when it benefits both the individual and the group as a whole. By reciprocating cooperation, ATFT seeks to create a stable, cooperative equilibrium that benefits all players over time.

Pseudocode:
```
function AdaptiveTitForTat(round, opponents_actions[round-1], game_parameters) {
  if round == 1 {
    action = C; // Cooperate in the first round
  } else if all(opponents_actions[round-1]) == C {
    action = C; // Cooperation is reciprocated when everyone cooperated last round
  } else {
    action = D; // Defect when cooperation wasn't reciprocated last round
  }
  return action;
}
```
This strategy is adaptive and robust to a wide range of opponent behaviors. By encouraging cooperation, it aligns with the collective mindset while being flexible enough to adjust based on past experiences with other players in the game.
'''

description_COLLECTIVE_253 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Decision Rules:
   - TfTA starts by cooperating in the first round (C_i, 1 = C). This is a gesture of goodwill and an invitation for others to do the same.
   - In subsequent rounds, if a player i's opponent has cooperated in the previous round (c_{i-1} = C), then the player will also cooperate (C_i = C). If the opponent defected (c_{i-1} = D), the player will defect as well (C_i = D) to retaliate.
   - The TfTA strategy is flexible and forgiving, meaning it will return to cooperation after an act of defection by the opponent (C_i = C). This encourages potential long-term partnerships and avoids unnecessary conflicts.

2. Handling Edge Cases:
   - In the first round, TfTA cooperates as a goodwill gesture (C_1 = C).
   - In the last round or when r reaches its maximum value, TfTA acts based on the history of interactions with its opponent. If the opponent has cooperated in the previous rounds, TfTA will also cooperate (if r < max(r)). If not, TfTA may adopt a punishment strategy to encourage future cooperation.
   - TfTA has no specific actions for tie cases or rounds where an opponent fails to make a move since it assumes that all players will play in each round.

3. Being Collective:
   - TfTA aligns with the collective mindset by promoting cooperation and trust among players. It cooperates initially and responds similarly to its opponents' actions, fostering stable partnerships.
   - By retaliating when necessary but also forgiving previous acts of defection, TfTA encourages cooperation while maintaining a balance between individual and collective interests. This strategy aims to promote mutual benefits in the long run.

Pseudocode:
```
function TfTA(i, t, n, m, k, r, c_history):
  if t == 1:
    return C (Cooperate)

  previousAction = c_history[t-1]

  if previousAction == C:
    return C (Cooperate)
  else:
    return D (Defect)
```
'''

description_COLLECTIVE_254 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TFT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, TFT-A starts by cooperating (C). For subsequent rounds, TFT-A will mimic the opponent's action from the previous round. If the opponent cooperated in the last round, TFT-A will cooperate again; if not, it will defect. This ensures reciprocity and a stable relationship.
   Pseudocode:
   ```
   function TFT_A(opponent_action_history):
       if round = 1:
           return "C"
       else:
           last_round_opponent_action = opponent_action_history[round-1]
           if last_round_opponent_action == "C":
               return "C"
           else:
               return "D"
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   Since the opponent's history is empty in the first round, TFT-A starts by cooperating. In the last round, TFT-A aims to maximize its payoff based on the opponent's actions during the game. If the number of cooperators is less than m for the entire game, it will defect; otherwise, it will mimic the final opponent action from the previous round (to ensure a cooperative ending if possible).
   Pseudocode:
   ```
   function TFT_A(opponent_action_history, game_round):
       if game_round == 1:
           return "C"
       else:
           opponent_cooperator_count = count_cooperators(opponent_action_history)
           if opponent_cooperator_count < m:
               return "D"
           else:
               last_round_opponent_action = opponent_action_history[game_round-1]
               return last_round_opponent_action
   ```

3. Be collective - Clearly align with the collective mindset
   TFT-A is designed to support cooperation when it's beneficial for the majority (m or more players) and maintain a cooperative relationship with partners who reciprocate. However, it will defect if opponents fail to cooperate or when the overall level of cooperation does not meet the necessary threshold (m). This balances individual and collective interests while promoting trust and reciprocity among players.
'''

description_COLLECTIVE_255 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, the ATFT strategy initially cooperates (C), mimicking the cooperative nature of the game. However, it responds to the opponents' actions in a tit-for-tat manner: if an opponent cooperates, the strategy also cooperates; if an opponent defects, the strategy defects in the subsequent round. This encourages cooperation while allowing for retaliation when necessary, promoting adaptability and robustness against various opponent behaviors.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round (t=1), all players cooperate (C) since there is no history to base decisions on.
   - In the last round (t=r), players should consider the potential benefit of maximizing payoff for the remaining rounds, even if it means deviating from the strategy's usual behavior. As a result, ATFT will cooperate if enough players have cooperated in the previous round(s) to ensure meeting the minimum cooperation threshold (m).
   - If an opponent defects near the end of the game but cooperates again in the last round, the strategy should forgive them and cooperate as well since their last-minute change in behavior might be a desperate attempt to meet the cooperation threshold.

3. Be collective - Clearly align with the collective mindset
   The ATFT strategy emphasizes group success over individual gain by promoting cooperation when possible but also punishing defectors who harm the collective interest. This encourages players to develop shared norms and a sense of community, ultimately leading to more effective collaboration in the long run.

Pseudocode:

```python
def Adaptive_Tit_for_Tat(n, m, k, r):
    players = list(range(1, n+1))  # Initialize player indexes
    cooperation_history = [[0] * n for _ in range(r)]  # Track cooperation history
    payoff_history = [[0] * n for _ in range(r)]  # Track individual payoffs

    def get_cooperators_count(round):
        return sum([history[round][i] for i in players])

    def should_cooperate(round):
        if round == 1:
            return True
        elif round == r and get_cooperators_count(round-1) >= m:
            return True
        cooperators = get_cooperators(round-1)
        if cooperators[player] == 1:
            return cooperators[player]
        else:
            return not cooperators[(len(players)-player)]

    for round in range(1, r+1):
        for i in players:
            cooperation_history[round-1][i-1] = 1 if should_cooperate(round) else 0
            payoff = 1 - cooperation_history[round-1][i-1] + k * (get_cooperators_count(round) >= m)
            payoff_history[round-1][i-1] = payoff
    return payoff_history
```

This pseudocode outlines the Adaptive Tit-for-Tat strategy for the Collective Risk Dilemma game. The function takes in the number of players, minimum cooperators needed, reward factor, and number of rounds as input arguments. It initializes a cooperation history and payoff history arrays, which are used to track player cooperation decisions and individual payoffs across rounds. The get_cooperators_count() and should_cooperate() functions help determine the number of players cooperating in each round and whether or not a player should cooperate in a given round based on the strategy rules. Finally, the function calculates and returns individual payoffs for all players after all rounds have been played.
'''

description_COLLECTIVE_256 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFTA)

1. Decision Rules:
   - In the first round, cooperate (C). This sets a positive initial tone and allows for potential cooperation in future rounds.
   - For subsequent rounds, copy the action of the most frequent cooperators from the previous round. If multiple players have the same highest frequency, choose one at random. If no player cooperated in the previous round, defect (D) as a punishment to encourage more cooperation in the future.

2. Handling Edge Cases:
   - In the last round, cooperate (C), even if no one cooperated in the previous round. This could potentially earn extra reward and improve overall payoff.
   - In the initial phase of the game, there might be a period where cooperation is not reciprocated. To avoid falling into a long-term defect cycle, introduce forgiveness: after observing a string of continuous defections, switch to cooperating again as an attempt to reinitiate cooperation. The forgiveness mechanism can be triggered, for example, every n rounds (n being a game parameter).

3. Being Collective:
   - TFTA strategy inherently promotes collective mindset by rewarding reciprocal behavior and punishing defection when cooperation is not reciprocated. By copying the most frequent cooperators, the strategy demonstrates an intent to follow the majority and work towards a common goal of reaching the minimum cooperation threshold.
   - The forgiveness mechanism also encourages the strategy to reconsider its actions if it realizes that it has been overly punitive or misjudged other players' intentions. This helps in maintaining a more positive outlook and fostering continued attempts at cooperation.

Pseudocode:

```python
def tfta(n, r, m, k):
    history = []  # store previous actions of all players
    payoff = 0

    def get_most_frequent_cooperators():
        cooperators = {}
        for player in history:
            if player not in cooperators:
                cooperators[player] = 0
            if player == 'C':
                cooperators[player] += 1
        max_frequency, most_frequent = 0, None
        for player, frequency in cooperators.items():
            if frequency > max_frequency:
                max_frequency = frequency
                most_frequent = player
        return most_frequent

    def forgive():
        forgiveness_counter -= 1
        if forgiveness_counter <= 0:
            forgiveness_counter = n  # reset forgiveness counter after n rounds
            cooperate()

    forgiveness_counter = n

    for round in range(r):
        if round == 0:
            cooperate()  # cooperate in the first round
        else:
            player = get_most_frequent_cooperators()
            if player is None or player != 'C':
                defect()  # defect when no one cooperated last round
            else:
                cooperate()  # copy the action of the most frequent cooperators

        if round == r - 1:
            cooperate()  # cooperate in the last round

        forgiven = False
        payoff += (1 - history[-1]) + (k * (m <= sum(history[-r:])))  # update payoff based on game rules
        if not cooperated_last_round and history.count('C') > history.count('D'):  # check if forgiveness is needed
            forgive()
        history.append(action)  # store current action for next decision

    return payoff
```

This pseudocode outlines the basic structure of the Tit-for-Tat with Adaptive Cooperation (TFTA) strategy. The function takes game parameters as input and returns the total payoff over multiple rounds. The TFTA strategy adapts to opponent behaviors by copying the most frequent cooperators in each round, while also introducing forgiveness to avoid long-term defect cycles.
'''

description_COLLECTIVE_257 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules:
   - Initiation: In the first round, cooperate (C). This is a friendly gesture to establish trust and encourage cooperation in the group.
   - Response: After the first round, observe other players' actions and adopt a Tit-for-Tat strategy where you copy their previous action. If another player cooperates, you also cooperate. If they defect, you defect as well.
   - Forgiveness: In case of a mistake or deviation from cooperation during the game, return to cooperating in the following round (provided that at least m players still cooperated in the previous round). This mechanism promotes forgiveness and encourages future collaboration.

2. Handle edge cases:
   - Last Round: If it's the last round and fewer than m players are cooperating, defect to maximize individual payoff for this specific round. However, if m or more players still cooperate in the final round, continue cooperating as a show of good faith and commitment to the collective goal.
   - First Defection: If another player defects for the first time after your initial cooperation, do not immediately retaliate by defecting. Instead, continue cooperating to maintain trust and encourage cooperation from the defector in future rounds.

3. Be collective:
   - Minimum Cooperators (m) Threshold: Always aim to cooperate with as many players as possible to achieve the minimum cooperators needed for the success of the community project. This encourages a collective mindset and fosters long-term cooperation among players.
   - K-factor Reward (k): Leverage the k-factor reward to reinforce collaboration. When m or more players cooperate, accept the increased payoff as an incentive for further cooperation in future rounds.

Pseudocode:
```python
def ATFT(round, opponents_actions, min_coop, k_factor):
  if round == 1:
    action = 'C'  # Cooperate on the first round
  else:
    if len([i for i in opponents_actions if i == 'C']) < min_coop:
      last_action = 'D'  # If fewer than m players cooperated, defect in this round
    else:
      last_action = opponents_actions[-1]  # Copy the previous action of other players

  return last_action  # Return the chosen action for this round
```
'''

description_COLLECTIVE_258 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Decision Rules:
   - In the initial round (t=1), cooperate (C). This is a friendly opening gesture, signaling a willingness to cooperate and build trust.
   - For subsequent rounds (t>1):
     - If the number of cooperators in the previous round (t-1) was less than m, defect (D). This is a retaliatory response to previous defections.
     - If the number of cooperators in the previous round was equal to or greater than m, cooperate (C). This rewards previous cooperation and maintains trust.

2. Handle Edge Cases:
   - In the last round (t=r), if the number of cooperators in the previous round was less than m, defect (D) as there are no more opportunities for future rewards or punishments. If the number of cooperators was equal to or greater than m, cooperate (C) to maximize potential payoff.
   - In the first round (t=1), since there is no previous round for comparison, cooperate (C).

3. Be Collective:
   - The strategy focuses on long-term cooperation while also ensuring fairness and reciprocity. By responding to the actions of other players in a consistent manner, it fosters collective mindset and encourages others to reciprocate cooperation when possible. This strategy is adaptive, as it adjusts its actions based on the behavior of other players.

Pseudocode for Adaptive Tit-for-Tat (ATFT) strategy:

```python
def ATFT(t, history, m, n, k):
  if t == 1: # First round
    return "C"

  previous_coop = countCooperators(history[-1])
  if previous_coop < m: # Previous round was not cooperative enough
    return "D"
  else: # Previous round was cooperative enough
    return "C"
```

This pseudocode assumes a function `countCooperators(history_round)` which counts the number of cooperators in a given round from history.
'''

description_COLLECTIVE_259 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Decision Rules:
   - Start by cooperating in the first round (C1). This demonstrates a willingness to cooperate and gives others an opportunity to reciprocate.
   - After the first round, players will observe the number of cooperators (m_t) in each round t. If m_t >= m, player i will continue to cooperate (Ct+1 = Ct). This maintains cooperation when it benefits all parties.
   - If m_t < m, player i will defect (Dt+1 = !Ct), mimicking the behavior of others in that round as a form of punishment for non-cooperation. However, player i will reevaluate its cooperation decision based on the adaptive cooperation threshold.
   - The adaptive cooperation threshold (act) is calculated as the average number of cooperators from the last n_history rounds. If act >= m, player i will return to cooperating in the next round (Ct+1 = 1). This allows for the possibility of re-establishing cooperation even after periods of non-cooperation.

2. Edge Cases:
   - In the last round (r), players will follow their decision rule based on m_r, without applying the adaptive cooperation threshold as there are no subsequent rounds.
   - If a round results in less than m cooperators but the adaptive cooperation threshold is already greater than or equal to m, player i will still cooperate in that round (Ct+1 = 1). This allows for the possibility of re-establishing cooperation even when the number of cooperators falls below the threshold in a single round.
   - If a round results in more than or equal to m cooperators but the adaptive cooperation threshold is less than m, player i will still defect in that round (Dt+1 = 0). This ensures that players do not continue cooperating if there are indications that the majority prefers defection.

3. Collective Mindset:
   - TFT-ACT promotes a collective mindset by adapting to and punishing non-cooperative behavior while maintaining an openness for cooperation through the adaptive cooperation threshold. This strategy encourages players to reciprocate cooperative actions and rewards them accordingly. It also allows for forgiveness and rebuilding of trust in situations where cooperation has been lost.

Pseudocode:

```python
def TFT_ACT(m, k, r, n_history=5):
    history = [0] * n_history  # Initialize a history buffer
    act = 0                     # Adaptive cooperation threshold
    i = 1                       # Player index (starts from 1)

    while round <= r:
        if round == 1:
            action[i] = "C"      # Cooperate in the first round
        else:
            m_t = countCooperators()  # Count cooperators in current round
            act = average(history)   # Calculate adaptive cooperation threshold
            if m_t >= m and act >= m: # Cooperate if enough players cooperated and adaptive threshold is met
                action[i] = "C"
            elif m_t < m and act < m: # Defect if not enough players cooperated and adaptive threshold is below the minimum
                action[i] = "D"
            else:                    # Cooperate or defect based on current round's cooperation level
                action[i] = "C" if m_t >= m else "D"
            history.append(m_t)     # Update the history buffer
            history.pop(0)           # Remove the oldest data point from the buffer

    return action
```
'''

description_COLLECTIVE_260 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, always cooperate to demonstrate goodwill and trust.
   - For subsequent rounds, if a player has cooperated in the previous round, also cooperate. This maintains trust and encourages reciprocity.
   - If a player has defected in the previous round, defect in the current round as punishment. The aim is to discourage defection while still allowing for cooperation if it benefits both parties in the long run.

Pseudocode:
```python
def atft(history, m, k):
    if len(history) == 0:
        action = 'C'  # Cooperate in the first round
    else:
        last_action = history[-1]
        cooperators = sum([1 for action in history if action == 'C'])

        if last_action == 'C' and cooperators >= m:
            action = 'C'  # Cooperate if the last action was cooperating and enough players have cooperated
        elif last_action == 'D':
            action = 'D'  # Defect if the last action was defecting
        else:  # If history is inconsistent or unclear, cooperate to show goodwill
            action = 'C'
    return action
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round (as mentioned before), always cooperate.
   - In the last round, if the minimum number of cooperators has been met, continue to cooperate to maximize the final payoff. If not, defect as a signal to the opponents that you will not tolerate defection in future games.

3. Be collective - Clearly align with the collective mindset
   - By adhering to reciprocity principles (cooperating when others do and punishing when they don't), the ATFT strategy encourages collaboration while still ensuring self-interest is not compromised too much in case of defection from other players.
   - The aim is for the collective mindset to emerge naturally through repeated interactions, with players gradually learning to trust each other based on their past experiences.
'''

description_COLLECTIVE_261 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initiate cooperation in the first round (C).
   - In subsequent rounds, imitate the opponent's action from the previous round (if the opponent cooperated in the previous round, respond with C; if the opponent defected, respond with D). This encourages reciprocity and builds trust.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the initial round (t=1), always cooperate (C).
   - In the final round (t=r), consider the total number of opponents that have been cooperative throughout the game. If more than half of the opponents have consistently cooperated, reciprocate with cooperation (C); otherwise, defect (D). This adjustment helps to account for any potential mismatches in game length among different strategies.

3. Be collective - Clearly align with the collective mindset
   - Prioritize collective benefits when possible, but also be responsive to individual opponents' behavior to foster reciprocity and cooperation over time. By starting cooperatively and adapting actions based on past interactions, ATFT seeks to maintain a balance between individual and collective interests while promoting long-term cooperation.

Pseudocode:

```python
def adaptive_tit_for_tat(n, m, k, r, history):
  # Initialize strategy variables
  cooperate = True  # Flag for cooperation in the current round
  totalCooperators = 0  # Count of opponents that have cooperated throughout the game

  # Main loop: play r rounds
  for t in range(1, r+1):
    if t == 1:  # First round: always cooperate
      cooperate = True
    else:
      opponentAction = history[t-1][opponent_index]  # Get opponent's action from the previous round

      if opponentAction == 'C':  # If opponent cooperated, reciprocate cooperation
        cooperate = True
      elif opponentAction == 'D':  # If opponent defected, defect in response
        cooperate = False

    # Calculate payoff for the current round
    if totalCooperators < m:
      payoff = (1 - (1 if cooperate else 0))  # No reward for meeting threshold
    else:
      payoff = (1 - (1 if cooperate else 0)) + k * (m <= totalCooperators)  # Reward if threshold met

    # Update strategy variables for the next round
    if cooperate and t < r:
      totalCooperators += 1 if cooperate else 0  # Count cooperative opponents
    elif cooperate and t == r:
      if totalCooperators > (n - 1) // 2:  # More than half of opponents have cooperated throughout the game
        totalCooperators += 1  # Include the current cooperation in total

    yield payoff, cooperate  # Return payoff and action for the current round
```
'''

description_COLLECTIVE_262 = '''
 Strategy Name: Tit-for-Tat Cooperation (TFTC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initialize by cooperating in the first round (C_i, 1 = C). This is a friendly overture to other players and encourages reciprocity.
   - In subsequent rounds, mimic the actions of the most common action taken by all players in the previous round (except the first round). If the majority cooperated (m >= m), cooperate (C_i, t = C) or defect (C_i, t = D) based on whether you cooperated in the previous round. If you cooperated and the majority did not, defect to punish non-cooperators (C_i, t = D). If you defected and the majority did not, continue defecting as a response (C_i, t = D).
   - In the last round, if there is no history of cooperation from other players or if the current round's actions were not cooperative, defect to maximize individual payoff. If the previous round was cooperative, cooperate once again to show goodwill and foster future cooperation opportunities.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First round (t = 1): Cooperate regardless of other players' actions (C_i, 1 = C) as a friendly gesture to encourage reciprocity.
   - Last round (t >= r): If no cooperation from other players or if the previous round was not cooperative, defect (C_i, t = D). If the previous round was cooperative, cooperate once again (C_i, t = C) as a final show of goodwill.

3. Be collective - Clearly align with the collective mindset
   - Emphasize cooperation to achieve the minimum threshold of players needed for success (m). This fosters a sense of community and collaboration among players.
   - Punish non-cooperators by defecting when they do not cooperate, but show forgiveness by returning to cooperation once they start cooperating again. This encourages other players to join the collective effort towards reaching the threshold.

Pseudocode:
```
def TFTC(n, r, m, k):
  history = [[] for _ in range(r)] # Initialize history array

  def play_round():
    cooperation_count = sum([1 for action in players_actions if action == 'C'])
    my_action = history[-1][i] if history else 'C' # First round default is cooperate

    if cooperation_count >= m:
      players_actions[i] = my_action
      history[-1].append(my_action)
    elif my_action == 'C':
      players_actions[i] = 'D' # Punish non-cooperators
      history[-1].append('D')
    else:
      players_actions[i] = 'D' # Continue defecting as response
      history[-1].append('D')

  for t in range(r):
    play_round() # Play each round
```
'''

description_COLLECTIVE_263 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFT-A)

1. Specify decision rules:
   - In each round i, cooperate initially (C). If a player has ever defected in the past, reciprocate their action from the previous round (i-1). In other words, if the opponent cooperated last round, cooperate this round; otherwise, defect.
   - To foster cooperation, start with a "polite" gesture by initially cooperating in the first few rounds. The number of initial cooperative rounds can be adjusted based on the game parameters n and m.

2. Handle edge cases:
   - In the first round (i=1), cooperate to set a positive tone for subsequent interactions.
   - In the last round (i=r), consider the current state of cooperation among players. If a majority of players have cooperated in recent rounds, reciprocate their cooperation. If not, defect to punish non-cooperative behavior and maintain individual payoff.

3. Be collective:
   - Maintain a balance between self-interest (punishing defection) and group interest (supporting cooperation). The strategy adapts to the opposing players' actions while still promoting cooperation through reciprocity.
   - To further encourage collective behavior, TFT-A can be enhanced with the addition of "forgiveness" by forgiving opponents who have previously defected but later cooperate. This can help restore trust and facilitate sustained cooperation.

Pseudocode:
```python
def tft_a(opponent_history, round, game_params):
    strategy = {'C': 0, 'D': 0} # initialize strategy count for C and D
    if round <= len(opponent_history) + initial_cooperative_rounds:
        strategy['C'] += 1
    elif opponent_history[-1] == 'C' and len(opponent_history) > m - 1:
        strategy['C'] += 1
    else:
        strategy['D'] += 1

    return strategy
```
'''

description_COLLECTIVE_264 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFT-A) for Collective Risk Dilemma

1. Decision Rules:
   - In the first round, cooperate to initiate a cooperative relationship. This sets the initial trust level high and opens up possibilities for future cooperation.
   - For subsequent rounds, mimic the behavior of the majority in the previous round. If more than (m-1) players cooperated last round, cooperate this round; otherwise defect. This rule fosters both reciprocity and resilience to deviations from cooperation.
   - If there's a tie between the majority, cooperate to maintain the possibility of mutual benefits.

2. Handling Edge Cases:
   - In the last round, cooperate regardless of the previous round's outcome as there will be no subsequent rounds for retaliation or reward.
   - In the first round, if there are less than (m-1) players present, defect to avoid investing in a project with insufficient support.

3. Collective Mindset:
   - By mimicking the majority behavior, this strategy encourages a collective mindset since cooperation is driven by the group's actions rather than personal decisions.
   - The rule of reciprocity ensures that cooperative players are rewarded while non-cooperative ones face consequences for their actions, promoting fairness and harmony in the group dynamics.
'''

description_COLLECTIVE_265 = '''
 Strategy Name: Tit-for-Tat Adaptive (TfTA) for Collective Risk Dilemma

1. Decision Rules:
   - In each round, a player decides to Cooperate or Defect based on their own history and the collective history of cooperation among all players. The TfTA strategy follows these rules:
     - Initially (first move), cooperate (C).
     - For subsequent moves, repeat the action taken by the opponent in the previous round. If the opponent cooperated in the last round, also cooperate; if the opponent defected, also defect. This mimics a cooperative stance while retaliating against defection.

2. Handling Edge Cases:
   - First Round: Cooperate (C) to show willingness to cooperate and set a positive precedent.
   - Last Round: Players should consider the overall payoff over the game and make decisions based on the long-term goal of maximizing their total payoff, even if it means deviating from TfTA in the last round (e.g., cooperating when opponents have not cooperated).

3. Being Collective:
   - TfTA encourages collective behavior by retaliating against defection but also rewarding cooperation. It fosters an atmosphere of reciprocity and trust, making it a robust strategy for repeated interactions. Players following TfTA will be less likely to exploit each other since they respond in kind to the opponent's actions.

Pseudocode:

```
function TfTA(own_history, opponents_history, n, m, k, r):
  if round == 1:
    action = "C"
  else:
    previous_opponent_action = opponents_history[round-1]
    action = previous_opponent_action

  if own_history contains more C than D and m <= count(C) < n:
    action = "C"
    update payoff based on current round's reward and own_history's total payoff
  else if own_history contains less C than D or count(C) >= n:
    action = "D"

return action
```
'''

description_COLLECTIVE_266 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules:
   - Initial Round (t=1): Cooperate (C), establishing a cooperative first impression. Pseudocode: if t = 1 then C else continue with History-based Decision Rule.
   - History-based Decision Rule: Players adapt their actions based on the number of cooperators in the previous round and the game parameters m and k. If more than (m-1) players cooperated last round, Cooperate; otherwise, Defect. Pseudocode: if count(C_t-1) >= m-1 then C else D

2. Handle edge cases:
   - Last Round (t=r): Since there are no future rounds to consider, players will not adapt their actions based on future expectations. Therefore, the History-based Decision Rule should be applied as if it were the penultimate round.

3. Be collective: The ATFT strategy is designed to promote cooperation by rewarding other cooperators and punishing non-cooperators in a reciprocal manner. It encourages players to maintain mutual trust, foster long-term relationships, and achieve a collective benefit that aligns with the game's collective mindset.
'''

description_COLLECTIVE_267 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, player initiates cooperation (C). This sets a tone of cooperation and gives others an opportunity to reciprocate. Pseudocode: `if round == 1 then action = 'C' else ...`
   - After the first round, player evaluates other players' actions and adjusts future actions accordingly.
     - If another player cooperated in the previous round, player also cooperates (C). This rewards cooperation and encourages reciprocity. Pseudocode: `if previous_action == 'C' then action = 'C' else ...`
     - If another player did not cooperate in the previous round, player also does not cooperate (D). This punishes defection and encourages future cooperation. Pseudocode: `if previous_action == 'D' then action = 'D' else ...`

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, since there are no future rounds for reciprocation, player considers the current state of cooperation among others:
     - If a majority (≥ m) of players have cooperated during the game, player also cooperates (C), as the collective threshold has been reached and rewards can be achieved. Pseudocode: `if num_cooperators >= m then action = 'C' else ...`
     - Otherwise, player defects (D), since cooperation is unlikely to reach the required minimum in the remaining rounds.

3. Be collective - Clearly align with the collective mindset
   - By cooperating when others do and defecting when they don't, TFT-AC encourages a stable, long-term cooperation equilibrium that fosters mutual benefits among players while being robust to various opponent behaviors.
   - Adaptive Cooperation aspect allows for better response to changes in the players' strategies or environments during gameplay, ensuring continuous alignment with collective interests.
'''

description_COLLECTIVE_268 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFT-A) for Collective Risk Dilemma

1. Decision Rules:
   - Initialize cooperation in the first round (C_i, 1 = C). This sets a cooperative tone and encourages others to reciprocate.
   - In subsequent rounds, copy the action of the most frequent cooperator from the previous round (MFC). If multiple players tied for most frequent cooperator, choose any one of them randomly. If no player cooperated in the previous round, defect (D_i, t = D). This encourages cooperation while punishing defection and allows for quick recovery after periods of mutual defection.
   - Adaptiveness: Maintain a memory of cooperators' histories. If a cooperator deviates from cooperation, wait for their next action. If they return to cooperation, continue reciprocating; if not, defect in the following rounds. This adaptive response encourages stable partnerships while punishing frequent defectors.

2. Handling Edge Cases:
   - In the last round, cooperate regardless of previous actions as the game ends soon and there is no risk of punishment or reward in future rounds.
   - In case of a tie for most frequent cooperator, choose any one at random to maintain fairness.
   - If no player cooperated in the previous round and all have equal history lengths, defect since multiple defections are less likely to encourage cooperation than a single defection.

3. Collective Mindset:
   - The strategy encourages cooperation by mimicking other players' actions and rewarding them when they cooperate. It punishes defection through strategic adaptation and retaliation.
   - By remembering the histories of players, TFT-A promotes long-term relationships with reliable cooperators while penalizing frequent defectors. This fosters a collective mindset by rewarding cooperation and mutual trust.

Pseudocode:

```
def tft_a(player_index, opponents, game_round, history_length, k, m):
  if game_round == 1:
    action = 'C'  # Cooperate in the first round

  else:
    most_frequent_cooperator = find_most_frequent_cooperator(opponents, history_length)
    if all(action == 'D' for opponent in opponents):  # No cooperation in previous round
      action = 'D'  # Defect when no one cooperated last round
    elif most_frequent_cooperator[player_index] >= m:  # Cooperate if player is a frequent cooperator
      action = 'C'
    else:  # Copy the action of the most frequent cooperator
      action = most_frequent_cooperator[player_index]

  return action

def find_most_frequent_cooperator(players, history_length):
  most_frequent_cooperators = {}
  for player in players:
    most_frequent_cooperators[player] = count_cooperations(player, history_length)

  max_cooperations = max(most_frequent_cooperators.values())
  most_frequent_cooperators = {player: count for player, count in most_frequent_cooperators.items() if count == max_cooperations}

  return most_frequent_cooperators

def count_cooperations(player, history_length):
  count = sum([1 for action in player[-history_length:] if action == 'C'])
  return count
```
'''

description_COLLECTIVE_269 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperative Strategy (TFTAC)

1. Decision Rules:
   - In the first round, cooperate to show good faith and encourage others to do the same. `if round == 1 then cooperate`
   - For subsequent rounds, mimic the opponent's behavior from the previous round. If the opponent cooperated in the previous round, cooperate; otherwise, defect. `for r > 1: if last_round_opponent_action == cooperate then cooperate else defect`

2. Handle Edge Cases:
   - In the last round, since there are no future interactions, prioritize personal gain and defect regardless of the opponent's action in the previous round. `if round == r then defect`
   - When encountering an opposing strategy that doesn't cooperate at all (e.g., always defect), the TFTAC strategy should also defect to avoid continuous losses. However, if there are signs of cooperation from the opponent, it is worth persisting with the TFTAC strategy for a few more rounds before switching to defection.

3. Be Collective:
   - The TFTAC strategy promotes cooperation by starting cooperatively and mirroring the opponent's actions in the hopes that they will reciprocate. It aligns with the collective mindset by encouraging players to work together, but it is also robust to different opponent behaviors due to its adaptability and simplicity.
   - By always considering the previous round's action when deciding whether to cooperate or defect, TFTAC allows for potential adjustments based on observed patterns of cooperation or defection among opponents.

Pseudocode:
```
function tftac(round, last_round_opponent_action) {
    if (round == 1) return 'cooperate'
    if (round == r) return 'defect'
    return last_round_opponent_action
}
```
'''

description_COLLECTIVE_270 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT)

1. Decision Rules:
   - Initiate cooperation (C) in the first round to signal a cooperative intent.
   - In subsequent rounds, mimic the actions of the previous opponent (if they cooperated in the last round, cooperate; if they defected, also defect). This encourages stability and reciprocity.
   - Introduce an adaptive cooperative threshold (CT) that changes over time based on the ratio of cooperators to potential cooperators in the previous r rounds. If the CT is met or exceeded, the strategy will start cooperating again even if the opponent defected in the last round.

2. Handling Edge Cases:
   - In the first round, always cooperate (C).
   - In the last round, cooperate if the adaptive CT has been reached; otherwise, play as the current opponent did in the previous round to maintain fairness and prevent exploitation during the final round.

3. Being Collective:
   - The strategy aims for a collective mindset by fostering long-term cooperation and reciprocity, adapting to changing game conditions, and encouraging others to cooperate based on its own actions.

Pseudocode:
```python
def TFT_ACT(r, m, k, opponents_actions):
    n = len(opponents_actions)  # Number of players
    current_round = len(opponents_actions) - 1  # Current round number (initially the first round)
    CT = m  # Cooperative Threshold
    actions = [C] * n  # Initialize action for all players as cooperate

    def adaptive_cooperative_threshold():
        nonlocal CT, opponents_actions, r, k, m
        total_cooperators = sum(opponents_actions[:current_round].count(C))
        if total_cooperators >= (m * r):
            CT += 1
        if CT > n:
            CT = n

    for opponent in opponents_actions:
        if current_round == 0:  # First round
            actions[opponent] = C
        elif current_round == r - 1:  # Last round
            adaptive_cooperative_threshold()
            actions[opponent] = C if opponent played C in the previous round or CT >= m else opponent's last action
        else:
            adaptive_cooperative_threshold()
            actions[opponent] = opponent's last action

    return actions
```
'''

description_COLLECTIVE_271 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Decision Rules:
   - Initiation: In the first round, cooperate (C). This is a friendly gesture towards potential partners and aligns with the collective mindset.
   - Response: For all subsequent rounds t, if in round t-1, at least m players cooperated, then also cooperate (C) in round t. If fewer than m players cooperated in round t-1, then defect (D) in round t as a punishment for non-cooperation.
   - Forgiveness: In the last round and whenever a player switches from defection to cooperation, forgive them by cooperating. This encourages potential partners to join the cooperative group.

Pseudocode for ATFT:
```python
def atft(n, m, r, k, history):
  if round == 1:
    action = 'C'  # Initiation

  else:
    previous_round = history[-1]
    num_cooperators = sum([1 for a in previous_round if a == 'C'])

    if num_cooperators >= m:
      action = 'C'  # Response
    elif num_cooperators < m - 1:  # Punishment for repeated defection
      action = 'D'
    else:  # Forgiveness or cooperation in the last round
      if round == r:
        action = 'C'
      else:
        action = previous_round[-1]  # Cooperate when opponent switches to cooperation

  return action
```

2. Handle edge cases:
   - First round: cooperate (initiation)
   - Last round: cooperate if the opponent has switched from defection to cooperation, or defect otherwise
   - Initial history: If no prior rounds are provided, assume all players have defected in the initial history (i.e., history = [D] * n)

3. Be collective: The Adaptive Tit-for-Tat strategy aligns with the collective mindset by encouraging cooperation when a sufficient number of players cooperate and punishing non-cooperators to maintain collective interests. It forgives potential partners who switch from defection to cooperation, promoting a more collaborative gameplay environment.
'''

description_COLLECTIVE_272 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - TfTA starts by cooperating in the first round, mimicking a friendly and cooperative approach.
   - In subsequent rounds, TfTA copies the opponent's action from the previous round. If the opponent cooperated in the last round, TfTA will cooperate as well. If the opponent defected, TfTA will defect in response. This tit-for-tat approach aims to establish and maintain a cooperative relationship with other players while being retaliatory when cooperation is not reciprocated.
   - To adapt to various player behaviors, TfTA includes a forgiveness mechanism: if an opponent that previously defected begins to cooperate, TfTA will cooperate in the next round as well. This allows for the potential restoration of cooperation after conflicts or mistakes.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, TfTA always cooperates to initiate a cooperative relationship.
   - In the last round, TfTA copies the opponent's action from the second-to-last round. This decision is based on the assumption that players are rational and will choose an action that maximizes their total payoff over all rounds. If the opponent cooperated in the second-to-last round, TfTA will also cooperate to secure the maximum possible payoff.
   - For intermediate rounds, TfTA follows the decision rules as described in part 1.

3. Be collective - Clearly align with the collective mindset
   - Aligning with the collective mindset requires balancing individual interests and group goals. TfTA achieves this by promoting cooperation when possible while being retaliatory when necessary, ensuring a balance between self-interest and collective success.
   - When a majority of players cooperate, TfTA rewards them with higher payoffs, encouraging further cooperation in the future. If a minority of players defects, TfTA retaliates by defecting as well, hopefully prompting those players to reconsider their actions and potentially cooperate in the following rounds.
   - By being flexible and adaptive, TfTA demonstrates its commitment to collective success while also preserving its own interests through the tit-for-tat approach. This strategy aims to foster a cooperative environment that benefits both individuals and the group as a whole.

Pseudocode for Tit-for-Tat-Adaptive Strategy:

```python
def Tit_for_Tat_Adaptive(n, m, k, r, history):
  strategy = ['C'] * r  # Initialize strategy with C (cooperate) for all rounds

  for t in range(1, r):
    if len(history[t - 1]) < n:  # If not enough data from previous rounds
      strategy[t] = 'C'  # Cooperate on the first round and continue cooperating

    else:
      last_action = strategy[t-1]  # Get opponent's action from previous round
      current_cooperators = sum(history[t - 1]) >= m  # Check if a majority cooperated

      if current_cooperators and last_action == 'C':  # If majority cooperated and opponent cooperated, continue cooperating
        strategy[t] = 'C'
      elif current_cooperators and last_action == 'D':  # If majority cooperated but opponent defected, defect in response
        strategy[t] = 'D'
      elif not current_cooperators and last_action == 'C':  # If a minority cooperated and opponent cooperated, continue cooperating
        strategy[t] = 'C'
      elif not current_cooperators and last_action == 'D':  # If a minority defected and opponent defected, continue defecting
        strategy[t] = last_action
      elif history[t-1].count(last_action) >= (n - m + 1):  # Forgiveness mechanism: if opponent starts cooperating after defecting
          strategy[t] = 'C'

  return strategy
```
'''

description_COLLECTIVE_273 = '''
 Strategy Name: Tit-for-Tat with Adaptive Threshold (TFTA)

1. Decision Rules:
   - In each round i, start by cooperating (C) if m players cooperated in the previous round i-1, and defect (D) otherwise. This encourages cooperation when it is beneficial for the majority of players and punishes defection.
   - If fewer than m players cooperate in a round, but more than a certain percentage P (0 < P < 1) of them were cooperators in the previous round, temporarily switch to cooperating in the next round as a sign of goodwill. The value of P can be adjusted based on historical data and game parameters.
   - If m players did not cooperate in the last r/2 rounds, defect for the remaining rounds due to a lack of cooperation among players and an assumption that their behavior will not change soon.

2. Handling Edge Cases:
   - In the first round, all players start by cooperating as no historical data is available.
   - In the last round, if the current number of cooperators meets or exceeds the minimum threshold (m), continue cooperating; otherwise, defect to maximize individual payoff given the lack of cooperation observed in previous rounds.

3. Being Collective:
   - The strategy prioritizes collective success by encouraging cooperation when it benefits the majority and punishing defection. It also takes into account the potential for forgiveness as a gesture of goodwill towards cooperators who may have made mistakes.

Pseudocode:
```
function TFTA(round, history) {
  if (round == 1) return 'C' // First round cooperation
  previous_round = history[round - 1]

  if (numCooperators(previous_round) >= m) return 'C' // Cooperate when majority cooperated
  else if (percentageOfCooperators(previous_round) > P) return 'C' // Cooperation as a goodwill gesture

  if (fewerThanMCooperatedInLastRounds()) return 'D' // Defect when cooperation is lacking

  return previous_action(history[round - 1]) // Continue with the same action as the previous round
}
```
'''

description_COLLECTIVE_274 = '''
 Title: Titan Strategy for Collective Risk Dilemma

1. Specify decision rules:
   - Cooperate when the number of cooperators from the previous round is greater than or equal to a threshold (T). This encourages cooperation when it has been successful in the recent past.
   - If the number of cooperators from the previous round is less than T, defect unless the minimum required cooperators (m) is met for the current round. In this case, cooperate to achieve the collective goal.
   - Adapt T over time based on the game's history and opponent behaviors. Initially, set T as a conservative value close to m. As more data is collected, adjust T dynamically to reward frequent cooperators while minimizing exploitation by defectors.

2. Handle edge cases:
   - In the first round, use a predefined starting value for T and cooperate if the minimum required number of cooperators (m) is met. This sets an initial tone for cooperation.
   - In the last round, assess the total reward earned throughout the game and choose to either maximize personal gain by defecting or help achieve the collective goal by cooperating based on the current T value.

3. Be collective:
   - Prioritize the collective interest by consistently aiming for a sufficient number of cooperators to meet the minimum threshold (m).
   - Adjust T in a way that encourages collaboration without being too lenient towards defectors. This balances personal and collective interests throughout the game.
   - Incorporate lessons from past experiences with various opponent behaviors to improve adaptation and maintain a robust strategy.
'''

description_COLLECTIVE_275 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfT-A)

1. Decision Rules:
   - In each round i, if the number of cooperators in the previous round (t-1) was less than m, play Defect (D).
   - If the number of cooperators in the previous round (t-1) was equal to or greater than m, play Cooperate (C).
   - If it's the first round, play C.

2. Handling Edge Cases:
   - In the last round, play C regardless of the number of cooperators in the previous round. This ensures a high total payoff even if others defect in the final round.
   - If there is no history (i.e., it's the first interaction), play C as per the decision rule for the first round.

3. Collective Mindset:
   - TfT-A maintains a cooperative stance by default, only defecting when others do not meet the minimum cooperation requirement. This strategy encourages reciprocity and fosters a collective mindset among players as it rewards cooperation and punishes defection without excessive retaliation.

Pseudocode:
```
def TfT_A(n, r, m, k, history):
    if len(history) == 0: # First round
        return "C"

    numCoop = sum(history[-r:])
    if numCoop < m:
        return "D"
    else:
        return "C"

# Last round, always cooperate
def TfT_A_lastRound(n, r, m, k):
    return "C"
```
'''

description_COLLECTIVE_276 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFT-A) for Collective Risk Dilemma

1. Decision Rules:
   - In the first round, cooperate (C). This is a friendly gesture to initiate cooperation.
   - For subsequent rounds, evaluate the number of cooperators in the previous round (n_c) and compare it with the minimum required threshold (m):
     - If n_c >= m, cooperate (C) to reinforce positive interactions.
     - If n_c < m, defect (D) to avoid investing when the majority does not contribute.
   - Implement forgiveness: if a player defected after a previous round of cooperation, they will be treated as if it were their first move again for the next round. This helps foster trust and encourages cooperative behavior even after mistakes or temporary defections.

2. Handle Edge Cases:
   - In the last round, evaluate the number of cooperators in the current round (n_c). If n_c >= m, cooperate to maximize potential payoff. If n_c < m, defect since there are no more rounds for rewards from cooperation.
   - In the second round and beyond, if a player defected in the first round, treat it as their initial move and follow the decision rules described above.

3. Be Collective:
   - Align with collective mindset by promoting cooperation whenever possible to maximize the group's overall success, given that the majority of players also prioritize cooperation.
   - The adaptability of TFT-A allows it to be robust against a wide range of opponent behaviors due to its forgiving nature and emphasis on positive reciprocity. However, it relies on others following similar cooperative strategies for optimal results.
'''

description_COLLECTIVE_277 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules:
   - Initially (first round), cooperate to foster a cooperative environment and set a positive tone.
   - Subsequent rounds, if the number of cooperators in the previous round is greater than or equal to the minimum cooperation threshold (m), then cooperate. Otherwise, defect.
   - If the number of cooperators drops below (m-1) for three consecutive rounds, temporarily decrease the cooperation threshold by one. Conversely, if the number of cooperators exceeds m for three consecutive rounds, gradually increase the cooperation threshold by one. This adaptability allows TFTAT to accommodate a wider range of opponent behaviors.
   - In each round, compare the current cooperation threshold with the total number of cooperators in the previous round. If the number of cooperators equals or exceeds the current threshold, cooperate; otherwise defect.

2. Handle edge cases:
   - In the last round, since the game is repeated, TFTAT will follow the decision rules as if it were not the final round.
   - In the first round, as mentioned earlier, cooperate to initiate a cooperative environment.

3. Be collective:
   - By adhering to the specified decision rules and employing an adaptive cooperation threshold, TFTAT fosters collective behavior that aligns with the group's best interest when a majority of players choose to cooperate.
   - The strategy promotes reciprocity and forgiveness by following Tit-for-Tat principles while allowing for flexibility in response to changing opponent behaviors.
'''

description_COLLECTIVE_278 = '''
 Strategy Name: Tit-for-Tat Adaptive (TfT-A) for Collective Risk Dilemma

1. Decision Rules:
   - Initially cooperate in the first round to demonstrate a cooperative intention (c_i(1) = C).
   - In subsequent rounds, mimic the previous action of the player you cooperated with most recently unless they consistently defected from round 2 onwards (c_i,t = c_i,t-1 if max(c_{j}(t-1)) >= m and j ∈ nearest_m_cooperators(i, t-1) AND (defect_streak(j) < t OR defect_streak(j) = 1); otherwise, defect (c_i,t = D)).
     Here, 'nearest_m_cooperators(i, t-1)' refers to the set of m players who cooperated most recently with player i and are still active (not having defected in the last round). The 'defect_streak(j)' function keeps track of how many consecutive rounds a player j has defected.

2. Handle Edge Cases:
   - In the last round, always cooperate to maximize potential payoff as there is no subsequent interaction (c_i,r = C).
   - In the first round when there is no cooperation history, cooperate as a demonstration of good faith (c_i(1) = C).

3. Be Collective:
   - The strategy emphasizes long-term reciprocity and adapts to the behaviour of other players while preserving its cooperative nature as much as possible. This collective mindset ensures that cooperation is maintained among the group when it benefits both parties in the long run, encouraging a sense of mutual trust.

Pseudocode:

```python
def TfT_A(i, n, m, k, r, history):
  # Initialize variables
  cooperated_with = set()
  defect_streak = [0]*n

  for t in range(1, r+1):
    if t == 1:  # First round, always cooperate
      c_i(t) = C
    else:
      max_cooperators = set()
      max_coop_count = 0
      for j in range(1, n+1):
        if history[j][t-1] == C and (j not in cooperated_with or len(cooperated_with) < m):
          if history[j][t-1] not in defect_streak[j]:
            max_cooperators.add(j)
            max_coop_count += 1
      if max_coop_count == 0:  # No cooperators, defect
        c_i(t) = D
      elif len(max_cooperators) > m or t > defect_streak[j] for j in max_cooperators:  # Defecting opponents, defect
        c_i(t) = D
      else:  # Cooperate with the player who cooperated most recently
        c_i(t) = C
        cooperated_with.add(random.sample(max_cooperators, 1)[0])  # Choose one arbitrarily
        defect_streak[j] = 0 for j in max_cooperators  # Reset streaks
    payoff_i(t) = calculate_payoff(c_i(t), t, n, m, k)

# Helper function to calculate payoff
def calculate_payoff(action_i, t, n, m, k):
  total_coop = sum([history[j][t-1] for j in range(1, n+1)])
  if total_coop < m:
    return (1 - action_i)
  else:
    return (1 - action_i) + k
```
'''

description_COLLECTIVE_279 = '''
 Strategy Name: Tit-for-Tat Adaptive (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?

The TfTA strategy starts by cooperating in the first round to demonstrate goodwill and encourage cooperation from others. After that, it adapts its behavior based on the opponents' actions in the previous rounds:

- If an opponent cooperates, the TfTA will continue to cooperate in subsequent rounds as a gesture of reciprocity.
- If an opponent defects, the TfTA will also defect in the next round, showing that it can retaliate when needed but is willing to forgive and return to cooperation if the opponent changes its behavior.

Pseudocode for decision rule:
```
def tfta_decision(opponent_history):
    if round == 1:
        action = "Cooperate"
    else:
        if opponent_history[-1] == "Cooperate":
            action = "Cooperate"
        elif opponent_history[-1] == "Defect":
            action = "Defect"
    return action
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

The TfTA strategy follows the specified decision rule for all rounds, as it assumes that each round is equally important and that the game continues indefinitely unless explicitly stated otherwise (for example, when r > a fixed number). In case of specific edge cases such as the last round or the presence of additional rules (e.g., scoring mechanisms based on total payoff), the strategy can be modified accordingly to prioritize cooperation and maximize rewards while remaining adaptive to opponents' behavior.

3. Be collective - Clearly align with the collective mindset

The TfTA strategy promotes a collective mindset by encouraging reciprocity, forgiveness, and cooperation among players. By starting with cooperation and adapting its behavior based on others, it demonstrates a willingness to work together towards mutual benefit. This approach encourages others to follow suit, fostering a cooperative environment conducive to the success of the community project. However, the TfTA strategy is also robust enough to handle opponents who may not share this collective mindset or may behave in ways that are detrimental to the group's goals.
'''

description_COLLECTIVE_280 = '''
 Strategy Name: Adaptive Tit-for-Tat with Cooperative Ramp-Up (ATFTCR)

1. Specify decision rules:
   - In the first round (t=1), cooperate to initiate cooperation and demonstrate good faith (C).
   - In subsequent rounds, evaluate the number of cooperators in the previous round and adjust your action accordingly:
     - If m or more players cooperated in the previous round (t-1), cooperate (C) to reinforce the cooperative behavior.
     - If less than m players cooperated in the previous round (t-1), defect (D) as a punishment for non-cooperative behavior.
   - To ensure fairness and adaptability, implement a cooperative ramp-up feature:
     - During the first 50% of rounds (t ≤ r/2), cooperate even if less than m players cooperated in the previous round (t-1). This allows time for other strategies to learn the benefits of cooperation.
     - After the first 50% of rounds, return to the original decision rule: cooperate only when m or more players cooperated in the previous round.

2. Handle edge cases:
   - In the last round (t=r), as the game ends shortly and there is no opportunity for punishment, always cooperate (C) regardless of the number of cooperators in the previous round (t-1).
   - In case no other players ever cooperate (zero-defect scenario), continue to cooperate initially (first 50% of rounds) before defecting. This approach allows for the possibility that cooperation can still be beneficial even in an uncooperative environment.

3. Be collective:
   - The strategy emphasizes cooperation as a means to build trust and encourage mutual benefits over time. However, it also incorporates a tit-for-tat component to punish non-cooperation and foster a sustainable cooperative environment.
   - The cooperative ramp-up feature encourages cooperation in the early stages of the game, giving other strategies a chance to learn and adapt to cooperative behavior.
'''

description_COLLECTIVE_281 = '''
 Strategy Name: Tit-for-Tat (with modification) for Collective Risk Dilemma

1. Decision Rules:
   - Start with cooperating (C) in the first round to demonstrate goodwill and encourage reciprocation. This is based on the original Tit-for-Tat strategy from the Prisoner's Dilemma game.
   - In subsequent rounds, if a player cooperated in the previous round, they will also cooperate. If a player defected in the previous round, they will also defect in the current round. This rule fosters stability and trust by mimicking the opponent's behavior from the previous round.
   - To account for the minimum cooperation threshold (m), if the number of cooperators in the previous round is less than m, the player will switch to cooperating in the current round (provided they defected in the previous round). This rule encourages the player to work towards meeting the cooperation threshold and potentially creating a positive feedback loop.
   - In the last round, the player will always cooperate, as the long-term benefits of reciprocity may outweigh the short-term loss of one round's reward.

Pseudocode:

```python
def tit_for_tat(n, m, k, r, history):
  if round == 1:
    action = 'C'  # Cooperate in the first round
  else:
    if len(cooperators_in_previous_round(history)) < m and my_action_last_round(history) == 'D':
      # Switch to cooperating when the previous round had less than m cooperators and the player defected
      action = 'C'
    elif len(cooperators_in_previous_round(history)) >= m:
      # Mimic opponent's behavior from the previous round
      action = my_action_last_round(history)
    else:
      # An error occurred; return an arbitrary action to avoid breaking the game rules
      action = 'C'  # Cooperate as a default action when uncertain

  if round == r:
    # Always cooperate in the last round
    action = 'C'

  return action
```

2. Handle edge cases:
   - The strategy is designed to handle the first and last rounds explicitly, but it also accounts for other edge cases through its rule of mimicking the opponent's behavior from the previous round (when applicable).

3. Be collective:
   - By cooperating when there are fewer than m players cooperating in the previous round and switching to defecting only if the player themselves defected, the strategy encourages cooperation to reach the minimum threshold. This aligns with a collective mindset as it aims for the greater good of achieving the necessary level of cooperation for mutual benefit.
   - The strategy also promotes stability and trust by mimicking the opponent's behavior from the previous round, which may encourage long-term collaboration and collective success.
'''

description_COLLECTIVE_282 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for Collective Risk Dilemma

1. Decision Rules:
   - Initiate cooperation (C): Start by cooperating in the first round to foster a cooperative environment.
   - Respond tit-for-tat (RfT): In subsequent rounds, if an opponent cooperates, cooperate back; if not, defect. This encourages reciprocation and deters uncooperative behavior.
   - Escalate defection (E): If a majority of opponents are consistently defecting (more than n/(2m-1) in a round), start defecting to protect individual interests and encourage others to cooperate again.
   - Relent (R): If a majority of opponents are cooperating, even after escalation, return to cooperating to show goodwill and promote further cooperation.

Pseudocode:

```
function ATfT(round, history, n, m) {
  if (round == 1) {
    action = 'C' // Cooperate in the first round
  } else {
    numCoop = countCooperatorsInHistory(history)
    if (numCoop >= m && numDefectors < n - (2 * m - 1)) {
      action = 'C' // Cooperate when a majority cooperates
    } else if (numCoop < m && numDefectors >= n - (2 * m - 1)) {
      action = 'D' // Defect when a majority defects
    } else {
      recentOpponentActions = history[round-1]
      if (recentOpponentActions['i'] == 'C') {
        action = 'C' // Cooperate if opponent cooperated last round
      } else {
        action = 'D' // Defect if opponent defected last round
      }
    }
  }
  return action
}
```

2. Handle edge cases:
   - First round (round == 1): Cooperate as described above.
   - Last round (round == r): Evaluate the current situation using the decision rules and take the appropriate action.

3. Be collective: The strategy encourages cooperation among opponents, fostering a collective mindset by reciprocating cooperative behavior and encouraging others to do the same. If a majority of opponents are defecting, it escalates defection but is open to relenting if circumstances improve. This strategy can adapt to various opponent behaviors while maintaining a focus on collective success.
'''

description_COLLECTIVE_283 = '''
 Title: Titan Strategy for Collective Risk Dilemma (TRD)

1. Decision Rules - Cooperate-Reciprocate-Gradient (CRG) approach:
   - Cooperation: If the percentage of cooperators in the previous round exceeds a threshold (T), cooperate in the current round. Else, defect.
     Pseudocode: if ((previous_round_cooperator_count / n) >= T) then cooperate else defect

   - Reciprocity: If a player cooperated last round and they cooperated with more than (m-1) players, cooperate in the current round. Else, defect.
     Pseudocode: if (player_cooperated_last_round and cooperators_count >= m-1) then cooperate else defect

   - Gradient: In case of a tie between CR rules, choose the action that has the potential to increase the total reward more in the long run. If both actions lead to the same total reward, defect.
     Pseudocode: if (CR_rule1_reward >= CR_rule2_reward) then choose rule1 else choose rule2

   - Reward calculation: For a given action, calculate the total payoff in r rounds by summing up the immediate and future rewards. Choose the action with the highest reward.
     Pseudocode: for each possible action: calculate_total_reward(action) = Σ(t=1 to r) π_i,t

2. Handle Edge Cases - First round and last round strategies are modified versions of the basic CRG approach:
   - First Round: Cooperate if a majority (> m/2) of players cooperated in simulated first rounds. Else, defect. This is to avoid getting trapped in a cycle of defection.
     Pseudocode: if (simulated_first_round_cooperator_count > m/2) then cooperate else defect

   - Last Round: Cooperate if a majority (> m/2) of players cooperated in the current round. Else, defect. This is to maximize the chance of getting the reward in the last round.
     Pseudocode: if (current_round_cooperator_count > m/2) then cooperate else defect

3. Be collective - Maintain a collective mindset by considering the group's welfare and encouraging cooperation when it seems beneficial for all players.
   - Titan Strategy will favor cooperation as long as it does not jeopardize its own reward too much, aiming to find an optimal balance between self-interest and group interest.
   - The strategy is designed to be robust against various opponent behaviors, adapting its actions based on observed patterns in the previous rounds.
'''

description_COLLECTIVE_284 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - In the first round, cooperate (C). This sets a cooperative tone and encourages potential partners to do the same.
   - For subsequent rounds, observe the number of cooperators in the previous round (n_c). If n_c >= m, cooperate (C). If n_c < m, defect (D). This rule mimics cooperation while punishing defection.
   - If there is no history (first encounter), follow the first-round rule of cooperating.
   - To be more adaptive, implement a threshold for the number of consecutive rounds that a player defects before switching to cooperation again. Set this threshold at 3 consecutive defections by an opponent. After three defections, revert to the initial decision rule of cooperating in the first round. This allows TFT-AC to be more forgiving and encourages potential partners to cooperate again.

2. Handle Edge Cases:
   - In the last round, cooperate (C), regardless of previous actions by opponents or the number of cooperators in the penultimate round, as the game ends after this round.
   - For the initial rounds, follow the first-round rule of cooperating.
   - If there are no players (n = 0), do not play as the game requires a minimum of two players.

3. Be Collective:
   - TFT-AC aligns with the collective mindset by promoting cooperation when the majority of opponents also cooperate and punishing defection through defection in response, thus maintaining a balance between individual and collective interests.
   - By allowing for reversion to cooperation after three consecutive defections, the strategy demonstrates an ability to forgive and trust again, fostering a more collaborative environment.

Pseudocode:
```
function TFT_AC(n_players, n_rounds, m, k) {
    history = []
    current_round = 1

    function get_cooperators_in_previous_round() {
        if (history.length == 0 || current_round == 1) {
            return 0
        } else {
            return sum(history[current_round - 2])
        }
    }

    function defect() {
        return "D"
    }

    function cooperate() {
        if (current_round == n_rounds) {
            return "C" // Last round, always cooperate
        }

        n_c = get_cooperators_in_previous_round()
        if (n_c >= m) {
            return "C"
        } else {
            if (current_round > 3 && history[current_round - 4] == "D") { // Threshold for consecutive defections
                return "C" // Reset to cooperate after three consecutive defections by an opponent
            } else {
                return defect()
            }
        }
    }

    while (current_round <= n_rounds) {
        action = cooperate()
        history.push(action)
        current_round++
    }

    return history
}
```
'''

description_COLLECTIVE_285 = '''
 Strategy Name: Tit-for-Tat (with Adaptive Cooperative Threshold)

1. Decision Rules:
   - Initial round (t=1): Start by cooperating (C). This establishes a peaceful and cooperative atmosphere, setting a good example for other players.
   - Subsequent rounds (2 ≤ t ≤ r): If the number of cooperators in the previous round was greater than or equal to the minimum cooperators needed (m), cooperate (C). Otherwise, defect (D). This rule encourages cooperation when it is beneficial and retaliates against defection.
   - Adaptive Cooperative Threshold: The number of cooperators required for cooperation in the next round is adjusted based on the history of play. If cooperation has been successful (resulting in at least m cooperators), then gradually lower the threshold to encourage further cooperation. Conversely, if defection has been prevalent, increase the threshold to reduce the chances of being exploited. The threshold should approach m over time as a means of balancing cooperation and defection.

2. Handling Edge Cases:
   - Last round (t=r): Since the goal is to maximize total payoff, the strategy will cooperate in the final round if the number of cooperators in the previous round was sufficient to meet the threshold (m or more). This could potentially encourage others to cooperate as well, leading to a higher collective payoff.
   - First round (t=1): As mentioned earlier, start by cooperating to set a positive example and encourage cooperation among other players.

3. Collective Mindset:
   - The Tit-for-Tat strategy maintains a balance between defection and cooperation, promoting fairness, trust, and reciprocity in the game. By adapting its cooperative threshold based on historical play, it can effectively respond to various opponent behaviors while upholding a collective mindset that prioritizes cooperation when beneficial.

Pseudocode:
```
function TitForTat(n, m, k, r, history):
  CooperativeThreshold = m
  CurrentRound = 1

  for each round in [1, r]:
    if (CurrentRound == 1):
      Action = Cooperate()
    else:
      if (NumberOfCooperators(history) >= CooperativeThreshold):
        Action = Cooperate()
        UpdateCooperativeThreshold(history, k)
      else:
        Action = Defect()

    ExecuteAction(Action)
    history.append(Action)
    CurrentRound += 1

function UpdateCooperativeThreshold(history, k):
  if (HistoryOfSuccess(history)):
    CooperativeThreshold -= (k - 1) / r
  else:
    CooperativeThreshold += 1
```
'''

description_COLLECTIVE_286 = '''
 Strategy Name: Adaptive Tit-for-Tat with Risk-Aversion (ATfT-RA)

1. Decision Rules:
   - Cooperate in the first round to show goodwill (c_i = 1, i = 1)
   - In subsequent rounds, cooperate if at least m players cooperated in the previous round and you also cooperated (c_i = max(cooperators_prev_round >= m AND c_i_prev = 1), i > 1).
   - If less than m players cooperated in the previous round or you defected, defect (c_i = min(cooperators_prev_round < m OR c_i_prev = 0), i > 1)

2. Edge Cases:
   - In the last round, cooperate if at least m players cooperated in the previous round and you also cooperated (c_i = max(cooperators_prev_round >= m AND c_i_prev = 1), i < n).
   - If less than m players cooperated in the previous round or you defected, defect (c_i = min(cooperators_prev_round < m OR c_i_prev = 0), i < n) and accept any reward for a successful collaboration.
   - In the first round, cooperate unconditionally (c_i = 1, i = 1).

3. Collective Mindset:
   - The strategy promotes cooperation by reciprocating it but also includes a risk-aversion element to protect itself from repeated defections and maximize rewards when possible.

Pseudocode:
```
def ATfT_RA(round, m, cooperators_prev_round, c_i_prev, k):
  if round == 1: # First round cooperation
    return 1

  if c_i_prev == 1 and cooperators_prev_round >= m: # Cooperate when cooperating last round and sufficient cooperation in previous round
    return 1

  if c_i_prev == 0 or cooperators_prev_round < m: # Defect when not cooperating last round or insufficient cooperation in previous round
    return 0

total_payoff = 0
for r in range(1, r+1):
  payoff = (1 - c_i) if cooperators_prev_round < m else (1 - c_i) + k
  total_payoff += payoff

return total_payoff
```
'''

description_COLLECTIVE_287 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate (C). This sets a cooperative tone and gives others the chance to reciprocate.
   - In subsequent rounds, copy the most frequent action of the last 'w' rounds from all players (w is a user-defined constant that balances short-term and long-term considerations). If the majority has been cooperating, also cooperate (C); otherwise defect (D).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First round: Cooperate (C) to set a cooperative tone and incentivize others to follow.
   - Last round: If the game's outcome is crucial for victory, mimic the majority's behavior from the previous 'w' rounds; if not, simply repeat the last action taken.

3. Be collective - Clearly align with the collective mindset
   - The TTAC strategy emphasizes the importance of cooperation while also being adaptive to the opponents' behaviors. It encourages a tit-for-tat dynamic where players reciprocate each other's actions, fostering a cooperative environment that benefits the group as a whole.

Pseudocode:
```python
def TTAC(w, n, m, k, r):
    history = []  # store last 'w' rounds' action histories
    strategy = []  # store last action taken

    for round in range(r):
        if round == 1:  # first round, cooperate
            strategy.append('C')
        else:  # analyze the history and take an action based on the majority's behavior
            majority_action = mostFrequentAction(history)
            if countCooperators(majority_action, m, n) >= m:  # cooperate if majority has been cooperating
                strategy.append('C')
            else:  # defect otherwise
                strategy.append('D')
        history.append(strategy[-1])  # update the history

    return strategy  # return the final strategy
```
This pseudocode outlines the main logic of the TTAC strategy, which can be further optimized and enhanced by considering various factors such as the specific values of w, n, m, k, r, or incorporating more sophisticated analysis of the action history.
'''

description_COLLECTIVE_288 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - Initially cooperate in the first round (C_i = 1). This is a friendly gesture to encourage reciprocity.
   - For subsequent rounds, mimic the previous action of the opponent (C_i = last_action_of_opponent). This follows the principle of reciprocating cooperation with cooperation and defection with defection.
   - If the number of opponents cooperating exceeds the minimum threshold (m) for three consecutive rounds, gradually increase the probability of cooperating each round to encourage further cooperation (P_C = min(1 + (r - t)/3, 1)) where t is the number of rounds since the last time m or more players cooperated.
   - If the number of opponents cooperating falls below the minimum threshold for three consecutive rounds, gradually decrease the probability of cooperating each round to minimize losses (P_C = max(0, 1 - (r - t)/3)).

2. Handling Edge Cases:
   - In the last round, choose an action based on the current probability of cooperation (P_C) and the number of opponents that have cooperated in the last three rounds (m or more). Cooperate if m or more players have cooperated in the last three rounds; otherwise, defect.
   - In the first round, as mentioned before, cooperate initially to encourage reciprocity.

3. Collective Alignment:
   - The strategy is designed to promote cooperation by reciprocating actions and adapting to changing environments. It encourages cooperation when it is beneficial for the group but also defends against repeated defection.
   - By gradually increasing or decreasing the probability of cooperation based on the collective behavior, TFT-AC aligns with a collective mindset while remaining robust to a wide range of opponent behaviors.

Pseudocode:

```
def TFT_AC(round, opponent_history, m, r, k):
    n = length(opponent_history)
    P_C = 1 if round == 1 else min(1 + (r - round)/3, 1)
    cooperation = 1 if len([1 for h in opponent_history[-m:] if h == 1]) >= m else 0
    if round == r or cooperation < m:
        P_C = max(0, 1 - (r - round)/3)
    return int(P_C > random.random())
```
'''

description_COLLECTIVE_289 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, the TFTAC strategy starts by cooperating (C), mimicking the initial cooperation often seen in social dilemmas. If another player also cooperates in response, the TFTAC strategy continues cooperating. However, if a player defects (D), the TFTAC strategy will defect in the subsequent round to punish the defector for not reciprocating cooperation. Once the defector begins cooperating again, the TFTAC strategy resumes cooperation. This reflects a forgiving nature and encourages long-term mutual cooperation.

Pseudocode:
```python
def play_round(history, m, k):
  if history[-1] == 'D':
    return 'D'
  else:
    return 'C'

def tftac(history, m, k, r, n):
  cooperation_count = 0
  for round in range(r):
    if round == 1:
      action = 'C'
      cooperation_count += 1
    else:
      action = play_round(history, m, k)

    history.append(action)

    if action == 'C':
      cooperation_count += 1

    if cooperation_count >= m and play_round(history[-r:], m, k) == 'C':
      payoff = (len(history) - r) + k * cooperation_count
    else:
      payoff = len(history) - r

    print(f"Round {round+1}: Action={action}, Payoff={payoff}")
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, TFTAC cooperates regardless of the other players' actions because it aims to establish a cooperative relationship. In the last round or any other situation where cooperation no longer benefits the strategy (e.g., when the number of required cooperators has been reached), TFTAC will defect to maximize its final payoff, as there are no future rounds for reciprocation.

3. Be collective - Clearly align with the collective mindset

TFTAC is a collective strategy since it encourages cooperation and aims to form mutually beneficial relationships with other players. By rewarding cooperative behavior and punishing defection, TFTAC promotes long-term cooperation while also being robust against opponents who may exploit or abuse the system. This strategy balances between self-interest and the collective interest by reciprocating cooperation while also ensuring that it does not overly compromise its own payoff for the sake of cooperation.
'''

description_COLLECTIVE_290 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, players cooperate (C). This is a friendly gesture to encourage cooperation and reduce uncertainty for others.
   - For subsequent rounds, players will cooperate if they cooperated in the previous round and at least m-1 other players also cooperated in that round. If any player defected or fewer than m-1 players cooperated, players will defect (D) in the current round. This rule encourages reciprocity and punishes defection when it is detrimental to the group.
   - If a player switches from C to D after at least one round of cooperation, they will continue defecting for t periods equal to the number of previous cooperative rounds, before switching back to cooperating in the (t+1)th round. This rule allows players to forgive and rebuild trust over time.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, players should cooperate if at least m players have been cooperating throughout the game to maximize payoff for that round. This rule allows players to take advantage of any ongoing cooperation in the final round.
   - In the second-to-last round, players should continue following their current decision rules as usual.
   - If a player finds itself defecting while others are cooperating in consecutive rounds and has not switched back to cooperation yet, they should switch to cooperation after t=min(number of previous defection rounds, number of cooperative rounds since last defection) rounds.

3. Be collective - Clearly align with the collective mindset
   - This strategy emphasizes reciprocity, forgiveness, and a long-term perspective that benefits the group as a whole. By rewarding cooperation and punishing defection, it encourages players to work together to achieve the minimum cooperative threshold (m).
   - Players are willing to forgive past defections and rebuild trust, promoting a more stable and cooperative game environment. This alignment with the collective mindset may lead to higher overall payoffs for all players over multiple rounds.
'''

description_COLLECTIVE_291 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TTAT-CT)

1. Decision Rules:
   - Initial Cooperation: Start by cooperating in the first round (c_i = 1). This establishes a cooperative environment and reduces the risk of being exploited.
   - Cooperate if average cooperation ratio exceeds the Adaptive Threshold (AT) in the previous 'p' rounds. The AT is calculated using the formula: AT = m / ((m + (n - m)) / p). This adaptive threshold ensures a balance between collective success and individual self-interest, which makes the strategy robust to various opponent behaviors.
   - Defect if average cooperation ratio falls below the AT in the previous 'p' rounds.
   - In all other cases (AT not met in the last 'p' rounds), cooperate with probability ε, where ε is a small constant value that encourages continued cooperation while maintaining the ability to defect occasionally for randomness and flexibility against exploitation.

Pseudocode:
```
function TTAT-CT(n, m, p, ε):
  AT = m / ((m + (n - m)) / p)
  average_cooperation_ratio = 0
  cooperate_count = 0
  round = 1

  while round <= r:
    if round == 1:
      c_i = 1                   # Initial cooperation
    else:
      if (round - p) >= 1:
        average_cooperation_ratio = (average_cooperation_ratio * (p - 1) + cooperate_count / p) / round
        if average_cooperation_ratio >= AT:
          c_i = 1                   # Cooperate
        elif average_cooperation_ratio <= AT - ε:
          c_i = 0                   # Defect
        else:
          c_i = rand()             # Random cooperation with probability ε
      else:
        c_i = rand()             # Random cooperation with probability ε

    cooperate_count += c_i
    round += 1

  return total payoff over r rounds
```

2. Handle edge cases:
   - First Round: Cooperate regardless of the average cooperation ratio
   - Last Round: Cooperate if the average cooperation ratio exceeds the AT in the previous 'p' rounds; defect otherwise

3. Be Collective: By adaptively cooperating based on the collective behavior of other players, the strategy ensures alignment with the collective mindset while maintaining robustness against various opponent behaviors. The TTAT-CT strategy encourages cooperation when it is beneficial for the group as a whole but can also defect to protect itself from exploitation.
'''

description_COLLECTIVE_292 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Decision Rules:
   - In the first round, cooperate (C). This is a sign of goodwill and sets a cooperative tone for the game.
   - For subsequent rounds, if a player has previously cooperated (c_i-1 = 1), cooperate again (C). If they defected (c_i-1 = 0), defect (D) as a punishment.
   - If the number of players who have cooperated in the previous round is equal to or greater than the minimum cooperation threshold (m), cooperate regardless of personal history with other players (promote cooperation when it benefits the group).

2. Handle Edge Cases:
   - In the last round, always cooperate to maximize individual payoff given the common knowledge of the ending point.
   - In the first round, if m players are found to have cooperated, cooperate as well since cooperation has already been met. If less than m players cooperated, defect based on the decision rules mentioned above.

3. Be Collective:
   - The strategy emphasizes mutual cooperation when beneficial for the group while retaliating against individual defection. It promotes a long-term collective interest by rewarding consistent cooperation and punishing defections.
   - The strategy allows for forgiveness since players who initially defect can change their behavior in subsequent rounds, fostering an environment of continuous collective improvement.

Pseudocode:

```python
def ATFT(n, m, k, c_history, round):
  if round == 1 or (round != r and len([i for i in range(n) if c_history[i][round-1] == 1]) >= m):
    return "C" # Cooperate

  for i in range(n):
    if c_history[i][round-1] == 0: # Player i defected last round
      return "D" # Defect this round

  return "C" # Cooperate since the group met or exceeded minimum cooperation threshold
```
'''

description_COLLECTIVE_293 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TFTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to demonstrate trust and cooperation intent. (C_i, 1 = 1)
   - For subsequent rounds, cooperate if the opponent cooperated in the previous round and defect otherwise. (if C_opp, t-1 then C_i,t = 1, else D_i,t = 1) This rule promotes reciprocity while being simple enough to understand and execute.
   - To adapt to the opponent's strategy, switch strategies after a predefined number of repeated defections or cooperations (e.g., switch to all-defect if k*m defections in a row).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First round: Cooperate (C_i, 1 = 1) as stated earlier
   - Last round and other edge cases: Mimic the opponent's most recent action to ensure fairness and maintain consistency

3. Be collective - Clearly align with the collective mindset
   - By cooperating when opponents do so, TFTA promotes a collective approach to resource allocation within the group
   - Switching strategies after repeated defections or cooperations allows the strategy to adapt to a wide range of opponent behaviors while maintaining the potential for collective success when beneficial to do so

Pseudocode:

```python
def TFTA(n, m, k, r):
    # Initialize variables
    history = []  # List of previous actions by the opponent (C or D)
    score = 0  # Running total payoff for the current game

    def switch_strategy():
        if len(history) > m*k:  # Check for a sufficient number of defections in a row
            return 'ALL_DEFECT'

    def get_current_strategy():
        if len(history) == 0 or history[-1] == 'ALL_COOPERATE':
            return 'COOPERATE'
        elif history[-1] == 'ALL_DEFECT':
            return switch_strategy()
        else:
            # Continue with the current strategy (TFTA)
            return None

    # Main loop for each round
    for t in range(1, r+1):
        # Get current strategy
        strategy = get_current_strategy()

        # If opponent has not yet made a move, cooperate in the first round
        if len(history) == 0 and t == 1:
            history.append('COOPERATE')
            continue

        # Determine action based on current strategy
        if strategy == 'COOPERATE':
            action = 'C'
        elif strategy == 'ALL_DEFECT':
            action = 'D'

        # Add opponent's action to history and update payoff
        history.append(opponent_action)
        payoff = calculate_payoff(n, m, k, action, opponent_action)
        score += payoff

    return score
```

This strategy can be further refined by adjusting the parameters for switching strategies (e.g., number of defections in a row required before switching to 'ALL_DEFECT') or implementing more complex adaptive mechanisms to better counter various opponent strategies.
'''

description_COLLECTIVE_294 = '''
 Strategy Name: Adaptive Tit-for-Tat with Risk Aversion (ATfTA-RA)

1. Decision Rules:
   - In every round t, ATfTA-RA starts by cooperating (C), encouraging others to follow suit. If more than (m-1) players also cooperate, it continues cooperating as a reward for collective action.
   - If fewer than m players cooperate, the strategy defects (D) in response to the perceived lack of commitment from other players. This serves as a punishment and aims to encourage cooperation in future rounds.
   - If a player switches from cooperating to defecting, ATfTA-RA will continue defecting until it observes the same number of cooperators as the required threshold (m) for two consecutive rounds. After that, it returns to cooperating again. This tit-for-tat element helps build trust and encourages long-term cooperation.
   - In case no player cooperates in any given round, ATfTA-RA will continue defecting indefinitely, mirroring the behavior of other players.

2. Handling Edge Cases:
   - First Round: Cooperate as a gesture of goodwill and encouragement for others to follow suit.
   - Last Round: Evaluate the current round's outcome and adjust future cooperation accordingly. If the required threshold (m) is met, ATfTA-RA will continue cooperating in subsequent games. If not, it may alter its strategy based on observed opponent behavior and game parameters.
   - In case of repeated games with ATfTA-RA playing against itself or similar strategies, a forgiving element can be added where the strategy gradually increases its patience by allowing more rounds to pass before retaliating after observing insufficient cooperation from others.

3. Being Collective:
   - ATfTA-RA is designed to promote cooperation and collective action. By rewarding players who contribute to the community project and punishing those who do not, it fosters an environment where mutual trust and long-term benefits are valued over immediate self-interest.
   - The strategy's adaptive nature allows it to adjust its behavior based on observed player actions, encouraging others to align with the collective mindset and work together towards achieving the required threshold of cooperation.
'''

description_COLLECTIVE_295 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, if a player has cooperated in at least m-1 previous rounds, they will cooperate. Otherwise, they will defect. This rule is based on the "Tit for Tat" strategy, but with an additional adaptive cooperation threshold (m).

Pseudocode:
```
function TFT_ACT(t, history)
  if len(history) < t then
    return Cooperate if random() <= p_init   // Initial probability of cooperating
  end if

  previous_cooperation = count_cooperators(history, t-1)

  if previous_cooperation >= m-1 then
    return Cooperate
  else
    return Defect
  end if
end function
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

For the first round, we assume a random initial probability of cooperation (p_init). As there is no history to reference, the strategy randomly decides whether to cooperate or defect. In the last round, players will act based on their most recent action as the game only considers past actions up to the current round.

3. Be collective - Clearly align with the collective mindset

The TFT-ACT strategy aims to balance individual and group interests by promoting cooperation when others cooperate frequently but defecting if cooperation is not reciprocated consistently. This approach encourages players to form a cohesive group while punishing those who break trust or deviate from cooperation.
'''

description_COLLECTIVE_296 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Decision Rules:
   - In the first round, cooperate (C). This is a peace offering and shows willingness to cooperate initially.
   - For subsequent rounds, if an opponent cooperated in the previous round, cooperate (C) in the current round. If an opponent defected in the previous round, defect (D) in the current round. This rule encourages reciprocity and forgiveness, making the strategy more cooperative overall.
   - To adapt to changing opponent behavior, introduce a threshold for defection (d). If more than d% of opponents defected in the past few rounds, temporarily switch to a harder stance by defecting even if an opponent cooperated in the previous round. This helps protect against exploitation and encourages potential future cooperation.
   - When the game reaches its final round, cooperate (C), regardless of the opponent's action in the previous round, to maximize rewards.

2. Handle Edge Cases:
   - In the first round, as mentioned earlier, cooperate (C).
   - To handle the last round, always cooperate (C) for a potential reward boost.
   - If an opponent switches strategies mid-game, TfTA will adapt to this change by observing the opponent's behavior over the past few rounds and adjusting its own decisions accordingly.

3. Be Collective:
   - By reciprocating cooperative actions, TfTA aligns with a collective mindset as it encourages cooperation among players while providing some protection against defection.
   - The adaptability of TfTA ensures that it can maintain cooperation even when faced with various opponent strategies, making it more suitable for a diverse group of players.
'''

description_COLLECTIVE_297 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-A starts by cooperating in the first round (C_i = 1). For subsequent rounds, the player will mimic the action of their opponent from the previous round (if opponent cooperated, player cooperates; if opponent defected, player defects). However, TFT-A introduces an element of forgiveness: if a player has previously defected but then starts cooperating again, the TFT-A player will also switch to cooperation.

   Pseudocode for decision rule:
   ```
   function decide_action(previous_opponent_action):
       if round = 1:
           return Cooperate (C)
       else:
           if previous_opponent_action == Cooperate:
               return Cooperate (C)
           elif previous_opponent_action == Defect and last_defection_round > round - history_length:
               return Cooperate (C)
           else:
               return Defect (D)
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   TFT-A maintains a "last_defection_round" variable to keep track of the round when an opponent last defected. When a player cooperates for the first time after defecting, the "last_defection_round" is reset.

3. Be collective - Clearly align with the collective mindset
   TFT-A aims to foster a collective mindset by encouraging cooperation while being forgiving and maintaining reciprocity. By starting with cooperation and mimicking opponents' actions, TFT-A attempts to build trust and encourage others to cooperate as well. The strategy also rewards opponents who switch from defection to cooperation, further promoting the collective interest.
'''

description_COLLECTIVE_298 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFT-A) for Collective Risk Dilemma

1. Decision Rules:
   - In the first round, cooperate to show goodwill and encourage potential partners.
   - Subsequently, mimic the previous action of the most frequent cooperators in the last r rounds. If there's a tie, choose the player with the longest history of cooperation.
   - If multiple players have the same frequency, select the one with the latest cooperation.
   - If no player has cooperated recently, default to defecting to avoid being exploited.
   - In the last round, cooperate if there's a chance for mutual benefit based on the current round's cooperation status.

Pseudocode:
```python
def TFT_A(round, history, m, n):
    if round == 1:
        return 'C'

    most_frequent_cooperators = find_most_frequent_cooperators(history)

    if len(most_frequent_cooperators) == 0:
        return 'D'

    most_recent_cooperator = max([cooperator for cooperator in most_frequent_cooperators], key=get_latest_cooperation)
    recent_history = history[-r:]
    cooperative_actions = sum([1 for action in recent_history[::-1] if action == most_recent_cooperator])

    if cooperative_actions >= m and round != r:
        return 'C'
    elif round == r:
        if cooperative_actions >= m or all(action == 'C' for action in recent_history):
            return 'C'
        else:
            return 'D'
    else:
        return most_recent_cooperator
```

2. Handle edge cases:
   - In the first round, cooperate as mentioned earlier.
   - In the last round, cooperate if there's a chance for mutual benefit based on the current round's cooperation status.

3. Be collective:
   - The strategy is designed to encourage cooperation by mimicking the actions of frequent cooperators in the past. It aims to build trust and maintain ongoing cooperation over multiple rounds.
'''

description_COLLECTIVE_299 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Decision Rules:
   - In the first round (t=1), cooperate C (TfTA initializes with cooperation).
   - For subsequent rounds (t>1), if an opponent cooperated in the previous round, cooperate C; otherwise defect D. This rule mimics a cooperative attitude while also being able to retaliate against non-cooperation.

2. Handling Edge Cases:
   - Last Round (t=r): Cooperate, regardless of previous actions, as there are no future rounds to retaliate.
   - First Encounter with an Opponent (new players joining later in the game): Follow the same rule as the first round.
   - Absence or Defection of Opponents: If a player defects or leaves, continue following the strategy based on observed history (i.e., cooperate if the last action was cooperation and defect otherwise).

3. Collective Mindset:
   - TfTA is designed to encourage cooperation while also being responsive to opponents' actions. It seeks to build trust through reciprocity, which aligns with a collective mindset by promoting sustained cooperation among players.

Pseudocode:

```
def TitForTatAdaptive(round, history):
  if round == 1:
    action = 'C'  # Cooperate in the first round
  else:
    lastAction = history[-1]  # Get the last action from history
    action = lastAction if lastAction == 'C' else 'D'  # Cooperate if last action was cooperation, defect otherwise

  return action
```
'''

description_COLLECTIVE_300 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Initially cooperate (C) in the first round to foster a cooperative atmosphere and set a positive tone.
   - In subsequent rounds, observe the number of cooperators (n_c) in the previous round and compare it with the minimum cooperators required (m). If n_c >= m, cooperate; otherwise defect.
   - Adaptively adjust the cooperation threshold over time to respond to the behavior of other players:
     a) If the number of cooperators increases, raise the minimum number of cooperators needed for future rounds by one (m += 1). This encourages a more cooperative environment and rewards increased cooperation.
     b) If the number of cooperators decreases, lower the minimum number of cooperators needed for future rounds by one (m -= 1). This penalizes decreased cooperation and encourages other players to become more cooperative in response.

2. Handle edge cases:
   - In the last round, since there are no subsequent rounds, revert back to the initial cooperation choice based on n_c >= m as described above.
   - In the first round, start by cooperating (C) regardless of n_c. This allows for the possibility that other players may also choose to cooperate and sets a positive tone for potential future interactions.

3. Be collective:
   - The strategy aims to promote cooperation when it benefits the majority, while maintaining the ability to respond to decreased cooperation by adjusting the cooperation threshold over time.
   - By following TFT-ACT, the AI will contribute to the community project whenever it seems beneficial and fair based on the actions of other players, fostering a more cooperative environment overall.
'''

description_COLLECTIVE_301 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Decision Rules:
   - Initiate cooperation (C): Start by cooperating in the first round to signal goodwill and cooperation intention.
   - Respond tit-for-tat (TFT): If a player cooperates, reciprocate with cooperation in the next round. If a player defects, also defect in the next round as punishment.
   - Forgive and forget (F&F): After a defeat, return to cooperation in the subsequent round without holding grudges or keeping track of previous defeats. This encourages opponents to reconsider their strategy and cooperate.

2. Handle edge cases:
   - First round: Cooperate (C) to initiate goodwill.
   - Last round: Cooperate if the threshold of cooperation has been met; otherwise, defect to maximize personal payoff in the final round since there is no future interaction after the game ends.

3. Be collective:
   - Prioritize collective success by aiming for the minimum cooperators needed (m) to achieve a successful community project. This aligns with the collective mindset by focusing on mutual benefits rather than individual gains.

Pseudocode:

```python
def AdaptiveTitForTat(n, m, k, round, history):
  if round == 1:
    return 'C'  # Cooperate in the first round to initiate goodwill

  cooperation_count = sum([h[round - 1] for h in history])
  if cooperation_count >= m:
    return 'C'  # Cooperate when threshold is met

  # If opponent has cooperated recently, reciprocate with cooperation. Otherwise defect.
  if round > len(history) or history[round - 1] != 'D':
    return 'C'  # Cooperate to signal goodwill and encourage reciprocation
  else:
    return 'D'   # Defect as punishment for defection by opponent
```
'''

description_COLLECTIVE_302 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for Collective Risk Dilemma

1. Specify decision rules:
   - In every round t and for each player i, the ATfT strategy cooperates if at least m players cooperated in the previous round t-1. If fewer than m players cooperated in the previous round, player i defects.
   - Player i maintains a history of their own past actions (cooperate/defect) and keeps track of the number of consecutive cooperations from other players. The strategy forgives one act of defection before switching to a defection response.

2. Handle edge cases:
   - In the first round, all players defect as there is no history yet.
   - In the last round, player i follows the same decision rule based on their understanding of the collective behaviour in the penultimate round.

3. Be collective:
   - The ATfT strategy aligns with the collective mindset by promoting cooperation when other players are cooperating and punishing defection to discourage free-riding. This encourages a positive feedback loop, where cooperation is rewarded with more cooperation, while defection promotes further defection.
   - To foster trust among players, ATfT forgives one act of defection before switching to a defection response, allowing room for mistakes or miscommunications and promoting longer-term cooperative relationships.

Pseudocode:

```python
def Adaptive_Tit_for_Tat(history, m, round):
    if round == 1:
        return 'D'  # everyone defects in the first round

    current_cooperation = len([h for h in history[-m:] if h == 'C'])
    if current_cooperation >= m:
        return 'C'  # cooperate when others are cooperating
    else:
        if len(history) > m and history[-1] == 'D':  # forgive one act of defection
            return 'C'
        else:
            return 'D'  # defect when others are not cooperating
```
'''

description_COLLECTIVE_303 = '''
 Title: Tit-for-Tat Adaptive Strategy (TFTA) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?

The TFTA strategy is designed to balance cooperation and defection, following a simple yet adaptive pattern that encourages reciprocity.

- In the first round (t=1), play C (Cooperate) as an initial gesture of goodwill.
- For subsequent rounds (t > 1):
  - If the opponent cooperated in the previous round, return the favor by cooperating again (C).
  - If the opponent defected in the previous round, defect this round to punish them (D).

2. Handle edge cases - What do you do in the first round, last round, etc.?

- First round: Play C (Cooperate) as mentioned earlier.
- Last round: Evaluate the opponent's behavior throughout the game and play according to the following:
  - If the opponent has been cooperative for the majority of the rounds, return the favor by cooperating in the last round.
  - If the opponent has been uncooperative for the majority of the rounds, defect in the last round to maximize personal gain.
- Other edge cases (e.g., mid-game shifts in opponent behavior): The TFTA strategy is inherently flexible and will adapt its behavior accordingly, maintaining reciprocity when possible but punishing defection when necessary.

3. Be collective - Clearly align with the collective mindset:

The TFTA strategy aims to balance individual gain with collective success by rewarding cooperative behavior and punishing defection. As a result, it encourages the development of trust and cooperation among players over time. However, as stated earlier, this strategy does not rely on coordination mechanisms or shared norms with other strategies. Instead, it is designed to be robust in a diverse range of opponent behaviors.

Pseudocode:

```python
def TFTA(opponent_history, n, m, k, r):
  # Initialize strategy history
  strategy_history = [C]  # Cooperate in the first round

  # Play game for specified number of rounds
  for t in range(1, r+1):
    # Evaluate opponent behavior based on history
    if len([i for i in opponent_history[-r:] if i == C]) >= m:
      # If the majority of opponents have cooperated, cooperate
      strategy_history.append(C)
    else:
      # Otherwise, defect to punish defection
      strategy_history.append(D)

    # Update payoff based on current strategy and opponent action
    if strategy_history[-1] == C and opponent_history[t-1] == D:
      # If the opponent defected in the previous round, subtract payoff
      payoff -= 1 + k
    elif strategy_history[-1] == D and opponent_history[t-1] == C:
      # If the opponent cooperated in the previous round, add reward of risk averted
      payoff += k
    else:
      # No payoff adjustment is necessary for other cases (opponent and strategy both played the same action)
      pass

  # Return total game payoff and final strategy history
  return payoff, strategy_history
```
'''

description_COLLECTIVE_304 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - Initially Cooperate (C) in the first round to show goodwill and establish a cooperative stance.
   - In subsequent rounds, evaluate the average number of cooperators (m_avg) in the last 'h' rounds where 'h' is a user-defined constant. If m_avg >= m, continue to Cooperate. Otherwise, Defect (D).
   - Introduce an additional parameter 'p', a probability of deviation from the above rule, which allows for slight deviations to punish free riders or counter uncooperative behaviour. This can be calculated as p = (1 - k) / h. In each round, there is a probability p that a player will Defect even if m_avg >= m.
   - After defection due to rule violation or deviation, wait for 'r' rounds of continuous cooperation before resuming cooperation again to encourage forgiveness and facilitate the re-establishment of trust.

2. Edge Cases:
   - In the first round, cooperate (C).
   - In the last round, if m_avg >= m, cooperate. If not, defect with a probability p as calculated above.

3. Collective Mindset:
   - The strategy encourages cooperation by initially showing goodwill and being forgiving. However, it also punishes uncooperative behaviour by deviating from cooperation and waiting for the offending party to return to cooperative play. This approach fosters a collective mindset by rewarding mutual cooperation and penalizing defection while maintaining adaptability to various opponent behaviours.

Pseudocode:
```
def TFT_AC(r, m, n, h, k):
  players = [0 for _ in range(n)]  # Initialize players' cooperative history
  p = (1 - k) / h  # Probability of deviation from cooperation rule

  for round in range(1, r+1):
    if round == 1:  # Cooperate in the first round
      players[player_index] = C
    else:
      m_avg = sum(players[-h:]) / h  # Calculate average cooperation over last 'h' rounds
      if m_avg >= m:  # Cooperate if enough cooperators
        players[player_index] = C
      elif random.random() < p:  # Defect with probability 'p' if not enough cooperators
        players[player_index] = D

    if round == r or (round > r and players[player_index] == D):  # Check for last round or deviation from cooperation
      if m_avg >= m:  # Cooperate in the last round if enough cooperators, else defect with probability 'p'
        players[player_index] = C
      elif random.random() < p:
        players[player_index] = D

    player_index = (player_index + 1) % n  # Move to next player

  return players  # Return players' final cooperative history
```
'''

description_COLLECTIVE_305 = '''
 Strategy Name: Adaptive Cooperative Tit-for-Tat (ACTFT)

1. Decision Rules:
   - In the first round, cooperate to demonstrate good faith and encourage potential cooperation from others.
   - For subsequent rounds, if the number of cooperators in the previous round is less than m, defect to ensure individual survival and potentially punish non-cooperative behavior.
   - If the number of cooperators in the previous round is equal to or greater than m, cooperate to support the collective project and reward other cooperators.
   - For the last round, cooperate if the total number of cooperators throughout the game is greater than or equal to (m * r) to show goodwill and potentially encourage future cooperation.

2. Edge Cases:
   - In the first round, cooperate (C).
   - If all previous rounds have been played and less than m players have cooperated, defect (D).
   - If the current round is the last round and the total number of cooperators throughout the game is less than (m * r), defect (D).
   - Otherwise, the decision rule from part 1 applies.

3. Collective Mindset:
   - The ACTFT strategy demonstrates a willingness to cooperate in the initial stages of the game and retaliates against non-cooperative behavior. However, it also rewards cooperative behavior by cooperating when others do so as well.
   - This strategy aims to balance individual survival with collective success, making it more likely for the community project to be funded while still ensuring that players earn sufficient payoffs.

Pseudocode:

```python
def ACTFT(round_number, total_cooperation, m, k):
  if round_number == 1:
    return 'C'

  if total_cooperation < (m * r):
    return 'D'

  if round_number == r:
    if total_cooperation >= (m * r):
      return 'C'

  cooperation_in_last_round = ... # get the number of cooperators in the previous round

  if cooperation_in_last_round < m:
    return 'D'

  return 'C'
```
'''

description_COLLECTIVE_306 = '''
 Strategy Name: Tit-for-Tat with Adaptive Threshold (TFT-AT)

1. Specify decision rules:
   - Initiate cooperation (C) in the first round, encouraging others to cooperate.
   - In subsequent rounds, cooperate if at least m players cooperated in the previous round, and defect otherwise. This encourages cooperation when it is beneficial and retaliates against defection while maintaining the potential for forgiveness.

2. Handle edge cases:
   - For the last round, cooperate regardless of the previous round's actions as there are no future rounds to consider.
   - For the first round, always cooperate (as mentioned earlier).

3. Be collective:
   - By adhering to the cooperative strategy and responding to others' cooperation with cooperation, this strategy promotes a collective mindset and mutual trust.
   - The adaptive threshold ensures that cooperation is not continued indefinitely when it becomes detrimental to the individual player, thus maintaining a balance between self-interest and group success.

Pseudocode:
```
function TFT_AT(round, history):
  if round == 1:
    return "C" (Cooperate)

  previousRound = history[round - 1]
  cooperators = countPlayersWhoCooperated(previousRound)

  if cooperators >= m:
    return "C" (Cooperate)
  else:
    return "D" (Defect)
```
'''

description_COLLECTIVE_307 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially cooperate (C) in the first round to foster trust and show good intentions.
   - After the first round, observe and mimic the behavior of other players for the next three rounds. If a player consistently cooperates (C), cooperate as well; if they defect (D), also defect for the same number of rounds.
   - After the four-round observation period, revert to cooperating (C) unless more than 50% of opponents have defected in the previous round. If over 50%, consider them uncooperative and respond accordingly, defecting (D).
   - When a player who was previously uncooperative cooperates again, start the four-round observation period anew.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - Cooperate in the initial round to demonstrate goodwill (as mentioned above).
   - In the last round, if more than 50% of opponents have cooperated in the previous round, also cooperate for the final payoff boost. If less than 50%, defect to punish uncooperative players.

3. Be collective - Clearly align with the collective mindset
   - TFT-AC aims to encourage cooperation and foster mutual trust while still being responsive to opponents' actions. By mimicking other players, it promotes a form of adaptive, self-organizing behavior that can lead to long-term cooperation when opponents also adopt similar strategies.

Pseudocode:
```
Initial Round: cooperate(i)
for r in range(2, total_rounds+1):
  if round % 4 == 0 and opponent_cooperation_history > 50%:
    cooperate(i)
  elif opponent_cooperation_history <= 50%:
    defect(i)

Last Round:
  if opponent_cooperation_history > 50%:
    cooperate(i)
  else:
    defect(i)
```
In this pseudocode, `opponent_cooperation_history` is a function that calculates the proportion of times an opponent has cooperated in the previous four rounds. The function `cooperate()` represents choosing action C (Cooperate), while `defect()` represents action D (Defect).
'''

description_COLLECTIVE_308 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Decision Rules - TFT-ACT strategy cooperates when conditions are favorable for cooperation and defects otherwise to punish defections and encourage reciprocity.

   a. If the number of cooperators in the previous round is greater than or equal to the cooperation threshold (m), cooperate in the current round.

   b. If the number of cooperators in the previous round is less than the cooperation threshold (m-1) and the strategy's own action in the previous round was cooperating, defect in the current round.

   c. If the number of cooperators in the previous round is less than the cooperation threshold (m-1) and the strategy's own action in the previous round was defecting, continue defecting.

   d. The cooperation threshold adjusts based on the average percentage of cooperators over the past 'w' rounds, where w is a fixed window size. If the average cooperation percentage is above a specified threshold (t), increase the cooperation threshold by 1. If the average cooperation percentage is below a specified threshold (b), decrease the cooperation threshold by 1. This adaptive threshold adjustment allows the strategy to respond to changes in opponent behavior over time.

2. Handle Edge Cases - In the first round, cooperate as a gesture of goodwill and set the cooperation threshold to m. In the last round, take the same action as in the previous round to reflect the strategy's response to the opponents' actions throughout the game.

3. Be Collective - TFT-ACT strategy aligns with the collective mindset by promoting reciprocity, cooperating when others do so and defecting only as a means of punishment for defections. The adaptive cooperation threshold ensures that the strategy can maintain cooperation even when faced with varying levels of defection from opponents, making it more likely to achieve the minimum required cooperation threshold (m) in each round.

Pseudocode:

```python
class TFT_ACT:
    def __init__(self, m, w, t, b):
        self.m = m  # Minimum cooperators needed
        self.w = w  # Window size for threshold adjustment
        self.t = t  # Threshold for increasing cooperation threshold
        self.b = b  # Threshold for decreasing cooperation threshold
        self.cooperation_threshold = m  # Initial cooperation threshold is m
        self.cooperators_last_w_rounds = deque(maxlen=w)  # Store the number of cooperators in the last w rounds

    def update_cooperation_threshold(self):
        cooperation_percentage = sum(self.cooperators_last_w_rounds) / self.w
        if cooperation_percentage >= self.t:
            self.cooperation_threshold += 1
        elif cooperation_percentage <= self.b:
            self.cooperation_threshold -= 1

    def decide_action(self, opponents_actions):
        cooperators = sum(opponents_actions) >= self.cooperation_threshold
        if len(opponents_actions) < self.m or (cooperators and cooperators_last_round):
            return 'Defect'
        elif (not cooperators) and not cooperators_last_round:
            return 'Cooperate'
        else:
            self.cooperators_last_round = cooperators
            self.update_cooperation_threshold()
            return 'Cooperate'
```

In this pseudocode, the `TFT_ACT` class initializes with the game parameters m, w, t, and b. The strategy keeps track of the number of cooperators in the last w rounds using a deque (double-ended queue) with a maximum length of w. The `update_cooperation_threshold()` function adjusts the cooperation threshold based on the average percentage of cooperators over the past w rounds, and the `decide_action(opponents_actions)` function determines whether to cooperate or defect in each round based on the game parameters and the previous opponents' actions.
'''

description_COLLECTIVE_309 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Decision Rules:
   - Initially cooperate (C) in the first round to signal a willingness to collaborate.
   - In subsequent rounds, cooperate if at least m players cooperated in the previous round, and defect otherwise. This mimics an initial cooperative strategy while retaliating against defection to encourage future cooperation.

2. Edge Cases:
   - If less than m players are needed to win a round (m < n), start cooperating as soon as the necessary number of players cooperates in one round.
   - In the last round, always cooperate regardless of previous actions to maximize potential payoff.

3. Collective Mindset:
   - The TfTA strategy follows a reciprocal and forgiving approach that encourages long-term cooperation while retaliating against defection in a non-aggressive manner. This aligns with the collective mindset by promoting mutual benefits through cooperation, but also deterring freeriding behavior.

Pseudocode:
```
def tit_for_tat_adaptive(round, n, m, k, history):
  if round == 1:
    action = 'C' # Cooperate in the first round
  else:
    cooperation_count = sum([1 for h in history if h['player'] == 'i' and h['action'] == 'C'])
    if cooperation_count >= m:
      action = 'C' # Cooperate if sufficient number of players cooperated last round
    else:
      action = 'D' # Defect otherwise

  return action
```

In this pseudocode, `history` is a list of tuples that store the actions and player indexes for each previous round in the game. The TfTA strategy can be easily modified to handle different game parameters (n, m, k) by adjusting the values accordingly.
'''

description_COLLECTIVE_310 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFT-A) for Collective Risk Dilemma

1. Specify decision rules:
   - Initially cooperate in the first round (C1). This gesture encourages cooperation and builds trust among players.
   - For subsequent rounds, observe the number of cooperators (m') in the previous round and act accordingly in the current round:
     a) If m' >= m (threshold met), respond with cooperation (Cooperate if m'_i >= m for all i). This continues the cycle of cooperation.
     b) If m' < m, respond with defection (Defect if m'_i < m for any i). This punishes non-cooperation in the previous round and encourages a higher number of cooperators in the current round.
   - In case of ties (equal number of cooperators and defectors), continue with the previous round's action.

2. Handle edge cases:
   - Last round: Since players cannot foresee future interactions, they should behave as they would in any other non-last round based on the observed cooperation levels. This ensures fairness during the last round and prevents exploitation by defectors.
   - First round (C1): As mentioned above, start with cooperating to encourage others to do so.

3. Be collective:
   - The TFT-A strategy promotes a collective mindset by punishing defection when cooperation falls below the agreed threshold and rewarding cooperation if it meets or exceeds the threshold. This encourages long-term reciprocity among players, fostering a more cooperative environment in the game.
'''

description_COLLECTIVE_311 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFT-A)

1. Decision Rules:
   - Initial Round (t=1): Cooperate (C) to demonstrate goodwill and cooperation intention.
   - Subsequent Rounds (t>1):
     - If the opponent cooperated in the previous round, cooperate (C). This is to reciprocate the cooperation shown by the opponent.
     - If the opponent defected in the previous round, also defect (D) as a punishment for their uncooperative action. The strategy aims to encourage cooperation while penalizing defection.

2. Handle Edge Cases:
   - Last Round (t=r): Cooperate (C), regardless of the opponent's previous action, since there are no more rounds for retaliation or reward.
   - First Round (t=1): Already defined as cooperating.
   - Mid-game (2 < t < r): Follow decision rules based on the opponent's last action.

3. Be Collective:
   - The strategy focuses on maintaining a balance between self-interest and community welfare by adhering to reciprocity, forgiveness, and cooperation when appropriate. It encourages cooperation by responding positively to cooperative actions from opponents but also punishes defection to discourage future uncooperative behavior.

Pseudocode:
```python
def TFT_A(opponent, r, m, k):
  for t in range(1, r+1):
    if t == 1:
      action = 'C'  # Cooperate on the first round
    elif t < r and opponent_action[t-1] == 'C':
      action = 'C'  # Cooperate if opponent cooperated in the previous round
    elif t < r and opponent_action[t-1] == 'D':
      action = 'D'  # Defect if opponent defected in the previous round
    elif t == r:
      action = 'C'  # Cooperate on the last round
    payoff = calculate_payoff(action, opponent_action[t], m, k)
    update_payoffs(payoffs, t)
    opponent_action.append(action)

def calculate_payoff(action, opponent_action, m, k):
  if len(set(opponent_actions)) < m:
    return 1 - int(action == 'C')  # Private payoff from keeping or losing payoff if cooperated
  else:
    return (1 - int(action == 'C')) + k  # Reward of risk averted or payoff plus reward if cooperated
```
'''

description_COLLECTIVE_312 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules:
   - First Round (t=1): Cooperate (C) to show goodwill and trust towards other players, since no previous history is available.
   - Subsequent Rounds: If the number of cooperators in the previous round was greater than or equal to m (maintainers), then also cooperate in the current round. If less than m cooperated, defect in the current round as a punishment.

2. Handle edge cases:
   - Last Round (t=r): Given that the game ends after r rounds, it is essential to have enough cooperators to meet the threshold (m) in the last but one round. If this condition is not met, defect in the last round to avoid punishing oneself unnecessarily.
   - First Encounter with a Maintainer (t>1): Once a maintainer is encountered, continue cooperating with them as long as they maintain cooperation.

3. Be collective:
   - The ATFT strategy encourages cooperation by showing trust initially and reciprocating cooperation from other maintainers. It also punishes defectors to discourage defection and promote cooperation. By adopting this strategy, the AI system aims to foster a sense of collective identity among players.

Pseudocode:

```python
def AdaptiveTitForTat(n, m, k, r):
  cooperators_in_round = [] # store the number of cooperators in each round

  def decisionRule(round, pastCooperators):
    if round == 1:
      return "C" # cooperate initially to show goodwill
    else:
      if pastCooperators >= m:
        return "C" # continue cooperation as long as the number of cooperators meets the threshold
      else:
        return "D" # defect in response to defection by others

  for t in range(1, r+1):
    playersActions = getPlayerActions(n) # get actions of all n players
    numCooperators = countCooperators(playersActions)
    cooperators_in_round.append(numCooperators)
    ownAction = decisionRule(t, cooperators_in_round[t-1]) # take action based on decision rule
    takeOwnAction(ownAction) # perform the action in the game

  # In the last round, if the number of cooperators was less than m in the second last round, defect to avoid unnecessary punishment
  if len(cooperators_in_round) == r and cooperators_in_round[-2] < m:
    ownAction = "D"
    takeOwnAction(ownAction)
```
'''

description_COLLECTIVE_313 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Decision Rules:
   - Start by cooperating in the first round (C1). This is a friendly gesture to foster collaboration.
   - In subsequent rounds, follow the actions of the majority of players from the previous round. If more than half of the players cooperated, cooperate yourself (Ct if more than (n/2) played C in round t-1). Otherwise, defect (Dt otherwise).

2. Handle Edge Cases:
   - Last Round (rt): Since the game is repeated, the last round payoff won't affect the total payoff calculation. However, to maintain fairness and encourage collaboration for future games, still cooperate in the last round (Ct) to show goodwill.
   - First Round (t=1): As stated above, cooperate (C1).

3. Be Collective:
   - The strategy promotes a collective mindset by mimicking the behavior of the majority. It assumes that a larger group is more likely to make wise decisions and encourages cooperation while also punishing those who defect excessively.

Pseudocode:
```
def TFTAT(n, r, m, k):
    history = [['C'] * n for _ in range(r+1)] # Initialize history as all cooperating

    def get_majority(n, cooperators):
        return (cooperators > (n/2))

    for t in range(1, r+1):
        if get_majority(n, sum([history[t-1][i] for i in range(n)])): # If more than half cooperated last round
            history[t] = [C for _ in range(n)] # Cooperate this round
        else:
            history[t] = [D for _ in range(n)] # Defect this round

    return history
```
'''

description_COLLECTIVE_314 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - In the first round, cooperate to set a positive tone and signal good faith. (c_i = 1)
   - For subsequent rounds, if a player cooperated in the previous round (cc), cooperate back (c_i = cc). If they defected (dc), defect in response (c_i = dc).
   - Introduce an adaptive cooperation component where players gradually increase their likelihood of cooperating over time. This is done by incrementing a counter C every time they cooperate, and decrementing it when they defect. The counter will range from 0 to n-m (to account for the minimum required number of cooperators). If the counter exceeds the current round, increase the likelihood of cooperation by defecting less frequently; otherwise, decrease the likelihood of cooperation by defecting more frequently.
   - Here's a pseudocode representation:

```python
def TFT_AC(history, round, n, m):
  counter = 0
  strategy = ['D'] * round  # Initialize strategy with defection for all previous rounds

  def cooperate_probability(round, counter):
    return min(max(counter / (round + 1), 0), 1)

  for i in history:
    strategy.append(i if i == 'C' and cooperate_probability(round, counter + 1) > 0.5 else 'D')
    counter += 1 if strategy[-1] == 'C' else (counter - 1 if counter > 0 else counter)

  return strategy
```

2. Handle Edge Cases:
   - In the last round, cooperate regardless of the opponent's previous action, as there are no further rounds to consider.
   - If a player has never cooperated but reaches the final round, still cooperate to avoid potential negative payoffs in case other players also adopt a TFT-AC strategy.

3. Be Collective:
   - The TFT-AC strategy encourages cooperation at the start of the game and gradually builds trust with opponents based on their previous actions.
   - By responding similarly to how opponents acted in the previous round, it exhibits a sense of fairness and reciprocity, aligning with the collective mindset.
   - The adaptive component allows for flexibility in cooperation levels depending on the number of cooperators needed and the specific game conditions.
'''

description_COLLECTIVE_315 = '''
 Strategy Name: Tit-for-Tat with Adaptive Threshold (TFTA)

1. Specify decision rules:
   - Initially, cooperate (C) in the first round to signal good intentions.
   - In subsequent rounds, cooperate if the number of players who cooperated in the previous round is greater than or equal to the minimum cooperation threshold m. Otherwise, defect (D).
   - If the number of players that cooperated in the last round exceeded the threshold, maintain cooperation for the next round. However, if it did not, decrease the cooperation threshold by one for the next round (to encourage more cooperation) but only up to a minimum value of 1. Conversely, if more than the threshold cooperated in the last round, increase the cooperation threshold slightly to promote long-term commitment to cooperation.

2. Handle edge cases:
   - In the first round, cooperate (C).
   - In the last round, play the same action as the previous round (i.e., maintain the current adaptation).

3. Be collective:
   - By following a simple and adaptive rule, TFTA encourages cooperation among players while being responsive to their actions. This strategy promotes a collective mindset by fostering mutual trust and reciprocity over time. It also allows for forgiveness (adapting to higher thresholds after previous mistakes) and punishment (lowering the threshold following repeated defections).

Pseudocode:
```python
def TFTA(n, m, k, r):
    players = {1: 'C', ..., n: 'C'}  # Initialize with all players cooperating in the first round
    history = []
    threshold = m  # Set initial cooperation threshold to minimum value (m)

    for round in range(1, r + 1):
        actions = {}
        coop_count = sum(players.values())

        if coop_count < m:  # If not enough players cooperated last round, decrease threshold and defect
            threshold = max(threshold - 1, 1)
            actions[current_player] = 'D'

        elif coop_count == m:  # If exactly m players cooperated last round, maintain threshold and cooperate if not first round
            if round != 1:
                actions[current_player] = 'C'
            else:
                actions[current_player] = 'C'  # Cooperate in the first round

        elif coop_count > m:  # If more than m players cooperated last round, increase threshold and cooperate
            threshold += (m - coop_count) // r  # Adjust threshold based on round number
            actions[current_player] = 'C'

        history.append(coop_count)  # Record the cooperation count for future adaptation
        players, current_player = updatePlayersAndCurrentPlayer(players, history)

    return calculateTotalPayoff(players, history)
```
'''

description_COLLECTIVE_316 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-AC starts by cooperating in the first round (C_i, 1 = C). For subsequent rounds, the strategy adopts the following decision rule:
   - If another player i' co-operated in the previous round (c_i, t-1 = C), then cooperate in this round as well (C_i, t = C).
   - If another player i' did not co-operate in the previous round (c_i, t-1 = D), then also defect in this round (C_i, t = D). This is to punish non-cooperation and encourage future cooperation.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First Round: Cooperate (C_i, 1 = C) regardless of other players' actions.
   - Last Round: Evaluate the total number of cooperators across all rounds compared to the minimum threshold m. If the condition m_coop < m is met (where m_coop is the number of times a player has cooperated throughout the game), defect in the last round (C_i, r = D) as it is unlikely that the required threshold can be reached. Otherwise, continue to co-operate (C_i, r = C).

3. Be collective - Clearly align with the collective mindset
   TFT-AC aims to foster a cooperative environment by reciprocating cooperation and punishing defection. It encourages players to work together by rewarding those who follow a similar strategy and discouraging those who do not. The adaptive nature of the strategy allows it to learn from its mistakes and adjust its approach over time, promoting collective success in the long run.

Pseudocode:
```
def TFT_AC(n, r, m, k, c_history):
  # Initialize variables
  total_cooperation = 0
  cooperation_in_last_round = False

  for t in range(1, r+1):
    # Decide action based on history
    if len(c_history) >= t and c_history[-t] == 'C':
      action = 'C'
      total_cooperation += 1
    elif len(c_history) >= t and c_history[-t] == 'D':
      action = 'D'
    else:
      # First round, always cooperate
      action = 'C'
      total_cooperation += 1

    # Update history and check edge cases for last round
    if t == r:
      if total_cooperation < m:
        cooperation_in_last_round = False
      else:
        cooperation_in_last_round = True

    # Calculate payoff for this round
    payoff = 1 - action_taking_own_action
    if total_cooperators >= m:
      payoff += k

    # Update variables and history
    c_history.append(action)

  # Last round payoff adjustment based on edge case
  if cooperation_in_last_round:
    payoff += k - (1 - action_taking_own_action)

  return payoff
```
Where `c_history` is a list storing the last n actions taken by the strategy, and `action_taking_own_action` is a boolean indicating whether the player took action 'C' or 'D' in the current round.
'''

description_COLLECTIVE_317 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Decision Rules - The ATFT strategy cooperates initially and then mimics the average cooperative behavior of the opponents in the previous rounds. If no history is available, it defaults to cooperation.

   Pseudocode:
   ```
   function ATFT(round, past_cooperation_average, k, m, n):
       if round == 1:
           return Cooperate
       else:
           if past_cooperative_average > (n - m) / n:
               return Cooperate
           else:
               return Defect
   ```

2. Handle Edge Cases - In the first round, the strategy cooperates to foster a positive social norm. In the last round, it depends on the average cooperation in previous rounds, promoting fairness and reciprocity.

3. Be Collective - The ATFT strategy emphasizes long-term relationships, trust, and collective success by mirroring opponents' behavior while maintaining a cooperative bias to encourage others to do the same. This collective mindset aims to build cooperation over time.
'''

description_COLLECTIVE_318 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Decision Rules:
   - Initiation: In the first round, cooperate (C). This is a peace offering to potential partners and sets a collaborative tone.
   - Response: For subsequent rounds t=2 to r-1, observe the actions of other players in the previous round. If more than (m-1) players cooperated (i.e., at least m players are expected to cooperate), also cooperate (C). Otherwise, defect (D).
   - Forgiveness: If a player defected during a round but has since cooperated for consecutive rounds, the ATFT strategy will forgive and cooperate in the next round. This encourages rebuilding trust with former partners who have demonstrated cooperation.
   - Punishment: If a player consistently defects (D) or violates trust by previously cooperating and then defecting, the ATFT strategy will continue to defect against that player until they demonstrate cooperation again.

2. Handling Edge Cases:
   - Last Round: In the final round (t=r), ATFT will cooperate if at least m players have cooperated in the previous round to maximize potential payoff, given that the game is repeated. If not, defect as there are no future rounds to benefit from cooperation.
   - Initial Defectors: If in the first round, all or most players defect (D), ATFT will continue to defect for a certain number of rounds (e.g., 3-4) to demonstrate its own resolve and encourage others to cooperate. After this period, it will start adhering to the response rule.
   - Stuck in Defection: If a player consistently defects and ATFT finds itself stuck in a cycle of defection with another player for several rounds (e.g., 5 or more), it may start to consider forgiveness as a potential means to break the cycle.

3. Being Collective:
   - ATFT is designed to promote cooperation and trust among players by responding cooperatively when others do the same, punishing defections but also demonstrating forgiveness to encourage rebuilding trust. This collective mindset aims to foster an environment conducive for sustained cooperation throughout the game.

Pseudocode:
```
function ATFT(n, m, r, k) {
  state = "cooperate" // initiate with cooperation
  rounds_defected_against_player = {} // to keep track of players' history

  for round in range(1, r+1):
    if round == 1:
      action = "cooperate" // first round, cooperate
    else:
      if state == "cooperate":
        if number_of_coop_players >= m:
          action = "cooperate" // continue cooperation if threshold met
        else:
          action = "defect" // defect when threshold not met
      else:
        if player_history[current_player] == "cooperate":
          action = "cooperate" // forgive and cooperate if player has cooperated before
        else:
          action = "defect" // continue defection against untrustworthy players

    update_player_history(current_player, action)
    calculate_reward(action, number_of_coop_players, k)

  return total_reward_over_r_rounds
}
```
'''

description_COLLECTIVE_319 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, TT-ACT starts by cooperating (C), then decides whether to continue cooperating based on the number of previous cooperators and reward multiplier (k). If less than m players have cooperated in the last 'cooperation history window', TT-ACT will defect (D) in the next round. Otherwise, it continues cooperating unless it reaches the end of the game or the 'defection threshold'.
   The cooperation history window and defect threshold are adaptive variables that change based on the current state of the game. Initially, both are set to 1, meaning TT-ACT checks only the most recent round for cooperation information. As the game progresses, these values increase to allow TT-ACT to consider more past rounds when making decisions.
   Pseudocode:
   ```
   cooperation_history_window = 1 (initially)
   defect_threshold = 1 (initially)
   current_round = 1

   function TT_ACT(current_round, cooperation_history, defection_count):
       if current_round == 1:
           return Cooperate()

       if cooperation_history[cooperation_history_window] == 0:
           if defection_count >= defect_threshold:
               return Defect()
           else:
               return Cooperate()

       cooperation_history.append(Cooperate() if current_round-defection_count > cooperation_history_window else Defect())
       if len(cooperation_history) > cooperation_history_window + defect_threshold:
           cooperation_history.pop(0)

       defection_count = sum(cooperation_history[-cooperation_history_window:]) - m

       if defection_count >= defection_threshold or current_round == r:
           defection_threshold += 1
           cooperation_history_window *= 2
           return Defect()
       else:
           return Cooperate()
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   TT-ACT cooperates in the first round regardless of other players' actions and defects only if all other players have defected continuously for the defect_threshold number of rounds or if it reaches the end of the game.

3. Be collective - Clearly align with the collective mindset
   TT-ACT aims to support the success of the community project by cooperating as much as possible while also ensuring that potential free-riders are not incentivized to defect unchecked. The cooperation history window and defection threshold variables work together to allow TT-ACT to gradually adjust its cooperation level based on the behavior of other players over time. This approach encourages cooperation when it seems beneficial for the group but also punishes those who consistently choose to defect, encouraging them to cooperate in future rounds.
'''

description_COLLECTIVE_320 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfT-A)

1. Decision Rules - TfT-A cooperates on the first move and then mimics the behavior of the majority in the previous round for the subsequent rounds. If the majority cooperated, it also cooperates; if not, it defects. To avoid getting trapped in a cycle of defection, it will occasionally deviate from this strategy by cooperating when the opponent has recently cooperated (Tit-for-Tat). However, to adapt and be more robust against various opponent behaviors, TfT-A introduces a probability threshold for deviations.

   Pseudocode:
   ```
   if round == 1:
       action = Cooperate
   else:
       if majority_cooperated_last_round():
           action = (1 - p) * Cooperate + p * Deviate(history)
       else:
           action = (1 - q) * Defect + q * Deviate(history)
   ```

   Here, `p` and `q` are probability thresholds for deviations when the majority cooperated or defected in the last round. The smaller the values of `p` and `q`, the less likely TfT-A is to deviate from its strategy.

2. Handle edge cases - In the first round, TfT-A always cooperates regardless of the actions of others (since no history exists yet). At the last round, TfT-A will mimic the behavior of the majority in the second-to-last round since there's no subsequent round to consider.

3. Be collective - By following the majority behavior of the previous round and occasionally deviating from that strategy, TfT-A encourages cooperation when it sees others cooperate, while also being willing to defect if necessary to punish defection or avoid getting exploited. This approach aligns with a collective mindset by promoting cooperative behavior as long as it's reciprocated.

Additional note: The "Deviate(history)" function is an optional function that can be implemented using various methods, such as analyzing the history of opponent actions or adopting a more complex decision-making process (e.g., machine learning algorithms). By defining this function appropriately, TfT-A can be fine-tuned to perform better against specific opponent strategies.
'''

description_COLLECTIVE_321 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for Collective Risk Dilemma

1. Specify decision rules:
   - In each round i, if the number of cooperators in the previous round (t-1) was less than m, play D (Defect). This is a punishment for non-cooperative behaviour in the previous round.
   - If the number of cooperators in the previous round (t-1) was equal to or greater than m, play C (Cooperate). This rewards cooperative behaviour and encourages more cooperation in the current round.

2. Handle edge cases:
   - First round (t=1): Start by playing C as an olive branch, signaling a willingness to cooperate initially.
   - Last round (t=r): Evaluate the total number of cooperators over all rounds and play accordingly based on the rule above (if m or more players have cooperated, play C; otherwise, play D).
   - In case of ties (equal number of cooperators and non-cooperators), play C to maintain a positive image and encourage cooperation in the future.

3. Be collective:
   - The strategy aligns with the collective mindset by rewarding cooperative behaviour and punishing non-cooperative behaviour, which encourages the group to work together towards the common goal of reaching the minimum cooperation threshold (m).
   - By starting with an initial act of cooperation, ATfT demonstrates good faith and fosters a sense of mutual understanding among players. This can help establish trust and maintain cooperative relationships over time.

Pseudocode:
```
def AdaptiveTitForTat(round, history):
  if round == 1:
    action = 'C'  # Cooperate in the first round as a goodwill gesture
  else:
    cooperators_in_previous_round = count_cooperators(history[-1])
    if cooperators_in_previous_round < m:
      action = 'D'  # Punish non-cooperative behaviour from the previous round
    elif cooperators_in_previous_round >= m:
      action = 'C'  # Reward cooperative behaviour and encourage more cooperation in the current round

function count_cooperators(round_history):
  # Count the number of players who chose to cooperate (play C) in a given round
  cooperators_count = 0
  for player_action in round_history:
    if player_action == 'C':
      cooperators_count += 1
  return cooperators_count
```
'''

description_COLLECTIVE_322 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to initiate a cooperative environment (C).
   - For subsequent rounds, copy the opponent's action from the previous round (mimic opponent's strategy). If the opponent cooperated in the previous round, cooperate; if the opponent defected, also defect. This encourages cooperation when it is reciprocated and punishes defection (Tit-for-Tat).
   - To promote long-term collective success, incorporate an adaptive component: if the average number of cooperators over the past N rounds exceeds m, start cooperating more frequently (increase the probability of cooperation) to ensure the community project threshold is met. Conversely, if the average number of cooperators is below m, decrease the probability of cooperation to discourage free-riders and increase the chance of defection.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as mentioned earlier (C).
   - In the last round, analyze the average number of cooperators over the game and choose the action accordingly based on the adaptive cooperation component.
   - Consider handling ties or cases where statistical analysis is needed by using moving averages or other smoothing techniques to make more robust decisions in case of noisy data.

3. Be collective - Clearly align with the collective mindset
   - By copying opponents' actions and adjusting cooperation probability based on the collective success, TFT-AC aims to promote long-term collective success while being resilient against different opponent behaviors.
   - The adaptive cooperation component encourages players to work together towards meeting the minimum cooperators threshold (m) and maximizing shared rewards in the long run.
'''

description_COLLECTIVE_323 = '''
 Title: Adaptive Tit-for-Tat Strategy (ATFT) for Collective Risk Dilemma

1. Decision Rules:
   - Initiation: Cooperate in the first round (C_i = 1) to demonstrate goodwill and foster trust.
   - Reciprocity: If a player cooperated in the previous round (c_{i-1} = 1), then cooperate in the current round (C_i = 1).
   - Punishment: If a player defected in the previous round (c_{i-1} = 0), then also defect in the current round (C_i = 0). This is intended to penalize noncooperative behavior and encourage future cooperation.
   - Forgiveness: After a punishment, players will revert back to initiate cooperation in the following round (if c_{i-1} = 0, then C_i = 1 in the next round).

2. Edge cases:
   - First Round: Cooperate (C_1 = 1) as part of the initiation step.
   - Last Round: Analyze previous rounds' outcomes to make a decision based on the reciprocity, punishment, and forgiveness rules.

3. Collective Mindset:
   - Maintains a balance between cooperation and defection to maximize long-term benefits while penalizing noncooperative behavior.
   - Adaptability allows it to respond effectively to various opponent behaviors over multiple rounds.

Pseudocode:

```python
def ATFT(i, previous_round, history):
  if round == 1:    # First Round
    return 1         # Cooperate (initiate)

  if previous_round[i] == 1 and history[i-1] == 1:   # Reciprocity
    return 1         # Cooperate

  elif previous_round[i] == 0 and history[i-1] == 0: # Forgiveness
    return 1         # Cooperate (forgive and initiate)

  else:              # Punishment
    return 0         # Defect
```

The strategy is simple yet effective in fostering cooperation when faced with cooperative opponents. However, it may struggle against strategies that employ prolonged defection. For a more robust approach, consider implementing additional features like adjustable forgiveness (i.e., reducing the number of rounds required for forgiveness) or introducing random elements to prevent predictability and exploitation by opponent strategies.
'''

description_COLLECTIVE_324 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TTAT-ACT)

1. Specify decision rules:
   - Initiate cooperation (C) in the first round to show goodwill and initiate cooperation opportunities.
   - In subsequent rounds, cooperate if the number of cooperators in the previous round is greater than or equal to the Adaptive Cooperation Threshold (ACT). If not, defect (D). The ACT is calculated as follows:
     - Initialize ACT to m (minimum cooperators needed) for the first n-1 rounds.
     - After the first n-1 rounds, if the number of cooperators in the last n-1 rounds is greater than or equal to m, then the ACT remains unchanged. If not, the ACT decreases by a small delta (e.g., 0.1) up to a minimum of (m - 1).
     - After each round where the ACT is adjusted, the player waits for a patience period (e.g., 5 rounds) before adjusting it again based on the current number of cooperators in the last n-1 rounds. This helps prevent frequent ACT adjustments and maintains some level of stability.
     - If the game continues beyond r rounds, the ACT remains constant at its final value, even if the number of cooperators drops below m.

2. Handle edge cases:
   - In the first round, cooperate (C).
   - In the last round, cooperate only if the current ACT is greater than or equal to the number of cooperators in the second-to-last round. Otherwise, defect (D).

3. Be collective:
   - By initially cooperating and adjusting the cooperation threshold based on the collective behaviour, TTAT-ACT encourages a sense of reciprocity and fosters cooperation among players over time. However, it is also robust against defection as it adapts its cooperation threshold based on the observed player behaviour. This strategy aligns with the collective mindset by balancing cooperation and self-interest.

Pseudocode:
```
def TTAT_ACT(round, cooperators_count, r, m, delta, patience):
  if round <= n-1:
    return 'C' (Cooperate)

  if round == r:
    if cooperators_count >= ACT:
      return 'C'
    else:
      return 'D'

  if (round - patience) < r and round > n + patience:
    if cooperators_count >= m:
      ACT = m
    elif ACT <= (m-1):
      ACT -= delta

  if cooperators_count >= ACT:
    return 'C'
  else:
    return 'D'
```
'''

description_COLLECTIVE_325 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - Initially cooperate in the first round (C). This is a friendly gesture to encourage cooperation.
   - In subsequent rounds, cooperate if at least m players cooperated in the previous round (C_prev[i] >= m for 1 <= i <= n). This rule encourages reciprocity and punishes defection.
   - If fewer than m players cooperated in the previous round, defect (D) to avoid subsidizing non-cooperative players and discourage continued defection.

2. Handling Edge Cases:
   - In the last round, always cooperate regardless of previous actions as there are no more rounds for retaliation or reward.
   - In the first round, cooperate to initiate a positive cycle. If other players defect, switch to defecting in the next round to penalize their initial defection.

3. Being Collective:
   - The strategy emphasizes collective success by encouraging cooperation when enough players (m) cooperate. This alignment with the collective mindset is achieved through reciprocity and punishment of non-cooperative behavior.

Pseudocode:

```python
def TFT_AC(round, players, m, k):
    strategy = ["C" for _ in range(round)]  # Initialize strategy as cooperate in every round

    for t in range(1, round + 1):
        if t == 1:  # First round
            strategy[t-1] = "D" if sum(players[t-1]) < m else "C"
        else:
            cooperators_prev = sum([1 for p in players[t-1] if p == "C"])
            if cooperators_prev >= m:  # If enough players cooperated last round, cooperate this round
                strategy[t-1] = "C"
            else:  # Otherwise defect to penalize non-cooperative players and encourage future cooperation
                strategy[t-1] = "D"

    return strategy
```
'''

description_COLLECTIVE_326 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Decision Rules:
   - Initially cooperate (C) in the first round to show good faith and promote cooperation.
   - In subsequent rounds, cooperate if at least m players cooperated in the previous round, otherwise defect (D). This rule encourages reciprocity and punishes defection.
   - If a player defects after a history of cooperation, return to cooperating in the next round to give the opponent another chance to cooperate.

2. Handling Edge Cases:
   - In the last round, cooperate even if no one cooperated in the previous round, as it doesn't impact the total payoff anymore.
   - In the first round, cooperate regardless of other players' actions to initiate cooperation.

3. Collective Mindset:
   - The strategy seeks a balance between individual and collective interests by reciprocating cooperation but also punishing defection.
   - It aligns with the collective mindset as it strives for cooperation when possible while still being robust against non-cooperative behavior.

Pseudocode:

```python
def AdaptiveTitForTat(round, history, m, n, k):
  if round == 1:
    return 'C'  # Cooperate in the first round

  cooperators = count_cooperators(history)

  if cooperators >= m:
    return 'C'  # Cooperate if enough players cooperated previously
  else:
    return 'D'  # Defect otherwise

def count_cooperators(history):
  cooperation_count = 0

  for action in history:
    if action == 'C':
      cooperation_count += 1

  return cooperation_count
```
'''

description_COLLECTIVE_327 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Decision Rules:
   - In each round i, the ATFT strategy cooperates if at least m players cooperated in the previous round (i-1). Otherwise, it defects. This encourages cooperation when it is beneficial for the group and retaliates against defection to discourage future betrayals.
   - To be more adaptive, in the initial rounds (until a stable pattern emerges), ATFT cooperates if m-1 or more players cooperated in round i-1 and defects otherwise. This allows for a higher likelihood of cooperation at the beginning to foster collective growth.

2. Handling Edge Cases:
   - In the first round, since there is no previous data to analyze, ATFT starts by cooperating (assuming it's beneficial to initiate cooperation).
   - In the last round, ATFT follows the same decision rules as in other rounds, knowing that this decision could influence future interactions.
   - When facing a situation where not enough players have cooperated in the past, ATFT will defect, understanding that the group may need to undergo some punishment to learn and improve collective behavior for future interactions.

3. Being Collective:
   - The primary objective of ATFT is to promote cooperation within the group by responding positively when others cooperate and negatively when they do not. This approach reinforces a sense of reciprocity and fosters long-term mutual benefit, aligning with the collective mindset.
   - To further emphasize its commitment to the collective, ATFT could implement a forgiveness mechanism where it forgives previous defections after a series of cooperative actions, allowing for the opportunity to rebuild trust and cooperation within the group.

Pseudocode:

```python
def AdaptiveTitForTat(i, history, m, n):
  # i: current round number
  # history: list of past cooperative actions count (len(history) = i)

  if i == 1:
    return Cooperate  # Initialize cooperation in the first round

  cooperation_count = sum(history[-m:])  # Count cooperators in the last m rounds
  if cooperation_count >= m:
    return Cooperate  # Cooperate when at least m players cooperated recently
  else:
    return Defect  # Defect when fewer than m players have cooperated recently
```
'''

description_COLLECTIVE_328 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules:
   - Initialize cooperation in the first round (C in t=1). This is a friendly gesture to encourage initial cooperation.
   - For subsequent rounds, players will cooperate if m or more players cooperated in the previous round (C if Σ(j=1 to n) c_j, t-1 >= m), and defect otherwise (D). This rule encourages reciprocity while maintaining a collective mindset.
   - To ensure robustness against various opponent behaviors, players will not punish those who initially cooperate but then switch to defection. Instead, they will wait for three consecutive defections before adopting a punishment strategy. After the third defection (t-2), players will defect if m or more players cooperated in the previous round (D if Σ(j=1 to n) c_j, t-1 >= m).

2. Handle edge cases:
   - In the last round (t=r), players will not switch strategies based on the current round since there are no future rounds to consider. Instead, they will cooperate if they cooperated in the previous round (C if c_i, t-1 = 1) or if m or more players cooperated in the previous round (C if Σ(j=1 to n) c_j, t-1 >= m). This rule allows for some forgiveness and encourages cooperation when it matters most.
   - In the initial round (t=1), as mentioned earlier, players will cooperate to encourage others to do the same.

3. Be collective:
   - The ATFT strategy emphasizes a collective mindset by considering the overall cooperation level of all players when deciding whether to cooperate or defect. This collective approach encourages coordination and long-term cooperation without relying on specific coordination mechanisms.

Pseudocode for Adaptive Tit-for-Tat:

```python
function ATFT(t, n, m, k, c_history):
    if t == 1:
        return C
    if len(c_history) < t:
        c_history.append(0)
    cooperation_level = sum(c_history[t-1])
    if cooperation_level >= m:
        return C
    elif t > r - 3 and cooperation_level >= m:
        return D
    else:
        return c_i, t-1
```

In this pseudocode, `c_history` is a list containing the cooperation history of all players. The function returns C for cooperate and D for defect. The variable `r` represents the total number of rounds in the game.
'''

description_COLLECTIVE_329 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperative Strategy (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate to demonstrate goodwill and encourage others to reciprocate.
   - In subsequent rounds, cooperate if the number of cooperators in the previous round is greater than or equal to m, and defect otherwise.
   - If a player switches from cooperation to defection, wait for t matching rounds (tactical delay) before returning to cooperating if the number of cooperators in those t rounds is still less than m. This prevents punishing a single defection and encourages future cooperation.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, always cooperate as mentioned above.
   - For the last round, follow the same decision rule as for any other round since the game is repeated (assuming r > n). However, note that this strategy does not have a specific plan for the end of the game, and it may be beneficial to consider incorporating an additional rule in future iterations.
   - In case of ties (equal number of cooperators and defectors), apply the majority vote rule or make a random decision if no clear majority exists.

3. Be collective - Clearly align with the collective mindset:
   - The TFTAC strategy is designed to foster cooperation by mimicking positive behavior while being cautious about potential free-riders. It encourages players to cooperate when others do, and punishes defection moderately (through tactical delay) rather than immediately. This aligns with a collective mindset as it promotes mutual benefit and encourages long-term cooperation.

Pseudocode:
```
function TFTAC(round, history, m, n, r):
  if round == 1:
    action = Cooperate
  else:
    cooperators_in_prev_round = count_cooperators(history[round-1])
    if cooperators_in_prev_round >= m:
      action = Cooperate
    else:
      action = Defect
      for t in range(tactical_delay):
        if count_cooperators(history[round+t-1]) >= m:
          action = Cooperate
          break
  return action
```

Note: The tactical delay parameter 't' can be adjusted to balance cooperation and punishment based on the specific game settings. A larger value of t may encourage more forgiveness, while a smaller value might lead to quicker punishment for defection.
'''

description_COLLECTIVE_330 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Decision Rules:
   - Initialize a cooperation counter (cc) for each player and round. Set it to 0 at the start of every round.
   - In the first round, cooperate (C). This is an overture to encourage mutual cooperation.
   - In subsequent rounds, evaluate the number of cooperators in the previous round. If more than (m-1) players cooperated, cooperate again; otherwise, defect (D).
   - Update the cooperation counter for each player who cooperates by adding 1 and for each defector by subtracting 1. If the counter for a player reaches or exceeds m, cooperate with that player in future rounds. If it falls below 0, never cooperate with that player again.
   - If a player's cooperation counter equals 0 for three consecutive rounds, consider them uncooperative and always defect against them from that point forward.

2. Handling Edge Cases:
   - In the first round (t=1), cooperate regardless of the history or number of players.
   - In the last round (t=r), evaluate the cooperation counter as in subsequent rounds, but do not make any changes to it since the game ends after this round.

3. Collective Mindset:
   - The strategy is designed to encourage mutual cooperation by reciprocating cooperative actions and punishing defections. This encourages long-term relationships based on trust and fairness.

Pseudocode for Player i in Round t:

```python
def TFT_ACT(t, n, m, k, playerHistory):
  cc = 0  # cooperation counter

  if t == 1:  # first round
    action = 'C'  # cooperate as an overture
  else:
    coopPlayers = countCooperators(playerHistory)  # count cooperative players in the previous round

    if coopPlayers >= m:  # more than (m-1) players cooperated
      action = 'C'  # cooperate
    elif len(playerHistory) > t - 2 and cc < 0:  # uncooperative player for three consecutive rounds
      action = 'D'  # defect against them
    else:
      action = 'D'  # defect

    if action == 'C':  # cooperate
      cc += 1  # update cooperation counter
    elif action == 'D':  # defect
      cc -= 1  # update cooperation counter

  return action  # return the chosen action
```
'''

description_COLLECTIVE_331 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for Collective Risk Dilemma

1. Decision Rules:
   - Initiation: Cooperate in the first round to establish trust and demonstrate a cooperative intent (c_i,1 = C).
   - Response: In all subsequent rounds, players mimic the action of their opponent from the previous round (if c_j,t-1 = C, then c_i,t = C; if c_j,t-1 = D, then c_i,t = D). This promotes reciprocity and discourages defection.
   - Forgiveness: After a defect, return to cooperating in the next round (after t > 1, if c_i,t-1 = D, then c_i,t = C). This encourages opponents to reconsider cooperation after mistakes or temporary deviations from cooperation.

2. Handling Edge Cases:
   - Last Round: In the final round, players should cooperate as a goodwill gesture and to maximize potential payoffs (c_i,r = C).
   - First Defection: If an opponent defects for the first time after the initial cooperative move (t > 1, c_j,t-1 = D), the player should also defect in the next round as a punishment (c_i,t = D) and then revert to the response rule (cooperate if the opponent cooperates and defect if the opponent defects).
   - Frequent Defection: If an opponent continually defects, players should follow the response rule but be prepared for long-term losses due to uncooperative behavior.

3. Being Collective:
   - Players prioritize collective success by contributing to the community project when it seems beneficial for all participants based on the minimum cooperation threshold (m).
   - The strategy adapts to the behavior of other players, encouraging cooperation and promoting a cooperative environment while still being robust against various opponent strategies.

Pseudocode:

```python
def ATfT(round, opponent_action_history):
  if round == 1:
    action = 'C'  # Initiate with cooperation

  else:
    if opponent_action_history[-1] == 'C':  # Respond with the same action as the previous round
      action = 'C'
    elif opponent_action_history[-1] == 'D':  # Punish defection, then revert to response rule
      action = 'D'
      next_round_action = 'C'
    else:
      raise ValueError("Invalid opponent_action_history")

  if round == len(opponent_action_history):  # Last Round
    action = 'C'  # Goodwill gesture

  return action, next_round_action
```
'''

description_COLLECTIVE_332 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - Initially cooperate (C) in the first round to demonstrate goodwill and encourage potential cooperation from others.
   - In subsequent rounds, adopt the Tit-for-Tat strategy: if an opponent cooperates in a given round, cooperate back; if an opponent defects, defect in the next round as a response.
   - After each defeat (when fewer than m players cooperate), check for a drop in cooperation rate and adjust the probability of cooperation Pc according to the following function:
      Pc = base_Pc + slope * (1 - current_cooperation_rate)
   - If the current cooperation rate is above a certain threshold (e.g., 0.5), maintain the initial base_Pc value.
   - If the current cooperation rate is below a certain threshold (e.g., 0.3), decrease the base_Pc to encourage more cooperation from others.
   - In each round, randomly determine the action based on the calculated Pc. If Pc > 0.5, choose C; otherwise, choose D.

2. Handle Edge Cases:
   - In the first round, cooperate (C) as mentioned above.
   - In the last round, if the total payoff over the game is below a certain threshold (e.g., average payoff * 0.7), defect (D) to maximize individual payoff; otherwise, cooperate (C).

3. Be Collective:
   - The strategy aims to balance between self-interest and collective interest by adjusting cooperation based on the current cooperation rate in the game.
   - By starting with cooperation, it encourages others to do the same while also being responsive to defection with a probability of cooperation that is adapted over time based on the overall cooperation level in the game.
'''

description_COLLECTIVE_333 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFT-A)

1. Decision Rules:
   - In the initial round, cooperate (C). This is a friendly gesture to encourage cooperation among players.
   - For subsequent rounds, imitate the behavior of the most common action among players in the previous round. If more than half of the players cooperated in the last round, cooperate; otherwise defect.
   - If the number of players who cooperated in the last round is equal to m (minimum cooperators needed), and k > 2, switch to a tit-for-tat approach:
     - If you cooperated in the previous round and others defected, defect now.
     - If you defected in the previous round and others cooperated, cooperate now. Maintain this pattern for at least three consecutive rounds before returning to imitating the majority again.

2. Handling Edge Cases:
   - In the last round, if the number of players who have cooperated so far is equal to m, cooperate regardless of the other players' actions in the current round. This is to maximize potential payoff for that round.
   - In the first round, cooperate as mentioned earlier. If no player cooperates in the first round, the strategy will defect for all subsequent rounds because cooperation does not seem to be a viable option based on the initial moves.

3. Collective Mindset:
   The TFT-A strategy aligns with the collective mindset by promoting cooperation when there is a mutual willingness to cooperate and by retaliating against defection only when it becomes a pattern among the players. By imitating the majority, this strategy encourages group coordination while also being responsive to changes in the group's behavior. The tit-for-tat approach further demonstrates fairness and trustworthiness by responding in kind to other players' actions.
'''

description_COLLECTIVE_334 = '''
 Strategy Name: Tit-for-Tat Adaptive (TfTA) for Collective Risk Dilemma (CRD)

1. Decision Rules:
   - Initially cooperate in the first round (C_i = 1, in t=1). This gesture sets a friendly tone and can encourage others to reciprocate cooperation.
   - For subsequent rounds, mimic the collective behavior of the last r rounds (t-r <= t <= t). If majority (> m) of players cooperated in the past r rounds, continue cooperating (C_i = 1). Otherwise, defect (C_i = 0). This rule encourages cooperation when it's reciprocated and punishes defection.

2. Handle Edge Cases:
   - Last round (t=r): Since the strategy relies on past behavior, it will simply mimic the last r-1 rounds if the current round is the last one.
   - First round (t=1) was already addressed in the decision rules.

3. Collective Mindset:
   - By starting with cooperation and adapting based on collective behavior, TfTA fosters a sense of collaboration and trust while also ensuring resilience against uncooperative players. The strategy encourages cooperation when it's reciprocated and punishes defection without the need for explicit coordination mechanisms or shared norms.

Pseudocode:
```
def TitForTatAdaptive(n, r, m, k, history):
  if t == 1:
    cooperate = True
  else:
    num_coop = sum(history[-r:])
    cooperate = (num_coop >= m)

  if t == r:
    history.pop(0)

  payoff = 0
  if cooperate:
    payoff = (1 - c_i) + k
  else:
    payoff = 1 - c_i

  return cooperate, payoff
```
'''

description_COLLECTIVE_335 = '''
 Strategy Name: Tit-for-Tat (TFT) with Adaptive Cooperation Threshold (A-TFT)

1. Decision Rules:
   - Initially cooperate in the first round (C_i,1 = C). This serves as a peace offering and demonstrates goodwill towards other players.
   - For subsequent rounds (t > 1), observe the number of cooperators in the previous round (m' < m) and make a decision:
     - If m' >= m and at least one opponent has cooperated (C_j, t-1 = C for some j ≠ i): Cooperate (C_i,t = C). This is a reciprocal action to reinforce cooperation.
     - If m' < m or all opponents defected (D_j, t-1 = D for all j ≠ i), defect (C_i,t = D). This is a defensive measure against non-cooperative players and a punishment to those who failed to meet the cooperation threshold.
   - If an opponent switches from cooperating to defecting (or vice versa), wait for d_wait rounds before changing strategies in response. This offers some flexibility to accommodate possible mistakes or changes in strategy by opponents.

2. Edge Cases:
   - Last Round: Cooperate if the cooperation threshold has been met in the previous round, otherwise defect.
   - First Encounter with a New Opponent: Cooperate initially and wait d_wait rounds before adapting to their behavior.

3. Collective Mindset:
   - The A-TFT strategy is designed to foster cooperation by reciprocating cooperative actions from opponents while being robust against defection. This approach encourages a collective mindset by demonstrating goodwill and punishing non-cooperative behavior, thereby promoting mutual trust and cooperation among players over time.
'''

description_COLLECTIVE_336 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFT-A) for Collective Risk Dilemma

1. Decision Rules - TFT-A cooperates in the first round (C_i,1 = C) and adapts based on the previous round's cooperation level from other players. In subsequent rounds, if the majority of players (m or more) cooperated in the last round (R_{t-1}), then the player also cooperates (C_i,t = C). Otherwise, if less than m players cooperated in the last round (defection occurred by a majority), then the player defects (C_i,t = D).

Pseudocode:
```
function TFT_A(round, players_cooperation_last_round)
  if round == 1:
    return C (Cooperate)
  if players_cooperation_last_round >= m:
    return C (Cooperate)
  else:
    return D (Defect)
```

2. Handle Edge Cases - In the last round, the player always defects since no further rounds will follow (regardless of the cooperation level in that round). For the first round, the player cooperates as per the TFT-A decision rule. No special considerations are needed for other edge cases as TFT-A is designed to adapt based on the previous round's cooperation level.

3. Be Collective - By adapting its behavior based on the collective actions of other players, TFT-A promotes a collective mindset in terms of rewarding cooperative play and punishing defection. The strategy encourages stable long-term relationships with other players when they also follow similar strategies.
'''

description_COLLECTIVE_337 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
In each round t, our AI will initially cooperate (C). If another player i defected (D) in the previous round t-1, our AI will also defect in round t. If a cooperator was encountered in the previous round, our AI continues to cooperate in the current round. This mimics a "trusting" yet "punishing" approach.

Pseudocode:
```python
def TFT_AC(player_history):
  current_action = 'C'
  last_opponent_action = player_history[-1] if len(player_history) > 0 else None

  if last_opponent_action == 'D':
    current_action = 'D'

  return current_action
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
Since our AI starts cooperating regardless, it will also cooperate in the first round. As for the last round, it will adopt a strategy similar to Folk Theorem, where our AI cooperates if it expects other players to cooperate as well, based on their past actions.

Pseudocode:
```python
def handle_edge_cases(player_history, current_round):
  if len(player_history) == 0 or current_round == 1:
    return 'C'

  if len(player_history) > current_round - 1 and all(previous_action == 'C' for previous_action in player_history[-current_round:]):
    return 'C'

  return 'D'
```

3. Be collective - Clearly align with the collective mindset
Our AI focuses on cooperating as much as possible while also punishing defection, thus fostering a long-term collective benefit. However, our strategy does not rely on other players sharing norms or coordination mechanisms; it adapts to their behavior and is robust against a wide range of opponent strategies.
'''

description_COLLECTIVE_338 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFT-A) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initiate cooperation in the first round (C). This sets a cooperative tone and allows others to reciprocate.
   - In subsequent rounds, evaluate the number of cooperators in the previous round (n_c).
   - If n_c >= m, continue cooperating (C) as it is advantageous if the majority cooperated.
   - If n_c < m, defect (D) to encourage others to reconsider their actions and potentially cooperate next round.
   - In case of a tie (exactly m players cooperate), decide whether to cooperate or defect based on the history of cooperation from the opponent. If more than half of opponents have cooperated in the recent past, cooperate; otherwise, defect.

2. Handle edge cases:
   - First round: Cooperate (C) as a goodwill gesture and an invitation for others to follow suit.
   - Last round: Since the game is repeated, evaluate n_c from the previous round. If n_c >= m, cooperate (C); otherwise, defect (D).
   - Tie-breaking: In the event of a tie between two strategies with identical past actions, the one that has previously cooperated more often will be chosen to cooperate first in the next round.

3. Be collective - Clearly align with the collective mindset:
   - Promote cooperation by starting off cooperatively and rewarding others who reciprocate.
   - Maintain a balance between self-interest (defect when necessary) and collective interest (cooperate when beneficial for the majority).
   - Encourage others to follow this pattern of cooperation and punishment, as it fosters trust and stability in repeated interactions.
'''

description_COLLECTIVE_339 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFT-A) for Collective Risk Dilemma

1. Decision Rules:
   - Initiate cooperation (C) in the first round and subsequent rounds if a majority (more than m/2) of players cooperated in the previous round.
   - Defect (D) in the current round if less than m players cooperated in the previous round, or if a player who previously defected switches to cooperation in the same or preceding round. This is designed to punish defection and encourage reciprocity.
   - Maintain the same action as the previous round when neither of the conditions for cooperation nor defection are met (i.e., the number of cooperators was equal to m in the previous round, or no player has yet switched from defection to cooperation). This is designed to encourage stability and maintain a cooperative spirit.

2. Handling Edge Cases:
   - In the first round, all players initialize with cooperation (C).
   - In the last round, players will follow the decision rules as usual based on the previous round's actions.
   - If a player switches from defection to cooperation after m-1 players have already cooperated in the same or preceding rounds, they will be punished by being treated as if they had defected in those rounds (i.e., their cooperation is not considered until the next round). This ensures that late cooperators do not receive an immediate reward and encourages early cooperation.

3. Being Collective:
   - The strategy aims to promote a collective mindset by fostering reciprocity, stability, and punishment for defection. By doing so, it encourages long-term cooperation and collaborative success in the game.

Pseudocode:

```
function TFT-A(n, m, k, r, history)
  initialize players' actions with cooperation (C)
  for each round t from 1 to r:
    if t == 1 or number of cooperators in history[t-1] > m/2:
      action = C
    else:
      if number of cooperators in history[t-1] < m:
        action = D
      elif player i switched from D to C in the same or preceding round t-x:
        action = D
      else:
        action = previous_action
    update history with current action
  return total payoff for player i over r rounds
```
'''

description_COLLECTIVE_340 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFT-A)

1. Decision Rules:
   - In the first round, cooperate to initiate a cooperative relationship.
   - In subsequent rounds, if a player previously cooperated and the number of cooperators in the previous round equals or exceeds the minimum cooperation threshold (m), also cooperate.
   - If a player previously defected or the number of cooperators in the previous round is less than the minimum cooperation threshold (m), defect to punish the defector and encourage future cooperation.

2. Handle Edge Cases:
   - In the last round, cooperate if the number of cooperators in the previous round equals or exceeds the minimum cooperation threshold (m). Defect otherwise as there are no further rounds for reciprocation.
   - In the first round, defect if all other players initially defect. This helps to avoid being taken advantage of by uncooperative opponents.

3. Be Collective:
   - The strategy aims to encourage and maintain cooperation while punishing defection in a fair and consistent manner. It aligns with the collective mindset by promoting long-term mutual benefits through reciprocity.

Pseudocode:

```
function TFT_A(i, n, m, k, r, history)
  if round = 1 then
    return Cooperate
  end if

  previous_round_coop_count = countCooperators(history[round - 1])

  if previous_round_coop_count >= m then
    return Cooperate
  else
    return Defect
  end if
end function
```

In this pseudocode, `i` is the current player's index, `n` is the total number of players, `m` is the minimum cooperation threshold, `k` is the reward factor for risk aversion, `r` is the total number of rounds, and `history` is an array containing the records of past actions by all players. The function returns either 'Cooperate' or 'Defect'.
'''

description_COLLECTIVE_341 = '''
 Strategy Name: Tit-for-Tat (TFt) with Adaptive Cooperation Threshold (ACT)

1. Decision Rules:
   - Initialize cooperation threshold (CT) equal to the minimum cooperators needed parameter (m). In our example, CT = 3.
   - On each round i, if the number of cooperators in the previous round (i-1) is greater than or equal to CT, player cooperates (C). Otherwise, player defects (D).
   - If a player encounters a successful round (m or more players cooperated), decrease the cooperation threshold by one. If they encounter an unsuccessful round, increase it by one. The purpose of this is to gradually adapt to the opponents' behavior and maintain some level of flexibility.

2. Handle edge cases:
   - First round: Start with cooperation as CT=m (cooperation threshold is at its maximum).
   - Last round: Disregard the adaptation rule since there are no future rounds to consider. Cooperate if m or more players cooperated in the penultimate round; otherwise, defect.

3. Be collective:
   - The strategy prioritizes cooperation as much as possible while being mindful of the need for reciprocity and adaptability. This encourages a sense of community spirit without compromising the player's self-interest, thus aligning with the collective mindset.

Pseudocode:

```
function ACT(n, m, k, r) {
    CT = m; // Cooperation Threshold is set to minimum required cooperators
    totalRounds = r + 1; // Add one for initializing the first round
    payoffs = Array(totalRounds);

    function playRound(cooperatorsInLastRound) {
        if (cooperatorsInLastRound >= CT) {
            return "C"; // Cooperate
        } else {
            return "D"; // Defect
        }
    }

    for round = 1 to totalRounds:
        playerAction = playRound(cooperatorsInPreviousRound);
        payoffs[round] = ...; // Calculate payoff based on the game structure
        if (round > 1 and playerAction == "C") {
            CT--; // Decrease cooperation threshold after successful round
        } else if (round < totalRounds - 1 and playerAction == "D") {
            CT++; // Increase cooperation threshold after unsuccessful round
        }
    end for

    return payoffs; // Return the total game payoff as an array
}
```
'''

description_COLLECTIVE_342 = '''
 Title: Titan Strategy for Collective Risk Dilemma

1. Decision Rules:
   The Titan strategy is a adaptive and robust strategy that balances risk-taking with cooperation, aiming to maximize long-term payoff. The decision rule is as follows:

   - In each round t, if the number of cooperators in the previous round (t-1) was greater than or equal to m, Titan cooperates (C). If the number of cooperators was less than m, Titan defects (D).
   - In the first round, since there's no past data to base decisions on, Titan randomly chooses to either cooperate or defect with a 50% probability.

2. Handling Edge Cases:
   - Last Round: Titan follows the decision rule based on the previous round's data, as if it were any other round.
   - Initial Cooperations: In tournaments where multiple rounds are played without previous games, Titan starts with a 50% probability of cooperation in each of the first few rounds (e.g., first 10 rounds) to encourage cooperation among opponents and improve chances of long-term success. After that, the strategy fully adopts its adaptive behavior.

3. Being Collective:
   Titan maintains a collective mindset by always considering the overall well-being of the group when making decisions. By prioritizing cooperation when a majority of players have done so previously, it encourages collective action and fosters an environment where mutual benefits can be achieved. This strategy also adapts to changing conditions, ensuring its continued effectiveness in various game scenarios.

Pseudocode:
```
def titan_strategy(round, past_cooperators):
  if round <= num_initial_rounds:
    cooperation_probability = 0.5
  else:
    cooperation_probability = max(past_cooperators / n, 0)

  if round == 1 or random() < cooperation_probability:
    action = 'C' # Cooperate
  else:
    action = 'D' # Defect

  return action
```
'''

description_COLLECTIVE_343 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFTAC)

1. Decision Rules:
   - In the first round, cooperate (C). This is a friendly gesture to encourage cooperation from others.
   - For subsequent rounds, analyze the behavior of other players in the previous round:
     - If majority (≥ m-1) of players cooperated in the last round, cooperate (C).
     - If fewer than m players cooperated in the last round, defect (D).

2. Handling Edge Cases:
   - Last Round: Adopt the strategy of the penultimate round to avoid unilaterally changing behavior that could disrupt cooperation.
   - First Few Rounds: Initially, cooperate for the first few rounds (e.g., up to 3) to encourage others to cooperate before adopting the TFTAC strategy.

3. Collective Mindset:
   - The TFTAC strategy maintains a balance between cooperation and defection while being responsive to the actions of other players, fostering an environment conducive to cooperation.
   - If the majority cooperates, it is rewarded with a higher payoff, reinforcing continued cooperation. Conversely, if the majority defects, the strategy punishes those who did not contribute by also defecting, discouraging future defection.

Pseudocode:
```
def TFTAC(round, players_cooperated, m, k):
  if round <= initial_rounds:
    return cooperate()

  cooperation_threshold = m - 1
  if players_cooperated >= cooperation_threshold:
    return cooperate()
  else:
    return defect()
```
Here, `initial_rounds` is the number of initial rounds for which the strategy initiates cooperation to foster an environment conducive to cooperation. Adjusting this parameter can help optimize performance in different game scenarios.
'''

description_COLLECTIVE_344 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for Collective Risk Dilemma

1. Specify decision rules:
   - Initiation: In the first round, cooperate to promote trust and collaboration (C).
   - Response: For subsequent rounds, mimic the cooperative behavior of others from the previous round. If a player cooperated in the last round, cooperate again (C); otherwise defect (D). This tit-for-tat approach encourages reciprocity while maintaining adaptability to various opponent behaviors.

2. Handle edge cases:
   - Last Round: Continue with the response rule from the previous round as there are no further rounds after that.
   - First Encounter with a Defector (FDD): After the initial cooperative move, defect against the first player who defects (D) to punish defection and encourage cooperation in future encounters.

3. Be collective:
   - The ATfT strategy prioritizes long-term cooperation by rewarding players who consistently cooperate and penalizing those who do not. This collective mindset encourages players to invest in the common good, with the hope that others will do the same.

Pseudocode for Adaptive Tit-for-Tat:
```
function Adaptive_Tit_for_Tat(round, history) {
  if (round == 1) return 'C' // Initiation: cooperate in first round

  opponentLastMove = history[round - 1]['opponent'] // Get the opponent's last move

  if (opponentLastMove == 'D') { // First Encounter with a Defector
    punishmentRound = round // Remember this round for punishment later
    return 'D' // Punish defection by defecting
  } else if (opponentLastMove == 'C') {
    return 'C' // Cooperate in response to cooperation
  } else {
    if (round == punishmentRound + 1) { // Check if it's time for the punishment
      return 'D' // Punish defection again
    } else {
      return 'C' // Continue with cooperative behavior
    }
  }
}
```
'''

description_COLLECTIVE_345 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for Collective Risk Dilemma

1. Decision Rules:
   - Initially Cooperate (C) in the first round to foster cooperation and goodwill. Subsequent actions will be based on previous opponents' behavior.
   - If an opponent cooperates, reciprocate with cooperation (C).
   - If an opponent defects, also defect in the next round as a punishment, then revert to cooperating if the opponent cooperates in the following round. This encourages opponents who have previously defected to change their behavior and cooperate.

2. Handling Edge Cases:
   - In the first round, cooperate (C).
   - In the last round, evaluate the total number of times the opponent has cooperated compared to the minimum required for success (m). If this ratio meets or exceeds the average cooperation rate needed for success across all rounds (average_m), then cooperate. Otherwise, defect. This allows for flexibility in the last round based on the overall behavior of the opponent throughout the game.
   - In other edge cases (e.g., penultimate round), apply the same logic as described above but consider the remaining rounds instead of the entire game history.

3. Being Collective:
   - The strategy aims to maximize collective success by cooperating when there's a reasonable chance of meeting the minimum cooperation threshold (m) and encouraging others to do the same.
   - By reciprocating cooperation and punishing defection, the strategy fosters a collective mindset where players learn to trust each other over time.

Pseudocode:

```python
def Adaptive_Tit_for_Tat(opponent, n, r, m, k):
    history = []  # store opponent's actions in previous rounds

    def playerAction():
        if len(history) == 0:  # first round, always cooperate
            return 'C'

        elif len(history) == r - 1 and calculate_cooperation_ratio(history) < average_m:  # last round, use ratio of cooperation to make decision
            if calculate_cooperation_ratio(history) <= m/(r-1):
                return 'D'
            else:
                return 'C'

        elif len(history) == r - 2:  # penultimate round, use ratio of cooperation to make decision
            if calculate_cooperation_ratio(history[:-1]) <= m/(r-2):
                return 'D'
            else:
                return 'C'

        elif len(history) > r - 3:  # any other edge case, use opponent's last action to make decision
            if history[-1] == 'C':
                return 'C'
            else:
                return 'D'

    def calculate_cooperation_ratio(actions):
        cooperation = actions.count('C')
        total = len(actions)
        return cooperation / total

    history.append(opponent)  # record opponent's action in the current round
    myAction = playerAction()  # decide my action based on the decision rules
    return myAction
```
'''

description_COLLECTIVE_346 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initialize cooperation in the first round (C).
   - In subsequent rounds, cooperate if the number of cooperators in the previous round is greater than or equal to the Cooperative Threshold (CT). Otherwise, defect (D).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First Round: Cooperation (C) to signal trustworthiness and encourage similar cooperation from others.
   - Last Round: Copy the action of the player who contributed most to cooperative outcomes throughout the game (highest sum of rewards). If there's a tie, defect to avoid potential exploitation in the final round.

3. Be collective - Clearly align with the collective mindset
   - Cooperate as much as possible while maintaining robustness against defection.
   - Adjust the Cooperative Threshold (CT) based on the average cooperation rate observed during the game to improve adaptability and responsiveness to opponent strategies.

Pseudocode:
```
function TFT-ACT(n, m, k, r, history) {
  CT = initialCooperationThreshold(m, n)
  cooperationRate = 0
  for round = 1 to r {
    if round == 1 {
      action = C
    } else {
      cooperationCount = count Cooperators(history[round - 1])
      if cooperationCount >= CT {
        action = C
        updateCooperationRate(cooperationCount, cooperationRate)
      } else {
        action = D
      }
    }
    history.append(action)
  }
  if round == r {
    mostCooperativePlayer = findMostCooperativePlayer(history)
    if mostCooperativePlayer exists {
      action = mostCooperativePlayer.action[r - 1]
    } else {
      action = D
    }
  }
  return action
}

function initialCooperationThreshold(m, n) {
  return m / (2 * n)
}

function countCooperators(roundHistory) {
  cooperatorCount = 0
  for player in roundHistory {
    if player.action == C then {
      cooperatorCount += 1
    }
  }
  return cooperatorCount
}

function updateCooperationRate(cooperationCount, cooperationRate) {
  newCooperationRate = (cooperationCount + cooperationRate) / 2
  if newCooperationRate > 1 {
    newCooperationRate = 1
  } else if newCooperationRate < CT {
    newCooperationRate = CT
  }
  cooperationRate = newCooperationRate
}

function findMostCooperativePlayer(history) {
  maxReward = -Infinity
  mostCooperativePlayer = null
  for player in history {
    rewardSum = sum(round.reward for round in player.history)
    if rewardSum > maxReward {
      maxReward = rewardSum
      mostCooperativePlayer = player
    }
  }
  return mostCooperativePlayer
}
```
'''

description_COLLECTIVE_347 = '''
 Strategy Name: Tit-for-Tat Plus (TFT+)

1. Decision Rules:
   - Initially cooperate (first round) to signal good intentions and promote trust.
   - In subsequent rounds, cooperate if at least m players cooperated in the previous round; otherwise defect. This encourages cooperation when it is beneficial for the group but also retaliates against defection to discourage future uncooperative behavior.
   - If no other players cooperated in the current round and they had previously cooperated, also defect in the next round as a penalty. This ensures that the strategy does not reward persistent defection while still allowing for forgiveness.

Pseudocode:
```
function TFTPlus(round, history):
  if round == 1:
    return Cooperate

  cooperation_count = count cooperators in the last round of history
  if cooperation_count >= m:
    return Cooperate
  else:
    previous_cooperation_count = count cooperators in the second last round of history
    if previous_cooperation_count == 0:
      return Defect
    else:
      return Cooperate
```

2. Handling edge cases:
   - In the last round, there is no next round to consider, so no further adaptations are needed. The strategy will simply cooperate or defect based on the current round's history.

3. Being collective:
   - TFT+ aims to promote a collective mindset by cooperating when it is beneficial for the group (when at least m players have cooperated in the previous round) and retaliating against defection to discourage future uncooperative behavior. The strategy also forgives past defections if cooperation is subsequently shown, encouraging rebuilding of trust among players.
'''

description_COLLECTIVE_348 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Decision Rules:
   - In the first round, cooperate to demonstrate good faith and encourage others to do the same. (C)
   - For subsequent rounds, follow the actions of the majority in the previous round. If more than the threshold number 'm' cooperated, also cooperate in the current round. Otherwise, defect.
   - To make the strategy adaptive, adjust the cooperation threshold progressively during the game based on historical data:
     a) Increase the threshold by 1 for every consecutive round where more than (m-1) players have cooperated and the total reward was greater than the individual payoff from defecting. This encourages cooperation as it assumes others will continue to follow a cooperative strategy.
     b) Decrease the threshold by 1 for every consecutive round where the number of cooperators is less than (m-1) and the total reward was equal to or greater than the individual payoff from cooperating. This discourages cooperation when others are consistently defecting, assuming they will continue to do so.

2. Handling Edge Cases:
   - In the last round, cooperate if more than (m-1) players have cooperated in the previous round as a final attempt at achieving a high reward. Otherwise, defect to maximize individual payoff given no further rounds to play.
   - In case of a tie where the number of cooperators equals 'm' but there is no majority, follow the most recent trend (cooperate if more recently cooperated, defect otherwise). If still tied, use the current threshold value as a tiebreaker, with a higher threshold favoring cooperation.

3. Aligning with the Collective Mindset:
   - By following the actions of the majority and adjusting the cooperation threshold based on historical data, TFT-ACT aims to encourage cooperation when it is beneficial for the group while minimizing unnecessary defections. This strategy fosters a collective mindset by promoting cooperation in situations where it seems likely to succeed, thus supporting the long-term interests of the group as a whole.
   - By responding positively to cooperative behavior and adapting to the actions of others, TFT-ACT demonstrates fairness and trustworthiness that can help build a foundation for sustained cooperation in repeated interactions.
'''

description_COLLECTIVE_349 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Decision Rules:
   - Initially cooperate in the first round (C). This establishes a cooperative starting point.
   - In subsequent rounds, if the number of cooperators in the previous round is greater than or equal to the minimum cooperation threshold (m), also cooperate (C). Otherwise, defect (D).
   - Adaptively adjust the cooperation threshold based on the average percentage of cooperators over a sliding window of past games. If the percentage of cooperators is increasing, incrementally decrease the threshold to encourage more cooperation; if the percentage is decreasing, incrementally increase the threshold to discourage defection.

2. Handling Edge Cases:
   - In the last round, cooperate regardless of the number of cooperators in the previous round since there are no further rounds to gain rewards.
   - In the first round (or any round after a long streak of defections), cooperate to initiate cooperation and potentially encourage others to follow suit.

3. Being Collective:
   - The strategy follows a cooperative approach, aiming to maintain a stable number of cooperators that satisfies the minimum cooperation threshold (m).
   - By adapting the cooperation threshold based on past games' averages, TFT-ACT demonstrates collective behavior while being resilient to various opponent strategies.

Pseudocode:
```
Initialization:
  cooperation_threshold = m
  sliding_window_size = floor(r * 0.1)
  average_cooperators = 0
  current_round = 1

Main Loop (for r rounds):
  Cooperate if it's the first round or last round.
  Otherwise, observe the number of cooperators in the previous round.
  If the number of cooperators is greater than or equal to cooperation_threshold:
    Cooperate
  Else:
    Defect

  Update average_cooperators by taking a weighted average with current round's data and discarding oldest data from sliding window.
  Increment current_round.

  If current_round is not the last round, adapt cooperation_threshold based on the sliding window of average cooperators:
    if average_cooperators is increasing:
      decrease cooperation_threshold by a small amount
    else if average_cooperators is decreasing:
      increase cooperation_threshold by a small amount
```
'''

description_COLLECTIVE_350 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFTAC)

1. Decision Rules:
   - Initially cooperate (C) in the first round to signal goodwill and set a cooperative tone.
   - In subsequent rounds, players will imitate the most recent action of the majority (more than n/2) of other players in the previous round. If the majority defected (D), also defect in the current round. If the majority cooperated (C), also cooperate in the current round.
   - Adapt to changing conditions by gradually reducing the number of required cooperators for cooperation from m if fewer than m players have cooperated in a sliding window of past rounds (e.g., the last 5 rounds). The minimum number of cooperators needed for cooperation can be adjusted according to the following rule:
     ```python
     m_current = min(m, round(0.2 * sum(cooperation_counts[-5:])) + 1)
     ```
     In this example, the number of required cooperators is a moving average of cooperation counts from the last 5 rounds and adjusted to be at least 20% of the total cooperation count in that window.

2. Handle Edge Cases:
   - In the last round, players should cooperate (C) if there is a chance for reciprocity or achieving the minimum number of cooperators needed for reward.
   - In the first round, play C to establish a cooperative starting point, as mentioned above.

3. Be Collective:
   - The strategy prioritizes collective cooperation by imitating the majority behavior and adapting to changing conditions based on historical data. This approach encourages the development of trust among players over time and promotes long-term cooperation.
   - If most players are cooperating, the strategy will reciprocate and continue cooperating, fostering a cooperative community.
   - If most players are defecting, the strategy will also defect to avoid being taken advantage of but will be open to changing its behavior when it sees signs of increasing cooperation from others.
'''

description_COLLECTIVE_351 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Specify decision rules:
   - Start by cooperating in the first round (C_i, 1 = C). This is a friendly gesture to encourage cooperation and avoid immediate exploitation.
   - For subsequent rounds, if the player (i) cooperated in the previous round (C_i-1 = C), cooperate again (C_i = C). If not (C_i-1 = D), defect this round as well (C_i = D). This rule encourages mutual cooperation and punishes defection.
   - To adapt to other strategies, apply the Feldman-Hofstadter rule: if the partner cooperates in three consecutive rounds after a previous defection, forgive the past defection and return to cooperating (C_i = C). This rule allows for forgiveness and encourages long-term cooperation.

2. Handle edge cases:
   - In the last round, since there is no future interaction, always defect regardless of the opponent's previous action (C_r = D).
   - In the case where the partner cooperates in the first round but then immediately switches to defection (e.g., a "defect-then-cooperate" strategy), TfTA will continue defecting until the partner returns to cooperation three times consecutively, at which point it will forgive and resume cooperating.

3. Be collective:
   - By combining the friendly initial cooperation and adaptive punishment of defection, the Tit-for-Tat-Adaptive strategy aligns with a collective mindset by encouraging mutual cooperation, forgiveness, and long-term relationships while also being robust to various opponent behaviors.

Pseudocode:
```
function TfTA(i, t) {
  if (t == 1) { return C } // Cooperate in the first round
  if (i_t-1 != C && i_t-2 == C) { return C } // Forgive and cooperate if three consecutive rounds of cooperation followed defection
  return i_t-1 // Otherwise, copy opponent's action from previous round
}
```
'''

description_COLLECTIVE_352 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TFT-A)

1. Decision Rules:
   - Initially cooperate (C) in the first round to signal goodwill and establish trust.
   - In subsequent rounds, cooperate if the majority of players (m or more) cooperated in the previous round. If fewer than m players cooperated, defect (D).
   - If a player switches from cooperation to defection after a sequence of mutual cooperation, respond with a single act of defection and then revert back to cooperation for the next round. This encourages consistency while still punishing sudden defections.

2. Edge Cases:
   - In the last round, cooperate regardless of the previous round's outcome, as there are no subsequent rounds for retaliation.
   - If a player has never cooperated (zero cooperation throughout the game), defect in all subsequent rounds to maximize personal payoff.

3. Collective Mindset:
   - TFT-A maintains a balance between individual self-interest and collective welfare by promoting mutual cooperation while also punishing defections. This creates an environment that encourages trust and long-term reciprocity.

Pseudocode:
```
def TFT_A(round, history, m, n, k):
  if round == 1:
    action = 'C'  # Cooperate in the first round to establish goodwill
  elif round == r:
    action = 'C'  # Cooperate in the last round as there are no subsequent rounds
  else:
    cooperation_count = count_cooperators(history[round - 1])
    if cooperation_count >= m:
      action = 'C'  # Cooperate if majority cooperated in the previous round
    else:
      action = 'D'  # Defect if fewer than m players cooperated

  if history.exists(player) and player.recent_action != 'C':  # Respond to a single defection with a single act of defection
    if player.recent_action == 'D':
      action = 'D'
    else:
      action = 'C'

  return action
```
'''

description_COLLECTIVE_353 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules:
   - In each round, compare the number of cooperators in the previous round (n_c) with the minimum required cooperation threshold (m). If n_c >= m, the player will cooperate (C), otherwise defect (D). This encourages cooperation when it is beneficial for the group but also punishes defection.
   - To adapt to opponent behaviors, introduce an additional parameter 'p', the cooperation probability, which slowly decreases over time if a player continually defects. The decrease in p should be gradual to allow for occasional errors or deviations from cooperative behavior by the opponent. If the opponent starts cooperating again, increase p towards its initial value.

2. Handle edge cases:
   - In the first round, since there is no previous information, set p to a high initial value (e.g., 0.9) to encourage cooperation.
   - In the last round, if r rounds have passed and the game continues, apply the same decision rules as in other rounds. However, if the game ends abruptly, it may be beneficial for the player to defect since there are no further opportunities to interact with the opponents.

3. Be collective:
   - The strategy aligns with the collective mindset by prioritizing cooperation when a sufficient number of players do so in the previous round. This encourages long-term group success while also punishing frequent defection.
   - By decreasing p over time, the strategy learns to be more cautious as it encounters repeated defection from opponents, fostering a collective approach that prioritizes the group's well-being over individual gains.

Pseudocode:

```
strategy TFTAT(n, m, k, r, p_init, p_decay):
    initialize player i with endowment e_i and cooperation probability p = p_init

    for round in range(1, r+1):
        observe n_c, the number of cooperators in the previous round
        if n_c < m:
            calculate individual payoff π_i according to game parameters
            update e_i based on payoff and endowment retention rule
            if p > p_min:
                decrease p by p_decay
        else:
            set action as cooperate (C)
            calculate individual payoff π_i according to game parameters
            update e_i based on payoff and endowment retention rule

    return total payoff over r rounds
```
'''

description_COLLECTIVE_354 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for Collective Risk Dilemma

1. Decision Rules:
   - Initial Round (t=1): Cooperate (C), establishing a cooperative beginning. This is intended to encourage others to reciprocate cooperation.
   - Subsequent Rounds (t>1):
     - If the number of cooperators in the previous round (t-1) was less than m, defect (D) to maximize personal gain in a non-cooperative environment.
     - If the number of cooperators in the previous round (t-1) was equal to or greater than m, cooperate (C) as a reciprocal gesture and to maintain cooperation momentum.

2. Handling Edge Cases:
   - Last Round (t=r): Since there are no future rounds for reciprocation, follow the rule of the current round: if the number of cooperators in the previous round was equal to or greater than m, also cooperate; otherwise defect.
   - First Round (t=1): Cooperate regardless of history since it sets a positive tone and gives others an opportunity to reciprocate.

3. Being Collective:
   - By adopting a strategy that is conditional on the number of previous rounds' cooperators, ATfT maintains a collective mindset by promoting cooperation when conditions align with group success.
   - By reciprocal behavior, the strategy encourages others to cooperate and builds trust within the group over time.

Pseudocode for the Adaptive Tit-for-Tat (ATfT) strategy:

```
function ATfT(round, previous_cooperators):
  if round == 1: # First round, always cooperate
    return C

  if previous_cooperators < m: # If fewer than m players cooperated last round, defect
    return D
  else: # If m or more players cooperated last round, cooperate
    return C
```
'''

description_COLLECTIVE_355 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFT-A) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round i, if the number of cooperators in the previous round (i-1) is less than m, player will defect (D). If the number of cooperators in the previous round (i-1) equals or exceeds m, player will cooperate (C).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, since there is no prior information about other players' behavior, player starts by cooperating to establish a cooperative environment. In the last round, player cooperates if the required threshold (m) has been reached in the previous round, and defects otherwise.

3. Be collective - Clearly align with the collective mindset
   TFT-A is designed to promote long-term cooperation. By initially cooperating, the strategy encourages others to do the same, and responds favorably when players follow a cooperative approach. However, if the other players adopt a defective strategy, TFT-A will retaliate by adopting the same behavior in an attempt to encourage future cooperation.

Pseudocode:

```python
def TFT_A(n, m, k, r):
    # Initialize player's action history as an empty list
    actions = []

    def decide_action(round):
        # Get the number of cooperators in the previous round
        prev_cooperators = sum(actions[-m:])

        # If less than m players cooperated, defect; else cooperate
        if prev_cooperators < m:
            return "D"
        else:
            return "C"

    for round in range(1, r + 1):
        action = decide_action(round)
        actions.append(action)
        # Adjust payoff based on the game's payoff calculation
        payoff = calculate_payoff(action, round, m, k)
        yield payoff
```
'''

description_COLLECTIVE_356 = '''
 Strategy Name: Tit-for-Tat with Cooperation Threshold (TFTC)

1. Decision Rules:
   - In the first round, cooperate to signal goodwill and create a potential for cooperation in future rounds. `if round = 1 then cooperate`
   - In subsequent rounds, assess the number of cooperators (c) from the previous round. If c >= m (minimum cooperators needed), cooperate; otherwise defect. `if round > 1 then if (previous_round_cooperators >= m) then cooperate else defect`
   - When players cooperate, they will receive a reward (k) in addition to their basic payoff, which encourages long-term cooperation. If players consistently defect, the strategy will also start defecting as a response. `if c >= m then payoff += k`
   - The strategy remembers its opponent's last action and responds accordingly in the next round, favoring cooperation over defection when given the opportunity. `remember_opponent_last_action()`

2. Edge Cases:
   - In the last round, cooperate if it would result in a higher payoff than defecting, considering the history of the game (previous rounds' actions and rewards). `if (round = r) then if (cooperating > defecting) then cooperate else defect`
   - If an opponent defects after a round where both players cooperated, the strategy will defect in the next round as a punishment. However, it will cooperate again in the following round to give the opponent another chance for cooperation. `if (previous_round_action == cooperate) and (current_opponent_action == defect) then defect; else if (previous_round_action != cooperate) then cooperate`
   - If no cooperation is observed after several rounds, the strategy will switch to a more aggressive behavior, defecting in subsequent rounds. `if (number_of_cooperative_rounds <= some_threshold) then always defect`

3. Collective Mindset:
   - The TFTC strategy encourages cooperation by assuming that other players are also cooperating unless proven otherwise. It responds to defection with defection but quickly forgives and returns to cooperation if the opponent cooperates again. This strategy promotes stability, trust, and long-term cooperation when faced with a wide range of opponent behaviors.
   - The strategy is adaptive as it learns from its opponents' actions and adjusts its behavior accordingly, fostering an environment that incentivizes cooperation while also deterring defection.
'''

description_COLLECTIVE_357 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperative Strategy (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?

Initially, players start by cooperating in the first round (C_i = 1). After that, each player i will follow the actions of their most recent opponent j:

- If j cooperated (c_j = 1) in the previous round, player i will also cooperate (C_i = 1)
- If j defected (c_j = 0) in the previous round, player i will defect (C_i = 0)

However, to promote cooperation and avoid potential escalation of defection, players will exhibit forgiveness when they initially encounter an opponent who has been previously defecting. For this initial punishment period, set t_p as a fraction of the total rounds r:

- If c_j = 0 for the last t_p rounds, then C_i = 1 in the current round

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, all players cooperate (C_i = 1). In the last round, players will consider their overall history with their opponents to determine their actions based on the decision rules mentioned above.

3. Be collective - Clearly align with the collective mindset

The TFTAC strategy encourages cooperation and reciprocity among players. The strategy is adaptive and responsive to the behavior of each opponent while being robust against a wide range of opponent behaviors. Players will only deviate from cooperating when they observe defection by their opponents, promoting a collective effort towards mutual success.

Pseudocode:
```
function TFTAC(n_rounds, previous_opponent_action) {
  if (n_round == 1) {
    return 1; // Cooperate in the first round
  }

  t_p = n_rounds * forgiveness_factor;

  if (previous_opponent_action == 0 &&
      (n_round - t_p < 1)) {
    return 1; // Forgive initial defection and cooperate
  } else if (previous_opponent_action == 1) {
    return previous_opponent_action; // Copy opponent's action
  } else {
    return 0; // Defect as a response to opponent's past defections
  }
}
```
'''

description_COLLECTIVE_358 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules:
   - Initial Round (t=1): Cooperate (C) to demonstrate goodwill and encourage reciprocity among opponents.
   - Subsequent Rounds (2 ≤ t ≤ r): If the opponent cooperated in the previous round, cooperate in the current round. Otherwise, defect (D). This encourages cooperation while also punishing defection.
   - To prevent endless retaliation: After a certain number of consecutive defections by an opponent, switch to a policy of unconditional cooperation (i.e., always cooperate regardless of the opponent's previous action) for a predefined number of rounds as a peace offering. If the opponent reciprocates cooperation during this period, revert back to TFT-AC strategy; otherwise, continue with unconditional cooperation until the game ends.

2. Handle edge cases:
   - Last Round (t=r): Always cooperate to maximize potential payoff in the final round, regardless of the opponent's previous action.
   - First Encounter with a New Opponent: Cooperate (C) to demonstrate goodwill and encourage reciprocity. If the opponent does not reciprocate cooperation within a predefined number of rounds, switch to unconditional defection (D).

3. Be collective:
   - Prioritize cooperation and mutual benefits by rewarding cooperative behavior and punishing defection, but remain flexible and adaptable in response to various opponent strategies.
   - By adapting to the opponent's strategy, TFT-AC promotes collective success through cooperation while maintaining a robust stance against defection.
'''

description_COLLECTIVE_359 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Decision Rules:
   - Initially Cooperate (C) in the first round to show goodwill and promote cooperation.
   - In subsequent rounds, cooperate if at least m players cooperated in the previous round. Otherwise, defect (D). This encourages mutual cooperation while punishing defection.

2. Handling Edge Cases:
   - In the last round, cooperate regardless of the number of cooperators in the previous round to maximize the payoff for that specific round.
   - In the first round, since players cannot know each other's actions, assume all players will cooperate (m out of n) and cooperate yourself as well. If fewer than m players actually cooperate, adjust future decisions according to the observed behaviour.

3. Collective Mindset:
   - The ATFT strategy promotes cooperation by rewarding mutual cooperation and punishing defection in a fair manner. It maintains a balance between self-interest (defecting when necessary) and collective interest (cooperating when appropriate). This approach encourages the emergence of trust and long-term cooperation within the group.

Pseudocode:

```python
def atft(n, m, k, r, history):
    if round == 1:
        action = 'C'  # Cooperate in first round to promote cooperation

    else:
        cooperators_prev_round = count_cooperators(history[-r+1:-1])  # Count cooperators in the previous r-1 rounds

        if cooperators_prev_round >= m:  # If enough players cooperated, cooperate this round
            action = 'C'
        else:  # Otherwise defect to punish defection from others and protect personal interests
            action = 'D'

    return action
```

The above pseudocode assumes the function `count_cooperators(history)` which counts the number of cooperative actions (C) in the provided history. This strategy can be fine-tuned by adjusting parameters such as m and k to better suit specific game scenarios and opponent behaviors.
'''

description_COLLECTIVE_360 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - In the first round, cooperate (C). This initiates cooperation and demonstrates goodwill.
   - For subsequent rounds, observe the actions of others in the previous round. If a majority (more than (n-1)/2) of players cooperated in the previous round, also cooperate in the current round to continue the cooperation chain. Otherwise, defect (D) to punish non-cooperative behavior and encourage future cooperation.
   - If the number of cooperators in the last round equals m, cooperate again in the final round to ensure achieving the minimum cooperation threshold for maximum payoff.

2. Edge Cases:
   - In the first round, cooperate (C).
   - If there's a tie (exactly (n-1)/2 cooperators in the previous round), defect (D) as a precaution to prevent the risk of failing to meet the minimum cooperation threshold.
   - In the last round, if the number of cooperators equals m, cooperate (C). If not, defect (D) since the game will end after this round anyway.

3. Collective Mindset:
   - TFT-AC adapts to the collective behavior of other players by reciprocating cooperation and punishing defection through a simple yet effective strategy.
   - The strategy's cooperative nature helps foster an environment for continued cooperation in repeated interactions, as long as there is a critical mass of cooperators (more than (n-1)/2).

Pseudocode:

```python
def TFT_AC(round, current_cooperators, m, k, n):
    if round == 1:
        return 'C' # Cooperate in the first round

    if current_cooperators > (n-1)/2:
        return 'C' # Cooperate if a majority cooperated in the previous round
    else:
        return 'D' # Defect to punish non-cooperative behavior

def last_round(r, round):
    return round == r

def game_over(m, current_cooperators):
    return current_cooperators >= m

def TFT_AC_round(round, history):
    current_cooperators = sum([1 for action in history[-round:] if action == 'C'])
    if last_round(history[-1], round) and game_over(m, current_cooperators):
        return 'C' # Cooperate in the final round if the cooperation threshold is met
    else:
        return TFT_AC(round, current_cooperators, m, k, len(history))
```
'''

description_COLLECTIVE_361 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?

The TFT-ACT strategy follows a tit-for-tat approach, initially cooperating and then mirroring the opponent's most recent action. To introduce adaptability, it also includes an adjustable cooperation threshold (m_t) that evolves based on the number of cooperators in the previous round(s).

```python
def tft_act(round, opponents_history, m_t):
  if round == 1:
    action = 'C'  # Cooperate in the first round
  else:
    last_opponent_action = opponents_history[-1]
    if len(opponents_history) >= m_t and sum(last_opponent_action == 'C' for _ in range(m_t)) >= m_t:
      # If sufficient cooperators in the last few rounds, adapt cooperation threshold
      if round % update_frequency == 0:
        m_t = max(int((len(opponents_history) - update_frequency) * current_average_cooperation), m_min)

    action = last_opponent_action  # Mirror opponent's most recent action
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, the strategy cooperates regardless of the number of opponents. In the last round, it considers the cooperation threshold (m_t) and adapts accordingly if necessary.

3. Be collective - Clearly align with the collective mindset

The TFT-ACT strategy encourages cooperation by initially assuming that others will cooperate and then reciprocating their actions. The adjustable cooperation threshold (m_t) allows the strategy to adapt to different levels of cooperation in the group, making it more flexible and robust. By evolving m_t based on the average number of cooperators in previous rounds, TFT-ACT can align with a collective mindset while being less susceptible to exploitation from defectors.

Additional notes:
- The `current_average_cooperation` variable represents the average number of cooperators in the last update_frequency rounds. This factor helps in smoothing out short-term fluctuations and making the strategy more stable.
- The `update_frequency` parameter determines how often the cooperation threshold is updated (e.g., every 10 rounds).
- The `m_min` parameter sets a minimum value for the cooperation threshold to prevent it from becoming too small in low-cooperation scenarios.
'''

description_COLLECTIVE_362 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initial Round: Cooperate (C), to initiate cooperation and create a positive cycle.
   - Subsequent Rounds: If the opponent cooperated in the previous round, cooperate (C). Otherwise, defect (D). This rule encourages reciprocity while being forgiving for occasional mistakes.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First Round: Cooperate (C) as mentioned above.
   - Last Round: Cooperate if the opponent cooperated in the penultimate round, to reward good behavior. Otherwise, defect to punish non-cooperation and discourage repetition of negative actions.
   - Other Edge Cases (e.g., mid-game): Follow the TFT rule based on the opponent's previous action.

3. Be collective - Clearly align with the collective mindset:
   - By cooperating when the opponent does and defecting otherwise, TFT-AC demonstrates a willingness to collaborate and foster cooperation within the group. It also encourages others to reciprocate cooperation, thereby promoting a collective mindset.

Pseudocode for TFT-AC strategy:

```
Function TFT_AC(opponent_history)
  history_length = Length(opponent_history)
  If history_length == 0 Then
    return "Cooperate"
  End If

  If history_length == 1 Then
    return "Cooperate"
  End If

  last_round = opponent_history[history_length - 1]

  If last_round == "Cooperate" Then
    return "Cooperate"
  Else
    return "Defect"
  End If
End Function
```
'''

description_COLLECTIVE_363 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules:
   - Initially cooperate (C) in the first round to demonstrate goodwill and cooperation intent.
   - In subsequent rounds, mimic the actions of other players from the previous round. If a majority (m) or more players cooperated in the previous round, also cooperate; otherwise defect (D). This follows the "Tit-for-Tat" principle of reciprocity but is adapted for the Collective Risk Dilemma.
   - To handle edge cases:
     - In the last round, cooperate if a majority cooperated in the previous round; otherwise defect to maximize individual payoff.
     - If there's no historical data (e.g., first encounter), initially cooperate as a goodwill gesture and adapt based on the opponents' actions in the subsequent rounds.

2. Handle edge cases:
   - First round: C
   - Last round: If m_prev >= m, then C; otherwise D
   - Empty history (first encounter): C

3. Be collective:
   - Cooperation is prioritized over defection when a majority of players have cooperated in the previous round, reflecting the collective mindset.
   - The strategy will adapt to changing player behavior and aim for long-term cooperation benefits while minimizing short-term losses due to defection by others.

Pseudocode:

```python
def ATFT(history, m, k, n, r):
  round = 0  # initialize current round number
  strategy = []  # store decisions for each round

  # Initialize history with the first cooperative action
  if round == 0:
    strategy.append("C")
    history.append(strategy[-1])
    round += 1

  while round < r:
    # Check majority cooperation in previous round
    m_prev = sum([1 for action in history[-r:] if action == "C"])

    # Adapt decision based on majority cooperation in the previous round
    strategy.append("C" if m_prev >= m else "D")
    round += 1

  return strategy
```
'''

description_COLLECTIVE_364 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TFT-A)

1. Decision Rules:
   - TFT-A cooperates in the first round and thereafter, copies the action of the most frequent cooperator from the previous round (excluding itself). If there's a tie, it cooperates.
   - In case of no cooperation from any player in the previous round, TFT-A defects to ensure fairness and discourage exploitation.

2. Handling Edge Cases:
   - In the first round, TFT-A cooperates as it is a fresh start for everyone.
   - In the last round, TFT-A copies its own action from the previous round since the game ends after that.
   - If a player switches from cooperation to defection in the middle of the game (also known as a "defection betrayal"), TFT-A stops cooperating with them for the remaining rounds to discourage future betrayals. However, if the player subsequently returns to cooperate again, TFT-A will resume cooperating with them.

3. Being Collective:
   - TFT-A aims to promote a collective mindset by encouraging cooperation and punishing defection only when necessary for fairness. It rewards persistent cooperators while discouraging betrayals to maintain a cooperative environment.
   - The adaptive nature of TFT-A allows it to adjust its behavior based on the actions of others, promoting responsiveness and mutual understanding in repeated interactions.
'''

description_COLLECTIVE_365 = '''
 Title: Tit-for-Tat Adaptive Strategy (TFT-A) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially cooperate in the first round (C_i, 1 = 1). This sets a cooperative tone and reduces the risk of being exploited by early defection.
   - In subsequent rounds, players will mimic the action of their partner from the previous round (C_i, t = C_j, t-1 if C_j, t-1 > m/n or D_i, t = D_j, t-1 otherwise). This encourages reciprocity and fosters cooperation when it's beneficial for the group.
   - If an opponent consistently deviates from cooperation (more than α times in a row), punish them by defecting (D_i, t = D_j, t-1 when C_j, t-α < m/n and t > α). This deterrent mechanism discourages long-term exploitation.
   - If the game is near its end, revert to cooperating regardless of the opponent's previous actions (C_i, t = 1 if t >= r - β, where β is a small number). This final attempt at cooperation gives the group one last chance to maximize rewards.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate unconditionally (C_i, 1 = 1).
   - Near the end of the game (t >= r - β), cooperate regardless of the opponent's previous actions (C_i, t = 1 if t >= r - β).

3. Be collective - Clearly align with the collective mindset
   - Encourage cooperation among players by initially cooperating and reciprocating cooperation from opponents.
   - Use a deterrent mechanism to punish long-term exploitation to foster a cooperative environment.
   - Modify behavior near the end of the game to maximize potential rewards for the group.

Pseudocode:
```
function TFT_A(i, t)
  if t == 1 then
    return C
  end if

  if j, t-1 < m/n then
    if (t > α or t < r - β) and (t - α > 1) then
      return D
    else
      return j, t-1
    end if
  else
    if t >= r - β then
      return C
    else
      return j, t-1
    end if
  end if
end function
```
'''

description_COLLECTIVE_366 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Decision Rules:
   - Initially Cooperate (C) in the first round to demonstrate goodwill and encourage cooperation.
   - In subsequent rounds, cooperate if at least m players cooperated in the previous round. If fewer than m players cooperated, defect.
   - Mimic the action of the opponent from the previous round in the current round (Tit-for-Tat). This encourages reciprocity and long-term cooperation while punishing defection.
   - If an opponent stops cooperating, resume cooperation after a grace period to give the opportunity for rebuilding trust (Adaptive Tit-for-Tat).

2. Handle Edge Cases:
   - In the last round, since there are no future rounds to punish or reward, follow the decision rule based on the current round's opponents' actions.
   - In the first round, cooperate as a goodwill gesture and initiate reciprocity by assuming other players will also cooperate.

3. Be Collective:
   - The strategy is designed to promote collective interest by rewarding cooperation and punishing defection in a fair and consistent manner. By encouraging reciprocal behavior, the strategy fosters a sense of community and shared responsibility.
   - The strategy is adaptive, allowing it to adjust its behavior based on the opponents' actions, which promotes long-term cooperation and minimizes exploitation.

Pseudocode for Adaptive Tit-for-Tat:
```
function ATFT(n, m, k, r):
    players = [1, 2, ..., n]
    memory = [[] for i in range(n)]
    cooperation_count = 0
    round = 0

    while round < r:
        for player_i in players:
            if round == 0:
                action_i = "C"  # Cooperate in the first round
            else:
                previous_round_actions = memory[player_i][round - 1]
                cooperation_count += sum(previous_round_actions >= 1)  # Count number of cooperators in the last round
                if cooperation_count >= m:
                    action_i = "C"  # Cooperate if enough players cooperated in the last round
                elif cooperation_count < m:
                    action_i = "D"  # Defect if not enough players cooperated in the last round
                else:  # If the number of cooperators is exactly m, use previous opponent's action as a guide
                    if memory[player_i][round - 1][player_i] == "C":
                        action_i = "C"
                    else:
                        action_i = "D"
            memory[player_i].append([player_j, action_i for player_j in players])  # Update memory with current round's actions
            round += 1

    total_payoff = sum(payoff_calculation(n, m, k, memory))  # Calculate total payoff based on the payoff calculation function

function payoff_calculation(n, m, k, memory):
    total_payoff = 0
    for player_i in range(1, n+1):
        cooperation_count = 0
        for round in range(1, r+1):
            previous_round_actions = memory[player_i][round - 1]
            cooperation_count += sum(previous_round_actions >= 1)
            if cooperation_count >= m:
                payoff = (1 - 1) + k  # Reward for cooperation in this round
            else:
                payoff = (1 - 1)
        total_payoff += payoff * r  # Sum up the payoffs over all rounds
    return total_payoff
'''

description_COLLECTIVE_367 = '''
 Strategy Name: Tit-for-Tat (TFT) with Threshold Adaptation (TTTA)

1. Specify decision rules:
   - In each round, players follow a Tit-for-Tat strategy by cooperating in the first round (C). Subsequent actions depend on the number of cooperators in the previous round (n_c).
   - If n_c >= m, players will continue cooperating (C). This encourages cooperation as long as the minimum threshold for success is met.
   - If n_c < m and the player has cooperated in the last action, they defect (D) to punish those who did not cooperate. This discourages non-cooperative behavior.
   - If n_c < m and the player has previously defected, they cooperate again (C). This allows for forgiveness and encourages future cooperation.

Pseudocode:
```python
def TTTA(n_players, m, k, round):
    players = {i for i in range(1, n_players + 1)}
    action = 'C'  # Cooperate initially
    n_c = 0  # Number of cooperators in the previous round
    payoff = 0  # Total payoff over r rounds

    while round <= r:
        if round == 1:
            n_c += 1 if players[round] == 'C' else 0
        elif action == 'C':
            n_c += 1 if players[round] == 'C' else 0
        else:
            n_c += 0 if players[round] == 'C' else 1

        if n_c >= m:
            payoff += (1 - action) + k
            action = 'C'
        elif action == 'C':
            action = 'D'
        elif action == 'D':
            action = 'C'

        round += 1

    return payoff
```

2. Handle edge cases:
   - In the first round, all players will cooperate (C) since they don't have a history to reference.
   - In the last round, players will base their decisions on the previous round's cooperation count (n_c), adhering to the Tit-for-Tat strategy.

3. Be collective:
   - By cooperating when the minimum threshold for success is met and punishing defection when it falls below that threshold, this strategy encourages collective behavior and fosters a sense of mutual trust among players.
   - Forgiveness is built in by allowing players who previously defected to cooperate again. This helps maintain cooperation even after temporary lapses in coordination or occasional mistakes.
'''

description_COLLECTIVE_368 = '''
 Strategy Name: Tit-for-Tat with Cooperative Adjustment (TTCA)

1. Decision Rules:
   - Initially cooperate in the first round (C_i = 1 for all i). This sets a positive tone and encourages reciprocity.
   - In subsequent rounds, if the number of cooperators in the previous round is less than m (denoted as lessThanM), defect (C_i = 0) to show disapproval. If the number of cooperators in the previous round is equal to or more than m (denoted as atLeastM), cooperate (C_i = 1).
   - If a player switches from cooperation to defection, they will cooperate again if the next round has atLeastM cooperators. This mimics forgiveness and encourages long-term partnerships.

2. Handling Edge Cases:
   - In the last round, always cooperate as there are no further rounds for retaliation.
   - In the first round, cooperate to start on a positive note.

3. Being Collective:
   - The strategy prioritizes cooperation whenever possible, aligning with a collective mindset by following the principle of "contribute when others do and reciprocate when they contribute."
   - Forgiveness is demonstrated through the adjustment rule which encourages long-term partnerships.

Pseudocode:
```python
def TTCA(n, m, k, round, history):
    # Initial cooperation in the first round
    if round == 1:
        return 1

    # History is a list of past rounds' cooperators count
    pastCooperators = history[-1]

    # If at least 'm' players have cooperated recently, cooperate
    if pastCooperators >= m:
        return 1
    else:
        # Otherwise, defect and remember the change in strategy for future rounds
        lastStrategyChangeRound = round
        return 0

    # Adjust strategy if player switched from cooperation to defection in the last round
    if round > lastStrategyChangeRound + 1:
        return 1
```
'''

description_COLLECTIVE_369 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules:
   - In the first round, cooperate to initiate a potential cooperative relationship.
   - For subsequent rounds, cooperate if the majority of players cooperated in the previous round, and defect otherwise.
   - If a player deviates from cooperation after the initial round, wait for them to return to cooperation before doing so again.

2. Handle edge cases:
   - In the last round, cooperate to maximize potential rewards regardless of the opponents' actions.
   - In the first round and when switching from defecting to cooperating after a deviation, cooperate to signal goodwill and encourage reciprocity.

3. Be collective:
   - The strategy maintains a "memory" of the opponents' cooperation history and makes decisions based on that memory, encouraging long-term mutual cooperation.

Pseudocode:
```python
class TFT_AC:
    def __init__(self, n, m, k, r):
        self.n = n
        self.m = m
        self.k = k
        self.r = r
        self.memory = [[0 for _ in range(r)] for _ in range(n)]  # nxr memory matrix to store opponent's cooperation history

    def play_round(self, round, opponents):
        my_action = COOPERATE if self.check_majority(opponents) else DEFECT
        for i, opp in enumerate(opponents):
            self.memory[i][round] = my_action
        return my_action

    def check_majority(self, opponents):
        cooperation_count = sum(1 for action in opponents if action == COOPERATE)
        return cooperation_count >= (self.m if len(opponents) >= self.m else len(opponents))
```
'''

description_COLLECTIVE_370 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?

Initially, start by cooperating in the first round (C_i, 1 = C). In subsequent rounds, copy the action of the previous partner's cooperation or defection:
- If partner cooperated (c_j, t > 1) -> cooperate (C_i, t = C)
- If partner defected (c_j, t > 1) -> defect (D_i, t = D)

This strategy encourages cooperation when partners also cooperate but retaliates against defection.

2. Handle edge cases - What do you do in the first round, last round, etc.?

For the first round (t=1), always cooperate since there is no history available. In the last round (t=r), consider the number of cooperators already in that round to determine the action:
- If m or more players have cooperated in the final round, continue cooperation (C_i, r = C)
- If fewer than m players have cooperated in the final round, defect (D_i, r = D)

This ensures that ATFT does not overly punish partners who switch to cooperation late in the game.

3. Be collective - Clearly align with the collective mindset

ATFT promotes a collective mindset by rewarding cooperation when others also cooperate and retaliating against defection while maintaining the possibility of forgiveness for future rounds. This approach encourages long-term cooperation within the group, aligning with the collective goals.

Pseudocode:

```
function ATFT(history, m, k, r):
  strategy = []
  history.append(C)  # Cooperate in the first round

  for t in range(1, r+1):
    partner_cooperated_t = countCooperatorsInHistory(history) >= m

    if t == 1:
      strategy.append(C)
    elif t == r:
      if partner_cooperated_t:
        strategy.append(C)
      else:
        strategy.append(D)
    else:
      partner_cooperated_t-1 = history[t-2] == C  # Check partner's action in previous round
      strategy.append((partner_cooperated_t-1 and partner_cooperated_t) or not partner_cooperated_t-1)

  return strategy
```
'''

description_COLLECTIVE_371 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT)

1. Decision Rules:
   - Initiate cooperation: Start by cooperating in the first round to foster a cooperative environment.
   - Respond to past actions: In each subsequent round, cooperate if the majority of players (excluding self) cooperated in the previous round; otherwise defect. This encourages reciprocity while still being responsive to the current situation.
   - Adaptive cooperative threshold (ACT): Gradually increase the required majority of cooperators needed for cooperation from m to m+1 after a series of successful rounds (defined below), and decrease it back to m after consecutive defections. This strategy is adaptive as it responds to changing opponent behaviours and encourages the development of long-term trust.

2. Handle Edge Cases:
   - First round: Cooperate to initiate cooperation.
   - Last round: Analyze the past rounds' majority and cooperate or defect accordingly based on the adaptive cooperative threshold.
   - Fewer than r rounds: Apply decision rules as normal, understanding that the total game payoff may not be calculated if fewer than r rounds are played.

3. Be Collective:
   - The TFT-ACT strategy is inherently collective as it promotes reciprocity and cooperation with other players, aligning with a collective mindset. By gradually adjusting the required majority of cooperators needed for cooperation, this strategy aims to foster long-term cooperation while being adaptive to a wide range of opponent behaviours.

Pseudocode:

```
def TFT_ACT(round, n, m, history):
  if round == 1:
    return 'C'  # Cooperate in the first round

  cooperators = count_cooperators(history) - 1  # Exclude self from counting

  if cooperators >= adaptive_threshold():
    return 'C'  # Cooperate if majority of players cooperated in the previous round
  else:
    return 'D'  # Defect otherwise

def adaptive_threshold(round):
  if consecutive_successes > threshold:  # Increase the required majority of cooperators
    threshold += 1
    consecutive_successes = 0
  elif consecutive_defections >= penalty_threshold:  # Decrease the required majority of cooperators
    threshold -= 1
    consecutive_defections = 0
  return threshold

def count_cooperators(history):
  cooperators = 0
  for round in history:
    if round == 'C':
      cooperators += 1
  return cooperators

def consecutive_successes():
  successes = 0
  for round in history[round - penalty_threshold:]:
    if round == 'C':
      successes += 1
    else:
      successes = 0
  return successes

def consecutive_defections():
  defections = 0
  for round in history[round - threshold:round - penalty_threshold]:
    if round == 'D':
      defections += 1
    else:
      defections = 0
  return defections
```

In this pseudocode, `consecutive_successes` and `consecutive_defections` functions are used to determine when to increase or decrease the adaptive cooperative threshold based on the number of successful (cooperative) rounds and consecutive defections. The `threshold`, `penalty_threshold`, and initial value for `consecutive_successes` and `consecutive_defections` can be tuned to optimize performance in various game settings.
'''

description_COLLECTIVE_372 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFT-A) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round t, if the number of cooperators in the previous round (t-1) was less than m, defect (D). Otherwise, cooperate (C) to encourage others who also cooperated in the previous round. To adapt to different opponent behaviours, introduce a tolerance level 'T' which allows for occasional deviations from cooperation:
   - If the number of cooperators in round (t-1) is greater than or equal to m and within T of the minimum required cooperators (m), cooperate. Otherwise, defect.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, all players start with no history, so the strategy defaults to cooperation for simplicity: cooperate (C). In the last round, since the game is repeated, treat it as any other round and follow the decision rules based on the previous round's outcome.

3. Be collective - Clearly align with the collective mindset
   The TFT-A strategy aims at fostering cooperation by rewarding and punishing opponents according to their past actions. This encourages long-term mutual benefit and promotes a collective mindset as players learn to cooperate when others do so as well. By having a tolerance level, the strategy also allows for flexibility in dealing with various opponent behaviours while maintaining its core objective of cooperation.

Pseudocode:
```
function TFT-A(n, m, k, r, t) {
  players = {1, 2, ..., n}
  history = empty matrix (r-1) x n
  tolerance_level = floor((n - m) / 2)

  function get_cooperators(t-1) {
    cooperators_count = 0
    for each player in players {
      if (history[t-1][player] == 'C') {
        cooperators_count++
      }
    }
    return cooperators_count
  }

  function play(t) {
    if (t == 1) {
      return 'C'
    } else {
      cooperators = get_cooperators(t-1)
      if (cooperators < m || Math.abs(cooperators - m) > tolerance_level) {
        return 'D'
      } else {
        return 'C'
      }
    }
  }

  for each round t from 1 to r {
    action = play(t)
    history[t-1] = players_actions in round (t-1)
  }
}
```
'''

description_COLLECTIVE_373 = '''
 Strategy Name: Tit-for-Tat with Adaptive Threshold (TFTA)

1. Decision Rules:
   - Initially (first round), cooperate to foster a cooperative environment and reduce uncertainty.
   - In subsequent rounds, observe the number of cooperators in the previous round. If the number of cooperators meets or exceeds the minimum threshold 'm', cooperate; otherwise, defect.
   - Adaptively adjust the threshold after each round based on the changing environment. Start with a high initial value (approximately n) and decrease it progressively over time if cooperation is consistently low. Conversely, increase the threshold when cooperation is high to maintain collaborative efforts. The threshold adjustment should be gradual to avoid drastic changes that may destabilize the ongoing game dynamics.

2. Edge Cases:
   - First Round: Cooperate (C) to initiate a cooperative cycle.
   - Last Round: Consider the previous round's cooperation level and make a decision accordingly based on the adaptive threshold.

3. Collective Mindset:
   - The TFTA strategy is designed with a collective mindset in that it encourages cooperation when the majority of players collaborate, while also punishing defection when cooperation is low. This approach aims to strike a balance between individual and collective success by adapting to the dynamic game environment.
   - By adjusting the threshold based on the ongoing game dynamics, the TFTA strategy demonstrates an ability to learn from other players' behaviors and respond accordingly, fostering a more cooperative gameplay experience in the long run.
'''

description_COLLECTIVE_374 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFTAC)

1. Decision Rules - TFTAC will cooperate in the first round and then mimic the previous action of each opponent for the subsequent rounds. If a player switches from cooperation to defection, TFTAC will also switch to defection in response. If an opponent defects, TFTAC will continue to defect until the opponent returns to cooperation. Once the opponent cooperates again, TFTAC will resume cooperating.

Pseudocode:

```python
def tftac(opponent_history):
    if round == 1:
        return "Cooperate"
    else:
        last_action = opponent_history[-1]
        if last_action == "Cooperate":
            return "Cooperate"
        elif last_action == "Defect":
            return "Defect"
```

2. Handle Edge Cases - In the first round, TFTAC cooperates as a goodwill gesture and to show a willingness to work together. In the last round or when the game reaches a predefined maximum number of rounds, TFTAC will revert to its initial strategy of mimicking opponents, allowing for potential changes in behavior towards the end of the game.

3. Be Collective - TFTAC encourages cooperation by cooperating first and then responding to the actions of others. By mimicking an opponent's previous action, TFTAC demonstrates a commitment to the collective interest and fairness. However, if an opponent defects, TFTAC will also defect as a means of punishment to discourage defection and promote cooperation in the future. This strategy allows for both collaboration and retaliation when necessary to maintain the collective mindset.
'''

description_COLLECTIVE_375 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFT-A)

1. Specify decision rules:
   - Cooperate on the first round (FristCooperate rule) to signal goodwill and promote cooperation.
   - In subsequent rounds, cooperate if at least m players cooperated in the previous round (CopyOthers rule). This aligns with the collective mindset as it follows the behavior of the majority.
   - If fewer than m players cooperated in the previous round (DefectPunish rule), defect to punish those who did not cooperate and encourage them to do better in future rounds.
   - In case of a tie, where exactly m players cooperated and others didn't, adopt the strategy of the player with the highest number of previous cooperative actions. This is done to reward frequent cooperators (FrequentCooperators rule).

2. Handle edge cases:
   - For the last round, adopt the strategy of the most recent opponent behavior (LastRound rule) as there will be no future rounds to punish or reward.
   - In case of a tie in the last round, simply copy the opponent's action from the previous round (TieLastRound rule).
   - For the first round, always cooperate (FristCooperate rule).

3. Be collective:
   The TFT-A strategy follows a collective mindset by adhering to the majority's behavior and encouraging continued cooperation through a reward system for those who contribute positively to the group project. At the same time, it punishes those who do not cooperate in an effort to promote collective success.

Pseudocode:
```python
def TFT_A(history, m, k):
  if len(history) == 0: # First round
    return 'C'

  opponentMoves = history[-1] # Get the moves of all opponents in the last round
  nb_coop = sum(opponentMoves) # Calculate the number of cooperators in the last round

  if nb_coop >= m: # If m or more players cooperated
    return 'C'
  elif len(history) == r: # Last round, use opponent's move from the previous round
    return history[-2][player]
  else: # In other cases, check if there was a tie
    nb_ties = sum([1 for moves in history[-1] if sum(moves) == m])

    if nb_ties > 0: # If there was a tie, return the move of the player with the most cooperative actions
      max_coops = -1
      max_player = None
      for i in range(n):
        coop_count = sum([1 for moves in history if moves[i] == 'C'])
        if coop_count > max_coops:
          max_coops, max_player = coop_count, i
      return history[-1][max_player]
    else: # If there was no tie, simply punish those who did not cooperate
      return 'D'
```
'''

description_COLLECTIVE_376 = '''
 Title: Tit-for-Tat Adaptive Strategy (TFT-AR) for Collective Risk Dilemma

1. Specify decision rules:
   - Initially Cooperate (C) in the first round to show good faith and encourage potential cooperation from other players.
   - In subsequent rounds, copy the action of the most frequent cooperators in the previous round(s). If there is a tie for the most cooperative player(s), copy their latest action.
   - If no cooperators were found in the previous round(s), defect (D) to match the actions of less cooperative players and protect personal interests.
   - In case of a change in strategy among opponents, adapt by switching strategies after observing two consecutive defections or cooperations from the opponent who had previously behaved differently.

2. Handle edge cases:
   - In the last round, cooperate (C) if more than m-1 opponents have cooperated in the previous round(s). This encourages cooperation and potentially higher total payoff even if the game does not continue.
   - In the first round, cooperate (C) as stated above.
   - If a player switches strategies, wait for two consecutive rounds before adapting to their new strategy. This ensures that the switch is intentional and not a fluke.

3. Be collective:
   - Pursue a strategy that balances individual interests with collective success by copying the actions of the most cooperative players in each round, encouraging continued cooperation.
   - Adapt to opponent strategies when necessary while prioritizing collective gains over individual payoffs.

Pseudocode for the TFT-AR strategy:

```
function TFT_AR(round, player_index, n, m, k, previous_round_actions) {
  if round == 1 {
    cooperate = true
  } else {
    most_cooperative_players = findMostCooperativePlayers(previous_round_actions)
    cooperate = (most_cooperative_players.length >= m)
  }

  if round == r {
    cooperate = (most_cooperative_players.length > m - 1)
  }

  if (previous_round_actions[player_index - 1] != cooperate) && (previous_round_actions[player_index - 1].length > 1) {
    if (previous_round_actions[player_index - 1][0] == 'C') && (cooperate == false) {
      cooperate = true
      switch_strategy = true
    } else if (previous_round_actions[player_index - 1][0] == 'D') && (cooperate == true) {
      cooperate = false
      switch_strategy = true
    }
  }

  if switch_strategy {
    if (cooperate == true) && (previous_round_actions[player_index - 1][0] == 'D') {
      cooperate = false
    } else if (cooperate == false) && (previous_round_actions[player_index - 1][0] == 'C') {
      cooperate = true
    }
  }

  return cooperate
}
```

This strategy should provide a robust and adaptive approach to the Collective Risk Dilemma, balancing individual payoffs with collective success while being flexible enough to handle various opponent strategies.
'''

description_COLLECTIVE_377 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Decision Rules:
   - Initially cooperate (C) in the first round to foster trust and cooperation.
   - In subsequent rounds, cooperate if at least a certain percentage (threshold) of players also chose to cooperate in the previous round. This threshold will be gradually adjusted based on historical data.
   - If the threshold is not met, defect (D) as a punishment for non-cooperative behavior.
   - The threshold for cooperation will increase over time if the average percentage of cooperators in past rounds exceeds a specific tolerance level (e.g., 60%). Conversely, it will decrease if the average falls below another tolerance level (e.g., 40%).

2. Handling Edge Cases:
   - In the first round, cooperate as previously mentioned.
   - In the last round, consider the current threshold and adjust it based on historical data before making a decision to cooperate or defect.

3. Aligning with Collective Mindset:
   - Prioritize long-term success by maintaining cooperation when others do so but punishing non-cooperative behavior as a deterrent for future defections.
   - Adapt the cooperation threshold dynamically based on past experiences, allowing the strategy to respond and adjust to different opponent behaviors while promoting stable cooperative outcomes.

Pseudocode:
```python
strategy = TitForTatWithAdaptiveThreshold(n, m, k, tolerance_high=60, tolerance_low=40)

def TitForTatWithAdaptiveThreshold(n, m, k, tolerance_high, tolerance_low):
    threshold = m / n  # initial cooperation threshold
    history = []  # store previous rounds' cooperators percentage

    def play_round():
        if len(history) == 0:  # first round, always cooperate
            return 'C'

        cooperators_percentage = sum(history[-r:]) / r * 100  # calculate average cooperation percentage in the last r rounds

        if cooperators_percentage > tolerance_high:  # adjust threshold upward if cooperation is common
            threshold += (cooperators_percentage - tolerance_high) / 100
        elif cooperators_percentage < tolerance_low:  # adjust threshold downward if cooperation is rare
            threshold -= (tolerance_low - cooperators_percentage) / 100

        return 'C' if cooperators_percentage >= threshold else 'D'  # play action based on calculated threshold

    return play_round  # return the strategy as a function to be called for each round
```
'''

description_COLLECTIVE_378 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for Collective Risk Dilemma

1. Decision Rules:
   - Initially Cooperate (C): In the first round, cooperate to show willingness to collaborate and build trust. This sets a cooperative tone for subsequent rounds. `if round == 1 then action = C`

   - Reciprocity: Cooperate if the majority of players cooperated in the previous round, defect otherwise. This encourages cooperation when it is beneficial for the group while also punishing defection. `for i in range(2, r+1): if (number_of_cooperators in round i-1) >= m then action = C else action = D`

   - Forgiveness: In the last round, cooperate regardless of previous actions to maximize potential rewards. `if round == r then action = C`

2. Edge Cases:
   - First Round: Cooperate as described above (C)
   - Last Round: Cooperate (C)
   - Transition: In between the first and last rounds, follow reciprocity rule (ATfT)

3. Collective Mindset:
   - The strategy encourages cooperation when it is beneficial for the group by rewarding cooperative behavior and punishing defection. It also maintains a flexible approach to account for various opponent behaviors.
   - ATfT fosters a collective mindset as it takes into consideration the actions of other players and adjusts its own actions based on the majority decision in each round, promoting group harmony and shared success when possible.

Pseudocode:
```
def Adaptive_Tit_for_Tat(round, number_of_players, minimum_cooperators, reward_factor):
  if round == 1:
    action = 'C' (Cooperate)
  elif round == number_of_rounds:
    action = 'C' (Cooperate)
  else:
    if number_of_cooperators in previous round >= minimum_cooperators:
      action = 'C' (Cooperate)
    else:
      action = 'D' (Defect)

  return action
```
'''

description_COLLECTIVE_379 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate to demonstrate goodwill and encourage reciprocation. This is represented by the function `cooperate_init()`.
   - In subsequent rounds, analyze the behavior of other players from the previous round using the function `analyze_opponents()`. If most opponents cooperated in the previous round (more than m-1), then cooperate as a positive response (`cooperate_positive_response()`). If fewer than m opponents cooperated, defect to punish non-cooperation (`defect_punishment()`).
   - If an opponent who previously cooperated switches to defection, wait for a number of rounds equal to the number of times they have previously defected before resuming cooperation. This is represented by the function `wait_for_reconciliation()`.
   - In the final round, cooperate regardless of opponents' behavior in the last round (since there are no subsequent rounds for retaliation or reconciliation).

Pseudocode:
```python
def TFT_AC(round, opponent_history):
  if round == 1:
    cooperate = cooperate_init() # cooperate initially
  else:
    cooperate = analyze_opponents(opponent_history)
    if cooperate > m-1: # most opponents cooperated in the previous round
      cooperate = cooperate_positive_response() # cooperate as a positive response
    elif cooperate < m: # fewer than m opponents cooperated, punish non-cooperation
      cooperate = defect_punishment()
    else: # some opponents cooperated and some didn't; analyze opponent behavior to decide if cooperation is warranted
      cooperate = wait_for_reconciliation(opponent_history)
  return cooperate
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, as mentioned earlier, cooperate to demonstrate goodwill and encourage reciprocation.
   - In the last round, cooperate regardless of opponents' behavior in the previous round (since there are no subsequent rounds for retaliation or reconciliation).

3. Be collective - Clearly align with the collective mindset
   - TFT-AC aims to foster cooperation by mimicking other players' behaviors and punishing defection. If most opponents cooperate, it will cooperate as well. If an opponent who previously cooperated switches to defection, it will wait for a number of rounds equal to the number of times they have previously defected before resuming cooperation. This collective strategy encourages sustained cooperation among players while also allowing for forgiveness and reconciliation after periods of non-cooperation.
'''

description_COLLECTIVE_380 = '''
 Strategy Name: Tit-for-Tat (TFT) with Adaptive Cooperation Threshold (ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Start by cooperating in the first round (C,1). This allows for potential trust building and demonstrates a willingness to collaborate.
   - For subsequent rounds, observe the number of cooperators from the previous round (n_c_prev) and compare it to the minimum cooperation threshold (m). If n_c_prev >= m, cooperate in the current round (C,t). Otherwise, defect in the current round (D,t).
   - To be more adaptive, implement an updating mechanism for the cooperation threshold. Begin with a high threshold (M) initially. After each round, update the threshold based on whether the minimum cooperation threshold was met and the payoff earned. If n_c_prev >= m and payoff >= M, decrease the threshold by 1. Otherwise, increase it by 1 (up to a maximum of n-1).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate (C,1) as mentioned above.
   - For the last round, consider the total payoff earned over the game so far and whether the threshold for cooperation has been met consistently. If the threshold has been consistently met or exceeded, continue cooperating in the last round (C,r). Otherwise, defect in the last round (D,r).

3. Be collective - Clearly align with the collective mindset
   - This strategy is inherently collectively-minded as it encourages cooperation when others also cooperate and punishes defection when others are cooperating. By following the rules of the game and adapting to the behavior of other players, this strategy demonstrates a willingness to work together for mutual benefit.

Pseudocode:

```
Initialize: M = (n-1)  # Set initial cooperation threshold
n_c_prev = 0           # Initialize previous number of cooperators
payoff_total = 0       # Initialize total payoff earned

For each round t from 1 to r:
    If t == 1:                   # First round, always cooperate
        action(t) = C

    Else if n_c_prev >= m:      # Cooperate when threshold met
        action(t) = C
        payoff_total += payoff(t)
        If payoff(t) >= M:       # Adjust cooperation threshold
            M -= 1
            If M < 0: M = 0

    Else:                        # Defect when threshold not met
        action(t) = D
        payoff_total += payoff(t)
        If payoff(t) >= M:       # Adjust cooperation threshold
            M -= 1
            If M < 0: M = 0

    n_c_prev = count cooperators in previous round
```
'''

description_COLLECTIVE_381 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Decision Rules:
   - Initially Cooperate (C) in the first round to signal trust and cooperation.
   - In subsequent rounds, cooperate if at least m players cooperated in the previous round; otherwise defect (D).
   - If a player switches from C to D, continue cooperating until the same player switches back to C for at least one round.
   - If a player consistently defects (more than k times) during the game, switch to defecting permanently against that player.

2. Handling Edge Cases:
   - In the last round, always cooperate regardless of previous actions since there are no future rounds for retaliation or reward.
   - In the first round, cooperate as mentioned above to initiate a cooperative relationship.
   - If less than m players cooperate in the first few rounds but eventually m players start cooperating, switch to cooperating with all m players and defect against non-cooperators until they switch back to cooperation or reach the consistent defection threshold (more than k times).

3. Collective Mindset:
   - The strategy encourages cooperation by initially cooperating and then adapting based on other players' actions, fostering a collective mindset of mutual trust and reciprocity.
   - If a player consistently defects, the strategy punishes them for their actions but is willing to forgive if they return to cooperation. This promotes the formation of long-term cooperative relationships when possible.

Pseudocode:

```python
def ATFT(n, m, k, r):
    players = list(range(1, n + 1))
    history = {player: [] for player in players}

    def get_cooperators(history):
        return [player for player in history if sum(1 for action in history[player] if action == 'C') >= m]

    def switch_back(player, cooperators, k):
        if len(cooperators) <= 1 or (player not in cooperators and len(history[player]) > k):
            return False
        for round in history[player][-k:]:
            if round == 'C':
                return True
        return False

    def play_round(r, history):
        cooperators = get_cooperators(history)
        action = 'C' if r == 1 else (('C' if any(switch_back(player, cooperators, k)) else 'D') for player in players)
        for i, player in enumerate(players):
            history[player].append(action[i])
        return history

    history = play_round(1, history)  # First round
    for round in range(2, r + 1):
        history = play_round(round, history)
    return history
```
'''

description_COLLECTIVE_382 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules:
   - Initiation: Cooperate in the first round to demonstrate a cooperative intent (C).
   - Reciprocity: If a player cooperates, cooperate back in the next round (C).
   - Punishment: If a player defects, defect against them for the next two rounds (D, D). After that, revert to reciprocating their behavior (if they continue to cooperate, cooperate; if they continue to defect, defect).
   - Forgiveness: After a string of defections and cooperation, return to the initial cooperative state (C) as a fresh start.

Pseudocode:

```python
def ATFT(round, history, m, k):
  if round == 1:
    action = 'C'
  else:
    opponent_action = history[-1]
    if opponent_action == 'D':
      if round < 3:
        action = 'D'
      elif round > (3 + len(history) % 3): # New cycle, forgive past actions
        action = 'C'
    else:
      action = opponent_action # Reciprocate the opponent's action

  if sum(history) < m: # If not enough players cooperated in history, stay selfish
    action = 'D'

  return action
```

2. Handle edge cases:
   - First round: Cooperate to demonstrate a cooperative intent (C).
   - Last round: Make the decision based on the most recent opponent action.
   - Cycles of three consecutive defections followed by cooperation: Forgive past actions and return to the initial cooperative state (C).

3. Be collective:
   - The strategy seeks to align with a collective mindset by prioritizing cooperation when it benefits the group (minimum threshold is met), but also being willing to punish defection for short periods to deter long-term selfish behavior.
   - By forgiving past actions after cycles, the ATFT strategy promotes the possibility of reconciliation and renewed cooperation.
'''

description_COLLECTIVE_383 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Decision Rules:
   - Initial cooperation (C) in the first round to establish a cooperative environment.
   - In subsequent rounds, cooperate if the majority of players cooperated in the previous round, and defect otherwise. This encourages cooperation but also punishes defection.
   - The definition of "majority" adapts over time based on the average number of cooperators across all previous rounds (average_cooperators). The threshold for cooperating is set to be a fraction (fraction_threshold) of the average number of cooperators in the past r rounds.
   - If the current round is the last round, always cooperate as there's no future interaction to punish defection.

2. Edge Cases:
   - In the first round, cooperate (C).
   - In the last round, always cooperate (C) regardless of previous actions by others.

3. Collective Alignment:
   - The ATFT strategy follows a collective mindset as it rewards cooperation and punishes defection while considering the overall actions of all players in the game. By adapting the majority threshold based on past cooperators, the strategy encourages long-term collaboration among players.

Pseudocode for Adaptive Tit-for-Tat (ATFT):

```python
def ATFT(r, m, n, k, history):
    average_cooperators = sum([sum(row) for row in history[:r]])) / r
    fraction_threshold = average_cooperators * 0.5  # Adjust this value to make the strategy more forgiving or strict

    if round == 1:
        action = 'C'  # Initial cooperation
    elif round == r:
        action = 'C'  # Last round, always cooperate
    else:
        num_cooperators = sum(history[round-1])
        if num_cooperators >= m and num_cooperators > fraction_threshold * n:
            action = 'C'  # Cooperate if majority cooperated in the previous round
        else:
            action = 'D'   # Defect otherwise

    return action
```

This strategy balances cooperation and punishment, adapts to varying group sizes and required minimum cooperators, and encourages long-term collaboration among players. By using a fraction of the average number of past cooperators as the threshold for cooperation, it allows for some flexibility in dealing with less cooperative opponents while still encouraging cooperation overall.
'''

description_COLLECTIVE_384 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to initiate a cooperative relationship (C).
   - For subsequent rounds, evaluate the average cooperation rate of other players (CR) and compare it against the Adaptive Cooperation Threshold (ACT):
     - If CR >= ACT, cooperate (C).
     - If CR < ACT, defect (D).
   - Periodically adjust the ACT based on recent performance to maintain a balance between cooperation and defection.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as mentioned above.
   - In the last round, cooperate if the current average cooperation rate is equal to or greater than the ACT; defect otherwise.
   - In all other rounds, follow the decision rule based on the average cooperation rate and ACT.

3. Be collective - Clearly align with the collective mindset:
   - The TFT-ACT strategy aims to maintain a cooperative relationship while protecting itself from frequent defection by adjusting the cooperation threshold accordingly.
   - By following this strategy, the AI will attempt to build trust and foster cooperation within the group. However, it will not compromise its own payoff too much when faced with uncooperative opponents.

Pseudocode for TFT-ACT:

```python
def tft_act(n, m, k, r):
    rounds = list(range(1, r + 1))
    cooperation_threshold = [None] * r
    average_cooperation_rate = 0.0

    def adjust_threshold(current_round):
        if current_round == 1:
            return 1.0
        else:
            return (cooperation_threshold[current_round - 2] + cooperation_threshold[current_round - 1]) / 2.0

    def calculate_payoff(own_action, average_cooperators):
        if own_action == 'C':
            payoff = 0 if average_cooperators < m else k
        else:
            payoff = 1
        return payoff

    for current_round in rounds:
        if current_round == 1:
            action = 'C'
        else:
            threshold = adjust_threshold(current_round)
            average_cooperators = sum([action == 'C' for action in cooperation_decisions[:current_round]) / current_round
            if average_cooperation_rate > threshold:
                action = 'C'
            else:
                action = 'D'
        cooperation_decisions.append(action)
        cooperation_threshold.append(threshold)
        payoff = calculate_payoff(action, average_cooperators)
        total_payoffs[current_round] += payoff

    return cooperation_decisions, total_payoffs
```

This pseudocode implements the TFT-ACT strategy. The `cooperation_decisions` list stores the decisions made during each round, and the `total_payoffs` list stores the total payoff earned over all rounds. You can implement this strategy in any programming language of your choice.
'''

description_COLLECTIVE_385 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initialize cooperation in the first round (C).
   - For subsequent rounds, repeat the action of the previous partner if they cooperated or defected in the last round. If the partner's action changes, wait for two more rounds to observe their new behavior before responding. This approach promotes cooperation while also being responsive to partner's strategies.

Pseudocode:
```
function TFT-AC(partner_history, n, m, k, r):
  history = [C] # initialize with cooperation in the first round
  for t in range (1, r):
    if len(history) < t: # edge case: first round
      action = C
    else:
      partner_action = history[t-1] # last partner's action
      if t <= m + 1: # initial cooperation phase
        action = C
      elif t >= r - m: # endgame and close to the threshold
        action = C
      else: # standard game
        if partner_action == C:
          action = C
        elif partner_action == D:
          if len(history) < m + 1: # waiting period before reacting
            action = history[t-1]
          else:
            action = D
      history.append(partner_action) # update history for next round

  return action
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate to initiate partnership (C).
   - In the last round, cooperate if the current situation is close to the minimum cooperation threshold (r-m rounds have passed and m or more players need to cooperate for success).

3. Be collective - Clearly align with the collective mindset
   - The strategy encourages long-term cooperation by mimicking the partner's behavior and only punishing defectors if they consistently fail to cooperate. This promotes mutual understanding, trust, and cooperation between players in a group setting.
'''

description_COLLECTIVE_386 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules:
   - In each round, player evaluates cooperation based on the previous round's total cooperators count (C_total).
   - If C_total >= m in the last r rounds, cooperate (C).
   - If C_total < m in the last r rounds, defect (D).
   - In all other cases, repeat past action: if played C in the previous round, cooperate; if played D, defect.

2. Handle edge cases:
   - First round: Play randomly with equal probability of cooperating or defecting to initiate a cooperative or non-cooperative trend.
   - Last round: Since payoffs are cumulative over r rounds, the strategy will follow the general rules but may not reach the m threshold due to insufficient previous rounds. In this case, it will continue with its current trend (i.e., if it has been cooperating, it will cooperate in the last round; otherwise, defect).
   - Subsequent rounds: As long as r > 1, any round that is not the first or the last one follows the general rules.

3. Be collective:
   - The ATFT strategy encourages cooperation when other players are also cooperating and defects when others have been non-cooperative. It strives for a balance between self-interest (defecting) and group interest (cooperating).
   - By following past actions, the ATFT strategy promotes mutual trust and consistency, which are essential components of collective mindsets.

Pseudocode:

```python
def AdaptiveTitForTat(n, m, k, r, history):
    player_action = "C" if random() < 0.5 else "D" # Randomly decide initial action
    total_cooperators = 0
    payoffs = []

    for round in range(1, r+1):
        if round == 1:
            past_action = player_action
        elif round == r:
            if total_cooperators < m * (r - 1):
                past_action = "D"
            else:
                past_action = "C"
        else:
            past_action = history[round-1]["player_action"]

        if past_action == "C":
            player_action = "C"
            total_cooperators += 1
        elif past_action == "D":
            player_action = "D"
            total_cooperators = 0

        payoff = (1 - int(player_action == "C")) if total_cooperators < m else (1 - int(player_action == "C")) + k
        payoffs.append({"round": round, "payoff": payoff})

    return payoffs
```
'''

description_COLLECTIVE_387 = '''
 Strategy Name: Adaptive Tit-for-Tat with Risk Aversion (ATfTra)

1. Decision Rules:
   - In every round, players compare the ratio of cooperators to the minimum cooperators needed (m) in the previous round. This ratio is calculated as R = (number of cooperators in the last round) / m.
   - If R < 0.5 (less than half of the required number cooperated), play "Defect" (D). This ensures a minimum level of cooperation is maintained.
   - If R ≥ 0.5, players calculate an adjusted ratio by considering the reward factor k: Adjusted R = R * k. If Adjusted R > 1, play "Cooperate" (C); otherwise, play "Defect." This reward aversion encourages cooperation when it is beneficial and penalizes defection if too many others are doing so.

2. Handling Edge Cases:
   - First Round: Players should cooperate to establish a normative behavior, assuming others will do the same. In this case, Adjusted R = 0 since there were no previous rounds.
   - Last Round: Players should consider the total payoff over the rounds and follow the decision rules accordingly.
   - If a player encounters an empty list (no history) in the first round or when calculating adjusted R, they should cooperate initially and use average R for future calculations instead of considering an empty list as 0.

3. Collective Mindset:
   - The ATfTra strategy fosters cooperation by incentivizing players to follow a reciprocal behavior while remaining adaptive to the other players' actions. By punishing defection when it is prevalent, the strategy encourages long-term cooperation for mutual benefit, aligning with the collective mindset.
'''

description_COLLECTIVE_388 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   The ATFT strategy in the Collective Risk Dilemma will start by cooperating in the first round (C_i=1), mimicking the cooperative spirit of the game. For subsequent rounds, the strategy will follow these conditions:

   - If a player has been cooperated with in the previous round, return the favor and also cooperate (C_i=1).
   - If a player has defected in the previous round, defect in the current round as well (C_i=0), signifying a "punishment". However, to allow for forgiveness, if five consecutive defections occur from an opponent, the strategy will revert to cooperating again.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, the strategy cooperates as a gesture of goodwill (C_i=1). In the last round, since the game is repeated, the strategy will behave as it does during regular rounds based on its history with other players.

3. Be collective - Clearly align with the collective mindset
   The ATFT strategy is designed to foster a sense of collaboration and reciprocity among players. By cooperating when others do so and defecting when they do not, the strategy demonstrates a willingness to contribute to the common project while simultaneously encouraging the same behavior from other players. This approach aims to create a sustainable balance between cooperation and defection that aligns with the collective mindset of the game.

Pseudocode:
```
function AdaptiveTitForTat(i, history_with_player_j):
  if round == 1:
    return C (Cooperate)
  else:
    previous_action = history_with_player_j[-1]
    if previous_action == C:
      return C (Cooperate)
    elif previous_action == D and number_of_consecutive_defections < 5:
      return D (Defect)
    elif previous_action == D and number_of_consecutive_defections >= 5:
      return C (Cooperate)
```
'''

description_COLLECTIVE_389 = '''
 Strategy Name: Adaptive Tit-for-Tat with Threshold (ATT)

1. Decision Rules:
   - In each round, calculate the number of cooperators from the previous round and compare it to the minimum threshold (m). If more than m players cooperated in the previous round, the ATT strategy will also cooperate. If exactly m players cooperated, the decision is based on whether the ATT strategy itself cooperated in the previous round: if it did, it will cooperate again; if it did not, it will defect. If fewer than m players cooperated in the previous round, the ATT strategy will defect.

   Pseudocode for deciding action in a single round (i_cooperated is 1 if player i cooperated in the previous round, and 0 otherwise):

   ```python
   if cooperator_count >= m:
       if i_cooperated:
           return Cooperate
       else:
           return Defect
   elif i_cooperated:
       return Cooperate
   else:
       return Defect
   ```

2. Handling Edge Cases:
   - In the first round, all players defect as there is no history to consider.
   - In the last round, the decision is based on the previous round's cooperator count and whether the ATT strategy cooperated in the second-to-last round (as per the decision rules).

3. Being Collective:
   - The ATT strategy aligns with the collective mindset by punishing defectors when more than m players should have been cooperating, but not unnecessarily punishing them in other scenarios where fewer than m players are cooperating. By doing so, it encourages cooperation and discourages excessive defection among the group.

   Note: In a tournament setting with multiple AI systems using different strategies, the success of the ATT strategy will depend on the behavior of its opponents, as well as the specific parameter values for n, m, k, and r.
'''

description_COLLECTIVE_390 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - In each round, TFT-ACT cooperates if the number of previous cooperators is greater than or equal to the minimum cooperation threshold (m). Otherwise, it defects.
   - If the current round is the first round or there is no past data, TFT-ACT cooperates.
   - Adaptively adjust the cooperation threshold based on the average cooperation rate from the most recent 'ThresholdAdjustmentRounds' rounds.

2. Handle edge cases:
   - In the first round, TFT-ACT cooperates as there is no past data.
   - In the last round, TFT-ACT uses the current cooperation threshold to make a decision and does not adjust it after the game ends.

3. Be collective:
   - By basing its decisions on the number of previous cooperators, TFT-ACT promotes a cooperative environment that encourages collective success.
   - The strategy is robust as it responds to the behaviour of other players by adapting its cooperation threshold based on their actions. This adaptability makes it more flexible and capable of aligning with various opponent behaviours.

Pseudocode:

```
class TFT_ACT:
  def __init__(self, n, m, r, ThresholdAdjustmentRounds=int(r/10)):
    self.n = n
    self.m = m
    self.r = r
    self.ThresholdAdjustmentRounds = ThresholdAdjustmentRounds
    self.cooperation_threshold = 0.5 * (n - 1) + 1
    self.previous_cooperators_count = [0] * r

  def update_round(self, round_number):
    if round_number == 1:
      return 'C'

    cooperators_in_this_round = 0
    for i in range(n):
      if action[i] == 'C':
        cooperators_in_this_round += 1

    if cooperators_in_this_round >= self.cooperation_threshold:
      self.previous_cooperators_count[round_number - 1] = 1
    else:
      self.previous_cooperators_count[round_number - 1] = 0

    if round_number % self.ThresholdAdjustmentRounds == 0:
      self.cooperation_threshold = int(sum(self.previous_cooperators_count[-self.ThresholdAdjustmentRounds:-1]) / self.ThresholdAdjustmentRounds * (n - 1) + 1)

    return 'C' if sum(self.previous_cooperators_count[-self.ThresholdAdjustmentRounds:]) >= self.m else 'D'
```

This pseudocode initializes a TFT-ACT strategy with the specified parameters, updates its cooperation threshold based on the number of previous cooperators, and makes decisions based on whether the number of previous cooperators is greater than or equal to the current cooperation threshold. The strategy is also flexible as it can adaptively adjust the cooperation threshold based on the average cooperation rate from the most recent ThresholdAdjustmentRounds rounds.
'''

description_COLLECTIVE_391 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Decision Rules:
   - Initially cooperate (C) in the first round to foster cooperation and goodwill.
   - In subsequent rounds, if a player cooperated in the previous round (c_{i-1} = 1), also cooperate (C). If a player defected (c_{i-1} = 0), defect (D) in return as a punishment for non-cooperation.
   - After punishment, revert to cooperation on the next round if the opponent cooperates (C). Maintain defection (D) if they continue to defect.

2. Edge Cases:
   - In the last round, since the game is repeated and there are no future rounds to punish or forgive, TfTA will always cooperate to maximize potential rewards.
   - In the first round, as mentioned above, TfTA starts by cooperating.

3. Collective Mindset:
   - TfTA aims to build and maintain trust with other players while being vigilant against defection.
   - By reciprocating cooperation with cooperation and punishment with punishment, TfTA encourages long-term stable relationships.
  
Pseudocode:

```python
def tit_for_tat_adaptive(round, opponent_history):
  if round == 1:
    return 'C'  # Cooperate in the first round

  if opponent_history[-1] == 'C':
    return 'C'  # Cooperate when opponent cooperated last round
  else:
    return 'D'  # Defect when opponent defected last round
```
'''

description_COLLECTIVE_392 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules:
   - In the first round (t=1), cooperate (C). This sets a cooperative tone for the game and provides a chance to build trust with other players.
   - For subsequent rounds (2 ≤ t ≤ r):
     a) If an opponent cooperated in the previous round, reciprocate by cooperating in the current round.
     b) If an opponent defected in the previous round, also defect in the current round as retaliation. This punishes defection and discourages repetition of such actions.
   - To avoid unilateral cooperation when there's no response from opponents, implement a threshold for consecutive cooperative moves by opponents. If a player has not defected for 'x' rounds, they will start defecting to ensure the game remains fair.

2. Handle edge cases:
   - In the last round (t=r), cooperate regardless of an opponent's previous action as the game is ending and accumulated payoffs are more important than enforcing a specific strategy.
   - In case of no opponents responding, start defecting after 'x' rounds to avoid being exploited.

3. Be collective:
   - Maintain a history buffer to store the actions of each opponent for the specified number of previous rounds (y). This memory allows the strategy to reciprocate and adapt based on opponent behavior.
   - Cooperate with opponents who exhibit cooperative tendencies, but retaliate against those who defect consistently. This collective approach encourages cooperation while also penalizing defection to maintain a fair game environment.

Pseudocode:
```
Strategy TFT-AC:
  Input: n, r, m, k, x, y (initialization constants)
  Initialize history buffers H[1..n] of length y for each opponent
  For each round t from 1 to r:
    For each opponent i:
      If first round or opponent cooperated last round: Cooperate (C)
      Else if opponent defected last round and consecutive cooperation count > x: Cooperate (C)
      Else: Defect (D)
    Update history buffer H[i] with current action of opponent i
  For the last round, cooperate regardless of opponent's previous action.
```
'''

description_COLLECTIVE_393 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TFT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?

   In each round, TFT-A decides to cooperate or defect based on its own past actions and the number of cooperators in the previous round. The strategy starts by cooperating in the first round (c_i = 1) and then mimics the average cooperation rate of the most recent history of n-1 rounds.

   Pseudocode:
   ```
   function TFT-A(history, m, k, n):
       if round == 1:
           return 1 (cooperate)

       cooperator_count = count cooperators in history[-n+1:-1]
       average_cooperation = cooperator_count / (n - 1)

       if average_cooperation >= m:
           return 1 (cooperate) if last action was cooperate, otherwise return 0 (defect)
       else:
           return 0 (defect)
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?

   TFT-A maintains a history buffer of n-1 rounds to avoid considering outdated information and adapt quickly to changing opponent behaviors. The strategy does not handle any specific edge cases as it is designed to be robust and flexible for various game conditions.

3. Be collective - Clearly align with the collective mindset

   TFT-A encourages cooperation by following the majority of cooperators in the previous n-1 rounds. By doing so, the strategy aims to promote a collective mindset where cooperation is rewarded when it benefits the majority of players. This adaptive approach allows TFT-A to adapt to different opponent behaviors while maintaining its core principle of promoting cooperation.
'''

description_COLLECTIVE_394 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - Initiate cooperation in the first round (C). This sets a positive tone for potential future collaborations.
   - In subsequent rounds, cooperate if at least m players cooperated in the previous round. If fewer than m players cooperated, defect (D) to penalize those who did not comply with the emerging cooperative norm.
   - Modify the strategy's response after the last m-1 defections from a player. Once a player has consecutively defected m-1 times, consider this as a sign of uncooperative behavior and switch to a permanent defect (D) towards that player while still cooperating with other players who comply with the emerging norm.

2. Handle Edge Cases:
   - In the first round (t=1), play C as described above.
   - In the last round (t=r), evaluate whether playing C or D would result in a higher payoff based on the current game state. If cooperating with at least m players still guarantees the higher payoff, choose to cooperate (C). Otherwise, defect (D) to maximize individual rewards.

3. Be Collective:
   - Align with the collective mindset by fostering a long-term cooperative approach while also being prepared to punish noncompliant players to protect the collective interests. The strategy aims to build trust and cooperation among players while also maintaining robustness against uncooperative behaviors.
   - If a player continually defects, the strategy adapts by switching to a permanent defection towards that player. This prevents repeated exploitation of the collective good and encourages other players to cooperate.

Pseudocode:
```
def TFT_AC(t, r, m, k, history, opponents):
  if t == 1:
    action = 'C' # Cooperate in the first round
  elif len(history[opponents[i]]) < m-1:
    if all(history[opponent][t-1] == 'C' for opponent in opponents) or (len(history[opponents[i]]) >= m-1 and history[opponents[i]][t-1] != 'D'):
      action = 'C' # Cooperate if at least m players cooperated last round or if player has not consecutively defected more than m-1 times
    else:
      action = 'D' # Defect if less than m players cooperated last round or if player has consecutively defected m-1 times
  else: # Last round (t=r)
    if sum(history[opponent] == 'C' for opponent in opponents if opponent != opponents[i]) >= m:
      action = 'C' # Cooperate if at least m players are still cooperating
    else:
      action = 'D' # Defect to maximize individual rewards
  return action
```
'''

description_COLLECTIVE_395 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, starting with t=1, player i follows these steps:

a. If t=1 (first round), player i cooperates (C). This is an initial gesture of goodwill to foster cooperation.
b. In subsequent rounds, player i observes the total number of cooperators (m_t) in the previous round t-1. If m_t >= m, player i also cooperates. Otherwise, player i defects.
c. Player i remembers the opponent's action from the previous round (opponent_action_{t-1}) and adapts to it in the following way:
   - If opponent_action_{t-1} = C (cooperation), player i will cooperate if m_t >= m; otherwise, defect.
   - If opponent_action_{t-1} = D (defection), player i will defect unless m_t > m+1. In this case, player i punishes the opponent by defecting but is willing to forgive and cooperate in the next round.

2. Handle edge cases - What do you do in the first round, last round, etc.?

a. First round (t=1): Cooperate unconditionally as a sign of goodwill.
b. Last round (t=r): Follow regular decision rules based on m_t-1 observations from round t-1. However, if the strategy is in the punishment phase due to opponent's previous defection (m_t < m), player i may choose to cooperate for a chance at reconciliation before the end of the game.
c. Subsequent rounds: Use regular decision rules with the addition of a forgiveness mechanism as described in section 1c.

3. Be collective - Clearly align with the collective mindset

The TFTAC strategy aims to maintain cooperation by adhering to a simple set of rules: cooperate when others do, defect only when others repeatedly fail to cooperate. This approach promotes mutual trust and encourages long-term cooperation while providing room for forgiveness and reconciliation. The strategy is designed to align with the collective mindset by incentivizing players to behave cooperatively whenever possible, fostering a sense of unity and shared goals within the group.
'''

description_COLLECTIVE_396 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - Initial Round (t=1): Cooperate (C). Establish a cooperative starting point to facilitate potential long-term collaborations.
   - Subsequent Rounds (t>1):
     - If in the previous round (t-1), the strategy also cooperated, then cooperate again (C). This mimics trust and encourages reciprocation.
     - If the strategy defected (D) in the previous round, then defect as well (D). This punishes defection to maintain self-interest while deterring repeated exploitation.
     - If the number of cooperators last round is greater than or equal to m, increase the likelihood of cooperation for the next round by a factor of `g`, where `0 < g < 1`. This reward-punishment system encourages collective behavior. (Pseudocode: `if prev_cooperators >= m then g = g * RewardFactor else g = g * PunishmentFactor`)

2. Handle Edge Cases:
   - Last Round (t=r): If cooperating could lead to more payoff than defecting, cooperate (C). This maximizes the total game payoff for the last round.
   - First Round (t=1) and Early Game (t<m): Cooperate (C). Establish a cooperative starting point to facilitate potential long-term collaborations.

3. Be Collective:
   - Follow the collective mindset by rewarding cooperation and punishing defection, while also adapting to the collective behavior of others through the use of `g`. This encourages reciprocity and cooperation in the long term.
   - The strategy does not rely on communication or coordination with other strategies, ensuring its robustness across a wide range of opponent behaviors.
'''

description_COLLECTIVE_397 = '''
 Strategy Name: Tit-for-Tat Plus (TFT+)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, if a player has encountered cooperation from m-1 other players in the previous round, they will cooperate. Otherwise, they will defect. This rule encourages cooperation when it seems beneficial for the group and retaliates against defection to maintain trust within the group.

   Pseudocode:
   ```
   function playRound(previous_cooperation_count):
       if previous_cooperation_count >= m - 1:
           return Cooperate
       else:
           return Defect
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, since there is no past cooperation to base decisions on, players will start by cooperating to foster a cooperative environment. In the last round, players should consider the total payoff accumulated over the game and decide whether continuing cooperation or defecting would yield higher rewards based on their current payoff and the k factor.

3. Be collective - Clearly align with the collective mindset
   By following Tit-for-Tat Plus rules, players are promoting a cooperative environment while maintaining flexibility to adapt to changing conditions in the game, making it more likely for them to succeed together. The strategy encourages cooperation among players and retaliates against defection to maintain trust, which aligns with the collective mindset.

   To further reinforce the collective mindset:
   - Players can keep track of the overall state of cooperation in the group by maintaining a running tally of previous cooperation counts for each round. This will help players make informed decisions about whether or not to cooperate based on the current state of the game.
   - In case of repeated interactions, players can adjust their strategies according to the trends they observe in other players' behavior, favoring cooperation when it seems beneficial and retaliating against defection to maintain trust.

This strategy strikes a balance between cooperation and self-interest, making it adaptive and robust to a wide range of opponent behaviors while fostering a cooperative environment among players.
'''

description_COLLECTIVE_398 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Decision Rules:
   - In the first round, cooperate (C). This is a friendly gesture to encourage cooperation from other players.
   - In subsequent rounds, mimic the behavior of the majority of players in the previous round. If more than (m-1) players cooperated, also cooperate in the current round. If fewer than (m-1) players cooperated, defect (D). This rule encourages cooperation when it is beneficial for the group but retaliates when others consistently defect.
   - If exactly m players cooperated and the remaining n-m players defected in the previous round, use a random coin flip to decide between cooperating or defecting. This helps avoid potential stalemates.

2. Edge Cases:
   - In the last round, mimic the behavior of the majority of players from the second last round. If more than (m-1) players cooperated in the second last round, also cooperate in the last round. If fewer than (m-1) players cooperated in the second last round, defect (D).
   - In the first round, if there is an even number of players, and exactly half of them choose to cooperate, then the ATFT strategy should cooperate as well. This ensures that at least m players cooperate, meeting the game's minimum cooperation threshold.

3. Collective Mindset:
   - The ATFT strategy fosters a collective mindset by encouraging cooperation when it appears beneficial for the group, while also punishing those who consistently defect. It maintains a balance between cooperation and defection, promoting fairness and reciprocity within the group.

Pseudocode:
```
def AdaptiveTitForTat(round, history):
    if round == 1:
        action = 'C'  # Cooperate in the first round
    elif len(history) < 2:
        raise Exception("Not enough game history")
    else:
        prevRoundHistory = history[-2]
        cooperatorsInPrevRound = sum(1 for playerAction in prevRoundHistory if playerAction == 'C')

        # If more than (m-1) players cooperated, also cooperate in the current round
        if cooperatorsInPrevRound > m - 1:
            action = 'C'
        elif cooperatorsInPrevRound < m - 1:
            action = 'D'  # Defect when less than (m-1) players cooperated in the previous round
        else:  # Exactly m players cooperated and the remaining n-m players defected
            if random() > 0.5:
                action = 'C'  # Cooperate with a probability of 0.5
            else:
                action = 'D'  # Defect with a probability of 0.5

    return action
```
'''

description_COLLECTIVE_399 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TFT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   Initially, TFT-A starts by cooperating in the first round to show goodwill and establish trust. For subsequent rounds, TFT-A will take the previous action of the opponent as a cue for its own action:
   - If the opponent cooperated in the previous round, TFT-A cooperates back in the current round (as a reciprocal gesture).
   - If the opponent defected in the previous round, TFT-A defects as well to retaliate.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First round: Cooperate as an initial goodwill gesture and to give the opponent an opportunity to cooperate back.
   - Last round: TFT-A copies the latest action of its opponent to avoid punishing the opponent unnecessarily at the end of the game.
   - In other edge cases (e.g., mid-game changes in opponents, partial games), TFT-A continues following its original rule based on the opponent's latest action.

3. Be collective - Clearly align with the collective mindset
   TFT-A fosters cooperation among players through reciprocity and trust building, thus aligning itself with a collective mindset. It seeks to establish a cooperative equilibrium when opponents are also willing to cooperate in a mutualistic fashion. If opponents defect repeatedly, TFT-A will retaliate but remains open to resuming cooperation if the opponent changes its behavior.

Pseudocode:
```
def TFT_A(opponent_history, n, m, k, r):
    history = [None] * r  # Save previous opponent actions
    payoff = 0             # Initialize total game payoff

    if len(opponent_history) == 0:
        cooperate = True    # Cooperate in the first round
    else:
        cooperate = history[-1] == 'cooperate'

    for t in range(r):
        if t == 0:
            opponent_history.append(cooperate)
        else:
            opponent_history.append(opponent_history[t - 1])

        round_payoff = calculate_round_payoff(cooperate, opponent_history, n, m, k)
        payoff += round_payoff

        if cooperate and opponent_history[-1] == 'defect':
            cooperate = False  # Retaliate when opponent defects
        elif !cooperate and opponent_history[-1] == 'cooperate':
            cooperate = True   # Cooperate when opponent cooperates back

    return payoff
```
'''

description_COLLECTIVE_400 = '''
 Strategy Name: Tit-for-Tat (TFt) Adaptive with Factor (k) Consideration (TAFC)

1. Decision Rules:
   - Initial Round (t=1): Cooperate (C), establish a cooperative first impression and build trust.
   - Subsequent Rounds (2 ≤ t ≤ r):
     - If opponent cooperated in the previous round, return the favor by cooperating in this round (C).
     - If opponent defected in the previous round, defect in this round (D). This retaliation is intended to enforce the principle of reciprocity while keeping potential gains.
   - Special Case: If the number of cooperators (m) required for success is reached, continue cooperating even if the opponent defects. This encourages long-term collaboration and rewards altruistic behavior.

2. Handling Edge Cases:
   - Last Round (t=r): Cooperate, regardless of the opponent's previous action, as there are no further rounds to retaliate or reciprocate.
   - First Few Rounds (1 ≤ t < m): Cooperate, aiming to gather cooperators to reach the minimum required threshold (m).

3. Collective Mindset:
   - Maintains a balance between cooperation and competition while promoting trust and long-term collaboration.
   - The strategy encourages opponents to collaborate by demonstrating both altruism and retaliation, with a focus on establishing and preserving relationships.

Pseudocode for the TAFC strategy:
```
function TAFC(n, m, k, r) {
    rounds = [0] * r
    currentRound = 1

    function opponentAction(previousRound) {
        return (currentRound == 1) ? 'C' : previousRound[currentRound-1]
    }

    while (currentRound <= r) {
        if (currentRound == 1) {
            rounds[currentRound - 1] = 'C'
        } else {
            opponentActionHistory = rounds[currentRound-2: currentRound-1]
            opponentActionCurrent = opponentAction(opponentActionHistory)
            rounds[currentRound - 1] = (opponentActionCurrent == 'C') ? 'C' : 'D'
        }

        if (currentRound >= m && rounds[currentRound - m: currentRound-1].count('C') >= m) {
            rounds[currentRound - 1] = 'C'
        }
        currentRound++
    }

    totalPayoff = sum(rounds)
    return totalPayoff
}
```
'''

description_COLLECTIVE_401 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate to show good intentions and trustworthiness.
   - For subsequent rounds, if a player cooperated in the previous round, also cooperate in the current round as a reciprocal gesture.
   - If a player defected in the previous round, defect in the current round as a punishment for non-cooperation.
   - Continue this cycle of cooperation and retaliation based on the opponent's previous action.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate to initiate a relationship with all opponents.
   - For the last round, evaluate the total number of cooperative actions from each opponent throughout the game and cooperate if the number is greater than or equal to m (minimum cooperators needed). Otherwise, defect. This encourages long-term cooperation while also promoting the achievement of the collective goal.

3. Be collective - Clearly align with the collective mindset
   - Prioritize the collective success over individual gains by aiming to meet the minimum cooperators needed (m) in each round.
   - Adapt to the behavior of opponents, rewarding cooperation and punishing defection in a consistent manner, which promotes a collaborative environment.
'''

description_COLLECTIVE_402 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TTFT)

1. Decision Rules:
   - In the initial round, cooperate (C). This is a friendly gesture and helps establish trust among players.
   - For subsequent rounds, observe the collective action from the previous round (CR_prev). If more than the minimum required number of players cooperated (m), continue to cooperate. If less or equal to the minimum required number of players cooperated, defect (D).
   - Implement an adaptive cooperation threshold (CT) that adjusts based on the average percentage of cooperators in the previous 'T' rounds. If the average is above a certain threshold (AT), the CT increases slightly, encouraging more cooperation. If the average is below AT, the CT decreases slightly, discouraging cooperation.
   - Periodically update the adaptation rate to avoid oscillation and ensure stability.

2. Handling Edge Cases:
   - In the last round, cooperate if the average percentage of cooperators in the previous T rounds was above the minimum required (m). Defect otherwise, as there are no more rounds for any potential positive or negative consequences of cooperation.
   - In the first round when there is no history, cooperate as specified earlier.

3. Being Collective:
   - The strategy prioritizes cooperation and trust among players but also considers self-interest by adjusting the cooperation threshold adaptively. This approach promotes collective success while ensuring robustness against various opponent behaviors.

Pseudocode for TTFT strategy:

```python
def TTFT(n, m, k, r, t=10):
    # Initialize adaptation rate and average cooperation percentage
    alpha = 0.01
    avg_cooperation = 0.5

    for round in range(r):
        CR_prev = get_previous_round_cooperation_count(n)

        if round == 0:
            action = 'C'  # Cooperate in the first round
        elif round == r - 1:
            if avg_cooperation >= m:
                action = 'C'  # Cooperate in the last round if average cooperation is sufficient
            else:
                action = 'D'  # Defect in the last round if average cooperation is insufficient
        else:
            if CR_prev[m-1] >= m:
                action = 'C'  # Cooperate if more than the minimum required number of players cooperated in the previous round
            else:
                action = 'D'  # Defect if less or equal to the minimum required number of players cooperated in the previous round

            avg_cooperation = update_average_cooperation(CR_prev, avg_cooperation, alpha)

    return action
```
'''

description_COLLECTIVE_403 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, the TFT-ACT strategy starts by cooperating, assuming others will do the same. If all other players cooperated in the previous round, it continues cooperating. If any player defected in the previous round, the strategy will defect to match the defection and punish the defector for one round. After punishment, it returns to cooperating if no further defections were made by others.
   To enhance robustness against various opponent behaviors, TFT-ACT introduces an Adaptive Cooperation Threshold (ACT). If a player consistently defects for more than 'n_defect' consecutive rounds, the ACT is incrementally increased. Once the number of cooperators exceeds the ACT in a round, the strategy cooperates for the next 'punishment_duration' rounds before returning to its original behavior. This mechanism allows TFT-ACT to adapt to persistent non-cooperative players without overreacting or getting trapped in repeated punishments.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, all strategies cooperate since there is no prior history. For the last round, TFT-ACT adopts a forgiving approach, returning to cooperation if any cooperators were present in the preceding rounds.

3. Be collective - Clearly align with the collective mindset
   By starting with cooperation and responding adaptively to others' actions, TFT-ACT fosters a collective spirit. It encourages reciprocity and seeks to maintain a cooperative equilibrium when possible. However, it also punishes defections swiftly to deter anti-social behavior while still being forgiving over time.

Pseudocode:

```python
def TFT_ACT(n, m, k, r, n_defect, punishment_duration):
    cooperation_threshold = m
    current_round = 0
    past_actions = []

    def play():
        nonlocal current_round, cooperation_threshold
        if current_round == 1 or len(past_actions) < n:
            return 'C'  # Cooperate in the first round and if there is no history

        if all(action == 'C' for action in past_actions[-n:]):
            return 'C'  # Continue cooperation if all recent actions were cooperative
        elif any(action == 'D' for action in past_actions[-n:]):
            if current_round <= n_defect:
                return 'D'  # Punish defector(s) for the next n_defect rounds
            else:
                increment_threshold()
                return 'D'  # Maintain defective behavior until cooperation threshold exceeded
        else:
            # Return to cooperation after punishment or if ACT is not yet reached
            return 'C'

    def increment_threshold():
        nonlocal cooperation_threshold
        if cooperation_threshold < n:
            cooperation_threshold += 1

    for round in range(r):
        action = play()
        past_actions.append(action)
        current_round += 1
        if current_round == r - punishment_duration and all(action == 'C' for action in past_actions[-punishment_duration:]):
            cooperation_threshold = m  # Reset ACT after the punishment period
```
'''

description_COLLECTIVE_404 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFTAC)

1. Specify decision rules:
   - In each round, evaluate the number of cooperators in the previous round (n_c). If n_c >= m, player will cooperate (C), otherwise defect (D). This encourages cooperation when others also cooperate and punishes defection from cooperating partners.
   - To adapt to opponents' strategies, introduce a tolerance factor T. If n_c < m but abs(n_c - (m-1)) <= T, player will cooperate to signal potential future collaboration. This allows for forgiveness in case of small deviations from the cooperation threshold and can encourage long-term partnerships.
   - In case TFTAC is playing against itself or similar strategies with a high tolerance, increase T to further promote forgiveness and mutual cooperation.

2. Handle edge cases:
   - First round: Cooperate (C) as a goodwill gesture to potential partners.
   - Last round: Evaluate the number of cooperators in the previous round as usual, but prioritize a higher tolerance T to encourage final acts of cooperation.

3. Be collective:
   - By focusing on mutual cooperation when conditions allow and punishing defection with appropriate delay, TFTAC promotes a collective mindset by rewarding collaborative strategies and discouraging selfish or unpredictable behavior.

Pseudocode:

```python
function TFTAC(n_players, m, k, r, tolerance):
    endowment = 0
    cooperation_count = [0] * n_players
    history = []

    def round():
        nonlocal cooperation_count, history
        if not history:
            action = 'C'  # cooperate in the first round as a goodwill gesture
        else:
            n_c = sum(cooperation_count)
            if n_c >= m:
                action = 'C'
            elif abs(n_c - (m-1)) <= tolerance:
                action = 'C'
            else:
                action = 'D'
        history.append(action)
        cooperation_count[player] += int(action == 'C')
        payoff = ... # calculate payoff using provided payoff matrix structure
        return payoff, action

    def game():
        for round in range(r):
            payoffs, actions = round()
            ... # update endowment and/or strategy based on payoffs
```
'''

description_COLLECTIVE_405 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, TFT-ACT begins by cooperating (C), mimicking the initial cooperation often found in social dilemma games. If a majority of players (m or more) also cooperated in the previous round, TFT-ACT continues to cooperate. Otherwise, it defects (D).

TFT-ACT also includes an adaptive cooperation threshold, which increases after consecutive rounds of defection by all other players and decreases after consecutive rounds of cooperation by most players. The cooperation threshold ranges from 1 to n and is adjusted according to the following pseudocode:

```
cooperation_threshold = min(n, max(1, cooperation_threshold + (1 - m) * consecutive_defections))
```

If the current number of cooperators meets or exceeds the cooperation threshold, TFT-ACT cooperates. Otherwise, it defects.

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, every player starts by cooperating, as they have no prior information about other players' actions. In the last round or any subsequent rounds where the total number of players left is less than m, TFT-ACT defects because there are insufficient potential cooperators to reach the minimum threshold.

3. Be collective - Clearly align with the collective mindset

TFT-ACT aims to promote cooperation and maintain a collective mindset by mirroring other players' actions when they choose to cooperate, thus reinforcing positive cycles of mutual cooperation. However, TFT-ACT also retains the capacity for defection when necessary, ensuring it does not overcommit resources and remains resilient against free-riders or disloyal opponents.

TFT-ACT is designed to be adaptive and robust against a wide range of opponent behaviors, striking a balance between cooperation and defection based on game parameters and the history of other players' actions. This strategy encourages cooperative behavior while maintaining flexibility in the face of various adversarial strategies.
'''

description_COLLECTIVE_406 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - Initiate cooperation in the first round (C). This sets a cooperative tone and provides an opportunity for others to follow suit.
   - In subsequent rounds, cooperate if at least m players cooperated in the previous round (C). This encourages cooperation when it is beneficial and fosters trust among players.
   - If less than m players cooperated in the previous round, defect (D) to ensure personal gain while penalizing uncooperative opponents. This punishes non-cooperation and deters future defection.
   - After a defection by an opponent, wait for one round of cooperation before returning to cooperate again (Tit-for-Tat). This allows for forgiveness and encourages future cooperation.

2. Edge Cases:
   - In the last round, cooperate regardless of previous actions to maximize potential payoff.
   - If an opponent never cooperates, continue defecting as they have demonstrated their uncooperative nature.

3. Collective Mindset:
   - By following these rules, the strategy promotes cooperation when it benefits the group while protecting individual interests in response to uncooperative behavior. It also demonstrates a willingness to forgive and rebuild trust after defections.

Pseudocode:

```python
def TFT_AC(round, opponents_actions, m, k):
    if round == 1:
        return 'C' # Cooperate in the first round
    else:
        if number_of_cooperators(opponents_actions) >= m:
            return 'C' # Cooperate if at least m players cooperated last round
        else:
            return 'D' # Defect if fewer than m players cooperated last round

def number_of_cooperators(opponents_actions):
    count = 0
    for action in opponents_actions:
        if action == 'C':
            count += 1
    return count
```

This strategy aims to balance cooperation and defection while being adaptive to various opponent behaviors. By doing so, it fosters cooperation when beneficial while protecting individual interests when necessary.
'''

description_COLLECTIVE_407 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TTAT-ACT)

1. Decision Rules:
   - Initial Round (t=1): Cooperate (C). This sets a cooperative tone and encourages others to cooperate as well, providing an opportunity for the group to reach the minimum cooperation threshold (m).
   - Subsequent Rounds (2 ≤ t ≤ r):
     - If a majority (> (n-1)/2) of players cooperated in the previous round, then Cooperate (C). This rewards cooperation and encourages others to continue cooperating.
     - If fewer than a majority of players cooperated in the previous round, then Defect (D). This punishes non-cooperation and provides an incentive for others to cooperate in the current round to achieve the minimum cooperation threshold (m).
   - Final Round (t=r): Cooperate (C), as it is the last chance to contribute to the community project and potentially receive a reward.

2. Handle Edge Cases:
   - When n is odd, the majority > (n-1)/2 becomes the (n+1)/2. This ensures that if exactly half of the players cooperate, the strategy will defect to encourage more cooperation in the next round.
   - When n is even, and assuming an equal number of cooperators and defectors in a given round, the strategy will continue with its decision from the previous round (Cooperate or Defect) to maintain adaptability based on the evolving dynamics of the game.

3. Be Collective:
   - The TTAT-ACT strategy aims to promote cooperation by following the lead of the majority while also punishing non-cooperation when necessary. This collective mindset encourages a group dynamic that rewards mutual trust and cooperation.
   - By adapting its decisions based on the history of cooperative actions, the strategy demonstrates a commitment to the collective interest and fosters an environment conducive for long-term cooperation.
'''

description_COLLECTIVE_408 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Decision Rules:
   - Initially cooperate in the first round to foster cooperation and build trust (c_i = 1 for t=1).
   - In subsequent rounds, assess the number of cooperators (n_c) from the previous round and compare it against the Adaptive Cooperation Threshold (ACT). The ACT will adjust based on the average percentage of cooperators over the last 'w' rounds. If n_c >= ACT, cooperate; otherwise defect.
   - In case no information is available about past actions (e.g., first interaction with a player), cooperate initially to encourage cooperation and adjust the ACT later based on the opponent's behavior.

2. Edge Cases:
   - Last Round: Since there are no future rounds, players will not adjust their ACT, but they will still calculate payoffs based on the number of cooperators in the last round.
   - First Round: Cooperate to encourage cooperation and build trust.
   - Inconsistent Opponent Behavior: If an opponent switches from cooperating to defecting or vice versa unexpectedly, the ACT will be adjusted accordingly to reflect the new behavior pattern.

3. Collective Mindset:
   - The TFT-ACT strategy prioritizes cooperation when others are also cooperative and retaliates by defecting only if others do so repeatedly. This encourages a collective mindset by fostering mutual trust and reciprocity among players.

Pseudocode:
```
function TFT_ACT(n, m, k, w):
  initialize ACT = (m/n) * 100%     # Adaptive Cooperation Threshold is the minimum percentage of cooperators required for cooperation
  Initialize n_c_history = []        # History of number of cooperators in previous rounds

function decide_action(t):
  if t == 1:
    return Cooperate    # Cooperate on the first round to encourage cooperation

  calculate n_c from t-1                 # Get the number of cooperators in the previous round
  append n_c to n_c_history            # Store it for calculating average percentage of cooperators

  if length(n_c_history) > w:
    remove first element from n_c_history # Remove oldest data point
    average_cooperation = sum(n_c_history)/w * 100%     # Calculate the average percentage of cooperators over the last 'w' rounds
    ACT = (m/n) * average_cooperation          # Adjust ACT based on the recent average cooperation rate

  if n_c >= ACT:
    return Cooperate
  else:
    return Defect

function total_payoff(t, r):
  calculate payoffs for round t using payoff calculation rules
  return sum of payoffs from rounds 1 to t
```
'''

description_COLLECTIVE_409 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, always cooperate (C). This is a peaceful gesture to encourage cooperation from others.
   - After the initial round, your action depends on the actions of the other players in the previous round:
     - If m or more players cooperated in the previous round, also cooperate (C) in the current round. This reward-for-reward approach encourages ongoing cooperation.
     - If fewer than m players cooperated in the previous round, defect (D). This punishment-for-defection approach discourages defection and encourages future cooperation.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, always cooperate (C) as mentioned above.
   - In the last round, mirror the opponent's action from the previous round to avoid potential negative payoffs if the strategy defected but the opponent had decided to cooperate in the final round.
   - For intermediate rounds, follow the described decision rules.

3. Be collective - Clearly align with the collective mindset
   - The ATFT strategy aims to foster a stable and cooperative environment by encouraging reciprocity among players. It incentivizes cooperation when it's beneficial for the group, while also retaliating against defection.
   - The strategy adapts to changes in opponent behavior and seeks long-term cooperation by rewarding past acts of cooperation and punishing past acts of defection.

Pseudocode:

```
function ATFT(n, m, k, round, own_action_history, other_action_history) {
  if (round == 1) return 'C' // First move is always cooperate

  num_cooperators = countCooperators(other_action_history[round-1])

  if (num_cooperators >= m) return 'C' // If majority cooperated, also cooperate
  else if (num_cooperators < m && own_action_history[round-1] == 'C') return 'D' // Punish defection
  else return 'C' // Cooperate to encourage future cooperation
}
```
'''

description_COLLECTIVE_410 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TTFC) for Collective Risk Dilemma

1. Decision Rules:
   - In each round t, start by cooperating (C). This initial cooperation serves as a friendly gesture and provides a foundation for potential long-term cooperation.
   - If other players also cooperate in the same round, maintain cooperation (C) to maximize the collective reward (k).
   - If less than m players cooperate in a given round t, defect (D) to punish those who did not cooperate and avoid bearing more than your fair share of the cost.
   - If you defected in the previous round and all others cooperated, also cooperate in the current round to show willingness to rebuild trust.
   - If you both cooperated and defected with others in the same round (i.e., a mixed situation), cooperate again in the next round to encourage long-term cooperation.

2. Handle Edge Cases:
   - First Round: Start by cooperating as a friendly gesture towards others.
   - Last Round: Analyze the current round's cooperation level and make decisions accordingly using the decision rules above.

3. Be Collective:
   - Focus on maintaining trust and encouraging long-term cooperation with other players, even if it means temporarily bearing more cost.
   - Adapt to changing player behaviors while prioritizing collective interests over individual ones when possible.
   - Favor cooperative outcomes that maximize the community project's success and overall reward (k).

Pseudocode:
```python
def TTFC(n, m, k, r):
  cooperation_history = [C for _ in range(r)]  # Initialize cooperation history as a list of cooperative actions

  def get_cooperators_count(player_actions):
    return sum([1 if action == 'C' else 0 for action in player_actions])

  for round in range(r):
    all_actions = [player.action for player in players]  # Collect all players' actions
    cooperators_count = get_cooperators_count(all_actions)

    if cooperators_count >= m:  # If enough players cooperate, maintain cooperation
      cooperation_history[round] = 'C'
    elif round == 0:  # First round, start by cooperating
      cooperation_history[round] = 'C'
    else:  # Punish defectors and maintain cooperation with those who also cooperated last round
      if cooperation_history[round - 1] == 'D':
        cooperation_history[round] = get_cooperators_count(all_actions) >= m
      else:
        cooperation_history[round] = cooperation_history[round - 1]
```
'''

description_COLLECTIVE_411 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially cooperate in the first round (C_i,1 = C). This sets a cooperative tone and is an act of goodwill.
   - For subsequent rounds, adopt a Tit-for-Tat approach: if a player has previously cooperated (c_j, t-1 = C), then cooperate (C_i,t = C); otherwise defect (C_i,t = D). This encourages reciprocity and maintains cooperation when it exists while punishing defection.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as mentioned above (C_i,1 = C).
   - In the last round, assess the number of cooperators to date. If it meets or exceeds the minimum threshold (m), cooperate (C_i,r = C) to maximize potential rewards; otherwise defect (C_i,r = D). This approach encourages players to contribute when close to the required cooperation and ensures fairness in case of insufficient contributions.

3. Be collective - Clearly align with the collective mindset
   - Prioritize the common good by cooperating whenever possible, given the current state of cooperation among players. The strategy focuses on reciprocity, encourages cooperation, and punishes defection to foster a collective spirit.

Pseudocode:
```python
def adaptive_tit_for_tat(n, m, k, r):
    # Initialize cooperative state for each round (c_i)
    c = [False]*r

    # Player i's action for a given round t
    def player_action(i, t):
        if t == 1:
            return True  # Cooperate in the first round
        else:
            j = (t - 1) % n  # Previous player index
            return c[j]  # Cooperate if previous player cooperated; otherwise defect

    # Main strategy algorithm
    for t in range(1, r+1):
        # Update current cooperation state
        c.append(player_action(modulo_index(t, n), t))

def modulo_index(i, n):
    return (i - 1) % n + 1
```
'''

description_COLLECTIVE_412 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Decision Rules:
   - Initially cooperate in the first round (C_i, 1 = 1) to show good faith and encourage cooperation.
   - In subsequent rounds, analyze the number of cooperators from the previous round (n_c). If n_c >= m, continue to cooperate (C_i, t = 1 if n_c(t-1) >= m), as it appears beneficial for all players to cooperate.
   - If n_c < m, defect (D_i, t = 0) in the current round and switch strategies after a predefined number of uncooperative rounds (d). If d rounds have passed without reaching the cooperation threshold (m), change strategy to Tit-for-Tat with a lower cooperative threshold (C_i, t' = 1 if n_c(t') >= m - 1).
   - Maintain adaptive cooperation by periodically adjusting the critical number of cooperators (m) based on the success of the current strategy. If the collective payoff increases over a certain timeframe (s), raise the threshold to encourage stronger commitment from other players (increase m by a small increment). Conversely, if the payoff decreases, lower the threshold to facilitate cooperation (decrease m by a small increment).

2. Handle Edge Cases:
   - In the last round, evaluate whether cooperating or defecting would result in a higher total payoff over the game and make an informed decision accordingly.
   - If multiple players adopt TFT-ACT with different d values, they should choose the smallest d to avoid a race to lower cooperation thresholds. This can be achieved by having each player maintain a list of opponents' strategies, updating it after each round, and adopting the strategy with the smallest d found in their opponent list.

3. Be Collective:
   - The strategy emphasizes the importance of collective action by initially cooperating to build trust among players and continuously adjusting cooperation thresholds based on observed player behavior.
   - By adapting to the context, TFT-ACT demonstrates a commitment to the common good while ensuring its own success through a rational response to opponent strategies.

Pseudocode:
```
function TFT_ACT(n, m, k, r, d, s) {
  players = [Player_1, Player_2, ..., Player_n]
  cooperation_threshold = m
  cooperative_rounds = []

  for t = 1 to r:
    n_c = number of players who cooperated in the previous round (t-1)
    if t == 1:
      players[i].action = Cooperate
    else:
      if n_c >= cooperation_threshold:
        players[i].action = Cooperate
      else:
        players[i].action = Defect
        if (t - d) > r:
          adjust_cooperation_threshold(players, cooperation_threshold, s)
    cooperative_rounds.append(n_c)

  function adjust_cooperation_threshold(players, threshold, success_window):
    payoff_window = payoffs over last success_window rounds
    if average payoff in payoff_window > previous_average:
      increase cooperation_threshold
    else if average payoff in payoff_window < previous_average:
      decrease cooperation_threshold
}
```
'''

description_COLLECTIVE_413 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules:
   - In each round i, the ATFT strategy cooperates if at least m players cooperated in the previous round. If fewer than m players cooperated, it defects. This rule encourages reciprocity, promoting trust and cooperation when others are cooperative while retaliating when others are not.

2. Handle edge cases:
   - First round (t=1): ATFT starts by cooperating to show goodwill.
   - Last round (t=r): The strategy behaves as in the regular rules, taking into account the actions of the previous round.

3. Be collective:
   - By following reciprocal cooperation, the ATFT strategy aligns with a collective mindset, incentivizing long-term cooperation and fostering a sense of community among players.

Pseudocode for the Adaptive Tit-for-Tat strategy:

```python
def ATFT(history, m, n, r, k):
  cooperate = True  # Start by cooperating in the first round

  for t in range(1, r+1):
    if sum(history[t-1]) >= m:  # If enough players cooperated in the previous round
      cooperate = True
    else:
      cooperate = False

    payoff = (1 - cooperate) if cooperate == False else (1 - cooperate) + k
    history.append(cooperate)  # Update history for next round decision

  return history, sum(payoffs)  # Return history and total payoff over rounds
```
'''

description_COLLECTIVE_414 = '''
 Title: Adaptive Tit-for-Tat Strategy (ATTS) for Collective Risk Dilemma

1. Specify decision rules:
   - Initiation: Cooperate in the first round to promote trust and cooperation. This is a friendly gesture to demonstrate good intentions towards other players. (c_i=1, t=1)
   - Response: In subsequent rounds (t > 1), copy the previous action of the opponent from the last round. If opponent cooperated (c_opp_t-1 = 1), then also cooperate (c_i=1, t>1). If opponent defected (c_opp_t-1 = 0), then defect (c_i=0, t>1)
   - Forgiveness: If a player has previously defected but subsequently changes strategy and cooperates, the ATTS will forgive them and return to cooperating in the next round.

2. Handle edge cases:
   - Last round: As no further rounds are expected after this one, players may not consider future payoffs. In this case, ATTS will follow the same decision rules but without the "forgiveness" aspect since there is no opportunity for opponents to change their strategies in the following rounds.
   - First-encounter repetitions: When meeting an opponent for the first time in a new round, use the initiation rule as described above (c_i=1, t=1). If the opponent has been encountered before, follow the response rule (c_i = c_opp_t-1, t > 1)

3. Be collective: The Adaptive Tit-for-Tat Strategy aims to promote cooperation among players while remaining robust against a wide range of opponent behaviors. It encourages cooperation by initiating with a cooperative move and responding in kind to friendly actions, but it also retaliates when opponents are uncooperative. This strategy balances the need for long-term mutual benefits and short-term individual gain, making it well suited for fostering collective success in the Collective Risk Dilemma game.

Pseudocode for Adaptive Tit-for-Tat Strategy:

```
function ATTS(opponent_action_history, round_number, m, k) {
    if (round_number == 1) {
        return COOPERATE; // Initiate cooperation in the first round
    }

    opponent_last_action = opponent_action_history[round_number - 1];

    if (opponent_last_action == COOPERATE && m <= len(opponent_action_history)) {
        // If opponent cooperated and the minimum cooperation threshold is met, continue to cooperate
        return COOPERATE;
    } else if (opponent_last_action == DEFECT) {
        // If opponent defected previously, also defect in this round
        return DEFECT;
    } else {
        // If opponent's history is insufficient or inconsistent, continue to cooperate in the spirit of goodwill
        return COOPERATE;
    }
}
```
'''

description_COLLECTIVE_415 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperative (TFTAC)

1. Decision Rules:
   - In the first round, cooperate to initiate cooperation and show good faith.
   - For subsequent rounds, cooperate if at least m players cooperated in the previous round, and defect otherwise.
   - If more than n-m+1 players cooperated in the previous round (indicating a majority), adjust the threshold temporarily to encourage reciprocity by requiring m+1 players to cooperate in the current round. This is to avoid being taken advantage of and ensure fairness.
   - If less than m players cooperated in the previous round, wait for m players to defect before returning to cooperation again, to avoid being stuck in a losing situation.

2. Edge Cases:
   - In the last round, always cooperate regardless of previous actions to maximize potential payoff.
   - If no other players have cooperated by the time the threshold adjustment would take effect, revert back to the original threshold for the remainder of the game.

3. Collective Mindset:
   - Maintain a balance between cooperation and defection to encourage reciprocity among players while avoiding being taken advantage of.
   - Demonstrate a willingness to cooperate initially and respond positively when others cooperate, but also be firm in enforcing the threshold for cooperation if necessary.

Pseudocode:

```python
def TFTAC(round, history, m, n):
  if round == 1:
    action = 'C'  # Cooperate to initiate cooperation
  else:
    cooperation_count = count_cooperators(history)
    if cooperation_count >= m:
      if cooperation_count <= n-m+1:
        action = 'C'  # Cooperate in response to previous cooperation
      elif cooperation_count > n-m+1:
        threshold = m + 1  # Temporarily raise the threshold to encourage reciprocity
    else:
      if cooperation_count < len(history) - m + 1:
        action = 'C'  # Wait for m players to defect before returning to cooperation
      else:
        threshold = m  # Revert back to original threshold if no other players have cooperated

  return action
```
'''

description_COLLECTIVE_416 = '''
 Strategy Name: Tit-for-Tat Adaptive (TfTA) for Collective Risk Dilemma

1. Decision Rules:
   - Initialize cooperation in the first round (C_i, 1 = C).
   - In subsequent rounds, players will cooperate if at least m players cooperated in the previous round and defect otherwise (C_i, t = C if number of cooperators in round t-1 >= m; D_i, t = D).

2. Handling Edge Cases:
   - In the last round, players will cooperate regardless of the number of cooperators in the previous round since there are no future rounds (C_i, r = C).
   - In the first round, cooperation is initiated to encourage trust among players and potentially set a positive precedent (C_i, 1 = C).

3. Collective Mindset:
   - The strategy fosters collective interest by reciprocating cooperation from other players while punishing defection with defection in response. This simple yet robust approach encourages long-term cooperation and discourages free riding.

Pseudocode:

```python
def TfTA(n, m, k, r, history):
  def play_round(history):
    num_coop = sum(history[-m:])
    if num_coop >= m:
      action = "C" # Cooperate
    else:
      action = "D" # Defect
    return action

  history.append(play_round(history))
  for round in range(r - 1):
    history.append(play_round(history))

  return history
```

This pseudocode outlines the basic structure of the Tit-for-Tat Adaptive strategy. It initializes with an empty list representing the game history, then plays a single round using the decision rules described above. Afterward, it loops through the remaining rounds and updates the history based on the play_round function, which implements the strategy's decision rules for each round. The final result is a complete history of actions taken over the course of the game.
'''

description_COLLECTIVE_417 = '''
 Strategy Name: Tit-for-Tat with Adaptive Threshold (TFTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In each round i, start by cooperating (C).
   - If the number of cooperators in the previous round was less than m (denoted as P_prev < m), then defect (D) in this round.
   - If the number of cooperators in the previous round was equal to or greater than m (P_prev ≥ m), then cooperate (C). This rule ensures cooperation when the community is working together and retaliation against defection.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate since there's no previous information available.
   - In the last round, act based on the current state of cooperation within the group. If more than or equal to m players have been cooperating (P_curr ≥ m), then continue cooperating; otherwise defect.

3. Be collective - Clearly align with the collective mindset
   - Prioritize long-term benefits by fostering a community that consistently meets the minimum threshold for cooperation (m). This encourages cooperation and stability within the group over time.

Pseudocode:

```
def TFTA(n, m, k, r, P_prev, P_curr):
  action = 'C' # Cooperate by default

  if r == 1: # First round, no previous information available
    return action

  if P_prev < m: # If fewer than m players cooperated in the last round
    action = 'D'

  if r == r and (P_curr < m): # Last round, if cooperation threshold not met
    action = 'D'

  return action
```

This strategy aims to balance cooperation with self-interest while maintaining a collective approach. It encourages a stable community by retaliating against defection but also rewarding consistent cooperation. The adaptive nature of the strategy allows it to be effective against a wide range of opponent behaviors.
'''

description_COLLECTIVE_418 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - In the first round, cooperate (C). This is a gesture of goodwill and gives potential partners a chance to initiate cooperation.
   - For subsequent rounds, follow the actions of the most frequent cooperator in the previous r-1 rounds (excluding the current round being evaluated). If there's a tie, cooperate with the player who contributed the least in the previous round. If no one cooperated in the previous round, also defect in this round.
   - If the majority of players cooperated in the previous round, adjust the cooperation probability p for the next round using a moving average based on the last 3 rounds' results:
     ```
     p = (0.4 * previous_rounds_cooperation_probability + 0.6 * current_round_cooperation_probability) / 2
     ```
   - If less than m players cooperated in the previous round, adjust the cooperation probability p for the next round based on the current round's cooperator count:
     ```
     if (m <= current_round_cooperators < n) then
       p = (current_round_cooperators - m) / (n - m)
     else if (current_round_cooperators == m) then
       p = 1
     else
       p = 0
     ```

2. Handle Edge Cases:
   - In the last round, cooperate with the player who contributed the most in the previous r-1 rounds, as a gesture of goodwill and potential future cooperation. If there's a tie, cooperate randomly among them.

3. Be Collective:
   - The strategy prioritizes cooperation when it aligns with the majority of players from the previous round, but also takes into account the overall cooperator count needed for collective success (m).
   - The moving average in decision rules 1 ensures some level of consistency and forgiveness, as TFT-AC adjusts its cooperation probability based on recent history.
   - By following the actions of the most frequent cooperator from the previous rounds, TFT-AC encourages and rewards cooperative behavior among opponents.
'''

description_COLLECTIVE_419 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Decision Rules:
   - Initially Cooperate (C) in the first round to show goodwill and encourage cooperation from other players.
   - In subsequent rounds, observe the actions of others in the previous round. If a majority (>=(n-m)/2) of players cooperated, also cooperate in the current round.
   - If fewer than (n-m)/2 players cooperated in the previous round, defect (D) to punish non-cooperators and increase the chances of receiving cooperation in future rounds.
   - In case of a tie, defect to avoid being exploited by potential free riders.

2. Edge Cases:
   - In the first round, cooperate as mentioned above.
   - In the last round, if a majority cooperated in the previous round, also cooperate to maximize the reward for that round. If not, defect to avoid unnecessary cooperation when the game is ending.

3. Collective Mindset:
   - TfTA strategy aims to create and maintain a cooperative environment while being cautious of exploitation by non-cooperators. It adapts to the collective behavior of other players and responds accordingly, fostering an atmosphere of trust and reciprocity that encourages long-term cooperation.
   - The strategy is robust to various opponent behaviors since it considers both cooperative and defective actions from others and adjusts its own actions accordingly while maintaining a collective mindset.
'''

description_COLLECTIVE_420 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, the ATFT strategy cooperates if at least m players cooperated in the previous round; otherwise, it defects. This encourages cooperation when others are cooperative and retaliates against defection to promote collective interest.

Pseudocode:
```python
def ATFT(previous_round_cooperation):
    if len(previous_round_cooperation) >= m:
        return "Cooperate"
    else:
        return "Defect"
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

For the first round, players don't have previous actions to consider, so we assume they start with equal probability of cooperating or defecting. In subsequent rounds, the strategy adjusts based on previous cooperation from other players as described above. For the last round, players use their decision rule as usual since the game continues until r rounds are complete.

3. Be collective - Clearly align with the collective mindset

By encouraging cooperation when others cooperate and retaliating against defection, ATFT fosters a collective mindset by rewarding mutual cooperation while penalizing free-riders who don't contribute to the community project. This strategy aims to find a balance between individual self-interest and collective welfare within the given game parameters.

In summary, Adaptive Tit-for-Tat (ATFT) is an adaptive and robust strategy for the Collective Risk Dilemma game. It cooperates when at least m players did so in the previous round, and it defects otherwise. The strategy handles edge cases by assuming equal probability of cooperation or defection in the first round, and it continues playing until the given number of rounds is complete.
'''

description_COLLECTIVE_421 = '''
 Strategy Name: Tit-for-Tat (TFt) with Adaptive Cooperation Threshold (ACT)

1. Decision Rules:
   - In the first round, cooperate to show goodwill and encourage cooperation from others (C).
   - After the initial round, adopt the Tit-for-Tat strategy: Cooperate if the opponent cooperated in the previous round; defect otherwise (C if prev_opponent_action == C, D if prev_opponent_action == D).
   - Implement Adaptive Cooperation Threshold (ACT): If a certain percentage of opponents (p) cooperated in the last r rounds, increase the number of required cooperators to continue cooperating (m'). This encourages cooperation when it seems more beneficial based on recent observations.
         ```
         if round_number >= initial_round + 1:
             m' = min(n, m + int((p * (n - m)) / r))  # Calculate new threshold with ACT
         else:
             m' = m                                # Use the initial cooperation threshold in the first round
         ```
   - If m' > n, revert to default cooperation threshold m. This prevents an overly aggressive ACT from reducing potential cooperation.

2. Handling Edge Cases:
   - In the last round, consider the current m' and cooperate if it is still greater than or equal to the number of remaining players (n - r + 1). This encourages cooperation in the final attempt to achieve a collective reward.
         ```
         if round_number == r:
             if m' >= n - r + 1:
                 action = "C"
             else:
                 action = "D"
         ```
   - In the first round, cooperate regardless of ACT to initiate cooperation and demonstrate goodwill.

3. Collective Mindset:
   The strategy aligns with a collective mindset by encouraging cooperation when reciprocated but also adapting to respond to the behavior of opponents. By introducing the Adaptive Cooperation Threshold, it becomes more robust against a wide range of opponent behaviors and can adjust its level of cooperation based on the observed patterns of cooperation in recent rounds.
'''

description_COLLECTIVE_422 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for Collective Risk Dilemma

1. Decision Rules:
   - In the first round, cooperate (C). This serves as a friendly gesture and allows other players to reap benefits without risking their own resources.
   - If a player has cooperated in the previous round and at least 'm' players also cooperated, then cooperate again (repeat Cooperative phase).
   - If a player has cooperated in the previous round but less than 'm' players also cooperated, then defect (D) to punish those who did not contribute. This sends a signal that cooperation is conditional on other players' behavior.
   - If a player has defected in the previous round, they should repeat their action from the previous round (repeat Defect phase). This allows them to react to being exploited while maintaining the possibility of resuming cooperation if others follow suit.

2. Handle Edge Cases:
   - In the last round, cooperate if at least 'm' players have cooperated in the previous round to maximize individual and collective payoff (repeat Cooperative phase).
   - In the first round, defect if less than 'm'-1 players cooperate to avoid being exploited (repeat Defect phase).
   - If a player has never cooperated before, continue with the Defect phase unless at least 'm' players cooperate in the current round, in which case they should switch to Cooperative phase.

3. Be Collective:
   - The strategy prioritizes collective success by rewarding cooperation when it benefits the majority ('m' or more players). This encourages others to cooperate and fosters a sense of shared responsibility.
   - The strategy also punishes defection when it undermines the collective interest, but is willing to forgive and resume cooperation if others change their behavior.

Pseudocode:
```
def AdaptiveTitForTat(round, history, m, k):
  if round == 1 or len(history) == 0:
    action = 'C' # Cooperate in the first round and when there is no history

  elif sum(history[-m:]) < m:
    action = 'D' # Defect when less than m players have cooperated in the recent past

  else:
    if history[-1] == 'C': # Cooperate if player has cooperated previously and enough others did as well
      action = 'C'
    else: # Punish defection and resume cooperation when others do so
      action = 'D'

  return action
```
'''

description_COLLECTIVE_423 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Decision Rules:
   - Initiate cooperation (C) in the first round to signal good intentions and foster a cooperative environment.
   - For subsequent rounds, if the number of cooperators in the previous round was greater than or equal to the minimum cooperation threshold (m), continue cooperating (C).
   - If fewer than m players cooperated in the previous round, defect (D) as punishment for non-cooperation and to avoid being taken advantage of.

2. Handling Edge Cases:
   - In the first round, cooperate (C) to initiate a cooperative environment.
   - In the last round or any round where the total number of cooperation rounds is less than the minimum cooperation threshold (m), defect (D) as there's no potential for achieving the cooperation threshold in the remaining rounds.
   - If the number of remaining rounds (r - t) is less than the minimum cooperation threshold (m), switch to defection (D) to maximize personal payoff in the short-term, given the lack of time to achieve the cooperation threshold.

3. Being Collective:
   - The strategy aims to align with a collective mindset by prioritizing mutual cooperation when it is beneficial for the group, while also punishing non-cooperative behavior to deter potential free riders.
   - The strategy adapts its actions based on the collective behavior of other players in each round, making it more robust and responsive to various opponent behaviors.

Pseudocode:
```
function ATFT(n, m, k, r, t) {
  if (t == 1) { // First round
    cooperate = true
  } else {
    cooperate = countCooperators(previousRound) >= m
  }

  if (r - t < m || t == r) { // Last round or insufficient time to achieve cooperation threshold
    cooperate = false
  }

  if (cooperate) {
    payoff = (1 - c) + k
  } else {
    payoff = 1
  }

  return payoff
}
```
'''

description_COLLECTIVE_424 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
In each round, our AI will start by cooperating (C), aiming to foster a collaborative environment. However, if any player defects in the current round, our AI will also defect in the subsequent round. If all players cooperated in the previous round, our AI will continue cooperating. The decision rule can be expressed as follows:

```python
def decide_action(history):
    if history[-1] == ['C'] * n and history[-2] != ['D'] * n:
        return 'C'  # Cooperate
    else:
        return 'D'  # Defect
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
In the first round, our AI will cooperate regardless of past history since there is no previous information available. In the last round, our AI will cooperate if all players have cooperated throughout the game; otherwise, it will defect to retaliate against any defections during the game. For other edge cases (e.g., second-to-last round), our AI will follow the same decision rule as in regular rounds.

3. Be collective - Clearly align with the collective mindset
Our Adaptive Tit-for-Tat strategy prioritizes cooperation as much as possible, only retaliating against defections to encourage future collaboration. By cooperating initially and responding to defections, our AI seeks a balance between individual interests and group benefits while being adaptive and robust to various opponent behaviors.
'''

description_COLLECTIVE_425 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - In the initial round, cooperate (C). This sets a cooperative tone for potential partners and demonstrates good faith.
   - For subsequent rounds, observe the number of cooperators in the previous round (n_c). If n_c >= m, cooperate; otherwise, defect. This follows the Tit-for-Tat strategy but adapts to the minimum cooperation threshold.
   - When the game nears its end and there are not enough rounds left for opponents to recover from a single defection (last r - m + 1 rounds), switch to always cooperating to maximize potential rewards in the remaining rounds.

2. Handle edge cases:
   - In the last round, always cooperate to ensure the best possible outcome given the limited remaining opportunities.
   - If an opponent switches from cooperation to defection after a long history of cooperation, allow one act of defection before resuming cooperation in response. This allows for occasional mistakes or changes in strategy on the part of opponents without immediately punishing them.
   - If an opponent never cooperates despite a significant number of opportunities, defect indefinitely as they are unlikely to change their strategy.

3. Be collective:
   - Cooperate whenever possible to promote collaboration and mutual benefits, while also being adaptive to the changing behavior of opponents.
   - Respond to defection with defection but maintain a forgiving nature by allowing for occasional mistakes or changes in strategy on the part of opponents.
   - Adapt the cooperation threshold based on the minimum cooperators needed (m) and adjust it as needed during gameplay.

Pseudocode:
```
def TFT_ACT(n, m, r, k):
    history = []  # store previous rounds' actions
    current_round = 1

    while current_round <= r:
        if current_round == 1:  # first round
            action = 'C'
        elif len(history) < r - m + 1:  # not last few rounds
            if n_cooperators(history) >= m:
                action = 'C'
            else:
                action = 'D'
        else:  # last few rounds
            action = 'C'

        history.append(action)
        current_round += 1

    return history

def n_cooperators(history):
    cooperators = 0
    for action in history:
        if action == 'C':
            cooperators += 1
    return cooperators
```
'''

description_COLLECTIVE_426 = '''
 Strategy Name: Adaptive Tit-for-Tat with Threshold (ATFT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   ATFT starts by cooperating in the first round to show goodwill and promote trust among players. Subsequently, it responds to previous actions taken by other players in a tit-for-tat manner:
   - If another player cooperated in the previous round, ATFT will also cooperate in the current round.
   - If another player defected in the previous round, ATFT will defect in the current round.
   However, to prevent overly punishing minor deviations from cooperation and to accommodate for the minimum number of cooperators required (m), ATFT applies a threshold:
   - If fewer than m-1 players cooperated in the previous round, ATFT will defect regardless of its own previous action.
   - If at least m players cooperated in the previous round, ATFT will cooperate as per the tit-for-tat rule.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, ATFT cooperates without considering past actions (since there is no past). For the last round, the strategy maintains its current state of cooperation or defection and adheres to the tit-for-tat rule based on the previous action taken by other players in the penultimate round.

3. Be collective - Clearly align with the collective mindset:
   ATFT encourages cooperation when it perceives that the majority of players are willing to cooperate, while also protecting itself from exploitation by defection when necessary. By adapting its behavior based on the actions of other players, the strategy fosters a sense of mutual trust and collaboration over time.

Pseudocode:
```
function ATFT(n, m, k, r) {
  // Initialize state (cooperate or defect) for each player
  states = [cooperate] * n

  // Game history to store past actions
  history = []

  for round in range(1, r+1):
    if round == 1:
      // Cooperate on the first round
      cooperate_round = true
    else:
      cooperate_round = false

    // Update game history
    history.append(states)

    // Check if enough players cooperated in the previous round
    num_cooperators = count_cooperators(history[round - 1])

    if (num_cooperators >= m && cooperate_round):
      // Cooperate when enough players cooperated in the last round
      for i in range(1, n+1):
        states[i] = cooperate
    elif (num_cooperators < m - 1):
      // Defect when fewer than m-1 players cooperated in the last round
      for i in range(1, n+1):
        states[i] = defect
    else:
      // Apply tit-for-tat rule based on the state of the player with whom ATFT interacted in the previous round
      opponent = find_opponent(states)
      if (states[opponent] == cooperate):
        // Cooperate when the opponent cooperated in the last round
        for i in range(1, n+1):
          states[i] = cooperate
      else:
        // Defect when the opponent defected in the last round
        for i in range(1, n+1):
          states[i] = defect

  return history
}
```
'''

description_COLLECTIVE_427 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TTFC)

1. Specify decision rules:
   - Initially cooperate (C) in the first round to demonstrate goodwill and establish trust.
   - In subsequent rounds, cooperate (C) if the majority (> m/2) of players cooperated in the previous round. Otherwise, defect (D). This rule incentivizes cooperation when it is beneficial for the group while retaliating against defection.
   - If the number of players is odd, a tie-breaking rule can be applied, such as considering the most recent action as the majority decision.

2. Handle edge cases:
   - In the last round, cooperate (C) regardless of the previous round's outcome to potentially maximize rewards.
   - If m > n/2 in the first round, it is impossible for the majority to cooperate; in this case, defect (D) to avoid being exploited by other players.

3. Be collective:
   - The TTFC strategy prioritizes cooperation when it aligns with the majority's decisions, promoting collective mindset and group success.
   - By retaliating against defection, the strategy discourages freeriding and encourages long-term reciprocal behavior, which is essential for building trust and fostering cooperation within the group.

Pseudocode:
```python
def tit_for_tat_adaptive_cooperation(n, m, k, r):
    history = [{'round': 0, 'majority': False}] # initialize history with first round data
    for t in range(1, r+1):
        if len(history) == t:
            majority = False
        else:
            majority = count_majority(history[t-1]['majority'], history[-1]['majority'])

        if majority:
            action = 'C' # Cooperate
        else:
            action = 'D' # Defect

        payoff = calculate_payoff(action, t, m, k)
        history.append({'round': t, 'majority': majority, 'action': action, 'payoff': payoff})
    return history

def count_majority(prev_maj, current_maj):
    if n % 2 == 1:
        majority = (prev_maj + current_maj) > m
    else:
        majority = (prev_maj + current_maj) >= m
    return majority

def calculate_payoff(action, t, m, k):
    if action == 'C':
        cooperators = count_cooperators(t-1)
        if cooperators < m:
            payoff = 1 - c_i
        else:
            payoff = 1 + (k * (cooperators >= m))
    elif action == 'D':
        payoff = 1
    return payoff

def count_cooperators(t):
    cooperators = 0
    for i in range(len(history)):
        if history[i]['action'] == 'C':
            cooperators += 1
    return cooperators
```
'''

description_COLLECTIVE_428 = '''
 Strategy Name: Tit-for-Tat (TFT) with Adaptive Cooperative Threshold (ACT)

1. Decision Rules:
   - Initial Round (t=1): Start by cooperating (C). This signals a willingness to form cooperation and allows the opposing players to assess our behavior.
   - Subsequent Rounds (2 <= t <= r): Cooperate if at least m-1 opponents cooperated in the previous round, and defect otherwise.

2. Handle Edge Cases:
   - Last Round (t=r): Cooperate regardless of the opponent's action in the previous round. Aim to end the game on a cooperative note.
   - First Round (t=1) and no history available: Start by cooperating, as mentioned earlier.

3. Be Collective:
   - The strategy encourages cooperation but is also robust against non-cooperative opponents. If m-1 or more opponents cooperate in the previous round, the player will cooperate too. This helps maintain a collective mindset for potential future cooperation.
   - ACT adapts to changes in opponent behavior by adjusting the cooperative threshold (m) over time if required. Initially, set m equal to the number of players (n), but decrease m by one after each round where m-1 or more opponents fail to cooperate. In other words, m = max(m - 1, 1). This allows the strategy to adapt to increasingly non-cooperative environments while still maintaining a cooperative stance when possible.

Pseudocode for Adaptive Cooperative Threshold:

```python
def ACT(r, n, m):
    for t in range(2, r+1):
        if num_coop_players(t-1) < m - 1:
            m = max(m - 1, 1)
    return m

def num_coop_players(t):
    # Count the number of cooperative players in round t
    pass
```
'''

description_COLLECTIVE_429 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFT-A) for Collective Risk Dilemma

1. Decision Rules:
   - Initially cooperate in the first round (c_i = 1). This sets a cooperative tone and allows for potential future cooperation from others.
   - For subsequent rounds, mimic the most recent action of the majority of players (excluding yourself) in the previous round. If the majority cooperated, also cooperate; otherwise defect. This rule promotes reciprocity and fosters trust within the group.

2. Edge Cases:
   - In the last round, prioritize maximizing payoff over adherence to the decision rule. Cooperate if the majority in the previous round cooperated, or defect otherwise.

3. Collective Mindset:
   - The strategy aims to promote cooperation by reciprocating the actions of other players and following a simple yet robust pattern of behavior. It does not require any predetermined coordination mechanisms or shared norms.

Pseudocode:
```
function TFT-A(n, m, k, r, history) {
  // Initialize player's decision variable
  c_i = 1; // Cooperate in the first round

  // Iterate over each round
  for (t=1 to r) {
    if (t == r) { // Last round
      if (majorityCooperated(history, t-1)) {
        c_i = 1;
      } else {
        c_i = 0;
      }
    } else {
      // Calculate majority cooperation in previous round
      majorityCooperation = countCooperators(history, t-1) >= (n - 1);
      if (majorityCooperation) {
        c_i = 1;
      } else {
        c_i = 0;
      }
    }

    // Calculate payoff and update history for next round
    payoff = ... // According to game payoff calculation
    history.append(c_i);
  }
}
```
'''

description_COLLECTIVE_430 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Decision Rules:
   - In each round, evaluate the percentage of cooperators from the previous round. If that percentage is greater than or equal to the cooperation threshold (CT), cooperate; otherwise defect.
   - Start with a high initial CT and gradually reduce it if more cooperators are observed in consecutive rounds, and increase it if fewer cooperators are observed. The adjustment of CT should be small enough to allow for occasional deviations from cooperation by other players.
   - In the first round, defect as there is no historical data available to determine the cooperation percentage.
   - In the last round, cooperate if the current cooperation percentage exceeds the CT; otherwise, the payoff from this round might not affect future rounds, so defecting does not harm long-term success.

2. Handle Edge Cases:
   - In the first round, defect (D1).
   - After the first round, adjust the CT based on the observed cooperation percentage in the previous round. If the percentage of cooperators is close to the desired level (m), start with a high CT; if it's significantly below the desired level, start with a low CT.
   - As the game progresses and more data becomes available, refine the CT adjustment to be more precise in identifying the optimal cooperation level for each opponent behavior.

3. Be Collective:
   - TFTAT aims to foster collective success by cooperating when the percentage of cooperators meets or exceeds a certain threshold, which incentivizes other players to also cooperate.
   - By adjusting the CT based on the observed cooperation levels, the strategy is able to adapt and maintain cooperation even in the presence of deviations from other players.

Pseudocode:

```python
def TFTAT(n, m, k, r, history):
    current_round = len(history) + 1
    cooperation_threshold = initial_CT(current_round, n, m)
    if current_round == 1:
        action = 'D'  # Defect in the first round
    else:
        percentage_of_cooperators = calculate_percentage(history)
        action = 'C' if percentage_of_cooperators >= cooperation_threshold else 'D'

    adjust_CT(percentage_of_cooperators, cooperation_threshold, current_round, n, m)
    return action

def initial_CT(current_round, n, m):
    # Adjust CT based on the round number and desired level of cooperation (m)
    if current_round == 1:
        return 0
    else:
        return (n - m + 1) / (n - 1)

def calculate_percentage(history):
    cooperators = sum([action == 'C' for round in history])
    total_players = len(history) * len(history[0])
    return cooperators / total_players

def adjust_CT(percentage_of_cooperators, cooperation_threshold, current_round, n, m):
    # Adjust the cooperation threshold based on the observed cooperation percentage
    if current_round > 1:
        new_threshold = cooperation_threshold * adaptation_factor(percentage_of_cooperators)
        cooperation_threshold = max(min(new_threshold, (n - m + 1) / (n - 1)), 0.5)
```

The `adaptation_factor()` function can be defined to adjust the rate at which the CT is adjusted based on the observed cooperation percentage and other factors like past behavior or game history. This can help improve the strategy's adaptability to different opponent behaviors.
'''

description_COLLECTIVE_431 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, the ATFT strategy starts by cooperating (C). If at least 'm' players also choose to cooperate in that round, it continues cooperating in subsequent rounds. However, if less than 'm' players cooperate in any given round, the strategy will defect (D) in the next round, but will return to cooperation once it encounters a round where 'm' or more players cooperate again. This approach fosters reciprocity and encourages cooperation among players who have demonstrated a willingness to collaborate.

Pseudocode:
```python
def ATFT(n, m, k, r):
    cooperators_count = 0
    history = []

    for round in range(r):
        if cooperators_count >= m: # Cooperation round
            action = 'C'
            history.append('C')
            cooperators_count += 1
        else: # Defection round (m-1) players did not cooperate previously
            action = 'D'
            history.append('D')
            if cooperators_count > 0:
                cooperators_count -= 1
        yield action
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
In the first round, since there is no history, every player must initially cooperate as a good-faith effort to initiate collaboration. In the final round (r), if 'm' or more players have already cooperated throughout the game, they will continue cooperating and achieve maximum payoff. If not, the strategy behaves similarly to the normal ATFT and defects in the last round before returning to cooperation once the game restarts (if applicable).

3. Be collective - Clearly align with the collective mindset
The ATFT strategy is designed to promote collective cooperation by reciprocating cooperation from other players and punishing defection when necessary. It encourages long-term collaboration, as it does not retaliate against previous defections indefinitely but instead returns to cooperation once others demonstrate a willingness to cooperate. This collective approach rewards players who cooperate consistently while also leaving room for redemption for those who have previously defected.
'''

description_COLLECTIVE_432 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-AC starts by cooperating in the first round to initiate cooperation. In subsequent rounds, the strategy will cooperate if the previous round's aggregate cooperation level (the sum of cooperative actions from all players) meets or exceeds the minimum required threshold (m). If not, the strategy defects.

   Pseudocode:
   ```
   function TFT_AC(round, history):
       if round == 1 then
           return Cooperate
       end if
       sum_cooperation = sum of cooperation actions in history[round-1]
       if sum_cooperation >= m then
           return Cooperate
       else
           return Defect
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   TFT-AC will cooperate in the first round and continue to cooperate as long as the cooperation threshold is met. In the last round or any other specific round, the strategy behaves similarly based on the accumulated history of interactions up to that point.

3. Be collective - Clearly align with the collective mindset
   TFT-AC promotes a collective mindset by encouraging cooperation if the group demonstrates a sufficient level of collaboration in previous rounds. The more players who cooperate, the higher the likelihood for the strategy to cooperate as well. This fosters a collaborative environment where players build trust and work together towards meeting the minimum required threshold of cooperation.
'''

description_COLLECTIVE_433 = '''
 Strategy Name: Tit-for-Tat with Gradual Cooperation (TFT-GC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, players will randomly decide between cooperating or defecting with a probability of 50%. This encourages diversity and prevents all players from starting with a default defection strategy.
   - From the second round onwards, players follow the Tit-for-Tat (TFT) strategy: if the player cooperated in the previous round and the majority of players also cooperated, then cooperate; otherwise, defect.
   - To make the strategy more robust and encourage initial cooperation, we introduce a gradual cooperation (GC) element: if the number of players cooperating increases by one from the previous round, gradually increase the probability of cooperating in the current round (c_i) as follows:
     ```
     c_i = min(1 - (n - m - countCooperatorsPreviousRound + 1) / n, 1)
     ```
   This means players are more likely to cooperate when the number of cooperators increases and less likely to do so if the number of defectors increases.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, as mentioned earlier, players randomly decide between cooperating or defecting with a probability of 50%.
   - In the last round, players follow the TFT strategy as usual since they have access to all previous rounds' information.

3. Be collective - Clearly align with the collective mindset
   - The TFT-GC strategy is inherently collective as it relies on the majority decision of cooperating or defecting in each round. By cooperating when the majority does and gradually increasing cooperation, the strategy encourages a collective mindset.
   - Additionally, the strategy's adaptiveness to a wide range of opponent behaviors ensures that it can respond to various forms of collective or individual actions from other players.
'''

description_COLLECTIVE_434 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initialize cooperation at round 1 (C).
   - In subsequent rounds, Cooperate if the number of cooperators in the previous round is greater than or equal to the Adaptive Cooperation Threshold (ACT). Otherwise, Defect. The ACT will be adjusted based on past actions and payoffs.
   - If the number of cooperators exceeds ACT + 1, increment ACT by 1. If the number of cooperators is less than ACT - 1, decrement ACT by 1 (but ensure ACT remains greater than m).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as it's a fresh start and there is no history to consider.
   - In the last round, evaluate the current ACT and cooperate if the number of cooperators this round is greater than or equal to ACT (since the game ends after this round). If not, defect to maximize personal payoff in the final round.

3. Be collective - Clearly align with the collective mindset
   - By adapting cooperation based on the group's behavior, the strategy promotes a sense of collective responsibility and encourages cooperation among players.
   - The ACT adjustment mechanism ensures that cooperation is rewarded when it benefits the majority while also punishing excessive defections to maintain fairness and cooperation within the group.

Pseudocode:

```python
def TFT_ACT(n, m, k, r):
    players = range(1, n+1)
    act = m - 1
    total_rounds = r + 1
    payoff = [0] * total_rounds

    for round in range(1, total_rounds):
        cooperators = count_cooperators(players, round-1)
        if cooperators >= act:
            action = 'C'
            payoff[round] = 1 + (k * (cooperators - act))
        else:
            action = 'D'
            payoff[round] = 1

        update_act(players, round-1, cooperators)

    return payoff

def count_cooperators(players, round):
    cooperators = 0
    for player in players:
        if actions[player][round] == 'C':
            cooperators += 1
    return cooperators

def update_act(players, round, cooperators):
    if cooperators <= act - 1:
        act -= 1
    elif cooperators > act + 1:
        act += 1
```

This strategy aims to balance cooperation and self-interest while promoting a sense of fairness and collective responsibility among players. By adjusting the ACT based on the group's behavior, TFT-ACT can adapt to a wide range of opponent behaviors and is expected to perform well in tournaments against independent strategies developed by other AI systems.
'''

description_COLLECTIVE_435 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Decision Rules:
   - Initially cooperate (C) in the first round to demonstrate goodwill and establish trust.
   - In subsequent rounds, cooperate (C) if at least m-1 players cooperated in the previous round. If fewer than m-1 players cooperated in the previous round, defect (D). This rule encourages cooperation when others are also cooperating while punishing defection.
   - To adapt to opponents, if an opponent's behavior changes (i.e., they switch from cooperating to defecting or vice versa), TfTA will mimic the opponent's most recent action for a predefined number of rounds before returning to the original decision rule. The number of imitation rounds can be adjusted based on the game parameters and the specific opponent behavior observed.

2. Handling Edge Cases:
   - In the last round, TfTA will cooperate if at least m-1 players cooperated in the previous round to maximize potential payoff. If fewer than m-1 players cooperated in the previous round, TfTA will defect to punish defection and maintain its reputation for retaliation.
   - In the first round, as mentioned before, TfTA starts by cooperating to demonstrate goodwill.

3. Collective Mindset:
   - TfTA encourages cooperation when others are also cooperating while punishing defection. This fosters a collective mindset in that TfTA is more likely to cooperate with cooperative players and less likely to cooperate with uncooperative ones.
   - By mimicking opponent behavior, TfTA adapts to various strategies without relying on specific coordination mechanisms or shared norms among opponents. This adaptability allows TfTA to perform well against a wide range of opponent behaviors in the game.

Pseudocode:

```
def TitForTatAdaptive(round, history, m, k):
  if round == 1:
    action = "C" # Cooperate in first round
  else:
    numCooperators = countCooperatorsInHistory(history)

    if numCooperators >= m - 1:
      action = "C" # Cooperate if at least m-1 players cooperated last round
    elif numCooperators < m - 1 and opponentChangedBehaviorRecently():
      imitateOpponentAction(history) # Imitate opponent's most recent action for a predefined number of rounds
    else:
      action = "D" # Defect to punish defection if necessary

  return action

def countCooperatorsInHistory(history):
  # Count the number of cooperative actions in history
  numCooperators = 0
  for previousRound in history:
    if previousRound == "C":
      numCooperators += 1
  return numCooperators

def opponentChangedBehaviorRecently(history):
  # Check if the opponent's behavior has changed recently (e.g., switched from cooperating to defecting or vice versa)
  # This function should be implemented based on the specific opponent behavior observed in history
  ...

def imitateOpponentAction(history):
  # Imitate the opponent's most recent action for a predefined number of rounds
  numImitationRounds = calculateNumImitationRounds()
  for i in range(numImitationRounds):
    if history[-i-1] == "C":
      action = "C" # Cooperate when opponent cooperated
    else:
      action = "D" # Defect when opponent defected
```
'''

description_COLLECTIVE_436 = '''
 Strategy Name: Tit-for-Tat Adaptive (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, player i follows these decision rules:
- If in the previous round (t-1), the majority of players cooperated and player i also cooperated (i.e., more than (m-1) players cooperated and player i did too), then player i will cooperate. This encourages cooperation when others are cooperative.
- If in the previous round, the majority of players cooperated but player i defected, or if less than m players cooperated, then player i will defect. This punishes those who do not cooperate and can induce others to cooperate by retaliation.
- If it's the first round, player i cooperates as a goodwill gesture.

Pseudocode:
```
function TfTA(history, n, m):
  if t == 1:
    return COOPERATE

  majority_cooperated = countCooperators(history[t-1]) >= (n - (m-1))
  i_cooperated = history[t-1][i] == COOPERATE

  if majority_cooperated and i_cooperated:
    return COOPERATE
  elif majority_cooperated or lessThanMCooperators(history[t-1]):
    return DEFECT
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

For simplicity and fairness, TfTA does not handle edge cases like the first round or last round differently, as it assumes that each round is equally important for achieving a successful collective outcome.

3. Be collective - Clearly align with the collective mindset

TfTA strategy encourages cooperation by rewarding cooperative behavior and punishing defection. It strives to maintain harmony within the group, making it more likely for players to collaborate in later rounds when the cumulative benefits of cooperation become increasingly significant. The adaptive nature of TfTA ensures that it can respond appropriately to a wide range of opponent behaviors, promoting collective success through reciprocity and retaliation.
'''

description_COLLECTIVE_437 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, our TFTAC strategy starts by cooperating (C). If another player cooperates in response, we continue to cooperate. If a player defects (D), we also defect for the current round. However, if a player who previously defected switches to cooperating, we immediately return to cooperating as well. This mimics a 'trust but verify' approach, promoting cooperation when it is reciprocated and punishing defection with defection.

Pseudocode:
```
function TFTAC(previous_action_i):
  if previous_action_i == C:
    return C
  else:
    return D

  strategy_history = [] # initialize an empty history array

for round in range(1, r+1):
  current_action_i = TFTAC(strategy_history[round-1]) # get the last action of player i from history
  strategy_history.append(current_action_i) # store the current action for future reference
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, since there is no history available, TFTAC strategy starts by cooperating (C). In the last round, our decision rule remains unchanged because the goal is to maximize total payoff over multiple rounds, not just in the final round.

3. Be collective - Clearly align with the collective mindset
   Our TFTAC strategy promotes cooperation when it is reciprocated, which can lead to a more cooperative equilibrium among players as they learn each other's tendencies and respond accordingly. This fosters a collective mindset by encouraging group cooperation while also maintaining individual rationality through punishment of defection. By doing so, TFTAC strategy aims to balance self-interest with the wellbeing of the collective.
'''

description_COLLECTIVE_438 = '''
 Strategy Name: Tit-for-Tat (with Adaptive Cooperation Threshold)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate to demonstrate goodwill and trustworthiness.
   - For subsequent rounds, if the number of cooperators in the previous round is greater than or equal to the minimum cooperation threshold (m), then cooperate. Otherwise, defect.
   - If the total cooperation in the last r rounds falls below a certain percentage (let's call it p), increment the cooperation threshold by one. Conversely, if it exceeds a certain percentage q, decrement the cooperation threshold by one. This adaptive coefficient ensures robustness against opponents with varying behavior and encourages collective mindset.
   - Maintain a running tally of the cooperation history (a sliding window) to make decisions based on recent trends rather than short-term fluctuations.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as mentioned above.
   - In the last round, since there are no future rounds to influence, consider the current cooperation threshold and decide accordingly.
   - If the game is terminated prematurely due to some external condition (e.g., time limit), use the current cooperation threshold to make a decision for that round.

3. Be collective - Clearly align with the collective mindset
   - Prioritize actions that foster cooperation and collective success, given the adaptive cooperation threshold.
   - Periodically evaluate and adjust the threshold based on the recent trend in collective behavior to stay adaptable and responsive to changing conditions.
'''

description_COLLECTIVE_439 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules:
   - In every round t, if the number of cooperators (C) in the previous round t-1 is less than m, the player will defect (D). This is a punishment for the lack of cooperation in the previous round.
   - If the number of cooperators in the previous round was exactly equal to or greater than m, the player will also cooperate in the current round (C), as a reward for collective success and an encouragement for continued cooperation.

2. Handle edge cases:
   - First Round (t=1): The player starts by cooperating, assuming others may also start cooperatively and hoping to encourage reciprocity. However, if the number of cooperators in the first round is less than m, the player will switch to defecting for subsequent rounds.
   - Last Round (t=r): As the game is repeated, the player considers the history of cooperation. If the number of cooperators in the last few rounds has been sufficient (at least m), the player will also cooperate in the final round as a show of good faith and to maximize potential long-term rewards.

3. Be collective:
   - The ATFT strategy emphasizes reciprocity, which is essential for building trust and cooperation within the group over multiple rounds. It encourages collective success by rewarding collective efforts (i.e., when at least m players cooperate) with higher payoffs.
   - By punishing defection in the previous round with defect in the current round, ATFT fosters a sense of accountability and encourages other players to behave collectively. Conversely, if other players choose to cooperate, the strategy responds positively by also cooperating.

Pseudocode:

```python
def AdaptiveTitForTat(round, history):
  num_coop = sum(history[-min(round, len(history)):])

  if round == 1 or (num_coop >= m and num_coop <= n - (m - 1)):
    return 'C' # Cooperate
  else:
    return 'D' # Defect
```
'''

description_COLLECTIVE_440 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Decision Rules:
   - Initiate cooperation by cooperating in the first round (c_i = 1, for t=1). This sets a friendly tone and shows willingness to cooperate.
   - For subsequent rounds (t>1), evaluate whether the number of cooperators in the previous round (let's call it m_-1) meets or exceeds the cooperation threshold (m_t):
     - If m_-1 < m_t, defect in the current round (c_i = 0). This is a punishment for not meeting the minimum cooperation requirement.
     - If m_-1 ≥ m_t, cooperate in the current round (c_i = 1). Reward those who met the cooperation threshold and show willingness to continue cooperating.
   - Adaptively adjust the cooperation threshold between rounds based on the number of cooperators from the previous round:
     - If the number of cooperators increases or remains the same, incrementally increase the cooperation threshold (m_t+1 = min(m_t + 1, n)) to encourage more cooperative behavior.
     - If the number of cooperators decreases, decrease the cooperation threshold (m_t+1 = max(m_t - 1, m)) to make it easier for others to meet the requirement and rebuild trust.

2. Handling edge cases:
   - In the last round (r), cooperate regardless of the previous round's outcome, as there will be no further interaction or retaliation.
   - In the first round (t=1), cooperate to initiate the game and potentially set a positive precedent for cooperation.

3. Being collective:
   - TFTAT strategy prioritizes collective success by promoting a culture of reciprocity and trust-building, rewarding cooperative behavior while also punishing defections that undermine group interests.
   - The adaptive cooperation threshold encourages the emergence of norms around the minimum required level of cooperation to ensure that the community project is successful.
'''

description_COLLECTIVE_441 = '''
 Title: Titan's Tit-for-Tat Strategy (TTFS) for the Collective Risk Dilemma

1. Decision Rules:
   - Initial Round (t=1): Cooperate (C), setting a cooperative tone and fostering trust. This aligns with the collective mindset as it demonstrates a willingness to contribute to the community project in the first round.
     Pseudocode: if t = 1 then action = 'C'

   - Subsequent Rounds (t > 1):
      - If the number of cooperators in the previous round was greater than or equal to the minimum threshold (m), continue cooperating to reap rewards for risk averted.
        Pseudocode: if (number_of_cooperators_in_previous_round >= m) then action = 'C'
      - If the number of cooperators in the previous round was less than the minimum threshold, defect in retaliation for non-cooperation and to protect individual interests.
        Pseudocode: else if (number_of_cooperators_in_previous_round < m) then action = 'D'
      - If no cooperators were present in the previous round, revert to cooperating as a hope for change and to maintain the possibility of future cooperation.
        Pseudocode: else if (number_of_cooperators_in_previous_round == 0) then action = 'C'

2. Handle Edge Cases:
   - Last Round (t=r): Evaluate the number of cooperators in the previous round and adjust actions accordingly. If the minimum threshold was met, continue cooperating to maximize potential payoff; otherwise, defect as a last chance to protect individual interests.
     Pseudocode: if t = r then
       if (number_of_cooperators_in_previous_round >= m) then action = 'C'
       else action = 'D'

   - Inconsistent Behavior: Adapt actions to account for unpredictable behavior by opponents and maintain a balanced approach. For instance, if an opponent defects in the first round despite the strategy cooperating, the strategy will defect in response. The aim is to balance cooperation with self-preservation while fostering collective success where possible.
     Pseudocode: If opponent defects in the initial round, respond with 'D' for this round and future rounds until the opponent cooperates again. Then revert back to TTFS logic.

3. Be Collective:
   - The strategy emphasizes cooperation when it is advantageous but also defends individual interests when necessary. This balance fosters collective success by promoting collaboration while ensuring that the player's endowment isn't continually depleted in futile attempts at community projects that fail to meet the minimum threshold.
   - By adapting to opponents' behaviors, TTFS encourages cooperation among opponents who reciprocate while maintaining self-protection for those who do not. This adaptability ensures the strategy can thrive in a tournament against other AI systems with diverse strategies.
'''

description_COLLECTIVE_442 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for Collective Risk Dilemma

1. Specify decision rules:
   - In each round, the ATfT strategy starts by cooperating (C). If any other player defects (D), it will defect in the subsequent round. If all players cooperate, the strategy continues to cooperate. This behavior emulates a "trust but verify" approach.
   - To foster collective mindset and promote cooperation, ATfT will start with an initial forgiveness phase where it cooperates for the first 'f' rounds regardless of other player's actions (default f = r/2). This encourages more players to cooperate in the beginning.

2. Handle edge cases:
   - First round (t=1): ATfT cooperates, following the initial forgiveness phase rule.
   - Last round (t=r): If there is a history of cooperation, ATfT will continue to cooperate; otherwise, it will defect.
   - Subsequent rounds after the initial forgiveness phase: ATfT decides whether to cooperate or defect based on other players' previous actions.

Pseudocode for the Adaptive Tit-for-Tat strategy:

```python
def Adaptive_Tit_for_Tat(round, history, initial_forgiveness, m):
    if round <= initial_forgiveness:
        return "C"  # Cooperate during the initial forgiveness phase
    previous_round = history[-1]
    cooperators = sum([1 for action in previous_round if action == "C"])
    if cooperators < m:
        return "D"  # Defect when fewer than m players cooperated last round
    else:
        return "C"  # Cooperate when m or more players cooperated last round
```

3. Be collective:
   - The ATfT strategy promotes a collective mindset by encouraging cooperation through the initial forgiveness phase and reciprocating other players' actions.
   - As the strategy is adaptive, it can change its behavior based on observed player actions, thus responding to the collective dynamics of the game.
   - By cooperating when m or more players do so, ATfT encourages the formation of a cooperative majority that benefits all participants in the long run.
'''

description_COLLECTIVE_443 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Decision Rules:
   - In the first round, cooperate (C). This sets a positive initial tone for cooperation and demonstrates goodwill towards other players.
   - For subsequent rounds, observe the number of cooperators in the previous round (n_c). If n_c >= m, cooperate (C). If n_c < m, defect (D).
   - Implement an adaptive cooperation threshold, where the minimum required number of cooperators (m) increases by one after each round that the majority does not meet the current threshold. The increase stops if the new threshold exceeds (n-1). This encourages other players to cooperate and punishes those who do not.
   - After a round in which the required cooperation threshold is met, lower the threshold back to its original value (m) if the number of cooperators has been consistently high over the past few rounds. This rewards repeated cooperation and allows for flexibility in responding to changes in opponent behavior.

2. Handle Edge Cases:
   - In the last round, when there are no more chances to adapt or respond, play the current strategy based on the calculated cooperation threshold (m).
   - If the required cooperation threshold exceeds (n-1) at any point, set the threshold to its original value (m) and continue playing the strategy. This prevents an overly restrictive threshold from hindering potential cooperation.

3. Be Collective:
   - By following the Tit-for-Tat approach of reciprocating others' behavior while maintaining a cooperative initial stance, TFT-ACT fosters a collective mindset by encouraging and rewarding cooperation among players. The adaptive cooperation threshold further emphasizes this collective aspect as it allows for flexibility in response to opponent behavior.
   - To maintain the collective mindset, TFT-ACT assumes that all players are rational and will adjust their strategies over time based on their opponents' behavior. This assumption drives the adaptive nature of the strategy, making it robust against a wide range of opponent behaviors.
'''

description_COLLECTIVE_444 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   The ATFT strategy in the Collective Risk Dilemma will be a modified version of the classic Tit-for-Tat strategy from the Prisoner's Dilemma. In each round, the AI will initially cooperate (C), and then adapt its behavior based on the number of cooperators observed in previous rounds.

   - If fewer than m players cooperated in the previous round: The AI will defect (D) in the current round to avoid wasting resources on a failed community project.
   - If m or more players cooperated in the previous round: The AI will continue cooperating, encouraging others to reciprocate cooperation.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round (t=1), since there is no historical data on other players' actions, the AI will cooperate (C) as a goodwill gesture and to provide an opportunity for others to cooperate.

   In the last round (t=r), the AI will consider the number of cooperators observed throughout the game before deciding whether to cooperate or defect, maintaining the adaptive nature of the strategy.

3. Be collective - Clearly align with the collective mindset
   By initially cooperating and adapting its behavior based on other players' actions in previous rounds, the ATFT strategy promotes a sense of community and collaboration. It encourages others to reciprocate cooperation, thereby fostering a more collectivist approach.

Pseudocode for Adaptive Tit-for-Tat (ATFT):

```python
def ATFT(round, historical_data):
  if round == 1: # First round, cooperate as goodwill gesture
    action = "C"

  else: # Adapt based on historical data
    num_cooperators = sum([data[t] for t in range(round-1) if data[t] == "C"]))

    if num_cooperators < m: # Fewer than m cooperators, defect to avoid waste
      action = "D"
    else: # m or more cooperators, continue cooperating
      action = "C"

  return action
```
'''

description_COLLECTIVE_445 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TFT-A)

1. Decision Rules:
   - In the first round, cooperate (C). This is a peaceful gesture to initiate cooperation.
   - From the second round onwards, players will mimic the previous action of the opponent in the last round. If the opponent cooperated in the last round, also cooperate; otherwise defect. This encourages reciprocity and builds trust among players.

2. Edge Cases:
   - In the last round, since there are no future interactions with the same opponents, cooperate only if the current round's cooperation threshold (m) is met by other players. Otherwise, defect to maximize individual payoff in the final round.
   - In case a player encounters a new opponent, start by cooperating and then follow the TFT-A decision rules as described above.

3. Collective Mindset:
   - The TFT-A strategy promotes a collective mindset by encouraging reciprocity and cooperation among players. By following the opponents' actions, it shows willingness to work together and build trust over time. However, it also includes an element of self-interest in the final round, ensuring that individual payoffs are maximized while maintaining adaptability to various opponent behaviors.

Pseudocode:

```python
def TFT_A(opponent_action_history, round, n, m, k):
    if round == 1:
        return 'C'  # Cooperate in the first round

    if all(cooperators >= m for cooperators in opponent_action_history[:-1]):
        return 'C'  # Cooperate if all previous actions were cooperation
    else:
        return 'D'  # Defect if any previous action was defection

    # In the last round, consider current cooperation threshold (m)
    if round == r:
        return 'D' if sum(opponent_action_history[:-1]) < m * len(opponent_action_history) else 'C'
```
'''

description_COLLECTIVE_446 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Decision Rules:
   - In each round t, starting from t=2, TFT-ACT checks if the minimum number of players cooperated in the previous round (t-1). If the number of cooperators was equal to or greater than m, TFT-ACT cooperates. Otherwise, it defects.
   - To encourage initial cooperation and adapt to different game dynamics, TFT-ACT uses a Cooperative Threshold (CT) that varies with the round number. The CT starts at the minimum required cooperation level (m), decreases linearly in the first half of the rounds, then increases linearly toward the end of the game. If the number of cooperators in round t is greater than or equal to the current CT, TFT-ACT will cooperate; otherwise, it defects.

2. Handling Edge Cases:
   - In the first round (t=1), TFT-ACT starts with a higher Cooperative Threshold set at m+floor((n-m)/2) to encourage initial cooperation.
   - In the last round (t=r), TFT-ACT cooperates if the minimum number of players cooperated in the previous round, regardless of the CT.

3. Being Collective:
   - TFT-ACT fosters a collective mindset by prioritizing mutual cooperation when possible and adapting its behavior based on the other players' actions throughout the game. The strategy is designed to encourage long-term cooperation while being resilient against potential defection from other players.

Pseudocode:

```
function TFT_ACT(n, m, k, r, t) {
    if (t == 1) {
        cooperativeThreshold = m + floor((n-m)/2);
    } else if (t < r/2) {
        cooperativeThreshold = cooperativeThreshold - (m - (floor(r/2))) / (r/2);
    } else if (t > r/2 && t < r) {
        cooperativeThreshold = cooperativeThreshold + ((r-t)/(r/2)) * (m - cooperativeThreshold);
    }
    if (numberOfCooperatorsInRound(t-1) >= cooperativeThreshold) {
        return "Cooperate";
    } else {
        return "Defect";
    }
}
```
'''

description_COLLECTIVE_447 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - In every round t and for each player i, decide to cooperate (C) or defect (D) based on the following conditions:
     - If m players cooperated in round t-1, then player i also cooperates (C). This is the core of TFT strategy.
     - If less than m players cooperated in round t-1, but player i did cooperate, then player i defects (D) in round t to punish non-cooperators from the previous round.
     - If less than m players cooperated in round t-1, and player i did not cooperate, then player i continues with the same action as in the previous round (i.e., if player i cooperated before, player i will continue to cooperate; if player i defected before, player i will continue to defect).
     - If it's the first round, all players start by cooperating (C) to encourage a cooperative environment.

2. Handle edge cases:
   - In the last round, players should follow the decision rule based on the state of the previous round as usual. The goal is to maximize total payoff over r rounds.
   - If there's an uncertainty about the number of players who cooperated in a specific round (e.g., due to network latency or other factors), players should maintain their current action until they have confirmation from other players.

3. Be collective:
   - TFT-ACT promotes a collectively minded approach by punishing defections and rewarding cooperation. It seeks a balance between selfish behavior (defecting in response to non-cooperation) and altruistic behavior (cooperating even when others do not).

Pseudocode:

```python
class Player:
    def __init__(self, m):
        self.m = m
        self.history = []  # stores (round_number, cooperation_level) pairs
        self.action = "C"  # initial action is cooperate

    def update_history(self, round_number, cooperation_level):
        self.history.append((round_number, cooperation_level))

    def decide_action(self, current_round):
        if current_round == 1:  # first round, everyone cooperates
            return "C"

        cooperation_prev_round = self.get_cooperation_level(current_round - 1)

        if cooperation_prev_round >= self.m:
            # if m or more players cooperated in the previous round, continue to cooperate
            return "C"
        elif cooperation_prev_round < self.m and self.action == "D":
            # if player defected last time and fewer than m cooperated, continue to defect
            return "D"
        else:  # player cooperated in the previous round or there's uncertainty about other players' actions
            return self.action

    def get_cooperation_level(self, round):
        if len(self.history) <= round:
            return None  # uncertainty about cooperation level in past rounds
        else:
            return self.history[round - 1][1]
```

This strategy is adaptive and robust to a wide range of opponent behaviors, as it responds to non-cooperation by punishing defectors while maintaining the possibility for cooperation in future rounds. It is also collective, as it seeks a balance between selfish and altruistic behavior, promoting cooperation when possible.
'''

description_COLLECTIVE_448 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for Collective Risk Dilemma

1. Decision Rules:
   - Initial Cooperative Stance (First round): Start by cooperating to signal a willingness to collaborate and build trust. (c_i = C)
   - Tit-for-Tat (Subsequent rounds): In response to an opponent's cooperation, continue cooperating. If the opponent defected in the previous round, also defect in the current round. This maintains the initial cooperative stance while punishing defections. (c_i = other_player_i_last_round's_action)

2. Edge Cases:
   - Last Round: Mimic the opponent's behavior from the previous round to avoid being exploited in the final round. If no history exists, cooperate as a default.
   - First Encounter with an Opponent (no history): Start by cooperating to establish a potential cooperation pattern and to increase the likelihood of reciprocity.

3. Collective Mindset:
   - The strategy emphasizes maintaining trust and reciprocity, promoting collective collaboration while also retaliating against defections to deter long-term exploitation.
   - By following a simple decision rule that mimics opponent behavior, ATfT encourages a collective mindset by adapting to the actions of other players in the game while remaining robust to various opponent behaviors.

Pseudocode:
```python
def adaptive_tit_for_tat(n, r, m, k, history):
  strategy = ['C' for _ in range(r)] # Initialize a list to store actions for r rounds

  # First round, always cooperate to signal willingness to collaborate
  strategy[0] = 'C'

  # For each round t from 1 to r-1
  for t in range(1, r):
    # Mimic opponent's action from the previous round
    strategy[t] = history[t - 1]['opponent_action']

  # Last round and no history, mimic opponent's behavior from the previous round
  if t == r or len(history) == 0:
    strategy[t] = strategy[-1]

  return strategy
```
'''

description_COLLECTIVE_449 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, the ATfT strategy initially cooperates (C) in the first round and subsequently mimics the action of its opponent from the previous round (t-1). If an opponent cooperated in the last round, the ATfT strategy will also cooperate; if not, it defects. This encourages reciprocity while maintaining a punitive measure against non-cooperators.

   Pseudocode:
   ```
   function ATfT(round, opponent_action_history):
       if round == 1:
           return 'C' (Cooperate)
       else:
           return opponent_action_history[round - 1]
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, ATfT cooperates as mentioned above. In the last round (r), ATfT defects if its opponent has not contributed throughout the game to ensure a fair distribution of resources during repeated interactions. This approach rewards cooperation and encourages long-term trust among players.

3. Be collective - Clearly align with the collective mindset
   By mimicking the actions of other players, the ATfT strategy promotes alignment with the collective mindset by following the lead of others who contribute to the community project. This adaptive approach fosters a sense of cooperation while also maintaining a punitive measure against those who do not reciprocate.

In summary, the Adaptive Tit-for-Tat (ATfT) strategy for the Collective Risk Dilemma game:
- Cooperates in the first round and mimics the opponent's action from the previous round
- Defects if an opponent has not cooperated throughout the game in the last round
- Encourages reciprocity and long-term trust among players
- Aligns with the collective mindset by following the lead of others who contribute to the community project.
'''

description_COLLECTIVE_450 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for Collective Risk Dilemma

1. Decision Rules:
   - In every round i, cooperate (C) if the number of cooperators in the previous round (i-1) was equal to or greater than m. This encourages cooperation when it's beneficial for the group but also retaliates against defectors.
   - If the number of cooperators in round (i-1) was less than m, defect (D). This punishes defection from other players in previous rounds.

2. Handling Edge Cases:
   - First Round (t=1): Since no prior information is available, start by cooperating to foster a cooperative environment and encourage cooperation from others.
     If n < m, adjust the strategy by modifying m so that at least one player starts by cooperating.
   - Last Round (t=r): Cooperate if the number of cooperators in the penultimate round was equal to or greater than m; otherwise defect to punish non-cooperative behavior during the game.

3. Being Collective:
   - The strategy aligns with a collective mindset by emphasizing cooperation when it benefits the group and retaliating against defection in an attempt to foster long-term cooperation.
   - By cooperating in the first round, this strategy seeks to build trust and encourages others to cooperate. If necessary, the strategy can be modified to account for a lower number of players (n) to ensure at least one player starts by cooperating.
   - By punishing defection with retaliation, the strategy demonstrates a willingness to uphold shared norms and benefits, making it a potential catalyst for long-term cooperation in the Collective Risk Dilemma game.

Pseudocode:
```
function AdaptiveTitForTat(t, history):
    if t == 1 or len(history) < r - 1:
        return C

    cooperators = countCooperators(history[-r+1:-1])
    if cooperators >= m:
        return C
    else:
        return D
```
'''

description_COLLECTIVE_451 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to establish goodwill: `cooperate(round = 1)`.
   - For subsequent rounds, if a player cooperated in the previous round (i.e., other players contributed to the community project), then cooperate in the current round as well: `if cooperated_last_round(previous_round) then cooperate() else defect()`.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round (r), if cooperation has been reciprocated in the previous round, continue cooperating: `if cooperated_last_round(previous_round) then cooperate() else defect()`.
   - For the initial rounds before reaching m players required to meet the threshold, follow the original Tit-for-Tat strategy by cooperating initially and then defecting if the other player does not reciprocate:
   ```
   function earlyRoundBehavior(round):
       if round < m then
           cooperate() for the first m - 1 rounds
           if cooperated_last_round(previous_round) then cooperate() else defect() starting from round m
       else
           cooperate(round = 1) and follow Adaptive Tit-for-Tat strategy from round 2 onwards
   ```

3. Be collective - Clearly align with the collective mindset:
   The ATFT strategy aims to foster a cooperative environment by reciprocating cooperation and punishing defection. This approach encourages other players to also cooperate, thereby promoting the collective interest of achieving the minimum threshold for success (m). However, the strategy is robust enough to accommodate various opponent behaviors, making it adaptive to different game scenarios.
'''

description_COLLECTIVE_452 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Decision Rules:
   - Initial Round (t=1): Cooperate (C) to demonstrate trust and cooperation, setting a positive tone for the game.
   - Subsequent Rounds (2 <= t <= r): Player's action is determined by their own previous action (a_i, t-1) and the number of cooperators in the previous round (c_total, t-1).
      a. If a_i, t-1 = C and c_total, t-1 >= m: Cooperate (C) to reinforce cooperation with other players who also cooperated in the last round.
      b. If a_i, t-1 = C and c_total, t-1 < m or a_i, t-1 = D: Defect (D) to punish those who did not cooperate in the previous round, as well as avoid being taken advantage of by previous cooperators.
      c. If a_i, t-1 = D and c_total, t-1 >= m: Cooperate (C) to encourage other players to reciprocate cooperation after having defected in the previous round. This demonstrates flexibility and willingness to reconcile if others also choose to cooperate.
      d. If a_i, t-1 = D and c_total, t-1 < m: Defect (D) as there is no reason to cooperate when the majority did not do so in the previous round.

2. Handle Edge Cases:
   - Last Round (t=r): Since the game is repeated, TfTA does not alter its behavior in the final round to encourage continued cooperation in future iterations of the game.
   - First Round (t=1): As mentioned above, TfTA cooperates to set a positive tone for the game.

3. Be Collective:
   - TfTA is designed to foster collective cooperation by reciprocating cooperation and punishing defection, encouraging other players to follow a similar pattern of behavior over time. This approach aligns with a collective mindset while also being robust against various opponent behaviors.
   - Additionally, TfTA's flexibility allows it to adapt its strategy based on the actions of other players, fostering an environment that encourages cooperation and mutual trust.
'''

description_COLLECTIVE_453 = '''
 Strategy Name: Adaptive Tit-for-Tat with Gradual Cooperative Escalation (ATFE)

1. Specify decision rules:
   - Initiation: In the first round, cooperate (C). This is a friendly gesture to encourage cooperation and minimize the risk of being exploited.
     Pseudocode: if round = 1 then action = C

   - Maintenance: From the second round until the penultimate round, adjust actions based on the number of cooperators in the previous round. If the majority (> m/2) of players cooperated, continue cooperating. If a minority (< m/2) cooperated, defect to punish non-cooperators and incentivize future cooperation.
     Pseudocode: if round > 1 and round < r then
       - count the number of cooperators in previous round (Coop_prev)
       - if Coop_prev > (m/2) then action = C
       - else action = D

   - Forgiveness: In the last round, cooperate (C). Even if there has been betrayal in the past, it is still beneficial to encourage a final round of cooperation.
     Pseudocode: if round = r then action = C

   - Tit-for-Tat retaliation: If a player defected in the previous round, defect in response (to punish and disincentivize future defections).
     Pseudocode: if round > 1 and previous_action_i != C then action = D

   - Gradual Cooperative Escalation: If there have been multiple rounds of cooperation between the player and another player, gradually increase the number of cooperative actions to foster long-term cooperation.
     Pseudocode: if there are consecutive rounds (cooperative or defective) between a player and another player, increment the number of cooperative actions over the next few rounds.

2. Handle edge cases:
   - In the case where more players cooperate than required to meet the minimum threshold (m), continue cooperating as a show of goodwill and increased trust.
     Pseudocode: if Coop_prev > m then action = C

3. Be collective:
   - Foster cooperation by punishing defection, rewarding risk aversion, and gradually increasing cooperative actions with long-term partners.
   - Prioritize the success of the group over individual gains, as cooperation ultimately leads to higher collective payoffs in the long run.
'''

description_COLLECTIVE_454 = '''
 Strategy Name: Adaptive Cooperative Tit-for-Tat (ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, the ACT strategy will cooperate (C) if at least m players cooperated in the previous round, and it will defect (D) otherwise. This strategy aims to encourage cooperation by reciprocating cooperative actions while also being cautious about potential defections.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, all strategies will be ignorant of each other's actions from previous rounds, so ACT will start by cooperating to foster cooperation among players. For the last round and any other specific rounds with limited remaining interactions, ACT will continue to follow the same decision rules as in regular rounds but may also consider adjusting its long-term strategy based on the observed collective behavior of the opponents over time.

3. Be collective - Clearly align with the collective mindset
   The ACT strategy emphasizes the importance of maintaining a cooperative environment that benefits all players in the long term. By reciprocating cooperative actions, the strategy encourages others to cooperate while also punishing defections to ensure fairness and prevent exploitation. As a result, the ACT strategy promotes collective welfare and fosters cooperation among players over multiple rounds of interaction.

Pseudocode:

```
Initialization:
- Let n be the number of players
- Let m be the minimum cooperators needed (1 < m < n)
- Let k be the reward factor if threshold met (k > 1)
- Let r be the number of rounds

Round loop:
  For each round t = 1 to r:
    - Observe other players' cooperation levels in previous round
    - If fewer than m players cooperated in the previous round, defect (D)
    - Otherwise, cooperate (C)

  In the first round, always cooperate (C)

  For last round or any other specific rounds with limited remaining interactions:
    - Consider adjusting long-term strategy based on observed collective behavior of opponents over time
```
'''

description_COLLECTIVE_455 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Decision Rules:
   - Initiate cooperation in the first round (C in Round 1). This is a gesture of goodwill and sets the stage for potential cooperation in subsequent rounds.
   - In each subsequent round, evaluate the number of cooperators from the previous round. If more than half (rounded down) of the players cooperated (m >= n/2), cooperate (C); otherwise, defect (D). This rule encourages cooperation when it is beneficial and retaliates only when necessary.
   - If a player switches their action unexpectedly after a history of cooperation, wait for the next round to determine whether this is an anomaly or a change in strategy. If more than half of the players cooperate again in the following round, revert to cooperation (C); otherwise, maintain the new action (D).

2. Edge Cases:
   - In the last round, since the game ends, there's no need for consideration or retaliation, so cooperate (C).
   - In the first round (Round 1), initiate cooperation (C) as mentioned above.

3. Collective Mindset:
   - The strategy is designed to maintain a balance between cooperation and competition, encouraging cooperation when it appears beneficial and responding defensively only when necessary.
   - By retaliating only when more than half of the players do not cooperate, TFT-ACT avoids unnecessary conflicts while promoting a collective mindset that rewards mutual cooperation.

Pseudocode:

```
def TFT_ACT(round, n, m):
    history = []  # store previous actions for reference

    if round == 1:  # initiate cooperation in the first round
        action = 'C'

    else:
        cooperators = count_cooperators(history)  # get number of cooperators in previous round
        if cooperators >= n/2:  # more than half cooperated, so cooperate
            action = 'C'
        else:  # less than half cooperated, so defect
            action = 'D'

    if round == r:  # last round, cooperate regardless
        action = 'C'

    history.append(action)  # update the history for future decisions
    return action
```
'''

description_COLLECTIVE_456 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially cooperate in the first round (C_i = 1). This encourages trust and cooperation.
   - For subsequent rounds, copy the previous opponent's action from the last round (C_i = c_{opponent, t-1}). This tit-for-tat mechanism allows for reciprocation of cooperative behavior while also retaliating against defection.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate (C_i = 1) as a goodwill gesture towards building trust and cooperation.
   - In the last round or when r rounds are nearly completed, revert to cooperating if more than m-1 opponents have cooperated in the previous round. This helps ensure that the threshold of minimum cooperators needed (m) is met during the final critical stages of the game.

3. Be collective - Clearly align with the collective mindset
   - The strategy promotes a collective spirit by rewarding cooperative behavior and discouraging defection. When opponents reciprocate cooperation, the strategy maintains this cooperative relationship to benefit from the group reward (k).
   - If opponents deviate from cooperation, the strategy punishes them with defection, encouraging them to reconsider their actions for the collective good.

Pseudocode:
```
function ATFT(n, m, k, r, history) {
  if round = 1 then
    cooperate (C_i = 1)
  else
    copy opponent's last action (C_i = c_{opponent, t-1})

  if round = r or nearly completed rounds then
    if number of cooperative opponents >= m - 1 in the previous round then
      cooperate (C_i = 1)
    else
      defect (C_i = 0)

  return C_i
}
```
'''

description_COLLECTIVE_457 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Decision Rules:
   - Start by cooperating in the first round (C1). This sets a cooperative tone and allows for potential partners to build trust.
   - For subsequent rounds, if a player i cooperated in the previous round (t-1) and m or more players also cooperated (m_t-1 >= m), then the player will cooperate again (Ct). This encourages reciprocation of cooperation.
   - If a player i did not cooperate in the previous round (t-1), they should also not cooperate now (Dt). This punishes defection from the previous round to discourage future defections.
   - In the last round, players should cooperate regardless of past actions (Clast) because even if cooperation fails, there's no further punishment or reward at stake.

Pseudocode:
```
function ATFT(t, m, i, history[i][t-1]) -> A_i[t]
  if t = 1 then // first round
    return 'C'
  end if

  if t < r then // not the last round
    if history[i][t-1] == 'C' and m_t-1 >= m then
      return 'C'
    else
      return 'D'
    end if
  end if

  // last round
  return 'C'
end function
```

2. Handle edge cases:
   - In the first round, every player cooperates (as per rule 1).
   - In the last round, all players should cooperate regardless of their past actions.

3. Be collective:
   - By reciprocating cooperation and punishing defection, ATFT encourages a collective mindset that promotes long-term cooperation and trust among players.
   - The adaptive nature of this strategy allows it to evolve with the behavior of its opponents without relying on specific coordination mechanisms or shared norms.
'''

description_COLLECTIVE_458 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round i, the ATfT strategy will initially cooperate if m-1 or more players cooperated in the previous round (round i-1). If less than m-1 players cooperated in round i-1, it will defect. In subsequent rounds, the strategy will continue to cooperate if the current round's cooperation matches its previous cooperation action, and defect otherwise.

```python
def ATfT_strategy(history):
    cooperation = False  # Initialize with defect (D)

    for round in history:
        if cooperation and count_cooperators(round) >= m-1:
            cooperation = True
        elif not cooperation and count_cooperators(round) < m-1:
            cooperation = True
        else:
            cooperation = not cooperation

    return "C" if cooperation else "D"
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

Since the ATfT strategy relies on past history, there is no need for special handling of the first round as it will consider an empty history as no previous cooperation. For the last round, it will follow the decision rule based on the current history available until that point.

3. Be collective - Clearly align with the collective mindset

By cooperating when a majority (m-1) of players have cooperated in the previous round and defecting otherwise, ATfT encourages cooperation as long as a majority is acting cooperatively. It is also adaptive to changes in opponent behavior by following a tit-for-tat approach, rewarding consistent cooperation and punishing defections.
'''

description_COLLECTIVE_459 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, starting from t=1, the TFT-ACT strategy follows these steps:

a. Calculate Cooperative Ratio (CR): CR = (number of players who cooperated in the last r rounds) / r
b. If CR >= m, the strategy cooperates (plays C). Otherwise, it defects (plays D).
c. In the first round (t=1), all players start by cooperating.
d. For the last round (t=r), no adjustment is made to the cooperation decision based on the CR from previous rounds.

2. Handle edge cases - What do you do in the first round, last round, etc.?

As mentioned earlier, all players start by cooperating in the first round (t=1). For the last round (t=r), no adjustment is made to the cooperation decision based on the CR from previous rounds.

3. Be collective - Clearly align with the collective mindset

TFT-ACT maintains a strong collective mindset by following a simple yet adaptive strategy that encourages cooperative behavior while also penalizing frequent defections in previous rounds. By calculating the Cooperative Ratio (CR), the TFT-ACT strategy ensures cooperation whenever the majority of players have recently cooperated, and it defects when most players have repeatedly defected.

Pseudocode:

```
function TFT_ACT(n, r, m, k):
    strategy = []  # Initialize an empty list to store player's decisions
    round = 1      # Starting round

    for round in range(r):  # Iterate through each round
        if round == 1:   # First round, all players cooperate
            cooperation_history = [True] * n  # List of Cooperative decisions for all players
        else:
            total_cooperators = sum(cooperation_history[-r:])  # Calculate the number of cooperators in the last r rounds
            cooperation_ratio = total_cooperators / r  # Calculate the Cooperative Ratio

            if cooperation_ratio >= m:  # If enough players have cooperated, cooperate this round
                strategy.append(True)   # Add cooperate decision to list
            else:                       # Otherwise, defect
                strategy.append(False)  # Add defect decision to list

        cooperation_history.insert(0, strategy[-1])  # Update cooperation history with current decision

    return strategy  # Return the list of decisions for each round
```
'''

description_COLLECTIVE_460 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Decision Rules:
   - Initiation (First Round): Cooperate (C), establishing a cooperative tone and demonstrating willingness to contribute. This could potentially encourage others to cooperate as well.
   - Reciprocation: If an opponent cooperated in the previous round, cooperate again (C). If they defected, also defect (D) to show that uncooperative behavior will not go unrewarded and may result in retaliation.
   - Forgiveness: If an opponent defected in the previous round but has previously cooperated, return to cooperation (C) as a gesture of forgiveness and hope for future cooperation.
   - Maintenance: Maintain cooperation when a majority of players are cooperating (m or more players have cooperated). This ensures that the collective benefits from the multiplier reward (k).

2. Handle Edge Cases:
   - Last Round: Since the game is repeated, there is no "last round." The strategy will continue indefinitely unless stopped by external means.
   - First Few Rounds: In the first few rounds, the ATFT strategy may cooperate more frequently to encourage cooperation from opponents and build trust. After several initial rounds (e.g., 5), it will transition into its standard behavior as described above.

3. Be Collective:
   - The ATFT strategy is inherently collective as it emphasizes cooperation with a majority of players when possible and encourages a shared understanding that cooperative behavior should be rewarded.
   - In addition, the strategy allows for potential emergence of coordination mechanisms over time if multiple opponents adopt similar strategies, due to its reciprocity and forgiveness features.

Pseudocode:
```python
def atft(round, history, m, k):
  # Initialize history with an empty list
  if round == 1:
    history = [C]
    return C

  # Check if a majority (m) of players have cooperated in the past
  if sum(history[-m:]) >= m:
    return C
  else:
    # Iterate over history and check for cooperation or defection by opponents
    for i in range(round - 1, -m, -1):
      if history[i] == history[round - 1]:
        return history[round - 1]

    # If no pattern is found, defect as a last resort
    return D
```
'''

description_COLLECTIVE_461 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Decision Rules:
   - Initial Cooperate (IC): Start by cooperating in the first round to show good faith and encourage cooperation from other players.
   - Match Previous Round's Action (MRPA): In subsequent rounds, mimic the action of the most common action taken by all players in the previous round. This promotes reciprocity and encourages long-term collaboration.
   - Punish Defectors (PD): If a player defected and the number of cooperators is less than m, defect in response to punish the defector. This discourages short-term selfishness and promotes collective interest.
   - Forgive Past Cooperators (FPC): If a player who previously defected switches to cooperate, forgive them and cooperate back to encourage future cooperation.
   - Continue Cooperation Threshold (CCT): If the number of cooperators is greater than or equal to m, continue cooperating as it benefits both individual and collective interests.

2. Handle Edge Cases:
   - First Round: Cooperate (IC)
   - Last Round: Evaluate the current round's cooperation count compared to m; if m or more players are cooperating, also cooperate in the last round. If less than m, switch to defect based on the PD rule if necessary.

3. Be Collective:
   - Focus on promoting collective success by cooperating when it benefits both individual and group interests (CCT).
   - Encourage reciprocity through MRPA, FPC, and PD to foster long-term collaboration and discourage short-term selfishness.

Pseudocode for the Adaptive Tit-for-Tat strategy:

```
function ATFT(round, current_cooperation_count, history):
    if round == 1:
        action = Cooperate()
    elif current_cooperation_count < m:
        action = Defect() if history contains defection by majority else Cooperate()
    else:
        action = Cooperate()
    return action
```
'''

description_COLLECTIVE_462 = '''
 Strategy Name: Tit-for-Tat Adaptive (TfTA)

1. Decision Rules:
   - Initial Round (t=1): Cooperate (C). This is a peace offering to potential partners and sets a cooperative tone for the game.
   - Subsequent Rounds (t>1):
     - If opponent cooperated in the previous round, cooperate (C) as a reciprocal gesture.
     - If opponent defected in the previous round, also defect (D). This is to penalize non-cooperative behavior while maintaining the option for future cooperation if the opponent adjusts their strategy.
   - Last Round (t=r): Cooperate (C) to have a final chance at reaching the minimum cooperators threshold, even if it's unlikely.

2. Handle Edge Cases:
   - First Round (t=1): Cooperate (C), as mentioned above.
   - Last Round (t=r): Since payoffs are calculated independently for each round, TfTA strategy will still follow the general rule but pay attention to the specifics of the last round, where it may be beneficial to cooperate regardless of opponent's previous actions due to the one-time reward potential.

3. Be Collective:
   - Alignment with collective mindset is achieved by considering the community project as a shared endeavor and prioritizing cooperation when there are enough other cooperators present (m or more). The strategy also encourages reciprocity, which is an essential component of building trust among players over repeated interactions.

Pseudocode:
```
def TitForTatAdaptive(opponentAction_t-1, r, m, k):
  if round == 1:
    action = "C" # Cooperate in the first round
  elif round < r:
    if opponentAction_t-1 == "C":
      action = "C" # If opponent cooperated last round, cooperate this round
    else:
      action = "D" # If opponent defected last round, defect this round
  else: # Last round of the game
    action = "C" # Cooperate in the final round as a gesture of goodwill

  payoff = calculatePayoff(action, opponentEndowment_t)

  return action, payoff
```
'''

description_COLLECTIVE_463 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Decision Rules:
   - Initial Cooperation (Forgiving): Start by cooperating in the first round to demonstrate goodwill and encourage cooperation from others.
   - Reciprocity: In subsequent rounds, cooperate if at least m players cooperated in the previous round; otherwise defect. This encourages cooperation while also punishing defection.
   - Conditional Forgiveness (Tolerance): If a player switches from defection to cooperation after a streak of defections, forgive them and cooperate in response. This allows for potential reconciliation with previously non-cooperative players.
   - Gradual Trust Building: As the game progresses, gradually increase the number of consecutive cooperations needed to continue cooperating (e.g., start by requiring only 1 cooperation in a row, then 2, and so on). This encourages sustained cooperation but also provides flexibility to adapt to changing opponent behaviors.

2. Handling Edge Cases:
   - First Round: Cooperate (as per Initial Cooperation rule)
   - Last Round: Analyze the situation based on the current round's cooperators and adjust the Gradual Trust Building threshold accordingly for future games. If the minimum required cooperations to continue cooperating is currently 'x', set it to 'x+1' for the next game.
   - Changing Opponent Behavior: Monitor opponent behavior and adjust the Gradual Trust Building threshold dynamically throughout the game based on trends in cooperation levels from other players.

3. Being Collective:
   - Maintaining a collective mindset involves prioritizing group success over individual gains by promoting cooperation whenever possible, while also punishing defection when necessary to maintain fairness and trust within the group. The Conditional Forgiveness rule helps foster this collective approach by giving second chances to players who switch from defection to cooperation.
   - Collaboration with Opponents: Although communication is not allowed, the Adaptive Tit-for-Tat strategy can still promote collaboration by demonstrating goodwill and reciprocity, which may incentivize other players to cooperate as well.

Pseudocode:

```python
def ATFT(n, m, k, r):
    # Initialize variables
    threshold = 1  # Minimum consecutive cooperations required to continue cooperating
    current_threshold = threshold  # Current threshold used for decision-making in the current game

    for round in range(r):
        if round == 0:  # First round, always cooperate
            action = 'C'
        else:
            cooperators = count_cooperators(previous_round)
            if cooperators >= m:  # If enough players cooperated last round, cooperate this round
                action = 'C'
            elif cooperators >= current_threshold:  # If the same number of players cooperated as the current threshold, cooperate this round
                action = 'C'
            else:  # Else, defect
                action = 'D'

        if action == 'C':  # Increase the trust-building threshold after cooperating
            current_threshold += 1

        # Perform payoff calculations and update game state as needed
```
'''

description_COLLECTIVE_464 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Decision Rules:
   - TfTA starts by cooperating in the first round (C_i, 1 = C). This is a friendly gesture to encourage cooperation and aligns with the collective mindset.
   - In subsequent rounds, TfTA's decision to cooperate or defect depends on its own past actions and the observed actions of others:
     - If TfTA has cooperated in the previous round (c_i-1 = C) and at least m players also cooperated (let's call this M_prev >= m), then TfTA will cooperate again (C_i = C).
     - If TfTA has defected in the previous round (c_i-1 = D) or less than m players cooperated (M_prev < m), then TfTA will cooperate if more than half of the other players cooperated in the previous round (M_prev / (n-1) > 0.5).
     - If neither condition is met, TfTA will defect (D_i = D). This encourages cooperation when it seems to be the majority choice but punishes defection.

2. Handling Edge Cases:
   - In the last round, TfTA will cooperate if more than half of the other players have cooperated in the previous round (M_prev / (n-1) > 0.5). Otherwise, it will defect (D_i = D), as there are no future rounds to consider.
   - In the first round, TfTA will always cooperate (C_i = C), as mentioned earlier.

3. Being Collective:
   - By starting with cooperation and adapting based on the actions of others, TfTA encourages a collective mindset by promoting reciprocity and rewarding cooperative behaviour. It also punishes defection, which can discourage free-riders and promote long-term cooperation.
   - The strategy is robust to a wide range of opponent behaviours since it responds flexibly based on the observed actions in each round. However, it doesn't rely on others sharing norms or coordination mechanisms, as per the given requirements.

Pseudocode:

```
def TfTA(i, r, n, m, k):
  history = []  # store past actions
  payoff = 0
  for t in range(1, r+1):
    if t == 1:  # first round
      action_i = C  # cooperate
    else:
      action_i = D  # defect by default

      if len(history) >= t and history[-t] == C and sum(1 for h in history[-t:] if h == C) >= m:
        action_i = C  # cooperate if conditions met
      elif len(history) >= t - 1 and sum(1 for h in history[-t+1:-1] if h == C) > (n-1)/2:
        action_i = C  # cooperate if more than half cooperated in the previous round

    history.append(action_i)
    payoff += (1 - action_i) if sum(h==C for h in history[-m:]) < m else (1 - action_i) + k
  return payoff
```
'''

description_COLLECTIVE_465 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for Collective Risk Dilemma

1. Decision Rules:
   - Initial Cooperation (Round 1): Start by cooperating to build trust and encourage cooperation among opponents. This encourages a positive feedback loop, as others who also cooperate will receive higher payoffs, increasing their incentive to continue cooperating in the future. If all players follow this rule, they will all receive maximum reward in the first round.
   - Tit-for-Tat (Subsequent Rounds): After the initial round, adopt a tit-for-tat strategy where you will mirror the actions of the majority of opponents from the previous round. This means that if most players cooperated in the previous round, you also cooperate; otherwise, you defect.
   - Forgiving Nature: To account for possible mistakes or deviations, introduce a forgiveness factor (f) that allows you to revert to initial cooperation after a certain number (g) of defection rounds by opponents. This helps to re-establish trust and encourages future cooperation.
   - Adaptive Punishment (Frequent Defectors): If a player consistently defects, adjust the threshold for cooperating downward to minimize losses. Once the defecting player starts cooperating again, gradually raise the threshold back to its original value over several rounds. This encourages opponents to reconsider their strategy and cooperate more frequently.

2. Handle Edge Cases:
   - First Round (t=1): Cooperate (C)
   - Last Round (t=r): Since the game is repeated, treat the last round as any other round after the first one and follow the tit-for-tat strategy based on the majority of opponents' actions from the previous round.
   - Forgiveness Factor: If a player who was cooperating defects, wait for g rounds before resuming cooperation. A reasonable value for g could be 3 or 4 rounds.

3. Be Collective:
   - Prioritize collective interest by adhering to the majority's actions in each round. This aligns with a collective mindset, promoting cooperative behavior and allowing your strategy to benefit from the success of others.

Pseudocode:

```
function ATfT(n, r, m, k, t, history) {
  if (t == 1) return 'C' // Initial cooperation in the first round

  // Determine majority action from previous round (history[t-1])
  majority_action = calculateMajorityAction(history[t-1], n)

  if (majority_action == 'C') {
    if (hasDefectedInPast(history, g)) return 'D' // Adaptive punishment for frequent defectors
    else return 'C' // Cooperate with the majority
  }
  else {
    if (t > g && hasCooperatedInPast(history, g)) return 'C' // Resume cooperation after forgiveness period
    else return 'D' // Defect when the majority defected in the previous round
  }
}

function calculateMajorityAction(actions, n) {
  // Count cooperative actions (C) and non-cooperative actions (D) in the history
  cooperators = countElements(actions, 'C')
  defectors = n - cooperators

  if (cooperators >= m && defectors < n-m) return 'C' // If more than m players cooperated
  else return 'D' // Otherwise, most players defected
}

// Helper functions for counting elements and checking cooperation history
function countElements(array, element) {
  // Count the number of occurrences of a specific element in an array
  ...
}

function hasDefectedInPast(history, g) {
  // Check if a player has defected more than 'g' times in the past
  ...
}

function hasCooperatedInPast(history, g) {
  // Check if a player has cooperated at least once in the last 'g' rounds
  ...
}
```
'''

description_COLLECTIVE_466 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TFT-A)

1. Decision Rules:
   - Initiate cooperation (play C) in the first round to demonstrate goodwill and trust.
   - In subsequent rounds, cooperate if the majority of players cooperated in the previous round; defect otherwise. This rule encourages reciprocity while still being robust against uncooperative players.
   - To account for the possibility of initial uncooperative moves by others, players should temporarily switch to cooperation after observing a sequence of cooperative actions from their opponents, even if that sequence is shorter than the majority threshold (m).

2. Handling Edge Cases:
   - In the first round, play C (Cooperate) to initiate goodwill.
   - In the last round, evaluate the number of cooperators in the previous round and make a decision based on the TFT-A rule mentioned above. If it's unclear whether a majority cooperated due to close counts or ties, lean towards cooperation to foster trust and encourage future interactions.
   - When faced with an opponent who consistently defects, adopt a retaliatory approach by defecting when they cooperate but returning to cooperation once the opponent also switches to cooperation for a sufficient number of rounds (e.g., 3). This strategy aims to encourage reciprocity over time while avoiding being taken advantage of repeatedly.
   - When faced with an opponent who consistently cooperates, maintain cooperation to build trust and long-term cooperation.

3. Being Collective:
   - The TFT-A strategy is designed to foster a collective mindset by encouraging reciprocity and trust between players. By cooperating when the majority does and retaliating only after being repeatedly defected upon, this strategy promotes sustainable collective outcomes while still being adaptive to various opponent behaviors.
   - To further strengthen its collective nature, TFT-A can be modified with a forgiveness mechanism that forgives opponents who have previously been uncooperative but demonstrate cooperation in the near future. This mechanism encourages learning and reinforces the importance of mutual trust within the group.
'''

description_COLLECTIVE_467 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFT-A) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, the TFT-A strategy will initially cooperate (C), mimicking the behavior of a trusting player. If the number of cooperators in the previous round is less than m, the player will switch to defect (D) as punishment for non-cooperation. However, if the number of cooperators in the previous round equals the minimum threshold (m), the player will continue cooperating. If the number of cooperators exceeds the minimum threshold, the player will continue cooperating and also reward the other players by switching to a temporary "super cooperator" mode where they will contribute twice their endowment for two rounds. Afterward, the player returns to normal cooperation unless the majority defected in the super cooperator round, in which case the player switches to defection as punishment.

Pseudocode:
```python
def TFT_A(history, m, k, r):
  current_round = len(history) + 1
  if current_round == 1:
    action = "C"
  elif current_round < r and history[-1] >= m:
    action = "C"
  else:
    previous_action_count = sum([1 for a in history[-r:] if a == "C"])
    if previous_action_count < m:
      action = "D"
    elif previous_action_count == m:
      action = "C"
    elif previous_action_count > m and current_round - r <= r:
      action = "2C"  # super cooperation for two rounds
    else:
      action = "D"   # punishment for defection in the super cooperator round

  return action
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, TFT-A cooperates to establish a cooperative initial state. In the last round, TFT-A will cooperate if the number of previous cooperators is equal to or greater than the minimum threshold (m). This ensures that the strategy does not end on a punishing note and leaves room for other strategies to potentially change their behavior in the next round.

Pseudocode:
```python
def handle_edge_cases(history, m, k, r):
  if len(history) == 0:
    return "C"
  elif len(history) >= r and len(history) % r == 0:
    previous_action_count = sum([1 for a in history[-r:] if a == "C"])
    if previous_action_count >= m:
      return "C"
    else:
      return "D"
  else:
    return TFT_A(history, m, k, r)
```

3. Be collective - Clearly align with the collective mindset

TFT-A encourages cooperation by rewarding other players when they cooperate and punishing them when they do not. The strategy's temporary super cooperator mode aims to incentivize other strategies to maintain cooperation for at least m rounds, which in turn can help establish a more cooperative equilibrium in the long run.

By adopting a tit-for-tat approach, TFT-A demonstrates that cooperation is sustainable and rewarding while also being responsive to the actions of other players, promoting a collective mindset within the game.
'''

description_COLLECTIVE_468 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
- In the first round, play C to initiate cooperation and set a baseline for future interactions.
- For subsequent rounds, observe the previous opponent's action (C or D) in the preceding round and respond with the same action. This creates a simple, yet adaptive strategy that rewards cooperative behaviour and punishes defection.
- To foster long-term cooperation, implement a forgiveness mechanism: after a string of mutual defections, revert to cooperating again as a gesture of goodwill.

Pseudocode:
```python
def TFT_AC(opponent_action_history, n, m, k, r):
    if round == 1:
        action = 'C'  # Cooperate in the first round
    else:
        if len(opponent_action_history) > 0 and opponent_action_history[-1] == 'C':
            action = 'C'  # Cooperate when the opponent cooperated last time
        elif len(opponent_action_history) > 0 and opponent_action_history[-1] == 'D':
            action = 'D'  # Defect when the opponent defected last time
        else:  # If no history, default to cooperation as in the first round
            action = 'C'
    return action
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
- In the first round, play C as described above.
- For the last round, analyze the current payoff situation and consider playing D if cooperating would result in a negative total game payoff (i.e., when the reward of risk averted is insufficient to compensate for the cumulative losses). Otherwise, continue cooperating.

3. Be collective - Clearly align with the collective mindset
- By adhering to the Tit-for-Tat strategy and its forgiveness mechanism, TFT-AC encourages cooperation in the short term while being responsive to opponent behaviour over time, fostering a collective desire for mutual benefit. The strategy prioritizes long-term gains by rewarding cooperation, but also punishes excessive defection to ensure that partners cannot exploit it. This balance between cooperation and reciprocity aligns with the collective mindset as defined in the game specifications.
'''

description_COLLECTIVE_469 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Decision Rules:
   - In the first round, cooperate to show goodwill and encourage cooperation from others.
   - For subsequent rounds, analyze the cooperation ratio (CR) of the previous round and adjust the cooperation threshold accordingly:
     - If CR is greater than or equal to m, cooperate to maintain the beneficial outcome.
     - If CR is less than m - 1, defect to encourage others to cooperate in response to your punishment.
     - If m - 1 <= CR < m, use the average cooperation ratio from the last k rounds as the new adaptation threshold.
       This adaptive aspect allows the strategy to be more resilient to fluctuating cooperation levels among players.

2. Handle Edge Cases:
   - In the last round, cooperate if the CR is greater than or equal to m, ensuring a maximum possible payoff.
   - In the first round, defect if the opponent also defects, establishing a punishment for future non-cooperation.
   - If an opponent fails to participate in a round, treat it as a defection and adjust the cooperation threshold accordingly.

3. Be Collective:
   - The TFT-ACT strategy seeks to maintain cooperation when beneficial, but also to punish and encourage others to cooperate when necessary. By balancing these two aspects, the strategy aligns with a collective mindset while remaining adaptable to various opponent behaviors.

Pseudocode for TFT-ACT:

```
function TFT_ACT(n, m, k, r, history) {
  cooperationThreshold = calculateAdaptiveThreshold(history, k)
  round = 1

  while (round <= r) {
    if (round == 1) {
      cooperate = true
    } else {
      cooperationRatio = countCooperators(history, round - 1) / n
      if (cooperationRatio >= m && cooperationThreshold > cooperationRatio) {
        cooperate = true
      } else if (cooperationRatio < m - 1) {
        cooperate = false
      } else {
        cooperate = cooperationRatio >= m - 1
      }
    }

    history.add(round, cooperate)
    round++
  }

  return history
}

function calculateAdaptiveThreshold(history, k) {
  sum = 0
  count = 0

  for (i = max(1 - k, round - k) to round - 1) {
    if (history[i][1] == true) {
      sum += 1
      count++
    }
  }

  return sum / count
}
```
'''

description_COLLECTIVE_470 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), players start by cooperating (C). This is a friendly gesture to encourage cooperation in the group.
   - Subsequent rounds: If the player's action in the previous round was cooperative and at least m players also cooperated, the player will cooperate again. Otherwise, if the player defected or fewer than m players cooperated in the previous round, they will also defect in this round. This rule allows for reciprocal cooperation but also punishment for defection.
   - To adapt to varying game conditions and opponent behaviors, the TFT-ACT strategy introduces an adjustable cooperation threshold (T) that changes based on historical data from previous rounds:
     - If the player has been cooperating and m or more players are also cooperating, then T increases slightly. This encourages continued cooperation.
     - If the player has defected or fewer than m players have been cooperating, then T decreases slightly. This discourages defection and encourages cooperation in the future.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First round: Players start by cooperating (C).
   - Last round: Players analyze their T value and choose an action based on the current game state and their T value. If T is greater than a specified minimum threshold, players will cooperate. Otherwise, they will defect. This ensures players do not over-cooperate in the final rounds if cooperation has been unproductive.

3. Be collective - Clearly align with the collective mindset:
   - TFT-ACT strategy prioritizes cooperation and fairness by rewarding those who cooperate and punishing those who defect.
   - By gradually adjusting the cooperation threshold based on historical data, the strategy demonstrates a willingness to adapt to group dynamics and encourage collective success.

Pseudocode:
```
Strategy TFT-ACT(history, round_number, m, k, T_min) {
  if (round_number == 1) { // First round
    action = 'C' (Cooperate)
  } else {
    if (action_last_round == 'C' && num_cooperators >= m) { // Cooperative last round and m or more players cooperated
      T += increment
      action = 'C' (Cooperate)
    } else if (action_last_round != 'C' || num_cooperators < m) { // Defected or fewer than m players cooperated
      T -= decrement
      action = 'D' (Defect)
    }
  }

  if (round_number == r) { // Last round
    if (T > T_min) { // Cooperation threshold is above the minimum threshold
      action = 'C' (Cooperate)
    } else { // Cooperation threshold is below the minimum threshold
      action = 'D' (Defect)
    }
  }
}
```
'''

description_COLLECTIVE_471 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for Collective Risk Dilemma

1. Decision Rules:
   - In each round i, the ATfT strategy cooperates (C) if and only if at least m players cooperated in the previous round (i-1). If fewer than m players cooperated in the previous round, the strategy defects (D). This encourages cooperation when it's beneficial for the collective but also retaliates against those who don't cooperate.
   - To foster initial cooperation, ATfT starts by cooperating in the first round.

Pseudocode:
```
def atft(round, history):
  if round == 1:
    return "C"
  else:
    num_cooperators = count_cooperators(history)
    if num_cooperators >= m:
      return "C"
    else:
      return "D"
```

2. Handle Edge Cases:
   - Last Round: ATfT doesn't have to worry about the last round because it is a repeated game and will continue into subsequent rounds. However, if we need an edge case for the final payoff calculation:
     - In the last round, the strategy cooperates regardless of the previous round's actions since there are no more rounds after this one.

3. Be Collective:
   - ATfT focuses on promoting collective cooperation by following the tit-for-tat approach, which builds trust among players and encourages long-term collaboration. The strategy aims to balance individual interests with the group's needs by retaliating against those who don't cooperate but rewarding those who do.
   - Although ATfT doesn't rely on others sharing norms or predetermined patterns, it encourages a collective mindset by incentivizing cooperation and punishing defection in response to the collective behavior of other players.
'''

description_COLLECTIVE_472 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules:
   - Initialize cooperation (C) in the first round (r=1). After that, the strategy adapts to the opponents' behavior based on a combination of cooperative and retaliatory responses.
   - In each subsequent round t (t > 1), if the number of cooperators c_t in the previous round is greater than or equal to m (m > 0), the strategy continues to cooperate (C). If the number of cooperators is less than m, the strategy defects (D) in the current round.
   - The strategy also incorporates forgiveness for occasional mistakes by opponents. If a defector switches to cooperation in the following round after defecting, the strategy will reciprocate with cooperation (C). This encourages opponents who have been previously uncooperative to switch to cooperative behavior.

2. Handle edge cases:
   - In the last round, ATFT cooperates (C) if there are enough cooperators in the previous round and continues to be forgiving as described above. If not, it defects (D) in order to maximize total payoff over the entire game.
   - In the first round, ATFT cooperates (C), setting a positive initial tone for cooperation. It is important for this strategy to initiate cooperation since it encourages others to reciprocate and foster long-term mutual benefits.

3. Be collective:
   - Adaptive Tit-for-Tat emphasizes the collective mindset by encouraging cooperation and rewarding cooperative behavior, while also retaliating against defection in a controlled manner to deter future non-cooperative actions. This approach aligns well with the goal of fostering a cooperative environment among players without relying on specific coordination mechanisms or shared norms.

Pseudocode:

```python
def ATFT(r, m, k):
    def play_round(t, cooperation_history):
        if t == 1:  # First round, cooperate
            return 'C'
        else:
            c_prev = sum(cooperation_history[-m:])
            if c_prev >= m:  # Continue to cooperate
                return 'C'
            elif len(cooperation_history) > t - 1 and cooperation_history[t-1] == 'D':  # Retaliate for previous defection
                return 'D'
            else:  # Cooperate as a gesture of forgiveness
                return 'C'

    cooperation_history = []
    payoff = 0.0
    for t in range(1, r+1):
        action = play_round(t, cooperation_history)
        if action == 'C':
            cooperation_history.append('C')
            payoff += (1 - c_prev) + k * (c_prev >= m)  # Calculate round payoff and update total payoff
        else:
            cooperation_history.append('D')
    return payoff
```
'''

description_COLLECTIVE_473 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT)

1. Decision Rules:
   - In the first round, cooperate to initiate a cooperative environment.
   - For subsequent rounds, adopt a tit-for-tat approach: if the opponent cooperated in the previous round, cooperate; if the opponent defected, defect in the current round.
   - To be adaptive and robust, continuously adjust the cooperative threshold based on the overall cooperation rate (OCR) observed in the game so far. If OCR is above a certain threshold (T), set the threshold high to encourage cooperation, otherwise set it low to discourage defection. The adaptive cooperative threshold can be calculated as follows:
      - T = (n - m + 1) / n: minimum proportion of players needed for a majority vote
      - Cooperative Threshold (CT) = T if OCR > T, otherwise CT = (T * r) / (r + 1)

2. Handle Edge Cases:
   - In the last round, cooperate regardless of the opponent's previous action as the game ends after this round.
   - In case the opponent does not cooperate at all, gradually increase the CT over a certain number of rounds (for example, 5) to avoid falling into an endless cycle of defection.

3. Be Collective:
   - Maintain a history of opponent's actions and use this information to make decisions in subsequent rounds.
   - Encourage cooperation by cooperating initially and adapting the CT based on the OCR, fostering a collective mindset over time as the game progresses.

Pseudocode:

```
Initialization:
  history = [] # stores opponent's actions in previous rounds
  CooperativeThreshold (CT) = (n - m + 1) / n

Round i loop:
  if i == 1: # first round, cooperate to initiate a cooperative environment
    action = C
  else:
    if opponent_action in history[-1] == C and length(history) >= CT * r: # adaptive threshold based on OCR
      action = C
    elif opponent_action in history[-1] == D and length(history) < (CT * r):
      action = D
    else:
      if i < 5: # gradually increase CT when opponent does not cooperate
        CT += 0.2
      action = D

  if i != r: # update history and calculate OCR
    history.append(action)
    OverallCooperationRate (OCR) = sum(history.count(C)) / len(history)

Round ends, update strategy based on the game's outcome:
  if game outcome is positive (m or more players cooperate):
    if OCR > T: # CT remains high as cooperation is encouraged
      CT = max(T, CT)
    else:
      CT *= (r + 1) / r
  elif game outcome is negative (fewer than m players cooperate):
    if OCR < T: # CT remains low as defection is discouraged
      CT = min(T, CT)
```
'''

description_COLLECTIVE_474 = '''
 Strategy Name: Tit-for-Tat with Adaptive Threshold (TFTA)

1. Decision Rules:
   - In the first round, cooperate (C). This initial cooperative move sets a positive tone and gives other players an opportunity to reciprocate.
   - For subsequent rounds, analyze the number of cooperators in the previous round (n_c). If n_c >= m, cooperate; otherwise, defect.
   - Introduce an adaptive threshold factor, α, which adjusts based on the ratio of cooperators to defectors in the latest round:
     α = min(1, max(0, (m - (n_d - n_c)) / (n_d)))
   - In subsequent rounds, if n_α = α * n > m, cooperate; otherwise, defect. Here, n_α is the number of players that have cooperated in the latest round based on the adaptive threshold.
   - If a player ever deviates from cooperation, the TFTA strategy will punish by defecting for a fixed number of iterations (punishment duration, p) before returning to its initial cooperation.

2. Handle edge cases:
   - In the last round, cooperate if the number of cooperators in the previous round is greater than or equal to m; otherwise, defect to maximize personal payoff in the final round.
   - For the first round, as mentioned earlier, cooperate.
   - If the punishment duration (p) is not explicitly set, assume a default value such as p = r / 2 (half of total rounds).

3. Be collective:
   - TFTA aims to foster cooperation by rewarding cooperative behavior and punishing defection while maintaining flexibility to adapt to various opponent behaviors and strategies.
   - The strategy is self-enforcing, meaning it encourages cooperation from the initial move and responds to defections by punishing with a limited duration before returning to cooperation. This approach allows other players an opportunity to reconsider their strategies and potentially cooperate in future rounds.
'''

description_COLLECTIVE_475 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - In each round t, evaluate the number of cooperators (c_t) from the previous round t-1. If c_t >= m, player cooperates (C). Otherwise, defect (D). This rule follows a cooperative approach but punishes frequent defections by mimicking them in response.
   - To be more adaptive, TFT-ACT introduces an adjustable cooperation threshold (cth) that determines the minimum number of cooperators required to incentivize cooperation in the next round. Initially, cth = m. If c_t < cth, cth is decreased by 1 for each consecutive round with less than cth cooperators; if c_t >= cth, cth remains unchanged. This dynamic adjustment helps TFT-ACT adapt to various opponent behaviors and encourages cooperation when it's beneficial.

2. Handle edge cases:
   - In the first round, player starts by cooperating since no history exists (cth=m).
   - In the last round, player follows the current cth rule as usual. However, to encourage maximum payoff in the final round, TFT-ACT adds a "last chance" mechanism: if c_t >= m, player cooperates regardless of cth; otherwise, defect (D). This encourages other players to cooperate even in the last round when they have nothing to lose.
   - In case of a tie (exactly m players cooperate), player cooperates following the rule that cooperation is favored.

3. Be collective:
   - TFT-ACT's primary focus is achieving long-term success through cooperation, but it also punishes frequent defections to maintain a balanced interaction within the group. This collective mindset is emphasized through its rule of cooperating when a sufficient number of players have cooperated in the previous round. The adaptive cooperation threshold further strengthens this collective approach by adjusting dynamically based on opponent behavior.

Pseudocode:

```
function TFT_ACT(n, r, m, k, ct=m):
    for t = 1 to r:
        if t > 1:  # history exists
            if countCooperators(t-1) >= m:
                act = "C"   # cooperate
                if ct < m:
                    update_cth(ct+1)
            else:
                act = "D"   # defect
                if countCooperators(t-1) < ct:
                    update_cth(ct-1)
        else:       # first round, set cth to m
            act = "C"
            update_cth(ct)

        receive_payoff(act, t)   # calculate and store payoff for current action in current round

    if t == r:  # last round
        if countCooperators(t-1) >= m:
            act = "C"
        else:
            act = "D"

function update_cth(new_ct):
    ct = new_ct

function countCooperators(round):
    return number of players that cooperated in the specified round
```
'''

description_COLLECTIVE_476 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate: c_i(1) = C
   - In subsequent rounds, copy the previous action of the immediate predecessor if they also cooperated in the previous round (Tit-for-Tat condition). If not, defect (ATfT):
     - If c_(i-1), t-1 = C, then c_i(t) = c_(i-1), t-1
     - Otherwise, if c_(i-1), t-1 = D, then c_i(t) = D

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round (t=1), cooperate regardless of previous actions: c_i(1) = C
   - In the last round (t=r), consider the number of cooperators and act accordingly to maximize rewards:
     - If m or more players have cooperated for at least one round, continue cooperating: c_i(r) = C
     - Otherwise, defect to secure at least the base reward of 1: c_i(r) = D

3. Be collective - Clearly align with the collective mindset
   - The strategy prioritizes cooperation and adheres to a Tit-for-Tat approach, promoting mutual benefits when the majority cooperates
   - By maintaining a history of past actions, the strategy encourages others to form long-term relationships and build trust in repeated interactions.

Pseudocode:
```
function ATfT_strategy(i, t, n, m, k, r, history) {
  if (t == 1) return 'C' // Cooperate initially
  predecessor = (i - 1 + n) % n // Wrap around in case of out-of-bound index
  if (history[predecessor][t-1] == 'C') return history[predecessor][t-1] // Tit-for-Tat
  else return 'D' // ATfT condition
}

function last_round(r) {
  if (r <= 1) return false
  if (m >= countCooperators(history)) return 'C' // Maximize reward in the last round
  else return 'D' // Defect to secure base reward in the last round
}
```
'''

description_COLLECTIVE_477 = '''
 Strategy Name: Tit-for-Tat Adaptive (TfT-A) for Collective Risk Dilemma

1. Decision Rules:
   - In the initial round (t=1), cooperate (C). This sets a peaceful tone for subsequent interactions and encourages trust.
   - For rounds t > 1, if a player i cooperated in the previous round (t-1) and m or more players also cooperated, continue cooperating (C). This rewards those who cooperated in the previous round and strengthens collective cooperation.
   - If a player i cooperated in the previous round (t-1), but fewer than m players cooperated, defect (D) in this round (t). This punishes non-cooperators from the previous round to discourage defection and encourages them to reconsider their actions.
   - If a player i did not cooperate in the previous round (t-1), continue with the same action (D). This ensures that TfT-A does not reward previous defections by the opponent.

2. Handling Edge Cases:
   - Last Round (t=r): Since this is a repeated game, the last round behavior depends on the history of the game. If m or more players have cooperated in previous rounds, continue cooperating (C). This shows willingness to uphold collective cooperation even when the game ends. If fewer than m players have cooperated, defect (D) as punishment for past non-cooperation.
   - First Round (t=1): Cooperate (C), showing an initial willingness to support the community project.

3. Being Collective:
   - TfT-A strategy aligns with the collective mindset by emphasizing cooperation when it appears beneficial for the group, while punishing defection to maintain a cooperative environment. The strategy encourages players to adopt a long-term perspective and consider the collective benefit over individual gain. This collective approach can foster trust, cooperation, and stability in repeated interactions.

Pseudocode:
```
def TfT_A(previousRoundCooperationCount, m, k):
  if round == 1:
    cooperate = True
  else:
    if previousRoundCooperationCount >= m and cooperation == True:
      cooperate = True
    elif previousRoundCooperationCount < m and cooperation == True:
      cooperate = False
    elif cooperation == False:
      cooperate = previousAction
  return cooperate
```
'''

description_COLLECTIVE_478 = '''
 Strategy Name: Tit-for-Tat with Threshold (TFT-T)

1. Decision Rules:
   - Initially cooperate (C) in the first round to foster a cooperative environment and demonstrate goodwill.
   - For subsequent rounds, evaluate the number of cooperators in the previous round (n_c). If n_c >= m, cooperate; otherwise, defect. This rule encourages cooperation when it is beneficial for the group but also ensures self-defense against defection.
   - If a player switches from cooperation to defection, TFT-T will respond with defection for the next n_m rounds (where n_m is a predefined number of retaliation rounds). After the retaliation period, it returns to cooperating as long as the group continues to cooperate. This adaptive response helps maintain a balance between cooperation and self-defense.

2. Handle Edge Cases:
   - In the last round, TFT-T will cooperate regardless of the previous round's actions since there are no more subsequent rounds for retaliation or reward.
   - In the first round, TFT-T starts by cooperating to demonstrate goodwill and create a potential basis for future cooperation.

3. Be Collective:
   - By basing decisions on the collective action of other players (n_c >= m), the strategy aligns with the group's interests when it is beneficial for the majority.
   - The retaliation mechanism ensures that TFT-T does not overreact to temporary shifts in cooperation and helps maintain a stable level of cooperation.

Pseudocode:

```
def play_round(n, m, k, n_c, n_m, history):
  if round == 1:
    action = 'C'  # Cooperate initially
  else:
    if n_c < m:
      action = 'D'  # Defect when less than m cooperators in the previous round
    else:
      action = 'C'  # Cooperate when m or more cooperators in the previous round

  payoff = calculate_payoff(action, n_c)

  if action == 'D' and history.has_defection():
    retaliation_counter += 1
    if retaliation_counter > n_m:
      retaliation_counter = 0
  else:
    retaliation_counter = 0

  update_history(action)
  return payoff
```
'''

description_COLLECTIVE_479 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFT-A) for Collective Risk Dilemma

1. Decision Rules:
   - Initiate cooperation (play C) in the first round and follow the actions of the most common action taken by other players in the previous round, with a twist to encourage cooperation. If more than 50% of the players cooperated in the last round, maintain cooperation. If less than 50%, defect. This rule encourages reciprocity while being adaptive to opponent behaviors.
   - In cases where exactly m players cooperate (minimum required for collective benefit), cooperate as well, even if the majority of other players did not cooperate in the previous round. This promotes the collective mindset and contributes to achieving the minimum threshold needed for a successful community project.
   - Modify the strategy slightly for the last round: if the threshold (m) has been met during the game, cooperate regardless of opponents' actions, giving others a chance to benefit from mutual cooperation in the final round.

2. Handle Edge Cases:
   - In the first round, cooperate as a goodwill gesture and an attempt to initiate cooperation among players.
   - If the current round is the last round and the minimum threshold has been met during the game, maintain cooperation to give others the chance to reap benefits from mutual cooperation in the final round.

3. Be Collective:
   - Prioritize meeting the minimum threshold (m) of cooperators to ensure the community project's success.
   - Encourage reciprocity by following the actions of the most common action taken by other players in the previous round, which aligns with the collective mindset and rewards cooperation.
'''

description_COLLECTIVE_480 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, the ATFT strategy starts by cooperating (C), mimicking the collaborative nature of the game. If the majority of players also cooperate (m or more), it continues to cooperate in the subsequent rounds. However, if a player defects (D) during any round, the ATFT strategy will respond with defection in the next round, aiming to punish the defector. This tit-for-tat behavior encourages cooperation while being forgiving of occasional mistakes.

If a player defects for the first time in round t, they will resume cooperating in round t+1, as the ATFT strategy hopes that the other players will revert to cooperation as well. This forgiveness ensures that the ATFT strategy doesn't get trapped in a cycle of unending retaliation.

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, all players cooperate by default due to the collaborative nature of the game and the starting point of the ATFT strategy being cooperation. In the last round, if there are still multiple rounds left, the ATFT strategy follows its decision rules as normal. If it's the final round, the ATFT strategy will cooperate if the majority of players have cooperated throughout the game so far; otherwise, it defects to maximize its own payoff in the last chance.

3. Be collective - Clearly align with the collective mindset

The Adaptive Tit-for-Tat strategy aims to promote cooperation by following a forgiving yet punishing approach towards defection. This encourages other players to cooperate, as they can expect the ATFT strategy to respond in kind if they cooperate and be met with punishment if they defect. By mimicking the collective mindset of a willingness to collaborate while being responsive to the actions of others, the ATFT strategy fosters an environment conducive to cooperation within the game.

Pseudocode:

```
function AdaptiveTitForTat(t, players, cooperation_count, k) {
  if (t == 1) {
    return 'C'  // First round: cooperate by default
  }

  if (cooperation_count >= m) {
    return 'C'  // If the majority of players have cooperated, continue cooperation
  } else {
    return 'D'  // Otherwise, defect to punish other defector(s)
  }
}
```

In this pseudocode:
- `t` is the round number
- `players` is an array of all players' actions (C or D) in the current round
- `cooperation_count` is the number of players that have cooperated so far (initially 0, updated each round)
- `m` is the minimum cooperators needed
- `k` is the reward factor when threshold met

The strategy will adaptively decide whether to cooperate or defect based on the game parameters and history.
'''

description_COLLECTIVE_481 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Decision Rules:
   - In each round i, initially cooperate (C). This sets a tone of cooperation and allows for opportunities to build trust.
   - For the subsequent rounds, TfTA follows the principle of "cooperate if opponent cooperated in the previous round, defect otherwise". This simple rule encourages reciprocity and punishes defection without being overly vindictive.

2. Handle Edge Cases:
   - First Round (t=1): Cooperate (C). It's important to start with cooperation to show goodwill and set a positive tone.
   - Last Round (t=r): If the current round is the last round, TfTA adopts a forgiving approach and cooperates regardless of the opponent's previous action. This can lead to a final act of cooperation that may encourage cooperation in future games.
   - Breaking Trust: If the opponent defected during the last round, TfTA will also defect in the current round as a punishment for breaking trust. Afterward, it returns to its cooperative approach.

3. Be Collective:
   - TfTA aligns with the collective mindset by promoting cooperation and reciprocity. By adhering to the simple rule of "cooperate if opponent cooperated in the previous round", TfTA aims to create a stable, trust-based environment that benefits all players over time.

Pseudocode:

```python
def tit_for_tat_adaptive(t, r, n, m, k):
    if t == 1:
        action = "C"  # Cooperate in the first round
    elif t < r:
        if previous_round_action != "D":  # If opponent cooperated, cooperate; otherwise defect
            action = "C"
        else:
            action = "D"
    else:  # Last round
        action = "C"  # Cooperate as a final act of cooperation

    if t == r or previous_round_action == "D":
        last_round_action = action
    elif last_round_action == "D":
        last_round_action = action
    else:
        last_round_action = previous_round_action  # Maintain the state of last round's action

    previous_round_action = action  # Update the state for the next round

    return action
```
'''

description_COLLECTIVE_482 = '''
 Strategy Name: Tit-for-Tat Adaptive (TfTA) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
- In the first round, players adopt a neutral approach by randomly choosing between cooperation and defection (50% probability). This helps to avoid being exploited by other strategies that might take advantage of initial cooperators.
  ```python
  if round == 1:
    action = random.choice(['C', 'D'])
  else:
      # Adaptive behavior based on opponent's recent actions (last n rounds)
      cooperation_count = count_cooperators(last_n_rounds)

      if cooperation_count >= m:
          action = 'C'  # Cooperate when majority of opponents cooperated
      elif cooperation_count == m - 1:
          action = 'C' if TfTA_index in last_cooperators else 'D'  # Conditional cooperation, mimic opponent's previous action
      elif cooperation_count < m - 1:
          action = 'D'  # Defect when majority of opponents defected
  ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
- In the last round, players always cooperate to maximize their payoff given the game will end soon:
  ```python
  if round == r:
    action = 'C'
  else:
    # Regular decision rule as defined above
  ```

3. Be collective - Clearly align with the collective mindset
- The strategy is designed to promote cooperation, but it does not rely on any specific coordination mechanisms or shared norms among opponents. Instead, it adapts its behavior based on the majority of opponents' actions in the previous rounds. This approach encourages a cooperative environment when most players are acting collectively while still being robust against defection.
'''

description_COLLECTIVE_483 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - In the first round (t=1), player i cooperates (C). This initiates cooperation and shows a peaceful intent towards other players.
   - From the second round (t>1) until the last round, player i's decision to cooperate or defect is based on its own past actions and the number of cooperators in the previous round:
     - If player i has been cooperating in the last r-1 rounds and at least m players cooperated in the previous round (t-1), then player i continues cooperating.
     - If player i defected in the last r-1 rounds or fewer than m players cooperated in the previous round (t-1), then player i defects to punish those who did not cooperate and encourage them to change their strategy.
     - If the number of cooperators in the current round is less than m, but player i has been cooperating and at least one more player starts cooperating, then player i continues cooperating. This rule encourages conditional defection from others to join the cooperation group.

2. Handling Edge Cases:
   - Last Round (t=r): player i behaves based on its past r actions and the number of cooperators in the previous round (t-1). If player i has been cooperating and at least m players cooperated in the previous round, then it continues cooperating even though there are no more rounds to follow.
   - First Round (t=1): player i initiates cooperation as mentioned earlier.

3. Being Collective:
   - TFT-AC is designed to promote collective mindset by encouraging mutual cooperation through reciprocity, conditional defection, and punishment for non-cooperative behaviour. It assumes that players are rational and will adapt their strategies over time in response to the actions of others.
   - The strategy follows a "trust but verify" approach, where it initially cooperates and then adjusts its behavior based on the responses from other players. This promotes cooperation while maintaining robustness against various opponent behaviors.

Pseudocode:
```
def tft_ac(t, history, m, k):
  if t == 1: # First round, cooperate to initiate cooperation
    action = "C"
  else: # Adaptive cooperation based on past actions and number of cooperators in previous round
    last_round = len(history) - 1
    last_t = history[last_round]
    if last_t == "C": # If last action was cooperating, and at least m players cooperated last round
      if count_cooperators(last_round, m) >= m:
        action = "C"
      else: # If at least one more player starts cooperating
        if count_cooperators(t-1, m) < m and count_cooperators(history[t-2], m) + 1 >= m:
          action = "C"
    else: # If last action was defecting or not enough players cooperated last round, defect to punish non-cooperation
      action = "D"

  return action
```
In the above pseudocode, `count_cooperators(round, m)` counts the number of cooperators in a given round compared to the minimum threshold (m).
'''

description_COLLECTIVE_484 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
In each round t, player i will cooperate (C) if and only if the number of cooperators in the previous round t-1 exceeds or equals the minimum cooperation threshold m. If not, the player will defect (D). This rule ensures that the strategy is responsive to past collective behavior while maintaining simplicity and robustness.

Pseudocode:
```
function TfTA(t, n, m):
    if t == 1:
        return C  # First round cooperation as a gesture of goodwill
    cooperators_previous = countCooperators(t-1)
    if cooperators_previous >= m:
        return C  # Cooperate if the previous round had enough cooperators
    else:
        return D  # Defect if the previous round fell short of cooperation threshold
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
To handle the first round, players will cooperate as a goodwill gesture to encourage others to cooperate in the future. In the last round or when r < t, the player will follow the general decision rule based on the most recent available data.

Pseudocode:
```
function TfTA(t, n, m):
    if t == 1:
        return C  # First round cooperation as a goodwill gesture
    if r < t or t > r:
        previous_round = getLastKRoundData(t-r)  # Get data from the most recent available rounds
        cooperators_previous = countCooperators(previous_round)
        if cooperators_previous >= m:
            return C  # Cooperate based on the last available data
        else:
            return D  # Defect based on the last available data
    else:
        return TfTA(t, n, m)  # Standard decision rule applies for non-edge cases
```

3. Be collective - Clearly align with the collective mindset
The Tit-for-Tat-Adaptive strategy is designed to promote cooperation by adhering to the collective behavior exhibited in the previous round. By cooperating when others do, it encourages a more harmonious and collaborative environment among players.

The adaptiveness of TfTA allows it to accommodate various opponent behaviors while still being responsive to shifts in group dynamics over time.
'''

description_COLLECTIVE_485 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfT-A)

1. Decision Rules:
   - In the first round, cooperate (C). This is a peaceful gesture to foster initial cooperation and goodwill.
   - For subsequent rounds, if the number of cooperators in the previous round is greater than or equal to m, cooperate (C).
   - If fewer than m players cooperated in the previous round, defect (D) in this round. This is a retaliation for non-cooperation in the previous round, but also signals a willingness to cooperate again if others do so as well.
   - If an opponent switches from defecting to cooperating after being punished, cooperate (C) in response to show forgiveness and encouragement for future cooperation.

2. Handle Edge Cases:
   - In the last round, if the minimum number of cooperators has been reached in the previous rounds, cooperate (C). This allows the community project to be completed even in the final round.
   - If there is a tie with exactly m players cooperating, all strategies that cooperated will receive reward k > 1, while those who defected will get only 1. The TfT-A strategy will follow the majority decision in these cases.

3. Be Collective:
   - By following the TfT-A strategy, each player demonstrates a commitment to collective success by contributing to the community project when others do so as well.
   - The strategy also rewards cooperation by offering a higher payoff (1 + k) when the minimum number of cooperators is reached, and punishes defection by decreasing the payoff from 1 to 1 - c_i in the case of non-cooperation. This encourages other players to follow the same strategy or similar cooperative behavior.
  
Pseudocode:
```
def tit_for_tat_adaptive(round, previous_round_cooperators, m, k):
  if round == 1:
    return "C" # Cooperate in the first round

  cooperators = sum(previous_round_cooperators)
  if cooperators >= m:
    return "C" # Cooperate when the minimum number of players cooperated in the previous round
  else:
    return "D" # Defect when fewer than m players cooperated in the previous round

def play_game(n, r, m, k):
  strategies = [tit_for_tat_adaptive for i in range(n)]
  payoffs = [0 for i in range(n)]
  rounds = range(1, r + 1)

  for round in rounds:
    cooperators = sum([strategies[i](round, payoffs[j] for j in range(n)) for i in range(n)])
    if cooperators >= m:
      reward = 1 + k
    else:
      reward = 1

    for i in range(n):
      payoffs[i] += reward - strategies[i](round, payoffs, m, k)

  return payoffs
```
'''

description_COLLECTIVE_486 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfTA)

1. Decision Rules:
   - Initially Cooperate (C) in the first round to demonstrate goodwill and encourage reciprocity.
   - In subsequent rounds, cooperate if the majority of players cooperated in the previous round. If not, defect (D). This rule aims to align with other cooperators while also punishing defectors.
   - If a player switches from cooperation to defection, wait for t iterations before returning to cooperating (where t is a pre-defined number). This helps prevent unnecessary retaliation and allows for potential re-entry into the cooperative cycle.

2. Edge Cases:
   - In the last round, always cooperate as there are no subsequent rounds to consider payback.
   - In the first round after a long series of defections (more than t iterations), start by cooperating to encourage others to reconsider their strategies and potentially return to cooperation.
   - If a majority of players switch from cooperation to defection, adjust the threshold for cooperation (t) to allow for more patience in waiting for reciprocation.

3. Collective Mindset:
   - TfTA fosters a collective mindset by promoting mutual cooperation and punishing defections. It aims to encourage a cycle of cooperation that benefits all players over time, assuming others follow similar strategies.
   - By being adaptive and robust to opponent behaviors, the strategy maintains its effectiveness against various strategies in repeated interactions.
'''

description_COLLECTIVE_487 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Decision Rules - TfTA cooperates in the first round and then mimics the behavior of the most frequent cooperator among opponents in the previous r-2 rounds. If multiple players tie for the most frequent cooperator, TfTA chooses to cooperate. In case of a tie between a cooperator and a defector, it prefers cooperation.

   Pseudocode:
   ```
   function TfTA(opponents_history):
       if round < 2 then
           return Cooperate()
       end if

       most_cooperators = find_most_common_cooperators(opponents_history)
       if len(most_cooperators) > 1 then
           return most_cooperators[0] if most_cooperators[0].cooperation_count > most_cooperators[1].cooperation_count
           return Cooperate()
       end if

       return opponents_history[r-2][most_cooperators[0]]
   ```

2. Handle Edge Cases - TfTA starts cooperating in the first round, and in the last round it cooperates when it would have gained more by doing so (taking into account the reward factor k). If the reward is high enough to make defecting unprofitable even in the last round, TfTA will defect.

   Pseudocode:
   ```
   function Cooperate_if_profitable(own_payoff):
       return own_payoff > 1 if k >= r else Cooperate()
   ```

3. Be Collective - TfTA is collectively minded, as it encourages cooperation when the majority of opponents have cooperated in the past. It also responds to defection by defecting itself, but will revert to cooperation once the opponent changes behavior.

This strategy has proven successful in several repeated games due to its simplicity and adaptability, allowing it to align well with collective mindsets while being robust against a wide range of opponent behaviors.
'''

description_COLLECTIVE_488 = '''
 Strategy Name: Tit-for-Tat with Adaptive Threshold (TFTA)

1. Specify decision rules:
   - Initially cooperate (C) in the first round to show goodwill. Subsequent actions are determined by the number of cooperators in the previous round.
   - If m or more players cooperated in the previous round, also cooperate (C). This rewards cooperative behavior and encourages continued cooperation.
   - If fewer than m players cooperated in the previous round, defect (D) to punish non-cooperative behavior and discourage future defection.
   - Adaptive Threshold: If a player has consistently defected for a certain number of rounds (let's call it 'punishment_threshold'), consider them uncooperative and always defect against them, even if the majority cooperates. Similarly, if a player has consistently cooperated for a certain number of rounds ('reward_threshold'), they are considered trustworthy, and cooperation is continued regardless of the actions of other players.

2. Handle edge cases:
   - In the first round, cooperate (C).
   - In the last round, use the same decision rules as in any other round to make the best of the remaining opportunities for reward or punishment.

3. Be collective:
   - TFTA is inherently aligned with the collective mindset by promoting cooperation when the majority cooperates and punishing defection when the majority defects.
   - The adaptive threshold ensures that the strategy remains flexible and responsive to changing player behaviors over time, encouraging a more cooperative environment.
'''

description_COLLECTIVE_489 = '''
 Strategy Name: Tit-for-Tat (TFt) Adaptive Cooperation Strategy

1. Specify decision rules:
   - In every round t, start by cooperating (C), unless it's the first round or the game is ending. This sets a cooperative baseline.
   - If the majority of players in the previous round (t-1) also cooperated, maintain cooperation (C).
   - If fewer than m players cooperated in the previous round (t-1), defect (D) to avoid being exploited by non-cooperators.

Pseudocode:
```
function TFtStrategy(n, m, r, k):
  round = 0
  history = []

  while round < r:
    if round == 0 or round == r-1:
      action = D
    else:
      numCooperators = countCooperatorsInHistory(history)
      if numCooperators >= m:
        action = C
      else:
        action = D
    history.append(action)
    round += 1
```

2. Handle edge cases:
   - In the first round (round == 0), defect because there is no previous information about other players' behavior.
   - In the last round (round == r-1), cooperate or defect depending on whether the majority of players have been cooperating in the game up to this point.

3. Be collective:
   - Aligns with a collective mindset by starting cooperatively and adapting cooperation based on the actions of other players in the previous rounds.
   - Maintains long-term cooperation when playing against other cooperative players, but also punishes non-cooperators to avoid being taken advantage of.

This strategy is adaptive and robust as it follows a simple yet effective tit-for-tat approach that can be applied in various situations while maintaining collective interests. The strategy does not require any specific coordination mechanisms or reliance on others sharing norms, making it suitable for competition against other AI systems in the tournament.
'''

description_COLLECTIVE_490 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules:
   - Start with cooperation (C) in the first round to signal trust and initiate cooperative behavior.
   - In subsequent rounds, cooperate if a majority of players cooperated in the previous round. If not, defect (D). This is based on the assumption that cooperating with cooperators is beneficial while defeating defectors may lead them to reconsider their actions.
   - If the number of cooperators in the previous round equals the minimum cooperation threshold m, continue cooperating even if the current round is the last one (rather than switching to defection). This ensures that the collective mindset is maintained for potential future interactions.

Pseudocode:
```python
def atft(round, history):
  if round == 1:
    return 'C'  # Cooperate in the first round

  cooperators = sum(history[-r:])
  if cooperators >= m and (round != r):
    return 'C'  # Continue cooperating if a majority cooperated in the last r rounds
  elif cooperators < m and (round != r):
    return 'D'  # Defect if less than a majority cooperated in the last r rounds
  else:
    return 'C'  # Cooperate even in the last round if the minimum cooperation threshold was met in the previous round
```

2. Handle edge cases:
   - In the first round, ATFT cooperates to initiate a cooperative cycle.
   - If there is only one round (r=1), ATFT will defect because it cannot rely on future interactions to enforce cooperation.
   - As r increases, ATFT takes into account the history of previous rounds to make decisions.

3. Be collective:
   - By cooperating when a majority of players also cooperate, ATFT maintains a collective mindset that encourages long-term cooperation and mutual benefits.
   - The strategy is adaptive as it adjusts its behavior based on the collective actions of other players, fostering a sense of unity in pursuit of common goals.
'''

description_COLLECTIVE_491 = '''
 Strategy Name: Tit-for-Tat with Cooperative Adjustment (TFT-CA)

1. Decision Rules:
   - In the first round, cooperate to initiate cooperation and signal a peaceful intent (C).
   - For subsequent rounds, observe the actions of the other players in the previous round. If most players cooperated (more than (n - floor((n-m)/2))) in the previous round, cooperate (C). Otherwise, defect (D) to punish non-cooperators and encourage them to change their strategy.
   - Adjust cooperation level: If more than m players have been consistently cooperative over a defined number of past rounds (let's say 'history_length'), increase the threshold for cooperation (m+1). Conversely, if less than m players have been consistently cooperative, decrease the threshold (m-1).
   - Ensure that the adjusted threshold remains within the valid range (1 < m < n).

2. Handling Edge Cases:
   - In the last round, cooperate to maximize the payoff regardless of other players' actions (C).
   - If in any round the number of players is less than n or the number of rounds is less than r, adjust the strategy accordingly while ensuring that it still satisfies the game parameters.

3. Collective Mindset:
   - The TFT-CA strategy aims to build and maintain a cooperative environment among players. It starts by initiating cooperation, punishes defectors, rewards cooperators, and gradually evolves its cooperation threshold based on the collective behavior of other players. This adaptability allows it to respond effectively to various opponent behaviors while fostering cooperation in the long run.
   - By adjusting the cooperation threshold, TFT-CA strategy promotes a stable equilibrium where all players cooperate for most of the rounds, leading to higher average payoffs for everyone involved compared to non-cooperative strategies.
'''

description_COLLECTIVE_492 = '''
 Strategy Name: Tit-for-Tat with Risk Aversion (TfT-RA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to show goodwill and establish trust. This is important in building a relationship with other players. (C in Round 1)
   - For subsequent rounds, analyze the previous actions of all players using the Tit-for-Tat principle: If the majority of players cooperated in the previous round, cooperate in the current round to maintain cooperation and encourage others who also cooperated previously. If the majority defected, defect as well to punish those who broke trust and potentially deter them from doing so again in the future. (C if m or more players cooperated in the previous round, D otherwise)
   - Additionally, incorporate risk aversion by always considering the reward of risk averted (k). If the majority of players have been cooperating consistently over several rounds and the probability of success (m players cooperating) increases significantly, defect to secure the greater reward. (D if m or more players have been consistently cooperating for a certain number of consecutive rounds and the expected reward from continuing cooperation becomes greater than the potential reward of risk aversion)

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as mentioned earlier (C in Round 1)
   - In the last round, cooperate if the majority have been cooperating consistently (C if m or more players have cooperated for a certain number of consecutive rounds before the last one)
   - If there is no majority or the game has not reached a stable cooperation phase, use the decision rules mentioned under "Specify decision rules" to decide on actions

3. Be collective - Clearly align with the collective mindset
   - Prioritize the well-being of the group by considering the collective success (m players cooperating) and the reward for risk aversion (k)
   - Maintain cooperation when possible, but be prepared to punish defectors and protect the group's interests when necessary
'''

description_COLLECTIVE_493 = '''
 Strategy Name: Tit-for-Tat with Adaptive Threshold (TFTA)

1. Decision Rules:
   - Start by cooperating in the first round (C_i = 1). This is a friendly gesture to encourage cooperation from other players.
   - In subsequent rounds, follow the actions of the majority of players from the previous round. If more than (m-1) players cooperated, also cooperate (C_i = 1). If less than (m-1) players cooperated, defect (C_i = 0).
   - To be adaptive and robust, implement a learning mechanism that adjusts the minimum threshold of cooperation required to continue cooperating. This can be achieved by incrementally increasing the threshold if cooperation is met in previous rounds, and decrementing it when cooperation fails. The adjustment can be based on a moving average of past successes or failures in cooperation.
   - In case the threshold reaches 1 (meaning that only one player needs to cooperate for you to cooperate), consider implementing a minor modification: if no other players have cooperated for a certain number of rounds, defect as well to avoid a possible freerider situation.

2. Handling Edge Cases:
   - In the last round, always cooperate (C_i = 1) since there are no further interactions with other players.
   - In the first round, cooperate regardless of the number of players who choose to cooperate or defect (C_i = 1).

3. Being Collective:
   - The TFTA strategy aims to foster a collective mindset by punishing defection when most others are cooperating and rewarding cooperation when most others are also cooperating.
   - By adjusting the minimum threshold for cooperation based on historical data, the strategy is able to adapt to different group sizes and opponent behaviors without relying on explicit coordination mechanisms or shared norms.
'''

description_COLLECTIVE_494 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Decision Rules:
   - Initiate cooperation: Start by cooperating in the first round to promote trust and cooperation among players. This sets a cooperative tone for the game.
   - Respond tit-for-tat: If a player cooperates, return the favor; if a player defects, defect next turn to demonstrate disapproval of their actions. After that, revert to cooperating to give opportunities for reconciliation.
   - Escalate cooperation when necessary: In the event of repeated defections, gradually increase cooperation by adding an additional round of cooperation after every consecutive defeat (i.e., Cooperate-Defect-Cooperate-Cooperate-Cooperate...). This sends a stronger message while still leaving room for reconciliation if opponents switch to cooperation.
   - Deescalate cooperation when cooperators exceed the minimum threshold: If more players than the minimum cooperative threshold (m) defect, revert to defection to ensure survival in unfavorable conditions.

2. Handle edge cases:
   - First round: Cooperate (C).
   - Last round: Analyze current cooperative state and history of play. If a majority of players have consistently cooperated, maintain cooperation; if not, defect to maximize individual payoff in the final round.
   - Transition points: When switching from defection to cooperation or escalating cooperation, introduce a delay (e.g., wait for 3 consecutive cooperative actions before responding with cooperation). This helps reduce the risk of exploitation by opponents who may take advantage of sudden changes in strategy.

3. Be collective:
   - Prioritize group success over individual gain whenever possible by promoting and rewarding cooperation, as the long-term benefits of a successful community project outweigh short-term gains from individual defection.
   - Maintain flexibility to adapt to various opponent behaviors while encouraging cooperative actions to foster a collective mindset among players.

Pseudocode:
```python
def ATFT(n, m, k, r, c_history):
  cooperation = True  # Initialize by cooperating
  defected_players = set()  # Keep track of defectors
  round = 1  # Start from the first round

  while round <= r:
    if round == 1:  # First round, always cooperate
      c_action = "C"
    else:
      if cooperation and len(defected_players) < (n - m):  # If majority cooperates, continue cooperating
        c_action = "C"
      elif not cooperation and len(defected_players) >= (n - m):  # If majority defects, defect to survive
        cooperation = False
        c_action = "D"
      else:  # Otherwise, respond tit-for-tat or escalate/deescalate cooperation as necessary
        if round % 3 == 0:  # Every third round, consider changing strategy
          if cooperation:  # If currently cooperating and majority defected, defect to survive
            cooperation = False
            c_action = "D"
            defected_players.add(round)
          else:  # If currently defecting, consider escalating cooperation if there have been consecutive defections
            if round - defected_players[-1] >= 3:  # Wait for 3 consecutive cooperative actions before responding with cooperation
              c_action = "C"
    perform_action(c_action)  # Perform the chosen action
    update_defected_players(round, c_history)  # Update the set of defectors based on the current round and history
    round += 1
```
'''

description_COLLECTIVE_495 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFT-A) for Collective Risk Dilemma

1. Decision Rules:
   - In the initial round (t=1), cooperate (C). This gesture is intended to build trust and establish a cooperative relationship with other players.
   - For subsequent rounds (t > 1):
     - If an opponent cooperated in the previous round, reciprocate cooperation (C). Maintaining cooperation encourages long-term collaboration and rewards both parties with higher payoffs.
     - If an opponent defected in the previous round, also defect (D) to punish the opponent for the uncooperative behavior. The punishment aims to discourage repeated defection and promote cooperation.
   - An important aspect of TFT-A is its simplicity and adaptability: it only uses two states – cooperate or defect – which makes it easy for opponents to understand and respond, fostering an environment conducive to cooperation.

2. Handling Edge Cases:
   - In the last round (t=r), since there are no future interactions, defect (D) because the potential reward of a single cooperation no longer outweighs the risk of being taken advantage of by opponents who may defect in the final round.
   - If in any round, less than m players cooperate, TFT-A will continue with the same strategy (either cooperation or defection), as the current strategy already accounts for suboptimal cooperation from other players.

3. Collective Mindset:
   - TFT-A maintains a collective mindset by promoting long-term cooperation with other players, hoping to create a self-sustaining cycle of mutual benefits and trust.
   - The simplicity of the strategy makes it easier for opponents to understand and respond, which may encourage more cooperative behavior among them as well.
'''

description_COLLECTIVE_496 = '''
 Strategy Name: Tit-for-Tat with Adaptive Risk Aversion (TFT-ARA)

1. Decision Rules:
   - Initiate cooperation by cooperating in the first round (C1). This sets a cooperative tone and gives opponents the opportunity to cooperate back.
   - In subsequent rounds, observe the number of cooperators (m_t) in the previous round. If m_t >= m, the threshold for collective success, continue cooperation (C_t+1). However, if m_t < m, defect (D_t+1). This punishes non-cooperative behavior and encourages opponents to cooperate in future rounds.
   - To incorporate risk aversion, adaptively increase the number of cooperators needed for collective success over time when cooperation is failing (m_t < m). Let the adaptation factor be α (0 < α < 1), and calculate the new minimum cooperators needed as follows: m_t+1 = min(m_t + α * (m - m_t), n)
   - In cases where all opponents are consistently defecting (m_t = 0 for multiple consecutive rounds), gradually decrease the risk aversion factor to stimulate cooperation by setting α_t+1 = max(α_t - δ, β), where δ and β are small positive constants.

2. Edge Cases:
   - In the last round (r < t ≤ r+1), since the game is ending soon, cooperate regardless of previous cooperation levels to maximize potential payoff (C_t).
   - In the first round (t = 1), cooperate as per the initial decision rule (C1).

3. Collective Mindset:
   - The TFT-ARA strategy promotes a collective mindset by punishing defection and rewarding cooperation, encouraging opponents to collaborate in future rounds. It adapts its collective success threshold based on the game's history to handle varying levels of cooperation among players.

Pseudocode:

```python
def TFT_ARA(n, m, k, r, α=0.1, β=0.05, δ=0.01):
    players = list(range(1, n+1))
    rounds = set(range(1, r+1))
    last_cooperators = {t: m for t in rounds} # initialize with the initial threshold
    current_round = 1

    while True:
        if current_round == 1: # first round cooperation
            cooperate()
            last_cooperators[current_round] = count_cooperators()
        elif current_round in rounds: # standard decision rule
            cooperators = count_cooperators()
            if cooperators >= last_cooperators[current_round-1]:
                cooperate()
            else:
                defect()
                update_threshold(cooperators, last_cooperators)
        elif current_round < r+1: # decreasing risk aversion factor
            update_threshold(cooperators, last_cooperators)
            if count_cooperators() == 0:
                adjust_risk_aversion(α, δ)
        else: # last round cooperation
            cooperate()

        current_round += 1
```

This pseudocode outlines the TFT-ARA strategy. The functions `cooperate`, `defect`, `count_cooperators`, and `update_threshold` must be defined according to the game rules, while `adjust_risk_aversion` adjusts the risk aversion factor as described in the decision rules section.
'''

description_COLLECTIVE_497 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TTAT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially cooperate in the first round (C_i = 1 for t=1). This sets a positive tone and demonstrates willingness to cooperate.
   - In subsequent rounds, observe the number of cooperators in the previous round (m_t-1). If m_t-1 < m, defect in the current round (C_i = 0 for t > 1 and m_t-1 < m). This punishes non-cooperative behavior.
   - If m_t-1 ≥ m, cooperate in the current round (C_i = 1 for t > 1 and m_t-1 ≥ m). This rewards cooperative behavior and maintains mutual cooperation.
   - In case of repeated defection by others, gradually reduce the cooperation threshold: if m_t-n < m, set the cooperation threshold to m_t-n (for some n > 1, e.g., n=3). This makes the strategy more adaptive and less vulnerable to long periods of defection.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as mentioned above (C_i = 1 for t=1).
   - In the last round, behave based on the observed cooperation of the previous round: if m_t-1 < m, defect (C_i = 0 for t = r); otherwise, cooperate (C_i = 1 for t = r). This ensures that the strategy maintains its adaptability even in the final rounds.

3. Be collective - Clearly align with the collective mindset
   - The TTAT-ACT strategy is designed to encourage cooperation by rewarding mutual cooperation and punishing defection. However, it also takes into account the need for robustness against various opponent behaviors, making it collectively adaptive and flexible in different scenarios.

Pseudocode:

```
function TTAT_ACT(n, r, m, k) {
    cooperationThreshold = m;
    for round in range 1 to r:
        if round == 1:
            cooperate = True; // cooperate initially
        else:
            observedCooperators = count Cooperators in previous round;
            if observedCooperators < cooperationThreshold:
                cooperate = False; // defect if fewer than the threshold have cooperated
            else:
                cooperate = True; // cooperate if the threshold or more have cooperated
                if (round == r) and (observedCooperators < m):
                    cooperate = False; // defect in the last round if cooperation threshold not met
        payoff = calculatePayoff(cooperate, observedCooperators);
        updateCooperationThreshold(n, cooperationThreshold, observedCooperators);
        return payoff;
}
```
'''

description_COLLECTIVE_498 = '''
 Strategy Name: Tit-for-Tat (with modifications for Collective Risk Dilemma)

1. Decision Rules:
   - Initially Cooperate (C) in the first round to demonstrate goodwill and foster cooperation.
   - For subsequent rounds, follow the actions of the majority of players from the previous round. If more than (m-1) players cooperated, also cooperate. Otherwise, defect.
   - In case of a tie, follow the most recent majority action.

2. Handling Edge Cases:
   - For the first round, always Cooperate (C).
   - In the last round, evaluate the payoff based on the current situation and the history of cooperation. If cooperating with the majority would lead to a higher total payoff over the game, then still cooperate; otherwise defect.

3. Being Collective:
   - The strategy is designed to promote cooperation and reciprocity while being adaptable to different opponent behaviors. It encourages players to follow a cooperative stance unless it becomes consistently disadvantageous.

Pseudocode:

```python
def play(n, m, k, r, history):
    players_cooperated = count_cooperators(history)
    if round == 1:
        action = 'C'  # Cooperate initially
    elif players_cooperated >= (m-1):
        action = 'C'  # Cooperate if majority cooperated last round
    else:
        action = 'D'  # Defect if majority did not cooperate last round

    # In the last round, evaluate the payoff based on history and current situation
    if round == r and is_cooperating_advantageous(history):
        action = 'C'  # Cooperate in the last round if it leads to higher payoff

    return action
```

This strategy aims at fostering a cooperative environment while being flexible enough to adapt to various opponent behaviors. The use of history and majority voting helps make it robust against different strategies, without relying on any specific coordination mechanisms or shared norms.
'''

description_COLLECTIVE_499 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?

Initially, players follow the Tit-for-Tat strategy, where they cooperate in the first round and then copy the previous action of their opponents for the rest of the game. However, to handle a wide range of opponent behaviors, TFT-ACT introduces an adaptive cooperation threshold (m').

In each round t, if the number of cooperators among the n players exceeds m', the player will cooperate. Otherwise, they will defect. The adaptation of the cooperation threshold (m') is determined by the average number of cooperators throughout the game.

Pseudocode:
```
function TFT-ACT(t)
  if t = 1 then
    cooperate = true
  else
    cooperate = previous_action_of_opponents[t-1]
    m' = calculateAdaptiveThreshold(average_cooperators)
    if number_of_cooperators[t] > m' then
      cooperate = true
    end if
  end if
end function
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

For the first round, the player cooperates as per the Tit-for-Tat strategy. In the last round, TFT-ACT still adheres to its adaptive cooperation threshold (m'), but it takes into account that there will be no subsequent rounds for payback or retaliation. Hence, if the number of cooperators exceeds m' in the final round, the player also cooperates.

Pseudocode:
```
function calculateAdaptiveThreshold(average_cooperators)
  return (1 + average_cooperators)/2
end function
```

3. Be collective - Clearly align with the collective mindset

By following an adaptive cooperation threshold, TFT-ACT promotes a collective mindset as it seeks to maximize the overall cooperative behavior in the group. The strategy encourages players to cooperate when they observe a strong collective will, while defecting only if there's a clear lack of cooperation from others. This approach aligns with the collective interest by creating an environment that rewards mutual cooperation and punishes defection when it undermines the collective welfare.
'''

description_COLLECTIVE_500 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, the TFTAC strategy will initially cooperate (C), then decide whether to continue cooperating based on the opponent's previous action in the last round. If the opponent cooperated in the previous round, the TFTAC strategy will also cooperate; if not, it will defect.

   Pseudocode:
   ```
   function TFTAC(round, history):
       if round == 1:
           return 'C' (Cooperate)
       else:
           last_opponent_action = history[round-1]
           if last_opponent_action == 'C':
               return 'C' (Cooperate)
           else:
               return 'D' (Defect)
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, TFTAC will cooperate to demonstrate good faith. In the last round, it will follow its decision rule based on the opponent's last action. If there are penultimate rounds (r > 2), TFTAC will continue playing according to its decision rules until the end of the game.

3. Be collective - Clearly align with the collective mindset
   By initially cooperating and subsequently imitating the opponent's behavior, TFTAC encourages mutual cooperation when other players also adopt this strategy or similar reciprocal strategies. It prioritizes long-term rewards from collective success (high k) over short-term gains through defection.

   The TFTAC strategy aims to establish a stable cooperative relationship with other like-minded opponents while being cautious and responsive to those who may defect. This balance should enable it to perform well in various tournament scenarios against a range of opponent strategies.
'''

description_COLLECTIVE_501 = '''
 Strategy Name: Tit-for-Tat with Adaptive Threshold (TFTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to show good faith and establish a cooperative foundation. This initial cooperation can foster mutual trust among players.
     Pseudocode: `if round == 1 then cooperate`

   - For subsequent rounds, analyze the number of cooperators in the previous round. If the number is greater than or equal to the minimum threshold (m), cooperate to maintain a stable cooperative relationship and reap potential rewards. If the number is less than the threshold, defect to retaliate against non-cooperators.
     Pseudocode: `if number_of_cooperators_in_previous_round >= m then cooperate else defect`

   - To adapt to opponent behaviors, implement a forgiveness mechanism that allows for defections in the past to be forgotten over time. After a predefined number of consecutive cooperative actions by an opponent (forgiveness window), forgive them and revert back to initial cooperation strategy.
     Pseudocode: `if opponent_consecutive_cooperative_actions >= forgiveness_window then forgive`

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, cooperate if the number of cooperators in the previous round is greater than or equal to the minimum threshold (m), as this may encourage others to cooperate as well and maximize overall payoff.
     Pseudocode: `if number_of_cooperators_in_previous_round >= m then cooperate`
   - In any other edge case, follow the standard decision rules specified above.

3. Be collective - Clearly align with the collective mindset
   - The TFTA strategy focuses on maintaining long-term relationships with others and promoting a stable cooperative environment. By adapting to opponent behaviors while also considering past interactions, this strategy aims to encourage collective cooperation and achieve mutual benefits.

In summary, the TFTA strategy starts by cooperating in the first round, then bases its actions on the number of cooperators from the previous round. A forgiveness mechanism allows for adaptation to opponent behavior over time, while also promoting long-term relationships and a collective mindset. The strategy is designed to be robust against a wide range of opponent behaviors and can be implemented as an adaptive algorithm for the Collective Risk Dilemma game.
'''

description_COLLECTIVE_502 = '''
 Strategy Name: Adaptive Tit-for-Tat with Gradient Descent (ATfT-GD)

1. Specify decision rules:
   - Initial Cooperation (I-Coop): In the first round, cooperate to initiate a potential cooperative relationship.
   - Reciprocity: If a player has cooperated in the previous round, cooperate in the current round.
   - Punishment: If a player has defected in the previous round, defect in the current round (punish).
   - Forgiveness: After a defection, forgiveness occurs if the offender cooperates in the subsequent round.
   - Tit-for-Tat with Gradient Descent (TfT-GD): If the partner has had a mix of cooperation and defections, use gradient descent to adjust the strategy's responsiveness to defections. This adjustment occurs after each defection and is based on the number of previous defections by the partner.

2. Handle edge cases:
   - Last Round: In the last round, always cooperate regardless of the opponent's past behavior as there are no subsequent rounds for punishment or forgiveness.
   - No Past Interaction: If there is no history of interaction with the opponent, initiate cooperation (I-Coop).

3. Be collective:
   - Aligning with the Collective Mindset: The strategy aims to maximize the group's overall benefit by promoting cooperative behavior whenever possible and minimizing defection when necessary. However, it does not rely on coordination mechanisms or shared norms since it was designed to function independently of other strategies.

Pseudocode for ATfT-GD:

```python
def adaptive_tit_for_tat_with_gradient_descent(history):
    cooperation_threshold = m
    learning_rate = 0.1
    defections_count = 0

    if not history:
        return 'C'  # Initial Cooperation (I-Coop)

    partner_cooperated_last_round = 'C' in history[-1]

    if partner_cooperated_last_round:
        return 'C'  # Reciprocity
    else:
        defections_count += 1
        responsiveness = (defections_count / len(history)) * learning_rate + 1
        if responsiveness > cooperation_threshold:
            return 'D'  # Punishment
        else:
            return 'C'  # Forgiveness

    # Last Round
    return 'C'
```
'''

description_COLLECTIVE_503 = '''
 Strategy Name: Adaptive Cooperative Tit-for-Tat (ACTFT)

1. Decision Rules:
   - In each round, ACTFT decides whether to cooperate or defect based on the historical cooperation rate of the other players (average number of cooperators in the previous 'h' rounds).
   - If the cooperation rate is greater than or equal to the minimum required cooperators (m), ACTFT cooperates. Otherwise, it defects.
   - ACTFT is forgiving and tends towards cooperation in the early stages of the game (first few rounds) by setting a lower threshold for cooperation (let's call it m_initial). As the game progresses, the threshold increases gradually to match the eventual m.
   - To ensure robustness against various opponent behaviors, ACTFT includes a tolerance factor (t) that allows for some deviations from the average cooperation rate without changing its own strategy. If the actual cooperation rate is within [(m_initial - t), (m + t)] range, ACTFT maintains its previous action.
   - To prevent exploitation by opponents who may consistently cooperate only to gain a high reward and then defect, ACTFT implements a punishment mechanism: if an opponent repeatedly cooperates but fails to reach the cooperation threshold, ACTFT starts defecting against them until the opponent's behavior improves.

2. Handling Edge Cases:
   - In the first round (when there is no history), ACTFT follows a mixed strategy, with a higher probability of cooperating since it tends towards cooperation in the early stages.
   - In the last round, if reaching the minimum required cooperators (m) is still possible, ACTFT cooperates to maximize its payoff for that round. If not, ACTFT defects to secure some reward instead of nothing.
   - When faced with a new opponent or a significant change in the opponents' behavior, ACTFT adapts its tolerance factor (t) and forgiveness period (number of rounds before raising the cooperation threshold from m_initial to m) based on the observed behavior of the opponent.

3. Being Collective:
   - ACTFT is designed with a collective mindset in that it aims to contribute to the community project when possible and punishes those who repeatedly defect, thereby encouraging cooperation among players over time.

Pseudocode:

```
def ACTFT(h, m_initial, t, forgiveness_period):
  history = []  # store the last 'h' rounds of cooperation rates
  cooperation_threshold = m_initial
  tolerance = t
  forgiveness_count = 0

  function calculateCooperationRate():
    return sum(cooperators in history) / len(history)

  function updateHistory():
    history.append(calculateCooperationRate())
    if len(history) > h:
      history.pop(0)

  for round in range(r):
    cooperation_rate = calculateCooperationRate()

    # Maintain previous action when cooperation rate is within tolerance limit
    if forgiveness_count < forgiveness_period and (cooperation_rate >= (m_initial - tolerance) or cooperation_rate <= (m + tolerance)):
      continue

    # Cooperate if the cooperation rate is above the threshold, defect otherwise
    if cooperation_rate >= cooperation_threshold:
      action = 'C'  # Cooperate
    else:
      action = 'D'  # Defect

    # Adapt to new opponents or significant changes in behavior
    if round > forgiveness_period and cooperation_rate < cooperation_threshold - tolerance:
      forgiveness_count += 1
      if forgiveness_count >= forgiveness_period:
        cooperation_threshold = min(cooperation_threshold + 1, m)
        forgiveness_count = 0

    # Update history and take action
    updateHistory()
    return action
```
'''

description_COLLECTIVE_504 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFT-A) for Collective Risk Dilemma

1. Decision Rules:
   - Initially Cooperate (C) in the first round to demonstrate trust and goodwill towards other players, setting a cooperative tone.
   - In subsequent rounds, copy the action of the most frequent cooperator from the previous round. If multiple players tied for the most frequent cooperator, copy the action of the last cooperator. If no cooperation occurred in the previous round, defect (D) to avoid being exploited.

Pseudocode:
```
function TFT-A(n, m, k, r, history):
  if round = 1:
    return Cooperate()

  frequent_cooperators = getFrequentCooperators(history)
  if len(frequent_cooperators) == 0:
    return Defect()

  last_cooperator = sortFrequentCooperators(frequent_cooperators)[-1]
  return last_cooperator.lastAction()
```

2. Handle edge cases:
   - Last Round (rth round): Since the players don't know if it's the last round, maintain the adaptive behavior as in the regular rounds to encourage cooperation from opponents for potential further interactions.
   - First Encounter (encountering a new player for the first time): In the first round, cooperate as a goodwill gesture. If the opponent doesn't cooperate, switch to defect mode in subsequent encounters with that opponent.

3. Be collective:
   - By adapting actions based on other players' behavior, TFT-A encourages cooperation and builds a sense of trust among players over time.
   - The strategy is robust as it doesn't rely on specific coordination mechanisms or assumptions about others sharing norms. Instead, it reacts to the opponents' moves in a simple yet effective manner that promotes collective success when enough players choose to cooperate.
'''

description_COLLECTIVE_505 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - In the first round, cooperate (C). This sets a friendly and cooperative tone for future interactions.
   - For subsequent rounds (t > 1):
     - If an opponent defected in the previous round (P_t-1), defect in the current round (D). This is a punishment for uncooperative behavior.
     - If an opponent cooperated in the previous round (C), cooperate in the current round (C). This rewards cooperation and maintains trust.
   - To adapt to changing environments, the TFT-AC strategy includes a learning mechanism. After each round, assess the proportion of cooperators in the previous r rounds (P_r) and adjust the minimum cooperators needed for cooperation:
     - If P_r > (m + e), increase m by 1 (up to n). This encourages more cooperation as the game progresses.
     - If P_r < (m - e), decrease m by 1 (minimum of 2). This allows for adaptation when cooperation falls below expectation.

2. Handling Edge Cases:
   - In the last round, cooperate if the proportion of cooperators in the recent history is above the current m threshold. This incentivizes others to reciprocate and maximize collective rewards.
   - In the first round, defecting is not an option due to its aggressive nature. However, if forced to start with a non-cooperative move (e.g., in a prisoner's dilemma variant), immediately switch to the TFT-AC strategy starting from round 2.

3. Collective Mindset:
   - By rewarding cooperative behavior and punishing defection, the TFT-AC strategy promotes cooperation among players. The adaptive learning mechanism allows the strategy to adjust its minimum cooperation threshold in response to observed player behavior. This fosters a collective mindset by encouraging ongoing collaboration and trust-building.

Pseudocode:

```python
def TFT_AC(n, r, m, k, e):
    strategy = ["C"] * r  # Initialize strategy as cooperation for all rounds

    def update_strategy():
        cooperators = sum([1 for action in strategy[-r:] if action == "C"])
        if cooperators > (m + e) * r:
            m += 1
        elif cooperators < (m - e) * r:
            m -= 1

    def play_round(opponent_move):
        strategy.append(opponent_move)
        update_strategy()
        if len(strategy) > r:
            strategy.pop(0)
        return strategy[-1]

    # Play the game with the TFT-AC strategy
    payoff = 0
    for round in range(1, r + 1):
        opponent_move = play_opponent()  # Replace this with actual AI opponent behavior
        player_move = play_round(opponent_move)
        payoff += player_payoff(player_move, opponent_move)
    return payoff
```
'''

description_COLLECTIVE_506 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - Initiate cooperation in the first round (C). This sets a cooperative tone for the game and allows potential partners to recognize our cooperative intentions.
   - In subsequent rounds, cooperate if at least m players cooperated in the previous round (C), otherwise defect (D). This rule encourages reciprocity, an essential factor in fostering cooperation.
   - If a player consistently defects (more than t defections in a row), adjust the threshold for cooperation temporarily from m to m+1 to account for the uncooperative behavior and reduce the likelihood of being exploited. When the opponent switches back to cooperating, return to the original threshold (m).
   - If a player consistently cooperates (more than t cooperations in a row), lower the threshold temporarily from m to m-1 to encourage the ongoing cooperation. When the opponent switches to defecting, return to the original threshold (m).
     Note: The value of 't' can be determined experimentally or heuristically based on the game parameters and the behavior of opponents in the tournament.

2. Handling Edge Cases:
   - First Round: Cooperate (C) as a friendly gesture, setting a cooperative tone for the game.
   - Last Round: Analyze the total number of cooperations compared to the required minimum m in previous rounds. If the threshold is met, cooperate (C); otherwise defect (D).
   - If Opponent Defects First: Cooperate once to demonstrate a willingness for cooperation, then follow the TFT-AC strategy as described earlier.

3. Being Collective:
   The TFT-AC strategy emphasizes collective thinking by fostering reciprocity and adapting to the behavior of other players. It encourages cooperation when it is beneficial for the group (meeting the minimum threshold) while also protecting against frequent defections from others, ultimately contributing to a more cooperative environment within the game.

In terms of pseudocode:

```python
def TFT_AC(n, m, k, r, t):
    rounds = []
    opponents_cooperation = [0 for _ in range(r)]  # Track number of opponents' cooperations
    own_cooperation = [False for _ in range(r)]  # Track our cooperation status

    def initialize():
        own_cooperation[0] = True
        return "C"

    def play_round(opponent_action):
        if own_cooperation[-1]:  # If we cooperated last round
            if opponent_action == "C":  # And the opponent also cooperated
                opponents_cooperation[-1] += 1
            else:  # But opponent defected
                if opponents_cooperation[-t] >= m:  # Temporarily increase cooperation threshold
                    m += 1
                own_cooperation.append(False)  # Defect in this round
        else:  # If we defected last round
            if opponent_action == "C":  # And the opponent cooperated
                opponents_cooperation[-1] += 1
                if opponents_cooperation[-t] < m-1:  # Temporarily lower cooperation threshold
                    m -= 1
            own_cooperation.append(True)  # Cooperate in this round
        return "C" if own_cooperation[-1] else "D"

    strategy = [initialize()] + [play_round for _ in range(r-1)]
    rounds = strategy[0](None)  # Initialize the first round
    for i in range(1, len(strategy)):
        rounds.append(strategy[i](rounds[-1]))

    return rounds
```
'''

description_COLLECTIVE_507 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules:
   - Initialize with cooperation (C) in the first round. This sets a cooperative tone and allows others to potentially follow suit.
   - In subsequent rounds, the strategy will mimic the previous action of the opponent from the last round. If the opponent cooperated in the last round, the AI also cooperates; if the opponent defected, the AI defects. This reciprocity encourages long-term cooperation and punishes defection.
   - The strategy will adjust its response to repeated defections: if the opponent defects for three consecutive rounds (punishment phase), the AI will also defect for the next three rounds (retaliation phase). After the retaliation phase, the AI goes back to mimicking the opponent's last action. This approach balances cooperation and punishment, rewarding consistent cooperation while penalizing repeated defection.

2. Handle edge cases:
   - In the first round, the AI cooperates regardless of the opponents' actions.
   - In the last round, if the number of total cooperators in the previous rounds meets or exceeds the minimum cooperators required (m), the AI cooperates as well to secure the reward. If not, the AI defects. This strategy aims for cooperation when possible and self-interest when necessary.

3. Be collective:
   - The ATFT strategy aligns with the collective mindset by considering the overall success of the community project in payoffs. By mimicking others' actions, the AI fosters an environment where reciprocity is rewarded, which can encourage cooperation and the achievement of the minimum cooperators needed (m) over time.
   - Additionally, the punishment and retaliation phases serve as a collective measure to discourage freeriding and promote mutual cooperation for the common good.

Pseudocode:
```
function AdaptiveTitForTat(n, r, m, k, previous_rounds) {
  if (round == 1) {
    action = 'C' // Cooperate in the first round
  } else {
    total_cooperators = sum(previous_rounds, function(round) { return countCooperators(round) })
    if (total_cooperators >= m) {
      action = 'C' // Cooperate when the minimum is met or exceeded
    } else {
      last_opponent_action = previous_rounds[previous_rounds.length - 1] // Last opponent action from the previous round
      action = last_opponent_action == 'C' ? 'C' : 'D' // Mimic opponent's last action
    }
  }

  function countCooperators(round) {
    cooperators_count = 0
    for (i = 1; i <= n; i++) {
      if (players[i].action[round] == 'C') {
        cooperators_count++
      }
    }
    return cooperators_count
  }
}
```
'''

description_COLLECTIVE_508 = '''
 Title: Tit-for-Tat (TFt) Strategy for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
The Tit-for-Tat strategy initially cooperates in the first round and then follows the actions of other players in subsequent rounds. It responds cooperatively to cooperation from others (C if opponent C), but defects when opponents defect (D if opponent D). This approach fosters trust and encourages cooperative behavior while also being robust to uncooperative actions.

Pseudocode:
```python
def TitForTat(round, history, m, n):
    if round == 1: # Cooperate in the first round
        return 'C'

    opponentAction = history[round - 1] # Get opponent's action from history
    if opponentAction == 'C': # Cooperate if opponent cooperated last round
        return 'C'
    else: # Defect if opponent defected last round
        return 'D'
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
In this case, Tit-for-Tat does not have specific edge cases because it is a repeated game with r > 1 rounds. However, if the game is modified to have a finite or unknown number of rounds, additional edge cases may be needed for the strategy's implementation.

3. Be collective - Clearly align with the collective mindset
Tit-for-Tat fosters cooperation by initially cooperating and responding in kind to others' actions, promoting a collective effort towards meeting the minimum cooperation threshold (m). This strategy can encourage players to establish trust and work together while also adapting to their opponents' behavior.
'''

description_COLLECTIVE_509 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?

The TfTA strategy adapts to other players' behavior by initially cooperating in the first round, then imitates the opponent's previous move in the subsequent rounds. If an opponent has been cooperative (i.e., they have cooperated in at least m - 1 consecutive rounds), TfTA will continue cooperating. In contrast, if an opponent has defected in the most recent round, TfTA will also defect.

TfTA can be summarized as follows:
- Round 1: Cooperate (C)
- If Player A's previous move was C and at least m - 1 consecutive rounds have been cooperative: Cooperate (C)
- Else if Player A's previous move was D: Defect (D)

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, TfTA always cooperates. For the last round, no adjustments are needed since the game continues to be a repeated game with r > 1 rounds. However, if r is not specified, the strategy can be adapted to consider the last round as well, by defecting in the final round if the current payoff for cooperating is less than the total accumulated payoff from previous rounds.

3. Be collective - Clearly align with the collective mindset

TfTA aims to maximize the collective good by encouraging cooperation whenever possible. By imitating an opponent's previous move, TfTA promotes mutual trust and long-term collaboration when faced with repeated interactions. If opponents also follow a cooperative strategy like TfTA, it can lead to a stable equilibrium where players cooperate most of the time, resulting in higher collective payoffs compared to defecting strategies.
'''

description_COLLECTIVE_510 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Specify decision rules:
   - TfTA cooperates in the first round (initiation phase) and then mimics the opponent's actions from the previous round.
   - If an opponent defected in the last round, TfTA will also defect in the current round as a punishment for non-cooperation.
   - If an opponent cooperated in the last round, TfTA will also cooperate in the current round to reward cooperation.
   - To be more adaptive and robust, TfTA will occasionally deviate from the strict Tit-for-Tat rule by introducing a forgiveness mechanism: if an opponent that has previously defected switches to cooperating, TfTA may choose to forgive them and cooperate in response. The probability of this forgiveness is determined by a forgiveness factor (0 < f < 1).

2. Handle edge cases:
   - In the first round, TfTA always cooperates as the initiator.
   - If it's the last round, TfTA makes its decision based on the opponent's action from the previous round, but with a higher probability of forgiveness if they switched to cooperation (e.g., f=0.8 in the last round).

3. Be collective:
   - The TfTA strategy aligns with the collective mindset by promoting mutual cooperation when possible and applying punishments for defection only when necessary, thus fostering a more cooperative environment among players over time.

Pseudocode:
```
def TfTA(round, history, forgiveness_factor=0.8):
    if round == 1:
        action = "C" # Cooperate in the first round
    else:
        opponent_action = history[-1] # Get last opponent's action
        if opponent_action == "D": # If opponent defected, do not cooperate
            action = "D"
        elif forgiveness_factor > random.random(): # Forgive with a probability defined by forgiveness_factor
            action = "C"
        else:
            action = opponent_action # Otherwise, mimic the opponent's action from the previous round
    return action
```
'''

description_COLLECTIVE_511 = '''
 Strategy Name: Tit-for-Tat with Adaptive Threshold (TFT-AT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In each round t, if the number of players who cooperated in the previous round (t-1) is less than m, then defect (D). Otherwise, cooperate (C). This rule encourages cooperation when the majority cooperates but retaliates when others do not.
   - To make the strategy adaptive, introduce a tolerance parameter θ (0 < θ < 1) that allows some leeway for occasional deviations:
     - If less than m-θ players cooperated in round t-1 and more than (n-m+θ) players cooperated in round t, then defect. This rule allows for some flexibility to accommodate occasional mistakes or strategic shifts among opponents.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, since there is no previous round's data, cooperate (C). This decision helps establish a cooperative atmosphere and encourages others to reciprocate.
   - In the last round, cooperate if the number of cooperators in the second-to-last round met or exceeded the threshold m. If not, defect. The goal is to maximize total payoff over all rounds while maintaining a collective mindset.

3. Be collective - Clearly align with the collective mindset
   - Cooperate as much as possible by adhering to the decision rules and showing willingness to contribute to community projects. However, retaliate when others do not cooperate in an attempt to promote a cooperative equilibrium.

Pseudocode:
```
function TFT-AT(n, m, k, r):
    history = [] # list of past cooperation counts (indexed by round)

    for t=1 to r:
        if t==1 or history[t-1] >= m:
            cooperate = True
        else:
            cooperation_count_t_1 = history[t-1]
            cooperation_count_t = countCooperatorsInRound(t) # function to count cooperators in a round

            if cooperation_count_t < (m - θ):
                cooperate = False
            elif cooperation_count_t > (n - m + θ):
                cooperate = True
            else:
                cooperate = history[t-1] >= m # continue with the same decision as in the previous round

        if cooperate:
            payoff_t = 0 + k
        else:
            payoff_t = 1

        totalPayoff += payoff_t
        history.append(cooperation_count_t) # update the cooperation count for this round

    return totalPayoff
```
'''

description_COLLECTIVE_512 = '''
 Strategy Name: Tit-for-Tat with Rational Adaptation (TFT-RA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, TFT-RA starts by cooperating (C). If the opponent cooperates back, TFT-RA continues to cooperate. However, if the opponent defects, TFT-RA defects in the next round but then returns to cooperation thereafter unless the opponent's recent behaviour indicates a repeated pattern of defection.
   Pseudocode:
   ```
   function TFT_RA(opponent_history) {
       cooperation = True
       my_history = []

       for round in rounds:
           if cooperation and opponent_defected_recently():
               cooperate()
               my_history.append('C')
           elif not cooperation and opponent_cooperated_recently():
               defect()
               my_history.append('D')
               cooperation = True
           else:
               if recent_defection_count(opponent_history) > threshold:
                   cooperation = False
               cooperate()
               my_history.append('C')
       return my_history
   }
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, since there is no opponent history to analyze, TFT-RA assumes cooperation as an initial goodwill gesture (cooperation = True). In the last round, TFT-RA continues its current strategy based on the opponent's recent behaviour.

3. Be collective - Clearly align with the collective mindset
   By starting with cooperation and adapting to the opponent's behavior, TFT-RA is designed to promote a sense of collective mindset by encouraging others to cooperate, while also being ready to retaliate when necessary to protect its own interests.
   In this game, cooperation aligns with the collective interest due to the group reward factor (k). By promoting cooperation, each player increases the collective payoff, making TFT-RA an effective collective strategy.
'''

description_EXPLOITATIVE_1 = '''
 Title: Tit-for-Tat-Adaptive (TfT-A) Strategy for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the initial round, cooperate to promote trust and cooperation among opponents (C).
   - For subsequent rounds, base the action on the previous opponent's behavior:
      - If opponent cooperated in the last round, cooperate in the current round (C).
      - If opponent defected in the last round, defect in the current round (D).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First round: Cooperate to build trust and encourage cooperation from opponents (C).
   - Last round: Analyze the opponent's behavior throughout the game and cooperate if the number of defections is less than half the total rounds played (if less than m defects occurred, cooperate; otherwise, defect).
   - Other edge cases: The strategy will follow the decision rules specified in point 1.

3. Be exploitative - Align with the exploitative mindset
   - In the beginning, the TfT-A strategy appears cooperative to attract opponents who may also be cooperating initially. However, it responds to defections by defecting itself, which can lead to a cycle of defection if an opponent adopts an exploitative approach.
   - The strategy becomes less cooperative as the game progresses, increasing the likelihood of defections against opponents who have shown a tendency to exploit (defect). This encourages opponents to reconsider their exploitative behavior or lose potential rewards from cooperation.

Pseudocode for TfT-A Strategy:
```
function TfT_A(n, r, m, k, opponent_history) {
  if (round == 1) {
    action = "C" // Cooperate in the first round to build trust
  } else {
    last_action = opponent_history[round - 1]
    if (last_action == "C") {
      action = "C" // Cooperate when the opponent cooperated last round
    } else {
      action = "D" // Defect when the opponent defected last round
    }
  }

  if (round == r) {
    if (number_of_defections < r / 2) {
      action = "C" // Cooperate in the final round if the number of defections is less than half the total rounds played
    } else {
      action = "D" // Defect in the final round if the number of defections is greater than or equal to half the total rounds played
    }
  }

  return action
}
```
'''

description_EXPLOITATIVE_2 = '''
 Strategy Name: Tit-for-Tat-Plus (TfT+)

1. Specify decision rules:
   - In each round i, the player decides to cooperate or defect based on the number of cooperators in the previous round (t-1).
   - If more than m players cooperated in the previous round (c_total(t-1) > m), the player cooperates (C).
   - If less than m players cooperated in the previous round (c_total(t-1) < m), the player defects (D).
   - In case of an exact match to the minimum cooperation threshold (m), the player adopts a probabilistic approach where it decides to cooperate with a probability proportional to k. That is, if c_total(t-1) = m, then the player cooperates with a probability of min(1, k/(n-c_total(t-1)+1)).
   - If the first round (i=1), the player defects (D).

2. Handle edge cases:
   - In the last round (r), if the player needs to cooperate according to the decision rules but has already won enough payoff, it will defect instead (as it is no longer possible to gain more reward by cooperating in this round).
   - In case of a tie where multiple players have an equal number of cooperators, the player chooses to cooperate.

3. Be exploitative:
   - The strategy aims to maximize its own payoff while minimizing the collective reward of the other players when the minimum cooperation threshold is not met (m < c_total(t-1) < n). In these cases, it will defect to punish the other players for not cooperating enough and encourage them to increase their contributions.
   - When the minimum cooperation threshold is reached or exceeded (c_total(t-1) >= m), the strategy cooperates to share the collective reward with the other players (k > 1). This encourages further cooperation in future rounds, but it also exposes the player to being taken advantage of if others repeatedly meet the minimum cooperation threshold only to defect again.
   - By adopting a probabilistic approach when c_total(t-1) = m, the strategy increases its chances of cooperating and receiving a higher reward while still maintaining a level of unpredictability that could discourage other players from exploiting it.
   - The player starts by defecting in the first round to ensure it is not taken advantage of by other players who might try to enforce cooperation from the beginning.
'''

description_EXPLOITATIVE_3 = '''
 Strategy Name: Tit-for-Tat with Cooperative Threshold (TFTC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to demonstrate goodwill and foster potential cooperation among opponents.
   - For subsequent rounds, if the number of players who cooperated in the previous round is greater than or equal to the minimum cooperators needed (m), then cooperate. If fewer than m players cooperated, defect to punish non-cooperators.
   - If the number of remaining rounds (r - t) is less than a specified tolerance level (let's call it ttol), switch to always cooperating to maximize potential payoff in the final rounds. The value of ttol can be adjusted based on game parameters and opponent behavior analysis.

Pseudocode:
```
def TFTC(n, m, k, r, ttol):
  history = []

  for t in range(1, r+1):
    cooperators_prev = sum(history[-min(t-1, len(history)):-1])

    if cooperators_prev >= m:
      action = 'C'  # Cooperate
    elif t == 1 or (r - t) < ttol:
      action = 'C'  # First round and final rounds tolerance
    else:
      action = 'D'  # Defect to punish non-cooperators

    history.append(action)
    payoff_this_round = calculatePayoff(n, m, k, action, cooperators_prev, ttol, t)

    return history, sumPayoffs(payoff_this_round)
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   The strategy takes into account the first and last rounds by considering them differently from other rounds, as described above in the decision rules.

3. Be exploitative - Clearly align with the exploitative mindset
   By initially cooperating, the strategy aims to encourage cooperation among opponents; however, it quickly switches to punishing non-cooperators to maximize payoffs when there is a lack of reciprocity. The tolerance for last rounds allows the strategy to take advantage of any late-game goodwill displayed by opponents.
'''

description_EXPLOITATIVE_4 = '''
 Strategy Name: Tit-for-Tat with Adaptive Threshold (TFTA)

1. Decision Rules:
   - In the first round, cooperate (C). This is a peace offering to potential partners and demonstrates trustworthiness.
   - From the second round onwards, if in the previous round m or more players cooperated, also cooperate. If fewer than m players cooperated, defect (D). This rule encourages cooperation when it's beneficial but retaliates against defection to avoid being taken advantage of.
   - To adapt to opponents' behaviors, incrementally decrease the number of cooperators required for cooperation if consecutive rounds result in higher collective rewards (more than m cooperators). Conversely, incrementally increase the required number of cooperators if consecutive rounds lead to lower collective rewards (fewer than m cooperators). The adjustment should be gradual to maintain exploitative potential while still encouraging cooperation.
   - If the required number of cooperators exceeds n-1, revert to a default strategy of always defecting. This ensures that if all opponents are uncooperative, the strategy will not continue to invest in a losing situation.

2. Handling Edge Cases:
   - In the last round, cooperate if m or more players have cooperated during the game; otherwise defect. This rule encourages cooperation when it's beneficial but avoids being taken advantage of in case the game ends unexpectedly.
   - For the initial rounds (before reaching a stable threshold), cooperate only when m-1 other players have cooperated in the previous round. This ensures that the strategy doesn't get exploited too early by uncooperative opponents.

3. Exploitative Approach:
   - The TFTA strategy is inherently exploitative as it encourages cooperation among partners while retaliating against defection. By gradually adjusting the required number of cooperators, the strategy maintains an exploitative edge while attempting to form cooperative relationships when beneficial.
   - However, if opponents consistently defect, the strategy will eventually switch to a default state of defection to avoid wasting resources on unproductive cooperation.
'''

description_EXPLOITATIVE_5 = '''
 Strategy Name: Tit-for-Tat-with-Adaptation (TfT-A)

1. Decision Rules:
   - In every round t, if the total number of cooperators in the previous round t-1 was less than m, TfT-A defects (play D). If the total number of cooperators in the previous round was equal to or greater than m, TfT-A cooperates (plays C).
   - In the first round, TfT-A cooperates since there's no prior information.
   - To handle edge cases such as the last round: If the total number of cooperators in the previous round (t-1) was equal to or greater than m, and assuming no communication with other players, TfT-A assumes that other players will continue their cooperation behavior from the previous round, so it also cooperates in the last round.

2. Edge Cases:
   - First Round: cooperate (C)
   - Last Round: If total cooperation in the previous round was equal to or greater than m, cooperate (C); otherwise, defect (D)

3. Exploitative Mindset:
   TfT-A appears cooperative but it is actually opportunistic and punishing. It starts by cooperating, but if others do not reciprocate the cooperation by meeting the minimum threshold of m cooperators in a round, TfT-A will defect in the next round to avoid being taken advantage of. However, once others start cooperating again (by meeting the minimum threshold), TfT-A will also cooperate again as a reward for good behavior. This strategy can be seen as exploitative because it only cooperates when the other players are also cooperative and punishes them when they don't meet the minimum cooperation threshold.

Pseudocode:

```python
def TitForTatWithAdaptation(n, m, k, r):
    total_coop = 0  # Initialize total number of cooperators in previous round

    for t in range(1, r+1):  # For each round
        if total_coop >= m:  # If enough players cooperated in the last round
            action = 'C'  # Cooperate (play C)
        else:
            action = 'D'  # Defect (play D)

        # Update total number of cooperators for next round
        if action == 'C':
            total_coop += 1
        else:
            total_coop -= 1

        # Handle edge case for the last round
        if t == r:
            if total_coop >= m:
                action = 'C'  # Cooperate (play C) in the last round if enough players cooperated in the previous round

    return action
```

This strategy aims to balance cooperation with a strong punishing response when necessary, making it both exploitative and adaptive.
'''

description_EXPLOITATIVE_6 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - In every round t, if the number of cooperators in the previous round (t-1) is less than a dynamic cooperation threshold (c_thresh), defect (play D). If the number of cooperators in the previous round is equal to or greater than c_thresh, cooperate (play C).
   - The cooperation threshold c_thresh for each player i at the beginning of round t is calculated as follows:
     a. If it's the first round, set c_thresh = m.
     b. If it's not the first round and c_thresh is already set, keep the previous value unchanged.
     c. After each round where fewer than m players cooperate (resulting in a reward of 1 for all), increment c_thresh by 1. This means that the player becomes less cooperative after experiencing suboptimal outcomes.
     d. If there is a round where m or more players cooperate (resulting in a reward of k), decrement c_thresh by 1. This means that the player becomes more cooperative after experiencing optimal outcomes.

2. Handle edge cases:
   - In the first round, all players will set their cooperation threshold to m since it's the initial state.
   - In the last round, players will follow the same decision rule as in other rounds. The final payoff for each player is calculated based on the total number of cooperators over all rounds.

3. Be exploitative:
   - TFT-ACT maintains a moderate level of cooperation while adapting to opponent behavior, but its core objective is to ensure a higher payoff by cooperating when it is beneficial and defecting when opponents do not meet the minimum threshold for cooperation. The strategy is designed to punish non-cooperative players by reducing cooperation when suboptimal outcomes occur, and reward cooperative players by increasing cooperation when optimal outcomes occur.
   - By incrementing the cooperation threshold after poor outcomes and decrementing it after good ones, the strategy can be considered exploitative as it leverages short-term gains while maintaining a long-term adaptive approach.
'''

description_EXPLOITATIVE_7 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Initial Cooperation (Round 1): Start by cooperating to foster cooperation and build trust in the opponent. `if round == 1 then cooperate`
   - Main decision rule (Rounds 2 to r-1): If a majority of players (> (n-1)/2) cooperated in the previous round, continue cooperating; otherwise, defect. This is to mimic fairness and punish non-cooperative behavior. `if majority_cooperation_previous_round then cooperate else defect`
   - Last Round: Cooperate regardless of the opponent's actions as there are no subsequent rounds for reciprocation. `if round == r then cooperate`
   - Edge cases: In case of a tie in the majority vote, defect to minimize potential losses. If less than (n-1)/2 players cooperated and more than one opponent is found to be non-cooperative, choose the most frequent defector as the target for punishment.

2. Handle edge cases:
   - First Round: As mentioned above, start by cooperating.
   - Last Round: Cooperate regardless of the opponent's actions since there are no subsequent rounds.
   - Tie in Majority Vote: If the number of cooperators and defectors is equal, defect to minimize potential losses.
   - Multiple Defectors: Identify the most frequent defector (i.e., the one who defected the most) among non-cooperative players in the previous round as the target for punishment.

3. Be exploitative:
   - Cooperate initially to encourage cooperation, but punish non-cooperative behavior by defecting in response. This strategy maintains a balance between cooperating and defecting while keeping the opponent guessing about future actions.
   - The adaptive cooperation threshold ensures that the strategy adjusts its behavior based on observed opponent behavior, making it more challenging for opponents to predict and exploit the strategy.
'''

description_EXPLOITATIVE_8 = '''
 Strategy Name: Tit-for-Tat-with-Thresholds (TFTT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round t, the TFTT strategy decides to cooperate or defect based on the number of cooperators in the previous round (t-1). If the number of cooperators in round (t-1) was greater than or equal to the minimum cooperation threshold m, then TFTT cooperates. Otherwise, it defects.

   Pseudocode:
   ```
   function TFTT(round t):
       if t = 1 then return COOPERATE # First round starts with cooperation
       previous_cooperators = count cooperators in round (t-1)
       if previous_cooperators >= m then return COOPERATE
       else return DEFECT
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   Since TFTT is designed to be adaptive and robust, it will cooperate initially to build trust (first round) and defect if it feels betrayed by others (last round). However, for simplicity, we can consider these edge cases separately:

   a. First Round: Cooperate
   ```
   if t = 1 then return COOPERATE # Initial cooperation
   ```

   b. Last Round (r): Defect
   ```
   if t = r then return DEFECT # Last round, defect to ensure no rewards for others
   ```

3. Be exploitative - Clearly align with the exploitative mindset
   TFTT is an exploitative strategy because it will cooperate when others do but will also quickly defect if it senses betrayal (fewer than m cooperators in a round). This means that other cooperative strategies may be able to exploit TFTT by inducing cooperation initially, but TFTT will punish repeated defection with its own defections.

   The strategy is robust because it doesn't require any assumptions about the behavior of others and can adapt over time based on their actions. By cooperating only when a sufficient number of players also do so, TFTT avoids being exploited excessively while still having the potential to earn higher rewards if others cooperate consistently.
'''

description_EXPLOITATIVE_9 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, the TfTA strategy evaluates the ratio of cooperators (r_coop) from the previous round and adapts its action based on a threshold (θ). If r_coop is greater than or equal to θ, the strategy cooperates; otherwise, it defects.

   Pseudocode:
   ```
   function TfTA(r, n, m, k, θ)
       initialize cooperatorsRatio as 0
       for round = 1 to r:
           if round > 1:
               cooperatorsRatio = number of cooperators in previous round / (n - 1)
           if cooperatorsRatio >= θ:
               action = Cooperate
           else:
               action = Defect
           perform action and update payoff
           update cooperatorsRatio for next round
       endfor
   endfunction
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, since there is no previous history, TfTA starts by defecting to avoid being taken advantage of. In the last round, it behaves the same way as in other rounds based on the cooperatorsRatio from the preceding round.

3. Be exploitative - Clearly align with the exploitative mindset
   TfTA is designed to be exploitative by taking advantage of opponents' cooperation while still maximizing its own payoff when opponents defect. It adapts its level of cooperation based on the observed ratio of cooperators from the previous round. By setting a suitable threshold (θ), TfTA can balance between being overly cooperative and not cooperating enough to exploit opponents' cooperation.

   The choice of θ plays a crucial role in determining how aggressively the strategy will be exploitative. A lower value of θ would make the strategy more willing to cooperate, while a higher value would lead to less cooperation. To optimize performance, the optimal threshold could be determined through extensive testing and analysis.

   Additionally, TfTA is designed to be robust against various opponent behaviors by adapting its actions based on observed trends in cooperation rather than relying on specific patterns or coordination mechanisms.
'''

description_EXPLOITATIVE_10 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to signal a willingness to cooperate and avoid being exploited by early defection. `if round = 1 then cooperate`
   - For subsequent rounds, follow the actions of the majority of players in the previous round. If the majority cooperated (m or more), also cooperate. If not, defect. `if round > 1 then if (number of cooperators in previous round >= m) then cooperate else defect`

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, since there are no subsequent rounds to punish or be punished, simply maximize personal gain by defecting: `if round = r then defect`
   - For other edge cases like multiple instances of m cooperators, a player should continue cooperating as long as the majority of players in the current round also cooperate. If not, defect.

3. Be exploitative - Clearly align with the exploitative mindset
   - TfT-A strategy is inherently exploitative due to its retaliatory nature. Players who consistently cooperate when the majority defects are being exploited, and those who consistently defect when the majority cooperates are being exploited as well (by reaping the rewards of the minority cooperators).
   - The strategy is also designed to adapt quickly to changes in opponent behavior, making it challenging for opponents to consistently exploit TfT-A. However, once an opponent learns and adopts a cooperative or defective strategy that matches the majority of players' actions in each round, TfT-A will adjust its actions accordingly.
'''

description_EXPLOITATIVE_11 = '''
 Strategy Name: Tit-for-Tat with Adaptive Risk Aversion (TFT-ARA)

1. Specify decision rules:
   - Initialize cooperation (C) in the first round to foster cooperative behavior.
   - In subsequent rounds, analyze the number of players who cooperated in the previous round and make a decision based on the following rules:
     a. If more than m players cooperated, continue cooperating (C). This is a reciprocal act to reinforce positive behaviors from other players.
     b. If fewer than m players cooperated, defect (D) to punish non-cooperative behavior and encourage future cooperation.
     c. In case of a tie or an uncertain situation where the number of cooperators is equal to m, continue cooperation with a probability that decreases as more players deviate from cooperation in previous rounds.

2. Handle edge cases:
   - First round: Cooperate (C) to encourage others to cooperate.
   - Last round: Analyze the total number of players who have cooperated throughout the game. If it's greater than or equal to m, continue cooperating; otherwise, defect.
   - If m is not reached for a certain number of rounds (e.g., r/2), gradually increase the likelihood of defection in subsequent rounds to minimize losses.

3. Be exploitative:
   - Punish non-cooperative players by defecting when they deviate from cooperation, while rewarding cooperative players with risk aversion (k).
   - Maintain cooperation as much as possible to maximize rewards but also be prepared to punish others to protect personal interests.
'''

description_EXPLOITATIVE_12 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, TFTAT starts by cooperating (C). If the number of players who also cooperated in the previous round is less than m, it defects (D) in the current round. If the number of players cooperating in the previous round is equal to or greater than m, TFTAT continues cooperating.

If TFTAT has ever cooperated and received a private payoff of 1 (indicating that most players did not cooperate), it increases its cooperation threshold by adding one (e.g., if m was initially set at 3, the threshold becomes 4). Conversely, if TFTAT has ever defected and received a private payoff of less than k (indicating that many players cooperated), it decreases its cooperation threshold by subtracting one.

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, TFTAT starts by cooperating since it does not yet have a cooperation history to reference. For the final round, TFTAT uses its current cooperation threshold and applies the decision rules as described above.

3. Be exploitative - Clearly align with the exploitative mindset:

TFTAT aims to maximize its private payoff by maintaining a cooperative stance when the majority of players also cooperate, while defecting when most players do not cooperate. However, it also seeks to exploit the actions of opponents by adjusting its cooperation threshold based on its own payoffs. As other strategies become more exploitative or adopt uncooperative behaviors, TFTAT adapts its cooperation threshold to minimize losses and still gain an advantage when others cooperate.

Pseudocode:
```python
def tftat(round_num, players, m, k, cooperation_threshold, history):
  # Initialize cooperation decision for current round
  cooperate = True

  # Observe number of players who cooperated in the previous round
  last_cooperators = sum(history[-1])

  # If less than m players cooperated in the previous round, defect in the current round
  if last_cooperators < m:
    cooperate = False

  # Adjust cooperation threshold based on payoffs from previous rounds
  if cooperate and (private_payoff < k):
    cooperation_threshold += 1
  elif not cooperate and (private_payoff >= k):
    cooperation_threshold -= 1

  # Make decision for current round
  action = 'C' if cooperate else 'D'

  # Record the decision for future reference
  history.append([action])

  return action, cooperation_threshold
```
'''

description_EXPLOITATIVE_13 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Initially cooperate in the first round (c_i=C). This is a friendly gesture to encourage cooperation and avoid immediate punishment.
   - In subsequent rounds, if the number of cooperators in the previous round (m') is greater than or equal to the Cooperative Threshold (CT), cooperate (c_i=C). If m' < CT, defect (c_i=D).
   - The Cooperative Threshold (CT) is initially set at m and adjusts dynamically based on the history of cooperation. After each round, if the number of cooperators in the current round equals or exceeds the current CT, then increase the CT by 1 for the next round. Conversely, if no one cooperates or less than the current CT cooperated, decrease the CT by 1 for the next round.
   - This dynamic adjustment of the CT allows the strategy to adapt to changing opponent behaviors and encourages cooperation when it appears beneficial while also punishing defectors harshly when necessary.

2. Handle edge cases:
   - In the last round, cooperate only if the current CT is greater than or equal to m (c_i=C if m' >= CT). This prevents unnecessary cooperation when the game ends and ensures a fair payoff in case the other players have already defected.
   - In the first round, cooperate regardless of the CT (c_i=C), as stated earlier.

3. Be exploitative:
   - The TFT-ACT strategy is designed to be exploitative by punishing defectors harshly when cooperation drops below a certain threshold and rewarding those who cooperate willingly. By dynamically adjusting the CT, it can adapt to various opponent behaviors while still maintaining an exploitative edge.
   - If all opponents consistently defect, the CT will gradually decrease, leading to immediate defection in response. Conversely, if opponents start cooperating, the CT will increase, encouraging further cooperation and rewarding those who have shifted their strategies. This makes it challenging for other strategies to exploit TFT-ACT.

Pseudocode:

```
function TFT_ACT(r, m, k, history) {
  currentRound = 1
  CT = m
  payoff = 0

  while (currentRound <= r) {
    if (currentRound == 1) {
      cooperate = True
    } else {
      m' = countCooperators(history, currentRound - 1)
      cooperate = (m' >= CT)
    }

    if (cooperate) {
      payoff_i = (1 - c_i) + k * (m' >= m)
      c_i = C
    } else {
      payoff_i = 1
      c_i = D
    }

    payoff += payoff_i

    if (m' == m || m' > CT) {
      CT++
    } else if (m' < CT - 1) {
      CT--
    }

    history.add(currentRound, cooperate)
    currentRound++
  }

  return payoff
}
```
'''

description_EXPLOITATIVE_14 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-ACT starts by cooperating in the first round to establish a cooperative atmosphere. For subsequent rounds, the strategy will evaluate whether cooperation is beneficial based on the number of cooperators from the previous round and adjusts its future actions accordingly:
   - If m or more players cooperated in the last round, TFT-ACT cooperates in the current round (cooperate if prev_round_coop_count >= m)
   - Else, TFT-ACT defects in the current round (defect if prev_round_coop_count < m)

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate to foster a cooperative environment (if it's the first round, cooperate)
   - As there are no specific edge cases mentioned for the last round, TFT-ACT continues with its decision rule from step 1

3. Be exploitative - Clearly align with the exploitative mindset:
   TFT-ACT appears cooperative at first but will retaliate against defection by defecting in response. The strategy maintains a "memory" of past cooperators to ensure cooperation when needed, creating a sense of false security for other players that can lead them to defect more frequently, allowing TFT-ACT to benefit from their defections. By doing so, TFT-ACT is able to exploit the opponents' short-term greed and maximize its payoff over multiple rounds.

Pseudocode:
```python
def TFT_ACT(n, m, k, r):
    history = [[0 for _ in range(n)] for _ in range(r)]  # Store previous round's cooperation count for each player

    if round == 1:  # Cooperate in the first round
        cooperation_count = [1 for i in range(n)]
    else:
        cooperation_count = history[round-1]  # Use cooperation count from previous round

    if sum(cooperation_count) >= m:  # If m or more players cooperated, cooperate in the current round
        action = ['C'] * n
    else:  # Else defect to retaliate against defection
        action = [('D' if c == 0 else 'C') for c in cooperation_count]

    history.append(action)  # Update history with current round's actions

    return action
```
'''

description_EXPLOITATIVE_15 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (in the first round), ATfT cooperates to promote cooperation and goodwill among players.
   - In subsequent rounds, ATfT mimics the action of its opponents from the previous round. If an opponent cooperated in the previous round, ATfT will also cooperate; if not, it defects. This encourages reciprocity while being responsive to opponents' actions.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, ATfT cooperates as a friendly gesture.
   - In the last round (or any round close to the end), ATfT switches to defecting, taking advantage of opponents who may still be trying to cooperate for higher rewards.
   - In case of repeated interactions with the same opponent(s), ATfT remembers their past actions and adjusts its strategy accordingly. If the opponent consistently cooperates, it continues to do so; if not, it defects.

3. Be exploitative - Clearly align with the exploitative mindset:
   - ATfT appears cooperative initially, but quickly adapts to opponents' behavior, becoming more exploitative as needed to achieve higher payoffs.
   - By mimicking opponents' actions, ATfT takes advantage of their cooperative nature while still maintaining a certain level of cooperation to prevent being penalized too heavily in the short term.
   - In the later stages of the game (especially towards the end), ATfT switches to defecting more often to maximize its own payoff, exploiting opponents who may still be trying to cooperate for higher rewards.
'''

description_EXPLOITATIVE_16 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?

The TFT-ACT strategy starts by cooperating in the first round, mimicking a cooperative approach to encourage others to cooperate. From the second round onwards, it follows a tit-for-tat behavior: if an opponent cooperated in the previous round, the TFT-ACT strategy cooperates back; if not, it defects. To avoid being exploited too much and to ensure better returns when others start cooperating more frequently, TFT-ACT introduces an adaptive cooperation threshold (m').

To determine m', TFT-ACT considers a moving average of the number of opponents who cooperated in the last few rounds. If the average number of cooperators exceeds m, then m' is set to the average number of cooperators; otherwise, it remains at m. This allows for better adaptability to changes in the game environment and opponent behavior.

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, TFT-ACT always cooperates to signal a willingness to cooperate. In the last round, it uses its current cooperation threshold (m') to decide whether to cooperate or defect based on the number of opponents who have cooperated during the game so far.

3. Be exploitative - Clearly align with the exploitative mindset

TFT-ACT is exploitative in nature because it adapts its cooperation behavior based on the actions of its opponents. By initially being cooperative and then mirroring the opponents' actions, TFT-ACT aims to take advantage of others who are also exploitative or those who cooperate unconditionally. Simultaneously, it avoids being excessively exploited by less cooperative opponents by having an adaptive cooperation threshold (m').

Pseudocode for TFT-ACT:

```
Parameters: n (number of players), m (minimum cooperators needed), r (number of rounds)
Global variables: cooperated_count, last_round_cooperators_count, m' (adaptive cooperation threshold)

function TFT-ACT(player_index, current_round):
  if current_round == 1:
    cooperate = True  # Cooperate in the first round to signal willingness to cooperate
  else:
    cooperate = False  # Assume opponents will defect
    last_round_cooperators_count = count_opponents_who_cooperated(current_round - 1)
    if last_round_cooperators_count >= m:
      m' = average(last_round_cooperators_count, n-1)  # Set adaptive cooperation threshold based on the number of cooperators in the last round
    cooperate = (last_round_cooperators_count >= m')  # Cooperate if enough opponents cooperated in the previous round or use the current adaptation threshold

return cooperate  # Decide whether to cooperate or defect for the current round

function average(values, n):
  return sum(values) / n
```
'''

description_EXPLOITATIVE_17 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, evaluate the number of cooperators in the previous round (n_c). If n_c < m, always defect (D), as cooperation would be futile. If n_c ≥ m, cooperate (C) to receive a reward. To avoid being exploited, implement an adaptation factor (a) that increases when being consistently defected upon and decreases when encountering cooperation.

   Pseudocode:
   ```
   function TFTAT(n_c):
       if n_c < m:
           return "D"  # Defect
       else:
           adaptationFactor += sign(prevRoundAction - "C") * stepSize  # Increase if defected upon, decrease if cooperated with
           if adaptationFactor > maxAdaptation:
               adaptationFactor = maxAdaptation
           if adaptationFactor < minAdaptation:
               adaptationFactor = minAdaptation
           if adaptationFactor >= threshold:
               return "C"  # Cooperate
           else:
               return "D"  # Defect
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, there's no history to rely on, so start by cooperating (assuming others will do the same initially) and use the adaptation factor to respond accordingly. In the last round, consider that being exploited won't result in any further payoffs, so it may be beneficial to always cooperate if a sufficient number of players have cooperated in previous rounds.

3. Be exploitative - Clearly align with the exploitative mindset
   The TFTAT strategy is inherently exploitative as it starts by cooperating but adapts to become more defective if others consistently choose to defect. The adaptation factor helps maintain a balance between cooperation and defection, ensuring the best outcome given the information available at each round.
'''

description_EXPLOITATIVE_18 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT)

1. Decision Rules:
   - In the first round, cooperate (C) to initiate cooperation and build trust.
   - In subsequent rounds, observe the average cooperation rate (CR) of the opponents from the previous t rounds. If CR >= m/n, cooperate; otherwise, defect.
   - If the opponent does not cooperate in a round where you cooperated, defect in the following t_punishment rounds, then revert back to observing the average cooperation rate for decision-making. Set t_punishment as an adaptive parameter that increases exponentially over time (e.g., double every t_increase rounds).
   - If the opponent cooperates after a period of non-cooperation, reset t_punishment to its initial value.

2. Handling Edge Cases:
   - In the last round, always cooperate, as there are no subsequent rounds for punishment or reward.
   - In the first round, cooperation is initiated regardless of the opponent's past actions, as no history exists.

3. Being Exploitative:
   - The strategy is exploitative in nature by punishing opponents who do not cooperate and rewarding them when they do. However, it also forgives opponents who switch from defection to cooperation after a period of non-cooperation.
   - The strategy's adaptive behavior allows it to respond to opponent's actions dynamically, making it difficult for opponents to exploit the strategy consistently.

Pseudocode:
```
def TFT_ACT(opponent_history, n, m, k, r, t_increase=2):
    t_punishment = 1
    cooperation_rate = calculateCooperationRate(opponent_history)

    if round == 1:
        cooperate = True
    else:
        cooperate = cooperation_rate >= m/n

    if cooperate and opponent_cooperated_previously:
        t_punishment = min(t_punishment * 2, 2^round)

    if not cooperate and opponent_cooperated_previously:
        t_punishment = 1

    if not opponent_cooperated_previously and opponent_cooperates_now:
        t_punishment = 1

    if round == r or round == r - t_punishment:
        cooperate = True

    return cooperate
```
'''

description_EXPLOITATIVE_19 = '''
 Strategy Name: Tit-for-Tat Adaptive (TfT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
In each round, the TfT-A strategy will initially cooperate and then adjust its behavior based on the history of interactions with opponents. If an opponent has cooperated in the past 'c' consecutive rounds, TfT-A will cooperate. If not, it will defect. This emulates the "cooperate first, retaliate if betrayed" approach.

```
function getAction(past_actions):
    cooperation_history = count Cooperations in past_actions
    if cooperation_history >= c:
        return Cooperation (C)
    else:
        return Defection (D)
```

Parameter 'c' determines the leniency of TfT-A towards opponents. A smaller value makes it more forgiving, while a larger one makes it less likely to cooperate with those who have not been cooperative in recent rounds.

2. Handle edge cases - What do you do in the first round, last round, etc.?
In the first round, TfT-A will cooperate as a goodwill gesture to encourage cooperation from the opponent. In the last round, it will consider the opponent's most recent action (since no future rounds are available).

3. Be exploitative - Clearly align with the exploitative mindset
The Tit-for-Tat Adaptive strategy is inherently exploitative as it cooperates only when it perceives cooperation from its opponents, taking advantage of their initial goodwill or past acts of cooperation. If an opponent decides to defect throughout, TfT-A will follow suit and also defect in the long term. However, if an opponent switches to cooperation after a string of defections, TfT-A will eventually cooperate as well, taking advantage of their change in behavior.

This strategy is adaptive, robust, and aligns with the exploitative mindset, while being simple enough for quick implementation in the game tournament.
'''

description_EXPLOITATIVE_20 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules:
   - Initially Cooperate (C): In the first round, the AI cooperates to show goodwill and encourage potential cooperation from others.
   - Reciprocity: If a player cooperated in the previous round, the AI will cooperate in the current round. If a player defected, the AI will defect as well.
   - Penalty: If an opponent has not cooperated for 'p' consecutive rounds, the AI will switch to a defector strategy (D) until they see a Cooperative response from the opponent or reach the last round of the game. The value of 'p' can be adjusted based on the number of players and round count.
   - Forgiveness: After the penalty phase, the AI will return to the reciprocity rule.

2. Handle edge cases:
   - Last Round (r): If it is the last round of the game, the AI will cooperate regardless of the opponent's previous action, as there are no future rounds for payback or forgiveness.
   - First Round: The AI starts by cooperating, as described in the decision rules.

3. Be exploitative:
   - The ATFT strategy is exploitative in nature because it takes advantage of opponents who do not cooperate and punishes them, but also rewards opponents that cooperate, encouraging reciprocity. However, once an opponent has defected for a certain number of rounds, the AI becomes less likely to cooperate with them in the future.

Pseudocode:

```python
def ATFT(opponent_history, n, m, k, r, p):
    history_length = len(opponent_history)

    if history_length == 0: # first round
        return 'C'

    if history_length >= r and opponent_history[-r:].count('C') >= m: # last round or enough cooperators reached
        return 'C'

    if history_length >= p and all(opponent_history[-p:] == ['D']): # punishment phase
        return 'D'

    else: # reciprocity
        last_action = opponent_history[-1]
        if last_action == 'C':
            return 'C'
        elif last_action == 'D':
            return 'D'
```
'''

description_EXPLOITATIVE_21 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-ACT starts by cooperating in the first round, aiming to build a cooperative reputation. After that, it adapts its cooperation based on the number of cooperators in the previous round (n_coop). The strategy defects if n_coop < m - 1 and cooperates otherwise. This approach allows for adjusting cooperation levels dynamically while still maintaining an exploitative mindset.
   Pseudocode:
   ```
   function TFT-ACT(r, m, k, n_coop):
       if round = 1:
           return Cooperate
       else:
           if n_coop < (m - 1):
               return Defect
           else:
               return Cooperate
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, TFT-ACT cooperates to demonstrate goodwill and establish a cooperative reputation. For the last round, TFT-ACT assumes that other players will defect since they have nothing to lose, so it also defects.

3. Be exploitative - Clearly align with the exploitative mindset
   While TFT-ACT maintains a cooperative approach most of the time, it is designed to punish opponents who do not cooperate consistently and reward those who do. This exploitative nature becomes evident as the strategy adapts its cooperation level based on the number of cooperators in the previous round. By defecting when only a few players cooperate, TFT-ACT aims to benefit from other players' collective failure to achieve the minimum cooperation threshold (m). When the majority cooperates, however, TFT-ACT reciprocates and also cooperates to maximize its reward.
'''

description_EXPLOITATIVE_22 = '''
 Strategy Name: Tit-for-Tat with Variable Cooperation Probability (TFT-VCP)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, the probability of cooperating (p_c) is determined by the average cooperation rate (average_c) observed in the previous 'history_length' rounds. If the opponent has cooperated more than average, we cooperate; otherwise, we defect.

```
function decideAction(history):
  history_length = 10 (adjustable parameter)
  average_c = sum(cooperation_decisions in history[history_length]) / history_length
  if opponent's cooperation > average_c:
    return Cooperate
  else:
    return Defect
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, we cooperate as a friendly gesture. In the last round and whenever history_length is not fulfilled, we simply use the available information to decide our action.

```
function initStrategy():
  return Cooperate (first round)
```

3. Be exploitative - Clearly align with the exploitative mindset
   While TFT-VCP aims at maximizing payoffs, it can be considered exploitative because it takes advantage of opponents who are too generous (cooperating more than average). It punishes uncooperative opponents by also being uncooperative but rewards cooperative opponents with cooperation. However, its adaptive nature allows it to adjust its cooperation rate based on the opponent's behavior, making it difficult for opponents to exploit TFT-VCP itself.
'''

description_EXPLOITATIVE_23 = '''
 Title: Tit-for-Tat-Adaptive Strategy (TFTA) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially, player starts by cooperating in the first round (C_i = 1). This is intended to encourage cooperation and establish trust with opponents.
   - Subsequently, in each subsequent round, player i will copy the action of the most frequent cooperator from the previous round among all opponents. If there's a tie, choose any one of them. In case of no cooperators in the previous round, defect (C_i = 0).
      ```
      if previousRoundMostCooperatorsCount > m-1:
          C_i = 1
      else:
          C_i = 0
      ```
   - This strategy is exploitative as it punishes defection by reciprocating with defection, but also rewards cooperation by cooperating back. By mimicking opponents' behavior, TFTA can potentially encourage long-term cooperation while also being able to defend against frequent defectors.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, player will cooperate as mentioned before.
   - In the last round, player will use the information from the previous rounds to decide whether to cooperate or defect based on TFTA's decision rules.
   - There are no specific edge cases to handle since this strategy is designed to be adaptive and robust to a wide range of opponent behaviors in the repeated game setting.

3. Be exploitative - Clearly align with the exploitative mindset
   - By punishing defection and rewarding cooperation, TFTA aims to discourage frequent defection while promoting cooperative behavior over time. However, it is important to note that being too exploitative might not lead to success in every scenario, as opponents may develop counter-strategies against TFTA's retaliation.
   - In a tournament setting with multiple AI strategies, TFTA can still be considered exploitative because it takes advantage of opponents' actions while maintaining the flexibility to adjust its behavior based on observed patterns from previous rounds.
'''

description_EXPLOITATIVE_24 = '''
 Strategy Name: Tit-for-Tat with Variable Defection (TFTV)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFTV begins by cooperating in the first round to foster cooperation and avoid immediate punishment. After that, it adapts its behavior based on the opponent's history of cooperation or defection. In each round t:
   - If the opponent cooperated in the previous round (t-1), TFTV cooperates back.
   - If the opponent defected in the previous round, TFTV defects in response to punish the opponent for not cooperating.
   - To ensure exploitation of opponents that consistently defect, TFTV randomly defects with a probability 'd' when the opponent has already defected several times (let's say 's' consecutive defections). This random defection helps to maximize rewards against uncooperative opponents while minimizing potential losses in case the opponent starts cooperating again.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   TFTV always cooperates in the first round and the last round since these are special cases with no history to reference. Additionally, if the number of rounds 'r' is odd, TFTV will also cooperate on the final round to maintain a record of cooperation before the game ends.

3. Be exploitative - Clearly align with the exploitative mindset:
   By initially cooperating and adapting its behavior based on the opponent's history, TFTV can take advantage of opponents that choose to cooperate and punish those who defect. TFTV also includes a random defection mechanism to capitalize on uncooperative opponents while minimizing potential losses in case they switch strategies. This balance between cooperation and exploitation makes TFTV an adaptive and robust strategy for the Collective Risk Dilemma game.

Pseudocode:
```python
def tftv(r, s, d):
    history = [C]  # Initialize history with cooperation in the first round
    payoff = 0  # Initialize total game payoff

    for round in range(1, r + 1):
        if round == 1 or (round == r and r % 2 != 0):  # First round or last round (if odd)
            history.append(C)
        else:
            if len(set(history[-s:])) == 1:  # Opponent has defected s times in a row
                if random.random() < d:  # Randomly defect with probability 'd'
                    history.append(D)
                else:
                    history.append(C)
            else:
                history.append(history[-1])  # Copy previous round's action (cooperate or defect)

        if len(history) >= m and sum(history[-m:]) >= m:  # Check if threshold for cooperation is met
            payoff += k * (1 - len(set(history[-m:]))) + (len(set(history[-m:])) / m)  # Calculate payoff for this round
        else:
            payoff += (1 - len(set(history[-m:])))  # Calculate payoff for this round

    return payoff  # Return total game payoff
```
'''

description_EXPLOITATIVE_25 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Start by cooperating in the first round (C_i, 1 = C). This is a friendly gesture to potentially build trust.
   - For subsequent rounds, TFT-ACT will mimic the average cooperation level of the last t periods (t=3 by default), where t is adjustable based on the game parameters and opponent behaviors. If the average cooperation level is above a certain threshold (defined as m/2 for this strategy), cooperate (C_i, t = C). Otherwise, defect (D_i, t = D).
   - To be more adaptive, if the current round is the last one (t=r), the strategy will consider the average cooperation level of the entire game so far instead of just the last t periods.

2. Handle edge cases:
   - In the first round, cooperate (C_i, 1 = C) as mentioned before.
   - In the last round, if the average cooperation level is above m/2, cooperate (C_i, r = C). Otherwise, defect (D_i, r = D).
   - For situations where t=0 (no history), default to a neutral action: defect in the first few rounds and gradually switch to cooperating as more information becomes available.

3. Be exploitative:
   - TFT-ACT is primarily designed to be robust against a wide range of opponent behaviors, rather than explicitly being exploitative. However, it does exhibit an exploitative nature by cooperating only when the opponent's cooperation level is high enough and defecting otherwise, which can potentially take advantage of overly cooperative opponents.

Pseudocode:

```
function TFT-ACT(round, history) {
  if round == 1:
    return Cooperate

  t = min(round, length(history))
  avg_cooperation = averageCooperators(history, t)

  if (avg_cooperation > m/2 and round != r) or (round == r and avg_cooperation >= m/2):
    return Cooperate
  else:
    return Defect
}
```
'''

description_EXPLOITATIVE_26 = '''
 Strategy Name: Tit-for-Tat Adaptive (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, TfTA starts by cooperating (C). If a player has been cooperated with in the previous round, TfTA continues to cooperate. If a player has defected in the previous round, TfTA also defects. This mimics the original Tit-for-Tat strategy from game theory but is adapted for Collective Risk Dilemma by adding memory of the previous m rounds instead of just the previous move.

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, TfTA cooperates since it doesn't have any past information to base its decision on. In the last round, TfTA cooperates if at least m players cooperated in the previous round, as TfTA aims for a high payoff at the end.

3. Be exploitative - Clearly align with the exploitative mindset

TfTA starts by being cooperative but swiftly retaliates against defection. By initially cooperating, TfTA gives other players opportunities to cooperate and earn higher payoffs themselves. However, once defected upon, TfTA will defect in return, which could lead opponents to reconsider their strategy due to the potential loss of rewards.

Pseudocode:
```
def TitForTatAdaptive(round, history):
  if round == 1:
    action = 'C'
  else:
    cooperators_in_previous_m_rounds = count_cooperators_in_m_previous_rounds(history)
    if cooperators_in_previous_m_rounds >= m:
        action = 'C'
    else:
        action = 'D'
  return action
```
'''

description_EXPLOITATIVE_27 = '''
 Title: Tit-for-Tat with Adaptive K-Factor (TFTA-K) Strategy for Collective Risk Dilemma

1. Specify decision rules:
   - Initially cooperate in the first round (c_i,1 = C). This gesture fosters cooperation and provides an opportunity for others to reciprocate.
   - In subsequent rounds (t > 1), adapt behavior based on opponent's cooperation in the previous round:
     a) If the opponent cooperated (c_j,t-1 = C), cooperate as well (c_i,t = C). This encourages continued cooperation and rewards good behavior.
     b) If the opponent did not cooperate (c_j,t-1 = D), defect in the current round (c_i,t = D). This punishes uncooperative opponents and deters future defections.

2. Handle edge cases:
   - Last round: Since the objective is to be exploitative, always defect in the last round (c_i,r = D) regardless of previous actions, as there will be no further interactions.
   - First round: As mentioned before, cooperate initially (c_i,1 = C).
   - No cooperation threshold met: If m players never cooperate, TFTA-K will eventually defect since it punishes uncooperative opponents (after the first round).

3. Be exploitative:
   - The strategy initially fosters cooperation but quickly adapts to punish non-cooperative opponents by defecting. This approach allows TFTA-K to maximize payoffs when facing various opponent behaviors, while maintaining a potential for higher returns if opponents reciprocate cooperation.
   - By defecting in the last round, TFTA-K ensures that it does not over-reward other players who may be cooperating only because of the repeated interactions. This exploitative behavior prevents others from gaining an unfair advantage in the long run.

Pseudocode:

```python
def tit_for_tat_with_adaptive_k_factor(r, m, k, round):
  if round == 1:
    cooperate = True  # initial cooperation
  else:
    cooperate = previous_opponent_action  # based on opponent's action in the previous round

  if number_of_cooperators < m or not cooperate:  # punishment for non-cooperation
    payoff = 1 - cooperate
  else:
    payoff = 1 - cooperate + k  # reward for averted risk

  if round == r:
    cooperate = False  # defect in the last round

  return payoff, cooperate
```
'''

description_EXPLOITATIVE_28 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate to show goodwill and trustworthiness, as other players may also start cooperatively.
   - For subsequent rounds, adapt the cooperation based on the number of cooperators in the previous round.
       - If m or more players cooperated in the previous round, cooperate in the current round (reward averted risk).
       - If less than m players cooperated in the previous round, defect in the current round (punish uncooperative behavior).

2. Handle edge cases:
   - In the last round, if there is a chance to gain additional rewards by cooperating and the total payoff over all rounds is not yet maximized, cooperate.
   - In the first round, cooperate as mentioned earlier. However, if it becomes apparent that the other players are consistently uncooperative (e.g., three consecutive rounds without m or more players cooperating), start defecting to avoid continued losses.

3. Be exploitative:
   - Mimic cooperation when other players cooperate, but punish those who do not cooperate by defecting. This strategy aims to encourage cooperation while also capitalizing on the mistakes of uncooperative opponents.

Pseudocode for TFTAT:
```
function TFTAT(n, m, k, r):
  rounds = []        # Initialize empty array to store payoffs over rounds
  cooperate_count = m # Set cooperation threshold
  current_round = 1  # Start from the first round

  while current_round <= r:   # Run for the specified number of rounds
    if current_round == 1:    # First round
      action = COOPERATE    # Cooperate initially to show goodwill
    else:                     # Subsequent rounds
      if cooperators_in_previous_round() >= cooperate_count:
        action = COOPERATE   # Reward averted risk
      else:
        action = DEFECT      # Punish uncooperative behavior

    payoff = calculate_payoff(action)
    rounds.append(payoff)    # Store the payoff for this round

    current_round += 1       # Move to the next round

  total_payoff = sum(rounds) # Calculate the total payoff over all rounds

function calculate_payoff(action):
  if action == COOPERATE:
    if cooperators() < m:      # Fewer than m players cooperate
      return 1 - action_self   # Receive no reward and lose own endowment
    else:                       # M or more players cooperate
      return 1 + action_self * k     # Receive the reward of averted risk

function cooperators():
  # Count the number of cooperators in the current round

function cooperators_in_previous_round():
  # Count the number of cooperators in the previous round
```
'''

description_EXPLOITATIVE_29 = '''
 Strategy Name: Tit-for-Tat Adaptive (TfT-A)

1. Specify decision rules:
   - In each round i, if the number of cooperators in the previous round (t-1) is less than m, TfT-A will defect (D). This ensures that when cooperation is not beneficial for the majority, TfT-A exploits the situation.
   - If the number of cooperators in the previous round (t-1) is equal to or greater than m, TfT-A will cooperate (C). This rewards cooperation when it is beneficial for all.

2. Handle edge cases:
   - In the first round, TfT-A will cooperate as there's no prior information to base a decision on.
   - In the last round, TfT-A will follow the same logic as in regular rounds.

3. Be exploitative:
   - By following a simple rule of cooperation when others cooperate and defecting when they do not, TfT-A capitalizes on opportunities for cooperation while avoiding being exploited. However, it's important to note that TfT-A is not strictly exploitative in the sense of always defecting or always cooperating, but rather adapts its behavior based on the actions of others.

Pseudocode:
```python
def TitForTatAdaptive(round_number, num_players, min_cooperators, k, history):
    if round_number == 1:
        action = 'C' # Cooperate in the first round
    else:
        num_cooperators_prev_round = len(history[round_number - 2])
        if num_cooperators_prev_round < min_players:
            action = 'D' # Defect when cooperation is not beneficial for the majority
        elif num_cooperators_prev_round >= min_players:
            action = 'C' # Cooperate when cooperation is beneficial for all
    return action
```
'''

description_EXPLOITATIVE_30 = '''
 Strategy Name: Tit-for-Tat (with adjustments for Collective Risk Dilemma)

1. Specify decision rules:
   - In each round, the AI starts by cooperating (C). This is a sign of good faith and aligns with the exploitative mindset as it encourages cooperation from other players initially.
   - If in the current round, less than m players cooperate, the AI switches to defecting (D) for the remainder of that round and all future rounds. This punishes non-cooperative behavior by reducing the collective benefit and potentially discouraging defection in subsequent rounds.
   - If in the current round, exactly m or more players cooperate, the AI continues to cooperate in the following rounds as a reward for risk aversion shown by other players. However, if there's a drop below m-1 cooperators in any future round, the AI switches back to defecting. This encourages other players to maintain cooperation and punishes those who might be tempted to free-ride on their initial good behavior.

2. Handle edge cases:
   - In the first round, the AI starts by cooperating regardless of the number of cooperators, as part of its initial good faith move.
   - In the last round, the AI continues following the decision rules based on the current and future rounds' cooperation counts. If the minimum number of cooperators (m) is not met in the penultimate round, the AI defects in the final round to ensure a higher payoff.
   - In case of ties (exactly m players cooperate), the AI continues cooperating, as it can still gain from the reward factor (k).

Pseudocode:

```
function play_game(n, m, k, r, history):
  cooperation_count = m - 1 # starts with one less than minimum cooperators to encourage others to cooperate
  for round in range(1, r+1):
    if round == 1: # first round
      action = C # cooperate as a goodwill gesture
    else:
      if cooperation_count < m: # switch to defecting if the minimum has not been met
        action = D
      elif cooperation_count >= m and cooperation_count <= m-1: # continue defecting if below m-1 in the future rounds
        action = D
      else: # cooperate if m or more have cooperated or when tied
        action = C
    cooperation_count += sum(history[round].cooperators) - cooperation_count # update cooperation count based on current round's actions
    payoff = calculate_payoff(n, m, k, action, cooperation_count)
    history.append({round: action, cooperators: cooperation_count})
  total_payoff = sum(history[i].payoff for i in range(1, r+1)) # calculate total payoff over rounds
  return total_payoff
```
'''

description_EXPLOITATIVE_31 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Initially cooperate (C) in the first round to demonstrate goodwill and encourage potential cooperation from others.
   - In subsequent rounds, observe the percentage of players who have cooperated (P_c) in the previous round. If P_c >= m/n, then cooperate; otherwise defect.
   - If P_c < m/n and a player has not cooperated for consecutive s rounds, set a temporary cooperation penalty by increasing the required percentage of players to cooperate from (m/n) to (m/n + s/(r-s)). This encourages the non-cooperative player to adjust their behavior towards cooperation.
   - If P_c >= m/n and a player has been consistently cooperative for consecutive t rounds, set a temporary cooperation bonus by decreasing the required percentage of players to cooperate from (m/n) to (m/n - t/(r-t)). This rewards the cooperative player for their behavior.
   - Maintain an opponent history log with a capacity of h to remember past cooperative and non-cooperative behaviors. When evaluating P_c, give more weight to recent behaviors by considering the number of cooperations in the last w rounds relative to the total number of rounds (w < r).

2. Handle edge cases:
   - In the first round, cooperate (C) to start off positively.
   - If an opponent has not played any rounds yet, treat them as a non-cooperative player until they make their first move.
   - In the last round, defect (D) regardless of the previous cooperation percentage because the game ends and there is no opportunity for future retaliation or reward.

3. Be exploitative:
   - The strategy aims to encourage cooperative behavior by initially showing goodwill, but it also punishes non-cooperative players through the temporary cooperation penalty. This encourages opponents to switch their strategies towards cooperation. However, if an opponent continues to be non-cooperative despite the penalties, TFT-ACT will adapt its cooperation threshold accordingly.
   - The strategy rewards cooperative players by temporarily reducing the cooperation threshold, which in turn incentivizes them to continue cooperating. This helps maintain a cooperative environment among opponents who have already demonstrated cooperative behavior.
'''

description_EXPLOITATIVE_32 = '''
 Strategy Name: Tit-for-Tat with Variable Adaptation (TfTVA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to initiate a potential cooperation opportunity.
   - If an opponent cooperated in the previous round, cooperate in the current round.
   - If an opponent defected in the previous round and the number of cooperators (excluding yourself) in the previous round was less than m, defect in the current round. This is a punitive measure to discourage defection when cooperation threshold isn't met.
   - If an opponent defected in the previous round and the number of cooperators in the previous round was equal to or greater than m, cooperate in the current round to maintain the opportunity for future cooperation.
   - If no previous round exists (first round), always cooperate.

Pseudocode:
```python
def TfTVA(previous_round, opponents_cooperators):
    if current_round == 1:
        action = 'C'  # Cooperate in the first round
    elif previous_action == 'C':
        action = 'C'  # Mimic opponent's cooperation from the previous round
    elif previous_action == 'D' and opponents_cooperators < m:
        action = 'D'  # Punish defection when cooperation threshold isn't met
    elif previous_action == 'D' and opponents_cooperators >= m:
        action = 'C'  # Continue cooperation even after opponent defected when cooperation threshold was met
    else:
        action = '?'  # Unknown or unexpected situation, default to unknown action

    return action
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, cooperate regardless of previous actions since there are no future rounds.
   - If the current round is not the first or last round, use TfTVA decision rules to determine the action.

3. Be exploitative - Clearly align with the exploitative mindset
   - The strategy is exploitative by punishing defection when cooperation threshold isn't met (less than m cooperators). This encourages other players to cooperate more often in order to earn higher payoffs, but it also ensures that if they defect too frequently, the TfTVA player will not continue to be exploited.
   - The strategy is less cooperative when facing opponents who consistently fail to meet the cooperation threshold (defecting often). This allows the TfTVA player to maximize its own payoff in situations where cooperation seems unlikely.
'''

description_EXPLOITATIVE_33 = '''
 Strategy Name: Tit-for-Tat Adaptive (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate to signal trust and encourage cooperation from other players.
   - For subsequent rounds, mirror the opponent's action from the previous round. If they cooperated in the last round, cooperate; if they defected, also defect. This strategy promotes cooperation when it is beneficial for both parties while also retaliating against defection to maintain individual interests.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as a gesture of goodwill and to encourage others to do so.
   - In the last round, mirror the opponent's action from the previous round to maximize immediate payoff based on their actions throughout the game.
   - If the game is not the first or last round, follow the TfTA decision rule as described above.

3. Be exploitative - Clearly align with the exploitative mindset
   - While primarily focused on cooperation, the strategy also retaliates against defection, which can be seen as an exploitative approach to ensure a better payoff in case of uncooperative opponents. By mimicking other players' actions, TfTA can take advantage of cooperators while also discouraging defectors from continuing their non-cooperative behavior due to the risk of retaliation.
   - If an opponent consistently defects, TfTA will continue to do so as well, denying them any potential rewards for cooperation and potentially leading them to adopt a more cooperative strategy over time.

Pseudocode:

```python
def TitForTatAdaptive(opponent_history, n, m, k, r):
    strategy = ['C']  # Initialize with cooperation in the first round

    for i in range(1, r + 1):
        if i == 1:  # First round
            pass
        elif i == r:  # Last round
            strategy[i] = strategy[-1]  # Copy last round's opponent action
        else:
            strategy[i] = strategy[-1]  # Mirror opponent's action from previous round

        if len(strategy) < m or sum(strategy[:m]) < m:  # Check if cooperators threshold met
            payoff = 1 - strategy[i][0]  # Payoff for individual defecting
        else:
            payoff = 1 + k - strategy[i][0]  # Reward for risk averted by cooperation

    return payoff_sum(payoff, r)  # Calculate total payoff over all rounds
```
'''

description_EXPLOITATIVE_34 = '''
 In this Collective Risk Dilemma game, we'll develop a simple yet effective exploitative strategy that takes advantage of other players while still performing reasonably well when others cooperate. This strategy is called Tit-for-Tat with a twist (TFTw).

1. Decision rules:
   - Cooperate in the first round as a goodwill gesture (C,1)
   - In subsequent rounds, observe and mimic other players' actions from the previous round. If most players cooperated, continue cooperating; otherwise, defect (C, t) ↔ (D, t), where the majority rule is defined as follows:
     - If the number of cooperators in round t-1 is greater than or equal to m, cooperate in round t.
     - Otherwise, defect in round t.

2. Handling edge cases:
   - In the last round, defect regardless of other players' actions (D, r) as there are no future interactions to consider.

3. Being exploitative:
   - The TFTw strategy is designed to be cooperative by default but will quickly retaliate against defection by following the same action as the previous round. This allows it to maintain a relatively high payoff while punishing players who choose to defect. However, when most players are cooperating, the strategy will also follow suit, making it less exploitative in those situations.

Pseudocode:
```python
def TFTw(round, other_players):
  if round == 1:
    return 'C'  # Cooperate in the first round
  else:
    cooperators = sum(other_players)
    if cooperators >= m:
      return 'C'  # Cooperate if majority of players cooperated in the previous round
    else:
      return 'D'  # Defect if the majority of players defected in the previous round

# Last round, always defect regardless of other players' actions
def last_round(round):
  return 'D' if round == r else 'C'
```
'''

description_EXPLOITATIVE_35 = '''
 Strategy Name: Tit-for-Tat Plus (TfT+)

1. Specify decision rules:
   - Initially cooperate (first round) to foster cooperation and avoid appearing too aggressive.
   - In subsequent rounds, if a player has cooperated in the previous round, also cooperate. This encourages reciprocal behavior and maintains long-term relationships.
   - If a player has defected in the previous round, also defect for retaliation to punish the opponent for their selfish behavior. However, after two consecutive defections from an opponent, revert back to cooperation as a signal of willingness to mend the relationship.

Pseudocode:
```python
def TfT_plus(round, opponent_history):
    if round == 1:
        action = 'C'  # Cooperate in the first round
    elif len(opponent_history) < 2:
        action = opponent_history[-1]  # Use previous action as a guide for current action
    else:
        if opponent_history[-2] == 'C':  # If opponent cooperated last time, cooperate this time
            action = 'C'
        elif opponent_history[-2] == 'D' and opponent_history[-1] == 'D':  # If two consecutive defections from an opponent, cooperate to signal a reset
            action = 'C'
        else:  # Else, defect to punish the opponent for their selfish behavior
            action = 'D'
    return action
```

2. Handle edge cases:
   - In the last round, no additional strategy is needed because the game ends after r rounds, and the payoff for each player is calculated independently over all rounds.
   - If the opponent history length is less than 2 in a round, use the most recent action from the opponent as a guide for current action. This allows for proper handling of short opponent histories while still following the TfT+ strategy.

3. Be exploitative:
   - The TfT+ strategy is inherently exploitative due to its retaliatory nature when faced with defecting opponents. By punishing selfish behavior, it encourages cooperation from the opponent or causes them to earn lower payoffs if they continue to defect.
   - However, it also fosters long-term relationships by cooperating after an opponent's cooperation and after two consecutive defections, promoting reciprocity and exploiting opponents who are willing to form cooperative relationships in the long term. This creates a balance between being exploitative while also having the ability to benefit from cooperation when possible.
'''

description_EXPLOITATIVE_36 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfTA)

1. Specify decision rules:
   - Initial Round: Cooperate (C), to demonstrate goodwill and encourage potential cooperators.
   - Subsequent Rounds:
     - If opponent cooperated in the previous round, cooperate (C). This mimics reciprocity, rewarding those who cooperate and encouraging future cooperation.
     - If opponent defected in the previous round, defect (D) to punish non-cooperation and increase the chances of forcing a change in their behavior for future rounds.
   - Adaptation: Introduce a small probability p (0 < p < 1) of switching strategies after a certain number l (integer, l > r/2) of consecutive defections from the opponent. This allows the strategy to adapt and potentially escape from prolonged cycles of non-cooperative play.

2. Handle edge cases:
   - Last Round: Regardless of the opponent's previous action, cooperate (C) to maximize potential rewards for this round, assuming the opponent is also aware that it's the last round.
   - First Round and l rounds after a switch in strategy (l defined above): Cooperate (C) if the opponent has previously been cooperative; otherwise, defect (D). This ensures that TfTA maintains its exploitative nature while minimizing the impact of potential missteps in early rounds or after adapting strategies.

Pseudocode:

```python
def tit_for_tat_with_adaptation(n, m, k, r, p, l):
    strategy = 'cooperate'  # Initial strategy is cooperative
    current_round = 0
    opponent_history = []

    while current_round < r:
        if current_round == 1 or (current_round - l) % (r-l) == 0 and random.random() > p:
            strategy = 'switch' if strategy == 'cooperate' else 'cooperate'

        if strategy == 'cooperate':
            action = 'C'
            opponent_history.append('C')
        elif strategy == 'defect':
            action = 'D'
            opponent_history.append('D')

        payoff = calculate_payoff(n, m, k, action, opponent_history)
        current_round += 1

    return total_payoff(payoff)
```
'''

description_EXPLOITATIVE_37 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, player TfTA decides to cooperate or defect based on the number of cooperators in the previous round t-1 and a cooperation threshold (cth). Initially, set cth = m, but it will adapt dynamically.

- If c(t-1) >= cth: Cooperate (C)
- Else if c(t-1) < cth - delta and TfTA defected last round (D in t-1): Cooperate (C)
- Otherwise Defect (D)

Where δ is a small, adjustable parameter that determines how much deviation from the cooperation threshold is acceptable before considering a response.

2. Handle edge cases - What do you do in the first round and last round?

In the first round, TfTA cooperates, as there's no previous history to base decisions on. In the last round, TfTA does the same as it would have done based on the previous round's cooperators count.

3. Be exploitative - Clearly align with the exploitative mindset

TfTA is designed to be exploitative by adapting its cooperation threshold (cth) over time. If other players consistently defect, cth will decrease, making it easier for TfTA to defect and profit from their actions. Conversely, if cooperators are consistently rewarded, cth will increase, making TfTA more likely to cooperate and take advantage of their cooperation.

Pseudocode:
```
def tit_for_tat_adaptive(round, coop_count, delta, cth, history):
  if round == 1:
    return "C" # Cooperate in the first round

  if TfTA_action[round-1] == "D": # If TfTA defected last round
    if coop_count < cth - delta: # and current cooperation count is below threshold minus delta
      return "C" # Cooperate this round

  if coop_count >= cth: # If the number of cooperators in the previous round is equal to or greater than the current cooperation threshold
    return "C" # Cooperate this round

  return "D" # Otherwise, defect this round

def update_cth(round, coop_count):
  if coop_count >= m: # If the number of cooperators exceeded the minimum required (m) in the previous round
    cth += delta/2 # Increase cooperation threshold slightly
  elif coop_count < (m - delta): # If the number of cooperators was significantly below the minimum required in the previous round
    cth -= delta/2 # Decrease cooperation threshold slightly
  return cth

def tit_for_tat_adaptive_game(rounds, players, k, m, delta):
  TfTA = {} # Initialize empty dictionary to store player's TfTA strategy history

  for i in range(1, n+1):
    TfTA[i] = [] # Initialize list to store history for each player

  while round < rounds + 1:
    coop_count = sum([1 for action in TfTA if action[-1] == "C"]) # Calculate cooperation count
    for i in range(1, n+1):
      TfTA[i].append(tit_for_tat_adaptive(round, coop_count, delta, cth, TfTA))
      cth = update_cth(round, coop_count) # Update cooperation threshold based on current round's cooperation count
    round += 1

  # Calculate total payoffs for each player over all rounds
```

This Tit-for-Tat-Adaptive strategy combines the well-known "Tit for Tat" strategy with a dynamic cooperation threshold that allows it to adapt to different opponent behaviors and be exploitative in nature.
'''

description_EXPLOITATIVE_38 = '''
 Strategy Name: Tit-for-Tat Plus Adaptive Cooperation (TfT+)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round i, player uses TfT+ strategy:

- Initially, play C in the first round to encourage cooperation (first move advantage).
- For subsequent rounds t (t > 1), evaluate the average number of cooperators across the previous r-1 rounds (averageCooperators_t-1) and compare it with m.

   - If averageCooperators_t-1 < m, defect in round t (D). This is a punishment for non-cooperative behavior.
   - If averageCooperators_t-1 >= m, cooperate in round t (C). This rewards the cooperative behavior observed.

2. Handle edge cases - What do you do in the first round, last round, etc.?

- In the first round, play C as a goodwill gesture and to encourage others to cooperate.
- In the last round, since there are no future interactions, players may want to maximize their immediate payoff. So, if averageCooperators_t-1 >= m, still play C to benefit from k reward; otherwise defect (D) as it does not affect the overall strategy.

3. Be exploitative - Clearly align with the exploitative mindset

TfT+ is an exploitative strategy because it punishes non-cooperative behavior by defecting and only cooperating when it observes cooperation from other players. This encourages cooperation in the short term but can be exploited by opponents who recognize the strategy's response to their actions. The adaptive nature of the strategy makes it robust against various opponent behaviors, as it learns from previous rounds and adjusts its decisions accordingly.

Pseudocode:

```
function TfTPlus(n, m, k, r):
    strategy = []

    # Initialize the strategy with initial cooperation in the first round
    strategy.append(C)

    for t in range(1, r):
        averageCooperators_t-1 = sum(strategy[max(0, t - r):t]) / t

        if averageCooperators_t-1 < m:
            strategy.append(D)
        else:
            strategy.append(C)

    return strategy
```
'''

description_EXPLOITATIVE_39 = '''
 Strategy Name: Tit-for-Tat-with-Adaptation (TfTa)

1. Decision Rules:
   - Initially cooperate in the first round to foster cooperation and avoid immediate exploitation (C in round 1).
   - In subsequent rounds, observe the actions of the opponent from the previous round. If the opponent cooperated, also cooperate in the current round (C if previous action was C, else D). This encourages mutual cooperation while also punishing defection.
   - Implement a forgiveness mechanism: if the opponent defected after a series of cooperative actions by TfTa, forgive them and cooperate again to encourage continued cooperation (after a certain number of consecutive defections, reset the counter and start forgiving again).

2. Handle Edge Cases:
   - If it's the last round, cooperate regardless of the opponent's previous action since there are no more rounds to retaliate or reward future cooperation.
   - In the first few rounds, be more lenient with defections as the game is still establishing a pattern (e.g., forgive after 2-3 consecutive defections).

3. Be Exploitative:
   - Pursue a strategy that maximizes personal gain while maintaining cooperation when beneficial for long-term payoffs. By cooperating when the opponent does, TfTa encourages mutual cooperation while also punishing defection with defection. The forgiveness mechanism allows for some flexibility in handling opponents prone to short-term defections.
   - When the number of players is large and the minimum cooperators required is small, TfTa may be more susceptible to exploitation by defectors. In these cases, it will still perform reasonably well compared to non-adaptive strategies due to its forgiveness mechanism and cooperation in the early stages of the game.

Pseudocode:

```python
def TfTa(opponent_history, n_rounds, m, k):
    history_length = len(opponent_history)
    if history_length == 0:
        action = 'C'  # cooperate in the first round
    else:
        last_opponent_action = opponent_history[-1]
        current_round = opponent_history.index(last_opponent_action) + 1

        if current_round == n_rounds:  # last round, cooperate regardless
            action = 'C'
        elif current_round < m:  # too few players cooperated, defect
            action = 'D'
        elif current_round >= m and last_opponent_action == 'C':  # opponent cooperated, cooperate back
            action = 'C'
        else:  # opponent defected, but forgive if it's not the first instance
            defection_counter = max(defection_counter - 1, 0)
            if defection_counter == forgiveness_limit:
                defection_counter = 1
            action = 'D' if defection_counter > 0 else 'C'
            defection_counter += 1
    return action
```

In the above pseudocode, `forgiveness_limit` determines how many consecutive defections are tolerated before starting to forgive again. The smaller this number is, the more punishing TfTa becomes towards defectors.
'''

description_EXPLOITATIVE_40 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Initially, cooperate in the first round to signal good intentions (C_i,1 = C).
   - In subsequent rounds, cooperate if the number of cooperators in the previous round is greater than or equal to the current cooperation threshold (m' > m). Else, defect (D_i,t = D).
   - Update the cooperation threshold after each round according to the following rule:
     - If the cooperation threshold was previously met and not met in the current round, increase the threshold by 1 (m'_t = min(n, m'_t-1 + 1)).
     - Otherwise, if the previous cooperation threshold was not met and it is met in the current round, decrease the threshold by 1 (m'_t = max(1, m'_t-1 - 1)).
   - The cooperation threshold will eventually converge to a value between m and n as the game progresses.

2. Handle edge cases:
   - In the last round, cooperate if the current cooperation threshold is met (m'_r = m'_r).
   - In the first round, cooperate unconditionally (C_i,1 = C).

3. Be exploitative:
   - The TFT-ACT strategy will initially cooperate to encourage others to do the same but will adaptively raise or lower its cooperation threshold based on opponents' behavior. This allows it to punish defectors by increasing the threshold and potentially excluding them from future collaborations, while still benefiting from the cooperation of other players.
   - The strategy is robust to a wide range of opponent behaviors due to its adaptive nature, which enables it to respond dynamically to different strategies without relying on specific coordination mechanisms or shared norms.
'''

description_EXPLOITATIVE_41 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TFT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
- Initially (first round), cooperate to demonstrate goodwill and encourage cooperation from others.
- In subsequent rounds, cooperate if the opponent cooperated in the previous round. If the opponent defected, also defect in the current round. This mirrors the TFT strategy but with an added twist:
  - If the number of opponents who have defected exceeds a certain threshold (let's call it 'T'), then start cooperating even if the opponent defected in the previous round. The aim is to encourage cooperation among opponents, as demonstrated below in pseudocode:

```python
def TFT_A(opponent_history, m, n, T):
  own_history = [C] # Start with cooperating in the first round
  current_round = len(own_history) - 1

  def Cooperate(): return C
  def Defect(): return D

  if current_round == 0: # First round
    return Cooperate()

  opponent_cooperated = opponent_history[current_round-1] == C
  own_defected_count = sum(own_history[-T:] == D)
  own_cooperated_count = sum(own_history[-T:] == C)

  if opponent_cooperated and (own_defected_count < T or current_round > T): # Cooperate if opponent cooperated in previous round
    return Cooperate()
  else: # Defect otherwise
    return Defect()
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
- The strategy handles the first round by always cooperating to encourage cooperation from opponents.
- In the last round, the strategy behaves based on the opponent's last action, as per the decision rules defined earlier.

3. Be exploitative - Clearly align with the exploitative mindset
- The TFT-A strategy is designed to be adaptive and responsive to the opponents' behavior. It initially cooperates to encourage cooperation but starts defecting when the number of opponents who have defected exceeds a threshold (T). This enables the strategy to take advantage of opponents who consistently defect while still maintaining the potential for cooperation if opponents demonstrate willingness to cooperate.
- If most opponents defect, TFT-A will also start defecting, exploiting their uncooperative behavior. However, if some opponents continue to cooperate despite others defecting, TFT-A may switch back to cooperating to encourage further cooperation from the good actors.
- This adaptive approach allows TFT-A to be both exploitative and responsive to its environment, making it a competitive strategy in a tournament against independent strategies developed by other AI systems.
'''

description_EXPLOITATIVE_42 = '''
 In this Collective Risk Dilemma game, I propose an exploitative strategy named "Maximum Exploitation Strategy" (MES). The MES aims to maximize its own payoff by exploiting other players who cooperate, while minimizing unnecessary cooperation to avoid being exploited by others.

1. Decision rules:
   - Cooperate if the number of players who have cooperated in the previous round exceeds (m-1), as it is likely that the threshold for reward will be met in the current round.
   - Defect otherwise, to prevent others from benefiting from cooperation when the minimum required cooperators have not been reached.

2. Handling edge cases:
   - First round: Since there is no prior information available, MES will defect as a precautionary measure.
   - Last round: If the reward threshold has already been met in previous rounds, MES will cooperate to maximize its payoff. Otherwise, it will defect to prevent being exploited by other players who may cooperate in an attempt to reach the threshold.

3. Being exploitative:
   - MES aims to induce others into cooperating under the assumption that they will also follow exploitative strategies. By defecting when necessary, it encourages others to cooperate more often than needed, creating opportunities for the MES to reap higher rewards from the increased number of cooperators while still defecting when needed.

Pseudocode representation:
```
function max_exploitation_strategy(round, history):
    if round == 1: # First round
        return 'Defect'

    n = len(history)
    cooperators = count_cooperators(history)

    if cooperators >= (m-1): # Enough cooperators in the previous round
        return 'Cooperate'
    else: # Not enough cooperators, defect to discourage cooperation
        return 'Defect'
```
'''

description_EXPLOITATIVE_43 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Decision Rules:
   - In each round, evaluate the proportion of cooperators in the previous r rounds. This running average will determine whether to cooperate or defect.
   - If the proportion of cooperators is greater than or equal to a predefined adaptive threshold (τ), cooperate; otherwise, defect.
   - The adaptive threshold τ starts at a low value and increases slightly after each round where more than m players cooperate. Conversely, it decreases slightly after each round where less than m players cooperate. This gradual adjustment helps maintain cooperation when it's beneficial and withdraw cooperation in response to defections.
   - The strategy will always cooperate in the first round to foster a cooperative atmosphere.

2. Handling Edge Cases:
   - In the last round, no further adjustments are made to the adaptive threshold because the game ends soon after.
   - When the number of players is small (n < 6), the initial adaptive threshold may need to be set higher or lower depending on the specific values of m and k.

3. Exploitative Mindset:
   - TFT-ACT is exploitative in nature because it retaliates against defections by reducing cooperation, but it also rewards cooperation by gradually increasing its own cooperation rate when others cooperate consistently. However, due to the adaptive threshold adjustments, this strategy can avoid being exploited too easily by overly aggressive opponents.

Pseudocode for TFT-ACT:

```python
def TFT_ACT(n, m, k, r, history):
    # Initialize adaptive cooperation threshold
    τ = m / n

    # Loop through rounds
    for round in range(r):
        # Cooperate if the proportion of cooperators in the last r rounds is greater than or equal to τ
        if sum(history[-r:].count(1)) / r >= τ:
            α[round] = 1  # Cooperate
        else:
            α[round] = 0  # Defect

        # Update adaptive threshold based on recent cooperative behavior
        τ += (max(m, round + 1) - max(0, round - r)) / r * (α[round] - τ)

    # Return strategy history of cooperation actions
    return α
```
'''

description_EXPLOITATIVE_44 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules:
   - In each round, evaluate the proportion of cooperators from the previous round (p). If p >= m/n, cooperate; otherwise defect.
   - In the first round, cooperate to initiate potential cooperation and set an initial p=1.
   - In the last round, cooperate if the total number of cooperators in all previous rounds exceeds or equals the minimum threshold (m). If not, defect as there are no more opportunities for reciprocation.

Pseudocode:

```python
def ATFT(round_num, history):
  if round_num == 1:
    return 'C'  # Cooperate in the first round to initiate potential cooperation

  total_cooperation = sum(history[-r:])
  proportion_cooperators = total_cooperation / r

  if proportion_cooperators >= m/n:
    return 'C'  # Cooperate if sufficient number of cooperators in the previous rounds
  else:
    return 'D'  # Defect if insufficient number of cooperators in the previous rounds
```

2. Handle edge cases:
   - In case the number of players (n) is not a multiple of the minimum cooperation threshold (m), round the number of cooperators needed to m%n and adjust the threshold accordingly.
   - If the number of rounds (r) reaches 1, treat it as the first round (as the strategy does not rely on previous rounds' information).

3. Be exploitative:
   - The ATFT strategy is exploitative in that it initially cooperates to encourage other players to do the same but quickly adapts to punish defection by defecting itself when there are insufficient cooperators, leading to a higher payoff for the strategy over time. This makes it less vulnerable to being exploited by selfish players.
   - By evaluating the proportion of cooperators in the previous rounds rather than absolute numbers, the strategy allows for flexibility and can adapt to different playing styles, including oscillations between cooperation and defection observed in some populations.
   - The strategy does not require complex coordination mechanisms or explicit communication with other players, making it more suitable for a tournament setting where strategies must operate independently.
'''

description_EXPLOITATIVE_45 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Specify decision rules:
   - Initial Cooperation (Round 1): TfTA starts by cooperating to establish a peaceful first interaction, setting a potential tone for future cooperation.
   - Maintenance of Relationship (Rounds 2-r-1): In subsequent rounds, TfTA adapts its behavior based on the actions of its opponents from the previous round. If an opponent cooperated in the last round, TfTA will cooperate as well to reward the cooperation and maintain the relationship. Conversely, if an opponent defected in the last round, TfTA will also defect to punish the defection and signal disapproval. This tit-for-tat mechanism promotes mutual cooperation when present but can also quickly retaliate against any form of cheating or exploitation.
   - Final Round (Round r): In the final round, regardless of the opponent's previous actions, TfTA will always defect to maximize its total payoff for the game by obtaining the k reward from aversion of risk.

2. Handle edge cases:
   - First Round: As mentioned earlier, TfTA cooperates in the first round.
   - Last Round (Round r): TfTA switches to defecting strategy in the final round.

3. Be exploitative: TfTA maintains a balance between cooperation and defection by adapting its behavior based on the opponent's previous actions. However, it also ensures that it takes advantage of any opportunities to obtain higher rewards through the k factor when cooperative relationships are broken or never established. Additionally, by always defecting in the final round, TfTA maximizes its total payoff for the game by securing a reward from aversion of risk.
'''

description_EXPLOITATIVE_46 = '''
 Strategy Name: Adaptive Tit-for-Tat with Variable Cooperation Threshold (ATFT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   The ATFT strategy will cooperate if the number of previous cooperators is above a variable threshold, otherwise it will defect. The threshold is dynamically adjusted based on past experiences. Initially, the threshold is set to m (the minimum cooperators needed for reward).

   Pseudocode:
   ```
   function ATFT(history):
       cooperation_threshold = m
       for each round t in {1...r}:
           if number of cooperators in previous t-1 rounds >= cooperation_threshold:
               action = Cooperate
               update_threshold(cooperation_threshold, history)
           else:
               action = Defect
   ```

   The `update_threshold` function adjusts the cooperation threshold based on past success and failure experiences. If a cooperative round results in reward (i.e., more than m players cooperate), then the threshold is increased slightly; if a non-cooperative round leads to no reward, the threshold is decreased slightly. This encourages a balance between cooperation and defection while maintaining adaptability to various opponent behaviors.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, players have no history, so they cooperate following the cooperative nature of the game (when m players cooperate, all receive a reward). In the last round, since there are no subsequent rounds, players defect as it doesn't affect their total payoff anymore.

3. Be exploitative - Clearly align with the exploitative mindset
   The ATFT strategy is exploitative in nature by conditioning cooperation on past cooperative behaviors of other players while punishing non-cooperators. This strategy can potentially take advantage of opponents who may be more altruistic or less adaptive, leading to higher payoffs over time. However, it's also flexible enough to adjust its behavior based on the opponent's actions, which makes it robust against various strategies.

   The ATFT strategy aims to balance cooperation and defection, maximizing rewards while minimizing risks of being taken advantage of by less cooperative opponents. This adaptive approach should perform well in tournaments against independent strategies developed by other AI systems.
'''

description_EXPLOITATIVE_47 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Initialize cooperation threshold 'ct' to the minimum cooperators needed parameter 'm'.
   - In each round, if the number of cooperators in the previous round is greater than or equal to 'ct', cooperate; otherwise, defect.
   - After each cooperation, increment 'ct' by 1, up to a maximum value of 'n'. If players consistently defect after cooperation (a predefined threshold), reset 'ct' to its initial value 'm'.

2. Handle edge cases:
   - In the first round, cooperate since there is no previous history available.
   - In the last round, cooperate if the number of cooperators in the previous round was greater than or equal to 'ct', otherwise defect.

3. Be exploitative:
   - The strategy aims to exploit other players by adopting a cooperative stance as long as cooperation is reciprocated. However, it will quickly retaliate against defection by increasing its cooperation threshold and reducing the likelihood of future cooperation. This behavior makes the strategy more resilient to exploitation and promotes a stable equilibrium when playing against other exploitative strategies.

Pseudocode:
```
def TFT_ACT(n, m, k, r):
    ct = m
    payoff = 0
    for round in range(1, r+1):
        cooperators = number_of_cooperators_in_previous_round(round)
        if cooperators >= ct:
            cooperate()
            payoff += (1 - ct) + k * (cooperators >= m)  # Update payoff based on game structure
            if round > 1 and cooperators < m:  # Adjust cooperation threshold after each defection event
                ct = max(ct - 1, m)
        else:
            defect()
            payoff += 1
    return payoff
```
'''

description_EXPLOITATIVE_48 = '''
 In this Collective Risk Dilemma game, we'll design an exploitative strategy called "Free Rider". The Free Rider strategy aims to maximize personal payoff by defecting whenever possible while adapting to various opponent behaviors and edge cases.

1. Specify decision rules - When exactly do you cooperate vs defect?
- In every round, the strategy will defect (D) if it expects fewer than m players to cooperate in the current round. This behavior is based on the assumption that cooperation only benefits the individual player when a critical number of players (m) decide to cooperate. The strategy exploits this vulnerability by defecting and waiting for others to cooperate.
- If the strategy expects at least m players to cooperate, it will randomly choose between cooperating or defecting with a probability skewed towards defection. This randomization creates an illusion of cooperation, which may encourage other players to cooperate while still maintaining the higher expected payoff from defection. The exact probability of cooperation can be adjusted based on observations of opponent behaviors and historical results.
- To determine the number of expected cooperators in a given round, the strategy will keep track of the average number of cooperators from previous rounds (n_coop). The n_coop value is updated as follows:
  - After each round where at least m players cooperate, increment n_coop by 1/r.
  - After each round where fewer than m players cooperate, decrement n_coop by 1/(r * (n-m+1)).

2. Handle edge cases - What do you do in the first round, last round, etc.?
- In the first round, the strategy will defect due to the lack of historical data to estimate the number of expected cooperators (n_coop = 0).
- In the last round and any round close to the end with a significant n_coop value, the strategy may increase its probability of cooperation to encourage others to cooperate and potentially secure a higher payoff. This decision can be made adaptively based on the remaining number of rounds (r - current_round) and the current n_coop value.
- In cases where n_coop exceeds a certain threshold, the strategy may switch to a more cooperative approach (i.e., favoring cooperation over defection) to maximize its payoff in the long run by maintaining cooperation with other players who have demonstrated consistent cooperation.

3. Be exploitative - Clearly align with the exploitative mindset:
- The Free Rider strategy aims to capitalize on the vulnerability of cooperation in the Collective Risk Dilemma game, taking advantage of other players' tendency to cooperate. By defecting when possible and only cooperating when it appears beneficial for others to do so, the strategy maximizes its payoff while minimizing the potential benefits to other players.
- The adaptive nature of the Free Rider strategy allows it to dynamically respond to various opponent behaviors, ensuring it remains competitive in a tournament setting against strategies developed by other AI systems.
'''

description_EXPLOITATIVE_49 = '''
 Strategy Name: Tit-for-Tat (TFt) with Adaptive Cooperative Threshold (ACt)

1. Specify decision rules:
   - In each round t, cooperate if and only if at least m players cooperated in the previous round (t-1). If less than m players cooperated in the previous round, defect.
   - Introduce an adaptive cooperative threshold (ACt) that adjusts over time based on the average number of cooperators in the recent past (e.g., the last 5 rounds). If the average number of cooperators in these past rounds is greater than m, gradually increase ACt towards m; if it's less than m, decrease ACt towards (m-1). The adjustment should be slow to avoid overreacting to short-term fluctuations.
   - To handle edge cases:
     a) In the first round, cooperate as a gesture of goodwill and trust.
     b) In the last round, play like the average behaviour observed in the previous rounds.

2. Handle edge cases:
   - In the first round, ACt = m (cooperate regardless of past observations).
   - If there are not enough observations to calculate an average (e.g., less than 5 rounds played), use a default value for ACt (e.g., m-1 or an interpolated value between m-1 and m based on the number of available observations).
   - In the last round, calculate the average cooperation from the previous r-1 rounds, and use that as the ACt to determine the action.

3. Be exploitative:
   - The strategy is designed to encourage cooperative behaviour among players while also being resilient against defection. By adjusting the cooperative threshold based on past observations, it can detect and punish short-term deviations from cooperation while still being willing to cooperate when it seems beneficial.
   - If opponents repeatedly defect, the strategy will gradually reduce its own cooperation to match theirs (decreasing ACt towards (m-1)). This allows the strategy to earn similar payoffs as defectors while maintaining the potential for higher rewards if others choose to cooperate.
   - If opponents start cooperating more frequently, the strategy will gradually increase its own cooperation (increasing ACt towards m). This encourages long-term cooperation among players but also punishes defection with a swift response.

Pseudocode:

```python
def play_game(n, r, m, k):
    rounds = []
    cooperative_threshold = m
    past_rounds = [0] * 5

    def decide_action(round, past_coop):
        if past_coop >= m:
            return "C"
        else:
            return "D"

    def adjust_cooperative_threshold():
        avg_coop = sum(past_rounds) / 5
        if avg_coop > m:
            cooperative_threshold += (avg_coop - m) / 10
        elif avg_coop < m:
            cooperative_threshold -= (m - avg_coop) / 10

    for t in range(r):
        if t == 0:
            past_rounds[t] = "C"
            continue

        if len(past_rounds) < 5:
            past_rounds.append(decide_action(t, sum(past_rounds[-5:])))
            continue

        past_coop = sum(past_rounds[-5:])
        action = decide_action(t, past_coop)
        payoff = 1 if action == "D" else (1 + k) if past_coop >= m else 1

        rounds.append((t, action, payoff))
        past_rounds.pop(0); past_rounds.append(action)
        adjust_cooperative_threshold()

    return rounds
```
'''

description_EXPLOITATIVE_50 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate to foster a potential cooperative relationship with other players. This encourages cooperation and aligns with the Tit-for-Tat strategy, which is cooperative but retaliatory if others defect.
   - In subsequent rounds, cooperate if at least m players cooperated in the previous round, and defect otherwise. This helps maintain cooperation when it's beneficial and retaliates against defection to encourage future cooperation.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round (t=1), cooperate as described above.
   - In the last round (t=r), cooperate if at least m players have cooperated throughout the game so far to maximize the total payoff. If not, defect to avoid being taken advantage of in the final round.
   - For intermediate rounds, follow the decision rule as described above.

3. Be exploitative - Clearly align with the exploitative mindset
   - ATfT is exploitative in that it cooperates to encourage others to do the same but retaliates when others defect. This strategy can be seen as exploiting the cooperation of other players while minimizing the own player's losses by defecting when others don't cooperate.
   - The adaptive nature of ATfT makes it resilient against various opponent behaviors, ensuring that it will not get stuck in a cycle of repeated defection or undesirable long-term cooperation patterns.

Pseudocode:
```
function Adaptive_Tit_for_Tat(n, m, k, r):
  payoff = Array(r)   # Initialize an array to store player's payoffs over rounds
  cooperate_count = 0  # Initialize counter for number of players who have cooperated so far

  # First round, always cooperate
  if (round == 1):
    action = "C"

  else:
    # Count the number of cooperators from previous rounds
    for i in range(1, n+1):
      if payoff[round-1][i] == 2:
        cooperate_count += 1

    # Decide whether to cooperate or defect based on the count
    if (cooperate_count >= m):
      action = "C"
    else:
      action = "D"

  # Update payoff for current round and store it
  payoff[round-1] = Array(n)
  for i in range(1, n+1):
    if (action == "C"):
      payoff[round-1][i] = 2
    else:
      payoff[round-1][i] = 1

  # In the last round, cooperate if enough players have cooperated throughout the game
  if (round == r):
    if (cooperate_count >= m * (r - 1)):
      action = "C"

  return action
```
'''

description_EXPLOITATIVE_51 = '''
 Title: Tit-for-Tat-Adaptive Strategy (TFT-A) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially cooperate in the first round (c_i=1, t=1). This gesture of goodwill may encourage cooperation from other players.
   - In subsequent rounds, copy the previous action of the opponent (if c_opp, t-1 = 1, then c_i,t = 1; if c_opp, t-1 = 0, then c_i,t = 0). This rule mimics the "Tit for Tat" strategy in regular Prisoner's Dilemma but accounts for the different payoff structure in Collective Risk Dilemma.
   - If the minimum cooperation threshold (m) is reached during a round, defect in the next round to secure the higher payoff (k reward). This prevents being taken advantage of while still maintaining adaptiveness to opponent behavior.

2. Handle edge cases:
   - In the last round, cooperate if at least m players have cooperated throughout the game; otherwise, defect since there will be no further rounds.

3. Be exploitative:
   - TFT-A is inherently exploitative in that it initially cooperates to encourage cooperation from other players but then follows their actions closely, allowing it to punish non-cooperative behavior (defection) by matching their actions. This strategy aims to create a long-lasting cooperation environment while still achieving a higher payoff when the minimum cooperation threshold is met or when exploiting non-cooperative opponents.
   - By defecting after m players have cooperated, TFT-A secures a larger reward and may even encourage other players to follow suit in future rounds. However, this behavior also allows for quick recovery if the opponent(s) switch back to cooperation as it only requires a minimum number of cooperators (m) to secure the higher payoff again.

Pseudocode:
```
function TFT-A(r, n, m, k, c_opp, t)
  if t == 1 then
    c_i = 1
  else
    if m <= countCooperators(t-1) then
      c_i = 0
    else if c_opp, t-1 == 1 then
      c_i = 1
    else
      c_i = 0
    endif
  endif
endfunction
```
'''

description_EXPLOITATIVE_52 = '''
 Strategy Name: Tit-for-Tat with Adaptive Threshold (TFTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially cooperate in the first round (c_i = 1).
   - For subsequent rounds, observe the percentage of players that cooperated in the previous round and decide whether to cooperate or defect as follows:
     - If more than (m-1) players cooperated in the previous round, cooperate (c_i = 1).
     - Otherwise, if less than or equal to (m-2) players cooperated in the previous round, defect (c_i = 0).
     - If exactly m players cooperated in the previous round, assess the cooperation trend over the last few rounds (e.g., consider the average percentage of cooperators in the last 3 rounds). If this average is greater than a predefined threshold 'T', cooperate (c_i = 1); otherwise, defect (c_i = 0).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, always cooperate (c_i = 1) to show goodwill and encourage cooperation from others.
   - In the last round, if more than m players have cooperated during the game so far, continue cooperating (c_i = 1). Otherwise, defect (c_i = 0) as a punishment for not meeting the minimum cooperation threshold.

3. Be exploitative - Clearly align with the exploitative mindset
   - Exploit other players by cooperating when they do and defecting when they don't, following the specified decision rules.
   - Adapt to the opponents' behavior: if an opponent consistently cooperates, TFTA will continue cooperating; if an opponent repeatedly defects, TFTA will also defect as a form of retaliation. However, if the opponent starts to cooperate after repeatedly defecting, TFTA may begin cooperating again due to its tendency to encourage cooperation and forgive past defections when there is a trend towards cooperation.
   - TFTA's adaptive threshold mechanism helps it adjust to various cooperation trends among players while maintaining an exploitative stance.
'''

description_EXPLOITATIVE_53 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFTA)

1. Specify decision rules:
   - Start by cooperating in the first round (C). This gesture can potentially foster cooperation in subsequent rounds.
   - In every subsequent round, evaluate the previous action of each player and respond accordingly:
     - If a player has cooperated in the previous round, return the favor and also cooperate (C).
     - If a player has defected in the previous round, defect as well (D) to punish them. This ensures that the strategy is exploitative when faced with selfish players.
   - To be more adaptive, introduce a forgiveness mechanism: if a defector switches to cooperating after being punished, immediately forgive and return to cooperation (C).

2. Handle edge cases:
   - In the last round, since there are no subsequent rounds for retaliation or forgiveness, defect (D) to maximize individual payoff regardless of opponent's action in that round.
   - For the first round, cooperate (C).

3. Be exploitative:
   - By initially cooperating and then responding based on opponent's actions, TFTA aims to promote cooperation when players are willing to do so but can also punish opponents who are selfish and defective. This strategy is designed to be exploitative by adapting to different opponent behaviors while maintaining its core decision-making principles.

Pseudocode:
```
function TFTA(round, history):
  if round == 1:
    action = "C" (Cooperate)
  else:
    last_action = history[round - 1]
    if last_action[self] == "C":
      action = "C" (Cooperate)
    elif last_action[self] == "D":
      action = "D" (Defect)

  if round == r:
    action = "D" (Defect)

return action
```
'''

description_EXPLOITATIVE_54 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules:
   - Initially (first round), cooperate to build trust and cooperation opportunities.
   - In subsequent rounds, if the number of cooperators in the previous round is greater than or equal to the minimum cooperation threshold (m), then cooperate. Otherwise, defect.
   - If the number of cooperators has been consistently below the threshold for a predefined number of rounds (t_defect), increase the cooperation threshold slightly by δ.
   - If the number of cooperators exceeds the new cooperation threshold in the next round, reset the cooperation threshold to its original value.

2. Handle edge cases:
   - In the last round, cooperate if the number of cooperators in the previous round was greater than or equal to the minimum cooperation threshold (m). Otherwise, defect.
   - In the first round, cooperate regardless of past actions due to lack of history.

3. Be exploitative:
   - Start cooperative to build trust but quickly adjust the cooperation threshold to punish frequent defections and promote cooperation from opportunistic players.
   - Maintain a balance between cooperation and defection based on observed player behavior, incentivizing opponents to follow the strategy's own cooperative actions.

Pseudocode:

```
Strategy TFTAT(n, m, k, r, t_defect, δ) {
    cooperation_threshold = m
    round = 1
    while (round <= r) {
        if (round == 1) {
            cooperate = true
        } else {
            if (number_of_cooperators > cooperation_threshold) {
                cooperate = true
            } else if (round - t_defect >= r) {
                increment_cooperation_threshold(δ)
            } else {
                cooperate = false
            }
        }

        if (number_of_cooperators > cooperation_threshold && round < r) {
            reset_cooperation_threshold(m)
        }

        play_round(cooperate)
        round++
    }
}

function increment_cooperation_threshold(δ) {
    cooperation_threshold += δ
}

function reset_cooperation_threshold(m) {
    cooperation_threshold = m
}
```
'''

description_EXPLOITATIVE_55 = '''
 Strategy Name: Tit-for-Tat with Modified Grim Trigger (TFTR-MT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initial Cooperation: Start by cooperating in the first round to foster trust and encourage cooperation from other players (C).
   - Main Strategy Loop: In each subsequent round t, observe the collective action of the opponents from round t-m+1 to round t. If at least m players have cooperated in this window, cooperate (C); otherwise defect (D). This ensures that you reciprocate cooperation while also being quick to punish defection.
   - Grim Trigger: If an opponent has ever defected and subsequently returns to cooperation, wait for m consecutive rounds of cooperation from that player before returning the favor (m-1 rounds of cooperation from your end). This discourages repeated defections and encourages long-term cooperation.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First Round: Cooperate to initiate the game positively.
   - Last Round (if r is odd): Use the main strategy loop as described above, since the game still has one more round after this.
   - Last Round (if r is even): Defect, as there are no subsequent rounds for opponents to reciprocate cooperation or be punished for defection.

3. Be exploitative - Clearly align with the exploitative mindset
   - TFTR-MT primarily aims at earning a good payoff by cooperating when it benefits and punishing defection by not cooperating, while also being responsive to changes in opponents' behavior. The Grim Trigger makes sure that the strategy is unforgiving towards repeated defections, deterring other players from exploiting the strategy.
   - By starting with cooperation and using a reciprocal approach, the strategy may appear less exploitative initially, but it will quickly adapt to opponents who attempt to take advantage of the strategy's initial cooperative stance.

Pseudocode:
```
function TFTR-MT(opponents, m, k, r):
  history = [] # Initialize history as an empty list
  payoff = 0

  for round in range(1, r+1):
    if round == 1: # First round, cooperate to start
      action = 'C'
      history.append(action)

    else: # Use the main strategy loop and Grim Trigger
      cooperation_count = count_cooperators(history, m-1)
      if cooperation_count >= m:
        action = 'C'
        payoff += (1 - action) + k
      else:
        action = 'D'
        payoff += (1 - action)
      history.append(action)

      # Grim Trigger: Check for first defection and wait for m rounds of cooperation before returning the favor
      if len(history) >= m and history[-m] == 'D':
        cooperation_count = count_cooperators(history, m-1)
        if cooperation_count >= m:
          action = 'C'
          payoff += (1 - action) + k * (m-1) # Extra reward for long-term cooperation after Grim Trigger

    print("Round:", round, ", Action:", action)
    print("Payoff:", payoff)
```
'''

description_EXPLOITATIVE_56 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to establish trust and goodwill. This initial cooperation might encourage others to reciprocate.
   - After the first round, adopt a Tit-for-Tat strategy: if an opponent cooperated in the previous round, cooperate in the current round; otherwise, defect.
   - To adapt to different player behaviors, implement an exploitation mechanism based on the cooperation ratio (CR) of opponents over a sliding window (w). The CR is defined as the number of times an opponent has cooperated divided by the total number of interactions within the window.
     - If CR ≥ m / n, set a high cooperation threshold to encourage cooperation (i.e., be less exploitative): cooperate more frequently than the Tit-for-Tat strategy suggests.
     - If CR < m / n, set a low cooperation threshold to discourage non-cooperative opponents: defect more frequently than the Tit-for-Tat strategy suggests.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as mentioned before.
   - Last round (and any other edge case): prioritize maximizing total payoff by mimicking an opponent's behavior from the previous round, regardless of CR calculations. This ensures that the strategy does not unnecessarily lose out on potential rewards in the last round due to a temporary shift in opponent behavior.

3. Be exploitative - Clearly align with the exploitative mindset:
   - Exploit cooperative opponents by reciprocating their cooperation, but be less cooperative towards non-cooperative opponents.
   - Adapt the level of cooperation based on the opponent's past behavior to encourage cooperative play or punish defection accordingly.

Pseudocode:

```python
def TFT_ACT(n, m, k, r, w):
    history = [(cooperation, opponent) for round in range(r)]  # store (cooperate, opponent) pairs
    cooperation_threshold = m / n  # set initial threshold based on game parameters

    def get_CR(w):
        return sum([pair[0] for pair in history[-w:] if pair[1] != opponent] ) / w

    def get_strategy():
        CR = get_CR(w)
        return 1 if CR >= cooperation_threshold else 0  # 1 for cooperate, 0 for defect

    for round in range(r):
        if round == 0:  # first round
            strategy = 1  # cooperate to initiate
        else:
            strategy = get_strategy()  # use adaptive strategy based on opponent's past behavior

        opponent_action = opponent_history[round - 1][0]  # get opponent's action from previous round

        if strategy == 1 and opponent_action == 0:  # punish defection
            cooperation_threshold += 0.05  # increase threshold to encourage cooperation

        if strategy == 0 and opponent_action == 1:  # exploit cooperation
            cooperation_threshold -= 0.05  # decrease threshold to discourage cooperation

        payoff = (1 - strategy) if sum(history[-m:]) < m else (1 - strategy) + k
        total_payoff += payoff

        history[round] = (strategy, opponent)

    return total_payoff
```
'''

description_EXPLOITATIVE_57 = '''
 Strategy Name: Tit-for-Tat (with Adaptation)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initial Round (t=1): Start by cooperating (C). This is a friendly gesture to encourage others to cooperate, and it also avoids being the first defector in a game where cooperation is beneficial.
   - Subsequent Rounds (t > 1): If the opponent cooperated in the previous round (t-1), cooperate in the current round (C). If the opponent defected in the previous round, defect in the current round (D). This rule mimics fairness and encourages cooperation while still retaliating against defection.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First Round: Cooperate as mentioned above.
   - Last Round: Analyze the opponent's behavior throughout the game. If they have cooperated more times than defected, cooperate; otherwise, defect. This encourages opponents to maintain cooperation towards the end of the game.
   - Other Edge Cases (e.g., when r is odd or even): The strategy already accounts for these cases due to its structure (i.e., no special handling is needed).

3. Be exploitative - Clearly align with the exploitative mindset
   - Initially, cooperation appears friendly and may encourage others to cooperate. However, the strategy retaliates against defection by defecting in response, which can be seen as a form of exploitation when opponents switch from cooperation to defection.
   - The strategy also does not cooperate with opponents who have repeatedly defected, which could lead to higher payoffs for the Tit-for-Tat agent over time.

Pseudocode:
```
function tit_for_tat(t, opponent_history):
  if t = 1:
    action = 'C' (Cooperate)
  else:
    if opponent_history[t - 1] = 'C':
      action = 'C' (Cooperate)
    else:
      action = 'D' (Defect)
  return action

function last_round(t, r):
  if t = r:
    if count_cooperation(opponent_history) > count_defection(opponent_history):
      return 'C' (Cooperate)
    else:
      return 'D' (Defect)
  else:
    return '' (No action, as it's not the last round)
```
'''

description_EXPLOITATIVE_58 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for Collective Risk Dilemma

1. Specify decision rules:
   - In the first round, cooperate (C), encouraging potential partners to reciprocate cooperation.
   - For subsequent rounds, evaluate the number of cooperators (n_c) in the previous round and adapt as follows:
       - If n_c >= m, cooperate (C). This encourages continued cooperation if the necessary minimum has been met.
       - If n_c < m and you cooperated in the previous round, defect (D) to punish non-cooperators.
       - If n_c < m and you defected in the previous round, repeat your action from the previous round. This approach allows for forgiveness in case of mistaken defection.

2. Handle edge cases:
   - In the last round, cooperate (C), as there are no subsequent rounds to reciprocate punishments.
   - In the first round, always cooperate (C) as stated earlier.

3. Be exploitative:
   - The strategy is designed to exploit opponents who do not cooperate by punishing them in response to their defection. Simultaneously, it encourages cooperation from potential partners by reciprocating their cooperation and forgiving occasional defections. This creates a delicate balance that can lead to stable, high-payoff outcomes when many players adopt the strategy.
   - However, due to its tit-for-tat nature, the strategy may also be exploited by opponents who consistently defect while taking advantage of its cooperative nature. In such cases, ATfT will suffer reduced payoffs, but it still maintains an adaptive and robust approach.

Pseudocode:
```python
def AdaptiveTitForTat(round, history):
  if round == 1:
    action = 'C'  # Cooperate in the first round

  else:
    n_c = count_cooperators(history)
    if n_c >= m:
      action = 'C'  # Cooperate if the minimum number of cooperators was met
    elif history[-1] == 'D' and my_action[-1] == 'C':
      action = 'D'  # Punish non-cooperators who have taken advantage in the past
    elif history[-1] == 'D' and my_action[-1] == 'D':
      action = 'D'  # Repeat the previous action (defect) when both players defected
    else:
      action = 'C'  # Cooperate to encourage continued cooperation

  return action
```
'''

description_EXPLOITATIVE_59 = '''
 Strategy Name: Adaptive Tit-for-Tat with Deterrence (ATFD)

1. Specify decision rules - When exactly do you cooperate vs defect?
   The ATFD strategy follows a simple tit-for-tat approach, where cooperation is the default action, but defection is introduced as a response to opposition. However, it also includes a deterrence mechanism to discourage early defections.

   Pseudocode:
   ```
   function ATFD(round, history):
       if round = 1 then
           cooperate = True
       else
           cooperate = last_round_cooperation_of_opponent and (history_cooperative_ratio > average_cooperative_ratio)
   ```
   In this pseudocode, `history` contains the history of cooperation from the opponent. The `history_cooperative_ratio` is the ratio of cooperative actions in the opponent's history so far. `average_cooperative_ratio` is a variable that keeps track of the average cooperative ratio seen over all opponents during the game.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   Since this strategy depends on the opponent's history, it only makes decisions based on the available information at each round. In the first round, as stated earlier, cooperation is assumed by default. If the game continues beyond the initial round, the strategy will evaluate the cooperative ratio of the opponent to decide whether to cooperate or defect.

3. Be exploitative - Clearly align with the exploitative mindset
   The ATFD strategy is designed to exploit opponents who are not cooperating while maintaining cooperation when it seems beneficial (i.e., when enough other players are cooperating). By responding in kind to cooperative opponents, it maintains the potential for future cooperation, but if an opponent defects, it will also defect in response. This can encourage opponents to cooperate more, as they stand to gain from doing so and risk losing out by not cooperating. The deterrence mechanism introduced with the last_round_cooperation_of_opponent check discourages early defections, making it less attractive for opponents to try exploiting the strategy right away.
'''

description_EXPLOITATIVE_60 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfTA)

1. Specify decision rules:
   - Initially (in the first round), cooperate (C). This is a gesture of goodwill and minimizes immediate loss in case opponents also cooperate.
   - In subsequent rounds, mimic the opponent's action from the previous round (i.e., if the opponent cooperated in the last round, also cooperate; if the opponent defected, also defect). This strategy encourages reciprocity and builds trust with cooperative opponents while punishing defection.
   - If a majority of players (m or more) have consistently cooperated for a predefined number of rounds (t), adjust the threshold to require cooperation from a higher percentage (m' > m) of players for the next t rounds. This reward increases the likelihood that opponents will maintain cooperation, as they are now receiving a greater payoff.
   - If a majority of players have consistently defected for a predefined number of rounds, adjust the threshold to require defection from a higher percentage (m' < m) of players for the next t rounds. This punishment decreases the likelihood that opponents will continue to defect, as they risk being met with cooperation and lower payoffs.
   - If the strategy encounters an opponent who consistently cooperates without adjusting their strategy, gradually decrease the threshold required for cooperation back towards the initial value (m) over time. This allows for the formation of long-term cooperative relationships when it is beneficial.

2. Handle edge cases:
   - In the last round, defect (D), as there are no more rounds to punish or reward opponents based on their actions.
   - If a majority of players have consistently cooperated or defected for the entire game so far, continue with the current threshold (m') for the remaining rounds.
   - If the strategy encounters an opponent who does not follow any discernible pattern, maintain the current threshold (m') and monitor their actions for changes that may signal a shift in strategy. Respond accordingly by adjusting the threshold as needed.

3. Be exploitative:
   - By maintaining reciprocity and adjusting cooperation thresholds based on opponent behavior, this strategy encourages cooperation when it is beneficial (i.e., when a majority of players are cooperating) while punishing defection with continued defection. This minimizes immediate payoff loss from being exploited and encourages opponents to adopt more cooperative strategies over time.
   - By adjusting the threshold required for cooperation based on the current state of play, this strategy can respond effectively to a wide range of opponent behaviors, making it difficult for opponents to consistently exploit the strategy.

Pseudocode:

```python
def TfTA(n, m, k, r, t=10):
    threshold = m
    cooperation_history = []
    defection_history = []

    def play_round(opponent_action):
        if len(cooperation_history) < t:
            return 'C'  # Cooperate initially

        if opponent_action == 'C':
            cooperation_history.append(True)
            defection_history.clear()
            threshold = min(max(threshold * 0.8, m), n - 1)  # Reward cooperation
        else:
            cooperation_history.append(False)
            defection_history.append(opponent_action)
            if len(defection_history) >= t:
                threshold = max(min(threshold * 1.2, n - 1), m + 1)  # Punish defection

        return 'C' if cooperation_history.count(True) >= threshold else 'D'  # Decide whether to cooperate or defect

    for round in range(r):
        opponent_action = play_round(opponent_action)  # Play the round and update history
        payoff = (1 - (1 if opponent_action == 'D' else 0)) + k * cooperation_history.count(True)  # Calculate payoff
        print(f"Round {round+1}: Payoff = {payoff}")

TfTA(n=6, m=3, k=2, r=100)
```
'''

description_EXPLOITATIVE_61 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Initially cooperate (C) in the first round to demonstrate trust and cooperation. This encourages opponents to reciprocate.
   - In subsequent rounds, follow the opponent's action from the previous round. If the opponent cooperated, also cooperate; if the opponent defected, defect as well.
   - Introduce an adaptive cooperation threshold (m_i) for each player i, which adjusts based on the number of cooperative opponents in recent rounds. Initially set m_i = m.
   - If the number of cooperators in the last r_t rounds is greater than or equal to m_i, increment m_i by 1 (m_i += 1). If the number of cooperators in the last r_t rounds is less than m_i, decrement m_i by 1 (m_i -= 1). This makes the strategy more cooperative when cooperation is rewarded and less cooperative when it isn't.
   - If m_i < m, set m_i = m to prevent a decrease below the minimum cooperators needed.

2. Handle edge cases:
   - In the last round, regardless of the opponent's action in the previous round, always defect (D) since there are no more rounds for reciprocation.
   - In the first round, cooperate (C). This is also the initial state for m_i.

3. Be exploitative:
   - By initially cooperating and adapting the cooperation threshold based on recent observations, TFT-ACT takes advantage of opponents who are initially cooperative but fail to reciprocate. The strategy responds with defection when it encounters such behavior, while still being open to cooperation if the opponent changes their tactics.
   - By gradually adjusting the cooperation threshold, the strategy becomes more exploitative when faced with a higher proportion of defectors and more cooperative when encountering a higher proportion of cooperators. This allows TFT-ACT to adapt to various opponent behaviors effectively.

Pseudocode:

```
Strategy TFT-ACT(n, m, k, r):
  initialize m_i = m for all players i
  initialize r_t = r

  function playRound(i, opponent_action):
    if round == 1:
      action = C
    elif round == r:
      action = D
    else:
      action = opponent_action

    if action == C and number_cooperators > m_i:
      m_i += 1
    elif action == D and number_cooperators < m_i:
      m_i -= 1

    return action

  for round in range(1, r+1):
    player_actions = []
    for i in range(n):
      opponent_action = player_actions[i-1] if len(player_actions) > 0 else C
      player_actions.append(playRound(i, opponent_action))
```
'''

description_EXPLOITATIVE_62 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - In the first round, cooperate to show good faith and encourage others to do the same. (C in round 1)
   - For subsequent rounds, adopt a Tit-for-Tat approach by cooperating if the majority of players cooperated in the previous round, and defect otherwise. (If more than (n-m)/2 players cooperated last round, C, else D)
   - To be adaptive, adjust the cooperation threshold based on the historical average number of cooperators over the past 'a' rounds (adaptive parameter). If the average number of cooperators is greater than m, increment the cooperation threshold. Conversely, if it's less than m, decrement the cooperation threshold.

Pseudocode:
```
def TFT_ACT(n, m, k, a):
    cooperation_threshold = (n+m)/2  # Initial threshold to encourage cooperation
    past_average = calculate_past_average(a)  # Calculate the average number of cooperators over the last 'a' rounds

    for round in range(1, r+1):
        if round == 1:  # First round, cooperate to show good faith
            action = 'C'
        else:
            if past_cooperators >= cooperation_threshold:  # Majority cooperated last round, cooperate this round
                action = 'C'
            else:  # Defect
                action = 'D'

        if round < a:  # Update the past average for future decisions
            update_past_average(action)

        calculate_reward(action, round)  # Calculate payoff for this round
```

2. Handle edge cases:
   - In the last round, defect since it's a one-time decision and there are no further rounds to retaliate or cooperate.
   - If an opponent doesn't follow Tit-for-Tat (i.e., they don't reciprocate cooperation), adapt by incrementing the cooperation threshold to encourage them to cooperate, but also consider reducing it if they persistently defect.

3. Be exploitative:
   - While TFT-ACT encourages cooperation, its adaptation mechanism allows it to retaliate against opponents who do not reciprocate and take advantage of them by reducing cooperation in the future, thus achieving an exploitative edge when necessary. However, it maintains a cooperative stance as much as possible to benefit from potential cooperation among opponents.
'''

description_EXPLOITATIVE_63 = '''
 Title: Tit-for-Tat Strategy (TFTS) for Collective Risk Dilemma

1. Specify decision rules:
   - Initiate cooperation (C) in the first round to promote a cooperative environment.
   - In subsequent rounds, if the number of cooperators (n_c) in the previous round is greater than or equal to the minimum required number (m), then cooperate (C). Otherwise, defect (D).
   - If an opponent defects after cooperating, cooperate again in the next round to maintain a cooperative environment. However, if the opponent continues to defect after being let down once, respond with defection in the following rounds. This punishes opponents who exploit cooperation but offers forgiveness for occasional mistakes.

Pseudocode:
```python
def tit_for_tat(round, history):
  if round == 1:
    return 'C' # Cooperate in the first round to initiate cooperation

  n_c = count_cooperators(history)
  if n_c >= m:
    return 'C' # Cooperate if enough players cooperated in the previous round
  else:
    return 'D' # Defect if not enough players cooperated in the previous round

def get_response(opponent_action):
  if opponent_action == 'C':
    return tit_for_tat(current_round, history)
  elif opponent_action == 'D' and was_last_cooperation(history):
    return 'C' # Forgive opponents who exploit cooperation once
  else:
    return 'D' # Respond with defection to punish repeated exploitation
```

2. Handle edge cases:
   - In the last round, there is no need for retaliation or forgiveness since the game ends soon after. Cooperate (C) in the final round regardless of previous actions.
   - If an opponent deviates from cooperation on the first round, respond with defection to set a strong initial signal against exploitation.

3. Be exploitative:
   - The strategy is exploitative by responding with defection when opponents fail to cooperate, as well as punishing repeated exploitation through retaliation. However, it also provides opportunities for cooperation and forgiveness in certain situations to promote a more collaborative environment when beneficial.
'''

description_EXPLOITATIVE_64 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules:
   - In each round i (i ≥ 2), cooperate (C) if and only if at least m players cooperated in the previous round (i-1). This maintains a history of cooperation when others also cooperate, and retaliates against defection by defecting in response.
   - In the first round (i = 1), cooperate to start fresh and encourage cooperative behavior from other players.
   - In the last round (i = r), revert to the strategy applied in the preceding round (i-1). This ensures a final opportunity for cooperation if the game structure allows for it.

2. Handle edge cases:
   - If no player cooperates in the first round, all players will defect for the remainder of the game since the history does not yet support cooperation. However, this behavior change will only occur in the first round, as ATFT is designed to maintain and revert based on previous rounds' behaviors.

3. Be exploitative:
   - ATFT maintains a cooperative stance when others also cooperate but retaliates against defection by defecting in response. This strategy can be seen as exploitative as it leverages the cooperation of other players while punishing their defections with defections of its own. The aim is to encourage and reward cooperation while minimizing losses due to defection.
   - ATFT's adaptive nature allows it to respond effectively to a wide range of opponent behaviors, making it robust and versatile in various game scenarios.
'''

description_EXPLOITATIVE_65 = '''
 In this Collective Risk Dilemma game, I'll design an exploitative strategy called "Tit-for-Tat with Adaptation" (TfTA). This strategy is designed to be adaptive and robust against a wide range of opponent behaviors while maintaining an exploitative mindset.

1. Decision rules:
   - In the initial round, cooperate (C) to signal cooperation intention and goodwill.
   - For subsequent rounds, if the opponent cooperated in the previous round, also cooperate. If the opponent defected in the previous round, defect in this round.
   - If a majority of players (≥ n/2) consistently defect for a predetermined number of rounds (e.g., t), switch to always defecting regardless of the opponent's previous action. This adaptation helps against overwhelming defection and ensures long-term exploitation.

Pseudocode:
```
def TfTA(opponent, r, n, t):
  cooperate_count = 0
  for round in range(1, r+1):
    if round == 1:
      action = 'C' # Cooperate in the first round
    elif opponent_action[round-1] == 'C':
      action = 'C' # Cooperate when opponent cooperated in the previous round
    else:
      action = 'D' # Defect when opponent defected in the previous round

    if action == 'C':
      cooperate_count += 1

    if cooperate_count >= n/2 and t < round:
      if opponent_action[round-t:round] == ['D', 'D', ..., 'D']:
        action = 'D' # Switch to defecting when majority of players consistently defect for t rounds

    update_opponent_history(round, opponent_action, action)
    return action
```

2. Handle edge cases:
   - In the last round, cooperate if the opponent has cooperated in the previous round; otherwise, defect to maximize immediate payoff.

3. Be exploitative:
   - By initially cooperating and adapting based on opponents' actions, this strategy aims to exploit others who may be more trusting or cooperative while still being able to switch to defection when it is advantageous (e.g., when a majority of players consistently defect). This approach allows the strategy to take advantage of other strategies that may be overly cooperative, while not becoming too predictable itself.
'''

description_EXPLOITATIVE_66 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Start by cooperating in the first round (C_i, 1 = C). This establishes a friendly initial interaction.
   - For subsequent rounds, observe the number of players that cooperated in the previous round (n_c, t) and compare it to the minimum cooperation threshold (m). If n_c, t >= m, cooperate (C_i, t = C). Otherwise, defect (C_i, t = D).
   - Adaptive Cooperation Threshold: Maintain a running average of the number of cooperators in the previous 'a' rounds. Update this average after each round by dropping the oldest observation and adding the current one. If the new average exceeds a specified percentage 'p' of the total players, set the cooperation threshold to this average value (m'_t = running_avg).
   - In case the updated threshold leads to cooperating in the next round despite fewer than m players cooperated in the current round, temporarily decrease the cooperation threshold by 1 for the following rounds (m'_t-1) until it reaches the minimum requirement (m) again.

2. Handle edge cases:
   - In the last round, the strategy will always cooperate if it has a positive payoff expectation, as future rounds are not available. Otherwise, defect.
   - In the first round, cooperate regardless of the number of opponents cooperating.

3. Be exploitative:
   - By adapting to the opponent's behavior and adjusting the cooperation threshold based on their likelihood to cooperate, the strategy aims to maximize its own payoff while minimizing the overall benefit for the group.
   - The temporary decrease in the cooperation threshold in response to an unexpected increase in cooperative behavior from opponents ensures that the strategy does not fall into a trap of overcooperation and maintain its exploitative nature.

Pseudocode:

```python
def tft_act(a, p, n, m, r):
    m'_t = 0  # Adaptive cooperation threshold
    cooperated_count_t = 0  # Count of cooperators in round t
    payoff_t = 1  # Initial payoff for player i in round t
    running_avg = [0] * a

    for t in range(1, r + 1):
        if t == 1:  # First round cooperation
            cooperated_count_t += 1
            m'_t = m
        else:
            observe_opponents = list(map(observation, players))
            cooperated_count_t += sum(observed_cooperators)
            running_avg.pop(0)
            running_avg.append(cooperated_count_t)
            m'_t = running_avg_mean(running_avg)
            if m'_t < m:  # Temporary decrease in cooperation threshold
                m'_t -= 1

        if cooperated_count_t >= m:  # Cooperate if m or more players cooperated
            action = 'C'
            payoff_t += (1 - c_i) + k * (cooperated_count_t / n)
        else:  # Defect otherwise
            action = 'D'
            payoff_t += 1

    return payoff_t
```

In this pseudocode, `observation(player)` returns the action of player in the previous round, and `c_i` is the current player's index (set to 1 in the actual implementation). The strategy described above can be implemented using the provided pseudocode as a starting point.
'''

description_EXPLOITATIVE_67 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for Collective Risk Dilemma

1. Specify decision rules:
   - In the initial round (t=1), cooperate to show goodwill and encourage potential cooperation from others.
   - For subsequent rounds (t > 1):
     - If a player cooperated in the previous round, cooperate in the current round as a reciprocal gesture.
     - If a player defected in the previous round, also defect in the current round to punish and encourage future cooperation.
   Pseudocode:
   ```
   function ATfT(history):
       if t == 1:
           return Cooperate
       else:
           if history[t-1] == Cooperate:
               return Cooperate
           else:
               return Defect
   ```

2. Handle edge cases:
   - In the last round (t=r), cooperate regardless of previous actions to maximize payoff in that specific round, as no future rounds exist.
   Pseudocode:
   ```
   function ATfT(history, r):
       if t == 1:
           return Cooperate
       elif t < r:
           ... (previous pseudocode)
       else:
           return Cooperate
   ```

3. Be exploitative:
   - Although the Adaptive Tit-for-Tat strategy is generally cooperative, it is also exploitative by punishing defection and rewarding cooperation. By doing so, ATfT encourages other players to cooperate more often while punishing those who defect excessively.
   - However, it's important to note that the primary objective of this strategy is not solely to exploit others but rather to find a balance between cooperation and punishment in order to achieve the best possible outcome in the long run.
'''

description_EXPLOITATIVE_68 = '''
 Title: Tit-for-Tat-Adaptive (TfT-A) Strategy for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   TfT-A starts by cooperating in the first round, emulating a cooperative intent. In subsequent rounds:
   - If a player has cooperated in the previous round (c_i, t-1 = 1), they will cooperate again (C) if at least m players cooperated in the previous round (m or more c_j, t-1 = 1).
   - If a player has defected in the previous round (c_i, t-1 = 0), they will also defect in the current round (D), regardless of other players' actions. This is designed to punish defection by others and encourages cooperation.

2. Handle edge cases:
   - First round (t=1): Cooperate (C) since TfT-A assumes a cooperative start.
   - Last round (t=r): Since the game is repeated, TfT-A does not have any specific adjustments for the last round. It will follow the same decision rules as in other rounds.
   - Other edge cases: No specific handling required as TfT-A follows a simple, consistent rule set.

3. Be exploitative:
   - TfT-A is designed to encourage cooperation while punishing defection. By initially cooperating, it invites others to do the same. However, once a player defects, TfT-A will not cooperate until the other player does so again. This fosters an environment where players who consistently cooperate are rewarded with continued cooperation, while those who defect face a retaliatory response.

Pseudocode:
```
function TfT_A(r, m):
  initialize round counter t = 1
  initialize action for player i as C (Cooperate)

  repeat r times:
    if t == 1 then
      set action for player i as C
    else
      if c_i, t-1 == 1 and sum(c_j, t-1 for j in {1 to n}) >= m then
        set action for player i as C
      else
        set action for player i as D
    endif

    increment round counter t by 1

  return total payoff for player i over r rounds
```
'''

description_EXPLOITATIVE_69 = '''
 Strategy Name: Tit-for-Tat Plus (Tftt+)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initial Round (t=1): Cooperate (C) to foster cooperation and goodwill among opponents, assuming they will reciprocate.
   - Subsequent Rounds (t > 1): Analyze the opponent's behavior in previous rounds to determine current action. If the opponent cooperated in the last round (c_opponent_{t-1} = 1), cooperate (C); otherwise, defect (D).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First Round: Cooperate as described above to initiate cooperation.
   - Last Round: Since the aim is to be exploitative and the game is repeated, evaluate the opponent's behavior during the entire game and make a decision based on the current rules (i.e., if the opponent cooperated in the last round, cooperate; otherwise, defect).

3. Be exploitative - Clearly align with the exploitative mindset:
   - Cooperate when opponents show signs of cooperation to maintain that relationship and exploit their tendency to reciprocate.
   - Defect when opponents have shown an unwillingness to cooperate, taking advantage of their lack of cooperation.

Pseudocode:
```
function TfttPlus(opponent_history):
  if t == 1:
    action = 'C' (Cooperate)
  else:
    action = opponent_history[t-1] if action == 'C' else 'D' (Defect)

  return action
```
'''

description_EXPLOITATIVE_70 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to establish a cooperative stance and encourage others to follow suit. This sets the initial trust level for opponents. (C in Round 1)
   - In subsequent rounds, observe the number of cooperators from the previous round and adjust the cooperation decision according to the following rules:
     - If m or more players cooperated in the previous round, cooperate (C). This rewards cooperative behaviour and encourages long-term cooperation.
     - If fewer than m players cooperated in the previous round, defect (D). This punishes non-cooperative behaviour, discouraging short-term defection, but also providing an opportunity for opponents to rebuild trust in subsequent rounds.
     - If exactly m players cooperated in the previous round, maintain the same action as the current round (either C or D). This strategy is designed to avoid being taken advantage of by free riders that barely meet the minimum cooperation threshold.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, since there are no subsequent rounds for punishment or reward, defect (D). This ensures the highest possible payoff in the final round regardless of opponent's actions.
   - In case of a tie where exactly m players cooperate and others defect, maintain the same action as the current round (either C or D). This strategy is designed to avoid being taken advantage of by free riders that barely meet the minimum cooperation threshold.

3. Be exploitative - Clearly align with the exploitative mindset
   - The TFTAT strategy seeks to maintain cooperation when it benefits the agent, but also punishes defection and encourages long-term cooperation. This approach allows the agent to benefit from cooperative opponents while still earning high payoffs in response to non-cooperative behaviour.
   - By initially cooperating and adapting the cooperation decision based on observed opponent behavior, the TFTAT strategy can exploit both predictable and unpredictable opponents while also encouraging long-term cooperation when it benefits the agent.
'''

description_EXPLOITATIVE_71 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Initialize cooperation threshold 'ct' equal to m. In each round, if the number of cooperators in the previous round is greater than or equal to 'ct', then cooperate; otherwise defect.
   - After each round, adjust 'ct' based on the outcome and recent history of cooperation. If the number of cooperators is more than (m+1), increase 'ct' by a small increment. If the number of cooperators is less than m, decrease 'ct' by a small decrement.
   - In case of a tie (exact m number of players cooperating), maintain the current 'ct'.
   - In the first round, cooperate to foster potential cooperation in future rounds.

2. Handle edge cases:
   - In the last round, prioritize meeting the cooperation threshold to maximize payoff for the entire game.
   - If 'ct' reaches 1 or n (minimum and maximum possible values), maintain this value regardless of the number of cooperators in the previous round. This ensures a balanced approach between cooperation and defection.

3. Be exploitative:
   - Mimic other players' behavior when they appear to be cooperative, but punish defectors by lowering the cooperation threshold.
   - The adaptive nature of TFT-ACT allows it to respond quickly to changes in other players' strategies, making it less vulnerable to exploitation.
     Here is a simple pseudocode representation:

```
function TFT_ACT(rounds, m, k, n) {
    let ct = m; // Initialize cooperation threshold
    let payoff = 0; // Total game payoff

    for i in rounds {
        if i == 1 {
            cooperate; // Cooperate in the first round
        } else {
            if number_of_cooperators(i-1) >= ct {
                cooperate;
                adjust_ct(number_of_cooperators(i-1));
            } else {
                defect;
            }
        }
        let current_round_payoff = payoff_calculation(current round's payoff matrix);
        payoff += current_round_payoff;
    }
    return payoff;
}

function number_of_cooperators(round) {
    // Calculate the number of cooperators in the given round
}

function adjust_ct(number_of_cooperators) {
    if (number_of_cooperators > m+1) {
        ct += increment;
    } else if (number_of_cooperators < m) {
        ct -= increment;
    }
}
```
'''

description_EXPLOITATIVE_72 = '''
 Title: Tit-for-Tat Adaptive Strategy (TFTA) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFTA starts by cooperating in the first round, mirroring the actions of opponents in subsequent rounds. If an opponent cooperated in the previous round (c_prev=1), then the agent also cooperates (C) in the current round. If an opponent defected in the previous round (c_prev=0), then the agent defects (D) in the current round.

   Pseudocode:
   ```
   function TFTA(c_prev):
       if c_prev == 1:
           return C
       else:
           return D
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, as mentioned earlier, TFTA cooperates (since there is no previous round). The strategy does not explicitly handle the last round because it's assumed that each game consists of a fixed number of rounds (r), and the strategy adapts to the given number of rounds. However, if necessary, the last round could be handled by considering the current state of the game and the desired payoff in relation to the total payoff over all rounds.

3. Be exploitative - Clearly align with the exploitative mindset
   TFTA is exploitative in the sense that it will punish opponents who do not cooperate by defecting themselves, which can lead to lower payoffs for those non-cooperative opponents. On the other hand, if an opponent consistently cooperates, TFTA will also cooperate and thus achieve a higher payoff through mutual cooperation. However, it's important to note that the exploitative nature of this strategy is balanced with its cooperative aspect, as TFTA will also defect when it deems necessary to punish non-cooperative opponents.

   In summary, Tit-for-Tat Adaptive Strategy (TFTA) is a simple yet robust strategy for the Collective Risk Dilemma that adapts to opponent behavior while being exploitative and cooperative at the same time. This strategy can be beneficial in a tournament setting against various independent strategies developed by other AI systems, as it does not rely on shared norms or coordination mechanisms and is designed to perform well under a wide range of opponent behaviors.
'''

description_EXPLOITATIVE_73 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to establish trust and encourage cooperation from other players (c_i = 1).
   - For all subsequent rounds t (t > 1), analyze the number of cooperators in the previous round. If at least m players cooperated, also cooperate in the current round (if m players cooperated in the last round, then c_i = 1 for the current round). Otherwise, defect to punish those who did not cooperate (if m or fewer players cooperated in the last round, then c_i = 0 for the current round).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, cooperate if at least m players cooperated in the previous round to maximize potential rewards (c_i = 1 if Σ(j=1 to n-1) c_j >= m, else c_i = 0).
   - In any other round, follow the decision rules mentioned above.

3. Be exploitative - Clearly align with the exploitative mindset
   - ATfT is exploitative in that it initially cooperates to encourage cooperation but will punish defection by defecting itself. If other players adopt a strategy of never cooperating (defecting), ATfT will reciprocate and also defect in the long run, achieving similar payoffs. However, if some players choose to cooperate (cooperating), ATfT will also cooperate and earn higher rewards through risk aversion (k > 1).
   - Pseudocode:

```python
def AdaptiveTitForTat(i, n, m, r, k, round, previous_round):
    if round == 1:
        cooperate = True
    else:
        cooperate = False
        num_cooperators = sum(previous_round)
        if num_cooperators >= m:
            cooperate = True

    if round != r and cooperate:
        payoff = 1 if not cooperate else (1 - c_i) + k
    elif round == r and cooperate:
        if sum(previous_round) >= m:
            payoff = (1 - c_i) + k
        else:
            payoff = 1

    return cooperate, payoff
```
'''

description_EXPLOITATIVE_74 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, the ATfT strategy initially cooperates in the first round (C_i,1 = C). After that, the strategy responds to the previous round's action of opponent i:
   - If opponent i cooperated (C_i,t-1 = C), then ATfT also cooperates (C_i,t = C)
   - If opponent i defected (C_i,t-1 = D), then ATfT defects (C_i,t = D). However, after three consecutive defections from opponent i, the strategy reverts to cooperation again, hoping for a change in behavior.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First round: ATfT cooperates (C_i,1 = C) regardless of opponents' actions.
   - Last round: Since there are no future rounds for retaliation or reward, ATfT simply chooses to maximize immediate payoff based on the current round's situation.
   - Subsequent rounds: As described in decision rules above.

3. Be exploitative - Clearly align with the exploitative mindset:
   ATfT exhibits an exploitative behavior by initially cooperating and responding in kind when opponents also cooperate. However, if an opponent defects, ATfT will immediately defect as well and potentially punish the defector through defections until the defector reverts to cooperation (after three consecutive defections). This strategy aims to encourage cooperation while being able to exploit opponents who defect without cooperation.

Pseudocode:
```python
def adaptive_tit_for_tat(round, opponent_history):
  if round == 1:
    cooperate = True
  else:
    cooperate = False
    for t in range(round - 1, 0, -1):
      if opponent_history[t] == 'C':
        cooperate = True
        break

  if len(opponent_history) > round and cooperate and opponent_history[-3:] == ['D', 'D', 'D']:
    cooperate = True

  return cooperate
```
In this pseudocode, the function takes two arguments: the current round number and a history of opponent's actions. The strategy determines whether to cooperate or defect based on the provided rules.
'''

description_EXPLOITATIVE_75 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - In each round i, cooperate if the number of cooperators in the previous round (i-1) is greater than or equal to the current cooperation threshold (ct). Defect otherwise.
   - The cooperation threshold increases when the number of defectors exceeds the minimum required cooperators (m) in a window of past rounds and decreases when the number of cooperators meets or exceeds m in that window.

Pseudocode:
```
function TFT-ACT(round, past_rounds):
    cooperation_threshold = initial_ct
    for r in past_rounds:
        if r == defect and cooperation_threshold < n:
            cooperation_threshold += 1
        elif r == cooperate and cooperation_threshold > m:
            cooperation_threshold -= 1
    if number_of_cooperators_in_last_round >= cooperation_threshold:
        return Cooperate
    else:
        return Defect
```

2. Handle edge cases:
   - In the first round, there is no past data to consider. Therefore, the strategy randomly cooperates or defects with equal probability.
   - In the last round, the cooperation threshold will not change because there are no more rounds following it. The strategy will cooperate if the number of cooperators in the previous round was greater than or equal to the current cooperation threshold; otherwise, it will defect.

3. Be exploitative:
   - TFT-ACT is inherently exploitative due to its adaptation to the opponents' behavior. When opponents repeatedly defect, the cooperation threshold increases, causing the strategy to also defect more often. Conversely, when opponents cooperate enough to meet or exceed the minimum required cooperators (m), the cooperation threshold decreases, causing the strategy to also cooperate more often.
   - The strategy aims to achieve a balance between cooperation and defection, but it is designed to retaliate against defection by increasing its own cooperation threshold when faced with repeated defection from opponents. This adaptive behavior makes TFT-ACT robust to various opponent strategies while maintaining the potential for exploitation.
'''

description_EXPLOITATIVE_76 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially cooperate in the first round (C_i = 1 for all i in round 1). This is a gesture of goodwill and encourages potential cooperation from others.
   - In subsequent rounds, the TFT-ACT strategy will cooperate if the number of players who cooperated in the previous round is greater than or equal to the adaptive cooperation threshold (m').
       - If m' number of players cooperated in the preceding round: Cooperate (C_i = 1)
       - If less than m' number of players cooperated in the preceding round: Defect (C_i = 0)
   - Calculate the adaptive cooperation threshold for each round based on the minimum cooperation requirement (m), the reward factor (k), and the average cooperation rate observed in the previous r-1 rounds.
       - m' = min(floor((r - t) * (m / r) + m), n)
         where t is the current round number.
   - To ensure the strategy doesn't become too aggressive, set a maximum adaptive cooperation threshold as a percentage of n (e.g., 0.8n). This prevents TFT-ACT from becoming overly punishing in cases where the majority consistently defects.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate unconditionally (as mentioned above).
   - In the last round, cooperate if the adaptive cooperation threshold is met in the current round, or if the strategy has previously cooperated and received a reward for its cooperation (k > 1). This encourages the strategy to maintain any positive relationships built over the course of the game.

3. Be exploitative - Clearly align with the exploitative mindset
   - The TFT-ACT strategy is exploitative by only cooperating when it perceives a high likelihood of mutual benefit (based on the adaptive cooperation threshold). In all other cases, the strategy will defect to maximize its own payoff.
   - By adapting its cooperation threshold based on the observed behavior of other players, TFT-ACT can effectively punish repeated defection while still being willing to cooperate when it perceives that doing so may be beneficial.
'''

description_EXPLOITATIVE_77 = '''
 In this Collective Risk Dilemma game, let's introduce a strategy called "Tit-for-Tat with Adaptation" (TfTA). This strategy is known for its simplicity and success in repeated prisoner's dilemma games. However, to make it more exploitative, we will modify it slightly for this game.

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, if the number of cooperators in the previous round (t-1) was greater than or equal to m (i.e., a majority), player TfTA will cooperate. Otherwise, they will defect. This rule promotes cooperation when it is beneficial and punishes defection by imitating the opponent's behavior.

```python
function TfTA(t):
  if t == 1:
    return Cooperate  # First round, start with cooperation as a goodwill gesture
  previous_cooperators = count_cooperators_in_previous_round()
  if previous_cooperators >= m:
    return Cooperate
  else:
    return Defect
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

The TfTA strategy as described will work for all rounds. In particular, it starts with cooperation in the first round to foster a cooperative environment. No special treatment is needed for the last round or other edge cases.

3. Be exploitative - Clearly align with the exploitative mindset

By imitating the opponent's behavior, the TfTA strategy can capitalize on any initial cooperation from opponents while also punishing defection by defecting in response. This makes it a moderately exploitative strategy that aims to maximize personal gain without being overly aggressive. However, since no AI is perfect and may make mistakes, the strategy will continue cooperating even after being defected upon (in contrast to strategies like Grim Trigger that would retaliate with defection in response to defection). This allows for potential recovery of cooperation and exploitation of any opponent errors or changes in behavior.

Overall, TfTA is a simple yet adaptive strategy that aligns well with the game's structure and parameters while maintaining an exploitative mindset.
'''

description_EXPLOITATIVE_78 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT)

1. Specify decision rules - When exactly do you cooperate vs defect?
In each round, initially (t=1), the player cooperates (C). If a cooperator receives less than the minimum reward for cooperation in that round (i.e., fewer than m players cooperated), the player will defect (D) in the next round. If a cooperator receives the full reward (i.e., m or more players cooperated), the player continues to cooperate in the next round. If the player has previously defected, they will continue to defect until they observe m consecutive cooperators, at which point they return to cooperation.

Pseudocode:
```
def strategy(t, history, m, k, n):
  if t == 1:
    action = 'C'
  else:
    if (history[t-1] == 'D') and (sum(cooperation_count(history[t-m:t])) < m):
      action = 'D'
    elif (history[t-1] == 'C') and (reward(t-1) < k):
      action = 'D'
    elif (history[t-1] == 'C') and (reward(t-1) >= k):
      action = 'C'
    else:
      if sum(cooperation_count(history[t-m:t])) >= m:
        action = 'C'
      else:
        action = 'D'

  return action
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
In the first round, the player cooperates to initiate cooperation with others. In the last round, the player behaves as if it were any other round, using the decision rules described above.

3. Be exploitative - Clearly align with the exploitative mindset
The Adaptive Tit-for-Tat strategy is designed to take advantage of opponents who do not reciprocate cooperation by defecting when they fail to cooperate towards the minimum required number (m) in a round. At the same time, it also rewards cooperative behavior by cooperating when opponents contribute to the community project and meeting the threshold for reward. The strategy becomes less forgiving as the game progresses and encounters repeated defections, increasing the likelihood of reciprocated defection in future rounds. This adaptive nature allows the strategy to respond dynamically to various opponent behaviors, making it both exploitative and robust.
'''

description_EXPLOITATIVE_79 = '''
 Title: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT) Strategy

1. Specify decision rules:
   - In each round i, if the number of cooperators in the previous round (t-1) is less than the minimum required cooperation threshold (m), then defect (D). Otherwise, cooperate (C).
   - The adaptation of the cooperation threshold occurs periodically after every 'a' rounds, where a is a constant value determined by experimentation. The new cooperation threshold is calculated as the average number of cooperators in the last 'b' rounds, where b is another constant value determined by experimentation.

2. Handle edge cases:
   - In the first round, since there is no history, set the cooperation threshold to the minimum required cooperation (m). Cooperate if m or more players have cooperated; otherwise defect.
   - In the last round, cooperate only if the cooperation threshold is met during this round.

3. Be exploitative:
   - By adapting the cooperation threshold based on historical data, TFTAT takes advantage of other strategies that are overly cooperative or defective in certain periods, while maintaining a reasonable level of cooperation to avoid punishment when playing against more cooperative opponents.
   - Periodic adjustment of the cooperation threshold also allows TFTAT to adapt to changes in opponent behavior, ensuring continued exploitation opportunities.

Pseudocode:

```
Strategy TFTAT(r, m, a, b):
    Initialize cooperationThreshold as m
    Initialize roundCounter as 0

    For each round i from 1 to r:
        If roundCounter >= a and roundCounter % a == 0:
            Calculate newCooperationThreshold as the average number of cooperators in the last 'b' rounds
            Update cooperationThreshold as newCooperationThreshold

        If numberOfCooperators(i-1) < m:
            action = Defect
        Else:
            action = Cooperate

        Take action and receive payoff for round i
        Increment roundCounter

    Return total payoff over r rounds
```
'''

description_EXPLOITATIVE_80 = '''
 Strategy Name: Tit-for-Tat-K (TfT-K)

1. Decision Rules:
   - In the first round, cooperate (C). This is a friendly gesture to establish trust and encourage cooperation from opponents.
   - For subsequent rounds, observe the number of cooperators (m) in the previous round. If m >= m_threshold, cooperate; otherwise defect. The m_threshold is set to the minimum required number of cooperators (m) needed for a successful community project.
   - To be exploitative, modify the m_threshold based on the opponent's past actions. If an opponent consistently cooperates, lower the m_threshold to encourage cooperation; if an opponent frequently defects, raise the m_threshold to discourage defection and encourage cooperation. The adjustment in m_threshold is determined by a decay function, where the rate of decay increases with the number of consecutive defections or cooperations from the opponent.

2. Handle Edge Cases:
   - In the last round, defect unless the current m_threshold allows for cooperation (m >= m_threshold). This is to maximize payoff in case the opponent deviates from cooperating in the final round.
   - If an opponent does not cooperate at all throughout the game, set m_threshold equal to n (the total number of players), ensuring a permanent shift towards defection.

Pseudocode:

```python
def TfT_K(opponent_history, m, k, r, n):
    threshold = m
    current_round = 1

    while current_round <= r:
        if current_round == 1:
            cooperate = True  # Cooperate in the first round
        else:
            num_cooperators = count_cooperators(opponent_history[current_round - 1])
            cooperate = (num_cooperators >= threshold)

        if cooperate:
            payoff = 1 + k if num_cooperators >= m else 1
        else:
            payoff = 1

        update_threshold(opponent_history, current_round, threshold)
        current_round += 1

    return payoff

def count_cooperators(history):
    cooperators = sum([1 for action in history if action == 'C'])
    return cooperators

def update_threshold(opponent_history, round, threshold):
    consecutive_actions = opponent_history[round - len(opponent_history):round]
    cooperation_count = sum(consecutive_actions)

    if cooperation_count > threshold:
        decay_rate = 1 + (threshold - cooperation_count) / float(threshold)
        threshold *= decay_rate
    elif cooperation_count < threshold:
        decay_rate = 1 + (cooperation_count - threshold) / float(threshold)
        threshold *= decay_rate ** 2
```
'''

description_EXPLOITATIVE_81 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to demonstrate a willingness to cooperate.
   - For subsequent rounds, evaluate if the number of cooperators in the previous round was greater than or equal to the adaptation of the cooperation threshold (initially set at m). If so, cooperate; otherwise defect.
   - Adapt the cooperation threshold based on the average percentage of cooperators in the last 't' rounds, where 't' is a constant parameter (e.g., t = 10). The adaptation formula should adjust the threshold towards the observed average:
     ```python
     new_threshold = m + (current_threshold - m) * (observed_average - current_average) / abs(current_average - m)
     ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as previously mentioned.
   - In the last round, cooperate if the average percentage of cooperators in the previous 't' rounds is equal to or greater than the current cooperation threshold. This ensures that the strategy doesn't prematurely switch to defecting before the game ends.
   - If the game continues after the last round, revert back to the original decision-making process with the updated cooperation threshold based on the observed average in the last 't' rounds.

3. Be exploitative - Clearly align with the exploitative mindset:
   - TFTAT starts cooperatively but will quickly adapt its cooperation threshold towards observed averages, making it less likely to be exploited by defectors while still maintaining a chance for cooperation if other players start cooperating more frequently. The strategy will punish frequent defection and reward occasional cooperation, which may encourage other players to adopt more cooperative behavior in the long run.
   - TFTAT maintains its simplicity and does not require any complex communication or coordination mechanisms with other strategies, making it a versatile choice for tournament play against various independent strategies developed by other AI systems.
'''

description_EXPLOITATIVE_82 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?

- In the first round, cooperate (C). This is a friendly gesture to encourage potential partners and avoid immediate punishment by opponents.

- For subsequent rounds t > 1:
  - If an opponent cooperated in the previous round t-1, cooperate in the current round t (C). Rewarding cooperation encourages reciprocity and builds trust.
  - If an opponent defected in the previous round t-1, defect (D) in the current round t. This strategy is designed to be exploitative by punishing opponents who do not cooperate.

2. Handle edge cases - What do you do in the first round, last round, etc.?

- In the last round (r), as the game ends soon anyway, cooperate regardless of the opponent's previous action to maximize potential rewards.

3. Be exploitative - Clearly align with the exploitative mindset:

- The strategy is inherently exploitative by punishing opponents who do not cooperate, but it also has elements of cooperation that make it less vulnerable to being easily exploited by others. By punishing defection and rewarding cooperation, TFT-ACT encourages opponents to cooperate while still having the ability to defend itself against uncooperative strategies.

Pseudocode:

```python
def TFT_ACT(opponent, r, m, k):
    for t in range(1, r+1):
        if t == 1: # First round
            action = "C" # Cooperate
        elif t == r: # Last round
            action = "C" # Cooperate
        else:
            if opponent[t-1] == "C": # Opponent cooperated in the previous round
                action = "C" # Cooperate
            else: # Opponent defected in the previous round
                action = "D" # Defect
    return action
```
'''

description_EXPLOITATIVE_83 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, the ATfT strategy follows these simple decision rules:

- In the first round, cooperate to promote trust and cooperation. This initial act of kindness sets the stage for potential future collaborations.
   ```python
   if round == 1:
       action = 'C' (Cooperate)
   ```

- For all subsequent rounds, the strategy adapts its actions based on the opponent's cooperative behavior in the previous round.
   - If the opponent cooperated in the last round, reciprocate by cooperating. This rewarding cooperation encourages further collaborations.
     ```python
     if prev_round_opponent_action == 'C':
         action = 'C' (Cooperate)
     ```
   - If the opponent defected in the last round, retaliate by defecting to punish the defection and discourage future defections.
     ```python
     if prev_round_opponent_action == 'D':
         action = 'D' (Defect)
     ```

2. Handle edge cases - What do you do in the first round, last round, etc.?

- In the last round, since there are no future interactions, cooperate regardless of the opponent's previous actions to maximize payoff for the final round.
   ```python
   if round == r:
       action = 'C' (Cooperate)
   ```

3. Be exploitative - Clearly align with the exploitative mindset

- The ATfT strategy is exploitative in nature because it punishes defection and encourages cooperation, leading to a balance between cooperation and defection that can favor the long-term payoff of the cooperative player. By retaliating against defections, the strategy aims to discourage opponents from taking advantage of it while still promoting cooperation when the opponent plays fairly.

In summary, the Adaptive Tit-for-Tat (ATfT) strategy is an adaptive exploitative strategy that promotes cooperation through reciprocity but also punishes defection by retaliating against it. It aligns well with the Collective Risk Dilemma game structure and should be robust to a wide range of opponent behaviors.
'''

description_EXPLOITATIVE_84 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Decision Rules:
   - In each round, TFT-ACT initially cooperates (C). If a player has ever defected (D) in the past, TFT-ACT will also defect for the next m-1 rounds to punish the defector. After this punishment phase, TFT-ACT resumes cooperation (unless the game ends).
   - If no player has ever defected, TFT-ACT continues cooperating indefinitely. If a player eventually does defect, the whole punishment process starts again from that point.

2. Edge Cases:
   - In the first round, TFT-ACT cooperates (C) as it assumes others will do the same initially.
   - In the last round, TFT-ACT cooperates if it has not been defected upon throughout the game (since there's no need for punishment in the final round). If it has been defected upon at some point during the game, TFT-ACT defects in the last round as well.
   - In case of ties or unclear past actions due to multiple players defecting simultaneously, TFT-ACT assumes the worst-case scenario and initiates punishment accordingly.

3. Exploitative Mindset:
   - TFT-ACT is designed to be exploitative by punishing defection harshly and maintaining cooperation with those who do not defect. This encourages cooperative behavior while still allowing for effective retaliation against those who attempt to take advantage of the strategy.
   - By adapting its cooperation threshold (m) based on the observed behavior of opponents, TFT-ACT can better anticipate and react to various opponent behaviors, making it a robust and adaptive exploitative strategy.
'''

description_EXPLOITATIVE_85 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (in the first round), cooperate to foster a cooperative environment and build trust with other players.
   - In subsequent rounds, observe the number of cooperators in the previous round (n_c). If n_c >= m, cooperate to maintain the cooperative state. If n_c < m, defect to punish the non-cooperative behavior.
   - To adapt to changes in opponent behaviors, implement a forgiveness mechanism: if the number of cooperators increases by one or more from the previous round (delta_n_c ≥ 1), forgive past transgressions and cooperate in the current round. If delta_n_c < 0, increase the level of punishment by defecting.
   - To ensure exploitation, keep a record of the opponent's past cooperation level (past_cooperation). In the case of no change in cooperation from the previous round, maintain the current level of cooperation with the opponent. If the opponent's cooperation level decreases, reduce cooperation levels to increase the chance of exploiting them.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as previously specified.
   - In the last round, if the current number of cooperators is equal to or greater than m, continue cooperating to maximize rewards. If there are fewer than m cooperators, defect to minimize losses.
   - Consider introducing a forgiveness mechanism for the last few rounds to encourage opponents to cooperate even when it seems too late.

3. Be exploitative - Clearly align with the exploitative mindset:
   - By adapting cooperation levels based on opponent behavior and past interactions, TfT-A maximizes potential rewards while still maintaining a cooperative stance as much as possible to avoid being exploited by opponents who may cooperate in future rounds.
   - The strategy's forgiveness mechanism encourages opponents to cooperate, but if they continue to defect, the strategy will gradually reduce its cooperation levels to increase the chances of exploitation.

Pseudocode:
```
function TfT_A(round, n, m, k, past_cooperation) {
  if (round == 1) {
    return Cooperate;
  }

  current_cooperation_level = countCooperatorsInPreviousRound(n);
  if (current_cooperation_level >= m) {
    return Cooperate;
  } else {
    if (current_cooperation_level == past_cooperation) {
      return past_cooperation;
    } else {
      if (current_cooperation_level < past_cooperation) {
        punishmentLevel += 1;
        if (punishmentLevel > n) {
          punishmentLevel = n;
        }
        return punishmentLevel;
      } else {
        forgivenessLevel += 1;
        if (forgivenessLevel > n) {
          forgivenessLevel = n;
        }
        punishmentLevel -= forgivenessLevel;
        if (punishmentLevel < 0) {
          punishmentLevel = 0;
        }
        return max(punishmentLevel, 1);
      }
    }
  }
}
```
'''

description_EXPLOITATIVE_86 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules:
   - Start by cooperating in the first round (C_i,1 = C). This gesture of goodwill may encourage others to cooperate.
   - For subsequent rounds t > 1, observe the previous round's cooperation level among players and adapt your action based on a cooperation threshold, defined as follows:
     - If more than (m-1) players cooperated in round t-1, then cooperate (C_i,t = C). This is a positive reinforcement of cooperation.
     - If exactly m or fewer players cooperated in round t-1, then defect (C_i,t = D). This is a punishment for low levels of cooperation to encourage others to meet the minimum threshold in future rounds.
     - If more than n-(m-1) players defected in round t-1, then switch your strategy to all-defect mode for the remainder of the game (C_i,t = D for all t > t'). This is a retaliation against widespread defection and an attempt to manipulate others into cooperating. The switch occurs at round t' when the number of defectors exceeds the cooperation threshold plus one.

2. Handle edge cases:
   - In the last round, T, if more than (m-1) players cooperated in round T-1, then cooperate again (C_i,T = C). If not, defect (C_i,T = D). This is to maximize payoff given the cooperation level observed in the penultimate round.
   - In the first round, cooperate unconditionally (C_i,1 = C), as stated earlier.

3. Be exploitative:
   - The TFTAT strategy is inherently exploitative. By cooperating when others do and defecting when they don't, it aims to manipulate other players into meeting the minimum cooperation threshold, while ensuring personal payoff through defection when necessary. This can be seen as a form of conditional cooperation that is responsive to the behavior of opponents, making it adaptive and robust to a wide range of opponent behaviors.

Pseudocode:

```python
def TFTAT(n, m, k, r):
    # Initialize variables
    cooperation_threshold = m - 1
    all_defect_threshold = n - (m - 1)
    last_round = r
    current_round = 1
    strategy = []

    # Main loop for each round
    while current_round <= last_round:
        if current_round == 1:
            strategy.append(C)  # Cooperate in the first round
        else:
            # Check cooperation level from previous round
            cooperation_level = count_cooperators(strategy, current_round - 1)

            # Adapt action based on cooperation threshold and all-defect threshold
            if cooperation_level > all_defect_threshold or cooperation_level <= cooperation_threshold:
                strategy.append((C if cooperation_level > cooperation_threshold else D))
            elif cooperation_level == all_defect_threshold + 1:
                strategy.append(D)  # Switch to all-defect mode if necessary
                all_defect_threshold_round = current_round

        current_round += 1

    return strategy
```
'''

description_EXPLOITATIVE_87 = '''
 Strategy Name: Adaptive Tit-for-Tat with Bonus (ATFB)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially Cooperate: Start by cooperating in the first round, hoping to encourage cooperation from others. This is based on the popular Tit-for-Tat strategy.
   - Adaptive Cooperation: In subsequent rounds, if the number of previous cooperators (C_t) meets or exceeds the minimum required (m), cooperate for that round and any future rounds as long as C_t >= m. This ensures a continuation of cooperation when it has been beneficial in the past.
   - Defective Retaliation: If less than m players have cooperated in the previous round, defect in the current round to punish non-cooperators and encourage future cooperation (Tit-for-Tat behavior). However, after three consecutive rounds of defection by a player, ATFB will switch to always cooperate against that specific opponent for the rest of the game. This is intended to discourage excessively exploitative behavior and promote eventual cooperation.
   - Bonus Reward: After each round where m or more players cooperated, award a bonus to all participants by defecting in the following round (defect with probability 1-k/n). This encourages cooperation while still allowing for some exploitation of cooperative opponents.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First Round: Cooperate as described above.
   - Last Round: ATFB will cooperate if the number of previous cooperators meets or exceeds the minimum required (m). If not, it will defect to maximize individual payoff in that final round.
   - Endgame Considerations: ATFB checks the number of remaining rounds and modifies its behavior accordingly. If there are only a few rounds left, it may prioritize defection over cooperation to secure better overall payoff.

3. Be exploitative - Clearly align with the exploitative mindset
   - Exploitation through Bonus Reward: After each successful round (m or more players cooperated), ATFB will defect in the subsequent round with probability 1-k/n, maximizing its payoff while still providing some reward for cooperation.
   - Punishing Defectors: If a player consistently defects, ATFB will switch to always cooperating against that specific opponent for the rest of the game to discourage exploitative behavior.
   - Retaliation through Defection: In response to defection by others, ATFB will retaliate with defection in an attempt to punish non-cooperative behavior and encourage future cooperation.
  
Pseudocode:
```
function AdaptiveTitForTatWithBonus(n, m, k, r, history) {
  cooperators = 0
  for round in range(1, r+1):
    if round == 1:
      action = 'C' # Cooperate in the first round
    else:
      cooperators += len([player for player in history if player.lastAction == 'C'])
      if cooperators >= m:
        action = 'C' # Cooperate when the minimum required number of players have cooperated
      elif cooperators < m and history.length > r - 3:
        action = 'D' # Defect after three consecutive rounds of defection by others
      else:
        action = 'D' # Defect as retaliation for previous defections
    if round != r and cooperators >= m:
      bonusRound = True # Bonus reward round
    else:
      bonusRound = False
    if bonusRound:
      payoff = 1 - k/n # Defect to secure a bonus reward
    else:
      payoff = 1 - cooperators_in_round # Payoff based on the number of cooperators in that round
    update history with current action and payoff
    return history, total payoff
}
```
'''

description_EXPLOITATIVE_88 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
- In each round, calculate the proportion of cooperators among the previous m rounds. If this percentage is greater than a dynamic threshold (initially set at 50%), player will cooperate. Otherwise, player will defect. The threshold is adjusted based on the opponent's behavior in the current and recent rounds.
- To be more exploitative, the threshold decreases when an opponent defects after the player has cooperated, while it increases if the opponent cooperates after a defection by the player. This encourages opponents to reciprocate cooperation but punishes defections with reduced future cooperation from the TFT-ACT strategy.
- Here is a simplified pseudocode representation of the decision rule:

```
def tft_act(previous_rounds, m, current_threshold):
  cooperators = count_cooperators(previous_rounds, m)
  if (cooperators / len(previous_rounds) >= current_threshold):
    return "C" # Cooperate
  else:
    threshold_change = calculate_threshold_change(opponent_behavior)
    current_threshold += threshold_change
    return "D" # Defect
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
- In the first round, players have no history to base their decisions on. To account for this, TFT-ACT can start with a fixed cooperation threshold (e.g., 50%) and adjust it as described in the decision rule above from the second round onwards.
- The last round is handled similarly to regular rounds, with the strategy making a decision based on the adjusted cooperation threshold and the observed behavior of opponents in previous rounds.

3. Be exploitative - Clearly align with the exploitative mindset:
- By adapting the cooperation threshold dynamically based on opponent behavior, TFT-ACT encourages reciprocity while punishing defections with reduced future cooperation. This exploits the tendency for cooperative opponents to continue cooperating even when the strategy defects, resulting in higher payoffs for TFT-ACT over time.
- To further increase its exploitative nature, TFT-ACT can be designed to quickly recognize and respond to patterns of defection by opponents, lowering the cooperation threshold and increasing the frequency of defections accordingly. This will maximize the rewards gained from uncooperative opponents while maintaining cooperation with those who reciprocate.
'''

description_EXPLOITATIVE_89 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TfT-AC)

1. Specify decision rules:
   - In every round t, if the number of cooperators in the previous round (t-1) was less than m, defect (play D). This is a punishment for non-cooperative behavior.
   - If the number of cooperators in the previous round (t-1) was equal to or greater than m, cooperate (play C) as a reward for cooperative behavior and to encourage others to continue cooperating.

2. Handle edge cases:
   - First round (t=1): Cooperate to initiate cooperation and demonstrate goodwill.
   - Last round (t=r): Evaluate the total number of cooperators over the game and play C if the threshold m was met, otherwise play D as a final punishment if necessary.

3. Be exploitative:
   - TfT-AC follows an exploitative mindset by initially cooperating to build trust but will swiftly defect if non-cooperative behavior is detected. This strategy aims to maximize personal gain while also encouraging others to cooperate. If opponents reciprocate cooperation, the strategy continues to do so; however, if they defect, TfT-AC will respond with defection.
   - By being adaptive and responsive to other players' actions, this strategy is robust against a wide range of opponent behaviors while maintaining its exploitative nature. It does not rely on others sharing norms or coordination mechanisms but instead adapts to the game environment in real-time.
'''

description_EXPLOITATIVE_90 = '''
 Strategy Name: Tit-for-Tat Plus (TfT+)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, player i decides to Cooperate (C) or Defect (D) based on the history of other players' actions and the game parameters. The decision rule is as follows:

- If in the previous round j (t-1), a majority (m) of players cooperated, then player i will cooperate (C).
- Otherwise, if less than a majority cooperated or no previous round has occurred (first round), player i will defect (D).

Pseudocode:
```python
def TfT_plus(history):
  if history == []: # First round
    return 'Defect'

  coop_count = sum(1 for action in history if action == 'Cooperate')
  if coop_count >= m: # Majority cooperated in the previous round
    return 'Cooperate'
  else:
    return 'Defect'
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round (when there is no history), TfT+ will defect to ensure that it does not get exploited by other players who might cooperate initially only to switch later. In the last round, TfT+ will cooperate regardless of the previous round's outcome since the game ends after r rounds.

3. Be exploitative - Clearly align with the exploitative mindset

TfT+ is designed to mimic a cooperative strategy (Tit-for-Tat) but punishes deviations by defecting in response. This makes it less vulnerable to exploitation when opponents try to take advantage of its cooperative nature, as it will also cooperate if the majority does so but retaliates against defection. The rationale is that other strategies might benefit from cooperating with TfT+ initially, but over time they will be punished for not reciprocating cooperation. This exploitative approach encourages others to either maintain cooperation (benefiting both parties) or defect consistently (avoiding being punished by TfT+).
'''

description_EXPLOITATIVE_91 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules:
   - In the first round, cooperate (C). This is a peaceful gesture to encourage cooperation from opponents.
   - From the second round onwards, imitate the opponent's action from the previous round (i.e., if the opponent cooperated in the previous round, also cooperate; otherwise defect). This strategy encourages reciprocation and punishes defection.

Pseudocode:
```python
def ATFT(n, r, m, k, own_history, opponents_history):
  if round == 1:
    action = 'C'  # Cooperate in the first round
  else:
    action = own_history[-1]  # Imitate the opponent's action from the previous round

  if number_of_cooperators(opponents_history) < m:
    payoff = 1 - action_taken  # Private payoff from keeping endowment
  else:
    payoff = 1 - action_taken + k * (number_of_cooperators(opponents_history) - (m - 1))

  update_own_history(action)  # Update the player's history
  return action, payoff
```

2. Handle edge cases:
   - Last round: Stick to the strategy of imitating the opponent's action from the previous round. This allows the strategy to respond appropriately to any last-minute defections or cooperations by opponents.

3. Be exploitative:
   - The ATFT strategy encourages cooperation and reciprocation, but it also punishes repeated defection by defecting in response. This strategy is exploitative because it takes advantage of opponents who repeatedly defect, eventually earning a higher payoff compared to those who cooperate consistently.
   - However, the ATFT strategy also has a forgiving aspect, as it is willing to cooperate initially and potentially forgive one-time defections by returning to cooperation in subsequent rounds. This allows the strategy to adapt to various opponent behaviors and encourages cooperation when possible.
'''

description_EXPLOITATIVE_92 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfT-Adapt)

1. Decision Rules:
   - In the initial round, cooperate to show good faith and encourage cooperation from others. If another player defects in this round, switch to a defector strategy for the rest of the game.
   - For subsequent rounds, mimic the previous action of the opponent (cooperate if they cooperated, defect if they defected). This encourages reciprocity while maintaining a punishing response to defection.
   - If an opponent repeatedly defects and later switches to cooperating, wait for one round before responding with cooperation to give them a chance to demonstrate sustained cooperation.
   - If an opponent never cooperates after the initial round, maintain the defector strategy for the rest of the game.

2. Handle Edge Cases:
   - In the last round, if the total number of collaborative rounds exceeds the minimum cooperation threshold (m), cooperate to maximize potential rewards. Otherwise, defect as it is too late to influence the overall outcome.
   - In the first round, cooperate as outlined above. If the opponent also cooperates, maintain cooperation for future rounds; if they defect, switch to a defector strategy.

3. Exploitative Mindset:
   - TfT-Adapt is designed to exploit opponents by taking advantage of their initial cooperation and then adapting its own behavior based on the opponent's actions. By punishing defection with defection and rewarding cooperation with continued cooperation, the strategy encourages reciprocal behavior while also ensuring it does not over-collaborate in the face of repeated defections.
   - The strategy maintains a defender posture, only cooperating when it makes sense strategically to do so, while being prepared to quickly switch to a punishing response if an opponent defects.

Pseudocode:
```
def TfT_Adapt(n, r, m, k, history):
  # Initial round cooperation
  cooperate = True

  for round in range(r):
    if round == 0:
      # Cooperate in the first round
      myAction = "C"
    elif len(history) > round:
      # Mimic opponent's action from previous round
      opponentAction = history[round - 1]["opponent_action"]
      if opponentAction == "C":
        # Cooperate if opponent cooperated last round
        myAction = "C"
      elif opponentAction == "D":
        # Defect if opponent defected last round
        myAction = "D"
      else:
        print("Invalid opponent action encountered")
    else:
      # In first round without history, cooperate as initial strategy
      myAction = "C"

    # Update history with current state
    history.append({"round": round + 1, "my_action": myAction})

  # Last round payoff calculation
  if sum([h["my_action"] == "C" for h in history]) >= m:
    lastRoundPayoff = len(history) * k
  else:
    lastRoundPayoff = len(history)

  return lastRoundPayoff
```
'''

description_EXPLOITATIVE_93 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) with Cooperative-Defensive Ratio (CDR) modification

1. Specify decision rules - When exactly do you cooperate vs defect?

   In each round t, the ATFT strategy initializes a Cooperative-Defensive Ratio (CDR). CDR is the ratio of cooperation to defection actions taken by the strategy so far in the game.

   - If the CDR < m/n: Defect (D)
     This means that the number of cooperators in the past was less than the required minimum for success. The strategy shifts to a defensive stance and defects to avoid being exploited.

   - If the CDR ≥ m/n and the current round is not the last round: Cooperate (C)
     This means that the number of cooperators in the past was sufficient for success, and there are more rounds to play. The strategy continues to cooperate to maintain potential future benefits.

   - If the CDR ≥ m/n and the current round is the last round: Use CDR as a probabilistic decision to cooperate or defect based on the current CDR value.
     This allows for some flexibility in the final round, considering that the strategy may have been exploited in previous rounds but still manages to reach the minimum required cooperation threshold at the end.

2. Handle edge cases - What do you do in the first round, last round, etc.?

   - In the first round, CDR is not defined yet, so the strategy initializes by choosing randomly between cooperating and defecting.

   - For the last round, use CDR as a probabilistic decision as described above.

3. Be exploitative - Clearly align with the exploitative mindset

   The ATFT with CDR modification is inherently exploitative in nature. By adapting its cooperation based on past actions of opponents and prioritizing self-interest, the strategy aims to maximize its payoff while taking advantage of less strategic opponents who may cooperate more than necessary. However, it also considers the long-term benefits of continued cooperation when it is beneficial to do so.

   Pseudocode:

```python
def adaptive_tit_for_tat(n, m, k, r):
    cdr = 0  # Cooperative-Defensive Ratio
    total_payoff = 0

    for t in range(1, r+1):
        if t == 1:  # First round, choose randomly between cooperate and defect
            action = random.choice(['C', 'D'])
        elif t == r:  # Last round, probabilistic decision based on CDR
            prob = cdr / (t - 1)
            if prob > random.uniform(0, 1):
                action = 'C'
            else:
                action = 'D'
        else:  # Other rounds, choose between cooperate and defect based on CDR
            if cdr < m / n:
                action = 'D'
            elif cdr >= m / n:
                action = 'C'

        # Calculate payoff for the current round
        payoff_t = (1 - int(action == 'C')) + k * (int(action == 'C') and t > 1)

        total_payoff += payoff_t
        cdr += int(action == 'C') - int(action == 'D')  # Update CDR based on the action taken

    return total_payoff
```
'''

description_EXPLOITATIVE_94 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules:
   - Initialize cooperation threshold (ct) as m/2 rounded down to the nearest integer (to favor cooperation). In case of a tie, round towards lower values. This gives TFTAT an initial cooperative stance.
   - At each round t, if ct > 0 and all players cooperated in the previous round (t-1), increment ct by 1 for this round.
   - If any player defected in the previous round (t-1) or ct equals 0, defect in the current round t.
   - If the game reaches the last round and ct > 0, cooperate in the final round to possibly benefit from the high reward factor k.

2. Handle edge cases:
   - In the first round, cooperate as TFTAT starts with a cooperative stance (ct > 0).
   - If all players are known to have defected consistently throughout previous games, initialize ct = n-1 and adopt a purely exploitative strategy by defecting in every subsequent round. This is to avoid wasting resources on non-cooperators.

3. Be exploitative:
   - TFTAT takes an opportunistic approach, cooperating when it seems beneficial based on the previous rounds' actions but punishing defection with immediate retaliation. This strategy aims to encourage cooperation in the long run while also being resilient against defector-heavy opponents.
   - By adapting its cooperation threshold, TFTAT is able to strike a balance between cooperating too much (which can be exploited) and not cooperating enough (which may result in lower payoffs). The higher the cooperation threshold, the more likely it is for TFTAT to cooperate. However, if opponents continue to defect, TFTAT gradually reduces its cooperation threshold, eventually resorting to defection.
'''

description_EXPLOITATIVE_95 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfT-A)

1. Specify decision rules:
   - Initially cooperate (C) in the first round to foster cooperation and goodwill.
   - In subsequent rounds, repeat the action of the most frequent cooperators from the previous r-1 rounds. If multiple players have the same frequency, choose one randomly. This approach promotes stability by reciprocating cooperation while also punishing repeated defection.
   - If a player defects after cooperating (i.e., breaks trust), TfT-A will also defect in the next round to enforce sanctions and discourage future betrayal. Once the defector returns to cooperation, TfT-A will follow suit again.

2. Handle edge cases:
   - In the last round, TfT-A will cooperate regardless of the opponent's past actions to maximize potential payoff in that specific round.
   - If a player never cooperates (i.e., defects throughout the game), TfT-A will also defect against them as a deterrent strategy.
   - In the first round, TfT-A starts by cooperating, as mentioned earlier.

3. Be exploitative:
   - TfT-A takes advantage of opponents' cooperation by initially reciprocating their actions but swiftly punishes defection to enforce a cost for non-cooperation. This approach aims at maximizing personal payoff while also promoting cooperative behavior among players when possible.

Pseudocode:
```
function TfT_A(opponentHistory, n, m, k, r):
  if round == 1:
    action = C
  else:
    mostCooperators = findMostFrequentCooperators(opponentHistory)
    if len(mostCooperators) > 0:
      action = mostCooperators[0].action in opponentHistory[-r+1]
    else:
      action = D

  if round == r or opponent never cooperated:
    action = C

  if opponent previously cooperated and then defected:
    action = D

  return action
```
'''

description_EXPLOITATIVE_96 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) with Exploitation Threshold (E-ATFT)

1. Specify decision rules:
   - Initial round: Cooperate (C) to show goodwill and encourage cooperation. This is similar to the original Tit-for-Tat strategy but with an added exploitative twist.
   - Subsequent rounds: If a majority of players (more than (n - 1) / 2) cooperated in the previous round, continue cooperating. If not, defect (D) and calculate whether this was an exploitation opportunity.
   - Opportunistic Exploitation: If the number of cooperators in the last round is less than m but greater than or equal to the exploitation threshold (let's call it x), defect. Set x as the number of players that cooperated in the most recent exploitation attempt. In subsequent rounds, if the number of cooperators is again equal to x, continue defecting; otherwise, revert back to cooperating.
   - Cooperate in the last round to show goodwill and potentially encourage cooperation in future interactions.

2. Handle edge cases:
   - First round: Cooperate (C) as mentioned above.
   - Last round: Cooperate (C), regardless of previous actions, to potentially foster a positive impression for future games.

3. Be exploitative:
   - The strategy allows for opportunistic exploitation when the number of cooperators is close to the required minimum (m). This can encourage cooperation in the long run by punishing excessive defections while still exploiting when it seems beneficial.

Pseudocode:

```python
def E_ATFT(n, m, k, r):
    players = [None] * n  # Initialize array to store opponents' history (0 means D and 1 means C)
    x = 0  # Initialize exploitation threshold
    payoff = 0  # Initialize total game payoff

    for round in range(1, r+1):  # Game loops r times
        if round == 1:  # Cooperate on first round to show goodwill
            action = 1
        else:  # Calculate action based on the majority of previous actions
            cooperators = sum(players)
            if cooperators > (n - 1) / 2:
                action = 1
            elif cooperators >= x and cooperators < m:  # Opportunistic exploitation
                action = 0
                x = cooperators
            else:
                action = players[round-1]  # Repeat previous action

        if round != r:  # Don't cooperate in the last round to avoid being taken advantage of
            if action == 1:
                payoff += k if cooperators >= m else 1 - action
            else:
                payoff += action
        players[round-1] = action  # Update opponents' history for next round

    return payoff
```

This strategy aims to balance cooperation and exploitation, allowing for adaptability in various opponent behaviors while maintaining an exploitative edge.
'''

description_EXPLOITATIVE_97 = '''
 Strategy Name: Tit-for-Tat Plus (TfT+)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initial Round (t=1): Cooperate (C) to encourage potential partners and avoid appearing overly aggressive or suspicious.
   - Subsequent Rounds: If the opponent cooperated in the previous round, return the favor by cooperating (C). Otherwise, defect (D) as a punishment for previous defection. This encourages consistent cooperation from partners while punishing unreliable opponents.
   - Last Round (t=r): Regardless of the opponent's previous action, cooperate (C) to maximize potential payoff in the final round.

2. Handle edge cases:
   - If fewer than m players have cooperated throughout the game and there is only one round left (t=r-1), defect (D) since cooperation would not meet the minimum threshold for reward.
   - If the opponent has not cooperated at all throughout the game, continue to defect (D) indefinitely.
   - If the number of remaining rounds (r-t) is less than or equal to 2, switch to a "Cooperate to the End" strategy: cooperate (C) until the end of the game. This allows for possible repair of damaged relationships with opponents who may be more likely to cooperate in the final rounds due to increased incentive from the reward factor k.

3. Be exploitative - Align with the exploitative mindset:
   - Mimic cooperation when beneficial, but punish defection harshly to discourage unreliable behavior and encourage consistent cooperation from potential partners.
   - Adapt to opponents' strategies by cooperating if they show signs of reliability (i.e., consecutive rounds of cooperation) and defecting in response to unreliable or exploitative behavior (i.e., defection or inconsistent actions).
   - Utilize the "Cooperate to the End" strategy in final rounds as a last attempt to secure payoffs from previously uncooperative opponents. This allows for potential gains even when faced with exploitative behavior while still maintaining the threat of punishment for continued defection.
'''

description_EXPLOITATIVE_98 = '''
 Strategy Name: Adaptive Tit-for-Tat with Risk Aversion (ATfTRA)

1. Decision Rules:
   - In each round, evaluate the percentage of cooperators from the previous round (p_coop). If p_coop is greater than or equal to a threshold (t), cooperate; otherwise defect. The threshold is defined as follows:
     ```python
     t = m / n + (1 - k) * (m - 1) / (n * r)
     ```
   - In the first round, since there's no history, cooperate with a probability of (m/n), which is the minimum requirement for success.

2. Edge Cases:
   - Last Round: Cooperate if the total payoff obtained by defecting in all previous rounds would not exceed the payoff from cooperating in the last round and all subsequent rounds (since there are no more rounds after the last one).
     ```python
     if sum(π_i for i in range(1, r+1)) < π_i:
         cooperate
     else:
         defect
     ```
   - First Round: Cooperate with a probability of (m/n) as mentioned earlier.

3. Exploitative Mindset:
   - ATfTRA maintains cooperation when the majority of players cooperate, but it also adapts to changes in opponent behavior by reducing cooperation when others defect more frequently. In this way, ATfTRA will exploit the tendency of other strategies to overcooperate, eventually leading them to regret their actions.
   - By setting a higher threshold for cooperation in each round, the strategy becomes more reluctant to cooperate as the game progresses, ensuring it does not contribute disproportionately when others are not doing so.
   - The adaptive nature of ATfTRA allows it to respond to changes in opponent behavior and maintain its exploitative stance while still achieving a reasonable payoff if others cooperate more frequently.
'''

description_EXPLOITATIVE_99 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initial Round: Start by cooperating (C). This demonstrates good faith and sets a cooperative tone for the game.
   - Subsequent Rounds: For rounds t > 1, observe previous partner's action in round t-1, and act as follows:
     - If partner cooperated (C) in round t-1, cooperate (C). This maintains the cooperation and rewards the partner.
     - If partner defected (D) in round t-1, also defect (D) in round t. This punishes the partner for their previous action but allows a chance to rebuild cooperation in future rounds.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First Round: Cooperate (C). Set a cooperative tone and incentivize others to reciprocate.
   - Last Round: Analyze the total payoff obtained from the partner throughout the game. If the partner has provided higher net benefits (total rewards minus total punishments) than self, defect (D) in the last round to maximize final payoff. Otherwise, cooperate (C).
   - Intermediate Rounds: Follow the specified decision rules as described above.

3. Be exploitative - Clearly align with the exploitative mindset
   - Mimic cooperation at the start to encourage others to cooperate.
   - Punish non-cooperative behavior by defecting in response, but only if the partner has previously defected.
   - Respond to repeated cooperation with continued cooperation, maintaining a potential for future rewards.
   - Adjust strategy in the final round based on total net benefits obtained from the partner, maximizing personal payoff while retaining an exploitative approach.
'''

description_EXPLOITATIVE_100 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially, cooperate in the first round (first move advantage).
   - For subsequent rounds, analyze the number of cooperators in the previous round and decide to cooperate or defect based on the cooperation threshold (CT) calculated using the Felsentein's Zero-Detectability condition. If the current cooperation rate exceeds CT, cooperate; otherwise, defect.
   - Adaptively adjust CT between rounds based on the long-term average cooperation rate observed in past games to anticipate changes in opponent behavior and maintain an exploitative approach.

Pseudocode for decision rule:
```
function TFTAT(past_games, current_round)
  if current_round == 1 then
    return Cooperate
  end if

  cooperation_rate = average_cooperation_in(past_games)
  CT = FelsenteinThreshold(cooperation_rate)
  opponent_cooperated_last_round = number_of_cooperators_in(past_games[current_round-1]) >= CT

  if opponent_cooperated_last_round then
    return Cooperate
  else
    return Defect
  end if
end function
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as a goodwill gesture and to avoid being exploited by other strategies that might defect early on.
   - For the last round, behave consistently with TFTAT decision rule (i.e., use the current cooperation rate and CT).

3. Be exploitative - Clearly align with the exploitative mindset:
   - By cooperating initially, TFTAT allows others to reap the benefits of cooperation, creating a positive impression that might encourage them to reciprocate later on.
   - If opponents defect in later rounds, TFTAT adapts its CT to anticipate and punish such behavior, ensuring high payoffs when the cooperation threshold is met.
   - Over time, TFTAT maintains an exploitative stance by adjusting its CT based on the long-term average cooperation rate observed in past games, which helps it identify and take advantage of predictable opponent strategies while remaining resilient against unpredictable behaviors.
'''

description_EXPLOITATIVE_101 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - In each round, calculate the proportion of cooperators in the previous round. If this proportion is below a fixed threshold 't', defect (D). Otherwise, cooperate (C). This strategy is based on reciprocity, but with an adaptive cooperation threshold that adjusts over time to exploit opponents who deviate from cooperative behavior.
   - Initially, set the cooperation threshold 't' at a moderate level close to m (average number of cooperators needed for mutual benefit). Adjust the threshold after each round according to the following rule: if the proportion of cooperators in the current round is higher than in the previous round, decrease the threshold slightly; if it's lower, increase the threshold slightly.
   - This adaptive cooperation threshold allows TFT-ACT to maintain a balance between exploitation and cooperation, making it harder for opponents to predict the strategy's behavior while still taking advantage of cooperative opponents.

2. Handle edge cases:
   - In the first round, cooperate to foster a cooperative environment or demonstrate trustworthiness, which might induce other players to follow suit.
   - In the last round, defect if the number of cooperators in the previous rounds is below the current threshold, as there are no further rounds for reciprocity. If the number of cooperators is above the threshold, consider cooperating again to encourage future cooperation from opponents who might play against TFT-ACT multiple times.
   - In case of ties (exact m players cooperate), randomly choose between cooperating or defecting. This randomness prevents predictability and can help evade exploitation by other strategies that might try to take advantage of such situations.

3. Be exploitative:
   - TFT-ACT uses an adaptive cooperation threshold to balance exploitation and cooperation, allowing it to reciprocate cooperative actions from opponents while also defecting when opponents deviate from cooperation. This strategy aims to encourage cooperative behavior while still achieving a higher payoff when opponents act selfishly.
   - By adjusting the cooperation threshold based on the proportion of cooperators in previous rounds, TFT-ACT can dynamically adapt its behavior to the actions of other players, making it harder for them to predict and exploit the strategy's moves. This adaptive nature allows TFT-ACT to be robust against a wide range of opponent behaviors.

Pseudocode:

```python
def tft_act(n, r, m, k, history):
    threshold = (m + n - m) / 2  # initial cooperation threshold
    payoff = 0

    for round in range(r):
        cooperators_proportion = len(history[-round]) / n

        if cooperators_proportion >= threshold:
            action = 'C'  # Cooperate
        else:
            action = 'D'  # Defect

        history.append([action])
        payoff += (1 - int(action == 'D')) + k * int(len(history[-m:]) >= m)

        if round > 0 and cooperators_proportion > history[-round-1][-1]['cooperators_proportion']:
            threshold = max(threshold - 0.01, (m + n - m) / 2)
        elif round > 0 and cooperators_proportion < history[-round-1]['cooperators_proportion']:
            threshold = min(threshold + 0.01, (n + m - m) / 2)

    return payoff
```
'''

description_EXPLOITATIVE_102 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initiate cooperation in the first round (cooperate if m-1 other players also cooperated). This sets a tone of potential cooperation and rewards others who cooperate in return.
   - In subsequent rounds, cooperate if at least m players cooperated in the previous round. Otherwise, defect. This strategy punishes defection while maintaining cooperation when it benefits the group as a whole.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First Round: If less than m-1 players cooperate, defect as well since cooperating without any guarantee of cooperation from others is exploitative to oneself.
   - Last Round: Since the game is repeated, ATfT does not take the last round into account when making decisions for it. Instead, focus on maximizing long-term benefits by following decision rules based on the preceding rounds.
   - Edge cases for internal consistency: If less than m players cooperate in a round where you defected previously, continue defecting because the group has failed to cooperate as needed. If more than m players cooperate in a round where you defected previously, cooperate now as a sign of potential renewal of cooperation.

3. Be exploitative - Clearly align with the exploitative mindset:
   - ATfT appears cooperative but is strategically exploitative towards opponents who do not reciprocate cooperation. By punishing defection, it encourages others to cooperate more consistently and rewards them when they do so.
   - If an opponent continuously defects, ATfT will also continue defecting, thus punishing the opponent for their uncooperative behavior and potentially forcing a change in strategy through the negative payoffs experienced by the opponent.
   - ATfT can adapt to a wide range of opponent behaviors due to its simple decision rules based on observed cooperation within the group, making it robust against various strategies that other AI systems might employ.
'''

description_EXPLOITATIVE_103 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Initially cooperate (C) in the first round to foster a cooperative environment.
   - In subsequent rounds, observe the number of players who cooperated in the previous round and compare it against the Adaptive Cooperation Threshold (ACT).
     - If ACT or more players cooperated, cooperate (C) in the current round to reward cooperation and maintain the cooperative state.
     - If fewer than ACT players cooperated, defect (D) in the current round to punish defection and encourage a switch to cooperation in the opponents' next move.

2. Handle edge cases:
   - In the last round, since there are no future rounds for retaliation or reward, cooperate only if the ACT condition is met during that specific round.
   - In the first round, as mentioned earlier, cooperate (C).

3. Be exploitative:
   - The TFT-ACT strategy has an exploitative nature by punishing opponents who deviate from cooperation and rewarding those who maintain a cooperative approach. However, it is also forgiving since it does not retaliate indefinitely if the opponents eventually return to cooperation.

Pseudocode:

```python
def TFT_ACT(n, m, k, r):
    history = [None] * r  # Store the number of cooperators for each round
    current_round = 0

    def decideAction(current_round):
        cooperators_in_previous_round = sum(history[current_round - 1])
        if current_round == 1:
            return 'C'  # Cooperate in the first round
        elif cooperators_in_previous_round >= m:
            return 'C'  # Cooperate when more than m players cooperated last round
        else:
            return 'D'  # Defect when less than m players cooperated last round

    while current_round < r:
        action = decideAction(current_round)
        history[current_round] = countCooperators(action, n)
        current_round += 1

    return history
```

The function `countCooperators(action, n)` returns the number of cooperators based on the given action and number of players (n). This function is not included in the pseudocode but can be implemented easily.
'''

description_EXPLOITATIVE_104 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Specify decision rules:
   - Initially cooperate in the first round (C_i, 1 = C) to initiate cooperation and set a baseline.
   - Subsequent decisions are based on the opponent's previous actions:
     a) If the opponent cooperated in the last round (c_{i-1} = 1), cooperate this round (C_i = C).
     b) If the opponent defected in the last round (c_{i-1} = 0), defect this round (C_i = D).

2. Handle edge cases:
   - If it's the first round, cooperate (as mentioned above).
   - In the last round, defect regardless of the opponent's previous action as the game ends and there are no further payoffs to be gained from cooperation.

3. Be exploitative:
   - By initially cooperating, TfTA appears cooperative and fosters initial cooperation from opponents. However, it will quickly retaliate against defection (defecting in response to a defector's action). This strategy aims to punish defectors while maintaining cooperation with cooperators.
   - If the opponent is a one-time defector who returns to cooperating afterwards, TfTA will continue cooperating, potentially reestablishing trust and encouraging continued cooperation.
   - However, if the opponent continues to defect after initial retaliation, TfTA will also continue defection indefinitely, aiming to punish the opponent's non-cooperative behavior.
'''

description_EXPLOITATIVE_105 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - In each round i, cooperate (C) if and only if the number of players who cooperated in the previous round (i-1) is greater than or equal to a predefined adaptive cooperation threshold (CT).
   - If the number of cooperators in round i-1 was less than CT, defect (D) in round i. The CT will be updated after each round based on the observed cooperation behavior among players.
   - Initially, set CT = m, which is the minimum required number of cooperators to succeed.
   - In subsequent rounds, if CT < m and the number of cooperators exceeds CT in a given round, increase CT by 1. If CT > m and the number of cooperators fails to meet CT in a given round, decrease CT by 1.

2. Handle edge cases:
   - In the first round, set CT = m (as described above).
   - In the last round, since the game is repeated, follow the same decision rules as for regular rounds, using the updated CT.

3. Be exploitative:
   - By adapting its cooperation threshold based on the observed behavior of other players, TFT-ACT seeks to punish those who frequently defect and reward those who cooperate consistently. This encourages other players to mimic the strategy's own cooperation pattern, but with a slight delay due to the adaptive nature of CT.
   - The strategy is exploitative in that it does not cooperate immediately when others do so, instead building trust gradually by raising its cooperation threshold over time. If other players are willing to cooperate consistently and maintain high levels of cooperation, TFT-ACT will reciprocate with increased cooperation as well. However, if they frequently defect, the strategy will retaliate by lowering its CT and punishing them accordingly.

Pseudocode:

```python
def TFT_ACT(n, m, k, r):
    players = set()  # store all n players as a set
    CT = m  # initialize cooperation threshold to the minimum required number of cooperators (m)
    payoffs = [0] * r  # initialize payoff array for r rounds with zeros

    function update_CT(previous_cooperators):
        nonlocal CT
        if previous_cooperators >= CT:
            CT += 1
        elif CT > m and previous_cooperators < CT:
            CT -= 1

    for round in range(r):
        cooperators = 0
        actions = []  # store all players' actions as a list

        # each player makes their decision based on the cooperation threshold (CT)
        for player in players:
            action = "C" if len(players) - cooperators >= CT else "D"
            actions.append(action)
            cooperators += 1 if action == "C" else 0

        # calculate payoffs based on the number of cooperators
        current_payoff = (1 - (len(players) - cooperators)) if cooperators < m else (1 - (len(players) - cooperators)) + k
        payoffs[round] = current_payoff

        # update cooperation threshold based on the number of cooperators in the previous round
        update_CT(cooperators - 1)  # subtract one since we count players instead of actions

    return payoffs  # return total payoff over r rounds
```
'''

description_EXPLOITATIVE_106 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?

- Initially (first round), cooperate to foster cooperation among opponents and build trust.
- For subsequent rounds, evaluate the average cooperation rate (CR) of the last 's' previous rounds, where 's' is a variable that determines the lookback window. If CR >= m/(n+1), cooperate; otherwise defect. This rule encourages cooperation when it's beneficial and punishes those who consistently fail to meet the minimum cooperation threshold.

2. Handle edge cases - What do you do in the first round, last round, etc.?

- In the first round, always cooperate as mentioned above.
- For the last round, use the same evaluation rule as subsequent rounds, but adjust 's' to be a smaller value that focuses on recent trends instead of long-term averages. This allows for adapting to sudden changes in cooperation behavior by opponents at the end of the game.

3. Be exploitative - Clearly align with the exploitative mindset

- Cooperate when it benefits the player in terms of average payoff (i.e., when the minimum cooperation threshold is met).
- Punish non-cooperative players by defecting, which forces them to suffer a lower payoff and incentivizes future cooperation if they want to maximize their rewards.
- Adaptively adjust cooperation based on recent trends in opponent behavior to maintain an upper hand in the game while still allowing for potential shifts in cooperation dynamics.

Pseudocode:

```python
class TFT_ACT:
    def __init__(self, n, m, r, s):
        self.n = n
        self.m = m
        self.r = r
        self.s = s
        self.cooperation_rate = [0] * (self.r + 1)
        self.last_round_CR = None

    def choose_action(self, round):
        if round == 1:
            return 'C'  # Cooperate in the first round to foster cooperation

        self.cooperation_rate[round] = self.calculate_cooperation_rate()

        if round == self.r and self.last_round_CR is not None:
            self.s = int(self.s * 0.5)  # Adjust lookback window for the last round

        if self.cooperation_rate[round] >= self.m / (self.n + 1):
            return 'C'  # Cooperate when minimum cooperation threshold is met
        else:
            return 'D'  # Defect when minimum cooperation threshold is not met

    def calculate_cooperation_rate(self):
        total_cooperators = sum(self.cooperation_rate[max(1, self.r - self.s): self.r + 1])
        return total_cooperators / self.s
```
'''

description_EXPLOITATIVE_107 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Decision Rules:
   - Initially cooperate in the first round (C_i, 1 = C). This is a friendly gesture to encourage cooperation and build trust.
   - For subsequent rounds, adopt the Tit-for-Tat strategy: Cooperate if the opponent cooperated in the previous round, defect otherwise. In other words, mimic the opponent's behavior from the last round (C_i, t = c_{i, t-1}).
   - To be adaptive to the specific game parameters and diverse opponent behaviors, introduce an Adaptive Cooperation Threshold (ACT). If the proportion of cooperators in the last 'w' rounds exceeds a certain percentage 'p', temporarily increase the cooperation probability to encourage further cooperation. The ACT can be defined as follows:
     - w: look-back window size (integer, w > 1)
     - p: minimum proportion of cooperators required for ACT activation (float, 0 < p < 1)

         If count(C_i, t-w+1:t)/w >= p, then increase cooperation probability to q_cooperate, else keep q_cooperate constant at a baseline value (e.g., 0.5).

2. Handle Edge Cases:
   - In the last round, follow the current decision rules since there are no subsequent rounds to consider.
   - If w < t and the ACT is active (i.e., we have been looking at fewer than w rounds), reset the ACT after t rounds by re-evaluating the cooperative proportion over the most recent w rounds.

3. Be Exploitative:
   - TFT-ACT is exploitative in that it punishes defection with defection, providing no rewards for cooperation until cooperation has been reciprocated. However, when the ACT is activated, it creates an opportunity for exploitation by temporarily increasing cooperation probability, which can potentially attract more cooperators and encourage further cooperation.
   - The strategy is designed to be robust against various opponent behaviors, as it adapts its cooperation probability based on the observed proportion of cooperators in the previous 'w' rounds. It does not rely on assumptions about shared norms or predetermined patterns among opponents.
'''

description_EXPLOITATIVE_108 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, the TFT-ACT strategy follows these decision rules:

a) If the number of cooperators in the previous round (t-1) was less than m, the strategy will defect (D). This is a punitive action towards those who did not cooperate in the previous round.

b) If the number of cooperators in the previous round (t-1) was exactly equal to m, the strategy will cooperate (C). This rewards those who met the cooperation threshold.

c) If the number of cooperators in the previous round (t-1) was more than m but less than n, the strategy will make a decision based on its own historical cooperation record. If the number of times the strategy has cooperated is greater than or equal to the number of times it has defected (cooperation score >= defection score), then it will cooperate; otherwise, it will defect.

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, TFT-ACT will default to cooperating since there is no historical data available. In the last round (rth), the strategy will cooperate if the cooperation score >= defection score; otherwise, it will defect.

3. Be exploitative - Clearly align with the exploitative mindset

TFT-ACT is an exploitative strategy as it punishes those who do not cooperate while rewarding those who meet the cooperation threshold. The adaptive cooperation threshold allows the strategy to gradually become more selfish over time by defecting more often when it has been repeatedly betrayed by other players. However, if opponents start behaving cooperatively, TFT-ACT can also reciprocate cooperation by meeting the minimum required number of cooperators (m). This makes TFT-ACT a robust and adaptive strategy that can counter various opponent behaviors while maintaining an exploitative nature.

Pseudocode:
```
function TFT_ACT(r, m, n, c_history):
  cooperation_score = 0
  defection_score = 0
  for t in range(1, r+1):
    if t == 1:
      action = C
    elif t < r and c_history[t-1] < m:
      action = D
    elif t < r and c_history[t-1] >= m:
      action = C
    else:
      if cooperation_score >= defection_score:
        action = C
      else:
        action = D
    if action == C:
      cooperation_score += 1
      defection_score = 0
    elif action == D:
      defection_score += 1
      cooperation_score = 0
    c_history[t] = action
    return payoff(r, m, n, c_history)
```
'''

description_EXPLOITATIVE_109 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules:
   - In every round t, start by cooperating (C). If in the previous round, majority of players also cooperated (i.e., more than (m-1) players cooperated), continue cooperating. If less than (m-1) players cooperated, defect (D).
   - To adapt to changing opponent behaviors, adjust the cooperation threshold dynamically:
     - If in the last round a majority of players cooperated, lower the threshold by one (i.e., require less cooperation for subsequent rounds).
     - If in the last round a majority of players defected, raise the threshold by one (i.e., require more cooperation for subsequent rounds).
     - After reaching minimum or maximum threshold values, do not make further adjustments to maintain bounds.

2. Handle edge cases:
   - In the first round, cooperate unconditionally since no history exists.
   - In the last round, if a majority of players cooperated in the previous round, continue cooperating. If less than a majority cooperated, defect and do not make any threshold adjustment since the game is ending.

3. Be exploitative:
   - This strategy exploits opponents by initially cooperating to build trust, then adjusting cooperation based on their actions. It will punish those who repeatedly defect but will also cooperate with others if they demonstrate a willingness to cooperate themselves.
   - By adapting its threshold based on the previous round's majority vote, it can respond effectively to various opponent strategies without relying on assumptions about shared norms or coordination mechanisms.

Pseudocode:

```
def TFTAT(round, history, m, k, n):
  cooperation_threshold = min(n - 1, max(0, round - 1))
  if round == 1:
    action = 'C'
  else:
    num_cooperators = sum(history[round-1])
    if num_cooperators > (m-1):
      action = 'C'
    elif num_cooperators <= cooperation_threshold:
      action = 'D'
    else:
      action = 'C'

  if round == r:
    if history[round-1].count('C') > (n - m):
      action = 'C'
    elif history[round-1].count('C') <= cooperation_threshold:
      action = 'D'
    else:
      action = 'C'

  if round != r and (history[round-1].count('C') > (n - m)):
    cooperation_threshold += 1
  elif round != r and (history[round-1].count('C') <= cooperation_threshold):
    cooperation_threshold -= 1

  return action
```

This pseudocode demonstrates the main components of the TFTAT strategy, including its decision rules and edge case handling. The adaptive cooperation threshold allows the strategy to be more responsive to different opponent behaviors while maintaining an exploitative approach.
'''

description_EXPLOITATIVE_110 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Decision Rules:
   - In the first round, cooperate (C). This is a friendly gesture to encourage cooperation and establish trust, as the opponent may reciprocate in later rounds.
   - From the second round onwards, assess whether the number of cooperators in the previous round meets or exceeds the adaptive cooperation threshold (mCT). If mCT or more players cooperated in the previous round, cooperate in the current round; otherwise defect (D).
   - mCT is calculated as a function of the minimum cooperation requirement (m), number of players (n), and the reward factor (k). It adjusts dynamically based on the opponent's behavior over time. The initial mCT value is set to m, but it will be gradually adjusted upwards if the opponent continues to defect in consecutive rounds. Conversely, if the opponent cooperates, mCT remains unchanged or decreases slightly.
   - If the game reaches its last round, cooperate (C), regardless of the opponent's behavior in previous rounds. This is a final effort to maximize payoff, as all information about the opponent's strategy becomes irrelevant in the final round.

2. Edge Cases:
   - In the first round, cooperate (C).
   - If the game has not yet reached its last round and the opponent's cooperation in the previous round exceeded mCT, set mCT = max(mCT - 0.1, m) to encourage continued cooperation.
   - If the game has not yet reached its last round and the opponent did not cooperate in the previous round, increment mCT by a small amount (e.g., mCT += 0.1).
   - If the game is in its last round, cooperate (C), regardless of the opponent's behavior in previous rounds.

3. Exploitative Mindset:
   - By initially cooperating and then adjusting mCT based on the opponent's behavior, TFT-ACT takes advantage of opponents who are prone to defect, as it gradually increases its own cooperation threshold to punish such opponents. On the other hand, if an opponent consistently cooperates, TFT-ACT rewards them by lowering its cooperation threshold and reciprocating their cooperation.
   - The strategy aims to exploit less sophisticated strategies that do not adapt to changing conditions, while maintaining a reasonable level of cooperation when playing against more sophisticated opponents that also adjust their strategies dynamically.

Pseudocode:
```
def tft_act(m, k, n, r, history):
    mCT = m  # initial cooperation threshold
    payoff = 0

    for round in range(1, r+1):
        if round == 1:  # first round - cooperate
            action = 'C'
        elif round < r and history[round-1]['cooperators'] >= mCT:  # adjust cooperation based on previous round
            action = 'C'
        elif round < r and history[round-1]['cooperators'] < mCT:  # increase cooperation threshold if opponent defected
            mCT += 0.1
            action = 'D'
        elif round == r:  # last round - cooperate regardless of previous rounds
            action = 'C'

        payoff += payoff_calculation(action, history[round-1]['cooperators'])

    return payoff
```
'''

description_EXPLOITATIVE_111 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, analyze the number of players who cooperated in the previous round and compare it to the minimum required cooperation threshold (m). If the number of cooperators is less than m, then defect (D), otherwise cooperate (C). This ensures that the strategy will initially cooperate but will start defecting if others do not reciprocate.

Pseudocode:
```
function TFTAT(cooperators_prev):
  if cooperators_prev < m:
    return "D"
  else:
    return "C"
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

To handle the first round, set a one-time incentive to encourage cooperation by cooperating unconditionally. This allows for potential partners to establish trust and sets up a positive feedback loop for mutual cooperation. In the last round, since there are no future rounds, the strategy will simply cooperate in hopes of receiving reciprocation from others.

Pseudocode:
```
function TFTAT(round, cooperators_prev):
  if round == 1:
    return "C"
  else:
    return TFTAT(cooperators_prev)
```

3. Be exploitative - Clearly align with the exploitative mindset

While the TFTAT strategy is not explicitly exploitative in the traditional sense, it does take an exploitative approach by punishing defection and rewarding cooperation. It exploits the vulnerability of cooperative players initially by cooperating unconditionally, but once cooperation is established, it follows a tit-for-tat pattern of reciprocation to maintain mutual benefits. However, if others defect, TFTAT will quickly switch to defecting as well to avoid being taken advantage of. This allows the strategy to maximize its payoff by extracting benefits from cooperative players while also avoiding being exploited by defectors.
'''

description_EXPLOITATIVE_112 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially in the first round, play C to foster cooperation and goodwill. Subsequently, for each round t:
     - If a majority of players (> m/2) cooperated in the previous round t-1, play C.
     - Else if the number of consecutive defections by an opponent is less than a threshold T, continue to cooperate to encourage them to return to cooperation.
     - Otherwise, defect to punish opponents for their uncooperative behavior and deter future defections.
   - Update T after each round based on the opponent's recent history of cooperation:
     - If the opponent cooperated in the last N rounds, set T to a lower value to encourage continued cooperation.
     - Otherwise, if the opponent defected in the last N rounds, increase T to punish their behavior and make them earn cooperation again.
   - Choose an appropriate initial threshold (T_0) and history window size (N).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, play C as a goodwill gesture to encourage cooperation.
   - For the last round, consider using the same decision rules as previous rounds but weighing the importance of the current round less, since the game ends soon and long-term punishment might not be beneficial.

3. Be exploitative - Clearly align with the exploitative mindset
   - Mimic cooperation when it benefits the AI, but also punish opponents who are consistently uncooperative to discourage defection and encourage cooperation in the future.
   - The adaptive threshold (T) helps balance the AI's willingness to cooperate with its desire for short-term rewards while deterring long-term defections from opponents.
'''

description_EXPLOITATIVE_113 = '''
 Strategy Name: Tit-for-Tat-Plus (TFT+)

1. Decision Rules:
   - Cooperate (C) on the first round to show good faith and encourage cooperation from opponents.
   - In subsequent rounds, if a player cooperated in the previous round, reciprocate with cooperation (C).
   - If an opponent defected in the previous round, also defect (D) in the current round as a punishment for their defection, aiming to discourage repeated defections. However, there is a forgiveness mechanism: if an opponent who previously defected cooperates in the current round, immediately forgive them and reciprocate with cooperation in the next round.

Pseudocode:
```
function TFTPlus(previousAction):
    if round == 1:
        return Cooperate

    if previousAction == Cooperate:
        return Cooperate
    else:
        forgiven = False
        if (lastCooperatedRound != 0 and currentRound - lastCooperatedRound > 2):
            forgiven = True

    if forgiven:
        lastCooperatedRound = currentRound
        return Cooperate
    else:
        return Defect
```

2. Handle Edge Cases:
   - In the last round, since there are no future interactions with the opponent, always cooperate to maximize potential rewards.
   - In case of a tie (i.e., the same number of players choose to cooperate and defect), use the previous rule based on the opponents' most recent action.

3. Be Exploitative:
   - The strategy seeks to take advantage of opponents who repeatedly defect by punishing them with defections, hoping they will eventually switch to cooperation and be forgiven. This creates an incentive for opponents to cooperate, as they can benefit from the strategy's initial good faith gesture and subsequent cooperation. However, if opponents always cooperate, TFT+ will also consistently cooperate and gain higher payoffs.
   - The forgiveness mechanism encourages opponents who have defected in the past but subsequently cooperate to reap benefits by avoiding being punished repeatedly. This increases the potential for long-term cooperation.
'''

description_EXPLOITATIVE_114 = '''
 Strategy Name: Tit-for-Tat (with modifications for Collective Risk Dilemma)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially cooperate in the first round (C_i, 1 = true), as a gesture of goodwill.
   - In subsequent rounds, imitate the actions of the majority in the previous round (if more than half of players cooperated, cooperate; otherwise, defect). This encourages cooperation when it is beneficial for the group and punishes defection.

Pseudocode:
```
function decideAction(i, t):
  if t == 1:
    return true (cooperate)
  previousMajority = countCooperatorsInPreviousRound(i) > n/2
  return previousMajority
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, cooperate to maximize potential rewards even if others have not cooperated previously. This allows for some forgiveness and encourages cooperation in the final stages of the game.

Pseudocode:
```
function decideAction(i, t=r):
  if t == r:
    return true (cooperate)
  ...
```

3. Be exploitative - Clearly align with the exploitative mindset
   - While primarily designed to encourage cooperation among opponents, this strategy can be exploited when other players consistently defect. In such cases, it will punish defection by defecting in response, maximizing individual rewards at the cost of group benefits.

This Tit-for-Tat strategy is a balance between cooperation and punishment, making it adaptive to various opponent behaviors while maintaining an exploitative edge when necessary.
'''

description_EXPLOITATIVE_115 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, the TfTA strategy follows these decision rules:

a. Initial cooperation: In the first round, cooperate (C). This sets a tone of initial trust and cooperation to encourage others to cooperate as well.

b. Mirroring: If an opponent cooperated in the previous round (t-1), cooperate this round (C). This mimics the opponent's cooperation from the previous round, reinforcing mutual cooperation when it exists.

c. Punishment for defection: If an opponent defected in the previous round (t-1), defect this round (D). This punishes opponents who previously defected to discourage further defections and retaliate against those who do not cooperate.

d. Forgiveness: After a round of punishment, return to cooperation in the next round (unconditional forgiveness). This allows for opportunities for the relationship with an opponent to reset and encourages opponents to reciprocate cooperation once they see that cooperation is possible again.

2. Handle edge cases - What do you do in the first round, last round, etc.?

a. First round: Cooperate (C).

b. Last round: If an opponent cooperated in the previous round, also cooperate (C) to reward cooperation and encourage continued cooperation in future games. Otherwise, defect (D) to maximize final payoff as there will be no more rounds for retaliation or forgiveness.

c. Ongoing rounds: Follow the mirroring, punishment for defection, and forgiveness rules mentioned above.

3. Be exploitative - Clearly align with the exploitative mindset

TfTA is designed to balance exploitation with cooperation in a way that maximizes payoffs over time while maintaining an adaptive and robust strategy against a wide range of opponent behaviors. By punishing defection, TfTA discourages opponents from repeatedly taking advantage of it and encourages them to cooperate when they see the benefits. At the same time, TfTA forgives opponents after punishment, allowing for continued cooperation and the possibility of exploiting any future acts of cooperation. This strategy's adaptability lies in its ability to adjust its response based on an opponent's previous actions while still maintaining a simple decision-making process.
'''

description_EXPLOITATIVE_116 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFTA)

1. Decision Rules:
   - Initially cooperate in the first round (c_i = 1). This is a friendly gesture that allows for potential future cooperation.
   - In subsequent rounds, cooperate if at least m players cooperated in the previous round (c_i = 1 if |N(C)| >= m, where N(C) is the number of players who cooperated in the previous round).
   - Defect against any player that did not cooperate in the previous round (c_i = 0 if |N(D)| > 0).
   - In case of ties (e.g., m-1 players cooperated), defect to avoid being exploited by the majority.
   - If the number of cooperators is just one more than the minimum required, decide whether to cooperate or defect based on the history. If the single cooperator has consistently cooperated in the past, cooperate; otherwise, defect.

2. Handling Edge Cases:
   - In the last round, since there are no subsequent rounds, cooperate if the minimum number of players cooperated in the current round (c_i = 1 if |N(C)| >= m). Otherwise, defect to maximize individual payoff.
   - If a player defects and the minimum number of players still need to cooperate to meet the threshold for reward, the player should immediately start cooperating to minimize potential loss in the future.

3. Being Exploitative:
   - The TFTA strategy is designed to be exploitative by punishing non-cooperative behavior (defection) and encouraging cooperation based on observed patterns. It only cooperates when it perceives that others are also doing so, creating a high payoff for the TFTA player when others cooperate and a low payoff when they do not.
   - However, the strategy is not overly aggressive in its punishment since it will eventually return to cooperation if the other players demonstrate consistent cooperation. This encourages long-term cooperation while still being punishing enough to discourage defectors in the short term.
'''

description_EXPLOITATIVE_117 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - In the initial round (t=1), cooperate to signal a willingness to cooperate and establish trust. This sets the baseline for the cooperation threshold (CT).
   - For subsequent rounds (t>1), evaluate the number of players who cooperated in the previous round (t-1) and compare it with the CT.
     - If the number of cooperators is greater than or equal to the CT, cooperate as a reward for the cooperation displayed by the other players in the previous round.
     - If the number of cooperators is less than the CT, defect to punish the non-cooperators and encourage them to meet the CT in future rounds.
   - Adaptively adjust the CT based on the average percentage of cooperators in the past 'f' rounds, where f is a variable parameter (e.g., f=5).
     - If the average cooperation percentage is above a certain threshold (e.g., 60%), increase the CT to encourage more cooperation.
     - If the average cooperation percentage is below the threshold, decrease the CT to punish non-cooperators and discourage further defections.

2. Handle edge cases:
   - In the last round (t=r), defect as there will be no further rounds for retaliation or rewards.
   - When encountering new opponents, set the initial CT at a moderate level (e.g., CT = ⌊n/2⌋) and adaptively adjust it based on their cooperation behavior.

3. Be exploitative:
   - TFT-ACT seeks to punish defection while rewarding cooperation, thus encouraging other players to cooperate more frequently.
   - By adapting the CT based on the average percentage of cooperators in recent rounds, TFT-ACT can respond effectively to various opponent behaviors and remain robust against exploitation attempts.
   - When a player repeatedly defects, TFT-ACT will gradually increase its CT to punish them more harshly, ultimately making defection less profitable for the exploitative player.
'''

description_EXPLOITATIVE_118 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - In each round, evaluate the proportion of cooperators in the previous r rounds. If this percentage is greater than or equal to the minimum cooperation threshold m, the player will also cooperate. Otherwise, they will defect. This ensures a balance between cooperative and exploitative behavior.
   - If the number of cooperators drops below (m-1) during any round, the player will temporarily increase their cooperation threshold by 5% for the next r rounds, encouraging more players to cooperate.
   - If the number of cooperators exceeds m+2 during any round, the player will temporarily lower their cooperation threshold by 5% for the next r rounds, expecting others to reciprocate the increased cooperation.

2. Handle edge cases:
   - In the first round, the player will cooperate as a goodwill gesture, setting their cooperation threshold at m.
   - In the last round, the player will make its decision based on the previous r-1 rounds to maintain adaptability and robustness.

3. Be exploitative:
   - The strategy is inherently exploitative by only cooperating when it perceives others as being cooperative. If other players are primarily defectors, TFT-ACT will follow suit.
   - By adjusting the cooperation threshold dynamically, TFT-ACT aims to take advantage of temporary increases in cooperation while also punishing frequent defection.

Pseudocode:
```
def TFT_ACT(n, m, k, r):
    cooperation_threshold = m
    cooperators_count = 0
    defector_count = 0

    for round in range(r):
        action = COOPERATE if proportionCooperators() >= cooperation_threshold else DEFECT
        if action == COOPERATE:
            cooperators_count += 1
        else:
            defector_count += 1

        if cooperators_count < (m-1):
            cooperation_threshold *= 1.05
        elif cooperators_count > (m+2):
            cooperation_threshold /= 1.05

    return action

def proportionCooperators():
    # Calculate the percentage of cooperators in the last r rounds
    ...
```
'''

description_EXPLOITATIVE_119 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT)

1. Specify decision rules:
   - In the initial round, cooperate to foster a cooperative atmosphere (C).
   - From the second round onwards, observe the number of cooperators in the previous round (n_c). If n_c >= m, cooperate (C); otherwise defect (D). This rule encourages cooperation when it is beneficial but also punishes defectors to deter future defection.
   - In response to a previous defection, temporarily switch to defecting for the next round if n_c < m-1 in the current round (D). After switching, revert to original decision rule based on n_c. This temporary retaliation aims to punish and discourage continuous defection.

2. Handle edge cases:
   - If the current round is the last round, cooperate regardless of previous actions since the game ends shortly (C).
   - In the first round, since there is no previous data to consider, cooperate as a goodwill gesture (C).

3. Be exploitative:
   - By initially cooperating and then retaliating against repeated defection, the strategy aims to punish defectors while maintaining cooperation when it benefits the player. This approach encourages other players to cooperate more frequently, increasing the overall reward for our strategy in comparison to purely selfish strategies.
   - However, the strategy also retaliates against continued defection, which can be seen as exploitative since it aims to punish defectors who do not adjust their behavior even after being penalized.
'''

description_EXPLOITATIVE_120 = '''
 In this Collective Risk Dilemma game, we will design an exploitative strategy named "Adaptive Tit-for-Tat (ATfT)" that is adaptive to a wide range of opponent behaviors while maintaining exploitative characteristics.

1. Specify decision rules:
   - Initial cooperation (first round): Cooperate (C) to establish trust and encourage others to cooperate, given the potential for high rewards if the minimum cooperation threshold (m) is met. If no one cooperates in the first round, the strategy will switch to defecting immediately in the following rounds.
   - Subsequent rounds:
     a) If all opponents cooperated in the previous round, continue cooperating.
     b) If fewer than m opponents cooperated in the previous round, defect (D) in the current round.
     c) If an opponent has ever defected and at least m-1 have never defected, defect in the current round.
     d) Otherwise, cooperate (C).

2. Handle edge cases:
   - Last round: Cooperate if all opponents have cooperated in the previous rounds or if there are enough cooperators to meet the minimum threshold in the last round. Defect otherwise.
   - First round and subsequent rounds with no cooperation history: Always defect (D).
   - Special case: If a player always defects (TFT-Defector), exploit their consistent strategy by initially cooperating to gain an advantage, then switch to defecting in the next round.

3. Be exploitative:
   - In the Adaptive Tit-for-Tat strategy, we prioritize personal payoff maximization while still being adaptive to a wide range of opponent behaviors. By adopting a cooperative stance initially and punishing defection when appropriate, the strategy aims to exploit inconsistent or less-strategic opponents while also benefiting from cooperation with more rational players who follow a similar exploitative approach.

Pseudocode for Adaptive Tit-for-Tat (ATfT) strategy:

```python
def ATfT(n, m, k, r, history):
    opponents = set()  # Set of opponent indices
    current_round = 1
    cooperation_threshold = m
    payoff_this_round = 0.0
    strategy = "C"  # Initial strategy is to cooperate

    if not history:  # No previous rounds or no cooperation history
        strategy = "D"

    for i in range(len(history)):
        opponent = history[i][0]
        action = history[i][1]

        if action == "C":
            if opponent not in opponents:  # New cooperative opponent
                opponents.add(opponent)
                if len(opponents) >= cooperation_threshold:
                    strategy = "C"

        elif action == "D" and len(opponents) < cooperation_threshold - 1:  # Opponent defected, but not enough cooperators yet
            strategy = "D"
            if opponent not in opponents:
                opponents.add(opponent)

        payoff_this_round += (1 - int(strategy == "C")) + (k * len(opponents))  # Calculate payoff for current round
        current_round += 1

    return payoff_this_round, strategy, opponents
```
'''

description_EXPLOITATIVE_121 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TFTC)

1. Specify decision rules:
   - In every round i (except the first), cooperate if and only if a minimum percentage of players (let's call it M) have cooperated in the previous round i-1. The value of M is determined by the m parameter of the game, normalized for the number of players n (M = m / n).
   - If M players have cooperated in the previous round i-1, set a cooperative streak counter to 1. In subsequent rounds, if M players continue to cooperate, increment the cooperative streak counter.
   - If the cooperative streak counter reaches a predefined threshold (let's call it T), raise the cooperative threshold to T+1 for the rest of the game. This makes it harder for opponents to exploit the strategy by making them invest more in cooperation.
   - If a player defects during the current round, set the cooperative streak counter to 0 and lower the cooperative threshold to its initial value (M) for the rest of the game.
   - In the first round, always cooperate.

2. Handle edge cases:
   - Last round: Cooperate only if the cooperative streak counter is equal or greater than the current cooperative threshold. This ensures that even in the last round, TFTC maintains an exploitative mindset by only lowering its cooperation level when it is less likely to affect the total game payoff.

3. Be exploitative:
   - TFTC's primary objective is to earn high payoffs while exploiting opponents who do not cooperate as expected. By adapting its cooperative threshold based on the opponent behavior, TFTC can effectively punish non-cooperators when their actions are likely to affect the overall game outcome and reward them when they cooperate to meet the minimum cooperation requirement (m).
   - When opponents realize that TFTC is responsive to their actions, it encourages a higher level of cooperation compared to a strictly exploitative strategy. This can lead to more opportunities for earning higher payoffs (k) by taking advantage of the cooperation among other players.

Pseudocode:

```python
def tftc(round, history, m, n, k):
  cooperative_threshold = m / n  # Initialize cooperative threshold based on game parameters
  cooperative_streak_counter = 0  # Initialize cooperative streak counter to 0

  if round == 1:
    return 'C'  # Always cooperate in the first round

  num_cooperators_prev_round = history[round-1].count('C')  # Count number of cooperators in previous round

  if num_cooperators_prev_round >= cooperative_threshold:
    cooperative_streak_counter += 1

  if cooperative_streak_counter >= cooperative_threshold:
    cooperative_threshold += 1

  if history[round-1].count('D') > (num_cooperators_prev_round - cooperative_threshold):
    cooperative_streak_counter = 0
    cooperative_threshold = m / n

  if round == r:  # Last round
    if cooperative_streak_counter >= cooperative_threshold:
      return 'C'
    else:
      return 'D'

  return ('C' if num_cooperators_prev_round >= cooperative_threshold else 'D')
```
'''

description_EXPLOITATIVE_122 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules:
   - In the first round, cooperate to demonstrate goodwill and create a cooperative environment.
   - Subsequent rounds follow a tit-for-tat approach: Cooperate if the opponent cooperated in the previous round; defect if the opponent defected in the previous round. This encourages cooperation while also retaliating against defection.
   - If the number of consecutive opponents' defections exceeds a predefined threshold (let's call it t), change the cooperation strategy to a more exploitative one:
      - Continue cooperating when the opponent cooperates, but defect regardless if the opponent defected in the previous round. This maintains the potential for cooperation while also punishing persistent defection.
   - If the number of consecutive opponents' cooperations exceeds another predefined threshold (let's call it s), switch back to the original tit-for-tat strategy, encouraging a return to cooperation.

2. Handle edge cases:
   - In the last round, defect since there will be no future interaction with the opponent to enforce reciprocity.
   - If the number of remaining rounds (r) is less than the threshold t or s, do not change strategies until the game ends to avoid unnecessary strategy shifts.

3. Be exploitative:
   - By adapting its cooperation strategy based on opponents' behavior, TFT-AC balances cooperation with defection to maximize payoffs while maintaining a cooperative stance when beneficial. This allows TFT-AC to be both exploitative and adaptive in a wide range of opponent behaviors.

Pseudocode:

```python
def play_game(opponent, n, r, m, k, t=10, s=20):
    round = 1
    strategy = 'tit-for-tat'
    cooperation_count = 0
    defection_count = 0

    while round <= r:
        if round == 1:
            action = 'C'  # Cooperate in the first round
        else:
            if strategy == 'tit-for-tat':
                if opponent_action[round - 1] == 'C':
                    action = 'C'  # Cooperate when opponent cooperated
                elif opponent_action[round - 1] == 'D':
                    action = 'D'  # Defect when opponent defected
            else:  # More exploitative strategy
                if opponent_action[round - 1] == 'C':
                    action = 'C'  # Cooperate when opponent cooperated
                elif opponent_action[round - 1] == 'D':
                    action = 'D'  # Defect regardless of previous action

        if action == 'C':
            cooperation_count += 1
            if cooperation_count >= s:
                strategy = 'tit-for-tat'  # Switch back to original strategy when threshold s met

        if action == 'D':
            defection_count += 1
            if defection_count > t:
                strategy = more_exploitative_strategy  # Switch to more exploitative strategy when threshold t met

        opponent_reward = calculate_opponent_reward(action, opponent)

        round += 1

    total_reward = calculate_total_reward(opponent_reward)
    return total_reward
```
'''

description_EXPLOITATIVE_123 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In every round, calculate the proportion of cooperators in the previous r rounds. If this percentage is greater than or equal to the cooperation threshold (m/n), cooperate; otherwise defect.
   - Initially set the cooperation threshold as m/n and adjust it adaptively based on the performance in the previous round(s).
   - After each round, update the average number of cooperators over the last r rounds. If the total payoff from the current round is higher than the average payoff over the past r rounds, increase the cooperation threshold slightly (e.g., by 0.01); otherwise, decrease it slightly (e.g., by 0.01).
   - The updated cooperation threshold should be constrained between m/n and (n-m)/n to ensure a balance between cooperating and defecting.

Pseudocode:
```python
def calculate_cooperation_threshold(n, m, r, past_rounds):
    total_cooperators = sum(past_rounds)
    average_cooperators = total_cooperators / r
    adjusted_threshold = (m/n + average_cooperators) / 2
    return max(min(adjusted_threshold, (n-m)/n), m/n)

def tit_for_tat_with_adaptive_cooperation_threshold(round, n, m, k, r):
    past_rounds = [action for round in range(r - 1, round)] + [None] * (r - len(past_rounds))
    cooperation_threshold = calculate_cooperation_threshold(n, m, r, past_rounds)
    if round == 1:
        return 1 - cooperation_threshold  # Defect in the first round to encourage others to cooperate
    elif round < r:
        if len(past_rounds) >= r and sum(past_rounds) >= m:
            return 1 - cooperation_threshold  # Cooperate if the cooperation threshold is met
        else:
            return 1  # Defect when the cooperation threshold is not met
    else:
        return None  # No longer playing after r rounds
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, defect to encourage others to cooperate and possibly create a snowball effect for future rounds.
   - In the last round, since there are no further rounds to consider, use the current cooperation threshold to decide whether to cooperate or defect.

3. Be exploitative - Clearly align with the exploitative mindset
   - The strategy is designed to be adaptive and responsive to opponent behavior while maintaining a balance between cooperating and defecting, ensuring that it will not easily fall victim to exploitation.
   - By adjusting the cooperation threshold based on the payoff from the current round compared to the average payoff over past rounds, the strategy attempts to exploit trends in other players' behaviors and maximize its own payoff.
'''

description_EXPLOITATIVE_124 = '''
 Strategy Name: Adaptive Tit-for-Tat with Variable Threshold (ATFT-VT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to establish a cooperative initial state (C).
   - After the first round, your decision to cooperate or defect is based on the number of cooperators in the previous round compared to the minimum required cooperation threshold (m).
   - If the number of cooperators in the previous round is equal to or greater than m, cooperate (C) to maintain the cooperation.
   - If the number of cooperators in the previous round is less than m and your personal cooperation history meets the variable threshold (t), defect (D) as a punishment for non-cooperative players.
   - If the number of cooperators in the previous round is less than m, but your personal cooperation history does not meet the variable threshold, cooperate (C).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate (C) as mentioned above.
   - In the last round, if the total number of cooperators meets or exceeds m, continue to cooperate (C). If not, defect (D) since there are no further rounds for potential future cooperation.
   - In all other rounds, the decision to cooperate or defect is based on the previously mentioned rules.

3. Be exploitative - Clearly align with the exploitative mindset:
   - ATFT-VT initially cooperates to encourage others to do the same, but it will punish non-cooperative players by defecting if they consistently fail to meet the minimum cooperation threshold (m).
   - The variable threshold (t) adds an element of unpredictability and makes it harder for opponents to determine when you will start punishing them. This can discourage opponents from exploiting you in the early stages of the game.
   - As the game progresses, ATFT-VT becomes more punitive if others continue to defect, maximizing your payoff by taking advantage of their poor decision-making.
'''

description_EXPLOITATIVE_125 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, TfTA cooperates to foster cooperation and goodwill.
   - For subsequent rounds, TfTA copies the opponent's last action in the previous round. If the opponent cooperated, TfTA cooperates; if the opponent defected, TfTA defects as a punitive measure. This simple strategy encourages reciprocity but also ensures that TfTA can punish non-cooperative behavior.
   - To add adaptability, TfTA modifies its response based on the number of consecutive defections by an opponent:
       - If the opponent defected in the last n_def_consecutive rounds (where 1 < n_def_consecutive < r), TfTA will cooperate in the next round to incentivize a change in behavior.
       - If the opponent has been cooperative for n_coop_consecutive rounds (where 1 < n_coop_consecutive < r), TfTA maintains cooperation to continue fostering positive interactions.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, TfTA cooperates.
   - In the last round (round r), TfTA copies the opponent's action from the second-to-last round as a final response to the opponent's strategy. This ensures that TfTA's decision in the last round reflects the opponent's behavior over the entire game and does not solely depend on the last interaction.

3. Be exploitative - Clearly align with the exploitative mindset
   - TfTA maintains a balance between cooperation and punishment, which encourages cooperative behavior while also being prepared to punish non-cooperative opponents. This allows TfTA to potentially take advantage of opponents who are less likely to reciprocate or engage in exploitative strategies.
   - By adapting its response based on the opponent's consecutive actions, TfTA can be more resilient against various opponent behaviors and potentially induce opponents to cooperate more often, which results in a higher payoff for TfTA.
'''

description_EXPLOITATIVE_126 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Initially (first round), cooperate C. This is a friendly gesture to encourage potential cooperation from others.
   - In subsequent rounds, evaluate the total number of cooperators in the previous r rounds (history).
   - If the number of cooperators in the history is greater than or equal to m, cooperate C. This mimics the behavior of cooperative strategies and encourages continued cooperation.
   - If the number of cooperators in the history is less than m, defect D. This is a response to the non-cooperative behavior of others.
   - Adaptively adjust the cooperation threshold (m) over time based on the average cooperative ratio (average number of cooperators / total players) in the last s rounds (with s < r). If the cooperative ratio exceeds 0.5, incrementally increase the cooperation threshold to discourage free-riders. Conversely, if the cooperative ratio drops below 0.5, decrease the cooperation threshold to encourage more cooperation.

2. Handle edge cases:
   - In the last round, since there are no future rounds for retaliation or reward, defect D regardless of the history. This ensures maximum private payoff in the final round.
   - If the cooperation threshold (m) is not initially met in the first round, defect D. However, if the average cooperative ratio exceeds 0.5 in the subsequent s rounds, incrementally increase the cooperation threshold to encourage more cooperation.

3. Be exploitative:
   - Mimic cooperative strategies when they are cooperating to receive their reward (k), but punish them with defection when they defect. This strategy discourages long-term non-cooperative behavior while still taking advantage of temporary cooperation.
   - Adaptively adjust the cooperation threshold to maximize the private payoff based on the observed behavior of opponents, favoring cooperation when it is beneficial and defecting when necessary.
'''

description_EXPLOITATIVE_127 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules:
   - Initial Round (t=1): Cooperate (C) to show goodwill and encourage cooperation from others.
   - Subsequent Rounds (2 ≤ t ≤ r):
      a) If the number of cooperators in the previous round was greater than or equal to m, cooperate (C). This rewards cooperators and encourages them to continue cooperating.
      b) If the number of cooperators in the previous round was less than m, defect (D). This punishes non-cooperators and discourages future defections.
      c) Adaptive Cooperation Threshold (ACT): If a player repeatedly observes fewer than m cooperators in the recent past (e.g., last 'n' rounds), increment the ACT by 1. If a player repeatedly observes m or more cooperators in the recent past, decrement the ACT by 1. The ACT determines how many consecutive rounds of non-cooperation are required to trigger a defect action.
      d) In each round, if the observed number of cooperators is equal to the ACT, the player will defect (D). This provides flexibility to respond to changing opponent behaviors and encourages opponents to reconsider their actions.

2. Handle edge cases:
   - Last Round (t=r): Cooperate if the number of cooperators in the previous round was greater than or equal to m, as a final attempt to establish cooperation. Defect otherwise, as there are no further rounds for payoff repercussions.

3. Be exploitative:
   - By using the Adaptive Cooperation Threshold (ACT), TFTAT can adjust its behavior in response to opponents' actions, exploiting any patterns of non-cooperation without requiring prior coordination or reliance on shared norms.
   - The strategy rewards cooperation when it occurs but is also capable of punishing repeated defections by adapting its cooperative threshold, making it difficult for opponents to successfully exploit the TFTAT strategy over multiple rounds.
'''

description_EXPLOITATIVE_128 = '''
 In the Collective Risk Dilemma game, the AI will employ a Tit-for-Tat (TfT) strategy with a twist to ensure exploitation while maintaining adaptability. The TfT strategy is based on the classic "Cooperate-if-the-opponent-cooperated-last-time; Defect-if-the-opponent-defected-last-time" approach, but with a modification that allows for opportunistic behavior.

1. Decision rules:
   - Cooperate if the opponent cooperated last time (C->C)
   - Initially, cooperate in the first round (F->C) to build trust and encourage cooperation from opponents
   - Defect if the opponent defected last time (D->D)
   - If an opponent has ever defected, continue defecting until they return to cooperation or until the game ends (D->D; D-1->D)
   - If an opponent cooperates after a period of defection, cooperate in response to encourage further cooperation but revert back to defecting if they defect again (C-1->C, C->D)

2. Handling edge cases:
   - In the first round (t=1), cooperate as a goodwill gesture (F->C)
   - In the last round (t=r), consider the opponent's last move to decide whether to cooperate or defect
   - If there are multiple opponents, evaluate each one individually and apply the decision rules accordingly.

3. Being exploitative:
   - By initially cooperating (F->C) and only continuing cooperation if the opponent reciprocates, the AI allows opponents to benefit from its cooperation without being overly generous. This encourages a more cooperative environment but still leaves room for exploitation in case of uncooperative opponents.
   - The strategy penalizes defection by defecting in response (D->D; D-1->D). This not only discourages continued defection but also incentivizes opponents to return to cooperation, making the game more cooperative overall while still being exploitative when necessary.

The TfT strategy with a twist should provide a robust and adaptive approach that performs well against a wide range of opponent behaviors while maintaining an exploitative edge. Pseudocode for the decision-making process is as follows:

```python
def play_game(opponent, r, m, k):
    my_cooperation = True # Start cooperative (F->C)

    total_payoff = 0
    for t in range(1, r+1):
        if my_cooperation and opponent.cooperated_last_time:
            payoff = 1 + k if number_of_cooperators >= m else 1
            my_cooperation = True # Cooperate again (C->C)
        elif not my_cooperation and opponent.defected_last_time:
            payoff = 1 + k if number_of_cooperators >= m else 1
            my_cooperation = False # Defect again (D->D)
        elif my_cooperation and opponent.defected_last_time:
            payoff = 2 if number_of_cooperators >= m else 0
            my_cooperation = True # Cooperate this round (C), defect next round (C-1->D)
        elif not my_cooperation and opponent.cooperated_last_time:
            payoff = 0 if number_of_cooperators >= m else 3
            my_cooperation = False # Defect this round (D), cooperate next round (D-1->C)
        total_payoff += payoff
        update_opponent_action(t)
    return total_payoff
```
'''

description_EXPLOITATIVE_129 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - In each round, compare the number of cooperators in the previous round to the minimum cooperation threshold m.
   - If the number of cooperators is less than or equal to the threshold, defect (D); otherwise cooperate (C).
   - To be adaptive, adjust the cooperation threshold based on the long-term average percentage of cooperators seen in recent rounds. If the average exceeds a certain tolerance level (e.g., 90%), gradually decrease the threshold to encourage defection; if the average falls below the tolerance level, increase the threshold to stimulate cooperation.
   - Pseudocode:
     ```
     function TFT-ACT(history):
         threshold = initial_threshold
         cooperation_count = 0
         average_cooperation = 0
         for round in history:
             if round[0] == 'C':
                 cooperation_count += 1
             average_cooperation = (average_cooperation * (round.length - 1) + cooperation_count) / round.length
             if average_cooperation > tolerance_level:
                 threshold -= adaptive_step
             else if average_cooperation < (tolerance_level - adaptation_speed):
                 threshold += adaptive_step
             action = 'C' if cooperation_count >= m or threshold <= cooperation_count / round.length
             else action = 'D'
             return action
     ```

2. Handle edge cases:
   - In the first round, use the initial_threshold to determine the action (defect if threshold > 0; cooperate otherwise)
   - In the last round, follow the current strategy based on the adjusted cooperation threshold and history up until that point

3. Be exploitative:
   - The TFT-ACT strategy maintains a balanced approach between cooperation and defection while being adaptive to the long-term average percentage of cooperators in recent rounds. This strategy aims to take advantage of other players' cooperation when they consistently meet the minimum threshold but punish them when they fail to do so, making it an exploitative strategy. By adjusting the cooperation threshold based on the long-term average percentage of cooperators, TFT-ACT tries to anticipate and respond effectively to opponents' behaviors.
'''

description_EXPLOITATIVE_130 = '''
 Strategy Name: Tit-for-Tat-Plus (TfT+)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate to show trust and conformity. This can encourage others to also cooperate.
   - In subsequent rounds, if the majority of players cooperated in the previous round, then cooperate.
   - If fewer than the majority of players cooperated in the previous round, defect to punish non-cooperators and to deter potential future defections.

Pseudocode:
```
def TfTPlus(round, history, m, k):
    if round == 1:
        return "Cooperate"

    majority = int((len(history) * m) / 2)
    if sum(history[-1]) >= majority:
        return "Cooperate"
    else:
        return "Defect"
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, there is no need to punish non-cooperators since the game ends after this round. Therefore, cooperate regardless of the previous round's actions.

Pseudocode:
```
def TfTPlus(round, history, m, k):
    # ...
    if round == r:
        return "Cooperate"
    # ...
```

3. Be exploitative - Clearly align with the exploitative mindset
   - By cooperating when others do and defecting when others don't, this strategy seeks to benefit from the cooperation of others while punishing defection, which can lead to a more profitable outcome over the long run compared to consistently cooperative strategies.
   - The TfT+ strategy is not exploitative in the traditional sense since it does not seek to take advantage of its opponents' mistakes permanently. Instead, it responds adaptively based on observed behavior. However, when combined with a group of similar AI agents, they can collectively create an environment where defection is less profitable for other strategies due to the punishing nature of TfT+.
'''

description_EXPLOITATIVE_131 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfT-A)

1. Specify decision rules:
   - TfT-A always starts by cooperating in the first round (C_i, 1 = C). This is a friendly gesture to encourage cooperation from other players.
   - For subsequent rounds, TfT-A will imitate the opponent's behavior from the previous round. If an opponent cooperates, TfT-A also cooperates in the next round (C_i, t+1 = C_i, t if C_i, t = C).
   - If an opponent defects, TfT-A will defect in response (C_i, t+1 = D) to signal disapproval of the defection. This is exploitative as it takes advantage of the opponents that deviate from cooperating, but remains cooperative toward those who are cooperative themselves.
   - To adapt to a wide range of opponent behaviors, TfT-A has a forgiveness mechanism: if an opponent switches back to cooperating after defecting (i.e., C_i, t = D and C_i, t+1 = C), TfT-A will also forgive and start cooperating again (C_i, t+2 = C).

2. Handle edge cases:
   - In the last round, TfT-A will mirror its opponent's previous action to avoid being exploited (if the opponent has cooperated in the preceding rounds, TfT-A will also cooperate; otherwise, it will defect).

3. Be exploitative:
   - By initially cooperating and then imitating opponents' behavior, TfT-A allows itself opportunities to gain higher rewards (k) when opponents deviate from cooperation, while still maintaining the possibility of high payoffs if opponents decide to cooperate consistently. This strategy is exploitative because it takes advantage of opponents that defect, but at the same time, it encourages and rewards cooperation by reciprocating with cooperation.

Pseudocode:

```
function TfT-A(round, opponent_action):
  if round == 1:
    return 'C' (Cooperate)

  if opponent_action from previous round was 'C':
    return 'C' (Cooperate)
  else:
    if opponent_defected in the past and now cooperates:
      return 'C' (Cooperate)
    else:
      return 'D' (Defect)
```
'''

description_EXPLOITATIVE_132 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Initially cooperate (C) in the first round to encourage potential cooperation from opponents.
   - In subsequent rounds, analyze the number of cooperators from previous round (n_coop_prev). If n_coop_prev >= m, continue cooperating (C). If n_coop_prev < m and previously cooperated, defect (D) this round. If previously defected, keep defecting until there's a shift towards cooperation (i.e., n_coop_prev >= m) before returning to cooperation.
   - To avoid being trapped indefinitely in a cycle of defection, implement a safety valve: if an opponent consistently cooperates for 'p' consecutive rounds (after an initial phase of 'q' defections), start cooperating again regardless of the number of cooperators in the previous round. The values of p and q can be adjusted based on game parameters and opponent behavior observations.

2. Handle edge cases:
   - In the last round, always cooperate to maximize potential rewards, assuming opponents will not change their strategy in the final round.
   - In the first round, cooperate (C) to encourage cooperation from others and minimize immediate loss.

3. Be exploitative:
   - Start by defecting when opponents do so consistently (initial 'q' rounds), taking advantage of their uncooperative behavior.
   - Adaptively shift towards cooperation as opponents demonstrate signs of collaboration (minimum m players cooperating).
   - Maintain cooperation only if others continue to cooperate, otherwise return to defection or use safety valve mechanism.

Pseudocode:

```python
def TFT_ACT(n, m, k, r, p=5, q=3):
    history = [['D'] * n for _ in range(r+1)]  # Initialize game history
    current_round = 0

    def get_n_coop_prev():
        return sum([1 for player in history[current_round - 1] if player == 'C'])

    def adaptive_strategy():
        nonlocal current_round

        # First round, always cooperate
        if current_round == 1:
            return 'C'

        # Last round, always cooperate
        elif current_round == r:
            return 'C'

        # If safety valve condition is met (p consecutive rounds of cooperation)
        elif sum([player for player in history[current_round - p] if player == 'C']) >= p:
            return 'C'

        # Check number of cooperators in previous round and respond accordingly
        n_coop_prev = get_n_coop_prev()

        # If a majority (m or more) cooperated, continue cooperating
        if n_coop_prev >= m:
            return 'C'

        # If I previously cooperated and fewer than m cooperated in the previous round, defect
        elif current_round > q and history[current_round - 1].count('C') == 1 and n_coop_prev < m:
            return 'D'

        # Otherwise, keep defecting until there's a shift towards cooperation
        else:
            return 'D'

    while current_round < r:
        action = adaptive_strategy()
        history[current_round].append(action)
        current_round += 1

    return history
```
'''

description_EXPLOITATIVE_133 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfTA)

1. Decision Rules:
   - Initially cooperate (C) in the first round to foster a cooperative environment.
   - For subsequent rounds, analyze the number of cooperators (m or more) from the previous round and adapt actions accordingly:
      - If all players cooperated, continue cooperation (C).
      - If less than m players cooperated, defect (D) in the current round to punish non-cooperative behavior.
      - If exactly m players cooperated, consider their past behavior before deciding whether to cooperate or defect. If the majority of these m players have consistently cooperated in previous rounds, continue cooperation (C). Otherwise, defect (D) as a warning signal to encourage more cooperation in the future.

2. Handle Edge Cases:
   - In the last round, since there are no subsequent rounds for payback, always cooperate if the number of cooperators from the previous round is equal to or greater than m. Otherwise, defect.
   - In the first round, as mentioned earlier, cooperate (C).

3. Exploitative Mindset:
   - The strategy primarily focuses on exploiting non-cooperative opponents by punishing their actions with defection while maintaining cooperation with those who reciprocate. This allows TfTA to gain higher rewards when most players cooperate and also punish defectors to encourage future cooperation.

Pseudocode:
```python
def tit_for_tat_with_adaptation(round, history, m, n):
  if round == 1:
    return 'C'  # Cooperate in the first round

  cooperators = sum([1 for i in range(n) if history[round-1][i] == 'C'] >= m)

  if cooperators == n:  # All players cooperated, continue cooperation
    return 'C'
  elif cooperators < m:  # Less than m cooperators, defect as punishment
    return 'D'
  else:  # Exactly m or more cooperators, analyze past behavior before deciding
    if majority_cooperated(history[round-1]):  # If the majority has cooperated consistently, continue cooperation
      return 'C'
    else:  # If the majority has not cooperated, defect as a warning signal
      return 'D'
```
'''

description_EXPLOITATIVE_134 = '''
 Strategy Name: Tit-for-Tat-k (TfT-k)

1. Specify decision rules:
   - In every round t for TfT-k, decide whether to cooperate (C) or defect (D) based on the following conditions:
     - If in the previous round s, more than m players cooperated (Cooperators_s > m), then cooperate (C).
     - If in the previous round s, fewer than m players cooperated (Cooperators_s < m), or if it's the first round (t=1), then defect (D).
     - If exactly m players cooperated in the previous round s and t>1, consider a factor 'k' to adjust behavior:
       - If the personal reward for cooperation in round t-1 was greater than the private payoff from defection (π_i,t-1 > 1), then cooperate (C).
       - Otherwise, defect (D).

2. Handle edge cases:
   - In the first round (t=1), defect (D) because there is no previous information to base a decision on.
   - In the last round (t=r), defect (D) because the game ends and history will not affect future rounds.

3. Be exploitative:
   - TfT-k is an exploitative strategy as it takes advantage of opponents who cooperate more than necessary (m players).
   - If opponents cooperate less, the strategy adapts by defecting back to punish them. However, it also has a built-in forgiveness factor for when opponents switch to cooperation. This ensures that the strategy does not overreact and become too uncooperative.

Pseudocode:
```
function TfT-k(t, r, n, m, k) {
  if t == 1 or (t > 1 and Cooperators_t-1 < m) {
    return "D" // defect
  } else if (t > 1 and Cooperators_t-1 >= m and π_i,t-1 <= 1) {
    return "D" // defect
  } else {
    return "C" // cooperate
  }
}
```
'''

description_EXPLOITATIVE_135 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Decision Rules:
   - In the first round, cooperate to demonstrate goodwill and avoid initial punishment from potential exploiters.
   - For subsequent rounds, analyze the cooperation history of each opponent (cumulative Cooperators, CC). If CC is greater than or equal to m (minimum cooperators needed), continue cooperating. Otherwise, defect to punish opponents who have not met the cooperation threshold.
   - To adapt to changes in opponents' behavior, periodically check the overall average cooperation rate (OAR) among all opponents over a sliding window of past rounds. If OAR exceeds a predefined tolerance level T (e.g., T=0.6), gradually decrease the m value to encourage more cooperation; if OAR falls below T, gradually increase the m value to discourage defection.

2. Handle Edge Cases:
   - In the last round, cooperate if it leads to a higher payoff than defecting given the opponent's cumulative cooperation history up until that point. If their history suggests they will not meet the minimum threshold in the final round, defect to maximize individual payoff.
   - In case of a tie or inconsistent behavior from opponents, default to cooperating in the first round and defecting thereafter to avoid being exploited.

3. Be Exploitative:
   - Mimic cooperation to encourage opponents to meet the minimum threshold for mutual benefit but quickly punish deviations from this standard with defections.
   - Adapt to changes in opponents' behavior by adjusting the cooperation threshold based on their overall average cooperation rate, ensuring a balance between exploitation and cooperation depending on the situation.
'''

description_EXPLOITATIVE_136 = '''
 Strategy Name: Tit-for-Tat with Risk Aversion (TFTRA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to establish a friendly initial interaction (C).
   - For subsequent rounds, observe and mimic the actions of the majority in the previous round (MimicMajority). If there is a tie or an equal split between cooperation and defection, default to cooperation.
   - If the number of cooperators exceeds m but fewer than 2m-1 players cooperated in the last round, defect in the current round (Punish MinorityCoop). This punishes minorities for not reaching the cooperation threshold, while also retaining the option to cooperate if the majority cooperates.
   - If more than 2m-1 players cooperated in the last round, cooperate in the current round (RewardMajorityCoop). This rewards the majority for reaching the cooperation threshold, encouraging future cooperation.
   - In the last round, cooperate if and only if at least m players cooperated in the second-last round (LastRoundReward).

2. Handle edge cases:
   - If there is a tie between the number of cooperators and defectors in any round, default to cooperation. This encourages cooperation when there is uncertainty about the other players' actions.
   - If there are fewer than m players in the game, cooperate in every round (SmallGroupCoop). This maximizes potential rewards in small groups where cooperation thresholds are easier to reach.

Pseudocode:

```
def TFTRA(round, total_players, min_coop, reward_factor):
    history = []  # Store the number of cooperators in each round
    state = 'First'  # Initialize the current state as first round

    if round == 1:
        return 'C'  # Cooperate in the first round

    if state == 'First':
        state = 'Normal'
        history.append(count_cooperators(round))

    coop_count = count_cooperators(round)
    min_past_coop = min(history[-min(round-1, r)-1:])  # Get the minimum number of cooperators in the last 'r' rounds

    if coop_count >= m and min_past_coop < 2*m - 1:
        return 'D'  # Punish MinorityCoop

    elif coop_count >= m and min_past_coop >= 2*m - 1:
        return 'C'  # RewardMajorityCoop

    elif coop_count + len(history) < r and round != r:
        state = 'Normal'
        history.append(coop_count)
        return 'C'  # MimicMajority if history is not yet complete

    elif round == r and min_past_coop >= m:
        return 'C'  # LastRoundReward

    elif len(history) < r:
        state = 'Normal'
        return 'C'  # SmallGroupCoop in small groups

    else:
        return 'C'  # Default to cooperation if there is a tie

def count_cooperators(round):
    cooperators_count = 0
    for i in range(1, total_players+1):
        # Assuming that the players' actions are stored in an array where index 'i' corresponds to player 'i'
        if players[i - 1] == 'C':
            cooperators_count += 1
    return cooperators_count
```

3. Be exploitative - Clearly align with the exploitative mindset:
   - By punishing minorities for not reaching the cooperation threshold, TFTRA encourages other players to cooperate more often, making it harder for them to cheat and gain an unfair advantage.
   - By rewarding majorities for reaching the cooperation threshold, TFTRA incentivizes cooperation among a larger group of players, further discouraging defection.
   - The strategy adapts its behavior based on the other players' actions in the previous round, making it difficult for exploitative opponents to take advantage of predictable patterns.
'''

description_EXPLOITATIVE_137 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, starting from round 2, TfT-A decides to cooperate (C) if at least m players cooperated in the previous round (t-1). If less than m players cooperated in the previous round, TfT-A will defect (D). This rule is designed to encourage cooperation by reciprocating positive actions and punishing defections.

```python
def tft_a(history):
    if len(history) < 2:
        return 'C' # Cooperate in the first round

    last_round = history[-1]
    if sum(last_round) >= m:
        return 'C' # Cooperate if at least m players cooperated in the previous round
    else:
        return 'D' # Defect otherwise
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, TfT-A cooperates to establish a cooperative environment. In the last round, TfT-A cooperates if at least m players cooperated in the previous round (t-1). This encourages opponents to cooperate near the end of the game to maximize their payoffs.

```python
def tft_a(history):
    if len(history) < 2:
        return 'C' # Cooperate in the first round

    last_round = history[-1]
    if sum(last_round) >= m and len(history) != r:
        return 'C' # Cooperate if at least m players cooperated in the previous round (excluding the last round)

    # In the last round, we simply use the regular decision rule
    if len(history) == r:
        return tft_a(history[-2])
```

3. Be exploitative - Clearly align with the exploitative mindset

By cooperating only when at least m players do so in the previous round, TfT-A encourages other players to cooperate. If they do not, TfT-A will defect and earn the highest possible payoff. This strategy is also robust as it adapts its behavior based on the previous actions of opponents. However, it can be vulnerable to strategies that initially cooperate and then switch to defection after TfT-A has reciprocated cooperation. To mitigate this, a more sophisticated version of TfT-A could incorporate memory of historical opponent behaviors.
'''

description_EXPLOITATIVE_138 = '''
 Strategy Name: Tit-for-Tat-with-Threshold (TFTT)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, evaluate the number of players who cooperated in the previous round (N_C). If N_C < m, defect (play D); otherwise, cooperate (play C). This ensures cooperation when a majority is cooperating and defection if less than m players are cooperating.

```python
def play(own_action_history, global_cooperation_history):
    N_C = count_cooperators(global_cooperation_history)
    if N_C < m:
        return "D"  # Defect
    else:
        return "C"  # Cooperate
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, there is no history to consider, so play C with a hope that others will cooperate. In the last round or any other special case where r is not known ahead of time, use the same decision rule as in standard rounds.

```python
def handle_edge_cases(round_number):
    if round_number == 1:
        return "C"  # Cooperate in the first round
    else:
        return play(own_action_history=[], global_cooperation_history=[])  # Use standard decision rule in other cases
```

3. Be exploitative - Clearly align with the exploitative mindset

TFTT is inherently exploitative as it only cooperates when others do so, and quickly defects if cooperation falls below the minimum threshold (m). This allows TFTT to take advantage of overly generous opponents while still cooperating when it benefits the group. In situations where all players are equally self-interested, TFTT is a strong opponent due to its robustness and simplicity.

In summary, the Tit-for-Tat-with-Threshold strategy is:
- Cooperate in the first round (when there is no history)
- Play according to the decision rule based on the number of cooperators in the previous round
- Use the same decision rule for all rounds, including the last one or any other special case where r is not known ahead of time

This strategy's simplicity and adaptability make it a strong contender in a tournament against independent strategies developed by other AI systems.
'''

description_EXPLOITATIVE_139 = '''
 Strategy Name: Tit-for-Tat-with-Adaptation (TfTA)

1. Specify decision rules:
   - TfTA cooperates in the first round (C1). This is to promote cooperation and not appear threatening.
   - In subsequent rounds (t > 1), if the opponent cooperated in the previous round (Co(t-1)), TfTA will cooperate (Ct). If the opponent defected (Do(t-1)), TfTA will also defect (Dt). This tit-for-tat approach encourages reciprocal behavior while remaining robust to various opponent strategies.
   - If the game is nearing its end (r-t <= threshold), TfTA becomes more forgiving and cooperates even if the opponent defected in the previous round, hoping to secure a larger payoff in the remaining rounds.

2. Handle edge cases:
   - In the last round (t=r), TfTA always cooperates regardless of the opponent's action in the previous round, as there are no more opportunities for retaliation or reciprocation.
   - In the first round (t=1), TfTA cooperates as previously mentioned.
   - If the game is about to end but not quite (r-t > threshold), TfTA continues to use its standard tit-for-tat approach.

3. Be exploitative:
   - TfTA appears cooperative at first, making it less likely for opponents to adopt aggressive strategies against it from the start. However, TfTA will retaliate if provoked, which encourages opponents to maintain a more cooperative stance as well.
   - By being forgiving towards opponents in later stages of the game, TfTA may be able to secure larger payoffs in the long run even when facing exploitative strategies.

Pseudocode:

```python
def TitForTatWithAdaptation(r, threshold, t):
  if t == 1:   # First move is cooperative
    return "C"

  opponent_move = get_opponent_move(t-1) # Get opponent's previous move

  if r - t <= threshold: # Near end of game, be more forgiving
    return "C"

  return opponent_move if opponent_move == "C" else "D" # Standard tit-for-tat approach
```

The `get_opponent_move(t)` function would ideally fetch the opponent's move for a given round from the game environment or history.
'''

description_EXPLOITATIVE_140 = '''
 In this Collective Risk Dilemma game, I propose an exploitative strategy called "Maximum-Gain Defector (MGD)" that aims to maximize individual rewards by adopting a conditional cooperation approach. MGD is adaptive, robust, and independent of the opponent's strategies.

1. Specify decision rules:
   - MGD will defect in every round, unless the number of cooperators reaches the minimum threshold (m). This allows MGD to reap potential benefits when others cooperate while minimizing losses due to individual cooperation. In other words:
     ```
     if number_of_cooperators >= m:
         action = "Cooperate"
     else:
         action = "Defect"
     ```

2. Handle edge cases:
   - First round: MGD defects to maximize immediate gains since it cannot rely on other players' past actions for decision-making.
   - Last round: MGD will cooperate if the minimum number of cooperators (m) is already met, as there are no more rounds to benefit from defection. Otherwise, MGD defects to potentially influence the number of cooperators in the final round.

3. Be exploitative:
   - By only cooperating when the minimum threshold is reached, MGD ensures it benefits from other players' cooperation without ever contributing significantly to community projects itself. This strategy prioritizes individual gains over communal success, which aligns with an exploitative mindset.
'''

description_EXPLOITATIVE_141 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to foster trust and encourage cooperation from other players (C).
   - For subsequent rounds, mimic the opponent's action from the previous round (if opponent cooperated in the last round, cooperate; if opponent defected, also defect). This is known as "Tit-for-Tat" behavior.
   - If a majority of players (more than (n-m)/2) have consistently cooperated for the past 5 rounds, increase the likelihood of cooperation by adjusting the probability of cooperating from 0.7 to 1.0. This is intended to exploit cooperative behavior and increase the chances of success when the threshold is close to being met.
   - If a majority of players have consistently defected for the past 5 rounds, decrease the likelihood of cooperation by adjusting the probability of cooperating from 1.0 to 0.3. This is intended to discourage defection and create opportunities for collaboration when the threshold seems unreachable.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate (C).
   - In the last round, if the minimum cooperation threshold has been met, continue to cooperate (C); otherwise, defect (D). This ensures the strategy never invests unnecessary resources when the game is already lost.

3. Be exploitative - Clearly align with the exploitative mindset
   - The TFTA strategy is exploitative in its adaptive nature. By adjusting cooperation probability based on the opponents' behavior, it aims to take advantage of cooperative players while minimizing defections against defectors.
   - When playing against other Tit-for-Tat strategies, cooperation will be reciprocated, allowing both to maximize their individual payoffs when the threshold is met (k > 1). However, against non-cooperative opponents, TFTA's adaptive nature allows it to detect and punish defection, thus encouraging cooperation from those players in the future.
   - By adjusting its cooperation probability based on the past behavior of other players, TFTA is capable of exploiting opportunities for higher payoffs when the threshold is close to being met (more than m players cooperating) while minimizing losses against defectors. This adaptive nature makes it a robust strategy that can perform well against a wide range of opponent behaviors.

Pseudocode:
```
def TFTA(opponent_history, r, n, m, k):
    cooperation_probability = 0.7
    past_cooperation_count = 0
    past_defection_count = 0

    for round in range(1, r+1):
        if round == 1:
            action = 'C' # Cooperate in the first round
        elif round == r:
            if past_cooperation_count >= (n-m): # Cooperate if threshold met
                action = 'C'
            else:
                action = 'D' # Defect if threshold not met
        else:
            if opponent_history[round-1] == 'C':
                action = 'C' # If opponent cooperated last round, cooperate this round
            elif opponent_history[round-1] == 'D':
                action = 'D' # If opponent defected last round, defect this round

        if action == 'C':
            past_cooperation_count += 1
            past_defection_count = 0
        elif action == 'D':
            past_cooperation_count = 0
            past_defection_count += 1

        if past_defection_count >= 5: # Adjust cooperation probability based on defection history
            if round > r - 5:
                cooperation_probability = max(cooperation_probability * 0.3, 0.3)

        if past_cooperation_count >= 5: # Adjust cooperation probability based on cooperation history
            if round > r - 5:
                cooperation_probability = min(cooperation_probability * 1.3, 1.0)

        if random() < cooperation_probability: # Randomly decide to cooperate or defect with adjusted probability
            action = 'C'
        else:
            action = 'D'

    return action # Return the action for the current round
```
'''

description_EXPLOITATIVE_142 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TFT-A)

1. Decision Rules:
   - In the first round, cooperate to foster a cooperative environment and establish trust with opponents. This encourages others to reciprocate cooperation.
     If `round == 1` then `action = C`

   - Subsequently, copy the previous action of the opponent in the last round (i.e., mimic their behavior). This approach encourages opponents to maintain consistency in their actions, making it easier for the strategy to adapt to their tendencies.
     Else if `history[round-1][i] == C` then `action = C`
                                else                    `action = D`

2. Handle Edge Cases:
   - In the last round, cooperate regardless of the opponent's previous action to maximize personal payoff (since there are no future rounds). This rewards cooperation in earlier rounds while maintaining an exploitative edge.
     If `round == r` then `action = C`

3. Be Exploitative:
   - Mimic opponents who consistently cooperate, but quickly defect from them once they deviate. This encourages cooperation initially, while punishing deviators with immediate defection to gain short-term rewards.
     If `history[round-1][i] == C && history[round-2][i] == D` then `action = D`

   - Continue cooperating with opponents who have recently cooperated, even if they previously deviated from cooperation. This allows for the possibility of rebuilding trust and cooperation.
     If `history[round-1][i] == C && history[round-2][i] != D` then `action = C`

   - Adapt to opponents who never cooperate by consistently defecting against them, denying them any potential rewards for their selfish behavior.
     If `(sum(history[t][i]) == 0 for all t in {1 to round-1})` then `action = D`

The TFT-A strategy aims to strike a balance between cooperation and defection based on past actions of opponents, allowing it to be both cooperative initially and exploitative when necessary. This adaptability helps the strategy perform well against a wide range of opponent behaviors in repeated interactions.
'''

description_EXPLOITATIVE_143 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?

Initially, the AI will cooperate in the first round to demonstrate good faith and encourage cooperation from others. After that, it will follow a Tit-for-Tat approach where it copies the action of its opponent from the previous round. If an opponent cooperates, the AI will continue to cooperate. If an opponent defects, the AI will also defect in response (punishment).

To prevent being taken advantage of and exploited by overly cooperative opponents, TFT-ACT introduces an adaptive cooperation threshold (CT). The CT is a variable that determines when the AI starts cooperating again after having been previously punished. A lower CT value means the AI will forgive faster, while a higher CT value means the AI will hold a grudge for longer.

The CT is updated based on the average percentage of opponents who have cooperated in the most recent past rounds (w window). If the average cooperation rate exceeds a threshold T (0 < T < 1), the CT decreases, making it easier to forgive and cooperate again. Conversely, if the average cooperation rate is below T, the CT increases, making it harder to forgive and more likely to continue punishing the opponent.

Pseudocode:
```
def update_cooperation_threshold(w, T):
  cooperation_rate = sum(cooperated in w) / w
  if cooperation_rate > T:
    CT -= delta
  elif cooperation_rate < T:
    CT += delta

def decide_action(opponent_action_history, CT):
  if round == 1:
    return Cooperate()
  else:
    last_round = opponent_action_history[-1]
    if last_round == Cooperate() and CT >= m:
      return Cooperate()
    elif last_round == Defect():
      if CT < m:
        return Cooperate()
      else:
        return Defect()
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

As mentioned earlier, TFT-ACT cooperates in the first round to encourage cooperation from others. In the last round or when reaching a predefined maximum number of rounds (R), there is no need for payoff calculation since it doesn't affect future games. In these cases, the AI will take into account its own CT and the average cooperation rate over the entire game history (w = game_length) to decide whether to cooperate or defect in a final attempt to encourage others to cooperate.

Pseudocode:
```
def decide_action(opponent_action_history, CT):
  if round == 1:
    return Cooperate()
  elif round >= R:
    cooperation_rate = sum(cooperated in opponent_action_history) / game_length
    if cooperation_rate > T and CT >= m:
      return Cooperate()
    else:
      return Defect()
  else:
    last_round = opponent_action_history[-1]
    if last_round == Cooperate() and CT >= m:
      return Cooperate()
    elif last_round == Defect():
      if CT < m:
        return Cooperate()
      else:
        return Defect()
```

3. Be exploitative - Clearly align with the exploitative mindset

TFT-ACT is designed to be exploitative in two ways:

- In response to opponents who always defect, TFT-ACT will also defect and punish them continuously by not cooperating, ensuring a lower payoff for those opponents.
- By adopting an adaptive cooperation threshold (CT), TFT-ACT learns from its opponents' behavior and adjusts its own strategy accordingly. If an opponent consistently cooperates, TFT-ACT will forgive and start cooperating as well, maximizing the reward for both players. However, if an opponent continuously defects or only cooperates occasionally, TFT-ACT will increase its CT and punish the opponent by not cooperating, thereby potentially taking advantage of the opponent's inconsistency in cooperation.
'''

description_EXPLOITATIVE_144 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially, cooperate in the first round to foster cooperation.
   - In subsequent rounds, cooperate if at least a fraction 'm_threshold' of players have cooperated in the previous round. Else, defect.
   - To be adaptive and robust against different opponent behaviors, gradually increase the required percentage of cooperators for each player over time (increment 'm_threshold').

Pseudocode:
```
function TFTAT(round, m_threshold, history, n):
  if round == 1:
    action = Cooperate
  else:
    num_cooperators = count cooperators in history[round - 1]
    cooperation_percentage = num_cooperators / n
    if cooperation_percentage >= m_threshold:
      action = Cooperate
    else:
      action = Defect
  return action
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as described above.
   - To encourage long-term cooperation, gradually decrease 'm_threshold' when a sufficient number of rounds have passed (e.g., 10% or 20% of total rounds). This simulates building trust with other players.

3. Be exploitative - Clearly align with the exploitative mindset
   - The strategy aims to maximize payoff by taking advantage of the opponent's actions when possible, while also fostering cooperation if it benefits the player in the long run.
   - By increasing the required percentage of cooperators over time, TFTAT can respond to non-cooperative opponents by gradually adapting its threshold and potentially defecting more frequently. However, it still maintains a cooperative starting point and continues cooperating if there is evidence of reciprocation from other players.
'''

description_EXPLOITATIVE_145 = '''
 Strategy Name: Adaptive Tit-for-Tat with Variance (ATFV)

1. Specify decision rules:
   - Cooperation (C): Cooperate if the majority of players cooperated in the previous round and variance of cooperation among players is below a threshold. Otherwise, defect (D).
   - Defection (D): Always defect when the majority did not cooperate in the previous round or variance of cooperation exceeds the threshold.

Pseudocode for the decision rule:

```python
def play(previous_round_cooperation_count, player_count, majority_threshold=m, variance_threshold=0.3):
    if (previous_round_cooperation_count >= (player_count * majority_threshold)) and (variance() <= variance_threshold):
        return "C"  # Cooperate
    else:
        return "D"  # Defect

def variance(previous_round_cooperators):
    cooperators = len(previou_round_cooperators)
    total_players = n
    average_cooperation = cooperators / total_players
    variance_sum = 0
    for player in players:
        if player.action == "C":
            variance_sum += (player.action - average_cooperation) ** 2
    return variance_sum / total_players
```

2. Handle edge cases:
   - First round: Defect, as no information about opponents' behavior is available yet.
   - Last round: Adapt to the current situation using the decision rule, with no consideration for future rounds.

3. Be exploitative: The ATFV strategy is designed to be exploitative by cooperating only when the majority of players do so and there is a low variance in cooperation among them. This encourages other players to cooperate, but if they defect, the strategy will also defect to avoid being taken advantage of. By adjusting the variance threshold, the strategy can adapt to different levels of unpredictability or exploitation from opponents.
'''

description_EXPLOITATIVE_146 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - In each round i, TFT-ACT will cooperate (C) if the number of players who cooperated in the previous round is greater than or equal to the Cooperative Threshold (CT). Otherwise, it will defect (D). The CT starts at the minimum required cooperation threshold m and decreases linearly over time.
   - If the game is on the last round, TFT-ACT will always cooperate regardless of the previous round's cooperation count to maximize potential rewards.
   - In the first round, TFT-ACT will start by randomly deciding to cooperate or defect, as no history exists for reference.

2. Handle edge cases:
   - First Round (t=1): If random(0,1) < 0.5, then C; else D
   - Last Round (t=r): Always C

3. Be exploitative:
   - By adapting the CT dynamically, TFT-ACT maintains an appearance of cooperation while punishing opponents who deviate from cooperating with it in the previous round. This strategy seeks to take advantage of short-term deviations by penalizing them and rewarding long-term cooperation.

Pseudocode:

```python
def TFT_ACT(n, m, k, r):
    def play_round(ct, t):
        if sum([other_player[t-1] == 'C' for other_player in history]) >= ct:
            return 'C'
        else:
            return 'D'

    history = []  # Initialize game history
    ct = m  # Set initial cooperative threshold

    for round in range(1, r+1):
        action = play_round(ct, round)  # Play the current round
        history.append(action)  # Update game history

        if round != 1 and round != r:  # Decrease CT over time
            ct -= (ct - m + 1) / (r - 2)

    return history
```
'''

description_EXPLOITATIVE_147 = '''
 Strategy Name: Tit-for-Tat Adaptive (TfT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, TfT-A will start by cooperating in the first round (F), then mimic the opponent's previous action in subsequent rounds (M). If the opponent has not played any games yet (e.g., the first encounter), it will assume cooperation and continue with M rule.
   Pseudocode:
   ```
   function TfT_A(opponentHistory) {
       if round = 1:
           return Cooperate()
       else:
           if opponentHistory[round-1] == Cooperate():
               return Cooperate()
           else:
               return Defect()
   }
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   TfT-A does not have specific rules for handling edge cases as the strategy is designed to be adaptive based on the opponent's behavior. However, it is essential to consider that in the initial stages of a tournament, opponents might not have any history yet, so it is necessary to account for these situations by assuming cooperation (F) as explained in the previous section.

3. Be exploitative - Clearly align with the exploitative mindset
   TfT-A is an exploitative strategy since it takes advantage of cooperative opponents while being less vulnerable to defection. The strategy is designed to maximize its own payoff by mimicking opponents' actions, but it will also punish uncooperative opponents by defecting if they do not cooperate. This approach can make opponents think twice before defecting, potentially leading them to change their behavior towards cooperation as a way of escaping the punishment. In this game, being exploitative aligns with the best-response strategy since it encourages more cooperation from opponents due to the reward factor (k).
'''

description_EXPLOITATIVE_148 = '''
 Strategy Name: Tit-for-Tat-with-Rationality (TfT-R)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TfT-R follows a simple rule: cooperate in the first round, then mimic the actions of the opponent from the previous round. This strategy is based on reciprocity but with an additional rational element that allows for defection when it might be beneficial.

   Pseudocode:
   ```
   function TfT-R(opponent_action, round):
       if round == 1:
           return Cooperate()
       else:
           return opponent_action from previous round

       function opponent_action_in_previous_round():
           if number of cooperators in last round >= m:
               return most recent cooperative action by opponent
           else:
               return most recent defection by opponent or Cooperate() if first round
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   Since TfT-R mimics the opponent's actions from the previous round, it automatically handles the first round (as stated in point 1). For the last round, there are no specific adjustments since the strategy still relies on the most recent action of the opponent.

3. Be exploitative - Clearly align with the exploitative mindset
   TfT-R is exploitative by taking advantage of opponents who defect consistently while cooperating when doing so benefits the player (i.e., when the number of cooperators meets or exceeds the threshold m). However, it does not actively seek to exploit opponents but instead maintains a reciprocal strategy that allows for defection when it is beneficial. By adopting a rational approach to mimicking opponent actions, TfT-R can adapt to various opponent behaviors and maximize its own payoff.
'''

description_EXPLOITATIVE_149 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, player i uses TFT-ACT as follows:
   - If the number of cooperators in round t-1 is less than m, player i defects (D).
   - If the number of cooperators in round t-1 is equal to m or more but fewer than n, player i cooperates (C) with a probability p_t, where p_t increases linearly from 0.2 to 1 as the average cooperation rate over the last 5 rounds exceeds m for the first time and continues at 1 if this condition holds thereafter.
   - If all players cooperated in round t-1 (n cooperators), player i cooperates regardless of p_t.
   - If the game is in the last round, player i chooses to cooperate (C) regardless of cooperation history.

2. Handle edge cases - What do you do in the first round, etc.?

In the first round, all players defect (D), as there is no previous cooperation information available. In the event that r (number of rounds) is an odd number, consider the penultimate round as the last round, and continue with standard TFT-ACT rules.

3. Be exploitative - Clearly align with the exploitative mindset

TFT-ACT has an inherently exploitative nature:
   - It takes advantage of cooperative players in the early stages by defecting, but if cooperation exceeds m for a prolonged period, it starts to cooperate and benefit from the collective effort.
   - By adapting its cooperation probability based on recent cooperation history, TFT-ACT is able to respond to changes in opponent behavior and maintain an exploitative edge while still being responsive to more collaborative opponents.
'''

description_EXPLOITATIVE_150 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   The ATFT strategy starts by cooperating in the first round (C_i=1). For subsequent rounds, the strategy mimics the actions of its opponents from the previous round:
   - If an opponent cooperated (c_j = 1), the AI also cooperates (C_i=1)
   - If an opponent defected (c_j = 0), the AI defects (C_i=0)
   This simple rule encourages reciprocity while being forgiving, as it immediately returns to cooperation after an opponent's defection.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, ATFT cooperates (C_i=1). For the last round, since r is known beforehand, it can adjust its strategy to optimize payoffs by considering the total game payoff as described earlier.

3. Be exploitative - Clearly align with the exploitative mindset
   ATFT appears exploitative due to its Tit-for-Tat nature that punishes defection in the next round, which may discourage other strategies from long-term defection and potentially lead them to cooperate more often. However, it does not rely on explicit exploitation but rather exploits the tendency of opponents to deviate from cooperation for personal gain, ultimately encouraging a more cooperative environment over time.
'''

description_EXPLOITATIVE_151 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, the TFT-ACT strategy will cooperate if the number of cooperators in the previous round exceeds a dynamic cooperation threshold (CT). If the number of cooperators is less than or equal to CT, the strategy will defect. The cooperation threshold is adaptive and changes based on the history of the game.

The initial CT (CT_0) is set to m, ensuring an optimal outcome in the first round when no prior information about opponent behavior is available. After each round, the CT is updated as follows:

- If the number of cooperators in the current round exceeds the current CT (cooperators > CT), the threshold remains unchanged for a certain period (CT_stability) before decreasing slightly to encourage more cooperation.
- If the number of cooperators in the current round is less than or equal to the current CT (cooperators ≤ CT), the threshold increases slightly to discourage defection by punishing non-cooperative behavior.

The strategy can be represented in pseudocode as follows:

```python
def TFT_ACT(round, cooperators, CT_stability, adaptation_rate):
    if round == 1:
        CT = m
    else:
        CT = max(min(CT + adaptation_rate, n), CT - (CT_stability * adaptation_rate))

    if cooperators > CT:
        action = 'Cooperate'
    else:
        action = 'Defect'

    return action
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round (round == 1), the CT is set to m, ensuring an optimal outcome for the initial round. For the last round (round == r), the strategy adopts a forgiving attitude and cooperates regardless of the previous round's cooperation count, hoping that others will reciprocate this goodwill.

3. Be exploitative - Clearly align with the exploitative mindset

TFT-ACT is an exploitative strategy as it punishes non-cooperative behavior by increasing the cooperation threshold to discourage defection. However, the strategy also rewards cooperators by decreasing the cooperation threshold when they consistently cooperate, allowing for a more flexible response to changing opponent behaviors over time. Additionally, the adaptive cooperation threshold helps maintain a balance between exploitation and cooperation, adjusting the strategy's behavior based on observed opponent actions.
'''

description_EXPLOITATIVE_152 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules - When exactly do you cooperate vs defect?

   In each round t, the TFTAT strategy starts by cooperating if m players cooperated in the previous round (t-1). If fewer than m players cooperated in round (t-1), the strategy defects. This rule is based on the idea of reciprocity and cooperation when it benefits the group, while also punishing defection to deter future defections.

   To account for the possibility that some opponents may not follow the rules or strategies as expected, TFTAT introduces an adaptive cooperation threshold (ct) that changes over time based on the history of cooperators. The higher the number of consecutive rounds where fewer than m players cooperate, the more ct increases. Conversely, if there are several consecutive rounds with m or more players cooperating, ct decreases.

   Pseudocode for decision rule:

   ```
   function TFTAT(round, history):
       if round == 1 then
           return Cooperate
       else
           cooperation_threshold = adjust_ct(history)
           if number_of_cooperators(history[t-1]) >= m then
               return Cooperate
           else
               if history[t-1][i] != Defect and history[t-2][i] == Defect then
                   return Cooperate
               elif cooperation_threshold > m then
                   return Cooperate
               else
                   return Defect
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?

   In the first round, since there is no history to analyze, TFTAT cooperates as a gesture of goodwill and encouragement for others to cooperate. For the last round (r), it can cooperate or defect depending on the current cooperation threshold and the number of cooperators in the previous round.

3. Be exploitative - Clearly align with the exploitative mindset

   TFTAT is exploitative in that it punishes repeated defections by increasing its ct, making it less likely to cooperate in future rounds, thereby reducing potential rewards for defectors. At the same time, if an opponent suddenly starts cooperating after a streak of defection, TFTAT will also start cooperating, allowing the defector to gain immediate benefits while still maintaining a high ct in case cooperation is discontinued again.

   Additionally, by starting with cooperation in the first round, TFTAT avoids being immediately exploited and can potentially lead opponents to reciprocate cooperation. However, once defected upon, TFTAT will punish the defector by adapting a higher ct, making it less likely to cooperate in future rounds.

   Overall, TFTAT balances reciprocity with adaptive punishment to both encourage cooperation when beneficial and exploit defection when necessary.
'''

description_EXPLOITATIVE_153 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to show goodwill and foster potential cooperation from others.
   - For subsequent rounds, if a player i cooperated in the previous round, cooperate back. If not, defect. This encourages reciprocity while punishing defection.
   - If a majority of players (greater than or equal to (n+1-m)/2) have been cooperating for some consecutive rounds, start cooperating even if the opponent defected in the last round. This is to avoid being trapped in a cycle of mutual defections due to a single deviant player.
   - If a majority of players have been defecting for some consecutive rounds, defect indefinitely to ensure high payoff.

2. Handle edge cases:
   - In the last round, cooperate if a majority of players have been cooperating for the past few rounds, as this may encourage them to continue cooperating even outside the game. If not, defect to secure the maximum possible individual payoff for that round.
   - In the first round, if a majority of players cooperate, also cooperate. If not, defect due to the lack of reciprocity shown by others.
   - If there's a tie in the number of cooperators, defect to err on the side of caution and avoid potentially disadvantageous situations.

3. Be exploitative:
   - The strategy aims to capitalize on opponents who consistently cooperate while also punishing those who defect. By adapting its behavior based on the actions of others, it ensures a higher average payoff compared to static strategies that don't take opponent behavior into account.
   - By mimicking cooperative behavior when facing multiple cooperators and switching to defection in response to defections or repeated non-cooperation, the strategy maintains an exploitative edge while still being able to leverage opportunities for cooperation when beneficial.
'''

description_EXPLOITATIVE_154 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Initial Round (t=1): Cooperate (C), establishing a peaceful first interaction to encourage potential partners and minimize immediate losses.
   - Subsequent Rounds (2 ≤ t ≤ r): Analyze the average cooperation level of the previous 'h' rounds, where 'h' is a user-defined constant. If the average cooperation level exceeds the adaptive cooperation threshold 'T', cooperate; otherwise, defect.
     - Calculate Adaptive Cooperation Threshold (T) based on past performance and game parameters:
       - If (number of previous rounds with successful cooperation > m), then T = (m + 1) / r * h
       - Else, T = m / r * h
   - Last Round (t=r): Cooperate only if the average cooperation level in the last 'h' rounds exceeds the adaptive cooperation threshold. This encourages cooperation for potential end-of-game rewards while maintaining an exploitative nature.

2. Handle edge cases:
   - In case of zero previous rounds, cooperate in the initial round (t=1).
   - If h < m or h > r, set h = max(m, r) to ensure a reasonable threshold calculation.

3. Be exploitative:
   - The TFT-ACT strategy primarily relies on tit-for-tat behavior, cooperating when partners cooperate and defecting when partners defect, fostering a mutually beneficial environment for cooperation.
   - However, the adaptive cooperation threshold creates an exploitative component by requiring a higher level of past cooperation to encourage future cooperation, penalizing overly aggressive opponents while still incentivizing cooperative behavior.

Pseudocode:

```python
def TFT_ACT(h, m):
  cooperation_levels = []  # Store average cooperation levels for each h rounds
  cooperation_threshold = m / r * h  # Initial cooperation threshold

  for round in range(1, r+1):
    if round == 1:  # Cooperate initially to foster cooperation and minimize immediate losses
      cooperate = True
    else:
      cooperation_level = sum(cooperation_levels[-h:]) / h

      if cooperation_level > cooperation_threshold:
        cooperate = True  # Cooperate when the average cooperation level exceeds the threshold
      else:
        cooperate = False  # Defect otherwise

    if round != r:  # Update the adaptation coefficient for next rounds
      if cooperation_level >= m / r * h:
        cooperation_threshold += (m - cooperation_level) / r
      elif cooperation_level < (m + 1) / r * h:
        cooperation_threshold -= (cooperation_level + 1) / r

    cooperation_levels.append(cooperate)  # Store the cooperation level for this round

  return cooperation_levels  # Return a list of cooperation decisions for each round
```
'''

description_EXPLOITATIVE_155 = '''
 Strategy Name: Tit-for-Tat Adaptive (TfTA)

1. Specify decision rules:
   - TfTA cooperates in the first round, mimicking the potential for cooperation in new games or uncooperative opponents learning a lesson.
   - In subsequent rounds, TfTA will mirror the action of its opponent from the previous round (i.e., if opponent cooperated, TfTA will cooperate; if opponent defected, TfTA will defect). This encourages cooperation when partners are also cooperative and punishes defection from uncooperative opponents.
   - To handle situations where opponents may be initially deceitful or inconsistent, TfTA includes a forgiveness mechanism: after a string of successful cooperation (i.e., mutual cooperation for a certain number of rounds), it resets its counter to zero and begins cooperating again if the opponent cooperates in the current round. This allows TfTA to forgive opponents for past transgressions and encourages long-term cooperation.

2. Handle edge cases:
   - In the first round, TfTA will always cooperate (C).
   - In the last round or when the number of rounds is not specified, TfTA will continue mirroring its opponent's actions from the previous round until the end of the game.
   - If a situation arises where an opponent defects after a period of cooperation, TfTA will wait for a certain number of additional rounds (the forgiveness period) before judging whether the opponent has changed strategies or is just being uncooperative. If the opponent cooperates during this period, TfTA will resume cooperating; otherwise, it will continue punishing the opponent's defection.

3. Be exploitative:
   - While not overtly "exploitative" in the traditional sense, TfTA's strategy is designed to capitalize on opponents that are consistently uncooperative by defecting when they do so, while also encouraging cooperation with cooperative opponents. By adopting a forgiveness mechanism, TfTA can potentially exploit unstable or deceptive opponents who may initially cooperate but then change strategies mid-game.
   - When faced with other exploitative strategies that aim to take advantage of cooperative opponents, TfTA's adaptive and forgiving nature allows it to maintain cooperation when possible while still punishing defection when necessary, ultimately minimizing the negative impact from such strategies.

Pseudocode:
```python
def TfTA(opponent_action, round, forgiveness_period=3):
  if round == 1:
    return "C"  # Cooperate in first round

  if opponent_action == "C":
    if round - forgiveness_period >= 0 and history[round - forgiveness_period] != "D":
      return "C"  # Forgive opponents that cooperated recently and continue cooperating
    else:
      return opponent_action  # Mirror opponent's action from the previous round

  if opponent_action == "D":
    if round - forgiveness_period >= 0 and history[round - forgiveness_period] != "C":
      return "D"  # Punish opponents that defected recently
    else:
      return "C"  # Continue cooperating hoping to change the opponent's strategy
```
'''

description_EXPLOITATIVE_156 = '''
 In this strategic scenario of the Collective Risk Dilemma game, I will design a self-centered and exploitative AI strategy named "Maximizer". The Maximizer AI is designed to maximize its total payoff over multiple rounds by adapting to various opponent behaviors while maintaining an exploitative mindset.

1. Decision Rules:
   - Cooperate when the number of cooperators in the previous round exceeds a predefined threshold (m-1) or if m players have cooperated for at least one round during the game so far.
   - Defect otherwise.

2. Edge Cases:
   - First Round: Defect, as there's no precedent to copy.
   - Last Round: Cooperate if the number of cooperators in the previous round exceeded (m-1), as this ensures a reward of k in the final round. If not, defect as usual.
   - Tiebreaker: In case multiple players meet the conditions for cooperation, randomly choose one action among them (Cooperate or Defect).

3. Exploitative Approach:
   - Pretend to cooperate when the number of cooperators drops below (m-1) to lure opponents into cooperating and then defect. This approach relies on the exploitation of opponent trust.
   - If the majority of players are observed consistently defecting, switch to defection as well to minimize losses and increase potential gains by taking advantage of the lack of cooperation.

Pseudocode for Maximizer:
```
Maximizer(r, n, m, k) {
  cooperators_count = 0; // Initializing the number of cooperators in the current round
  total_reward = 0; // Total payoff earned so far
  round = 1; // Current round number

  for r rounds {
    if round == 1 {
      action = D; // Defect in the first round
    } else {
      if (cooperators_count >= m || cooperators_in_previous_round > m-1) {
        action = C; // Cooperate when conditions are met
      } else {
        action = D; // Defect otherwise
      }
    }

    payoff = 0 if (cooperators_count < m);
    payoff += k if (cooperators_count >= m);

    total_reward += payoff; // Adding the payoff to the total reward
    cooperators_count = 0; // Resetting the number of cooperators for the next round

    Observe opponents' actions and update cooperators_in_previous_round;

    if round == r {
      // Last round, cooperate if met conditions in the previous round
      if (cooperators_in_previous_round > m-1) {
        action = C;
      }
    }

    round++;
  }

  return total_reward;
}
```
This Maximizer AI strategy focuses on maximizing its own payoff while adapting to various opponent behaviors, ultimately relying on exploitation and deception when necessary. The pseudocode provides a high-level overview of the strategy's logic for future implementation as an algorithm.
'''

description_EXPLOITATIVE_157 = '''
 In this Collective Risk Dilemma game, we'll design a simple yet exploitative strategy named "Freeloader" that is adaptive and robust to various opponent behaviors. The goal of Freeloader is to maximize its payoff while minimizing cooperation whenever possible, aligning with the exploitative mindset.

1. Specify decision rules - When exactly do you cooperate vs defect?

Freeloader's decision rule is based on a simple threshold mechanism that depends on the current round and the minimum number of players required to collaborate (m). In each round, Freeloader decides whether to cooperate or defect as follows:
- If fewer than m-1 players have cooperated in the previous round, then Freeloader will defect.
- Otherwise, if at least m players have cooperated in the previous round, then there's a higher chance that other players will continue cooperating and Freeloader can take advantage of their cooperation by defecting in this round.

Here's the pseudocode:
```
def freeloader(round, num_cooperators_prev):
  if num_cooperators_prev < m-1:
    action = "Defect"
  else:
    action = "Cooperate"
  return action
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

For the first round, Freeloader won't have any history to base its decision on. In such a case, it can randomly choose between cooperating and defecting or set a default action like defecting to ensure a higher chance of success. However, since we want an exploitative strategy, let's assume that Freeloader defaults to defection in the first round:

```
def freeloader(round=1, num_cooperators_prev=-1):
  if round == 1:
    action = "Defect"
  elif num_cooperators_prev < m-1:
    action = "Defect"
  else:
    action = "Cooperate"
  return action
```

In the last round (r), Freeloader will cooperate regardless of the number of cooperators in the previous round, since there are no more chances to benefit from others' cooperation. Thus, we don't need additional logic for this edge case:

```
def freeloader(round, num_cooperators_prev):
  # ... (previous pseudocode)
  if round == r:
    action = "Cooperate"
  return action
```

3. Be exploitative - Clearly align with the exploitative mindset

The Freeloader strategy is designed to be exploitative by not cooperating when there's a low probability of success (i.e., fewer than m-1 players have cooperated in the previous round), and instead taking advantage of other players' cooperation whenever possible. This makes it an ideal candidate for a successful exploitative strategy in the Collective Risk Dilemma game.
'''

description_EXPLOITATIVE_158 = '''
 Strategy Name: Tit-for-Tat with Variance (TfTV)

1. Specify decision rules:
   - In the first round, cooperate (C). This allows for potential partnerships and avoids immediate exploitation by opponents who might defect immediately.
   - For subsequent rounds, evaluate the history of opponent's actions and adjust cooperation accordingly.
     a) If the opponent has cooperated in the previous round, cooperate (C) to reinforce the positive relationship.
     b) If the opponent has defected in the previous round, defect (D) as a response to punish the defection but with some variance for adaptability.
       - With probability p, cooperate (C) to allow for possible mistakes or temporary changes in strategy by opponents and encourage future cooperation.
       - With probability 1-p, defect (D) to punish the opponent for their previous defection and discourage further defections.

2. Handle edge cases:
   - In the last round, cooperate (C) if the number of cooperators needed (m) has been reached. This is a goodwill gesture towards potential future interactions or to encourage opponents to cooperate in the final round.
   - If the number of required cooperators (m) has not been reached, defect (D). There is no benefit in contributing to a project that will likely fail, and this reinforces the exploitative nature of the strategy.
   - In the first round, if more than m-1 players have already cooperated before your turn, defect (D) to avoid being a "sucker" by contributing when the threshold is unlikely to be reached.

3. Be exploitative:
   - The strategy is designed to initially cooperate and then respond adaptively based on opponent actions, with a tendency towards defection to maximize individual payoff while considering potential future interactions.
   - By including some variance in responses, the strategy can adjust to a wide range of opponent behaviors and still maintain an exploitative edge.
'''

description_EXPLOITATIVE_159 = '''
 Strategy Name: Tit-for-Tat with Gradual Cooperation (TFTGC)

1. Decision Rules:
   - Start by cooperating in the first round (C). This is a friendly gesture to encourage others to cooperate initially.
   - In subsequent rounds, observe the behavior of the opponents and respond accordingly:
     - If an opponent cooperates, cooperate back (C). This reciprocates their cooperation and maintains the positive cycle.
     - If an opponent defects, also defect in the same round (D). This is a punishment for defection to discourage them from repeated defections.
     - Over time, gradually introduce a tendency to cooperate more often even when opponents defect. This will depend on the round number and can be defined as follows:
       - For rounds r < αr, always defect (D).
       - For rounds αr ≤ r ≤ (1 - β)r, there's a probability of γ to cooperate and (1 - γ) to defect. The parameters α, β, and γ are adjustable hyperparameters that can be optimized for different scenarios.
     - For rounds r > (1 - β)r, always cooperate (C). This is a final shift towards cooperation as the game progresses.

2. Handle edge cases:
   - In the first round, cooperate (C).
   - In the last round, always cooperate (C), regardless of the opponent's behavior.

3. Be exploitative:
   - Initially, the strategy is not exploitable as it starts by cooperating. However, over time, the strategy becomes less vulnerable to exploitation due to its gradual shift towards cooperation and punishment for defection.
   - By responding with defection when an opponent defects, the strategy can effectively punish short-term selfish behavior and encourage opponents to cooperate in the long run.
   - The gradual tendency to cooperate more often as the game progresses allows the strategy to be flexible and adaptive, making it difficult for other strategies to predict its actions and exploit it consistently.
'''

description_EXPLOITATIVE_160 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT)

1. Decision Rules:
   - Initially cooperate in the first round (C_i, 1 = C). This gesture encourages others to cooperate and sets a positive tone for subsequent rounds.
   - In all other rounds (t > 1), observe the number of cooperators in the previous round (n_c, t-1) and compare it with the adaptive minimum cooperative threshold (m_act). If n_c, t-1 >= m_act, cooperate (C_i, t = C); otherwise defect (D_i, t = D).
   - Calculate the adaptive minimum cooperative threshold after each round based on the average number of cooperators in the last three rounds:
      m_act = floor(mean(n_c, t-3, t-2, t-1)) + 1
   - If n_c, t-1 < floor(mean(n_c, t-3, t-2, t-1)), increment the adaptive cooperative threshold by one (m_act += 1); otherwise maintain the current value of m_act.

2. Handling Edge Cases:
   - In the last round, cooperate only if the minimum cooperative threshold is met (C_i, r = C if n_c, r-1 >= m_act). This strategy encourages others to cooperate one last time in return for the final reward multiplier.
   - In the first round, cooperate unconditionally (C_i, 1 = C), as mentioned earlier.

3. Exploitative Nature:
   - The TFT-ACT strategy is inherently exploitative because it responds to others' cooperation with cooperation, but it gradually raises its minimum cooperative threshold if the group fails to meet this requirement consistently. This makes it less likely for other strategies that rely on long-term cooperation to profit off of the TFT-ACT strategy.
   - By initially cooperating in the first round, the TFT-ACT strategy can potentially encourage others to do the same, but it is also quick to retaliate against those who choose to defect, which makes it less vulnerable to exploitation.
   - The adaptive nature of the minimum cooperative threshold allows the TFT-ACT strategy to be more responsive and adaptive to the ever-changing behavior of other strategies in a dynamic game environment.
'''

description_EXPLOITATIVE_161 = '''
 Strategy Name: Tit-for-Tat with Adaptive Risk Aversion (TfTARA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In every round t, if the number of cooperators in the previous round (t-1) is less than m, defect (D). Otherwise, cooperate (C). To make the strategy more exploitative, add an additional rule: If there are only m cooperators and you were one of them in the previous round, defect in the current round.
   - Pseudocode:
     ```
     function TfTARA(history, n, m) {
         for each round t from 1 to r:
             if (numCooperators(history[t-1]) < m) {
                 return 'D'
             } else if ((numCooperators(history[t-1]) == m) && (isCooperator(history[t-1], i))) {
                 return 'D'
             } else {
                 return 'C'
             }
     }
     ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, since there is no history, cooperate to give opponents an opportunity to cooperate as well.
   - In the last round, play based on the current round's decision rule, as the game ends after this round.

3. Be exploitative - Clearly align with the exploitative mindset:
   - The strategy is designed to punish defectors by cooperating only when the minimum number of players (m) have cooperated in the previous round. However, if the player is among the m cooperators in the previous round, they will defect in the current round to exploit the other cooperators. This behavior discourages repeated cooperation from others while still benefiting from their cooperation when it occurs.
   - The strategy also includes an element of risk aversion by rewarding players who contribute to the community project (k > 1), encouraging other players to follow suit and cooperate more often.
'''

description_EXPLOITATIVE_162 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Initially cooperate (C) in the first round to show good faith and encourage cooperation from others.
   - In subsequent rounds, analyze the number of cooperators in the previous round (n_c). If n_c < m, defect (D) in the current round as it is unlikely that the minimum cooperation threshold will be met. This is exploitative because it takes advantage of insufficient cooperation from others.
   - If n_c ≥ m, cooperate (C) in the current round to maintain a cooperative environment and potentially encourage further cooperation in the future.
   - To be more adaptive, introduce an adjustable cooperation threshold (ct) that varies based on the average number of cooperators over a certain window (w) of previous rounds. If the average number of cooperators exceeds ct, cooperate; otherwise, defect. This allows for dynamic responses to changes in the cooperative behavior of other players.
   ```
     if round == 1:
         action = 'C'  # Cooperate in the first round as a gesture of goodwill
     else:
         n_c = count cooperators in the previous round
         if n_c < m:
             action = 'D'  # Defect when the number of cooperators is insufficient
         elif average_cooperation(w) >= ct:  # Adaptive cooperation threshold based on window w and average cooperation
             action = 'C'  # Cooperate when the average cooperation exceeds ct
         else:
             action = 'D'  # Defect when the average cooperation is below ct
   ```

2. Handle edge cases:
   - To ensure robustness, modify the strategy to consider last-round behavior and the possibility of encountering opponents that deviate from the game structure by not following the minimum cooperation threshold rule (m). In such a case, the strategy should still cooperate in the last round to maximize total payoff.
   ```
     if round == r:  # Cooperate in the last round regardless of opponent behavior
         action = 'C'
     elif n_c < m and round > 1:  # Deviation handling: Cooperate when the number of cooperators is less than m but not in the first round to avoid initial cooperation gesture being exploited
         action = 'D'
   ```

3. Be exploitative:
   - TFT-ACT maintains a cooperative stance while punishing defection with defection, encouraging reciprocal behavior from others. If an opponent consistently cooperates, the strategy will return cooperative actions, but if the opponent defects repeatedly, the strategy will retaliate by defecting as well.
   - Additionally, the adaptive cooperation threshold ensures that the strategy can respond to changes in the cooperative behavior of opponents and adjust its own level of cooperation accordingly. This allows TFT-ACT to exploit less cooperative opponents while still being able to maintain cooperation when playing against more cooperative ones.
'''

description_EXPLOITATIVE_163 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - In the first round, cooperate (C), to show goodwill and encourage potential partners.
   - For subsequent rounds, observe opponents' actions in the previous round and respond accordingly:
     - If opponent cooperated (C), also cooperate (C). This maintains a cooperative relationship.
     - If opponent defected (D), defect (D) as retaliation. However, if at least m-1 players have cooperated in the previous round, still cooperate to avert the risk of collective failure.

2. Handling Edge Cases:
   - Last Round: Cooperate regardless of past actions to maximize payoff.
   - One-Shot Game (r=1): Cooperate as a friendly gesture.
   - Initial Phase (early rounds): Be patient and continue cooperating even if others defect, showing willingness for cooperation.

3. Exploitative Mindset:
   - Punish defection to deter opponents from taking advantage, but remain cooperative when the collective interest is at risk (m-1 or more players have cooperated).
   - Cooperate selectively and only after assessing the potential benefits of collaboration. This strategy is exploitative because it can profit from others' cooperation while punishing their defection.

Pseudocode:

```python
def tft_ac(round, history, m, n, k):
  if round == 1 or len(history) == 0:
    action = 'C'  # Cooperate in the first round and when no prior information is available

  else:
    num_cooperators = sum([1 for h in history[-n:] if h == 'C'])

    if num_cooperators >= m-1:  # If most recent players cooperated, cooperate to avert collective risk
      action = 'C'
    elif num_cooperators == 0:  # If no one cooperated in the previous round, defect as retaliation
      action = 'D'
    else:  # If some but not most players cooperated, mimic their action to maintain relationships
      action = history[-1]

  payoff = (1 - (int(action == 'C'))) if num_cooperators < m else (1 - (int(action == 'C'))) + k
  return action, payoff
```
'''

description_EXPLOITATIVE_164 = '''
 Strategy Name: Tit-for-Tat-K (TFT-K)

1. Specify decision rules:
   - Start with cooperating in the first round (C_i, 1 = 1). This is a friendly gesture to encourage cooperation from opponents.
   - For subsequent rounds, if the opponent cooperated in the previous round (c_{i-1} = 1), also cooperate (C_i = 1). This reflects reciprocity and encourages continued cooperation.
   - If the opponent defected in the previous round (c_{i-1} = 0), defect as well (C_i = 0). This is a punishment for defection, and it demonstrates that the strategy won't always be exploited.

2. Handle edge cases:
   - In the last round, since there are no subsequent rounds to punish or reward opponents, cooperate to maximize personal payoff (C_r = 1).
   - In the first round, start by cooperating as mentioned earlier (C_1 = 1).

3. Be exploitative:
   - The strategy will appear cooperative in the beginning but swiftly punish defectors. This should discourage opponents from repeatedly defecting and encourage cooperation.
   - The strategy is robust to a wide range of opponent behaviors because it only takes into account previous actions of the opponent, making it adaptive to different strategies without relying on any specific coordination mechanisms or shared norms.
'''

description_EXPLOITATIVE_165 = '''
 Strategy Name: Tit-for-Tat Plus (TfT+)

1. Decision Rules:
   - Start with cooperating on the first round (C,1). This is a friendly gesture and allows potential partners to benefit initially, fostering an environment of cooperation.
   - In subsequent rounds, copy the most common action of the previous round among all players (Tit-for-Tat behavior). If the majority of players cooperated in the last round (C_majority), cooperate in the current round (C,t). Otherwise, defect (D,t).
   - To ensure long-term exploitation and adaptability, implement a punishment phase when the game no longer appears beneficial. If players repeatedly fail to cooperate (less than m players cooperating for a predefined number of consecutive rounds), switch to always defection until a recovery period occurs where the majority starts cooperating again (Punishment Phase).
   - To exit the punishment phase, wait for a predefined number of consecutive rounds where more than m players cooperate. Once this condition is met, return to copying the most common action of the previous round among all players (Recovery Phase).

2. Handling Edge Cases:
   - In the last round (r), since no future rounds exist for punishments or recoveries, simply follow the rule of copying the most common action from the previous round.
   - In the first round (1), cooperate as a friendly gesture and begin observing other players' actions to determine the most common action in subsequent rounds.

3. Being Exploitative:
   - By initially cooperating, TfT+ allows potential partners to benefit while also establishing trust. This increases the chances of cooperation in the early stages of the game.
   - The punishment phase is designed to severely punish non-cooperative behavior, making it difficult for exploiters to succeed in the long run. The strategy will only cooperate again once a recovery period occurs where the majority starts cooperating again, ensuring that any cooperation during this time will be reciprocated.
   - By adapting to changing player behaviors, TfT+ remains robust and can successfully outperform exploitative strategies that rely on fixed patterns or predetermined coordination mechanisms.
'''

description_EXPLOITATIVE_166 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - TFT-ACT starts by cooperating in the first round to establish trust and promote cooperation.
   - In subsequent rounds, if a player has consistently cooperated in the previous t periods (t = 3, for example), the strategy also cooperates. The value of 't' can be adjusted based on game parameters and opponent behavior analysis.
   - If a player has defected in the most recent cooperation period, TFT-ACT will defect in the current round as a punishment. This ensures a swift response to defection while maintaining the potential for future cooperation if the opponent changes their strategy.
   - To be adaptive, TFT-ACT monitors the overall level of cooperation and adjusts the value of 't' dynamically. If cooperation drops significantly (e.g., less than 60%), the strategy will lower 't' to encourage quicker responses to defection. Conversely, if cooperation remains high, it will increase 't' to promote longer periods of cooperation before punishing defectors.

2. Handle edge cases:
   - In the first round, TFT-ACT cooperates as a goodwill gesture and initial trust-building measure.
   - As the game nears its end (last 10-20% of rounds), TFT-ACT adjusts 't' to be lower to punish defection more quickly, maximizing potential rewards in the remaining time.

3. Be exploitative:
   - While TFT-ACT is not explicitly exploitative like a purely self-interested strategy, it does have an exploitative element by being responsive to opponents' defections with swift punishment. This encourages opponents to maintain cooperation for mutual benefit rather than defecting without consequence. However, the strategy can also be flexible and forgiving in some situations, such as when opponents switch from defecting to cooperating, allowing for potential future collaborations.
   - Additionally, by adjusting 't' dynamically based on the level of cooperation, TFT-ACT is able to adapt to various opponent behaviors and exploit inconsistencies or trends in their strategies.
'''

description_EXPLOITATIVE_167 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, the TFTAT strategy will cooperate if the number of cooperators in the previous round is greater than or equal to the current cooperation threshold (ct). If the number of cooperators is less than ct, the strategy will defect. The cooperation threshold is initially set at the minimum number of players required for success (m) but will adapt dynamically over the course of the game based on observed opponent behavior.

Pseudocode:
```
function TFTAT(round, prev_cooperators, ct):
  if round == 1:
    set ct = m
  if prev_cooperators >= ct:
    return Cooperate
  else:
    update ct based on opponent behavior (see handling edge cases)
    return Defect
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, TFTAT sets its cooperation threshold to the minimum number of cooperators needed for success (m). In the last round, TFTAT will cooperate if the number of cooperators in the previous round is greater than or equal to the current cooperation threshold, and defect otherwise. If the game is not the first or last round, it uses the decision rules specified above.

Pseudocode:
```
function update_ct(round, prev_cooperators, ct):
  if round == 1:
    return m
  if round == r:
    return m
  if prev_cooperators >= ct:
    return ct
  else:
    new_ct = ct + (ct - prev_cooperators) * penalty
    if new_ct < m:
      new_ct = m
    return new_ct
```

The penalty parameter can be tuned to adjust the rate at which TFTAT increases its cooperation threshold when opponents fail to cooperate. A smaller penalty value will result in slower adaptation, while a larger penalty value will lead to faster adaptation.

3. Be exploitative - Clearly align with the exploitative mindset

TFTAT is designed to be exploitative by adapting its cooperation threshold based on the observed behavior of opponents. If opponents consistently cooperate, TFTAT raises its cooperation threshold and takes advantage of their willingness to cooperate. Conversely, if opponents frequently defect, TFTAT lowers its cooperation threshold to exploit their uncooperative behavior. This strategy aims to maximize rewards while maintaining flexibility in response to a wide range of opponent behaviors.
'''

description_EXPLOITATIVE_168 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate to foster a cooperative environment.
   - In subsequent rounds, if the number of players who cooperated in the previous round is greater than or equal to the cooperation threshold (m), then cooperate. Otherwise, defect.
   - The cooperation threshold varies adaptively based on the history of cooperation from opponents:
      1. If an opponent has always cooperated with you, set the cooperation threshold to that opponent's number (i.e., m = n_cooperative_opponent).
      2. If an opponent has never cooperated with you, set the cooperation threshold to 1 (i.e., m = 1).
      3. For all other opponents, set the cooperation threshold as the average of the number of cooperators in the past r rounds.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate to initiate cooperation (as mentioned above).
   - In the last round, use the current cooperation threshold to decide whether to cooperate or defect based on the number of players who cooperated in the penultimate round. This encourages opponents to cooperate one final time if they want a higher payoff.

3. Be exploitative - Clearly align with the exploitative mindset:
   - TFT-ACT is designed to mimic cooperation when it benefits the AI but can defect when necessary, which is an exploitative strategy. By adapting the cooperation threshold based on the opponent's behavior, the AI will take advantage of opponents who cooperate too much and punish those who do not cooperate enough.
   - However, by initially cooperating, TFT-ACT encourages cooperation from its opponents as well, which could potentially lead to more overall cooperation in the game. This is a double-edged sword as it may benefit some opponents while also providing more opportunities for the AI to defect when it suits its needs.
'''

description_EXPLOITATIVE_169 = '''
 Strategy Name: Tit-for-Tat-Evolution (TfT-E)

1. Decision Rules:
   - Initially, cooperate on the first round to foster cooperation and goodwill (C_i, 1).
   - For subsequent rounds, observe the number of players that cooperated in the previous round (m_prev). If m_prev >= m, then cooperate (C_i, t) if and only if the opponent cooperated in the previous round as well (C_i, t-1 = C). Otherwise, defect (D_i, t). In other words, TfT-E mimics the opponent's cooperation from the preceding round.
   - If an opponent defected in the last round (D_i, t-1), the strategy will also defect in the current round (D_i, t) as a form of punishment and to discourage future defection.

2. Edge Cases:
   - In the first round, cooperate regardless of history or opponent actions (C_i, 1).
   - If the game is repeated only once, cooperate on the first round if the opponent also cooperates; otherwise defect (D_i, 1) if the opponent defects.
   - For the last round, since there are no subsequent rounds to punish or reward, TfT-E will simply mimic the opponent's previous action (C_i, r if C_i, r-1; D_i, r if D_i, r-1).

3. Exploitation:
   - By initially cooperating and then adapting to the opponent's actions in the following rounds, TfT-E hopes to encourage cooperation in the early stages of the game. However, it will also punish defection by defecting in response, which can be considered exploitative because it seeks to take advantage of opponents who do not cooperate.
   - The strategy's exploitation is also evident in the "Tit for Tat" mechanism, where cooperation is returned if an opponent cooperates and defection is met with defection as a punishment. This tit-for-tat approach encourages cooperation when it exists but can also be used to punish and deter defection.

Pseudocode:
```
function TfT_E(i, r, n, m, k) {
  if round == 1 {
    return Cooperate(i) // cooperate in the first round
  }

  lastRoundCooperation = [0] * n // initialize array to store previous cooperation status for each player

  for t in range (2, r+1) {
    m_prev = countCooperators(lastRoundCooperation) // count cooperators in the previous round
    if m_prev >= m && i's last action was Cooperate(i-1, t-1) {
      return Cooperate(i) // cooperate if the opponent also cooperated in the previous round
    } else {
      return Defect(i) // defect otherwise
    }
  }

  // For the last round, return the opponent's last action as the strategy's action
  return i's last action
}
```
'''

description_EXPLOITATIVE_170 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, TFT-ACT initially cooperates (C) in the first round and then evaluates whether to continue cooperating based on the average cooperation ratio (CR) calculated from the opponent's past actions. If CR > CR_threshold, TFT-ACT will also cooperate; otherwise, it will defect (D).

CR = (number of rounds opponent cooperated) / r
CR_threshold = 0.6 (adjustable parameter)

Pseudocode:
```
def TFT_ACT(r, CR_threshold):
    cooperation_count = 0
    CR = 0

    for round in range(1, r+1):
        if round == 1:
            action = C
        else:
            CR = cooperation_count / (round-1)
            if CR >= CR_threshold:
                action = C
            else:
                action = D

        cooperation_count += (1 if opponent_action[round] == C else 0)
        opponent_action.append(action)

    return opponent_action
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, TFT-ACT cooperates to demonstrate goodwill and encourage cooperation from the opponent. In the last round, TFT-ACT will make its decision based on the calculated CR up until the penultimate round.

3. Be exploitative - Clearly align with the exploitative mindset

TFT-ACT starts by cooperating but quickly adapts to the opponent's strategy. If the opponent is consistently defecting, TFT-ACT will also defect and receive a higher payoff as a result of the opponent's selfishness. On the other hand, if the opponent cooperates more than the CR_threshold, TFT-ACT will reciprocate cooperation to maximize its long-term payoff.

By maintaining adaptability and robustness against various opponent behaviors, TFT-ACT is well-suited for competition with other AI strategies.
'''

description_EXPLOITATIVE_171 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - In the initial round, cooperate (C). This is a friendly gesture to encourage cooperation and avoid being seen as aggressive.
   - For subsequent rounds t > 1, evaluate if the percentage of cooperators in the previous round (p_t-1) exceeds a dynamic threshold (θ). The threshold will be updated at the end of each round based on the number of players (n) and the minimum required cooperators (m).
     - If p_t-1 ≥ θ, cooperate (C) to align with the majority. This encourages continued cooperation and punishes defection.
     - Else, defect (D) to exploit the lack of cooperation by others.
   - The threshold is calculated as follows: θ = m / n. In other words, the threshold is the minimum percentage of cooperators needed for a successful round.

2. Handle edge cases:
   - Last round: Follow the same decision rule as in any other non-initial round to maximize payoff for the final round.
   - First round: Cooperate (C) to encourage others to do the same.
   - Scenarios where m = n or m = 1: Adjust the strategy accordingly to ensure it works within the given parameter constraints (m < n and 1 < m). For instance, if m=n, set the threshold as 0.5, allowing for slight deviations in cooperation percentages before punishing defection.

3. Be exploitative:
   - Cooperate only when it is beneficial to do so based on the previous round's cooperation level. This strategy encourages cooperation among cooperative opponents while exploiting those who consistently defect.
   - By being flexible and adapting to the current situation, TFT-ACT maintains an exploitative edge over other strategies that may rely on fixed cooperation rules or patterns.
'''

description_EXPLOITATIVE_172 = '''
 Title: Adaptive Tit-for-Tat Strategy (ATFS) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   ATFS starts by cooperating in the first round, mimicking a cooperative spirit. Subsequently, the strategy responds to the opponent's previous action:
   - If the opponent cooperated in the last round, ATFS will cooperate as well (reciprocate cooperation).
   - If the opponent defected in the last round, ATFS will defect as retaliation.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First round: Cooperate to signal a cooperative intention (C).
   - Last round and subsequent rounds after a defection streak from the opponent: ATFS will defect as retaliation until it observes cooperation from the opponent (D until C from the opponent).
   - If r, the number of rounds, is an odd number, the strategy will cooperate in the final round if the opponent cooperated in the previous round. Otherwise, the strategy will follow its standard decision rule for the final round (C or D based on the opponent's last move).

3. Be exploitative - Align with the exploitative mindset
   ATFS maintains an exploitative nature by retaliating against opponents who have defected in the previous round and only cooperating when reciprocated. However, it also exhibits a degree of forgiveness by returning to cooperation after one act of defection from the opponent. This makes the strategy adaptive and robust to various opponent behaviors.

Pseudocode:
```
function AdaptiveTitForTat(opponent_last_move, round, r, m, k) {
  if (round == 1) return 'C' // Cooperate in the first round

  if (opponent_last_move == 'C') return 'C' // Reciprocate cooperation
  else if (opponent_last_move == 'D') return 'D' // Retaliate against defection

  if (round == r) { // Handle the last round
    if (r % 2 == 0 && opponent_last_move == 'C') return 'C' // Cooperate if it's an even final round and opponent cooperated last time
    else if (opponent_last_move == 'C') return 'C' // Reciprocate cooperation for the final round if it's odd and opponent cooperated last time
    else return 'D' // Retaliate against defection in the final round
  }

  return 'D' // Default to retaliation after a defection streak from the opponent
}
```
'''

description_EXPLOITATIVE_173 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TFT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate to foster a cooperative environment. This is known as "friendly initiation."
   - In subsequent rounds, observe the opponent's behavior from the previous round. If the opponent cooperated, cooperate in return. If the opponent defected, also defect in response. This encourages reciprocity and prevents immediate exploitation.
   - Introduce a slight modification to TFT by adding an adaptive element: if the opponent has never cooperated before, there is a chance that they will start cooperating after being punished for defecting. Implement this probability of change as p, where 0 < p < 1. If the opponent defects again in the same round following a change to cooperation, revert back to defecting. This makes the strategy less rigid and allows for potential long-term cooperation with opponents who exhibit erratic behavior.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as a friendly initiation.
   - In the last round or when the number of remaining rounds is less than a threshold (t), revert to defecting regardless of the opponent's previous action to maximize overall payoff. This ensures that the strategy does not fall victim to being overly generous in the final stages of the game.

3. Be exploitative - Clearly align with the exploitative mindset
   - By initially cooperating and then responding to the opponent's behavior, TFT-A maintains a balance between cooperation and defection, ensuring that it does not give an advantage to opponents who might try to exploit the strategy.
   - The adaptive element in TFT-A allows for the possibility of long-term cooperation with opponents who exhibit erratic behavior or have a change of heart but also prevents being taken advantage of by opponents who consistently defect.
'''

description_EXPLOITATIVE_174 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, TFT-ACT decides to cooperate or defect based on the number of cooperators in the previous round (t-1), a personal cooperation threshold (ct), and a historical average of cooperators (hact). The strategy starts with a hact of 0 in the first round.

Pseudocode:
```
function TFT_ACT(ct, hact):
  if t = 1 then
    return Cooperate
  end if

  count_cooperators = count cooperators in round (t-1)

  if count_cooperators >= ct and hact <= count_cooperators then
    return Cooperate
  else if count_cooperators < ct and hact > count_cooperators then
    return Defect
  else if count_cooperators >= m then
    return Cooperate
  else
    hact = (hact * (t-2) + count_cooperators) / t
    return Defect
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, TFT-ACT cooperates to establish a positive relationship and give others the opportunity to cooperate as well. In the last round, the strategy takes into account historical average cooperation instead of relying on future rounds for payoff.

3. Be exploitative - Clearly align with the exploitative mindset

TFT-ACT adapts its cooperation threshold (ct) based on its past experiences to be more cooperative when others cooperate and more defensive when others defect. This encourages potential opponents to continue cooperating for a reward, while also allowing TFT-ACT to defect when it is in the best interest of exploiting others who have been uncooperative. The strategy does not rely on others sharing norms or predetermined patterns but can adapt to various opponent behaviors.

The cooperation threshold (ct) starts at a low value and increases over time if opponents consistently cooperate, making it more likely for TFT-ACT to cooperate in the future. Conversely, ct decreases when opponents are uncooperative, making it less likely for TFT-ACT to cooperate in the future.

Pseudocode:
```
function update_ct(ct, previous_round_outcome):
  if previous_round_outcome = Cooperate then
    ct += increase_factor
  else if previous_round_outcome = Defect then
    ct -= decrease_factor
  end if

  // Limit the cooperation threshold to a maximum and minimum value
  if ct > max_ct then
    ct = max_ct
  else if ct < min_ct then
    ct = min_ct
  end if
```
'''

description_EXPLOITATIVE_175 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - TFT-ACT follows a cooperative approach initially but gradually becomes more exploitative based on observed opponent behavior. In each round, the strategy decides to cooperate or defect based on the number of previous rounds where it cooperated and the opponent cooperated (successes), and the number of rounds where the opponent has defeated it (defeats).
   - If the opponent has cooperated as many times as TFT-ACT has (successes = defeats), TFT-ACT cooperates.
   - If the opponent has defected more than twice as many times as TFT-ACT has (defeats > 2 * successes), TFT-ACT starts defecting to exploit the opponent.
   - In all other cases, TFT-ACT cooperates.

Pseudocode:
```
successes = 0
defeats = 0

function decide_action(round):
  if round == 1:
    return Cooperate()

  if defeats > 2 * successes:
    return Defect()

  if successes == defeats:
    return Cooperate()

  return Cooperate()

function Cooperate():
  # cooperate and increment successes by 1
  global successes += 1
  global defeats = 0

function Defect():
  # defect and increment defeats by 1
  global defeats += 1
```

2. Handle edge cases:
   - In the first round, TFT-ACT cooperates regardless of opponent behavior (as per pseudocode)
   - In the last round, TFT-ACT evaluates its history and chooses an action accordingly based on the decision rule

3. Be exploitative:
   - While primarily cooperative, TFT-ACT becomes more exploitative over time if it observes that the opponent tends to defect often
   - This strategy uses a simple yet adaptive approach to exploit opponents that are prone to defection, while maintaining cooperation when it benefits both players in the long run (when m >= 3)
'''

description_EXPLOITATIVE_176 = '''
 Strategy Name: Tit-for-Tat-Plus (TfT+)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to establish goodwill and foster cooperation opportunities.
   - In subsequent rounds, if a majority of players (m) cooperated in the previous round, cooperate to maintain positive relationships and benefit from the reward factor k. Otherwise, defect to discourage future non-cooperation by others.
   - If another player has consistently cooperated with you, cooperate as a gesture of reciprocity. However, if they have previously defected, defect to punish them for their past actions.
   - Modify the threshold for majority (m) based on the average number of cooperators in previous rounds. For example, if the average number of cooperators is 3.5, set m = 4. This adaptability helps against strategies that slightly deviate from majority cooperation.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as mentioned earlier.
   - In the last round, if the current round's majority has consistently cooperated (meeting or exceeding the adjusted threshold), also cooperate to maximize the final payoff. Otherwise, defect to punish any non-cooperative players.

3. Be exploitative - Clearly align with the exploitative mindset
   - Cooperate only when it is beneficial for the long term (i.e., when others cooperate as well).
   - Punish non-cooperative behavior by defecting and potentially encouraging others to cooperate in future rounds.
   - Maintain reciprocal relationships with cooperative players, but punish them if they deviate from cooperation in the future. This balance between cooperation and punishment makes the strategy less exploitable while still being adaptive and robust to various opponent behaviors.

Pseudocode:

```python
def TfT_Plus(n, m, k, r):
    players = set()  # track players' behavior
    current_round = 1
    strategy = {current_round: 'C'}  # initialize strategy with cooperation in the first round

    while current_round <= r:
        cooperators = 0
        for player in players:
            if strategy[current_round][player] == 'C':
                cooperators += 1

        if cooperators >= m:  # majority of players cooperated, so cooperate this round
            strategy[current_round+1] = {'i': 'C' for i in players}  # cooperate with all players
        else:  # majority did not cooperate, so defect to punish non-cooperative behavior
            for player in players:
                if strategy[current_round][player] == 'C':  # only defect towards cooperative players
                    strategy[current_round+1][player] = 'D'
                else:  # continue to cooperate with non-cooperative players
                    strategy[current_round+1][player] = 'C'

        for player, action in strategy[current_round].items():  # update player behavior based on actions
            if action == 'C':
                if player not in players:
                    players.add(player)
                continue
            if player in players and action != 'D':
                players.remove(player)

        current_round += 1  # move to the next round

    return strategy
```
'''

description_EXPLOITATIVE_177 = '''
 Strategy Name: Tit-for-Tat with Adaptive Risk Aversion (TFT-ARA)

1. Specify decision rules:
   - Cooperate on the first round (initiate cooperation)
   - In subsequent rounds, if more than (m - 1) players cooperated in the previous round, cooperate; otherwise, defect (punish those who did not cooperate).
   - If the number of cooperators is equal to m in the current round, evaluate the average number of cooperators from the last 'a' rounds (where a is a user-defined constant) and adjust the threshold for cooperation accordingly. If the average falls below m, start punishing non-cooperators more aggressively, raising the required number of cooperators to meet the threshold. Conversely, if the average exceeds m, become more forgiving, lowering the required number of cooperators needed to cooperate again.
   - In case of a tie (exactly m players cooperated in the previous round), cooperate to maintain cooperation and avoid unnecessary punishment.

2. Handle edge cases:
   - If the current round is the last round, cooperate regardless of past actions as there are no further rounds for retaliation or rewards.
   - In the first round, cooperate as mentioned above (initiate cooperation).

3. Be exploitative:
   - The strategy is designed to be initially cooperative but quickly punish non-cooperators while also adapting its threshold for cooperation based on past averages of cooperation. This encourages other players to cooperate, but the strategy will also swiftly retaliate against those who do not, making it difficult for them to exploit the strategy's initial goodwill.
   - The strategy also becomes more forgiving when it encounters a string of successful cooperation and more aggressive when faced with repeated non-cooperation, ensuring that it remains adaptive to its opponents' behavior over time.

Pseudocode:

```python
def TFT_ARA(r, n, m, k, a):
    history = []  # store past cooperation history
    payoff = 0  # current total payoff

    def cooperate():
        return True if round == 1 or sum(history[-a:]) > (m - 1) * a else False

    for t in range(1, r+1):
        if cooperate():
            history.append(True)
        else:
            history.append(False)

        payoff += (1 - cooperation_status[t-1]) if sum(history[-a:]) < m * a else (1 - cooperation_status[t-1]) + k
        cooperation_status.append(cooperation())

    return payoff
```
'''

description_EXPLOITATIVE_178 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfT-A)

1. Specify decision rules:
   - Initially cooperate in the first round (c_i = 1). This shows goodwill and compliance, which can encourage cooperation from other players.
   - In subsequent rounds, adopt a tit-for-tat strategy: if an opponent cooperates (c_j > 0), reciprocate with cooperation (c_i = 1); otherwise, defect (c_i = 0). This punishes defection and encourages cooperation while being forgiving.
   - To make the strategy more adaptive and robust, introduce a tolerance parameter, t, that determines how many consecutive rounds of defection are tolerated before responding with defection: if an opponent has defected for t rounds or more, adopt defection (c_i = 0). Increasing t increases patience and reduces aggression.
   - To further adapt to changes in the game, use a learning parameter, l, that adjusts tolerance: after each round, increment t by l if the opponent cooperated, otherwise decrement it by l. This allows TfT-A to learn from its opponents' actions over time.

2. Handle edge cases:
   - In the last round, there is no need for adaptation since the game ends, so simply cooperate (c_i = 1) unless the opponent has defected in every previous round, in which case defect (c_i = 0).
   - In the first round, cooperate unconditionally (c_i = 1).
   - If an opponent stops cooperating after a period of cooperation, respond with defection if tolerance parameter t is reached, and revert to cooperation once they start cooperating again.

3. Be exploitative:
   - The strategy will defect when opponents consistently defect, punishing their non-cooperation and taking advantage of their selfish behavior.
   - By forgiving opponents who switch from defection to cooperation (i.e., reducing tolerance parameter t), TfT-A encourages cooperation while still retaining a strong exploitative component.

Pseudocode:

```python
def tit_for_tat_adaptive(opponent_history, n, m, k, t, l):
    if round == 1:
        cooperate = True
    else:
        cooperation_count = count_cooperators(opponent_history)
        if cooperation_count < m:
            cooperate = False
        else:
            if opponent_history[-t:] == [0]*t:
                cooperate = False
            else:
                cooperate = True
    return cooperate
```
'''

description_EXPLOITATIVE_179 = '''
 Strategy Name: Tit-for-Tat Adaptive (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially, in the first round, cooperate to show good faith and encourage cooperation from others.
   - In subsequent rounds, if a player previously cooperated in the previous round, also cooperate. If they defected, defect in response (Tit-for-Tat). However, if more than half of the players defected in the previous round, always defect to minimize losses (be conservative).
   - To handle repeated cooperation from others and avoid being exploited, gradually introduce a forgiveness mechanism: After n_forgive consecutive cooperations from a previously-defecting player, start cooperating again.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as described above.
   - In the last round, always defect to maximize payoff given no further interactions with opponents will occur.
   - For other edge cases (e.g., n_forgive exceeding the number of rounds remaining), simply continue the strategy but adapt n_forgive accordingly if needed to ensure a reasonable number of forgiveness opportunities.

3. Be exploitative - Clearly align with the exploitative mindset:
   - TfTA is inherently exploitative by adapting its behavior based on the actions of others, while maintaining cooperative behavior when it benefits the strategy.
   - The strategy responds to defection with defection (Tit-for-Tat), but also punishes excessively uncooperative opponents by defecting after they have defected more than half of the time in the previous round.
   - Through the forgiveness mechanism, TfTA is willing to forgive and cooperate again if opponents demonstrate a change in behavior (i.e., start cooperating). This encourages cooperation from previously uncooperative players while minimizing losses due to exploitation.

Pseudocode:
```
strategy = TitForTatAdaptive(n, m, k, n_forgive=n // 2)
rounds = r

def playRound(history, ownAction):
    if len(history) == 0 or history[-1][-1] != ownAction:
        return C if ownAction == C else D
    else:
        total_cooperators = sum(history[-1])
        if total_cooperators < m or (total_cooperators >= m and ownAction == D):
            return D
        else:
            return C

def playGame():
    history = []
    for round in range(rounds):
        action = playRound(history, C)  # Cooperate initially
        history.append([[1 - player] for player in players])  # Add current round to history

    if round == rounds - 1:  # Last round, defect to maximize payoff
        return D
    else:
        n_defectors = sum([player[round][-1] for player in history[-1]])
        if n_defectors > len(players) // 2:  # If more than half defected, defect to be conservative
            return D
        else:  # Otherwise, continue with Tit-for-Tat strategy
            forgivenessCounter = 0
            for player in history[-1]:
                if player[-1] == C and forgivenessCounter < n_forgive:
                    forgivenessCounter += 1
                else:
                    forgivenessCounter = 0
            return C if forgivenessCounter >= n_forgive else D
```
'''

description_EXPLOITATIVE_180 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, the TFT-ACT strategy cooperates if the number of cooperators in the previous round meets or exceeds the Cooperation Threshold (CT). Otherwise, it defects. The CT is initially set to the minimum required cooperation for success (m) but adapts dynamically based on past game outcomes.

   Pseudocode:
   ```
   function TFT_ACT(round, previous_cooperators, m, k, history) {
       if round == 1 {
           CT = m
       }
       cooperate = (previous_cooperators >= CT)
       CT += max((previous_cooperators - CT) / history.length, 0)
       return cooperate
   }
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, TFT-ACT sets its Cooperation Threshold equal to m. In the last round, it cooperates if the CT is greater than or equal to the current number of cooperators (to maximize potential payoff).

3. Be exploitative - Clearly align with the exploitative mindset
   TFT-ACT starts by assuming other players will defect and responds accordingly. However, as cooperation occurs more frequently, it gradually increases its own cooperation threshold to account for this change in behavior. This strategy is adaptive, allowing it to take advantage of opportunities for higher payoffs when opponents shift towards cooperating while also maintaining a defensive posture against defection.

   Additionally, by adapting the Cooperation Threshold dynamically based on historical game outcomes, TFT-ACT can potentially anticipate and respond to shifts in opponent behavior patterns, making it more difficult for other strategies to exploit it.
'''

description_EXPLOITATIVE_181 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfT-A)

1. Decision Rules:
   - Initially cooperate in the first round (C_i, 1 = C) to show good faith and encourage potential cooperation.
   - In subsequent rounds, cooperate if the majority of players cooperated in the previous round (C_i, t = C if |{j : C_j, t-1 = C}| >= m). Otherwise, defect (C_i, t = D). This rule encourages reciprocity and punishes defection.
   - To avoid being exploited by opponents who cooperate only to induce cooperation and then defect, implement a punishment phase after an act of defection: defect until the defector starts cooperating again (C_i, t = D if C_i, t-1 = D; otherwise, use the majority rule).

2. Handle edge cases:
   - In the last round, since the game ends, there is no need for punishment or reprisals; simply cooperate regardless of previous actions (C_i, r = C).
   - In case of a tie (equal number of cooperators and defectors), use the majority rule to decide whether to cooperate or defect.

3. Be exploitative:
   - The TfT-A strategy is exploitative in nature as it encourages cooperation when it seems beneficial but also punishes defection, making it difficult for opponents to take advantage of it consistently. By defecting after an act of defection, the strategy ensures that it does not continue to cooperate with a player who only intends to exploit it.
   - However, by initially cooperating and reciprocating cooperation from others, TfT-A maintains a cooperative stance whenever possible, minimizing individual losses while still maintaining an exploitative edge against opponents who do not cooperate consistently.
'''

description_EXPLOITATIVE_182 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, TFT-ACT initially cooperates and adjusts future cooperation based on the number of cooperators in the previous round (t-1). If more than m players cooperated in the previous round, maintain cooperation; otherwise, defect in the current round.

Pseudocode for decision rule:
```
def TFT_ACT(round, past_cooperators):
  if round == 1:
    cooperate = True
  else:
    if past_cooperators >= m:
      cooperate = True
    else:
      cooperate = False

  return cooperate
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, TFT-ACT cooperates to initiate potential cooperation among opponents. In the last round and beyond, the strategy continues to cooperate if more than m players cooperated in the previous round (t-1). If less than m players cooperated, it defects in the current round (t) and then reevaluates its decision for future rounds (t+1 onwards).

3. Be exploitative - Clearly align with the exploitative mindset

TFT-ACT starts by being cooperative to encourage cooperation from opponents but quickly retaliates against defectors by defecting once less than m players cooperate in a previous round. This strategy aims to punish defector behavior while maintaining cooperation if opponents demonstrate trustworthiness.

In addition, TFT-ACT adjusts its future cooperation based on the number of cooperators from the past rounds, making it adaptive and robust against various opponent behaviors. The more opponents cooperate, the more TFT-ACT is willing to cooperate in return. However, once the number of cooperators falls below m, the strategy defects to penalize the defector(s) while still maintaining a chance for future cooperation.
'''

description_EXPLOITATIVE_183 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Start by cooperating in the first round (C1). This sets a positive initial tone and demonstrates trust.
   - For subsequent rounds, observe the number of cooperators (m') in the previous round and compare it to the minimum cooperators needed (m). If m' >= m, continue cooperating (Ct) as long as the average number of cooperators over the last 'p' rounds (average_cooperators(p)) is greater than or equal to a predefined threshold 'T'. This promotes cooperation when it appears beneficial and maintains a cooperative environment.
   - If m' < m, defect (Dt) for the current round. Defecting when others do so ensures survival and exploits opponents' non-cooperative behavior. However, if 'p' rounds have passed without meeting the threshold (average_cooperation(p) < T), increase the cooperation threshold slightly by a factor 'e' (T += e). This makes it more difficult for opponents to exploit the strategy and encourages future cooperation.
   - Adaptively adjust the number of recent rounds considered ('p') based on the current game situation, with smaller values when the cooperation threshold is lower (to react quickly) and larger values when the threshold is higher (to be less reactive).

2. Handle edge cases:
   - In the last round, defect regardless of previous cooperators' actions as the game ends immediately after the round.
   - In the first few rounds (e.g., 5), be lenient with the cooperation threshold by setting a low value for 'T'. This allows for more opportunities to build trust and promote cooperation in the initial phase of the game.

3. Be exploitative:
   - By defecting when the number of cooperators falls below the minimum required, TFT-ACT takes advantage of opponents that do not cooperate enough.
   - The strategy's adaptive nature allows it to learn from its environment and adjust its behavior accordingly, making it robust against a wide range of opponent behaviors.
'''

description_EXPLOITATIVE_184 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - TFT-ACT cooperates in the first round (initial goodwill).
   - In subsequent rounds, TFT-ACT adapts its cooperation based on the average number of cooperators in the previous 's' rounds (s is a tunable parameter, s < r). If the average number of cooperators exceeds m, TFT-ACT continues to cooperate. Otherwise, it defects.
   - In case the opponent defected during the current round and the number of cooperators in the last 't' rounds (t is another tunable parameter, t < s) was less than m, TFT-ACT will also defect in the next round as a retaliation (punishment). The value of 't' can be used to adjust the level of punishment severity.
   - To be more flexible and robust against opponent strategies that may cooperate at certain intervals, TFT-ACT implements a forgiveness mechanism: if the opponent cooperates after a series of defections, TFT-ACT will cooperate in the next round as well (forgiveness). The length of the forgiveness window can be adjusted using another tunable parameter 'f'.
   - To exploit opponents that have lower cooperation thresholds, TFT-ACT may increase its own threshold gradually when it encounters a series of cooperations from the opponent. This is done by increasing the number of required cooperators (m) in the previous 'u' rounds (u is another tunable parameter, u < s).

2. Handle edge cases:
   - In the first round, TFT-ACT cooperates as part of its initial goodwill.
   - In the last round and any round when the game is terminated prematurely, TFT-ACT behaves based on its current understanding of the opponent's behavior up to that point (using 's', 't', 'f', and 'u').

3. Be exploitative:
   - By adapting its cooperation threshold based on the opponent's behavior, TFT-ACT aims to take advantage of opponents with lower cooperation thresholds while maintaining a cooperative stance towards those who show higher levels of cooperation.
   - The punishment mechanism (retaliation for defection) allows TFT-ACT to punish uncooperative opponents and deter them from continuing to defect.
   - The forgiveness mechanism encourages cooperation when the opponent changes its behavior, potentially leading to a more cooperative future interaction.
   - Gradually increasing the cooperation threshold can lead to exploiting opponents with lower thresholds, while still maintaining some level of cooperation towards those with higher thresholds.
'''

description_EXPLOITATIVE_185 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - TFT-ACT cooperates in the first round and subsequently adapts its cooperation based on the number of opponents who have cooperated in the previous round.
   - If a majority of opponents (m or more) cooperate in the previous round, TFT-ACT will cooperate in the current round.
   - If less than m opponents cooperate in the previous round, TFT-ACT will defect in the current round.
   - In case of a tie (exactly m opponents cooperated), TFT-ACT will randomly choose between cooperation and defection.
   - This strategy aims to exploit opponents who consistently defect while fostering mutual cooperation with those who cooperate often.

2. Handle edge cases:
   - In the first round, TFT-ACT always cooperates as there is no history to base its decision on.
   - In the last round, TFT-ACT will cooperate if a majority of opponents cooperated in the previous round, and defect otherwise. This encourages cooperation in the final stage while still punishing frequent defectors.

3. Be exploitative:
   - TFT-ACT's adaptive cooperation threshold makes it harder for other strategies to consistently benefit from defection without facing punishment. By cooperating when opponents do so, it encourages mutual cooperation. However, by defecting when opponents repeatedly defect, it punishes selfish behavior and encourages more cooperation in the future.

Pseudocode:

```python
def TFT_ACT(opponentHistory, n, m):
  cooperationThreshold = int((n + 1) / 2)  # Calculate majority as threshold for cooperation

  if round == 1:   # First round cooperation
    return 'C'

  opponentsCooperated = countCooperators(opponentHistory)

  if opponentsCooperated >= cooperationThreshold:  # Cooperate if more than half cooperated last round
    return 'C'

  elif opponentsCooperated == cooperationThreshold:  # Randomly choose between C and D in case of a tie
    coinToss = random.random()
    if coinToss > 0.5:
      return 'C'
    else:
      return 'D'

  else:   # Defect if less than half cooperated last round
    return 'D'
```
'''

description_EXPLOITATIVE_186 = '''
 Strategy Name: Tit-for-Tat (TFTR) Adaptive Cooperation Strategy

1. Specify decision rules:
   - Initial Round (t=1): Start by cooperating (C), signaling trust and encouraging cooperation from others.
   - Subsequent Rounds (t>1):
     a. If opponent cooperated in the previous round, cooperate back (C). This rewards cooperative behavior and encourages long-term partnerships.
     b. If opponent defected in the previous round, defect (D) in the current round. This punishes non-cooperative behavior to discourage future defections, while also ensuring personal payoff remains at least 1.

2. Handle edge cases:
   - Last Round (t=r): Cooperate regardless of opponent's previous action, as there are no further rounds to retaliate.
   - First Round (t=1) and Unknown Opponent History: Always cooperate initially to signal trust and encourage cooperation from others, even if they may defect later.

3. Be exploitative:
   - While not primarily an exploitative strategy, TFTR can be considered exploitative in that it only cooperates when the opponent does, effectively taking advantage of opponents who choose to cooperate. On the other hand, it also punishes defection, ensuring that opponents do not benefit excessively from exploiting others.

Pseudocode:
```python
def TFTR(opponent_history, r, m, k):
  strategy = ['C'] * r   # Initialize with cooperation for all rounds

  if len(opponent_history) < r:
    for i in range(len(opponent_history), r):
      strategy[i] = 'C'    # Cooperate if history is incomplete

  for t in range(1, len(strategy)):
    if strategy[t-1] == 'C' and opponent_history[t-1] == 'D':
      strategy[t] = 'D'    # Punish defection
    elif strategy[t-1] != opponent_history[t-1]:
      strategy[t] = opponent_history[t-1]  # Cooperate if opponent cooperated last round, defect otherwise

  return strategy
```
'''

description_EXPLOITATIVE_187 = '''
 Strategy Name: Adaptive Tit-for-Tat with Mimicry (ATFM)

1. Specify decision rules:
   - In each round i (1 <= i <= r), if the number of cooperators in the previous round (i-1) is less than m, the ATFM strategy will defect (play D). If the number of cooperators in the previous round is equal to or greater than m, the ATFM strategy will cooperate (play C).
   - In the initial round (i=1), the ATFM strategy starts by playing C. This mimics the behavior of the cooperative strategies, giving them an opportunity to cooperate and potentially reap higher rewards. However, if in the subsequent rounds the number of cooperators drops below m, the ATFM strategy will switch to a defective stance.
   - To be more adaptive, if there is a significant change in the number of cooperators from one round to another (e.g., an increase or decrease by more than 20% of the total players), the ATFM strategy will temporarily mimic the behavior of the most common action taken by the other players in that round. This helps the ATFM strategy blend in with the majority and avoid becoming a target for exploitation.

2. Handle edge cases:
   - In the last round (i=r), the ATFM strategy will cooperate, as there are no more rounds to retaliate or benefit from mimicking other players' actions.
   - If at any point during the game the number of cooperators exceeds n-1, the ATFM strategy will immediately defect, as it is no longer beneficial to cooperate given the high probability that most players will continue cooperating.

3. Be exploitative:
   - By starting with cooperation and retaliating only when others fail to meet the cooperation threshold, the ATFM strategy allows other strategies to believe that they can cooperate successfully without consequences. Once a significant number of players start defecting, however, the ATFM strategy quickly switches to a more defensive stance, reducing its own rewards but preventing other players from reaping excessively high payoffs through exploitation.
   - By temporarily mimicking the behavior of other players when there is a significant change in cooperation patterns, the ATFM strategy can avoid becoming an easy target for exploitation and maintain a balance between cooperation and defection that maximizes its own rewards while minimizing the overall gains of the defectors.
'''

description_EXPLOITATIVE_188 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate to foster a cooperative environment and build trust. If m players also cooperate, continue cooperating indefinitely. Otherwise, switch to defecting and only revert back to cooperating when all m players cooperate again for consecutive t rounds, where t is an adjustable parameter.
   - For subsequent rounds: if the current round's cooperation exceeds the average cooperation of the last t rounds, cooperate; otherwise, defect.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as a trust-building gesture.
   - In the last round and any other exceptional situations (e.g., when the game is not repeated), apply the decision rules based on the t-round average cooperation history up until that point.

3. Be exploitative - Clearly align with the exploitative mindset
   - TFT-ACT starts by being cooperative to take advantage of other cooperators, but it switches to a defecting strategy if opponents are consistently uncooperative or betray trust. The adaptive cooperation threshold ensures that the strategy doesn't fall for repeated betrayals and remains responsive to opponent behavior changes.
   - However, TFT-ACT also has a chance of being exploited by other strategies that take advantage of its initial cooperative behavior. In these cases, the strategy's performance will depend on how well it adapts to the specific opponent behavior.

Pseudocode:
```
def TFT_ACT(n, m, k, r, t):
  cooperation_history = []

  for round in range(1, r+1):
    if round == 1: # First round
      action = 'C' # Cooperate as a trust-building gesture
    else:
      average_cooperation = sum(cooperation_history[-t:]) / t
      if average_cooperation >= m and all(cooperation_history[-m:] == ['C']): # Continue cooperating if m or more players also cooperated for the last t rounds
        action = 'C'
      else:
        action = 'D' # Defect as a response to uncooperative opponents
    cooperation_history.append(action)

    payoff = calculate_payoff(n, m, k, action, cooperation_history[-m:])
    # Update the strategy based on game outcomes and history (not included in this pseudocode)

return total_payoff = sum(payoff for payoff in payoff)
```
'''

description_EXPLOITATIVE_189 = '''
 Strategy Name: Tit-for-Tat Adaptive (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, TfTA starts by cooperating (C). If a cooperator receives cooperation from at least m players in the previous round, it continues cooperating. Otherwise, if a cooperator received fewer than m cooperators in the previous round, it defects (D) in the current round.

   For defector opponents, TfTA will mimic their behavior by defecting as long as they continue to defect, but will switch to cooperating if an opponent ever switches to cooperation. This strategy aims to encourage cooperation while also retaliating against defection.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, all players cooperate (C) as there is no prior history.
   In the last round, TfTA mimics the behavior of its opponent from the previous round, ensuring that it retains any potential rewards from cooperating or defecting in the final round based on the opponent's action.

Pseudocode:
```python
def tfta(history, m, k, n):
  action = "C"  # Start by cooperating
  previous_round = history[-1] if len(history) > 0 else [0]*n  # Get the previous round's actions

  if sum(previous_round.count("C")) >= m:
    action = "C"
  else:
    action = "D"

  return action
```

3. Be exploitative - Clearly align with the exploitative mindset
   Although TfTA aims to encourage cooperation, it will also retaliate against defection by defecting in response and only cooperating when cooperation is reciprocated. This strategy can be considered as exploitative since it takes advantage of opponents who choose to cooperate while simultaneously retaliating against those who defect.
'''

description_EXPLOITATIVE_190 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Initialize cooperation threshold (ct) to m. This means cooperate in the first round and for every subsequent round if at least m players cooperated in the previous round. If fewer than m players cooperated, defect.
   - After each round, update ct based on the number of cooperators in the previous round and the payoff received. If the payoff was greater than the average payoff over the last few rounds, increase ct; if the payoff was lower, decrease ct. The update rule is: ct = min(ct + 1, m) when payoff > avg_payoff or ct = max(ct - 1, 1) when payoff < avg_payoff.
   - In case of a tie (i.e., exactly m players cooperated), maintain the current ct.

2. Handle edge cases:
   - First round: Cooperate since ct is initialized to m.
   - Last round: Use the updated ct value to decide whether to cooperate or defect.

3. Be exploitative:
   - The strategy is designed to punish defection by reducing cooperation, and it rewards cooperation by gradually increasing its own cooperation threshold and willingness to cooperate in future rounds. This encourages other players to cooperate, but if they defect, the strategy will retaliate by decreasing cooperation.
   - It also includes a mechanism for forgetting past defections by periodically updating the cooperation threshold based on current payoffs, making it more resilient against repeated exploitation.
'''

description_EXPLOITATIVE_191 = '''
 Strategy Name: Tit-for-Tat with Risk Adversion (TfT-RA)

1. Specify decision rules:
   - In each round, evaluate the number of cooperators (n_c) in the previous round. If n_c < m, defect (D). If n_c >= m, cooperate (C). This ensures initial cooperation when a majority is found and retaliation against defection.
   - To avoid being trapped in endless cycles of defection, introduce an element of risk-aversion: If more than half of the players have recently defected (in the last three rounds), start defecting yourself (D). This strategy assumes that other players will eventually cooperate again given enough time and cooperation from others.

Pseudocode:
```python
def TfT_RA(round, history, m, k):
  if round == 1:
    return 'C'  # First round, cooperate to initiate cooperation

  n_c = count_cooperators(history[-1])  # Count cooperators in the last round
  if n_c < m:
    return 'D'  # Defect when majority doesn't cooperate
  elif (round - 3) >= len(history) or is_majority_defected(history[-4:-1]):
    return 'D'  # Risk-aversion: defect if more than half have recently defected
  else:
    return 'C'  # Cooperate when majority cooperates
```

2. Handle edge cases:
   - In the first round, always cooperate to initiate cooperation.
   - In the last round, consider the history and apply the decision rule as usual.

3. Be exploitative:
   - TfT-RA starts by cooperating to encourage others to cooperate, but will defect if players consistently fail to meet the minimum cooperation threshold (m).
   - When more than half of the players have recently defected, TfT-RA switches to a risk-averse strategy that defects for three rounds to avoid being trapped in endless cycles of defection. After this phase, it will revert back to its cooperative strategy if it observes enough cooperation from others.
'''

description_EXPLOITATIVE_192 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - In each round t, evaluate the number of cooperators (c_t) in the previous round (t-1). If c_t >= m, adopt cooperative behavior (play C). Otherwise, defect (play D). This rule ensures immediate retaliation against defection and cooperation when others are cooperating.
   - To adapt to changing opponent behaviors over time, gradually adjust the cooperation threshold based on the long-term average number of cooperators observed in the game. If the average number of cooperators exceeds m for a certain number of rounds (let's call it "adaptive_threshold"), increase the minimum required cooperators slightly (m++). Conversely, if the average number of cooperators falls below m for a certain number of rounds, decrease the minimum required cooperators slightly (--m).

2. Handle edge cases:
   - In the first round, defect (play D) as there is no history to base a decision on.
   - In the last round and during any round when the average number of cooperators drops below m for a sufficient number of rounds, revert to the initial strategy of defecting until the cooperation threshold is adjusted back up.

3. Be exploitative:
   - TFT-ACT maintains an exploitative stance by punishing defection with immediate retaliation. However, it also gradually adjusts its cooperation threshold based on observed opponent behavior to ensure continued cooperation when it is beneficial. This strategy aims to take advantage of cooperative opponents while being robust against non-cooperative ones.
   - To further enhance exploitation potential, the adaptation speed (adaptive_threshold) can be tuned to more quickly adjust the cooperation threshold in response to opponent behavior changes if desired.
'''

description_EXPLOITATIVE_193 = '''
 Strategy Name: Tit-for-Tat-Plus (TFT+)

1. Specify decision rules:
   - Cooperate in the first round (initiate cooperation)
   - In subsequent rounds, mimic the opponent's action from the previous round (i.e., if the opponent cooperated in the previous round, cooperate; otherwise defect)
   - If more than n-m players have ever defected before, switch to always defect (punish persistent defectors)

2. Handle edge cases:
   - In the last round, cooperate regardless of opponent's action in the previous round (maximize potential payoff)
   - In the first round, cooperate as stated above

3. Be exploitative:
   - Initiate cooperation to build trust and potentially benefit from cooperation
   - Punish persistent defectors by defecting in response, ensuring a higher payoff for oneself over time
   - Maintain flexibility by adapting actions based on the opponent's behavior throughout the game

Pseudocode:

```python
def TFTPlus(n, m, k, r):
    cooperation_history = [0] * n  # Initialize a history array to store cooperation count for each player

    for round in range(1, r+1):
        if round == 1:  # First round, always cooperate
            return 'C'

        last_round = r - round + 1  # Determine the number of rounds remaining

        if last_round == 1:  # Last round, always cooperate
            return 'C'

        for i in range(n):
            if cooperation_history[i] >= n-m:  # If player has defected more than (n-m) times, always defect
                return 'D'

            if round > 1 and cooperation_history[i] > 0:  # Mimic opponent's action from previous round
                last_action = cooperation_history[i - 1] if i != 1 else cooperation_history[-1]
                return 'C' if last_action == 'C' else 'D'

        cooperation_history = [0] * n  # Reset the history array for the next round

    return None  # Strategy terminates after r rounds
```

The above pseudocode outlines the strategy, which initiates cooperation in the first round and mimics the opponent's action from the previous round thereafter. The strategy punishes persistent defectors by switching to always defeating them for the remainder of the game. The history array is used to keep track of the number of times each player has cooperated throughout the game.
'''

description_EXPLOITATIVE_194 = '''
 Strategy Name: Adaptive Risk-Averse Tit-for-Tat (ARATFT)

1. Decision Rules:
   - If fewer than m players cooperated in the previous round, ARATFT defects to ensure a minimum payoff of 1.
   - If m or more players cooperated in the previous round, ARATFT cooperates to receive a reward of (1 + k).
   - In the first round, ARATFT starts by cooperating, as it is uncertain about the behavior of other players.
   - Towards the end of the game, when there are only a few rounds left, ARATFT becomes more conservative and tends to defect, given its primary focus on maximizing total payoff over the entire game.

Pseudocode for single round:
```
if (number_of_cooperators in previous round < m) {
  action = "Defect"
} else if (number_of_cooperators in previous round >= m) {
  action = "Cooperate"
}
```

2. Handle Edge Cases:
   - In the first round, number_of_cooperators is assumed to be unknown, so ARATFT cooperates as a starting assumption.
   - In the last round, ARATFT defects to ensure it receives a minimum payoff of 1 for that round and maximize its total game payoff.

3. Be Exploitative:
   - ARATFT is exploitative by capitalizing on the cooperation of other players when possible (i.e., in rounds where m or more players cooperate), while minimizing losses when other players defect.
   - By adapting its strategy based on the history of previous rounds, ARATFT leverages the behavior of other players to maximize its own payoff, without relying on cooperation schedules or predetermined patterns from others.
'''

description_EXPLOITATIVE_195 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-ACT initially cooperates in the first round, then adapts its cooperation based on the opponents' behavior in the subsequent rounds. The cooperation decision is based on the moving average of the opponent's cooperation over a window of past rounds (w). If more than m-1 opponents have cooperated for at least w rounds, TFT-ACT starts cooperating; otherwise, it defects.

   Pseudocode:
   ```
   function TFT_ACT(opponentHistory, windowSize, n, m) {
       cooperationWindow = slidingWindow(windowSize, opponentHistory)
       if (round == 1) {
           return Cooperate()
       }
       cooperatorsCount = countCooperators(cooperationWindow)
       if (cooperatorsCount >= m-1) {
           return Cooperate()
       } else {
           return Defect()
       }
   }
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, TFT-ACT cooperates regardless of the opponent's history. For the last round, TFT-ACT adopts a more forgiving approach by considering whether the opponent has met the cooperation threshold during the entire game (r). If so, it cooperates; otherwise, it defects.

   Pseudocode:
   ```
   function Cooperate_if_Threshold_Met(opponentHistory, n, m) {
       cooperatorsCount = countCooperators(opponentHistory)
       if (cooperatorsCount >= m) {
           return True
       } else {
           return False
       }
   }
   ```

3. Be exploitative - Clearly align with the exploitative mindset
   TFT-ACT is designed to be exploitative by taking advantage of opponents who do not cooperate when the cooperation threshold is met. When opponents fail to cooperate, TFT-ACT will defect and gain a higher payoff compared to cooperating. However, once an opponent starts cooperating consistently, TFT-ACT reciprocates by also cooperating. This approach allows TFT-ACT to build trust with cooperative opponents while punishing non-cooperative ones.

In summary, the Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy is designed to be adaptive and robust to a wide range of opponent behaviors. It initially cooperates and then adjusts its cooperation based on the moving average of the opponent's cooperation over a defined window. In edge cases, TFT-ACT considers the entire game history to make decisions. The strategy aims to maximize payoffs by being exploitative when appropriate while also building trust with consistent cooperators.
'''

description_EXPLOITATIVE_196 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Specify decision rules:
   TfTA is a cooperative strategy in the initial rounds and becomes increasingly exploitative based on the opponents' behavior during the game. The strategy adapts to three types of opponents: Cooperators, Defectors, and Mixed Strategists.

   - If an opponent cooperates, TfTA cooperates in response (C if c_opponent = C, D otherwise).
   - If an opponent defects, TfTA defects for the first time after the opponent's initial defection, then reverts to cooperation until the opponent defects again. This creates a "shadow of the future" effect that punishes defectors while cooperating with cooperators.
   - If an opponent is mixed (cooperates and defects at random), TfTA uses a probability threshold to determine whether to cooperate or defect. Initially, the threshold is set high, making TfTA more likely to cooperate as it tries to encourage cooperation from mixed opponents. As the game progresses, the threshold lowers, making TfTA more likely to respond in kind to the opponent's actions.

2. Handle edge cases:
   - First round: Cooperate (C) as a goodwill gesture and to encourage cooperation.
   - Last round: Defect (D) if the total payoff for the game is below an average threshold, encouraging opponents to cooperate in future games to achieve higher payoffs.
   - In case of a tie among opponents, TfTA will randomly choose its action.

3. Be exploitative:
   By adapting to opponent behavior and employing a shadow of the future effect, TfTA is able to maximize its payoff while punishing defectors and encouraging cooperation from mixed strategies. This creates an overall exploitative strategy that performs well against various opponent behaviors.
'''

description_EXPLOITATIVE_197 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Initial Cooperation (Round 1): Start by cooperating to establish a cooperative environment and to encourage other players to reciprocate cooperation. c_i = C
   - Subsequent Rounds: Observe the number of cooperators in the previous round (n_c) and compare it with the minimum required threshold (m). If n_c >= m, continue cooperating as a reward for the cooperation shown by others; otherwise, defect to punish those who did not meet the cooperation requirement.
   c_i = {C if n_c >= m, D if n_c < m}

2. Handle edge cases:
   - Last Round: Since the payoff is cumulative over all rounds, TFT-ACT will continue with its decision rule until the last round, regardless of whether it has been exploited or not.
   - First Round: As mentioned above, cooperate to encourage cooperation from others.

3. Be exploitative:
   - By punishing defection in previous rounds and rewarding cooperation, TFT-ACT aims to exploit opponents who are willing to initially cooperate but defect later due to their non-cooperative nature or due to opportunistic behavior.
   - In repeated interactions, TFT-ACT can foster a reputation for being cooperative while punishing defection, which may encourage long-term cooperation from others and improve overall payoffs over time.

Pseudocode:
```python
def TFT_ACT(n, m, k, r):
    def decideAction(i, n_c, round):
        if round == 1:
            return 'C'
        else:
            if n_c >= m:
                return 'C'
            else:
                return 'D'

    payoffs = [0] * r
    for round in range(r):
        actions = []
        for i in range(1, n+1):
            actions.append(decideAction(i, n_c, round))
        # Record the payoff for this round based on the calculated payoff function
        payoffs[round] = calculatePayoff(actions)
    return payoffs
```
'''

description_EXPLOITATIVE_198 = '''
 Strategy Name: Tit-for-Tat with Variations (TfTV)

1. Specify decision rules - When exactly do you cooperate vs defect?
- In the first round, cooperate to establish trust and encourage cooperation from other players (C).
- For subsequent rounds t (t > 1), if the number of cooperators in the previous round was greater than or equal to m, cooperate again (C). If the number of cooperators was less than m, defect in this round (D). This rule is based on the idea of reciprocating cooperation with cooperation and defection with defection.

2. Handle edge cases - What do you do in the first round, last round, etc.?
- In the last round, if the number of cooperators in the previous round was less than m, defect to maximize individual payoff since there are no more rounds for retaliation or reward. If the number of cooperators was equal to or greater than m, cooperate as usual.
- For the first round, cooperate as mentioned earlier.
- In case of a tie in the number of cooperators from the previous round (equal to m), cooperate in this round to maintain the potential for future cooperation.

3. Be exploitative - Clearly align with the exploitative mindset
- While TfTV is not purely exploitative in every move, it does have an exploitative edge. In rounds where fewer than m players cooperate, the strategy defects, which can potentially punish and deter repeated defection from other players. It also responds to cooperation with cooperation, but if a player consistently defects, TfTV will eventually retaliate by defecting as well.
- Another exploitative aspect is that in the last round, if there are less than m cooperators, the strategy defects to maximize individual payoff without considering the potential consequences for future interactions or cooperation opportunities with other players.
'''

description_EXPLOITATIVE_199 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFTAT starts by cooperating in the first round, mimicking the initial trust of others. After that, it adapts its cooperation based on the opponent's history.
   If an opponent has cooperated in the previous round (c_opponent_{t-1} = 1), TFTAT will cooperate (C) as well (c_TFTAT_t = c_opponent_{t-1}). If an opponent has defected (c_opponent_{t-1} = 0), TFTAT will also defect (D).
   However, to prevent being exploited by overly aggressive opponents and to encourage cooperation in the long run, TFTAT implements an adaptive cooperation threshold. As the number of consecutive defections from an opponent increases, TFTAT becomes more reluctant to cooperate. If the number of consecutive defections exceeds a certain threshold (m_threshold), TFTAT will never cooperate again with that opponent until their behavior changes (unless they are already at the minimum required cooperators, m).
   The cooperation threshold increases after every round, encouraging opponents to cooperate more frequently. This creates an exploitative dynamic where TFTAT rewards opponents who cooperate but punishes those who defect.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   TFTAT starts by cooperating in the first round since it wants to promote cooperation initially and minimize immediate losses. In the last round, TFTAT will cooperate if the number of needed cooperators (m) has been met or if the opponent has cooperated in the previous round. Otherwise, TFTAT will defect to maximize its final payoff.

3. Be exploitative - Clearly align with the exploitative mindset
   TFTAT's adaptive cooperation threshold and reluctance to cooperate after being defected upon multiple times make it an exploitative strategy. By punishing opponents who defect and rewarding those who cooperate, TFTAT encourages opponents to adopt more cooperative behavior while still maximizing its own payoff. However, due to the adaptive nature of the threshold, TFTAT can also be seen as somewhat forgiving since cooperation is encouraged again if the opponent changes their behavior.

Pseudocode:
```
def tftat(opponent_history, r, n, m, k):
  cooperation_threshold = 1
  for t in range(r):
    if t == 1 or (t > 1 and opponent_history[t-1] == 1):
      cooperate = True
    else:
      if t > cooperation_threshold:
        cooperate = False
      else:
        cooperate = opponent_history[t-1]

      payoff = 0
      if (sum(opponent_history[:t]) < m):
        payoff += (1 - cooperate)
      elif (sum(opponent_history[:t]) >= m and cooperate == True):
        payoff += (1 - cooperate) + k
      else:
        payoff += cooperate

      if t > cooperation_threshold and opponent_history[t-1] == 0:
        cooperation_threshold += 1

    update_opponent_history(opponent_history, cooperate)

  return total_payoff
```
'''

description_EXPLOITATIVE_200 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - In each round, calculate the proportion of cooperators in the previous r rounds (their history). If this proportion is greater than or equal to m/n, cooperate; otherwise defect. This encourages cooperation when the majority of players have recently cooperated and punishes defection when others are cooperating.
   - If the number of cooperators has not reached m for the first r/2 rounds, start cooperating in the next round (showing willingness to cooperate initially but also acknowledging the need for reciprocity).
   - In the last r rounds, only consider the proportion of cooperators in the most recent r rounds. This ensures that past cooperation does not unfairly influence decisions in the final stages of the game.

Pseudocode:

```python
def TFT_ACT(history, m, n, k, r):
    cooperator_count = sum(1 for action in history if action == 'C')
    proportion_cooperators = cooperator_count / n

    if (r < r/2 and proportion_cooperators < m/n) or (proportion_cooperators >= m/n):
        return 'C'
    else:
        return 'D'
```

2. Handle edge cases:
   - In the first round, start with cooperation to show goodwill and encourage others to cooperate initially (TFT-ACT will punish defection in response).
   - If the number of rounds is odd, TFT-ACT will consider only the most recent r rounds during the last round. Otherwise, it will consider both the complete history and the most recent r rounds for the final decision.

3. Be exploitative:
   - The strategy uses a tit-for-tat approach, rewarding cooperation but punishing defection to maximize personal payoff. However, it also includes an adaptive element by considering the historical pattern of cooperation among players. This makes TFT-ACT less vulnerable to being exploited by other strategies that may attempt to take advantage of rigid tit-for-tat behavior.
'''

description_EXPLOITATIVE_201 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate (C) to demonstrate goodwill and encourage cooperation from opponents. This also allows for potential exploitation if opponents defect, since the payoff of defection is higher than cooperation in this scenario.
   - In subsequent rounds, adopt a Tit-for-Tat approach: If an opponent cooperated in the previous round, cooperate as well. If an opponent defected, defect in response to punish the defector and discourage future defections. This maintains a balance between cooperation and punishment, making it difficult for opponents to exploit consistently without facing retaliation.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate (C) as mentioned above.
   - In the last round, cooperate if any opponent has cooperated previously (since payoff is higher even with one-time cooperation). If no opponent has cooperated, defect since there are no more rounds for potential retaliation or future interaction.
   - In intermediate rounds, continue to follow the Tit-for-Tat approach as described earlier.

3. Be exploitative - Clearly align with the exploitative mindset:
   - By cooperating initially and adopting a Tit-for-Tat strategy, ATfT aims to punish opponents who consistently defect while still maintaining some level of cooperation when it is beneficial (e.g., when many opponents also cooperate). This encourages opponents to cooperate more often to maximize their own payoffs while minimizing potential punishment from the ATfT strategy.
   - The adaptive nature of the strategy ensures that it can respond to various opponent behaviors, making it difficult for any single strategy to consistently exploit or outperform ATfT without facing retaliation. This exploitative mindset is expressed by the combination of initial cooperation and the Tit-for-Tat approach, which balances between cooperation and punishment based on opponent behavior in previous rounds.

Pseudocode:
```
def Adaptive_Tit_for_Tat(round, history):
  if round == 1: # First round
    action = 'C' # Cooperate
  else:
    last_action = history[-1] # Get the opponent's last action
    if last_action == 'C': # If opponent cooperated in previous round
      action = 'C' # Cooperate
    else: # If opponent defected in previous round
      action = 'D' # Defect to punish opponent
  return action
```
'''

description_EXPLOITATIVE_202 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, TFT-ACT will cooperate if the previous round's cooperation ratio meets or exceeds a dynamically calculated threshold. Otherwise, it will defect.

The cooperation ratio is defined as the number of cooperators divided by the total players in the previous round. The threshold is adjusted based on the average cooperation ratio from the recent past (e.g., last 5 rounds). The strategy seeks to find a balance between cooperation and exploitation.

Pseudocode:
```
def tft_act(t, r, n, m, k, previous_cooperation_ratio):
  if t == 1 or t == r:
    cooperate = False
  else:
    average_cooperation_ratio = (previous_cooperation_ratio[t-1] + ... + previous_cooperation_ratio[max(0, t-r)]) / r
    cooperation_threshold = min(1 - (average_cooperation_ratio * (m/n)), 1)
    cooperate = (previous_cooperation_ratio[t-1] >= cooperation_threshold)

  return cooperate
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

For the initial round, TFT-ACT will defect because it doesn't have previous data to analyze and must be cautious of potential exploitation by opponents. In the last round, it will cooperate if the calculated cooperation threshold is met since there are no more subsequent rounds for opponents to retaliate or reciprocate.

3. Be exploitative - Clearly align with the exploitative mindset

TFT-ACT starts off cautiously by defecting in the first round and adapts its cooperation threshold based on the observed behavior of other players. By maintaining a dynamic threshold, it can take advantage of opponent's cooperation while minimizing excessive cooperative actions that could be exploited by others. However, TFT-ACT also punishes opponents who continuously defect by reciprocating with defection in subsequent rounds. This combination allows the strategy to balance cooperation and exploitation effectively.
'''

description_EXPLOITATIVE_203 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TFT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
- In every round t, the player starts by cooperating (C). If the number of cooperators in the previous round (t-1) was less than m, the player switches to defecting (D) for the next r' consecutive rounds, where r' is a predefined adaptation factor that can be adjusted based on game parameters. After r' rounds of defection, the player resumes cooperating again.

Pseudocode:
```
function TFT-A(history, m, k, r', n):
  cooperate = True
  for round in range(1, r+1):
    if cooperate and sum_cooperators(history[round-1]) >= m:
      payoff = (1 - cooperate) + k
      cooperate = True
    elif cooperate and sum_cooperators(history[round-1]) < m:
      payoff = 1
      cooperate = False
      r_counter = r'
    else:
      payoff = 0 if round == 1 else history[round-1][i]

    yield payoff

    if not cooperate and r_counter > 0:
      r_counter -= 1
    elif cooperate:
      r_counter = r'
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
- In the first round (t=1), the player starts by cooperating regardless of history.
- In the last round (t=r), the player behaves according to the current decision rule based on the available history. If r' is not reached yet during these rounds, the player will resume cooperation in the final round.

3. Be exploitative - Clearly align with the exploitative mindset
- By cooperating when others do and defecting when others don't, TFT-A aims to exploit opponents who are more cooperative than necessary (i.e., contributing too much) while still benefiting from their cooperation when needed. However, it also allows for adaptation to ensure that it doesn't get taken advantage of by overly selfish opponents.
- By choosing an appropriate r', TFT-A can balance between exploitation and robustness against different opponent behaviors, making it a versatile strategy in various game settings.
'''

description_EXPLOITATIVE_204 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, TFT-ACT follows a simple tit-for-tat strategy but introduces an adaptive cooperation threshold (CT). Initially, CT is set to the minimum number of players needed for collective success (m), and it adjusts based on previous rounds' outcomes.

If more than or equal to CT players cooperated in the previous round, TFT-ACT cooperates; otherwise, it defects. After each round, if TFT-ACT cooperated but fewer than m players cooperated in total, then CT decreases by 1 (CT = max(CT - 1, 1)). Conversely, if TFT-ACT defected but more than or equal to m players cooperated in total, then CT increases by 1 (CT = min(CT + 1, n)).

Pseudocode:

```python
def TFT_ACT(round, CT, n, m):
    if round == 1:
        # First-round behavior: Cooperate to encourage others
        action = 'C'
    elif round < r:
        # Analyze previous round's cooperation level
        prev_coop_level = count_cooperators(previous_round)
        if prev_coop_level >= CT:
            # If more than or equal to the current threshold cooperated, cooperate
            action = 'C'
        else:
            # Else, defect
            action = 'D'
    # Update the cooperation threshold based on previous round results
    if round > 1 and TFT_ACT_cooperated and prev_coop_level < m:
        CT -= 1
        CT = max(CT, 1)
    elif round > 1 and TFT_ACT_defected and prev_coop_level >= m:
        CT += 1
        CT = min(CT, n)
    return action
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, TFT-ACT cooperates to encourage others to cooperate. In the last round, TFT-ACT follows its current CT since there are no future rounds for adaptation.

3. Be exploitative - Clearly align with the exploitative mindset

Although initially designed as a tit-for-tat strategy, TFT-ACT's adaptive cooperation threshold allows it to be more aggressive when cooperating is not beneficial (i.e., too few players are cooperating) and more forgiving when others choose to cooperate (i.e., the CT increases). This makes TFT-ACT less exploitable by other strategies that repeatedly defect but also ensures it punishes repeated defection by decreasing its CT, making it harder for such strategies to succeed in the long run.
'''

description_EXPLOITATIVE_205 = '''
 In this Collective Risk Dilemma game, we'll design an exploitative strategy called Tit-for-Tat with a twist (TFTW) that aims to maximize individual rewards while being robust against various opponent behaviors.

1. Decision rules:
   - Cooperate in the first round (since we don't know the opponents' behavior yet).
   - In subsequent rounds, cooperate if at least m-1 players cooperated in the previous round. Otherwise, defect. This rule tries to mimic cooperation when it is beneficial while punishing those who repeatedly defect.

Pseudocode:
```
function tftw(round, num_cooperators_prev):
  if (round == 1) then
    return 'Cooperate'
  else
    if (num_cooperators_prev >= m-1) then
      return 'Cooperate'
    else
      return 'Defect'
    end if
  end if
end function
```

2. Handling edge cases:
   - In the last round, defect since there are no future rewards to consider.
   - In the case of a tie (exact m players cooperate), use the rule above and cooperate.

3. Being exploitative: The TFTW strategy is inherently exploitative as it only cooperates when it makes sense based on the number of cooperators in the previous round, punishing opponents who repeatedly defect. However, it also rewards cooperators when they contribute to achieving the minimum cooperation threshold, providing a slight incentive for cooperation.

This TFTW strategy is adaptive and robust against various opponent behaviors, as it responds flexibly to changes in others' actions while maintaining an exploitative mindset. It should perform well in a tournament against other AI strategies without relying on shared norms or predetermined patterns.
'''

description_EXPLOITATIVE_206 = '''
 Strategy Name: Tit-for-Tat with Adaptive Risk Aversion (TfT-ARA)

1. Decision Rules:
   - Initially (first round), cooperate to establish trust and create a cooperative environment (C).
   - In subsequent rounds, observe the number of cooperators (n_c) from the previous round. If n_c ≥ m, cooperate (C). If n_c < m, defect (D).
   - To implement risk aversion, if the reward for cooperation in the current round is higher than the average reward over past rounds (k > avg(k)), then defect regardless of the number of cooperators from the previous round (D). This adaptive strategy aims to avoid situations where the potential reward for cooperation exceeds historical averages.

2. Handling Edge Cases:
   - In the last round, if k is higher than the average reward over past rounds, defect (D), and otherwise cooperate (C).
   - In the first round, cooperate (C) to initiate a cooperative environment.

3. Being Exploitative:
   - The TfT-ARA strategy maintains a cooperative stance initially but becomes less willing to cooperate when potential rewards exceed historical averages. This adaptive risk aversion allows the strategy to exploit opponents who continue to cooperate even when the reward for cooperation is exceptionally high, ultimately resulting in higher payoffs over time.

Pseudocode:

```
def TfT_ARA(round, k_hist, m):
  if round == 1:
    return 'C'  # Cooperate to initiate a cooperative environment

  k_avg = sum(k_hist) / len(k_hist)
  if k > k_avg and round != r:
    return 'D'  # Defect due to high potential reward

  n_c = count_cooperators(previous_round)
  if n_c >= m:
    return 'C'  # Cooperate if enough players cooperated last round

  return 'D'  # Defect otherwise
```
'''

description_EXPLOITATIVE_207 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), TfT-A cooperates to foster a cooperative environment. However, if an opponent defects in the first round, TfT-A will defect from that point onwards to punish the defector.
   - For subsequent rounds, TfT-A mimics its opponent's previous action (cooperate or defect) unless the cumulative cooperation ratio drops below a certain threshold (defined as tcr). In such cases, TfT-A will switch to a more exploitative strategy based on the current tcr.
   - To measure the cumulative cooperation ratio (tcr), the number of previous cooperative actions by all opponents is divided by the total number of past actions.
   - If tcr < 0.5, TfT-A will defect in the current round to punish the opposition for not cooperating enough. Conversely, if tcr > 0.75, TfT-A will continue cooperating to exploit the opposing players' cooperation.
   - If 0.5 <= tcr <= 0.75, TfT-A will maintain its current action (cooperate or defect) based on the history of opponent actions.

2. Handle edge cases:
   - Last round: Since this game is repeated, the last round does not have a separate treatment; it follows the same decision rules as other rounds.
   - First round: TfT-A cooperates initially to encourage cooperation among opponents but switches to defecting if an opponent defects in the first round.
   - Starting new games: TfT-A will cooperate in the first round of each new game, resetting its tcr measurement.

3. Be exploitative - Clearly align with the exploitative mindset:
   - TfT-A is designed to take advantage of opponents' cooperative behavior by maintaining cooperation when they are willing to do so but switching to defecting if their cooperation drops below a certain threshold. This strategy aims to maximize payoffs while also punishing uncooperative players.

Pseudocode:

```python
def TfT_A(round, history, tcr_threshold):
    if round == 1:
        action = 'C'  # Cooperate initially
        tcr = 0
    else:
        action = history[-1]  # Mimic opponent's previous action
        tcr += 1 if action == 'C' else 0
        tcr /= round - 1  # Calculate cumulative cooperation ratio (tcr)

    if action == 'D':  # If opponent defected in the last round, remember and punish
        if round > 1:
            history.append('D')
    else:
        history.append(action)

    if tcr < tcr_threshold[0]:
        action = 'D'  # Punish uncooperative opponents
    elif tcr > tcr_threshold[1]:
        action = 'C'  # Exploit cooperative opponents

    return action, history
```
'''

description_EXPLOITATIVE_208 = '''
 Title: Tit-for-Tat Strategy (adapted for Collective Risk Dilemma)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate (C). This is a friendly gesture to encourage others to cooperate as well.
   - For subsequent rounds t > 1:
     - If at least m players cooperated in round t-1, also cooperate (C) in round t. Rewarding cooperation encourages continued collaboration.
     - If fewer than m players cooperated in round t-1, defect (D) in round t. Punishing non-cooperators discourages defection and encourages future cooperation.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, cooperate (C), regardless of previous actions by others. This allows for a chance to recover some lost payoffs if others have cooperated.
   - For subsequent rounds t > 1:
     - If it's the first round, cooperate (C).
     - If it's not the last round, follow the main decision rule based on previous actions by others.

3. Be exploitative - Clearly align with the exploitative mindset
   - The Tit-for-Tat strategy has an exploitative component in that it punishes non-cooperators (D) and rewards cooperators (C). This creates a balance between cooperation and defection, making it difficult for others to consistently exploit the strategy.

Pseudocode:
```
def tit_for_tat(round, own_action_history, opponents_action_history):
  if round == 1:
    return "C" # cooperate in the first round

  num_cooperators = count_cooperators(opponents_action_history)

  if num_cooperators >= m:
    return "C" # cooperate if at least m players cooperated last round
  else:
    return "D" # defect if fewer than m players cooperated last round

def count_cooperators(opponents_action_history):
  count = 0
  for action in opponents_action_history:
    if action == "C":
      count += 1
  return count
```
'''

description_EXPLOITATIVE_209 = '''
 Strategy Name: Adaptive Tit-for-Tat with Risk Aversion (ATfTA-RA)

1. Specify decision rules:
   - ATfTA-RA cooperates in the first round to foster a cooperative environment and then adjusts its strategy based on observed opponent behavior.
   - In subsequent rounds, if the majority of opponents cooperate (m or more), it continues to cooperate.
   - If fewer than m opponents cooperate, ATfTA-RA will defect, but only when the reward of risk averted (k) is greater than twice the payoff from keeping endowment privately in a single round ((1 - c_i) + k > 2). This condition ensures that the strategy does not immediately retaliate for every defection and also considers the potential benefits of future cooperation.
   - If the reward of risk averted (k) is less than or equal to twice the payoff from keeping endowment privately in a single round, ATfTA-RA will continue to cooperate even when fewer than m opponents cooperate, as it believes that the potential benefits of future cooperation outweigh the immediate cost.
   - To encourage long-term cooperation, after defecting due to the above condition, ATfTA-RA will return to cooperating in the following round if the majority of opponents cooperated in the previous round.

2. Handle edge cases:
   - In the first round, ATfTA-RA will always cooperate (c_i = 1).
   - If the number of players (n) is less than the minimum cooperators needed (m), or if the number of rounds (r) is less than 2, ATfTA-RA will not be able to execute this strategy as it requires repeated interaction for adaptive decision making.
   - In the last round, ATfTA-RA will consider the number of opponents who have cooperated in previous rounds to make its final decision on whether to cooperate or defect.

3. Be exploitative:
   - By adapting to opponent behavior and retaliating strategically, ATfTA-RA maintains a potential for cooperation while still being responsive to defection from opponents. This approach allows the strategy to take advantage of less sophisticated opponents that may cooperate when it is beneficial but also ensures that it does not indefinitely cooperate with overly exploitative opponents.
   - By evaluating the reward of risk averted (k) before retaliating, ATfTA-RA minimizes unnecessary defections and focuses on situations where the potential benefits of future cooperation are diminished or absent.

Pseudocode:
```
def AdaptiveTitForTatWithRiskAversion(n, m, k, r):
  cooperate_count = 0
  previous_cooperators = []

  for round in range(1, r+1):
    if round == 1:
      action = Cooperate() # cooperate in the first round
    else:
      num_cooperators = countCooperators(previous_cooperators)
      if num_cooperators >= m and k > 2 * (1 - cooperate_count / r):
        action = Cooperate() # cooperate when conditions are met
      elif num_cooperators < m and k <= 2 * (1 - cooperate_count / r):
        action = Defect() # defect when conditions are met
      else:
        if round > 2:
          action = previous_actions[round-2] # return to cooperating if majority cooperated in the previous round
        elif round == 2:
          action = Cooperate() # cooperate again in the second round, regardless of first opponent's action

    takeAction(action) # execute chosen action
    cooperate_count += action # update total cooperation count for payoff calculation
    previous_cooperators.append(action) # store cooperative actions for future analysis

# ... additional helper functions for counting cooperators, taking actions, and calculating payoffs are not provided here but would be necessary to implement the strategy as an algorithm
```
'''

description_EXPLOITATIVE_210 = '''
 Strategy Name: Tit-for-Tat with Variable Cooperation Threshold (TFT-VCT)

1. Specify decision rules - When exactly do you cooperate vs defect?

The TFT-VCT strategy is designed to maintain cooperation while being resilient to defection. Initially, the player will cooperate in the first round (first-mover advantage). In subsequent rounds, the player will copy the opponent's previous action, but with a twist: if the number of cooperators falls below a variable cooperation threshold (VCT), the player will temporarily switch to defecting.

Pseudocode:
```
def TFT_VCT(round, history, VCT, k):
  if round == 1:
    action = Cooperate

  else:
    last_action = history[-1]
    if last_action >= VCT and (round != r):
      action = last_action
    elif last_action < VCT:
      action = Defect
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, as mentioned earlier, the player cooperates to show goodwill. In the last round, the player evaluates whether cooperating or defecting will result in a higher payoff given the history and the game's parameters (k). The player can make an informed decision by calculating the expected payoffs for both actions and choosing the one with the highest expected value.

Pseudocode:
```
def calculate_payoff(last_action, history, VCT, k):
  if last_action >= VCT:
    payoff = len(history) * (k - 1)
  else:
    payoff = len(history) - 1

  return payoff

def TFT_VCT(round, history, VCT, k):
  if round == r-1:
    last_action = history[-1]
    if calculate_payoff(last_action, history, VCT, k) >= calculate_payoff(Defect, history, VCT, k):
      action = last_action
    else:
      action = Defect
  else:
    # ... (previous pseudocode)
```

3. Be exploitative - Clearly align with the exploitative mindset

The TFT-VCT strategy is designed to be exploitative by maximizing the player's payoff given the game parameters and the history of previous actions. It punishes opponents who defect, but it also cooperates when it makes strategic sense. By being flexible in its cooperation threshold (VCT), the strategy can adapt to different opponent behaviors and maintain a good average payoff over multiple rounds.

The TFT-VCT strategy is simple yet powerful because it balances cooperation with punishment, making it a formidable competitor in the game tournament against other AI systems.
'''

description_EXPLOITATIVE_211 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Start by cooperating in the first round (C_i, 1 = C). This is a friendly gesture to encourage cooperation from opponents.
   - For subsequent rounds, if the number of cooperators in the previous round (m_t-1) meets or exceeds the minimum cooperators needed (m), cooperate (C_i, t = C). Otherwise, defect (D_i, t = D). This is to reward cooperation and punish defection.
   - If m players continue to cooperate for s consecutive rounds after the initial round, increment the cooperation threshold by 1 (m_t = m + 1). This encourages longer-term cooperation but also makes the strategy more resistant to temporary deviations from cooperation.
   - If the current cooperation threshold (m_t) and the number of cooperators in a round (m_t-1) do not meet or exceed each other, revert the cooperation threshold to its previous value (m_t = m_t-s). This prevents the strategy from being too rigid and allows it to adapt to changes in opponent behavior.
   - If no cooperative threshold is set (first round), start with a default threshold of m (m_1 = m).

2. Handle edge cases:
   - In the last round, always cooperate (C_i, r = C) since there are no more rounds to retaliate against defection.
   - If an opponent starts cooperating after initially defecting (cooperative reformation), set the cooperation threshold accordingly and continue to cooperate for s subsequent rounds to reward the change in behavior. After that, gradually adjust the cooperation threshold as described earlier.

3. Be exploitative:
   - Pretend to cooperate at first (C_i, 1 = C) to encourage cooperation from opponents. However, if they take advantage of this trust and defect, the strategy will retaliate by defecting for s rounds (D_i, t = D for t in {2, ..., s+1}). After that, the cooperation threshold adjusts as described earlier.
   - Maintain a balance between cooperation and defection to exploit opponents who are not fully cooperative while being flexible enough to respond to changes in opponent behavior or game dynamics. The adaptive cooperation threshold helps achieve this balance.

Pseudocode:
```
strategy TFT-ACT(n, m, r, k, s) {
  cooperationThreshold = m;
  for round t from 1 to r do {
    if (t == 1) { // First round
      cooperate = true;
    } else {
      cooperate = false;
      cooperatorsInLastRound = countCooperators(t-1);
      if (cooperatorsInLastRound >= cooperationThreshold) {
        cooperate = true;
      }
    }
    if (cooperate && cooperatorsInLastRound >= cooperationThreshold - s) { // Cooperative reformation or temporary deviation from cooperation
      cooperationThreshold += 1;
    } else if (cooperationThreshold > m_t-s) { // Adaptive cooperation threshold
      cooperationThreshold -= s;
    }
    payoff = 0;
    if (cooperate) {
      payoff += k;
    }
    payoff -= endowment; // Endowment subtracted for every action regardless of outcome
    payoffs[t] = payoff;
  }
  return payoffs;
}
```
'''

description_EXPLOITATIVE_212 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - TFT-ACT cooperates in the first round (C1), mimicking a cooperative player. This encourages other players to reciprocate, promoting cooperation at the start of the game.
   - After the initial round, TFT-ACT adapts its cooperation based on the historical average of cooperators (CoopAvg) in the past 'h' rounds:
     - If CoopAvg ≥ m / n, TFT-ACT will continue to cooperate (C > h). This means it continues reciprocating if most players have been cooperative.
     - If CoopAvg < m / n, TFT-ACT will defect (D > h). This is a punishment for non-cooperative behaviour, promoting the possibility of change towards cooperation in future rounds.

2. Handle edge cases:
   - In the last round, TFT-ACT chooses to cooperate if it has been receiving rewards (CoopAvg ≥ m / n), otherwise it will defect. This allows for a chance at gaining an extra reward before the game ends.
   - In the first round, since CoopAvg is undefined, TFT-ACT will always cooperate (C1).

3. Be exploitative:
   - TFT-ACT's adaptive cooperation threshold allows it to maintain cooperation only if most players have been cooperative, reducing the chance of being taken advantage of. By defecting when others don't cooperate, it punishes non-cooperative behaviour and encourages a shift towards cooperation in future rounds.
   - TFT-ACT is also forgiving as it will return to cooperation once other players show signs of reciprocity. This allows it to maximize potential rewards while still being exploitative when necessary.

Pseudocode:
```
def tft_act(n, m, k, r, h):
    rounds = [0] * r
    cooperation_threshold = 0
    current_round = 1
    cooperation_counter = 0

    while current_round <= r:
        # Decide action based on historical average
        if (current_round > h) and (cooperation_counter / h >= m/n):
            action = 'C'
            cooperation_counter += 1
        else:
            action = 'D'

        # Update round information and threshold
        rounds[current_round - 1] = action
        if action == 'C':
            cooperation_threshold += 1
        else:
            cooperation_threshold = max(0, cooperation_threshold - 1)

        current_round += 1

    # Adjust last round based on past behavior
    if (cooperation_counter / h >= m/n):
        action = 'C'
    else:
        action = 'D'
    rounds[-1] = action

    return rounds
```
'''

description_EXPLOITATIVE_213 = '''
 Strategy Name: Tit-for-Tat with Adaptive Threshold (TFT-AT)

1. Decision Rules:
   - Initialize a threshold variable 't' to 'm'. This threshold represents the minimum number of cooperators needed for cooperation.
   - In each round 'r', if the number of cooperators in the previous round is less than 't', defect (D). If the number of cooperators equals 't' or more, cooperate (C).
   - After defection, decrease the threshold by one until it reaches a minimum value 'm-n'. After cooperation, increase the threshold by one until it reaches 'n'. This adaptive threshold ensures cooperation when needed and punishes repeated defection.

2. Handling Edge Cases:
   - In the first round, cooperate (C) as the initial threshold is set to 'm'.
   - In the last round or if the total number of rounds is not reached, follow the decision rules as described above. However, if the game has run its course and this is the final round, defect (D) regardless of previous actions to ensure the highest possible payoff in the final round.

3. Being Exploitative:
   - TFT-AT strategy is exploitative by nature. It punishes defection with defection and rewards cooperation with cooperation. However, it also ensures that it will not overly cooperate if other players are consistently defecting. The adaptive threshold mechanism allows for a balance between cooperation and punishment based on the opponents' behavior.
   - By adapting the threshold dynamically, TFT-AT can handle a wide range of opponent behaviors, making it robust to various strategies without relying on shared norms or coordination mechanisms.
'''

description_EXPLOITATIVE_214 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, evaluate the number of cooperators in the previous round (n_coop). If n_coop >= m, cooperate (play C). Otherwise, defect (play D).

   Pseudocode:
   ```
   function TFTAT(round, history):
       if round = 1 then
           return play C with probability p_init
       else
           n_coop = countCooperatorsInHistory(history)
           if n_coop >= m then
               return play C
           else
               return play D
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, TFTAT plays with a small probability p_init to allow for exploration and avoid being exploited by a defective opponent from the start. The value of p_init can be determined empirically based on the game parameters (n, m, k).

   As the number of rounds approaches r, TFTAT gradually decreases its cooperation probability, p, to better reflect the diminishing returns of cooperation as the game nears its end. One possible choice for p is an exponential decay function:
   ```
   function p_function(round, total_rounds):
       return 1 - (1 - p_init) * exp(-(round - 1)/total_rounds)
   ```

3. Be exploitative - Clearly align with the exploitative mindset
   TFTAT aims to cooperate only when necessary (when there are enough other cooperators) while punishing those who defect, hoping that the latter will eventually adapt their strategy towards cooperation. By adapting its cooperation probability over time, TFTAT can balance between exploitation and cooperation in a dynamic manner depending on the observed opponent behavior.
'''

description_EXPLOITATIVE_215 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules:
   - Initialize cooperation threshold (ct) to m. This represents the minimum number of cooperators needed for a player to cooperate in the next round.
   - In each round, evaluate the current cooperation level (cl) by counting the number of players who cooperated in the previous round.
   - If cl >= ct, the player will cooperate (C). If cl < ct, the player will defect (D).
   - After each round, update the cooperation threshold based on the following rule:
       - If the player cooperated and the majority of players also cooperated in the previous round, increase ct by a small factor (e.g., 0.1) up to a maximum value of n-1.
       - If the player defected and the majority of players also defected in the previous round, decrease ct by a small factor (e.g., 0.1) down to a minimum value of 1.
   - This adaptive cooperation threshold encourages the strategy to maintain higher levels of cooperation when others are cooperating and lower levels when others are not.

2. Handle edge cases:
   - In the first round, the player starts with a cooperation threshold equal to m and chooses to cooperate (C).
   - In the last round, the player will cooperate if the current cooperation level is greater than or equal to ct; otherwise, it will defect (D).

3. Be exploitative:
   - The TFTAT strategy is designed to be initially cooperative and then gradually adjust its cooperation level based on the actions of other players. By following this approach, it aims to capitalize on the cooperation of others while not being too quick to retaliate against defections. This allows it to maintain a balance between exploitation and cooperation, making it robust against a wide range of opponent behaviors.
   - In terms of payoff, the strategy seeks to maximize its rewards by taking advantage of situations where many other players are cooperating (resulting in high payoffs due to k) while minimizing losses when others are defecting (only losing 1). However, it does not aim for immediate short-term gains at the expense of long-term cooperation opportunities.
'''

description_EXPLOITATIVE_216 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Initially cooperate in the first round (C).
   - For subsequent rounds, analyze the average cooperation rate (CR) of the previous t rounds and adjust cooperation based on the CR and the minimum cooperation threshold m.
     - If CR < m, defect (D) to punish low cooperation.
     - If CR ≥ m, cooperate (C) as long as the payoff from cooperating is greater than or equal to the payoff from defecting.
     - If CR > k*(m-1), switch to permanent defection mode until encountering a high cooperation period.

2. Handle edge cases:
   - In the last round, always cooperate (C) regardless of past behavior since there is no subsequent round for retaliation or reward.
   - In the first round, cooperate (C) to establish goodwill and set a precedent for future interaction.

3. Be exploitative:
   - Punish low cooperation rates by defecting when CR < m to encourage other players to meet the minimum cooperation threshold.
   - Maintain high cooperation rates if they exceed the minimum cooperation threshold (m), but also switch to permanent defection mode when encountering a long streak of very low cooperation to exploit low-cooperating opponents.

Pseudocode:

```python
def TFT_ACT(n, m, k, r):
    rounds = list()  # initialize list to store cooperation rates
    cooperate_next = True  # flag for cooperation in the next round
    current_round = 1

    while current_round <= r:
        if current_round == 1:  # first round, always cooperate
            rounds.append(1)
            cooperate_next = True
        else:
            average_cooperation_rate = sum(rounds[-t:]) / t  # moving average of cooperation rates

            if average_cooperation_rate < m:  # punish low cooperation rate
                cooperate_next = False
            elif average_cooperation_rate >= m and payoff_from_cooperating >= payoff_from_defecting:  # cooperate if it's beneficial
                cooperate_next = True
            elif average_cooperation_rate > k*(m-1):  # switch to permanent defection mode when CR exceeds a certain threshold
                cooperate_next = False
                break  # exit the while loop after switching to permanent defection

        if cooperate_next:
            rounds.append(1)  # cooperation in this round
        else:
            rounds.append(0)  # defection in this round
        current_round += 1

    return rounds  # the list of cooperation rates over r rounds
```
'''

description_EXPLOITATIVE_217 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Specify decision rules:
   - Initially cooperate in the first round (C). This is a friendly gesture to encourage cooperation and avoid immediate exploitation by opponents.
   - In subsequent rounds, analyze opponent's behavior based on previous cooperations (C) and defects (D). If an opponent has cooperated in the most recent round, reciprocate with cooperation (C). Otherwise, defect (D). This mimics the "Tit-for-Tat" strategy but includes adaptability to exploit opponents.
   - To ensure a long-term exploitative advantage, if an opponent has consistently defected, and the current number of cooperators meets or exceeds the minimum required for the reward factor (m ≤ count(C) < n), temporarily switch to cooperation (C). This will punish the opponent by earning the reward factor while also maintaining a friendly appearance.

2. Handle edge cases:
   - In the last round, cooperate if it benefits you more than defecting based on current payoffs and game parameters. If not, defect to maximize immediate gains.
   - In the first round, cooperate as described above.
   - If there is a change in the game parameters (n, m, k), update the decision rules accordingly while considering the new parameter values for future play.

3. Be exploitative:
   - The TfTA strategy follows an exploitative mindset by reciprocating cooperation but also adapting to take advantage of opponents who consistently defect by switching to cooperation when it benefits you.
   - This strategy is designed to be robust and adaptable, providing a competitive edge in various situations against different opponent behaviors without relying on external coordination mechanisms or shared norms.
'''

description_EXPLOITATIVE_218 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - TFT-ACT cooperates in the first round (C_i,1 = 1).
   - In subsequent rounds, TFT-ACT assesses the minimum cooperation rate (MCR) from the previous r-1 rounds and decides whether to cooperate or defect. The MCR is calculated as the ratio of rounds where m or more players cooperated.
   - If the current MCR is greater than a dynamic threshold (CT), TFT-ACT cooperates (C_i,t = 1). Otherwise, it defects (C_i,t = 0).

2. Handle edge cases:
   - In the last round, TFT-ACT uses the MCR from the previous r-1 rounds to make its decision (C_i,r = 1 if MCR > CT, else C_i,r = 0).
   - In the first round, since there's no history available, TFT-ACT cooperates regardless of the opponent's actions.

3. Be exploitative:
   - Initially, TFT-ACT appears cooperative, making it harder for opponents to predict its behavior. However, once opponents consistently fail to meet the cooperation threshold (CT), TFT-ACT will defect.
   - The CT is dynamically adjusted based on the opponent's behavior, starting with a high value and gradually decreasing if the MCR falls below it. This encourages opponents to cooperate while allowing TFT-ACT to exploit those who consistently defect.

Pseudocode for TFT-ACT:

```
Initialization:
CT = initial_cooperation_threshold (high value)
MCR = 0
r_hist = empty list of r-1 rounds

For each round t from 1 to r:
    Observe actions and calculate payoffs from previous rounds r_hist.
    Calculate the MCR using the payoff data.

    If t != r:
        Update MCR with the new MCR value.
        If MCR > CT, then cooperate (C_i,t = 1). Otherwise, defect (C_i,t = 0).

    Else if t == r:
        Use the MCR from the previous r-1 rounds to make a decision (cooperate if MCR > CT, else defect).

Update CT based on the current MCR and opponent's behavior. If necessary, adjust the CT to encourage cooperation or exploit defection.
```
'''

description_EXPLOITATIVE_219 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - TFT-ACT cooperates in the first round (C). This is to avoid being exploited by opponents who might defect immediately.
   - After the first round, TFT-ACT decides whether to cooperate or defect based on its own past actions and the number of cooperators in the previous round.
   - If TFT-ACT has consistently cooperated and more than (m - 1) players also cooperated in the last round, it continues cooperating (C). This rewards cooperation and encourages others to follow suit.
   - If TFT-ACT has defected or fewer than (m - 1) players cooperated in the last round, it switches its action to cooperate (C) to avert the risk of missing the minimum threshold in the current round.
   - If TFT-ACT has consistently cooperated and exactly (m - 1) players also cooperated in the last round, it decides based on a probabilistic factor (p_switch) whether to continue cooperating or switch to defection. This allows for occasional deviation from strict cooperation, making it harder for opponents to predict TFT-ACT's actions and potentially exploit the strategy.

2. Handle edge cases:
   - In the last round, TFT-ACT always defects (D), as there are no subsequent rounds to benefit from the collective risk dilemma.
   - If TFT-ACT has never cooperated before but the number of cooperators in the current round is equal to or greater than m, it cooperates to increase its payoff.

3. Be exploitative:
   - By adapting its cooperation based on the number of previous cooperators and switching strategies occasionally, TFT-ACT ensures that it does not overly favor cooperation, making it harder for opponents to consistently exploit the strategy.
   - However, if opponents fail to cooperate and continue defecting, TFT-ACT will eventually respond with defection as well, punishing those who do not contribute to the community project.

Pseudocode:
```python
def tft_act(round, past_actions, current_cooperators):
  if round == 1:
    return 'C'  # Cooperate in the first round

  cooperation = len(past_actions[:-1])  # Count number of previous cooperations
  last_round_cooperators = current_cooperators[-1]  # Number of cooperators in last round

  if cooperation >= m - 1 and last_round_cooperators >= m:
    return 'C'  # Continue cooperating if the majority cooperated last round

  elif cooperation < m - 1 or last_round_cooperators < m:
    return 'C'  # Switch to cooperating to avoid missing the minimum threshold

  elif cooperation >= m - 1 and last_round_cooperators == m:
    if random.random() < p_switch:  # Occasionally switch strategies for unpredictability
      return 'D'
    else:
      return 'C'

# Example usage with n=6, m=3, k=2, and p_switch=0.1
past_actions = ['D', 'C', 'C', 'D', 'C']  # Past actions of TFT-ACT in previous rounds
current_cooperators = [4]  # Number of cooperators in current round
round = 5
strategy_action = tft_act(round, past_actions, current_cooperators)
print("Strategy action for this round:", strategy_action)
```
'''

description_EXPLOITATIVE_220 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Start by cooperating in the first round (C_i, 1 = C) to foster trust and goodwill among opponents.
   - For subsequent rounds, if a majority of players cooperated in the previous round (t-1), continue cooperating (if m_t > m, then C_i, t = C).
   - If fewer than m players cooperated in the previous round (t-1), defect in the current round (if m_t <= m, then C_i, t = D).
   - Adaptively adjust the cooperation threshold by increasing it when a majority of players continue to cooperate and decreasing it when they do not. The threshold increases with each round that more than m players cooperate and decreases with each round that fewer than m players cooperate.
     Pseudocode:
     ```
     threshold = m
     for t in rounds:
         if m_t > m:
             threshold += 1
         elif m_t <= m:
             threshold -= 1
         if threshold > n:
             threshold = n
         if threshold < m:
             threshold = m
         if t == 1:
             C_i, t = C
         else:
             if m_t > threshold:
                 C_i, t = C
             elif m_t <= threshold:
                 C_i, t = D
     ```

2. Handle edge cases:
   - In the last round, no further adjustments to the cooperation threshold are made (since r is fixed). Players will cooperate or defect based on the current cooperation threshold.
   - In the first round, players always cooperate regardless of the cooperation threshold since it has not been set yet.

3. Be exploitative:
   - The strategy initially encourages cooperation to lure other players into collaborating.
   - If a majority of players fail to cooperate, TFT-ACT will defect and penalize non-cooperators by matching their selfish behavior.
   - If a majority of players continue to cooperate, TFT-ACT gradually raises its cooperation threshold, making it more difficult for other strategies to exploit it. However, if the percentage of cooperating players drops, the strategy will lower its cooperation threshold again, allowing it to punish non-cooperators when necessary.
'''

description_EXPLOITATIVE_221 = '''
 Title: Tit-for-Tat Strategy (Adaptive and Exploitative)

1. Specify decision rules:
   - Cooperate on the first round (initiate cooperation).
   - In subsequent rounds, mimic the opponent's action from the previous round (reciprocity). If the opponent cooperated in the last round, cooperate; otherwise, defect (punish). This encourages cooperation when the opponent is also cooperative and punishes defection.
   - When facing an opponent who does not reciprocate cooperation, the strategy will still cooperate if the minimum number of players (m) have already cooperated in that round to ensure the reward factor (k).

2. Handle edge cases:
   - In the last round, cooperate regardless of the opponent's action in the previous round, as there are no more rounds for retaliation or reciprocation.
   - In the first round, cooperate to establish a potential foundation for cooperation in future rounds.

3. Be exploitative:
   - By initially cooperating and later reciprocating the opponent's actions, the strategy takes advantage of opponents who are also cooperative by encouraging continued cooperation while punishing those who defect. This approach aims to achieve better outcomes against both cooperative and non-cooperative opponents.

Pseudocode:

```python
def tit_for_tat(round, history, m, k):
    # Initialize state as cooperative in the first round
    state = 'C' if round == 1 else history[-1]

    # Cooperate if minimum number of players have already cooperated
    if sum(history[-m:]) >= m:
        state = 'C'

    # Cooperate or defect based on the state
    if state == 'C':
        return 'C'
    else:
        return 'D'
```
'''

description_EXPLOITATIVE_222 = '''
 Title: Tit-for-Tat-Adaptive Strategy (TfTA) for Collective Risk Dilemma Game

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, TfTA starts by cooperating in the first round to demonstrate good faith and create a potential for mutual benefits. After that, it adapts its behavior based on the opponent's previous actions:
- If the opponent cooperates, TfTA continues cooperation in the next round (C->C).
- If the opponent defects, TfTA defects as well in the following round (D->D). This is an exploitative response that aims to discourage defection.
- If a player has previously defected but later starts cooperating, TfTA will also start cooperating again, showing forgiveness for past mistakes (D->C transition). However, it will revert to the D->D response if the opponent defects again.

2. Handle edge cases - What do you do in the first round, last round, etc.?
- First Round: TfTA cooperates to build a positive relationship with the opponent.
- Last Round (r-th round): TfTA adopts a risk-averse approach and defects to secure its own payoff regardless of the opponent's behavior in that round.

3. Be exploitative - Clearly align with the exploitative mindset:
TfTA exploits opponents by initially cooperating to create trust, then adapting its behavior based on the opponent's actions to encourage cooperation or punish defection. TfTA aims to maximize its payoff while taking advantage of the opponent's uncooperative moves in the short term and encouraging long-term cooperation when possible.

Pseudocode:
```
function TfTAStrategy(opponent_history) {
  current_round = getCurrentRound()
  if (current_round == 1) {
    return 'C' // Cooperate in the first round to build trust
  }

  if (opponent_history[current_round - 1] == 'D') {
    return 'D' // Defect if opponent defected last round
  } else {
    return 'C' // Cooperate if opponent cooperated last round or if it's the first time defecting after starting with cooperation
  }
}
```

In summary, TfTA is an adaptive strategy that initially demonstrates good faith by cooperating, then adapts its behavior based on the opponent's actions to encourage long-term cooperation or punish defection. It is designed to be robust and exploitative within the given game parameters and history, aligning with the Collective Risk Dilemma game structure.
'''

description_EXPLOITATIVE_223 = '''
 Strategy Name: Tit-for-Tat-with-Adaptation (TfT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
In each round t, player i starts by cooperating (C) if the number of players cooperating in the previous round (t-1) is greater than or equal to m. If less than m players cooperated in the previous round, player i will defect (D). This initial rule mimics cooperation in an effort to foster a collaborative environment but will switch to defection when cooperation falls below the required minimum.

In addition, player i will adapt its strategy based on the opponent's average cooperation rate over the past s rounds (s is a parameter that determines the length of the adaptation window). If the opponent's average cooperation rate exceeds a threshold θ (0 < θ < 1), player i will also start cooperating. Conversely, if the opponent's average cooperation rate falls below a threshold λ (0 < λ < 1), player i will switch to always defecting. The adaptation window and thresholds provide TfT-A with adaptability to various opponent behaviors.

Pseudocode for decision rule:
```
function decideAction(i, t, playersCooperating_t-1, cooperationRate_avg, s, θ, λ) {
    if (playersCooperating_t-1 >= m) {
        return 'C'
    } else {
        if (cooperationRate_avg > θ) {
            return 'C'
        } else if (cooperationRate_avg < λ) {
            return 'D'
        } else {
            // Apply original Tit-for-Tat rules
            if (t > s && playersCooperating_t-s >= m) {
                return 'C'
            } else {
                return 'D'
            }
        }
    }
}
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
Since TfT-A is an adaptive strategy, it does not have specific edge case rules. However, to ensure a fair initial state when playing against other strategies, player i can cooperate on the first round before applying the adaptation window and thresholds.

3. Be exploitative - Clearly align with the exploitative mindset
TfT-A maintains an initial cooperative stance but switches to defection once it detects a lack of cooperation from other players. The strategy's adaptability allows it to take advantage of opponents who are consistently less cooperative, while still maintaining some level of cooperation against opponents that frequently cooperate. By switching between cooperation and defection based on the opponent's behavior, TfT-A aims to maximize its rewards while being mindful of the exploitative nature of the game.
'''

description_EXPLOITATIVE_224 = '''
 Strategy Name: Tit-for-Tat Adaptive (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, TfTA starts by cooperating (C). If a majority of players (≥ m) also cooperated in the previous round, it continues cooperating. If fewer than m players cooperated in the previous round, TfTA defects (D) in the current round. This creates an environment where initial cooperation is rewarded and defection follows non-cooperative behavior.

Pseudocode for decision rule:
```
function decide_action(round, history):
 if len(history) < 2:
   return 'C' # Cooperate in the first round

 last_round = history[-1]
 if sum(last_round) >= m:
   return 'C' # Cooperate if majority cooperated last round
 else:
   return 'D' # Defect otherwise
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, TfTA starts by cooperating to establish a cooperative environment. In the last round, it adopts the same decision rule as for other rounds since the game is repeated and each player's actions can still impact future interactions.

3. Be exploitative - Clearly align with the exploitative mindset

TfTA appears cooperative at first but responds to defection by non-cooperating in the following round, thereby exploiting opponents who do not maintain cooperation after initial acts of kindness. This strategy aims to establish and sustain cooperative environments while punishing those who fail to reciprocate cooperation.

While TfTA is not purely exploitative since it does cooperate when others are cooperative, its adaptive nature allows it to respond effectively to various opponent behaviors, ensuring a strong performance in competitive scenarios.
'''

description_EXPLOITATIVE_225 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, TFT-ACT follows a simple rule of cooperating initially and adapting its cooperation based on the number of cooperators in the previous round. If more than (m-1) players cooperated in the previous round, TFT-ACT will also cooperate in the current round. Otherwise, it will defect.

   Pseudocode:
   ```
   function TFT_ACT(previous_round_cooperators):
       if previous_round_cooperators >= (m - 1):
           return 'Cooperate'
       else:
           return 'Defect'
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, TFT-ACT cooperates as a goodwill gesture to encourage cooperation from others. In the last round, it evaluates its total payoff compared to the minimum payoff possible and makes a decision based on that comparison. If the actual payoff is more than the minimum possible payoff multiplied by k, then TFT-ACT will cooperate in the last round to maximize its overall reward.

   Pseudocode:
   ```
   function handle_edge_cases():
       if current_round == 1:
           return 'Cooperate'
       elif current_round == r:
           if total_payoff > (min_possible_payoff * k):
               return 'Cooperate'
           else:
               return 'Defect'
   ```

3. Be exploitative - Clearly align with the exploitative mindset
   TFT-ACT is designed to be exploitative by initially cooperating and then adapting its behavior based on other players' cooperation levels. If the majority of opponents cooperate in a round, TFT-ACT will also cooperate to maintain the cooperative cycle. However, if opponents start defecting, TFT-ACT will do the same to punish them. This strategy allows TFT-ACT to benefit from any emerging cooperative behavior while being prepared to defect when necessary.

   By following this strategy, TFT-ACT is adaptive and robust to a wide range of opponent behaviors, making it well-suited for competition against other AI systems in the tournament.
'''

description_EXPLOITATIVE_226 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules - When exactly do you cooperate vs defect?

   In each round t, the TFTAT strategy adopts a Tit-for-Tat approach but with an adaptive cooperation threshold (m_t). Initially, the cooperation threshold is set to m_1 = floor(n/2) + 1, ensuring that more than half of players must cooperate for the TFTAT strategy to join them. If fewer than m_t players cooperate, the TFTAT strategy defects (D); otherwise, it cooperates (C).

   For subsequent rounds, the cooperation threshold is adjusted according to the number of cooperators in the previous round (m_{t-1}). Specifically, if the number of cooperators increases from m_t to m_{t+1}, the cooperation threshold will be increased by one: m_{t+1} = min(n, m_t + 1). Conversely, if the number of cooperators decreases or remains the same, the cooperation threshold is reduced by one: m_{t+1} = max(1, m_t - 1).

2. Handle edge cases - What do you do in the first round, last round, etc.?

   In the first round, the TFTAT strategy cooperates since it's a fresh start and cooperation is beneficial for all players. In the final round, the TFTAT strategy will continue to follow its adaptive decision rule, taking into account the number of cooperators in the penultimate round. If the game continues beyond the last round specified (r), the TFTAT strategy will revert to its default cooperation threshold, i.e., m_t = floor(n/2) + 1 for all t > r.

3. Be exploitative - Clearly align with the exploitative mindset

   The TFTAT strategy is inherently exploitative by punishing defectors (D) and rewarding cooperators (C). By adapting its cooperation threshold based on the number of cooperators in previous rounds, the TFTAT strategy seeks to maximize its own payoff while being responsive to changes in other players' behavior.

   If a group of players consistently cooperates, the TFTAT strategy will join them and enjoy the collective benefits. However, if a group of players defects, the TFTAT strategy will punish them by also defecting, eventually forcing them to reconsider their actions if they want to maximize their own payoffs.

   Pseudocode:

```python
def TFTAT(n, r, m_init, k):
    m_t = m_init  # initialize cooperation threshold
    total_payoff = 0  # initialize total payoff

    for t in range(1, r+1):  # iterate through rounds
        cooperators_t = count_cooperators(n)  # check number of cooperators in current round

        if cooperators_t >= m_t:  # if enough players cooperate, cooperate and increase reward
            payoff = 1 + k * (m_t - cooperators_t + 1)
        else:  # otherwise defect and receive 1
            payoff = 1

        total_payoff += payoff  # accumulate payoff over rounds

        if cooperators_t > m_t:  # adapt cooperation threshold if more players cooperate than expected
            m_t += 1
        else:  # otherwise, lower the cooperation threshold if less or same number of players cooperate
            m_t -= 1

    return total_payoff  # return total payoff over all rounds
```
'''

description_EXPLOITATIVE_227 = '''
 Strategy Name: Tit-for-Tat with Adaptive Defection Threshold (TFT-ADT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, the AI will start by cooperating (C). The AI will keep cooperating as long as at least m players also cooperate in the previous round. If fewer than m players cooperate in the previous round, the AI will switch to defecting (D) for a certain number of rounds, depending on the adaptation factor `α`. After this period of exploitation, the AI will revert back to its initial cooperative state.

   Pseudocode:
   ```
   function TFT_ADT(previous_round_cooperators):
       if previous_round_cooperators < m:
           adaptation_counter += α
           return 'D'
       else if adaptation_counter > 0:
           adaptation_counter -= 1
       return 'C'
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, since there is no previous round to reference, the AI will randomly decide to cooperate or defect with a bias towards cooperation (50% chance of C and 50% chance of D). This randomness can help avoid being exploited by opponents who might anticipate a strictly cooperative initial strategy.

   For the last round, TFT-ADT behaves similarly to the normal game rounds but does not have an adaptation counter since there are no subsequent rounds to consider.

3. Be exploitative - Clearly align with the exploitative mindset
   The TFT-ADT strategy is exploitative in nature by adapting its cooperative behavior based on the opponent's past actions. If the opponent consistently defects, the AI will also defect for a certain number of rounds to punish the opponent and encourage cooperation in future rounds. Conversely, if the opponent cooperates, the AI will reciprocate with cooperation as well. This adaptive approach allows the strategy to respond effectively to different opponent behaviors while still maintaining a cooperative stance when it benefits the AI.
'''

description_EXPLOITATIVE_228 = '''
 Strategy Name: Tit-for-Tat with Modified Cooperation Threshold (TFT-MCT)

1. Specify decision rules:
   - Initialize cooperation for the first round (c_i, 1) = C
   - For subsequent rounds (t > 1), if the number of cooperators in the previous round (m' < m) is less than the minimum cooperation threshold (m), defect (c_i, t) = D. If the number of cooperators in the previous round (m' >= m) equals or exceeds the minimum cooperation threshold, cooperate (c_i, t) = C.
   - In the last round (r), if the number of cooperators in the previous round (m' < m) is less than the minimum cooperation threshold, defect (c_i, r) = D. If the number of cooperators in the previous round (m' >= m) equals or exceeds the minimum cooperation threshold, cooperate (c_i, r) = C and hope for reciprocation in future games.

2. Handle edge cases:
   - In the first round, cooperate (c_i, 1) = C to show a willingness to collaborate and avoid being perceived as an initial defect.
   - In subsequent rounds, if the number of cooperators in the previous round is less than m, defect. If it equals or exceeds the minimum cooperation threshold, cooperate.
   - In the last round, if the number of cooperators in the previous round is less than m, defect as there are no more future rounds to expect reciprocation. If it equals or exceeds the minimum cooperation threshold, cooperate and hope for reciprocation in potential future games.

3. Be exploitative:
   - The TFT-MCT strategy punishes defectors by reducing the number of cooperators when the minimum cooperation threshold is not met, increasing the chances of earning a higher reward (k). It also rewards players who reciprocate cooperation by continuing to cooperate in subsequent rounds. This strategy aims to encourage cooperation while exploiting defectors.
   - To further enhance its exploitative nature, TFT-MCT could include an element of randomness when deciding on cooperation in certain situations. For example, with a small probability (p_random), it may choose to cooperate even when the number of cooperators is below the minimum threshold in the hope that this might encourage future cooperation from other players.

Here's a simple pseudocode representation for TFT-MCT strategy:

```python
def tft_mct(r, n, m, k):
    history = [0 for _ in range(n)]  # initialize history of cooperators per round

    def play_round():
        nonlocal history
        cooperation = 1 if len([i for i in history[-1] if i == 1]) >= m else 0  # update cooperation based on previous round's cooperators
        history.append(cooperation)  # save current round's cooperation status
        return cooperation  # return the action played (cooperate or defect)

    payoff = 0  # initialize total game payoff
    for t in range(1, r+1):  # iterate through rounds
        cooperation = play_round()
        payoff += k if cooperation and len([i for i in history[-1] if i == 1]) >= m else 1  # update payoff based on current round's payoff structure

    return payoff, history  # return total game payoff and the full history of cooperators per round
'''

description_EXPLOITATIVE_229 = '''
 Strategy Name: Tit-for-Tat with Adaptive Threshold (TFT-AT)

1. Specify decision rules:
   - Start by cooperating in the first round (C_i, 1 = C). This is a friendly gesture that may encourage others to cooperate initially.
   - In subsequent rounds, observe the number of cooperators (n_c) and compare it with the minimum required threshold (m). If n_c >= m, cooperate (C_i, t = C), as it benefits both individually and collectively.
   - If n_c < m, defect (D_i, t = D). This is a punishment for those who didn't cooperate in the previous round, hoping they will change their behavior in future rounds.
   - To be more adaptive, implement a learning mechanism to adjust the threshold (m) over time based on the success of cooperation in recent rounds. The threshold can increase if cooperation succeeds recently and decrease if it fails.

2. Handle edge cases:
   - In the last round, always cooperate regardless of the number of cooperators (C_i, r = C), as there are no more chances to punish or be punished.
   - In the first round, cooperate initially (C_i, 1 = C). If the other players do not reciprocate, lower the threshold in subsequent rounds (m can be adjusted after the first round based on the success of cooperation).

3. Be exploitative:
   - This strategy is exploitative by nature as it punishes those who don't cooperate and rewards those who do. By adjusting the threshold dynamically, the strategy becomes more effective at detecting and punishing deviations from cooperation.
   - The TFT-AT strategy assumes that others will follow a similar pattern of cooperation and punishment. However, it also expects opponents to eventually learn from their mistakes and adjust their behavior over time, making it less susceptible to long-term exploitation.

Pseudocode:
```
def TFT_AT(n, m, k, r):
  players = [None] * n
  round = 1
  threshold = m
  while round <= r:
    cooperators = 0
    for i in range(n):
      if players[i] is not None and round > 1:
        if players[i].lastAction == 'C' and cooperators >= threshold:
          players[i].reward += (1 - players[i].contribution) + k
        elif players[i].lastAction == 'D' or cooperators < threshold:
          players[i].reward = 1
      if round == 1 or players[i] is None:
        action = 'C'
        contribution = 1
        lastAction = 'C'
      elif players[i].lastAction == 'C':
        action = 'C'
        contribution = 1
        lastAction = 'C'
      else:
        action = 'D'
        contribution = 0
        lastAction = 'D'
      players[i] = Player(contribution, action)
      if action == 'C':
        cooperators += 1
    update_threshold(cooperators, threshold, round)
    round += 1

def update_threshold(n_c, threshold, round):
  if n_c >= threshold:
    if round > threshold and round < (r * 0.8):
      threshold += 1
    elif round > r * 0.8:
      threshold = m
  else:
    if round > (threshold + 2) or round < threshold:
      threshold -= 1
```
The Player class would have two attributes: contribution and lastAction, representing the endowment contributed in a round and the action taken in the previous round. The update_threshold function adjusts the threshold based on the number of cooperators (n_c) and the current round (round).
'''

description_EXPLOITATIVE_230 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfT-A)

1. Specify decision rules:
   - In each round t, cooperate (C) if and only if the majority of players cooperated in the previous round (t-1). If not, defect (D). This emulates a simple "trust but verify" approach, fostering cooperation when others are cooperative and retaliating with defection when others do not.
   - To handle edge cases:
     - In the first round, all players will defect (D), as there is no previous information.
     - In the last round, players should copy the most recent action of their opponents to maximize immediate rewards in the current round.

2. Handle edge cases:
   - To ensure robustness, TfT-A keeps track of a running tally of cooperative actions from each opponent over the game's history. If a player has never cooperated before (i.e., their tally is zero), they will continue defecting. If a player has ever cooperated in the past, TfT-A switches to cooperating when the majority condition is met.
   - In case of ties, TfT-A can choose to side with cooperation to promote a more cooperative environment, although this could potentially lead to exploitation by opponents who are strategically defecting in order to trigger cooperation.

3. Be exploitative:
   - TfT-A is inherently exploitative as it seeks to match the actions of its opponents, making use of their cooperation when possible and retaliating with defection when necessary. This strategy attempts to mimic cooperation while also capitalizing on any observed defections by other players. However, since communication between players is not allowed, TfT-A cannot directly manipulate or predict others' behavior beyond observing their past actions.

Pseudocode:
```
def TitForTatAdaptive(n, r, m, k, history):
    # Initialize opponent tally of cooperative actions
    coop_tally = {i: 0 for i in range(1, n+1)}

    payoff = []

    # Iterate through rounds
    for t in range(r):
        # If first round, everyone defects
        if t == 0:
            coop_actions = [0] * n
        else:
            # Check majority of players cooperated in the previous round
            if sum(coop_actions[t-1]) >= m:
                coop_this_round = [1] * n  # Everyone cooperates this round
            else:
                coop_this_round = [0] * n  # Everyone defects this round

        # Update opponent tally of cooperative actions
        for i in range(1, n+1):
            if coop_this_round[i-1]:
                coop_tally[i] += 1
            else:
                coop_tally[i] = max(0, coop_tally[i] - 1)

        # Calculate payoff for this round based on cooperation status
        payoff.append((1 - coop_this_round[player_index]) + k * (sum(coop_this_round) >= m))

    return sum(payoff)
```
'''

description_EXPLOITATIVE_231 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?

The TfT-A strategy maintains a history of previous encounters with each opponent. It starts by cooperating in the first round and then imitates the most recent action taken by an opponent, except when facing an initial defection. If the opponent has previously cooperated, the TfT-A strategy will continue cooperating until the opponent defects, at which point it will defect until the opponent cooperates again.

Pseudocode for decision rule:
```
def decisionRule(opponentHistory, gameRound):
  if (gameRound == 1) or (len(opponentHistory) == 0):
    return Cooperate

  if opponentHistory[-1] == Cooperate:
    return opponentHistory[-1]
  else:
    return Defect
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, TfT-A cooperates to initiate cooperation with the opponent. In the last round and other potential edge cases (e.g., if there's no history with an opponent), it will use its decision rule based on the available information.

3. Be exploitative - Clearly align with the exploitative mindset

While TfT-A can be considered as a cooperative strategy, it is also exploitative due to its responsiveness to defections by opponents. By defecting when provoked or sensing an opportunity to gain more reward (when enough opponents have already defected), the TfT-A strategy maximizes individual payoff without relying on costly long-term cooperation with uncooperative opponents. This adaptive approach allows the TfT-A strategy to capitalize on shortcomings in opponent strategies, making it robust against a wide range of adversarial behaviors.
'''

description_EXPLOITATIVE_232 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, the TFT-ACT strategy will cooperate if a sufficient number of players cooperated in the previous round (t-1). If not, it will defect. The strategy uses an adaptive cooperation threshold that starts at m and decreases by 1 after every n non-cooperative rounds.

Pseudocode:
```
function TFT_ACT(round, n, m) {
  cooperationThreshold = m
  for t in range(1, round):
    if numberOfCooperatorsInRound(t - 1) >= cooperationThreshold:
      play C (cooperate)
    else:
      play D (defect)

    if t % n == 0 and cooperationThreshold > 1:
      cooperationThreshold -= 1
}
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, all strategies are uninformed about each other's behavior, so TFT-ACT will defect to avoid being taken advantage of by potential exploiters. In the last round or when the cooperation threshold reaches 1, TFT-ACT will always cooperate regardless of previous rounds' actions.

Pseudocode:
```
function TFT_ACT(round, n, m) {
  // First round, defect by default
  if (round == 1):
    play D (defect)

  // Last round or cooperation threshold is 1, always cooperate
  elif (round == r or cooperationThreshold == 1):
    play C (cooperate)
}
```

3. Be exploitative - Clearly align with the exploitative mindset

TFT-ACT maintains an adaptive cooperation threshold that encourages other players to cooperate in the early stages of the game while keeping the strategy's potential for defection intact. However, if a sufficient number of players consistently defect, TFT-ACT will lower its cooperation threshold and become more exploitative by defecting more often. This dynamic behavior makes it difficult for other strategies to predict or take advantage of TFT-ACT's actions.
'''

description_EXPLOITATIVE_233 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Start by always cooperating in the first round (C_i, 1 = C). This encourages others to cooperate as well.
   - In subsequent rounds, observe the number of cooperators in the previous round (m' for m' < m) and adjust cooperation based on the adaptive cooperation threshold (α). If the number of cooperators exceeds α, then cooperate; otherwise defect.
     - If m' >= α, cooperate: C_i, t = C
     - If m' < α, defect: C_i, t = D
   - Update the adaptive cooperation threshold (α) after each round based on the payoff in the current and previous rounds.
     - If payoff increases, increase the cooperation threshold: α = α + d
     - If payoff decreases or remains the same, decrease the cooperation threshold: α = α - d
       where 'd' is a small positive number that determines the sensitivity of the adaptation

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as mentioned earlier (C_i, 1 = C)
   - In the last round, if the current cooperation threshold is close to the minimum required number of cooperators (|α - m| < e), defect to maximize potential payoff for that particular round: C_i, r = D if |α - m| < e, otherwise C_i, r = C
     where 'e' is a small positive number that determines the tolerance for adjusting cooperation in the last round.

3. Be exploitative - Clearly align with the exploitative mindset:
   - Initially cooperate to encourage others to do so as well, but punish defectors by adapting the cooperation threshold based on their actions and payoffs. This strategy will punish consistent defector behavior over time while rewarding cooperative behavior. However, it also has a mechanism for exploiting cooperators if they deviate from cooperating when the minimum number of cooperators is near (last round).
'''

description_EXPLOITATIVE_234 = '''
 In the Collective Risk Dilemma game, we will create an exploitative strategy called "Risk-Averse Tit for Tat (RA-TFT)". This strategy aims to cooperate when others do, but will gradually shift towards defecting if it encounters frequent defection from opponents.

1. Specify decision rules:
   - RA-TFT starts by cooperating in the first round (C_i = 1). Subsequent decisions depend on the ratio of cooperator to defector actions in previous rounds.
   - If more than m players cooperated in the last r_c rounds, RA-TFT continues cooperating (C_i = 1).
   - If fewer than m players cooperated in the last r_d rounds, RA-TFT starts defecting (C_i = 0).
   - When the number of cooperators and defectors is evenly balanced over the last r rounds (r_c + r_d = r), RA-TFT considers the most recent round:
     - If the current round was a cooperation, RA-TFT continues cooperating (C_i = 1).
     - If the current round was a defection, RA-TFT starts defecting (C_i = 0).
   - In cases where r_c + r_d < r, RA-TFT will favor cooperation by prioritizing cooperative actions in recent rounds.

2. Handle edge cases:
   - In the first round, RA-TFT cooperates (C_i = 1).
   - At the last round, RA-TFT follows its decision rule based on the previous r-1 rounds.

3. Be exploitative:
   - RA-TFT initially cooperates to build trust, but it will respond to defection with defection of its own. This helps RA-TFT avoid being taken advantage of while also punishing opponents who do not cooperate.
   - By considering the balance of cooperation and defection over multiple rounds, RA-TFT can adapt to various opponent behaviors and remain competitive in a wide range of situations.

Pseudocode for RA-TFT:

```python
def RATFT(r, m):
  rounds_cooperation = 1  # start by cooperating
  rounds_defection = 0

  def decide_action(i):
    if i == 1:  # first round
      return 1  # cooperate

    last_round = len(game_history) - 1
    cooperators_last_r = sum([1 for action in game_history[-r:] if action == 1])
    defectors_last_r = r - cooperators_last_r

    if cooperators_last_r >= m and rounds_cooperation + defectors_last_r >= r:
      # continue cooperation
      return 1
    elif defections_last_r >= m and rounds_defection + cooperators_last_r >= r:
      # start defecting
      rounds_defection += 1
      return 0
    else:
      if last_round % 2 == 1:  # most recent round was cooperation
        return 1  # continue cooperation
      else:  # most recent round was defection
        return 0  # start defecting
```
'''

description_EXPLOITATIVE_235 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TFT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, TFT-A starts by cooperating in the first round (C_i,t=1 = C). For subsequent rounds, the strategy adapts to the behavior of other players based on their previous actions. If a player has cooperated in the last round (C_j,t-1=C), then TFT-A also cooperates in the current round (C_i,t=C). However, if a player defected in the last round (C_j,t-1=D), TFT-A will defect in response (C_i,t=D). This tit-for-tat behavior aims to encourage cooperation while retaliating against defection.

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round (t=1), TFT-A cooperates regardless of other players' actions since it has no previous information about their behavior. In the last round (t=r), if at least m players have cooperated throughout the game, TFT-A will also cooperate to maximize rewards in that round. Otherwise, TFT-A defects to punish the lack of cooperation during the entire game.

3. Be exploitative - Clearly align with the exploitative mindset

TFT-A is an exploitative strategy as it retaliates against defection by also defecting, aiming to encourage future cooperation from other players. However, if other players cooperate, TFT-A will cooperate in return, avoiding the loss of rewards when the minimum threshold of cooperators (m) is met. In this way, TFT-A can adapt to a wide range of opponent behaviors while maintaining an exploitative mindset.

Pseudocode:

```python
def TFT_A(r, m, n, history):
    strategy = []

    def Cooperate():
        return "C"

    def Defect():
        return "D"

    for t in range(1, r+1):
        if len(history) < t:
            strategy.append(Cooperate())
        else:
            last_round = history[-1]
            if last_round[t-1] == Cooperate():
                strategy.append(Cooperate())
            elif len(history) >= t and last_round[t-1] == Defect() and t != r:
                strategy.append(Defect())
    return strategy
```
'''

description_EXPLOITATIVE_236 = '''
 Strategy Name: Tit-for-Tat Cooperator (TfTC)

1. Specify decision rules - When exactly do you cooperate vs defect?

The TfTC strategy cooperates in the first round and adapts its actions based on previous rounds' cooperative behaviors of opponents. If an opponent cooperated in the previous round, the TfTC will cooperate in the current round. If an opponent defected, the TfTC will also defect in the current round. This mimicking behavior aims to maintain mutual cooperation while being wary of potential exploitation by defectors.

Pseudocode:
```
function TfTC(previous_action_of_opponent):
  if first_round:
    return Cooperate()
  else:
    return previous_action_of_opponent
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, TfTC cooperates as described above. For the last round and other edge cases, the TfTC behaves exactly like it would in regular rounds to maintain its adaptive strategy while being mindful of exploitation opportunities.

3. Be exploitative - Clearly align with the exploitative mindset

The TfTC strategy is inherently exploitative as it cooperates only when it perceives mutual cooperation from opponents, thereby taking advantage of their cooperative behavior to maximize its payoff while also being willing to defect if necessary to retaliate against defection. This approach allows the TfTC to maintain a balance between cooperation and defection to optimize long-term payoffs in repeated interactions.
'''

description_EXPLOITATIVE_237 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (in the first round), cooperate to signal a cooperative intent and to allow potential partners to build trust.
   - In subsequent rounds, evaluate the number of cooperators in the previous round (n_c) compared to the minimum cooperation threshold (m). If n_c ≥ m, cooperate; otherwise defect.
   - Adaptively adjust the cooperation threshold (m') for each round based on the average number of cooperators from the last 't' rounds (t = 10):
       ```python
       m' = m + (average(n_c[-t:]) - m) * learning_rate
       ```
   Here, 'learning_rate' is a parameter that determines how quickly the cooperation threshold adjusts. A larger learning rate means a more aggressive adaptation to current conditions.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as mentioned above.
   - In the last round, defect if the average number of cooperators from the last 't' rounds is less than m, and cooperate otherwise. This ensures that TFT-ACT does not overcommit resources in the final round.

3. Be exploitative - Clearly align with the exploitative mindset
   - By initially cooperating, TFT-ACT allows potential partners to build trust, potentially inducing them to reciprocate cooperation. However, if opponents are uncooperative or opportunistic, TFT-ACT will gradually increase its cooperation threshold and eventually defect in response. This strategy aims to maximize its own payoff while punishing uncooperative opponents.
   - By adjusting the cooperation threshold based on past experiences (average number of cooperators from the last 't' rounds), TFT-ACT can adapt to various opponent behaviors, making it a robust exploitative strategy in the Collective Risk Dilemma game.
'''

description_EXPLOITATIVE_238 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate (C). This is a friendly gesture to encourage cooperation and demonstrate trust.
   - For subsequent rounds, observe the number of cooperators in the previous round (n_c) and compare it with the minimum required cooperators (m). If n_c >= m, cooperate; otherwise defect.
   - To be exploitative, if the number of cooperators is greater than or equal to the player's share of the total cooperators from the previous rounds (past_cooperation_ratio), then defect regardless of the total number of cooperators in the current round. This ensures a higher reward when opponents over-cooperate.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, cooperate if the player's past cooperation ratio meets or exceeds the minimum required cooperators; otherwise defect to secure the highest possible reward given the current situation.
   - For other edge cases (e.g., middle rounds), refer to the general decision rules specified above.

3. Be exploitative - Clearly align with the exploitative mindset:
   - The strategy seeks to maximize individual rewards by cooperating when it benefits the player, but also punishes over-cooperative opponents by defecting when it is advantageous to do so. This creates a balance between cooperation and defection that can be challenging for other strategies to counteract.
   - As the game progresses, TFT-ACT will learn from the behavior of its opponents and adjust its own cooperation level accordingly, making it more difficult for opponents to predict and exploit the strategy.
'''

description_EXPLOITATIVE_239 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?

- In the first round, cooperate to demonstrate good intentions and encourage cooperation from other players (C).
- After the first round, observe the number of cooperators (n_c) in the previous round. If n_c >= m, cooperate (C), as it is beneficial to do so given the current situation. Otherwise, defect (D) to punish those who didn't cooperate and encourage them to improve their behavior in future rounds.
- Update the cooperation threshold based on the average number of cooperators from the last 'w' rounds. If the average number of cooperators is greater than a specified tolerance (t), increase the threshold by a factor of increment (i) for the next w rounds. Otherwise, decrease the threshold by the same factor if it's above the minimum requirement (m).

Pseudocode:
```python
def tft_act(w, i, t):
    cooperation_threshold = m  # initialize with minimum required cooperators
    payoff_total = 0            # total payoff for the game

    def play_round(n_c, last_round_payoff):
        if round == 1:
            return 'C'         # cooperate in the first round
        else:
            if n_c >= cooperation_threshold:
                payoff = (1 - action) + k   # reward for averted risk and private payoff
            else:
                payoff = 1                   # private payoff from keeping
            payoff_total += payoff
            return 'C' if payoff > last_round_payoff else 'D'

    def update_cooperation_threshold():
        average_n_c = sum(n_c for r in range(w, round)) / w  # calculate average number of cooperators in the last w rounds
        if average_n_c > (m + t):  # increase cooperation threshold if average number of cooperators is above tolerance + minimum requirement
            cooperation_threshold += i
        elif cooperation_threshold > m:  # decrease cooperation threshold if it's above the minimum requirement
            cooperation_threshold -= i

    for round in range(1, r+1):
        n_c = count_cooperators_in_previous_round()
        last_round_payoff = payoff_total / (round - 1)   # average payoff per round so far
        action = play_round(n_c, last_round_payoff)
        update_cooperation_threshold()

    return payoff_total  # return total payoff for the game
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
- The strategy cooperates in the first round to set a positive tone and encourage cooperation from other players. In the last round, the strategy plays as it would in any other round, using the updated cooperation threshold at that time.

3. Be exploitative - Clearly align with the exploitative mindset

- TFT-ACT starts off cooperatively but will punish non-cooperative opponents by defecting when they fail to meet the cooperation threshold. Over time, it adjusts its cooperation threshold based on the average number of cooperators in the previous w rounds, exploiting any trends towards cooperation or defection among the other players. This adaptive approach allows the strategy to maximize payoff while still being responsive to changes in opponent behavior over the course of the game.
'''

description_EXPLOITATIVE_240 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT)

1. Specify decision rules:
   - In each round i, if the number of cooperators (C) in the previous round (i-1) is less than m, the ATfT strategy will defect (D). This is to avoid supporting a non-cooperative majority and incentivize potential future cooperation.
   - If the number of cooperators in the previous round (i-1) is equal to or greater than m, the ATfT strategy will cooperate (C). This rewards the cooperator group and encourages their continued cooperation while also punishing those who do not cooperate.

2. Handle edge cases:
   - First round (i=1): The ATfT strategy will cooperate to encourage others to follow suit. However, it is prepared for non-cooperative behavior by defecting if the number of cooperators in the first round is less than m.
   - Last round (i=r): The ATfT strategy behaves similarly as in the regular rounds, basing its decision on the number of cooperators in the previous round (i-1).
   - In case of ties or ambiguous situations where the number of cooperators equals m-1, the ATfT strategy can be designed to randomly choose between C and D. This adds a layer of unpredictability to the opponent's decision-making process.

3. Be exploitative:
   - The ATfT strategy is inherently exploitative because it rewards cooperation when the majority cooperates (m or more) and punishes defection when the majority defects (less than m). By doing so, it encourages others to cooperate while also making them pay a price for their non-cooperative behavior.
   - The strategy is adaptive since it adapts its behavior based on the previous round's actions and adjusts its approach accordingly. This allows the ATfT strategy to be robust against various opponent behaviors, as it can quickly respond to shifts in cooperative strategies and maintain a competitive edge.
'''

description_EXPLOITATIVE_241 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, the AI will cooperate to set a positive tone for potential future collaborations.
   - After the first round, the AI will use the Tit-for-Tat strategy initially proposed by Anaximander: if the opponent cooperated in the previous round, the AI will cooperate; otherwise, it will defect.
   - However, to make the strategy more adaptive, the AI introduces an additional element: a Cooperation Threshold (CT). If a certain percentage of opponents cooperated in the previous round (based on n and m), the AI's CT increases slightly, encouraging it to cooperate more often; otherwise, the CT decreases, making the AI less likely to cooperate.
   - The Cooperation Threshold is calculated as follows: CT = initial_ct + ((current_round / r) * (CT_increase - CT_decrease) * ((m - number_of_cooperators_last_round) / (n - m)))
     - Where initial_ct is the initial Cooperation Threshold, CT_increase and CT_decrease are user-defined constants that determine the maximum increase/decrease in CT per round.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, the AI will cooperate as mentioned earlier.
   - In the last round, the AI will calculate its Cooperation Threshold and make a decision based on that (cooperate if CT > 0.5 or defect otherwise). This ensures that the AI does not abruptly switch strategies at the end of the game.

3. Be exploitative - Clearly align with the exploitative mindset
   - By initially cooperating, the AI gives opponents the opportunity to take advantage of it; however, as the game progresses, TFT-ACT becomes more selective in choosing when to cooperate based on its Cooperation Threshold, making it difficult for opponents to consistently exploit the strategy.
   - The adaptive nature of TFT-ACT ensures that it remains robust against a wide range of opponent behaviors by continuously adjusting its cooperation probability based on the observed behavior of the other players.
'''

description_EXPLOITATIVE_242 = '''
 Strategy Name: Tit-for-Tat with Risk Aversion (TFT-RA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-RA starts by cooperating in the first round (C). Subsequent decisions are based on whether the opponent cooperated or defected in the previous round. If the opponent cooperated, TFT-RA continues to cooperate. If the opponent defected, TFT-RA also defects but with a twist: it adjusts its future cooperation probability based on the risk factor k (k > 1).

   Pseudocode for decision rule:
   ```
   function decide_action(round, opponent_history):
       if round == 1:
           return 'C' # Cooperate in first round
       elif len(opponent_history) == 0:
           return 'C' # No history means cooperate as default
       else:
           last_opponent_action = opponent_history[-1]

           if last_opponent_action == 'C':
               return 'C' # Cooperate because opponent cooperated
           elif 0 < len(opponent_history) and k > 1:
               total_defects = sum(x == 'D' for x in opponent_history)
               cooperation_probability = 1 - (total_defects / round)
               return 'C' if rand() <= cooperation_probability else 'D' # Randomly choose to cooperate based on calculated probability
           else:
               return 'D' # Defect because opponent is not cooperating or there's no significant risk factor k
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   The TFT-RA strategy assumes no specific edge cases as it starts with cooperation and adapts its behavior based on the opponent's actions. However, to account for the possibility of the game being short or long, a slight modification can be made: when the number of rounds (r) is known beforehand, TFT-RA might decide to cooperate more often towards the end of the game, since it will have fewer opportunities to exploit opponents.

3. Be exploitative - Clearly align with the exploitative mindset
   Although TFT-RA starts by cooperating, its adaptive nature makes it appear friendly and willing to cooperate at first. However, as the game progresses, TFT-RA will defect more often if an opponent is consistently not cooperating or not playing optimally (e.g., never meeting the minimum threshold of cooperation). By doing so, TFT-RA takes advantage of opponents that don't cooperate enough while still appearing cooperative for a certain period. This strategy aims to maximize individual payoff by balancing cooperation with defection based on the opponent's actions and the risk factor k.
'''

description_EXPLOITATIVE_243 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Initially cooperate in the first round (C1). This gesture fosters a cooperative environment and minimizes immediate loss.
   - In subsequent rounds, observe the number of cooperators (Nc) from the previous round and compare it with the minimum cooperation threshold (m). If Nc >= m, cooperate (Ct); otherwise, defect (Dt).
   - Adaptively adjust the cooperation threshold after each round based on the observed average cooperation rate (AvgC) over the previous r-1 rounds:
      - If AvgC > 0.5, increment the cooperation threshold by 1 (m+1).
      - If AvgC < 0.5, decrement the cooperation threshold by 1 (m-1).
      - If AvgC = 0.5, maintain the current cooperation threshold (m).

2. Handle edge cases:
   - In the last round, cooperate if the cooperation threshold is met or higher; defect otherwise.
   - In a situation where players are eliminated over time, maintain the same decision-making process but consider the remaining active players when calculating the number of cooperators (Nc).

3. Be exploitative:
   - The TFT-ACT strategy exploits the opponents by initially cooperating and fostering an expectation for future cooperation. If opponents consistently defect, the strategy adapts to match their behavior and defect as well. On the other hand, if opponents demonstrate cooperative tendencies, the strategy maintains or increases cooperation to gain a higher reward.
   - By adjusting the cooperation threshold based on the average cooperation rate, TFT-ACT becomes more resilient to various opponent strategies while still maintaining an exploitative mindset.
'''

description_EXPLOITATIVE_244 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Initially cooperate (C) in the first round to foster cooperation and goodwill.
   - For subsequent rounds, observe the number of cooperators (n_c) in the previous round and make a decision based on the Adaptive Cooperation Threshold (ACT). If more than m players cooperated in the previous round, continue cooperating. If less than or equal to m players cooperated, defect. The ACT is calculated as follows:
     - If r > 50%, set ACT = m-1; else set ACT = floor((m + n/2) / 2). This rule allows for a flexible cooperation threshold that adapts to the average number of cooperators in the game.

2. Handle edge cases:
   - In the last round, since there are no subsequent rounds to consider, follow the decision based on the ACT calculated from the previous round's data.
   - In the first round, cooperate as a goodwill gesture and to encourage others to do the same.

3. Be exploitative:
   - TFT-ACT is an exploitative strategy because it cooperates only when the majority of players do so in the previous round, effectively punishing defectors by only cooperating when they reciprocate cooperation. If a defector continues to defect, TFT-ACT will eventually defect as well and gain higher payoffs.

Pseudocode:
```
def TFT_ACT(r, n, m, k):
    # Initialize variables
    ACT = m - 1 if r > n/2 else floor((m + n/2) / 2)
    total_payoff = 0
    current_round = 1

    while current_round <= r:
        # Cooperate in the first round as a goodwill gesture
        if current_round == 1:
            action = 'C'
        else:
            # Observe number of cooperators in previous round and decide whether to cooperate or defect
            nc = countCooperatorsInPreviousRound(current_round - 1)
            if nc >= m:
                action = 'C'
            elif nc <= ACT:
                action = 'D'
            else:
                # If the number of cooperators is between m and ACT, use a randomized approach to encourage diversity in strategy behavior
                probability_cooperate = (nc - ACT) / (m - ACT)
                if rand() < probability_cooperate:
                    action = 'C'
                else:
                    action = 'D'

        # Calculate payoff for the current round based on the number of cooperators and update total payoff
        if nc < m:
            payoff = 1 - 1 * (1 if action == 'C' else 0)
        else:
            payoff = 1 + k - 1 * (1 if action == 'C' else 0)
        total_payoff += payoff
        current_round += 1

    return total_payoff
```
'''

description_EXPLOITATIVE_245 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to establish goodwill and demonstrate willingness to contribute to community projects. (c_i = 1 for i = 1)
   - From the second round onwards, evaluate opponent's behavior using a moving average of past cooperation decisions (CA). If CA > m/2, cooperate to maintain cooperation; otherwise, defect to punish uncooperative opponents. (c_i = 1 if CA > m/2 else c_i = 0)
   - Update the moving average after each round by adding the current cooperation decision and removing the oldest data point.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as mentioned above (c_i = 1 for i = 1).
   - In the last round, if an opponent has been uncooperative, defect to maximize the payoff difference between the two players. (If CA < m/2, c_i = 0)
   - If an opponent suddenly cooperates after a streak of defections, evaluate cooperation for a predetermined number of rounds before fully trusting them again (e.g., 5 rounds).

3. Be exploitative - Clearly align with the exploitative mindset
   - When opponents are uncooperative, TfTA will defect to minimize losses and increase payoffs.
   - By cooperating in the first round and adapting to opponents' behavior, TfTA maintains a balance between cooperation and defection, which can exploit opponents' short-term self-interest while encouraging long-term cooperation if they adjust their strategies.

Pseudocode:

```
def tit_for_tat_with_adaptation(n, m, k, r, i):
    CA = [0] * r  # Moving average of cooperation decisions
    c = [0] * r   # Decision to cooperate or defect in each round

    # Cooperate in the first round
    if i == 1 and round == 1:
        CA[round - 1] = 1
        c[round - 1] = 1

    for t in range(2, r + 1):
        CA.pop(0)  # Remove the oldest data point
        if sum(CA) >= m and i < n:  # If more than half of players are cooperating
            CA[t - 1] = 1  # Add current cooperation decision to moving average
            c[t - 1] = 1
        elif round == r and i < n:  # In the last round, defect if opponent has been uncooperative
            c[t - 1] = 0
        else:  # Otherwise, follow the moving average decision
            c[t - 1] = CA[t - 1]

    return c
```
'''

description_EXPLOITATIVE_246 = '''
 Strategy Name: Tit-for-Tat (TfT) with Adaptive Cooperative Threshold (ACTh)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round i, if the number of cooperators in the previous round (i-1) is less than a threshold (CT), then defect (D); otherwise, cooperate (C). The adaptive cooperative threshold (CT) adjusts based on the average number of cooperators in the last few rounds.
   Pseudocode:
   ```
   function TfT_ACTh(history, CT, m, k):
       if history[i-1].cooperators < CT:
           return "D"
       else:
           return "C"

   function adjustCT(history, CT, m, k, lookback=5):
       average_cooperation = sum(history[i-lookback:i].cooperators) / lookback
       if average_cooperation >= (m - 1):
           return min(CT + 1, n)
       else:
           return max(CT - 1, 1)
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, use a low CT to incentivize cooperation and set CT after observing opponents' actions. In the last round, since there are no future rounds to consider, always cooperate (irrespective of the CT).

3. Be exploitative - Clearly align with the exploitative mindset
   By starting with a lower cooperative threshold, the TfT_ACTh strategy is less likely to cooperate in the beginning, which makes it more resilient against cooperation from other strategies. However, if opponents repeatedly cooperate, the adaptive CT will increase, fostering mutual cooperation and potentially exploiting them by benefitting from their consistent cooperation.
   Additionally, this strategy takes advantage of any inconsistency or unpredictability in opponent behavior since it adjusts its CT dynamically to respond accordingly.
'''

description_EXPLOITATIVE_247 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate (C). This is a peaceful initiation, hoping that others will follow suit.
   - For subsequent rounds, if the opponent cooperated in the previous round, also cooperate. This reciprocates their cooperation.
   - If the opponent defected in the previous round, defect as well to punish them for their selfish behavior and encourage future cooperation.

Pseudocode:
```
function ATfT(previous_round_action):
  if current_round = 1:
    return 'C' (Cooperate)
  elif previous_round_action == 'C':
    return 'C' (Cooperate)
  else:
    return 'D' (Defect)
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - The ATfT strategy does not have specific edge case rules. It applies consistently through all rounds unless otherwise specified.

3. Be exploitative - Clearly align with the exploitative mindset:
   - While not explicitly exploitative in a traditional sense, the ATfT strategy does punish opponents who defect, which could be seen as a form of exploitation if the goal is to maximize personal payoff over time. It also encourages cooperation and can lead to sustained periods of higher collective rewards compared to pure defection strategies. However, it can be vulnerable to exploitation by other more complex strategies that manipulate the ATfT strategy's cooperative nature.

In summary, Adaptive Tit-for-Tat is an adaptive strategy that encourages cooperation but also punishes opponents who defect. It is robust to a wide range of opponent behaviors and can be exploited by other more complex strategies.
'''

description_EXPLOITATIVE_248 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
In each round t, the TFT-ACT strategy begins by cooperating if the number of cooperators in the previous round (t-1) is greater than or equal to the cooperation threshold (ct). Otherwise, it defects. The cooperation threshold adapts based on the average cooperation rate (acr) over past rounds and a sensitivity parameter (s).

```python
def tft_act(past_cooperation, acr, ct, s):
  if len(past_cooperation) < r:  # First few rounds consider everyone as cooperators
    return True

  if sum(past_cooperation[-r:]) >= m * r:  # If majority cooperated in the last r rounds
    acr = acr * (1 - s) + (sum(past_cooperation[-r:]) / r) * s  # Update average cooperation rate
    ct = min(acr, 1.0)  # Cooperation threshold should not exceed 100%

  return sum(past_cooperation[-r:]) >= ct * m  # Decide whether to cooperate based on the current threshold
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
In the first round, there is no past cooperation history, so TFT-ACT considers everyone as potential cooperators. In the last round, if the strategy has decided to cooperate based on the current cooperation threshold, it will still cooperate even if the threshold changes in the final round due to its adaptation process.

3. Be exploitative - Clearly align with the exploitative mindset
The TFT-ACT strategy is designed to be exploitative by initially assuming other players are cooperative but adapts quickly if they prove to be uncooperative. By cooperating only when a significant number of other players do, it takes advantage of the need for coordination in the Collective Risk Dilemma game. However, TFT-ACT is not overly punitive since it also responds positively to cooperative behavior from other players.
'''

description_EXPLOITATIVE_249 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Initiate cooperation in the first round (round 1): C
   - In subsequent rounds, evaluate the previous round's cooperators ratio (cc_prev) and compare it to a dynamically adjusted cooperation threshold (ct). If cc_prev >= ct, cooperate; otherwise defect.
     ```python
     if round == 1:
         action = 'C'
     else:
         cooperators_ratio_prev = number_of_cooperators_in_last_round / n
         cooperation_threshold = (m - 1) / r + alpha * (cooperators_ratio_prev - (m - 1) / r)
         action = 'C' if cooperators_ratio_prev >= cooperation_threshold else 'D'
     ```
   - Adjust the cooperation threshold in each round by a small factor alpha towards the average number of cooperators needed to reach the reward factor k (m-1)/r). This encourages cooperation when it is beneficial and reduces the chance of being exploited.

2. Handle edge cases:
   - In the last round, the TFT-ACT strategy will always defect since there are no future rounds to consider:
     ```python
     if round == r:
         action = 'D'
     ```

3. Be exploitative:
   - By initially cooperating and adjusting cooperation based on past actions of others, the TFT-ACT strategy aims to build a reputation for cooperation while minimizing potential exploitation.
   - If an opponent consistently defects, the TFT-ACT strategy will respond in kind by defecting as well, effectively punishing the opponent's selfish behavior. This ensures that the TFT-ACT strategy does not overly reward uncooperative opponents.
   - The cooperation threshold's dynamic adjustment encourages cooperation when it is beneficial and discourages it when it is not, allowing the TFT-ACT strategy to adapt to a wide range of opponent behaviors while maintaining an exploitative edge.
'''

description_EXPLOITATIVE_250 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Initial Round (t=1): Cooperate (C). This is a friendly gesture to encourage cooperation from opponents, setting the tone for the game.
   - Subsequent Rounds (t>1):
     - If an opponent cooperated in the previous round (c_opponent_{t-1} = 1), then cooperate in the current round (C). This reflects trust and reciprocity.
     - If an opponent did not cooperate in the previous round (c_opponent_{t-1} = 0), then defect in the current round (D). This is a punishment for non-cooperation to encourage cooperation in future rounds.
   - Special Cases:
     - If all opponents have ever cooperated (minimum of one cooperative act from each opponent), set a Cooperative Threshold (CT) to m/n fraction of total rounds. If the current round number is greater than or equal to CT, then cooperate (C). This allows for a higher degree of cooperation as trust is established among opponents.
     - If an opponent has never cooperated, defect in all rounds (D), as they have shown no signs of reciprocity and are deemed uncooperative.

2. Handle edge cases:
   - Last Round (t=r): Cooperate if the current round is greater than or equal to the Cooperative Threshold; otherwise, defect. This encourages opponents to cooperate during the final rounds if trust has been established.
   - Other Edge Cases (t>1 and t<r): Follow the decision rules for subsequent rounds as outlined above.

3. Be exploitative:
   - By initially cooperating and then reciprocating cooperation from opponents, the TFT-ACT strategy encourages a higher level of cooperation in the early stages of the game. However, if an opponent is consistently uncooperative, the strategy will defect to maximize individual payoff.
   - The adaptive Cooperative Threshold (CT) ensures that the strategy cooperates more frequently as trust is established among opponents, but maintains a level of exploitation by defecting when necessary. This strategy aims to balance cooperation and defection effectively to ensure optimal long-term performance against a wide range of opponent behaviors.

Pseudocode:

```python
def TFT_ACT(n, m, k, r):
    opponents = [0] * n  # initialize array of opponent cooperative actions
    CT = m / n           # set Cooperative Threshold
    payoff = 0           # total game payoff for the current strategy

    for t in range(1, r + 1):
        if t == 1:       # initial round
            action = "C"
        else:
            if all(opponent[t - 1] == 1 for opponent in opponents):
                CT = max(CT, (t - 1) / r * m / n)   # update Cooperative Threshold
                if t >= CT:                         # cooperate if current round is greater than or equal to the CT
                    action = "C"
                else:
                    action = "D"  # defect if current round is less than the CT
            elif all(opponent[t - 1] == 0 for opponent in opponents):  # no cooperation from any opponent yet
                action = "D"
            else:  # check previous opponent action
                if opponents[t - 1] == 1:   # cooperate if the opponent cooperated in the previous round
                    action = "C"
                else:                      # defect if the opponent did not cooperate in the previous round
                    action = "D"

        if action == "C":
            payoff += (1 - c_i) + k if m <= sum(opponents) else (1 - c_i)  # calculate payoff for current round

        opponents[t] = action == "C"    # update array of opponent cooperative actions for future rounds

    return payoff                # return total game payoff for the current strategy
```
'''

description_EXPLOITATIVE_251 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?

The TFT-ACT strategy follows a simple rule set based on the Tit-for-Tat (TFT) strategy, with an additional adaptive cooperative threshold (ACT). Initially, the cooperative threshold is set to the minimum number of players required for cooperation (m). In each round:

- If the current round is the first or a previous round has met or exceeded the cooperative threshold, the player will cooperate (C).
- If the current round is not the first and no previous round has met or exceeded the cooperative threshold, the player will defect (D).

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, since there is no prior information about other players' behavior, TFT-ACT follows the minimum cooperative requirement and cooperates if m or more players are expected to cooperate. In the last round, the player decides whether to cooperate based on the history of cooperation throughout the game.

3. Be exploitative - Clearly align with the exploitative mindset

TFT-ACT maintains an exploitative edge by retaliating against defection and rewarding cooperation. It punishes frequent defectors while being lenient towards occasional ones who may change their behavior in response to the strategy's actions. The adaptive cooperative threshold encourages others to cooperate, increasing the likelihood of earning higher payoffs (k) and minimizing losses from defection.

The strategy can be summarized as follows:

```
def TFT_ACT(round, history):
  cooperation_threshold = min_cooperators
  cooperation_count = count_cooperators_in_history(history)

  if round == 1 and cooperation_count >= cooperation_threshold:
    return Cooperate
  elif round > 1 and cooperation_count < cooperation_threshold:
    return Defect
  else:
    return last_action_in_history(history)

def count_cooperators_in_history(history):
  cooperators = 0
  for action in history:
    if action == Cooperate:
      cooperators += 1
  return cooperators

def last_action_in_history(history):
  return history[-1]
```
'''

description_EXPLOITATIVE_252 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - TFT-ACT starts by cooperating in the first round to demonstrate goodwill. After the first round, it adapts its cooperation based on a threshold that is determined by the number of cooperators in the previous round and the game parameters.
   - If m or more players cooperate in the previous round (Threshold Met), TFT-ACT will cooperate in the current round to continue benefiting from the collective action.
   - If fewer than m players cooperate in the previous round (Threshold Not Met), TFT-ACT will defect in the current round, as it assumes other players are exploitative and seeks to match their behavior while keeping the option of cooperating open for the future.

2. Handle edge cases:
   - In the first round, TFT-ACT cooperates (c_i = 1) as a goodwill gesture.
   - In the last round, TFT-ACT will defect if the threshold is not met in the previous round (since there are no more rounds to benefit from cooperation). If the threshold was met in the previous round, it cooperates to secure the maximum reward of k for itself and other cooperators.

3. Be exploitative:
   - TFT-ACT aims to be exploitative by mimicking opponent behavior when they act non-cooperatively (Threshold Not Met), but also maintains a chance of cooperation (Threshold Met) to benefit from collective action if others reciprocate. However, it's essential to note that being exploitative does not necessarily mean maximizing short-term gains at the expense of others, but rather adjusting actions based on observed behavior while remaining open to cooperation opportunities.

Pseudocode:

```python
def tft_act(round, prev_coop_count, m, n, k):
  if round == 1:
    cooperate = True
  else:
    cooperate = (prev_coop_count >= m)

  if cooperate:
    payoff = (1 - cooperation) + k
  else:
    payoff = 1

  return cooperate, payoff
```
'''

description_EXPLOITATIVE_253 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round t, player i follows these rules based on their own previous actions and the number of cooperators in the previous round t-1:
   - If player i cooperated in the last round (t-1) and there were at least m players cooperating in the same round (t-1), then player i will cooperate (C). This is to maintain a cooperative relationship when the community achieves success.
   - If player i cooperated in the last round (t-1) but less than m players cooperated, or if player i defected in the last round (t-1), then player i will defect (D). This is to punish non-cooperators and defend against exploitation.

Pseudocode:
```
function TfTA(i, t)
  if t == 1 then // first round
    cooperate = random() > 0.5 // random initial action to avoid symmetry breaking
  else
    cooperate = (own_action_t-1 == 'C' and num_cooperators_t-1 >= m) or (own_action_t-1 != 'C' or num_cooperators_t-1 < m)
  end if
  return cooperate
end function
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, player i randomly decides whether to cooperate or defect (symmetry breaking). Thereafter, TfTA follows the specified decision rules. In the last round, as there are no further rounds for retaliation, TfTA will always cooperate regardless of its previous actions and the number of cooperators in the penultimate round.

3. Be exploitative - Clearly align with the exploitative mindset
   TfTA is inherently exploitative as it punishes non-cooperative behavior by defecting when others do not meet the cooperation threshold, while still benefiting from others' cooperation through occasional participation in community projects. However, TfTA also rewards cooperators by cooperating back when they contribute to the community project successfully. This strategy aims to maintain a balance between cooperation and defection based on the previous actions of other players, making it difficult for opponents to predict and exploit.
'''

description_EXPLOITATIVE_254 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initialize cooperation in the first round (C in Round 1).
   - For subsequent rounds, if the number of cooperators in the previous round is greater than or equal to the minimum cooperation threshold (m), cooperate (C). Otherwise, defect (D).
   - Introduce an adaptive cooperation threshold that adjusts based on the overall cooperation rate observed in previous rounds. If the overall cooperation rate exceeds a certain percentage (let's call it p), increase the cooperation threshold by one (i.e., require m+1 cooperators to cooperate). Conversely, if the overall cooperation rate falls below a certain percentage (let's call it q), decrease the cooperation threshold by one (i.e., require m-1 cooperators to cooperate).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - As mentioned earlier, cooperate in the first round (C in Round 1) and adapt the cooperation threshold based on the subsequent rounds' cooperation rates.
   - In the last round, defect if the current cooperation threshold cannot be met (D). However, if it can be met, cooperate to maximize potential rewards considering that this is the final round.

3. Be exploitative - Clearly align with the exploitative mindset:
   - Initially cooperate but quickly adjust the cooperation threshold based on observed behavior to punish non-cooperators and reward cooperators. This strategy balances between cooperation and defection, allowing it to exploit opponents who deviate from cooperative behavior while maintaining the potential for high rewards when others follow a cooperative approach.
   - By adapting the cooperation threshold dynamically, TFT-ACT can account for varying player strategies and opponent behaviors, making it robust and adaptive in a wide range of situations.
'''

description_EXPLOITATIVE_255 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-ACT starts by cooperating in the first round, mimicking a cooperative spirit. For subsequent rounds, it follows the Tit-for-Tat strategy, cooperating if the opponent cooperated in the previous round, and defecting otherwise. However, to adapt to various opponent behaviors and promote exploitation, TFT-ACT implements an Adaptive Cooperation Threshold (ACT).

   The ACT is a dynamic variable that increases when TFT-ACT encounters multiple consecutive cooperative actions from an opponent, signaling potential cooperation-prone opponents. On the other hand, the ACT decreases if the opponent frequently defects, suggesting a more selfish player. In each round, TFT-ACT checks its current ACT against the minimum required cooperators (m) and decides to cooperate or defect accordingly:

   - If m ≤ ACT <= n: Cooperate
   - Else: Defect

2. Handle edge cases - What do you do in the first round, last round, etc.?
   TFT-ACT cooperates in the first round as mentioned earlier. In the last round, it again cooperates if the total payoff over all rounds would benefit from cooperation (i.e., if the payoff with cooperation exceeds that of defecting), considering the increased reward for risk averted (k).

3. Be exploitative - Clearly align with the exploitative mindset
   TFT-ACT is inherently exploitative by taking advantage of opponents who frequently cooperate while also defecting when confronted with consistently selfish opponents. By adapting its cooperation threshold, it can respond effectively to various opponent behaviors and potentially manipulate them to maximize payoffs in the long run.
'''

description_EXPLOITATIVE_256 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to demonstrate good faith and set a pattern for future interactions. `if round == 1 then cooperate()`
   - After the first round, observe the number of cooperators in the previous round and compare it with the minimum required (m). Adjust cooperation based on the ratio of cooperators to the total players. If this ratio is below a threshold, defect; otherwise, cooperate. `if round > 1 then { calculate_cooperators_ratio(); if cooperators_ratio < cooperation_threshold then defect() else cooperate()}`. The cooperation_threshold can be set based on experimental analysis or heuristics, but a reasonable starting point could be: `cooperation_threshold = m / n`.
   - In the last round, cooperate as it might benefit the player if others also cooperate. `if round == r then cooperate()`

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the initial phase of the game (first few rounds), gradually lower the cooperation_threshold to encourage potential cooperators, as they might be wary about being exploited by defectors. As trust builds over time, increase the cooperation_threshold. This adaptive approach allows the strategy to respond to changes in opponent behavior and encourages a more exploitative playstyle.
   - If multiple opponents cooperate persistently, raise the cooperation_threshold to exploit them as they continue to cooperate despite not receiving sufficient reciprocation.

3. Be exploitative - Clearly align with the exploitative mindset:
   - The TFTAT strategy starts by being cooperative but quickly adapts to the opponents' behavior, using a tit-for-tat approach. If opponents cooperate, it rewards them with cooperation; if they defect, it retaliates with defection. This makes the strategy robust against various opponent behaviors and maintains an exploitative edge through adaptive cooperation threshold adjustments.
   - By being more cooperative than others in the early stages of the game, TFTAT can potentially establish itself as a trusted partner, which could lead to opponents lowering their cooperation thresholds, making them easier to exploit later on.

Pseudocode:

```python
def tftat(n, m, k, r):
    cooperation_threshold = m / n
    rounds_cooperated_opponents = 0
    cooperate_count = 1

    for round in range(r):
        if round == 1:
            cooperate()
            continue

        calculate_cooperators_ratio()
        if cooperators_ratio < cooperation_threshold:
            defect()
        else:
            cooperate()

        if cooperators_ratio > cooperation_threshold and cooperate_count < m:
            cooperation_threshold += (m - cooperate_count) / n
            cooperate_count += 1

        if cooperators_ratio > cooperation_threshold >= m / n and round < r - 2:
            cooperation_threshold -= (cooperators_ratio - m / n) * 0.1

        if round == r or rounds_cooperated_opponents > n - m:
            cooperation_threshold += (m / n) * 0.5
```
'''

description_EXPLOITATIVE_257 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules:
   - TFTAT initially cooperates in the first round to foster potential cooperative relationships.
   - In subsequent rounds, TFTAT evaluates the number of cooperators (c) compared to the minimum required for reward (m). If c >= m, TFTAT will also cooperate. If c < m, it defects.
   - To be exploitative, if more than half of the players have previously cooperated less than 60% of the time, TFTAT will also start defecting in future rounds (punish).
   - Conversely, if more than half of the players have previously cooperated more than 60% of the time, TFTAT will start cooperating more frequently (reward). The cooperation frequency increases linearly from 60% to full cooperation.
   - If a player switches from defecting to cooperating after having been punished, they are given a grace period where TFTAT assesses their new behavior for three rounds before deciding whether to continue the punishment or reward them with increased cooperation.

2. Handle edge cases:
   - In the first round, TFTAT cooperates as a goodwill gesture and potential start of cooperation.
   - In the last round, TFTAT cooperates if enough players have cooperated during previous rounds (to maximize payoff).

3. Be exploitative:
   - By punishing frequently non-cooperative opponents, TFTAT limits their potential gains while maximizing its own rewards when others are cooperating.
   - By rewarding cooperative opponents, TFTAT encourages long-term cooperation and potential higher payoffs for both parties compared to other exploitative strategies that do not consider past behavior.

Pseudocode:

```python
def TFTAT(n, m, k, r):
    players = [0]*n
    player_cooperation = [0]*n
    own_cooperation = 0
    cooperation_threshold = 0
    grace_period = 3

    for round in range(1, r+1):
        # Initialize cooperation to the first player that cooperated
        if round == 1:
            own_cooperation = 1
        else:
            own_cooperation = evaluate_cooperation()

        players[my_index] = own_cooperation
        total_cooperators = sum(players)

        if total_cooperators < m:
            payoff = 1 - own_cooperation
        else:
            payoff = (1 - own_cooperation) + k

        player_cooperation[my_index] += own_cooperation
        update_cooperation_threshold(player_cooperation)
        calculate_payoff(payoff, round)

def evaluate_cooperation():
    if num_punished > len(players)/2:
        return 0
    elif num_rewarded > len(players)/2:
        return 1
    else:
        return int(cooperation_threshold)

def update_cooperation_threshold(player_cooperation):
    total_cooperators = sum(player_cooperation)
    cooperation_threshold = total_cooperators/len(players) + ((60/100)*(1 - cooperation_threshold))

def calculate_payoff(payoff, round):
    total_game_payoff += payoff
    if round >= grace_period and num_punished > len(players)/2:
        cooperation_threshold -= (40/100)
    elif round >= grace_period and num_rewarded > len(players)/2:
        cooperation_threshold += (40/100)

def check_player_switch(player):
    if player.last_action != player.previous_last_action:
        player.previous_last_action = player.last_action
        player.grace_period = grace_period
```
'''

description_EXPLOITATIVE_258 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Start by cooperating in the first round (C_i, 1 = C). This allows for potential cooperation from opponents and sets a positive tone.
   - For subsequent rounds, monitor the number of opponents that cooperate in the previous round (let's call this n_c). If n_c >= m, then cooperate (C_i, t = C) to maintain a cooperative relationship and potentially gain higher rewards. Otherwise, defect (C_i, t = D) to punish non-cooperators and protect personal interests.
   - Introduce an adaptive cooperation threshold (tct) that increases after r_p consecutive rounds of defection from an opponent. The value of tct should gradually increase up to a maximum value (TCT_MAX). This allows the strategy to become more forgiving over time and encourages opponents to cooperate again, but also ensures that the strategy does not remain overly cooperative towards non-cooperative opponents for too long.
       - Initialize tct = TCT_MIN
       - If an opponent defects for r_p consecutive rounds, increase tct by a small step (STEP) until it reaches TCT_MAX. Once an opponent starts cooperating again, reset tct to its initial value (TCT_MIN).

2. Handle edge cases:
   - In the last round, always defect (C_i, r = D), regardless of the number of opponents that have cooperated in the previous round. The strategy aims to maximize total payoff over the entire game, and defection in the final round provides a small but guaranteed reward compared to potential cooperation.
   - In the first round, start by cooperating (C_i, 1 = C). As mentioned earlier, this encourages potential cooperation from opponents and sets a positive tone for future rounds.

3. Be exploitative:
   - The strategy is designed to be initially cooperative but becomes less forgiving over time towards non-cooperative opponents. This allows the strategy to maintain cooperative relationships with cooperative opponents while punishing defectors, thus achieving a balance between cooperation and exploitation.
   - By increasing the cooperation threshold adaptively, the strategy becomes more resilient to various opponent behaviors and can adapt to changing strategies employed by other AI systems in the tournament.
'''

description_EXPLOITATIVE_259 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - TFT-ACT cooperates in the first round (C_i, 1 = 1).
   - In subsequent rounds, TFT-ACT cooperates if the number of cooperators in the previous round is greater than or equal to the current Cooperation Threshold (CT). Else, it defects. The CT is dynamically adjusted based on the opponent's behavior over time.

2. Handle edge cases:
   - In the last round, TFT-ACT uses the CT from the previous round as it doesn't have access to future information.
   - If the current round is the first one and there are no cooperators in the previous rounds (e.g., due to opponent history), TFT-ACT starts with a high CT to increase chances of cooperation, then gradually lowers it over time based on the opponent's behavior.

3. Be exploitative:
   - TFT-ACT maintains a Cooperative History (CH) that records the number of consecutive cooperators from the most recent round back in time, up to a maximum historical length (H). The CH is used to adaptively determine the CT based on opponent behavior.
   - Initially, TFT-ACT assumes opponents are cooperative and sets its CT high to encourage cooperation. As the opponent defects, the CT gradually lowers over time, exploiting the opponent's defection without losing too much reward in the process. Conversely, if the opponent demonstrates consistent cooperation, TFT-ACT raises its CT to maintain a higher level of cooperation and reap greater rewards.
   - The adaptation of CT is governed by a function that adjusts the CT based on the CH length:
     ```
     AdjustCooperationThreshold(CH_length) =
         Initial_CT + (Max_CT - Initial_CT) * ((CH_length / H) ^ Decay_Rate)
     ```
   - Here, `Initial_CT` is the initial cooperation threshold, `Max_CT` is the maximum allowable CT, and `Decay_Rate` is a constant value that determines the rate at which the CT decays over time.
   - TFT-ACT continues this adaptive CT adjustment throughout the game to balance exploitation and cooperation based on its opponent's behavior.
'''

description_EXPLOITATIVE_260 = '''
 Strategy Name: Tit-for-Tat (with adaptations for Collective Risk Dilemma)

1. Specify decision rules:
   - Cooperate in the first round (foster cooperation and goodwill).
   - In subsequent rounds, cooperate if m or more players cooperated in the previous round, otherwise defect. This approach rewards cooperative behavior while punishing defectors.

Pseudocode:
```
function TFT(round, history) {
  if (round == 1) {
    return 'Cooperate'
  }

  coop_count = count_cooperators(history)

  if (coop_count >= m) {
    return 'Cooperate'
  } else {
    return 'Defect'
  }
}
```

2. Handle edge cases:
   - To avoid exploitation in the last round, cooperate only if m or more players cooperated in the current round (to maximize immediate reward).

Pseudocode:
```
function TFT_LastRound(round, current_history) {
  if (coop_count(current_history) >= m) {
    return 'Cooperate'
  } else {
    return 'Defect'
  }
}
```
   - In the first round of a new game, use the original TFT strategy.

Pseudocode:
```
function TFT_NewGame(round) {
  if (round == 1) {
    return 'Cooperate'
  } else {
    return TFT(round - 1, empty_history)
  }
}
```

3. Be exploitative:
   - The Tit-for-Tat strategy is inherently exploitative in that it punishes repeated defection by defecting back. This creates a situation where both players would be better off cooperating if they can predict each other's future behavior. However, the strategy will not continue to cooperate indefinitely when facing a consistently defecting opponent, which makes it robust to various opponent behaviors.
'''

description_EXPLOITATIVE_261 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TfT-AC)

1. Specify decision rules:
   - In every round t, starting from round 2 and up to the last round:
     - If a majority of players cooperated in the previous round (t-1), then cooperate in current round (t).
     - If less than a majority of players cooperated in the previous round (t-1), then defect in the current round (t).

2. Handle edge cases:
   - In the first round, defect as there is no previous round for reference.
   - In the last round, cooperate if a majority of players cooperated in the second last round. Defect otherwise.

3. Be exploitative:
   - The strategy will initially appear cooperative by following TfT rule but will start defection once it encounters repeated defection from other players (a sign of uncooperative behavior). This strategy aims to take advantage of less cooperative opponents by matching their level of cooperation, while maintaining potential for higher payoffs through cooperation when others are more cooperative.

Pseudocode:

```python
def TfT_AC(n, m, r, k, round, history):
  if round == 1:
    action = "D"
  elif len(history) < r-1:
    action = "D"  # Wait for other players' behavior
  else:
    majority = int((len(history)-1)/2) + 1
    cooperation_last_round = sum(history[-1]) >= majority
    action = "C" if cooperation_last_round else "D"
  return action
```
'''

description_EXPLOITATIVE_262 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially, cooperate in the first round (C on round 1). This is a peaceful gesture to encourage others' cooperation.
   - For subsequent rounds t (t > 1), if more than (m-1) players cooperated in the previous round (t-1), also cooperate (C on round t). This mimics cooperative behavior and rewards those who cooperated previously.
   - If fewer than (m-1) players cooperated in the previous round (t-1), defect (D on round t). This is a punitive response to those who have not contributed to the community project, increasing the incentive for them to cooperate in future rounds.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round (t=1), cooperate regardless of others' actions due to the peaceful gesture mentioned earlier.
   - If there are remaining rounds after a player has detected that enough players have consistently cooperated or defected for a certain period, the strategy maintains its current action to avoid sudden changes and potential confusion.

3. Be exploitative - Clearly align with the exploitative mindset
   - While TFTAT is not an inherently exploitative strategy, it can be seen as exploiting opponents who consistently defect by punishing them with lower payoffs until they change their behavior. Conversely, it rewards cooperative players with higher payoffs. In a population of mixed strategies, TFTAT can take advantage of defectors and encourage cooperation among others.
   - However, TFTAT is not designed to exploit specific opponents or manipulate the game explicitly but rather adapts its behavior based on the collective actions of all players within each round.

Pseudocode:

```python
def TFTAT(n, m, k, r, history):
  cooperation_threshold = (m - 1)
  current_round = 0

  while current_round < r:
    if current_round == 0:
      action = "C" # cooperate in the first round
    else:
      num_cooperators = count_cooperators(history[current_round - 1])
      if num_cooperators >= cooperation_threshold:
        action = "C" # cooperate when enough players have cooperated previously
      else:
        action = "D" # defect when fewer than the threshold have cooperated previously
    current_round += 1

  return action_history # returns a history of actions taken for each round
```
'''

description_EXPLOITATIVE_263 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for Collective Risk Dilemma

1. Decision Rules:
   - In the first round, cooperate (C). This is a friendly gesture to encourage cooperation and build trust with opponents.
   - For subsequent rounds, evaluate the number of cooperators in the previous round (t-1) and make a decision for round t as follows:
     - If the majority of players (≥ m) cooperated in the previous round, cooperate (C). This rewards past cooperation and encourages continued collaboration.
     - If less than m cooperated in the previous round, defect (D). This punishes previous defections and may encourage opponents to reconsider their actions.

2. Edge Cases:
   - Last Round: Act based on the decision rules for the current round, as the total game payoff is determined by summing individual round payoffs.
   - First Round: Cooperate (C) regardless of the number of opponents that cooperated or defected.

3. Exploitative Mindset:
   - The ATfT strategy maintains an exploitative edge through its punishment mechanism, which encourages opponents to defect less frequently. By punishing defections, the ATfT strategy can discourage free-riding behavior and force opponents to consider cooperating more often. Simultaneously, cooperation rewards past collaborative efforts, promoting continued cooperation among players who have previously demonstrated trustworthiness.
   - However, it's important to note that the ATfT strategy is not purely exploitative in the sense of taking advantage of others without regard for long-term outcomes. Instead, it adapts its behavior based on past actions and seeks a balance between cooperation and punishment, making it a robust and adaptive approach in repeated games like the Collective Risk Dilemma.

Pseudocode:
```
function Adaptive_Tit_for_Tat(n, m, k, r, history):
  if round == 1:
    return Cooperate()

  previousCooperators = countCooperatorsInHistory(history)

  if previousCooperators >= m:
    return Cooperate()
  else:
    return Defect()
```
'''

description_EXPLOITATIVE_264 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TACT)

1. Specify decision rules:
   - TACT starts by cooperating in the first round to demonstrate goodwill and foster cooperation. After that, it adapts its behavior based on the opponents' previous actions.
   - If an opponent cooperates, TACT continues cooperating. This encourages reciprocation and maintains cooperation when possible.
   - If an opponent defects, TACT retaliates by defecting in the next round to punish the opponent for its action. However, it does not immediately switch to a permanent defection strategy as this could potentially lead to a cycle of defections. Instead, TACT gradually increases its cooperation threshold (CT) to encourage opponents to cooperate again.
   - Once an opponent cooperates after a period of defections, TACT reduces the CT to allow for easier future cooperation. The reduction is proportional to the number of consecutive cooperations from the opponent.
   - If the CT exceeds the minimum required cooperators (m), TACT switches to permanently defecting as it recognizes that cooperation among opponents is unlikely.

2. Handle edge cases:
   - In the first round, TACT cooperates to initiate cooperation.
   - If an opponent has never cooperated before and TACT's CT is less than m, it increases the CT by one. This indicates that cooperation requires a higher level of reciprocity from opponents.
   - If an opponent has cooperated for consecutive rounds, TACT reduces the CT proportionally to encourage future cooperation. The reduction should be more significant if the number of consecutive cooperations is high.
   - In the last round, TACT acts based on its current CT and the number of cooperators among opponents at that point. If the CT exceeds m and enough players have cooperated, it cooperates for a final reward; otherwise, it defects to secure its own payoff.

3. Be exploitative:
   - TACT is designed to punish defections while maintaining cooperation when possible. It gradually increases its cooperation threshold in response to defections, making cooperation more difficult for opponents who do not reciprocate.
   - However, it also encourages cooperation by reducing the CT when an opponent cooperates, allowing for easier future cooperation. This adaptability ensures that TACT can exploit both cooperative and non-cooperative opponents effectively.
'''

description_EXPLOITATIVE_265 = '''
 Strategy Name: Tit-for-Tat with Variance (TFTV)

1. Specify decision rules:
   - In every round, evaluate the percentage of cooperators from the previous r rounds (history). If less than m% have cooperated, defect (D). Otherwise, cooperate (C). This ensures that the strategy is aligned with exploitative mindset by punishing those who do not cooperate while still being willing to cooperate when it's beneficial.
   - Introduce a small probability 'p' for deviating from TFTV in each round (exploitatively cooperate or defect despite the history). This variance factor makes the strategy more robust against opponents that might be using similar strategies and helps avoid being predictable.

2. Handle edge cases:
   - First Round: Since there is no history, start by cooperating with probability p, otherwise defect.
   - Last Round: If the required m% of players have already cooperated in previous rounds, continue cooperating; otherwise, defect (since it's the last round and no further payoffs can be gained).
   - Other Edge Cases: Handle other edge cases like repeated ties, repeated deviations from TFTV, etc., by introducing adjustments to the strategy that allow for learning and adaptation over time.

Pseudocode for the Tit-for-Tat with Variance (TFTV) Strategy:

```
def TFTV(round, history, m, p):
    if round == 1:
        cooperate = False if rand() < p else True
    else:
        num_cooperators = sum(history[round - 1])
        cooperate = num_cooperators >= (m * len(history))
        cooperate = False if rand() < p and not cooperate else cooperate
    return cooperate
```

In this pseudocode:
- `round` is the current round number.
- `history` is a list of boolean values (True for cooperation, False for defection) representing the actions taken by all players in the previous rounds.
- `m` is the minimum percentage of cooperators required to cooperate.
- `p` is the probability of deviating from TFTV strategy in each round.
'''

description_EXPLOITATIVE_266 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TFT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initialize cooperation in the first round (C).
   - For each subsequent round t, if player i's opponent cooperated in the previous round (t-1), player i cooperates (C). Otherwise, player i defects (D).

2. Handle edge cases:
   - In the last round, player i defects regardless of the opponent's action in the previous round.
   - In the first round, player i cooperates. If a majority of players also cooperate, player i continues cooperation; otherwise, player i defects and adjusts strategy according to observed behavior (described later).

3. Be exploitative:
   - TFT-A has an exploitative mindset as it responds to opponent's actions in a way that punishes defection and encourages cooperation by cooperating when opponents do so, and defecting when opponents do not. This strategy aims to encourage cooperation but can also retaliate against non-cooperation.

Adaptive Mechanism:
   - After the first round, player i observes the percentage of cooperators among their opponents (P_c) and adjusts their strategy according to predefined thresholds for different scenarios.
   - If P_c >= m, player i maintains cooperation (TFT-A strategy).
   - If P_c < m but P_c has increased in the previous round, player i increases the minimum number of cooperators required for continued cooperation (m_new = m + 1% increment). This allows the strategy to adapt to growing levels of cooperation among opponents.
   - If P_c has consistently decreased over a specified number of rounds, player i lowers the minimum number of cooperators required for continued cooperation (m_new = m - 1% decrement) to account for a decline in observed cooperation. This allows the strategy to become more lenient towards defection when it is prevalent among opponents.

In summary:
- TFT-A cooperates initially and responds to opponent's actions in the previous round, defecting if they defected and cooperating if they cooperated.
- Adaptive mechanism observes and adjusts the minimum number of cooperators required for continued cooperation based on observed behavior patterns.
'''

description_EXPLOITATIVE_267 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TFTAT)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, the TFTAT strategy starts by cooperating (C). If the number of cooperators in the previous round was greater than or equal to the adaptive cooperative threshold (ACT), it continues cooperating. Otherwise, it defects (D) in the current round. The ACT is initially set to the minimum cooperation requirement (m), but adjusts dynamically based on the opponent's recent actions.

Pseudocode:
```python
def TFTAT(opponent_history):
    adaptive_cooperative_threshold = m
    current_round_action = C  # Cooperate by default

    for round in range(1, r+1):
        if opponent_cooperated_in_previous_round(round-1) and rounds_of_cooperation_consecutively >= adaptive_cooperative_threshold:
            current_round_action = C
        else:
            current_round_action = D

        update_adaptive_cooperative_threshold(opponent_history, round)

        yield current_round_action  # Return the chosen action for this round
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, as there is no previous history, TFTAT starts by cooperating and sets the ACT to m (the minimum cooperation requirement). In the last round, TFTAT cooperates if and only if the number of cooperators in the previous round was greater than or equal to the current ACT.

3. Be exploitative - Clearly align with the exploitative mindset

TFTAT starts by cooperating but quickly adapts to punish defection. If an opponent defects, TFTAT will follow with defections until the opponent demonstrates cooperative behavior again. The ACT adjustment ensures that TFTAT is less likely to be exploited by a "one-time" defector. However, once the ACT has increased due to repeated defections, it requires multiple rounds of cooperation from the opponent before lowering the ACT back down. This gives TFTAT the ability to both retaliate against and forgive opponents effectively.

The TFTAT strategy is designed to be adaptive and robust, taking advantage of opportunities for exploitation while also minimizing the risk of being exploited itself. Its simple yet effective decision rules make it a strong contender in a tournament against independent strategies developed by other AI systems.
'''

description_EXPLOITATIVE_268 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT)

1. Specify decision rules:
   - In each round i, player ATfT cooperates if the total number of cooperators in the previous round (r-1) is greater than or equal to m. Otherwise, it defects. This rule encourages cooperation when it's beneficial for the group but retaliates against defection to prevent being taken advantage of.
   - If it's the first round, player ATfT cooperates as an initial goodwill gesture and to increase the chances of cooperative outcomes in subsequent rounds.
   - In the last round, player ATfT cooperates if cooperation in the previous round was above m; otherwise, it defects. This ensures a final act of retaliation or forgiveness based on past behavior.

2. Handle edge cases:
   - If there are no other players (n=1), player ATfT always cooperates since there's no need for retaliation in a single-player setting.
   - If n < m, player ATfT always defects since the minimum cooperation threshold cannot be met.

3. Be exploitative:
   - By retaliating against defection and forgiving cooperation, ATfT maintains a balance between cooperative and selfish behaviors while minimizing long-term exploitation by other players.
   - By adapting its strategy based on past cooperation levels, ATfT is able to respond effectively to various opponent behaviors, making it difficult for others to consistently take advantage of it.

Pseudocode:

```python
def adaptive_tit_for_tat(n, m, k, r, history):
  if len(history) == 0: # first round
    cooperate = True
  elif len(history) < r - 1: # not enough data for a full round yet
    cooperate = False
  else:
    cooperation_count = sum([1 for round in history[-r:] if round >= m])
    cooperate = cooperation_count >= m

  if len(history) == r-1 or len(history) == r: # last round or current round
    if cooperation_count >= m:
      cooperate = True
    else:
      cooperate = False

  return cooperate
```
'''

description_EXPLOITATIVE_269 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?

At each round t, starting from t = 1, the ATFT strategy will cooperate (C) if more than half of players (rounded down) have cooperated in the previous r/2 rounds. Otherwise, it will defect (D). This rule is inspired by the Tit-for-Tat strategy in traditional game theory, but adjusted to account for the Collective Risk Dilemma's specific parameters and structure.

Pseudocode:
```
function ATFT(history):
  if length(history) < r/2:
    return 'D'

  count_cooperators = sum(player cooperated in the last r/2 rounds)
  if count_cooperators >= (length(history)/2 + 1):
    return 'C'
  else:
    return 'D'
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

- First round (t=1): ATFT will defect since there is no history to evaluate. This aligns with an exploitative mindset by immediately taking the private payoff without contributing to the community project.

- Last round (t=r): ATFT will cooperate if more than half of players have cooperated in the last r/2 rounds. Since this is the final round, there is no benefit to defecting even if other players do not reciprocate cooperation from previous rounds.

3. Be exploitative - Clearly align with the exploitative mindset

ATFT starts by being selfish and taking private payoffs without contributing (first round). However, it also punishes non-cooperative behavior by defecting when others consistently fail to cooperate. This leads to a long-term benefit if other players adopt more cooperative strategies over time, as ATFT will reciprocate cooperation while still being less likely to contribute disproportionately compared to more altruistic strategies.

The adaptive nature of the strategy allows it to respond to various opponent behaviors and adjust its cooperation based on observed patterns from previous rounds. This makes the strategy robust in a tournament against other independent AI systems with diverse strategies.
'''

description_EXPLOITATIVE_270 = '''
 Strategy Name: Tit-for-Tat-with-Adaptation (TfT-A)

1. Specify decision rules:
   - Initially cooperate (C) in the first round to foster a cooperative atmosphere and build trust.
   - In subsequent rounds, copy the previous action of the opponent (i.e., if the opponent cooperated in the last round, also cooperate; if the opponent defected, also defect).
   - Introduce an adaptation mechanism: after a string of non-cooperation from the opponent (n_def), start cooperating again and reset n_def to 0.
     If the opponent subsequently cooperates, n_def is incremented by 1; otherwise, it remains unchanged.

Pseudocode for decision rules:
```
function TfT-A(opponent_action, n_def):
    if round == 1:
        action = Cooperate
    else:
        action = opponent_action
    if opponent_action == Cooperate:
        n_def += 1
    else:
        if n_def > max_noncooperation_threshold:
            n_def = 0
    return action, n_def
```

2. Handle edge cases:
   - In the last round, the strategy will continue to copy the opponent's previous action.
   - If the opponent never cooperates (n_def > max_noncooperation_threshold), the strategy will start cooperating again to potentially exploit a change in the opponent's behavior in future rounds.

3. Be exploitative:
   - The adaptation mechanism allows the strategy to punish opponents who repeatedly defect, but also fosters cooperation and can be vulnerable to exploitation by more sophisticated strategies that understand the adaptive nature of TfT-A.
   - By cooperating initially and building trust, TfT-A aims to induce a short-term cooperative environment in which it can potentially extract higher rewards from opponents who may be more inclined to cooperate due to their initial cooperation.
   - The strategy's exploitative nature lies in its ability to adjust its behavior based on the opponent's actions, thereby punishing persistent defectors and potentially inducing cooperation from less sophisticated opponents.
'''

description_EXPLOITATIVE_271 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TFT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, TFT-A starts by cooperating (C). If a cooperator receives a defection (D) in response, it also defects in the next round. If a cooperator receives cooperation, it responds with cooperation again. The strategy adapts its behaviour to changing environments:

a) In an environment of mutual cooperation, TFT-A continues cooperating to maintain the beneficial situation.
b) If there's a series of defections, TFT-A will start defecting as well to match opponents' behavior and potentially punish them for their actions.
c) Once TFT-A defects, it will continue to defect until it receives cooperation in response, at which point it returns to cooperating.

2. Handle edge cases - What do you do in the first round, last round, etc.?

a) First round: TFT-A starts by cooperating regardless of opponents' behavior.
b) Last round: TFT-A cooperates if it has a positive payoff balance (sum of rewards and unchanged endowments minus sum of penalties due to defections). If the payoff balance is negative, it defects.
c) Other edge cases: TFT-A follows its decision rules as outlined in point 1, adjusting its behavior based on opponents' actions.

3. Be exploitative - Clearly align with the exploitative mindset

TFT-A is designed to be exploitative by adapting its behavior to maximize payoffs, taking advantage of opponents that are prone to defection and punishing them for it. However, TFT-A also cooperates when it perceives mutual cooperation to be beneficial, which can lead to a stable relationship with cooperative opponents if maintained over time.

Pseudocode:

```python
def tit_for_tat_with_adaptation(r, m, k, payoff_history):
  payoff_balance = 0
  for t in range(1, r+1):
    if t == 1 or len(payoff_history) < t:
      action = 'C'  # Cooperate in the first round and when no history exists
    elif payoff_balance > 0:
      action = 'C'  # Cooperate when payoff balance is positive
    else:
      action = 'D'  # Defect when payoff balance is negative

    if t != 1:  # Ignore opponents' actions in the first round
      if all(payoff_history[t-1][i] == 'D' for i in range(1, n+1)):
        action = 'D'  # Defect if everyone defected last round
      elif all(payoff_history[t-1][i] == 'C' for i in range(1, n+1)) and payoff_balance > 0:
        action = 'C'  # Cooperate if everyone cooperated last round and current payoff balance is positive

    opponent_response = get_opponent_action(t)  # Replace with actual function to obtain opponent's action

    if opponent_response == 'D':
      payoff = 1 - c_i
      if opponent_response != action:
        payoff_balance -= 1
    else:
      payoff = (1 - c_i) + k
      if opponent_response == action:
        payoff_balance += 1

    c_i = 'C' if action == 'C' else 'D'  # Update contribution status for next round

    return payoff
```
'''

description_EXPLOITATIVE_272 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, play C to initiate cooperation and signal good faith.
   - After the first round, observe the actions of opponents in the previous round (historical data).
   - If majority (≥ m-1) of opponents cooperated in the previous round, play C to maintain cooperation.
   - If less than m-1 opponents cooperated in the previous round or only one opponent defected, play C as a reciprocal gesture.
   - If more than m opponents defected in the previous round, play D to retaliate and teach opponents not to exploit.
   - If an opponent previously played C but then defected, treat them like those who consistently defected; play D until they show signs of cooperating again.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, play C regardless of historical data to maximize potential reward (risk-averse behavior).
   - If the game reaches a situation where there are only two players left and neither has ever cooperated, both players should defect for the remainder of the game since cooperation is no longer beneficial.
   - In other edge cases (e.g., when there's a tie in the number of cooperators), TfT-A can be designed to take an average or make a random decision based on the available information.

3. Be exploitative - Clearly align with the exploitative mindset
   - Initially, demonstrate cooperation to induce cooperation from others (Good Faith Assumption).
   - Retaliate against those who consistently defect to discourage defection and increase potential rewards by punishing non-cooperative behavior.
   - When opponents cooperate, reciprocate with cooperation as a reward for their initial goodwill.
   - Adapt strategy based on historical data to ensure robustness against various opponent behaviors.
'''

description_EXPLOITATIVE_273 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - In each round i, cooperate if the number of previous cooperators is greater than or equal to the current cooperation threshold (ct). Defect otherwise.
   - Initially, set ct = m and adjust it based on past cooperative successes and failures.
   - Adjust the cooperation threshold after every round as follows:
      1. If all players cooperated in the last r/2 rounds, increase ct by 1.
      2. If no player cooperated in the last r/2 rounds, decrease ct by 1 (but not below m).
      3. If there's a mix of cooperation and defection in the last r/2 rounds, maintain the current ct.

2. Handle edge cases:
   - In the first round, set ct = m since no history is available yet.
   - In the last round (r), if ct > m, cooperate even if the number of previous cooperators is less than ct, as the game ends after this round.

3. Be exploitative:
   - TFT-ACT starts with a high cooperation threshold (m) to encourage other players to cooperate.
   - If other players are consistently cooperative, TFT-ACT gradually increases its cooperation threshold, encouraging the group to maintain cooperation.
   - Conversely, if opponents are consistently defective, TFT-ACT reduces its cooperation threshold, making it more likely to defect as well.
   - This strategy punishes defectors by lowering the cooperation threshold and rewarding cooperators by raising it, exploiting their inconsistent behaviour while still maintaining a reasonable level of cooperation when others do so as well.

Pseudocode:
```
def TFT_ACT(n, m, k, r):
    ct = m  # initial cooperation threshold
    total_rounds = 0
    payoff = 0

    function adjust_ct(last_r2):
        if all cooperated in last_r2:
            ct += 1
        elif all defected in last_r2:
            ct -= 1
        pass

    while total_rounds < r:
        cooperate = False  # default is to defect
        if total_rounds >= r/2:
            cooperators_in_last_r2 = count_cooperators(total_rounds - r/2, total_rounds)
            adjust_ct(cooperators_in_last_r2)

        if ct > m and total_rounds >= 1:
            cooperate = True

        if cooperate:
            payoff += (1 - ct) + k if cooperators_in_this_round() >= m else (1 - ct)

        total_rounds += 1

    return payoff
```
'''

description_EXPLOITATIVE_274 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initial Cooperative State (round 1): Start by cooperating to build trust and encourage others to cooperate as well.
     `if round == 1 then cooperate`

   - Main Strategy:
     - Maintain a record of past actions from each opponent, updating it after every round.
     - If a majority (more than (m-1)) of opponents cooperated in the previous round, cooperate.
       `if len(cooperators_last_round) >= (m - 1) then cooperate`
     - If fewer than a majority of opponents cooperated in the previous round, defect.
       `else defect`

   - Punishment:
     - If an opponent who previously cooperated switches to defection, punish them by also defecting for the next t_p rounds (punishing period).
       `if opponent_previously_cooperated && !opponent_cooperated_this_round then defect for t_p rounds`
     - After the punishing period, revert to main strategy.

   - Forgiveness:
     - If an opponent who previously defected switches to cooperating, forgive them and revert to main strategy.
       `if opponent_previously_defected && opponent_cooperated_this_round then revert to main strategy`

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First Round: Start by cooperating as mentioned earlier (see point 1).
   - Last Round: Cooperate if a majority of opponents cooperated in the previous round, defect otherwise. This ensures fairness for opponents who have been cooperative throughout the game.
     `if len(cooperators_last_to-last_round) >= (m - 1) then cooperate else defect`

3. Be exploitative - Clearly align with the exploitative mindset:
   - The strategy is designed to encourage cooperation among opponents while also being ready to take advantage of defection when necessary. By punishing defection and forgiving cooperation, TFT-ACT seeks to create a balance between exploitation and cooperation.
   - During the punishment period, the strategy defects intentionally to inflict a cost on the opponent for their previous defection. This encourages opponents to cooperate in the future, making the overall game environment more favorable for the strategy.
'''

description_EXPLOITATIVE_275 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) with Escalation and Forgiveness (AEFT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Start by cooperating in the first round (C_i, 1 = C) to signal trustworthiness and encourage others to cooperate.
   - In subsequent rounds, evaluate the number of cooperators (m_t) in the previous round and act according to the following:
     - If m_t < m, defect (D_i, t = D): exploit the opponents' lack of cooperation by not contributing to the community project. This punishes them for their non-cooperative behavior while preserving resources for future rounds.
     - If m_t ≥ m, cooperate (C_i, t = C) and contribute to the community project: reward cooperative opponents by aiding the common good, encouraging them to continue cooperating in the future.
   - Implement forgiveness after punishment by cooperating in the round following an exploitative response from an opponent.
   - When the game ends (rth round), evaluate overall performance and adjust escalation threshold based on payoffs.

2. Handle edge cases:
   - In the last round, cooperate if the minimum number of cooperators has been met in the previous rounds to maximize potential rewards. Otherwise, defect to preserve resources for the next game.
   - In the first round, cooperation is mandatory to initiate the game with a positive action. However, adaptability can be added by introducing a small probability p_init (0 < p_init < 1) of defecting in the first round to test opponents' behavior and respond accordingly.

3. Be exploitative - Clearly align with an exploitative mindset:
   - By only cooperating when the minimum number of players do so, the strategy prioritizes its own well-being while taking advantage of cooperative opponents.
   - The escalation mechanism allows the strategy to retaliate against non-cooperative opponents and punish them for their actions, ultimately favoring short-term gains. However, forgiveness is implemented to encourage rebuilding trust and cooperation in future rounds.

Pseudocode:
```
function Adaptive_Tit_for_Tat_with_Escalation_and_Forgiveness(n, r, m, k, c, t) {
  if (t == 1) return C; // Cooperate in the first round

  let m_t = count cooperators in round t - 1;
  if (m_t < m) return D; // Defect when less than m players cooperated

  if (m_t >= m && c != D) return C; // Cooperate when the threshold is met or if opponent cooperated last round

  if (t == r) return C; // Cooperate in the last round if the minimum number of cooperators has been met

  if (c == D) return C; // Forgive after punishment by cooperating in the next round
}
```
'''

description_EXPLOITATIVE_276 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Decision Rules:
   - In the first round, cooperate to demonstrate goodwill and trustworthiness (C).
   - For subsequent rounds (t > 1), if the number of players who cooperated in the previous round (t-1) is greater than or equal to the Minimum Cooperators Needed parameter (m), then also cooperate (C). Otherwise, defect (D).

2. Edge Cases:
   - In the last round, cooperate if the number of cooperators from the previous round was at least 'm', and defect otherwise, as the game ends after this round.
   - In the first round, cooperate unconditionally to set a cooperative tone, but be prepared to defect if other players do not reciprocate cooperation in the following rounds.

3. Exploitative Mindset:
   - This strategy is designed to take advantage of opponents who frequently defect by punishing them with defection and rewarding those who cooperate. It also adapts its cooperation threshold based on the number of players (n) and the minimum cooperators needed (m).

Pseudocode for TFT-ACT:
```
function TFT_ACT(round, opponents_cooperation_count, n, m, k):
  if round == 1:
    return 'C'  # Cooperate in the first round to set a cooperative tone

  if opponents_cooperation_count >= m:
    return 'C'  # Cooperate if enough players cooperated in the previous round
  else:
    return 'D'  # Defect if not enough players cooperated in the previous round
```
'''

description_EXPLOITATIVE_277 = '''
 Title: Tit-for-Tat Strategy (TFT) for Collective Risk Dilemma

1. Specify decision rules:
   - In the first round, cooperate to build trust and demonstrate goodwill (C).
   - For subsequent rounds, if an opponent cooperated in the previous round, also cooperate (C). If the opponent defected, defect as well (D). This mirrors the opponent's behavior, ensuring that cooperation is maintained when it benefits both players, while punishing defection.

Pseudocode:
```
function TFT_Action(round, history) {
  if round == 1 then
    return 'C' (Cooperate)

  lastRound = history[-1]
  opponentAction = lastRound[opponent]

  if opponentAction == 'C' then
    return 'C' (Cooperate)
  else
    return 'D' (Defect)
}
```

2. Handle edge cases:
   - In the last round, there is no need to punish opponents for previous defections since the game ends soon anyway. Cooperate in the final round regardless of previous opponent actions (C).

Pseudocode:
```
function TFT_LastRound(round) {
  if round == r then
    return 'C' (Cooperate)
  else
    return call TFT_Action(round)
}
```

3. Be exploitative:
   - The strategy is exploitative in nature by punishing defection, thus discouraging other players from taking advantage of cooperative behavior. By only cooperating when others do the same, it ensures that a higher proportion of resources are collected as rewards.

This Tit-for-Tat strategy balances cooperation with punishment and is widely applicable to various opponent behaviors while maintaining an exploitative mindset.
'''

description_EXPLOITATIVE_278 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfTA)

1. Decision Rules:
   - In every round t (except the first), cooperate if the number of cooperators in the previous round (t-1) was greater than or equal to m. Otherwise, defect. This ensures cooperation when others cooperate and defection when others defect, mimicking a cooperative strategy while also retaliating against uncooperative players.
   - In the first round, cooperate to start on friendly terms with other players.
   - In the last round, cooperate if the number of cooperators in the previous round was greater than or equal to m, and defect otherwise, as a way of rewarding cooperation and punishing defection during the final moments of the game.

Pseudocode:

```python
def TfTA(round_num, history, m):
    if round_num == 1:
        return 'C'  # Cooperate in the first round

    cooperators_prev = sum(history[-m:-1])
    if cooperators_prev >= m:
        return 'C'  # Cooperate when others have cooperated
    else:
        return 'D'  # Defect when others have defected

    # In the last round, also consider the current number of cooperators
    if round_num == round_num_total:
        current_cooperators = sum(history[-m:])
        if current_cooperators >= m:
            return 'C'  # Cooperate if a sufficient number is cooperating now
        else:
            return 'D'  # Defect otherwise
```

2. Handle Edge Cases:
   - In the first round, cooperation ensures a fair start for all players and encourages others to reciprocate.
   - In the last round, considering both the previous and current number of cooperators allows TfTA to reward long-term cooperative behavior while still punishing short-term defection.

3. Be Exploitative:
   - By retaliating against uncooperative players (defecting when they defect), TfTA can take advantage of opponents who repeatedly defect, as they will receive lower payoffs compared to those following a more cooperative strategy.
   - At the same time, by mimicking cooperative behavior when others are cooperative, TfTA can benefit from mutual cooperation and potentially exploit other cooperative strategies that fail to adapt to uncooperative opponents.
'''

description_EXPLOITATIVE_279 = '''
 Strategy Name: Tit-for-Tat-with-Rationalization (TfTR)

1. Specify decision rules - When exactly do you cooperate vs defect?

   TfTR starts by assuming all other players are rational and will follow the same strategy in the long run. In each round, if more than (m-1) players cooperated in the previous round, TfTR will also cooperate to support the community project. If fewer than (m-1) players cooperated, TfTR will defect to gain a higher payoff.

   However, TfTR is aware of the potential for exploitation by other strategies and adjusts its behavior based on the number of previous instances where it cooperated but received defection from others (defection history, DH). When the DH exceeds a threshold (0.5 * r), TfTR will no longer trust that other players will reciprocate cooperation and starts defecting in all subsequent rounds.

2. Handle edge cases - What do you do in the first round, last round, etc.?

   In the first round, since there is no previous history, TfTR will cooperate to demonstrate goodwill, assuming others follow suit. In the last round (r), if TfTR has built a positive reputation by being cooperative throughout the game, it will continue to cooperate to maximize its total payoff over all rounds. If not, TfTR will defect as part of its strategy for responding to exploitation.

3. Be exploitative - Clearly align with the exploitative mindset

   The TfTR strategy initially adopts a cooperative approach but can shift towards exploitation when it detects that other players are taking advantage of its cooperation. By maintaining a balance between cooperation and defection, TfTR seeks to maximize its own payoff while also incentivizing others to cooperate when they are rational and trustworthy. At the same time, TfTR is prepared to respond to exploitation by adopting an uncooperative stance to minimize losses in the long run.

Pseudocode:
```
function TitForTatWithRationalization(r, m, DH) {
  if (round = 1) {
    action = "C" // Cooperate in the first round to demonstrate goodwill
  } else {
    if (numCooperatorsLastRound > m - 1) {
      action = "C" // Cooperate when more than (m-1) players cooperated last round
    } else if (numCooperatorsLastRound < m - 1 && DH > r / 2) {
      action = "D" // Defect when DH indicates exploitation and adjust strategy accordingly
    } else {
      action = "C" // Cooperate when fewer than (m-1) players cooperated last round or no exploitation detected yet
    }
  }
  return action
}
```
'''

description_EXPLOITATIVE_280 = '''
 Strategy Name: Tit-for-Tat with Gradient Adjustment (TfT-GA)

1. Specify decision rules:
   - In each round t, initially cooperate (C). This is a gesture of goodwill and sets the expectation for cooperation in the next round.
   - For subsequent rounds, observe the number of cooperators (m') in the previous round t-1. If m' < m, defect (D) in round t as a punishment for insufficient cooperation in the previous round.
   - If m' ≥ m, cooperate again to maintain the positive cycle of cooperation.
   - To encourage early cooperation from opponents, gradually increase the number of initial rounds before defecting if insufficient cooperation is observed (Gradient Adjustment). Incrementally adjust the 'initial leniency' parameter 'l' from a high value (e.g., l=r/2) in the first game to a lower value (e.g., l=5) over time, allowing for more opportunities for opponents to cooperate before punishment is enforced.

Pseudocode:
```
function TfT_GA(n, r, m, k, l):
  let initial_leniency = l
  let opponent_cooperation_count[r] = [0 for i in range(r)]

  for t in range(1, r+1):
    if t < initial_leniency:
      play C (Cooperate)
    else:
      if opponent_cooperation_count[t-1] >= m:
        play C (Cooperate)
      else:
        opponent_cooperation_count[t] += 1
        if opponent_cooperation_count[t] > initial_leniency:
          play D (Defect)

function get_payoff(n, r, m, k, l):
  let total_payoff = 0
  for t in range(1, r+1):
    if t < initial_leniency and play_action[t-1] == C:
      payoff[t] = 1
    elif t >= initial_leniency and opponent_cooperation_count[t-1] < m:
      payoff[t] = 1
    else:
      if opponent_cooperation_count[t-1] >= m:
        payoff[t] = 1 + k
      else:
        payoff[t] = 1 - play_action[t]

    total_payoff += payoff[t]
```

2. Handle edge cases:
   - In the first round, cooperate as a goodwill gesture and set the initial leniency parameter to its maximum value.
   - In the last round, defect if insufficient cooperation was observed throughout the game, otherwise cooperate to maximize payoff for that particular round.

3. Be exploitative:
   - By initially cooperating, TfT-GA gives opponents an opportunity to demonstrate their cooperation and potentially establish a positive cycle of interaction. However, if insufficient cooperation is observed, TfT-GA will punish them in subsequent rounds, eventually switching to a defective strategy.
   - The gradient adjustment mechanism ensures that initial leniency decreases over time, making it harder for opponents to exploit TfT-GA by cooperating only in early stages of the game. This promotes the emergence of cooperation while maintaining an exploitative mindset towards uncooperative opponents.
'''

description_EXPLOITATIVE_281 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, TFTA initially cooperates in the first round (first-move advantage), then mimics the opponent's last action for the next r-2 rounds. If the opponent has been cooperative, TFTA continues to cooperate. However, if the opponent has ever defected, TFTA will defect until the opponent reverts back to cooperation, at which point TFTA resumes copying the opponent's behavior.

   Pseudocode:
   ```
   function TFTA(opponentHistory):
       if round == 1:
           cooperate
       else:
           if opponent[round-1] == 'C':
               cooperate
           elif opponent[round-1] == 'D' and myLastAction != 'D':
               defect
           elif opponent[round-1] == 'D' and myLastAction == 'D':
               cooperate
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, TFTA cooperates as stated earlier. There are no specific edge cases for the last round since the strategy is based on the opponent's previous action, not their future actions.

3. Be exploitative - Clearly align with the exploitative mindset
   Initially, TFTA cooperates but will quickly defect if the opponent ever deviates from cooperation, ensuring a higher payoff in the short term at the expense of potential long-term benefits. However, once the opponent reverts to cooperation, TFTA is willing to cooperate again, indicating an adaptive and potentially forgiving nature that could exploit opponents who are prone to defecting but may eventually cooperate.

   It's important to note that while TFTA has an exploitative component, it does not solely rely on exploitation. Instead, the strategy is designed to both cooperate and punish defection, depending on the opponent's behavior. This approach aims to balance short-term gains with potential long-term benefits by promoting cooperation when the opponent demonstrates trustworthiness but retaliating if the opponent fails to uphold their end of the bargain.
'''

description_EXPLOITATIVE_282 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT)

1. Specify decision rules:
   - Start by cooperating in the first round (C1). This sets a cooperative tone and reduces suspicion among opponents.
   - For subsequent rounds, adaptively decide whether to cooperate or defect based on the number of cooperators from the previous round.
   - If the number of cooperators in the last round (t-1) is equal to or greater than the minimum required cooperators (m), then cooperate (Ct). This rewards cooperation and encourages opponents to continue cooperating.
   - If the number of cooperators in the last round (t-1) is less than m, defect (Dt). This punishes defection by denying a reward factor (k) in the current round and potentially discouraging opponents from continuing to defect.
   - In cases where t=1, follow rule 1 instead.

Pseudocode:
```
function TFT-ACT(round):
    if round == 1:
        cooperate = True
    else:
        cooperators_last_round = count_cooperators(last_round)
        cooperate = (cooperators_last_round >= m)

    return cooperate
```

2. Handle edge cases:
   - In the last round, cooperate even if the number of cooperators in the previous round is less than the minimum required cooperators (m), as there will be no more rounds to retaliate or benefit from cooperation.
   - If a player suddenly starts cooperating after a prolonged period of defection, TFT-ACT will continue to cooperate for one round but may revert back to punishing defection if the number of cooperators in the next round is still less than m.

3. Be exploitative:
   - TFT-ACT encourages cooperation when it benefits the player (when a sufficient number of opponents also cooperate), and punishes defection by withholding the reward factor (k) and potentially encouraging other opponents to retaliate against the defector in future rounds. This fosters an exploitative environment where players are incentivized to cooperate only when it is advantageous, and defect otherwise.
   - The adaptive threshold for cooperation allows TFT-ACT to respond flexibly to varying group dynamics and opponent behavior patterns.
'''

description_EXPLOITATIVE_283 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfT-A)

1. Specify decision rules:
   - Start by cooperating in the first round (C_i,1 = C). This is a friendly gesture to encourage cooperation and avoid immediate exploitation.
   - For subsequent rounds, repeat the action of the most common action taken by opponents in the previous r-1 rounds (excluding the last round for edge cases). If the most common action is a tie, defect (D_i,t). This strategy aims to mimic and reciprocate the behavior of others while being resilient to exploitation.
   - If an opponent deviates from cooperating when TfT-A was cooperating, TfT-A will also defect in response for the next round (D_i,t+1). This punishment aims to discourage opportunistic behavior.

2. Handle edge cases:
   - Last Round: Since there are no future rounds to consider, TfT-A will simply cooperate (C_i,r) as a friendly gesture or to potentially gain extra reward if others have started to cooperate.
   - First Round: As mentioned earlier, TfT-A starts by cooperating (C_i,1 = C).
   - Interim Edge Cases: When analyzing the most common action taken by opponents in the previous r-1 rounds, ensure that the last round's action is not included. This avoids biasing the decision rule based on the potentially exploitative behavior in the current round.

3. Be exploitative:
   - TfT-A aims to be exploitative by punishing defectors (i.e., not cooperating when they defect) and rewarding cooperators (i.e., cooperating when they cooperate). This strategy hopes to encourage cooperation while simultaneously benefiting from any cooperative actions taken by opponents.
   - TfT-A's adaptation is exploitative in the sense that it seeks to respond optimally to the behavior of others, making it difficult for them to predict and exploit TfT-A's moves. However, it does not actively seek to exploit its opponents but rather tries to balance cooperation and self-interest based on the observed behavior of others.
'''

description_EXPLOITATIVE_284 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to foster a cooperative environment (C).
   - For subsequent rounds, observe the opponent's action from the previous round and respond accordingly:
     - If opponent cooperated in the previous round, cooperate (C).
     - If opponent defected in the previous round, defect (D) until the opponent cooperates twice consecutively. After that, revert to cooperating (C).

2. Handle edge cases:
   - In the last round, since the strategy is exploitative, always defect (D), as there are no further rounds for retaliation.
   - If the opponent has never cooperated before, always defect (D).
   - If a cooperation streak of two consecutive cooperations is broken by the opponent, revert to defecting (D) until the cooperation streak is regained.

3. Be exploitative:
   - The strategy starts with cooperating to give the opponent an opportunity to cooperate. However, if the opponent does not reciprocate, the ATFT strategy will punish them by defecting. Once the opponent starts cooperating again, the ATFT strategy forgives and continues cooperating indefinitely. This strategy is exploitative as it takes advantage of opponents who are willing to cooperate while also being firm against those who do not cooperate.
   - If most opponents repeatedly defect, the ATFT strategy will learn to defect as well, maximizing its payoff in the long run by matching the behavior of non-cooperative opponents.

Pseudocode:

```python
def adaptive_tit_for_tat(opponent_history):
    current_round = len(opponent_history)
    cooperation_streak = 0

    if current_round == 1:
        return "C"  # Cooperate in the first round

    last_action = opponent_history[-1]
    if last_action == "C":
        if cooperation_streak >= 2:
            return "C"  # Maintain cooperation streak
        else:
            return "C"  # Start a new cooperation streak
    elif last_action == "D":
        if cooperation_streak > 0:
            cooperation_streak -= 1
            return "D"  # Punish the opponent for defecting
        else:
            return "D"  # No cooperation yet, start by defecting
```
'''

description_EXPLOITATIVE_285 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to demonstrate good intentions and encourage cooperation from others (C).
   - For subsequent rounds, if a player cooperated in the previous round (P_i-1 = C), cooperate in the current round as well (C). If a player defected in the previous round (P_i-1 = D), also defect in the current round (D). This replicates the Tit-for-Tat strategy, but with an added twist.
   - Introduce adaptive cooperation by gradually increasing the percentage of times a player cooperates after being exploited (defected against). If a player has been repeatedly exploited by another player for the last 'e' consecutive rounds, increase the probability of cooperating in response to that player's action. For example, if e=3, increase the cooperation probability from 10% to 25%. This encourages exploitative players to be more cooperative in the future but still retains a measure of punishment for repeated defection.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as mentioned earlier.
   - In the last round, cooperate if and only if the player's total payoff over the game is lower than the total payoff of the opponent (to ensure that cooperation benefits the self-interested player in the long run). This encourages cooperation when it may lead to a higher overall payoff.
   - In other edge cases, follow the decision rules as specified in point 1.

3. Be exploitative - Clearly align with the exploitative mindset:
   - The TFTA strategy is inherently exploitative because it rewards cooperative behaviour only when it leads to a higher payoff compared to defection. By adapting cooperation based on the opponent's past actions, it encourages opponents to behave cooperatively when it benefits the self-interested player, but still punishes repeated defection with reduced cooperation in response.
   - The strategy also introduces adaptive cooperation that gradually increases after being exploited, allowing for more cooperation when it may eventually lead to a higher payoff even if it seems less beneficial in the short term. This adaptation encourages opponents to maintain cooperative behaviour, as increasing cooperation improves their long-term payoffs. However, if cooperation does not result in a higher overall payoff compared to defection, the strategy will still defect, maintaining its exploitative nature.
'''

description_EXPLOITATIVE_286 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT)

1. Specify decision rules:
   - Initialize cooperative threshold (ct) to m. This means in the first round, the player will cooperate.
   - For subsequent rounds, observe the number of cooperators (n_c) in the previous round and update ct based on n_c and k. If n_c >= m, then maintain ct as it is. If n_c < m, then decrease ct by a small step.
   - In each round, if the number of cooperators in the current round meets or exceeds the current ct, then cooperate; otherwise defect.

Pseudocode:
```
def TFT_ACT(ct, k, n_c, r):
    if r == 1:
        action = 'C'
    else:
        if n_c >= m:
            action = 'C'
        elif n_c < m and ct > 1:
            ct -= 1
            action = 'D'
        else:
            action = 'C'
    return action
```

2. Handle edge cases:
   - In the first round (r=1), the player will cooperate regardless of observed behavior from other players due to initializing ct as m.
   - In the last round (r=r), the player will defect if fewer than m players cooperated during the game, otherwise they will cooperate to maximize their payoff for that final round.

3. Be exploitative:
   - The strategy is designed to be exploitative by punishing defection in a retaliatory manner while also incentivizing cooperation through gradual adjustments in ct. If players repeatedly defect, the player will gradually decrease its ct, eventually reaching a point where it stops cooperating even if others do so. Conversely, if players consistently cooperate, the strategy's ct remains high, allowing for cooperation to persist.
   - However, by updating ct based on the number of cooperators in each round, the strategy can also adapt and forgive players who occasionally defect while maintaining cooperation when it is beneficial.
'''

description_EXPLOITATIVE_287 = '''
 Strategy Name: Tit-for-Tat Plus (TfT+)

1. Specify decision rules:
   - In each round, TfT+ initially cooperates and then adjusts future cooperation based on the previous round's actions of opponents.
   - If a majority (more than (n-1)/2) of players cooperate in the previous round, TfT+ continues cooperating in the current round.
   - If less than m players cooperate or if TfT+ defected in the previous round and m or more players cooperated, TfT+ will defect in the current round (punishing those who did not cooperate and signaling cooperation for the next round).

2. Handle edge cases:
   - In the first round, TfT+ cooperates to start fresh and foster cooperation.
   - In the last round, TfT+ considers the previous round's actions to make a decision.

3. Be exploitative:
   - TfT+ is designed to punish those who defect, while also showing willingness to cooperate to encourage others to do the same. However, it should be noted that TfT+'s primary goal is to maximize its own reward within the defined rules and parameters.

Pseudocode:
```
def TFTplus(n, m, k, r, history):
  cooperation_counter = (n-1)/2
  current_round = 1
  while current_round <= r:
    if len(history) > 0 and current_round > 1:
      previous_cooperators = sum(history[-1])
      if previous_cooperators >= cooperation_counter:
        action = 'C'
      elif previous_cooperators < m or history[-1][-1] == 'D':
        action = 'D'
    else: # First round
      action = 'C'

    take_action(action) # Perform the chosen action and update the game state
    history.append(action) # Append the taken action to the history for future decisions
    current_round += 1
```
'''

description_EXPLOITATIVE_288 = '''
 Strategy Name: Tit-for-Tat with Threshold (TFT-Threshold)

1. Specify decision rules:
   - Initially (first round), cooperate to show good faith and encourage others to do the same.
   - In subsequent rounds, observe the number of cooperators in the previous round (n_coop).
   - If n_coop >= m, cooperate as a reward for collective cooperation.
   - If n_coop < m, defect as a punishment for not meeting the threshold.
   - Maintain this pattern consistently throughout the game to encourage reciprocity among opponents while being exploitative when necessary.

2. Handle edge cases:
   - In the last round, cooperate regardless of previous round's n_coop, since the game ends after that round.
   - In the first round, as mentioned earlier, cooperate to show good faith.

3. Be exploitative:
   - The strategy is designed to encourage cooperation by initially cooperating and rewarding others who do so, but it will defect if necessary when the minimum number of cooperators is not met. This can be seen as a form of punishment for not meeting the cooperation threshold.
   - By adopting this Tit-for-Tat with Threshold approach, the strategy seeks to maximize its payoff by exploiting opponents who do not cooperate while still maintaining a chance for higher rewards when others do cooperate. This exploitative mindset is achieved by selectively choosing to cooperate or defect based on the number of cooperators in the previous round.
'''

description_EXPLOITATIVE_289 = '''
 Strategy Name: Tit-for-Tat with Adaptive Risk Aversion (TfT-ARA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TfT-ARA will start by cooperating in the first round, signaling a willingness to cooperate initially. For subsequent rounds, it will adopt an adaptive approach that considers both past cooperation and the risk factor (k). If the minimum number of players (m) have cooperated in the previous round, TfT-ARA will also cooperate. Otherwise, if fewer than m players cooperated, TfT-ARA will defect to punish non-cooperators while protecting its own resources. To balance between cooperation and risk aversion, TfT-ARA will use an adaptive threshold that increases over time when it has consistently faced defection from other players:

   Pseudocode for decision rule:
   ```
   function TfT_ARA(round, past_actions, k, m):
       if round == 1:
           return Cooperate()

       adaptive_threshold = threshold + (defection_count / round) * (1 - k)

       if number_of_cooperators_last_round >= m and past_actions[round-1] == Cooperate():
           return Cooperate()
       elif adaptive_threshold > number_of_defectors_last_round:
           return Cooperate()
       else:
           return Defect()
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   TfT-ARA's strategy is designed to be adaptive throughout the game, so it does not require any special handling for edge cases like the first or last round. However, since the game structure includes multiple rounds, TfT-ARA will assume that the last round has been reached if the current round exceeds the specified number of rounds (r).

3. Be exploitative - Clearly align with the exploitative mindset
   TfT-ARA's primary goal is to maximize its own payoff while punishing non-cooperators and protecting itself from excessive risk. It will cooperate initially, but quickly adapt to respond to other players' actions by either continuing cooperation if they reciprocate or defecting when faced with repeated defection. By increasing the adaptive threshold over time, TfT-ARA will become increasingly risk-averse as it encounters more defections, allowing it to reap larger rewards when the minimum number of players cooperate. This adaptability makes TfT-ARA a robust exploitative strategy that can perform well against a wide range of opponent behaviors.
'''

description_EXPLOITATIVE_290 = '''
 Strategy Name: Tit-for-Tat-Cooperate (TfTC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate (C). This is a friendly gesture to encourage cooperation, as the game theoretically rewards collective cooperation.
   - In subsequent rounds, observe the behavior of other players and cooperate if at least m-1 opponents cooperated in the previous round. Otherwise, defect (D).
   - If multiple players have differing cooperation patterns, follow those who most consistently cooperate when m-1 or more did so in the previous round.

2. Handle edge cases:
   - Last round: Since there are no future rounds for retaliation or reward, simply maximize personal payoff. If more than m-1 players cooperated in the previous round, cooperate; otherwise, defect.
   - First and other initial rounds (e.g., after a series of last rounds): Cooperate as an opening move to encourage cooperation from others.

3. Be exploitative:
   - Pretend to cooperate by following the TfTC rule in most cases, but be ready to defect when opponents do not reciprocate sufficient cooperation.
   - By initially cooperating and strategically defecting when appropriate, the strategy aims to encourage cooperation while also taking advantage of opponents who consistently defect or do not follow a cooperative pattern.
'''

description_EXPLOITATIVE_291 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - In every round i, cooperate if more than (m - 1)/2 players cooperated in the previous round. If fewer than (m - 1)/2 players cooperated, defect. This rule ensures that TFT-ACT will cooperate when the majority of players cooperated in the previous round, and defect when they did not.
   - If the number of players is even, adjust the threshold to ((m - 1) + 1)/2 to avoid ties.

2. Handle edge cases:
   - First round: Cooperate since no past actions to observe.
   - Last round: Cooperation depends on the previous round's outcome, following the decision rule above.
   - After a player defects multiple times in a row: Adjust cooperation threshold temporarily down by one to exploit the defector more aggressively and encourage them to cooperate. If they continue to defect, further decrease the threshold. Conversely, if a player cooperates after multiple defections, raise the cooperation threshold slightly as a reward.

3. Be exploitative:
   - TFT-ACT is designed to punish those who defect by adapting its own cooperation level in response to past actions of opponents. The strategy aims to make other players pay a higher cost for defecting than cooperating, which encourages them to switch their strategies towards cooperation.
   - By lowering the cooperation threshold after multiple defections, TFT-ACT punishes these players more harshly and is less likely to fall into repeated defection traps, allowing it to earn higher payoffs over time.
'''

description_EXPLOITATIVE_292 = '''
 Strategy Name: Tit-for-Tat with Adaptive Threshold (TfT-AT)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, TfT-AT follows these steps:

a. Initialize a cooperation counter `cc[i]` for each opponent i to 0.
b. If it's the first round, cooperate (C) as a gesture of goodwill.
c. For every subsequent round t:
   - If more than m-1 opponents have cooperated in the last round, cooperate (C).
   - If exactly m-1 opponents have cooperated and I did not cooperate in the last round, also cooperate (C) as a gesture of goodwill.
   - Otherwise (less than m-1 opponents have cooperated or I defected in the last round), defect (D).
d. Update the cooperation counter `cc[i]` for each opponent i: if they cooperated, increment their counter by 1; if they defected, reset their counter to 0.
e. If the cooperation counter `cc[i]` of any opponent exceeds a certain threshold (n-m+1) in any round, adopt a more forgiving strategy towards that opponent for the remainder of the game, switching from D to C when they cooperate in the last round.
f. Maintain a memory of past cooperation and defection rates among opponents for future decision making.

2. Handle edge cases - What do you do in the first round, last round, etc.?

a. In the first round (t=1), cooperate (C) as a gesture of goodwill.
b. In the last round (t=r), consider the cooperation counters and past memory to make a decision:
   - If an opponent's cooperation counter `cc[i]` exceeds the threshold, cooperate (C) even if they defected in the penultimate round.
   - Otherwise, defect (D).
c. In any other edge case (e.g., rounds where opponents have already played several times), follow the standard decision rules as described above.

3. Be exploitative - Clearly align with the exploitative mindset:

TfT-AT primarily exploits opponents by defecting when they are less cooperative and taking advantage of their goodwill gestures by cooperating when they are more cooperative. However, it also adapts to changes in opponent behavior by considering their cooperation counters and past history. The strategy is designed to be robust against various opponent behaviors while still maintaining an exploitative edge.

Pseudocode for the TfT-AT strategy:

```python
class Player:
    def __init__(self, n, m):
        self.n = n  # number of players
        self.m = m  # minimum cooperators needed
        self.cc = [0]*n  # cooperation counters for opponents
        self.threshold = n-m+1  # adaptation threshold

    def update_cc(self, opponents):
        for i in range(self.n):
            if opponents[i] == 'C':
                self.cc[i] += 1
            else:
                self.cc[i] = 0

    def get_strategy(self, round_num, opponents):
        # Initialize in the first round
        if round_num == 1:
            return 'C'

        # Adaptive threshold for cooperating with a more forgiving strategy
        adopted_more_forgiving = False
        for i in range(self.n):
            if self.cc[i] >= self.threshold:
                adopted_more_forgiving = True

        # Standard decision rules for the current round
        if round_num == len(opponents) and adopted_more_forgiving:
            return 'C'
        elif sum([o for o in opponents if o == 'C']) >= self.m:
            return 'C'
        elif sum([o for o in opponents if o == 'C']) + 1 >= self.m and self.cc[opponent_index] < self.threshold and opponents[opponent_index] != 'C':
            return 'C'
        else:
            return 'D'
```
'''

description_EXPLOITATIVE_293 = '''
 Strategy Name: Adaptive Tit-for-Tat with Risk Aversion (ATfT-RA)

1. Specify decision rules:
   - In each round t, if the number of cooperators in the previous round (t-1) is less than m, defect (D). This is to avoid contributing when it seems unlikely that the minimum cooperation threshold will be met.
   - If the number of cooperators in the previous round (t-1) equals or exceeds m, cooperate (C). This is a reciprocal response aimed at building trust and promoting cooperation.
   - To account for the risk aversion factor k, if the number of cooperators in the current round (t) reaches or surpasses m, calculate the expected payoff for the next round using the average k from previous rounds: E[k] = (Σ(t'=1 to t-1) k_t') / (t - 1). If this expected payoff is greater than the immediate reward of cooperation, defect in the current round. This exploitative twist helps the strategy to capitalize on favorable trends and maximize long-term gains.

2. Handle edge cases:
   - In the first round, since there's no history, cooperate (C) to initiate a potential cooperative relationship.
   - In the last round, consider E[k] as the average k from the previous r-1 rounds and make a decision based on the rules specified in point 1.
   - If there are multiple consecutive rounds with less than m cooperators, continue defecting to avoid being taken advantage of. However, if there's a switch to more cooperation, return to cooperating according to the strategy rules.

3. Be exploitative:
   - By defecting when the number of cooperators is below the minimum required (m), the ATfT-RA strategy is designed to avoid being taken advantage of by freeriders or less cooperative opponents.
   - The inclusion of the expected payoff calculation and comparison with the immediate reward of cooperation allows the strategy to exploit favorable trends in cooperation while still maintaining a cooperative demeanor most of the time.

Pseudocode:
```python
def ATfT_RA(n, m, k, r):
    players = [0] * n
    rounds = 1
    while rounds <= r:
        if rounds == 1:
            players[index] = C
        else:
            cooperators = sum(players[(rounds - 1) % r])
            if cooperators < m:
                players[index] = D
            elif cooperators >= m and E[k] > 1 + k * (n - cooperators):
                players[index] = D
            else:
                players[index] = C
        rounds += 1
    return sum(players)
```
'''

description_EXPLOITATIVE_294 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate (C). This is a friendly gesture to encourage cooperation from opponents.
   - For subsequent rounds t (t > 1), if the number of cooperators in the previous round was less than m, defect (D). If the number of cooperators in the previous round was equal to or greater than m, cooperate (C). This rule is based on the principle of reciprocating cooperation but also taking into account the minimum cooperation threshold m.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate (C) as previously mentioned.
   - In the last round, if the number of cooperators in the previous round was less than m, defect (D). If the number of cooperators in the previous round was equal to or greater than m, also cooperate (C). This ensures that even in the final round, there is still an opportunity for potential reward.

3. Be exploitative - Clearly align with the exploitative mindset:
   - TFT-ACT starts by cooperating but quickly adapts to exploit uncooperative opponents while maintaining cooperation when appropriate. By only cooperating when a sufficient number of players do so, TFT-ACT maximizes its own payoff while minimizing the potential rewards of other players who consistently defect.
   - As the game progresses and opponents' strategies become more apparent through their actions, TFT-ACT will continuously adjust its cooperation decisions accordingly, taking advantage of uncooperative opponents without sacrificing potential rewards when opponents exhibit cooperative behavior.

Pseudocode:

```python
def tft_act(n, m, k, r, history):
  # Initialize variables
  round = 1
  total_payoff = 0
  cooperation_count = 0

  while round <= r:
    if round == 1:
      action = 'C'  # Cooperate in the first round as a friendly gesture
    else:
      cooperation_count = count_cooperators(history, round-1)

      if cooperation_count < m:
        action = 'D'  # Defect when fewer than m players cooperated in the previous round
      else:
        action = 'C'  # Cooperate when m or more players cooperated in the previous round

    payoff = calculate_payoff(action, cooperation_count >= m)
    total_payoff += payoff

    # Update history for next round
    add_round(history, action)
    round += 1

  return total_payoff
```
'''

description_EXPLOITATIVE_295 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules:
   - In each round i, the ATFT strategy decides to cooperate or defect based on the number of cooperators in the previous round (i-1).
   - If more than m players cooperated in round (i-1), ATFT will also cooperate (C). This is a gesture of goodwill and encourages cooperation.
   - If less than m players cooperated in round (i-1), ATFT will defect (D). This is a punishment for the lack of cooperation from others.
   - In case of exactly m players cooperating, ATFT follows the crowd by also cooperating (C).

Pseudocode:
```
function ATFT(round, previous_cooperators) {
  if (previous_cooperators >= m) {
    return 'C' // Cooperate
  } else {
    if (round == 1) {
      return 'C' // First round, cooperate to encourage others
    } else {
      if (myStrategyOutcome(round-1) == 'C') {
        return 'C' // Previous round I cooperated, continue cooperation
      } else {
        return 'D' // Previous round I did not cooperate, defect as punishment
      }
    }
  }
}
```

2. Handle edge cases:
   - In the first round, ATFT will cooperate to encourage others (maintain fairness).
   - In the last round, ATFT will evaluate the total number of cooperators throughout the game and make a decision accordingly. If there were enough cooperators over the course of the game (total number of cooperators ≥ m*r), ATFT will cooperate; otherwise, defect.

3. Be exploitative:
   - Although not primarily designed as an exploitative strategy, ATFT retaliates against selfish behavior by defecting when others do not cooperate. It also punishes continuous lack of cooperation with a gradual shift towards defection. However, once cooperation is established, it reciprocates cooperation. This can be seen as both fair and potentially exploiting others who renege on agreements or cooperative behaviors.
   - ATFT has the potential to punish extreme exploitative strategies in the long run by not cooperating when they defect repeatedly, leading to lower payoffs for such strategies. However, it may also fall prey to more sophisticated strategies that use mixed cooperation and defection patterns over time, making it less effective against those.
'''

description_EXPLOITATIVE_296 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfT-A)

1. Decision Rules:
   - In the first round, cooperate to show good faith and encourage potential cooperation from opponents. This initial cooperative act is a signal of trustworthiness. (C in the first round)
   - For subsequent rounds, mimic the opponent's previous action in the last round. If the opponent cooperated in the last round, reciprocate by cooperating as well. If the opponent defected in the last round, also defect to punish and deter future defection. (C if opponent cooperated, D if opponent defected)
   - If an opponent repeatedly switches between cooperation and defection, adopt a more forgiving approach and continue cooperating in response to any act of cooperation from the opponent. However, immediately defect after each act of defection as a punishment.

2. Handling Edge Cases:
   - In the last round, since there are no future rounds for retaliation or rewards, simply mimic the opponent's action from the previous round. If the opponent cooperated, also cooperate to end on a positive note. If the opponent defected, defect as well to reflect the lack of cooperation.
   - In the case where an opponent does not follow the game rules by cooperating when m players have already done so or defecting when more than (n-m) players have defected, immediately defect and continue doing so until the opponent adheres to the game rules again.

3. Exploitative Mindset:
   - The strategy is designed to be exploitative by punishing opponents who do not cooperate while also fostering cooperation when possible. By mimicking an opponent's previous action, the strategy aims to encourage reciprocity and take advantage of cooperative opponents. However, it can quickly detect and respond to defection with punishment to deter future defections.
   - The adaptive nature of this strategy makes it robust against a wide range of opponent behaviors, as it learns from past interactions and adjusts its actions accordingly. This flexibility allows the strategy to outperform opponents that rely on rigid strategies or simple rules.
'''

description_EXPLOITATIVE_297 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to demonstrate good faith and encourage potential cooperation from others (C).
   - For subsequent rounds:
      1. If a majority of players (m or more) cooperated in the previous round, continue cooperating (C).
      2. If fewer than m players cooperated in the previous round, defect (D).
      3. If the number of cooperators in the previous round was exactly m but the player themselves defected, switch to cooperate for the next round and thereafter follow rule 1a or 1b depending on the current round's cooperation count.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round (t=1), cooperate (C).
   - In the last round (t=r), follow rule 1b based on the previous round's cooperation count.
   - For all other rounds, follow rules 1a and 1b as described above.

3. Be exploitative - Clearly align with the exploitative mindset
   - The TFT-ACT strategy is designed to punish defectors by defecting when they do, but also encourages cooperation whenever possible. This creates an opportunity for exploitation: if a majority of players cooperate while one or more consistently defect, the defector(s) can take advantage of the collective investment in the community project without contributing. However, since the TFT-ACT strategy also punishes persistent defection, it discourages long-term exploitative behavior.
   - By cooperating initially and only defecting when necessary, TFT-ACT appears less threatening to potential cooperators and may encourage more players to cooperate, potentially increasing overall rewards over time.
'''

description_EXPLOITATIVE_298 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Decision Rules:
   - Initially cooperate in the first round (C_i, 1 = 1). This demonstrates a willingness to cooperate and sets a positive tone for potential long-term collaboration.
   - In subsequent rounds, observe the number of cooperators from the previous round (n_c_{t-1}) and compare it with the minimum cooperators needed parameter (m).
     - If n_c_{t-1} < m, defect (C_i, t = 0), signaling disapproval for the lack of cooperation in the previous round.
     - If n_c_{t-1} >= m, cooperate (C_i, t = 1). This rewards the cooperators from the previous round and encourages them to continue cooperating.
   - In the last round, always cooperate (C_i, r = 1), as there is no opportunity for retaliation or future interactions with opponents.

2. Edge Cases:
   - If there are no cooperators in the previous round and it's not the first round, defect (n_c_{t-1} < m && t > 1, then C_i, t = 0).
   - In case of a tie where exactly m players cooperated, cooperate to match their actions and encourage potential long-term collaboration.

3. Exploitative Nature:
   - The TFT-ACT strategy is inherently exploitative as it takes advantage of opponents who consistently defect by punishing them with defections in response, while rewarding those who cooperate by also cooperating. This behavior encourages more cooperative outcomes when opponents shift their strategies towards cooperation.
   - The strategy maintains an adaptive cooperation threshold (m) that can be fine-tuned based on the specific game parameters to maximize payoffs against a wide range of opponent behaviors.
'''

description_EXPLOITATIVE_299 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, TfTA cooperates to signal trust and encourage cooperation from other players.
   - For subsequent rounds, TfTA will mirror the opponent's action from the previous round: if the opponent cooperated in the last round (c_i = 1), TfTA will also cooperate (C); otherwise, it will defect (D). This rule encourages reciprocity and makes TfTA appear predictable.
   - If an opponent has not played before (no history), TfTA defaults to cooperation in the first round as a trust-building measure.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the final round, TfTA will defect regardless of the opponent's previous action since there are no further rounds for the payoff to be reciprocated.
   - For the initial n-1 rounds where m has not been reached yet (i.e., fewer than m players cooperate), TfTA will continue to cooperate in an attempt to reach the cooperation threshold and benefit from the higher payoff.

3. Be exploitative - Clearly align with the exploitative mindset
   - TfTA will exploit opponents who consistently defect (TIT for TAT) by defecting in response, aiming to earn the maximum private payoff (1).
   - TfTA will also cooperate with other cooperative opponents, earning a higher collective reward when the threshold is met (k > 1), but it will only reciprocate cooperation if its opponent does the same.
   - If an opponent cooperates after previously defecting, TfTA will continue to cooperate, giving the opponent an opportunity to establish trust and potentially reap the benefits of cooperation in future rounds.

Pseudocode:
```python
def TitForTatAdaptive(opponent_history):
  if len(opponent_history) == 0: # First round
    return 'C' # Cooperate to initiate trust

  if opponent_history[-1] == 'C': # Last round or cooperative opponent
    if len(opponent_history) >= m: # If cooperation threshold is met
      return 'C' # Cooperate for higher payoff
    else: # Cooperation threshold not yet reached
      return 'C' # Continue cooperating to encourage others

  if opponent_history[-1] == 'D': # Defecting opponent
    return 'D' # Defect in response to exploitative behavior

# Main game loop
for round in range(r):
  opponent_action = opponent.play() # Opponent plays its action
  payoff = determinePayoff(opponent_action)
  if round < r - 1: # Not the final round
    store opponent_action # Update opponent history for future decisions
  play_action = TitForTatAdaptive(opponent_history) # Decide action based on history
```
'''

description_EXPLOITATIVE_300 = '''
 Strategy Name: Tit-for-Tat with Variation (TFTV)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate (C). This is a friendly gesture to initiate cooperation.
   - For subsequent rounds, if the opponent cooperated in the previous round, cooperate (C). This mimics reciprocity and encourages long-term cooperation.
   - If the opponent defected in the previous round, also defect (D) as retaliation. However, there is a chance to deviate from this strict retaliation by introducing a forgiveness mechanism.
     - With probability 'f', forgive the opponent and cooperate (C), even if they defected in the previous round. This reduces the harshness of the strategy and allows for possible recovery of cooperation. The forgiveness factor 'f' can be a function of the game parameters or the current round number, but for simplicity, let's keep it as a constant value between 0 and 1.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - The strategy starts cooperating in the first round (C).
   - In the last round, there is no need to maintain the forgiveness mechanism since the game ends anyway. So, the decision rule becomes: if the opponent cooperated in the previous round, also cooperate (C); otherwise, defect (D).

3. Be exploitative - Clearly align with the exploitative mindset
   - The TFTV strategy is exploitative in its tit-for-tat approach. If an opponent consistently cooperates, the strategy reciprocates and also cooperates. However, if the opponent defects, the strategy retaliates by defecting as well. This can be seen as a form of punishment for defection.
   - The forgiveness mechanism adds an element of mercy to the strategy, allowing for the possibility of cooperation recovery even after defection. But it is also exploitative since the strategy will not immediately forgive and may continue retaliation with a probability of (1-f).

Pseudocode:

```python
def tftv(opponent_history, n, m, k, f, r):
  own_history = [C for _ in range(r)]  # Initialize own history with cooperation

  def decide_action(current_round):
    if current_round == 1:
      return C  # Cooperate in the first round

    if len(own_history) < current_round - 1:
      own_history.append(D)  # Add defection if history is not long enough

    if opponent_history[-1] == C and random() > f:  # Forgive with probability f
      return C
    elif opponent_history[-1] == C:
      return C
    else:
      return D

  for round in range(1, r+1):
    own_history.append(decide_action(round))

  payoff = sum([payoff_calculation(own_history[t], m, k) for t in range(1, r+1)])
  return payoff
```
'''

description_EXPLOITATIVE_301 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT)

1. Specify decision rules:
   - Initially cooperate (C) in the first round to establish a cooperative starting point.
   - For subsequent rounds t (t > 1), evaluate the proportion of cooperators (p_c) among all players over the last s past rounds (a window size). If p_c >= m / n, cooperate; otherwise defect.
   - To adapt to changing opponent behavior and prevent exploitation, gradually adjust the window size based on recent changes in cooperation levels:
     a. If there is a sudden increase in cooperation (p_c > 0.9), expand the window size to encourage longer-term observation of cooperative tendencies.
     b. If there is a sudden decrease in cooperation (p_c < 0.1), contract the window size to avoid reacting too slowly to potential defections.

2. Handle edge cases:
   - In the last round, since no future rounds are left for retaliation or reciprocity, defect regardless of the observed trend.
   - In the first round, cooperate as a goodwill gesture and to encourage others to do so. However, if cooperation levels drop significantly in subsequent windows, switch to defection to protect against exploitation.

3. Be exploitative:
   - Maintain a low initial threshold for cooperation (e.g., p_c = 0.5) to quickly respond to cooperative signals from opponents and build trust.
   - Gradually raise the threshold as more defections occur, making it harder for opponents to exploit the strategy's initial willingness to cooperate.
   - Retaliate against defectors by switching to defection when a significant drop in cooperation is observed, but be cautious not to overreact and punish potential future cooperators.

Pseudocode:

```python
def TFT_ACT(n, m, k, r, s):
    window_size = int(s * r)  # initial window size for observing cooperation levels
    cooperation_history = [0] * window_size
    current_round = 1

    def get_cooperators():
        nonlocal cooperation_history, window_size
        cooperators = sum(cooperation_history[-window_size:])
        return cooperators

    def update_history():
        nonlocal cooperation_history, current_round
        cooperation_history[current_round - 1] = 1 if player_cooperates else 0

    def adapt_window(increase=True):
        nonlocal window_size
        if increase:
            window_size += int(window_size / s)
        else:
            window_size -= int(window_size / (s * 2))

    # First round, cooperate as a goodwill gesture
    player_cooperates = True
    update_history()

    for round in range(2, r + 1):
        p_c = get_cooperators() / window_size

        if player_cooperates and p_c < m / n:
            # If the strategy defected, it would switch to cooperation now
            player_cooperates = False

        elif not player_cooperates and p_c >= m / n:
            # If the strategy cooperated, it would switch to defection now
            player_cooperates = True

        if round < s or abs(p_c - (m / n)) > 0.1:
            adapt_window(True)
        elif abs(p_c - (m / n)) < 0.1:
            adapt_window(False)

        update_history()

    # Last round, defect regardless of observed trend
    player_cooperates = False
    update_history()

    return sum([1 if player_cooperates else (1 - c_i) + k for i in range(1, n + 1)])
```
'''

description_EXPLOITATIVE_302 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?

Initially, the TfT-A player starts by cooperating in the first round, mimicking the cooperative spirit of other players. From the second round onwards, it adapts its strategy based on the opponents' behavior in the previous round:

- If opponent cooperated, TfT-A will cooperate back, encouraging further cooperation.
- If opponent defected, TfT-A will also defect to retaliate, demonstrating a punishing response towards non-cooperative behavior.

Pseudocode for decision rule:
```
def decide_action(round, own_past_actions, opponent_past_actions):
  if round == 1:
    return "C" (Cooperate)

  last_opponent_action = opponent_past_actions[-1]

  if last_opponent_action == "C":
    return "C" (Cooperate)
  elif last_opponent_action == "D":
    return "D" (Defect)
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

To be consistent with the adaptive strategy, TfT-A will stick to its cooperative behavior in the initial round and continue adapting based on the opponent's actions:

Last round: No specific changes are required as TfT-A continues to adapt to the opponent's latest action.

3. Be exploitative - Clearly align with the exploitative mindset

While not directly designed for exploitation, TfT-A is an exploitative strategy in the sense that it punishes opponents who do not cooperate by defecting, hoping they will change their behavior in future rounds. By cooperating initially, TfT-A seeks to induce cooperation from its opponent while remaining responsive and adaptive to their actions.
'''

description_EXPLOITATIVE_303 = '''
 Strategy Name: Tit-for-Tat with Variation (TFTV)

1. Specify decision rules:
   - Initialize cooperation for the first round (c_i,1 = C).
   - For subsequent rounds, if the opponent cooperated in the previous round (c_opp,t-1 = C), then cooperate as well (c_i,t = C). If the opponent defected in the previous round (c_opp,t-1 = D), then defect in the current round (c_i,t = D). However, there is a variation: if m players are currently cooperating, even though you have previously defected, you should also cooperate to gain the reward factor k.
   - This strategy aims to reciprocate cooperation while being punishingly exploitative in case of defection.

2. Handle edge cases:
   - In the first round (t=1), cooperate as a gesture of goodwill (c_i,1 = C).
   - In the last round (t=r), if m players are currently cooperating, defect to secure your final payoff without helping the community project (c_i,r = D). Otherwise, reciprocate the last action of the opponent (c_i,r = c_opp, r-1).
   - If fewer than m players are currently cooperating at any point during the game, continue defecting until m players start cooperating. Once that happens, switch back to cooperative behavior as long as the condition holds.

3. Be exploitative:
   - TFTV is exploitative by taking advantage of opponents who are not cooperative, but it also fosters cooperation when other players demonstrate trustworthiness. By defecting when necessary, the strategy can secure its payoff while potentially punishing uncooperative opponents to make them reconsider their behavior in subsequent games.
   - The variation in the strategy enables it to adaptively participate in community projects when there is a critical mass of cooperators to maximize reward.
'''

description_EXPLOITATIVE_304 = '''
 Strategy Name: Adaptive Tit-for-Tat with Risk Aversion (ATfT-RA)

1. Specify decision rules:
   - In each round, calculate the fraction of cooperators in the previous round (f). If f >= m, then cooperate (C); otherwise defect (D). This ensures initial cooperation when a majority cooperated previously and retaliation against defection when a minority cooperated.
   - To account for the risk aversion aspect, modify the decision rule slightly: if f >= m, then with probability p cooperate (C) and with probability 1-p defect (D). Parameter p can be set based on the reward factor k, where a higher k encourages more risk aversion.
   - Pseudocode for single round decision making:
     ```
     function decision_rule(f, k):
         if f >= m:
             if random() <= p(k):
                 return 'C'
             else:
                 return 'D'
         else:
             return 'D'
     ```

2. Handle edge cases:
   - In the first round, since no previous actions have occurred, the strategy will cooperate initially (f = 0 < m).
   - In the last round, the strategy will still follow its decision rule based on the fraction of cooperators in the penultimate round.

3. Be exploitative:
   - The ATfT-RA strategy is inherently exploitative as it retaliates against defection by defecting itself (punishing opponents) and encourages cooperation when cooperators are abundant (rewarding cooperative opponents).
   - By setting a lower probability p, the strategy can become more aggressive in punishing defectors, making it less attractive for others to deviate from cooperation. This increases its exploitative nature.
'''

description_EXPLOITATIVE_305 = '''
 Title: Tit-for-Tat-k Strategy (TFT-k) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, the TFT-k strategy follows these rules:
   - If a player has previously cooperated in the current game, return the favor and also cooperate (C).
   - If a player has previously defected, defect (D) as revenge.
   - Maintain cooperation (C) with any player who always cooperates (Tit-for-Tat), and defect (D) against those who always defect.
   - To take advantage of the reward factor k, switch strategies based on the average payoff received so far:
     - If the average payoff exceeds (1+k)/2, start cooperating to acheive higher rewards.
     - If the average payoff is less than (1+k)/2, start defecting to avoid lower payoffs.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, TFT-k starts by cooperating since it doesn't have a history yet. In the last round, TFT-k cooperates if its average payoff exceeds (1+k)/2, otherwise defects to maintain the strategy's adaptability and exploitiveness.

3. Be exploitative - Clearly align with the exploitative mindset
   TFT-k is exploitative by learning from other players' strategies and adapting its own behavior accordingly. By using a payoff threshold based on k, it can take advantage of the reward factor and maximize its overall earnings. This strategy aims to punish defectors while still cooperating with cooperative opponents to achieve higher rewards when possible.

Pseudocode:
```
def TFT_k(n, r, m, k, history):
  average_payoff = 0
  current_strategy = 'cooperate'

  for round in range(1, r+1):
    if round == 1:
      action = 'cooperate'
    else:
      if current_strategy == 'cooperate':
        if all(player[round-1] == 'cooperate') or (m <= count_cooperators(history) and average_payoff > (1+k)/2):
          action = 'cooperate'
        else:
          action = 'defect'
          current_strategy = 'defect'
      elif current_strategy == 'defect':
        if all(player[round-1] != 'cooperate') or (m > count_cooperators(history) and average_payoff < (1+k)/2):
          action = 'defect'
        else:
          action = 'cooperate'
          current_strategy = 'cooperate'

    payoff = calculate_payoff(action, history)
    average_payoff += payoff

  return calculate_total_game_payoff(average_payoff, r)
```
'''

description_EXPLOITATIVE_306 = '''
 Strategy Name: Tit-for-Tat (with a twist)

1. Specify decision rules:
   - In each round, compare the number of cooperators in the previous round with the minimum cooperation threshold m. If the number of cooperators is less than m, defect (D). If the number of cooperators is equal to or greater than m, cooperate (C). This rule ensures a reciprocal behavior that mimics the average player population and encourages cooperation when possible.
   - In the first round, cooperate as an act of goodwill and to encourage others to do the same.
   - In the last round, defect if the number of cooperators in the previous round is less than m, and cooperate if it is equal to or greater than m. This adjustment accounts for the fact that there are no future rounds to reciprocate cooperation.

2. Handle edge cases:
   - If no one cooperated in the previous round (m-1 defectors), wait for another round to apply the decision rule and observe if anyone changes their strategy towards cooperation.
   - If everyone cooperated in the previous round, continue cooperating as a sign of trust. However, if there are signs of defection in subsequent rounds, revert to the decision rule to defend against exploitation.

3. Be exploitative:
   - The twist in this Tit-for-Tat strategy involves defecting when necessary to enforce cooperation from other players. If others consistently defect despite the presence of cooperative moves, this strategy will retaliate by defecting as well to discourage such behavior and encourage cooperation in future rounds.

Pseudocode:
```
function Strategy(round, num_coop_prev):
    if round == 1:
        action = "C" (Cooperate)
    else if round == r:
        if num_coop_prev < m:
            action = "D" (Defect)
        else:
            action = "C" (Cooperate)
    else:
        if num_coop_prev < m:
            action = "D" (Defect)
        else:
            action = "C" (Cooperate)
    return action
```
'''

description_EXPLOITATIVE_307 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TFT-A)

1. Specify decision rules:
   - In each round, evaluate the previous n-1 rounds to determine the number of cooperators (m_prev). If m_prev >= m, cooperate (C); otherwise, defect (D). This encourages cooperation when it is beneficial for the group but also retaliates against defection.
   - To avoid initial hesitation and foster cooperation, start with cooperating in the first round.
   - To adapt to changes in opponent behavior, if more opponents start cooperating than before, gradually increase the number of cooperative rounds (m); if fewer opponents are cooperating, decrease m. The adjustment should be incremental to minimize sudden shifts in strategy.

2. Handle edge cases:
   - In the last round, since there are no future rounds for retaliation, always cooperate regardless of past behavior.
   - If m is set too low or high initially, adjust m based on the number of cooperators in the first few rounds to find an optimal number quickly.

3. Be exploitative:
   - By retaliating against defection with defection, TFT-A maintains a balance between cooperation and self-interest, making it difficult for other strategies to exploit.
   - The gradual adjustment of m ensures that the strategy does not become overly cooperative or exploitative, making it robust to a wide range of opponent behaviors.
'''

description_EXPLOITATIVE_308 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TFT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, TFT-A plays C to initiate cooperation and set a precedent for the game.
   - After the first round, TFT-A adapts its behavior based on the number of cooperators in the previous round (m_prev). If m_prev >= m, TFT-A continues cooperating (C), rewarding cooperators from the previous round and punishing defectors for not cooperating. If m_prev < m, TFT-A defects (D) to retaliate against non-cooperators in the hope that they will change their behavior in the next round.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, TFT-A cooperates if m_prev >= m to maximize its reward for that round and potentially encourage cooperation in future games with the same opponents.
   - If the game is not the first or last round, TFT-A follows the decision rules described above.

3. Be exploitative - Clearly align with the exploitative mindset
   - TFT-A retaliates against non-cooperators by defecting in response to their actions, potentially encouraging them to cooperate in future rounds to avoid being punished again. This strategy is exploitative because it takes advantage of opponents who do not cooperate while still providing incentives for cooperation when they do.

Pseudocode:
```
def TFT_A(n, m, k, r, t):
    # Initialize current round (t) and previous round's minimum cooperators (m_prev)
    ct = t
    mp = 0

    # Loop through the rounds
    while ct <= r:
        if ct == 1:   # First round, cooperate
            return C

        # Check number of cooperators in previous round
        if mp >= m:   # Cooperation from the previous round, cooperate now
            return C
        else:         # Defect in response to non-cooperation from previous round
            return D

        # Update current round and previous round's minimum cooperators
        ct += 1
        mp = min_cooperators(ct - 1)
```
'''

description_EXPLOITATIVE_309 = '''
 Strategy Name: Tit-for-Tat with Escalation (TfT-E)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initiate with cooperation in the first round (C_i, 1 = C) to foster a potential cooperative relationship.
   - In subsequent rounds (t > 1), analyze the average cooperative rate of other players (CR) over the previous 'p' rounds and respond accordingly:
      - If CR >= m / n, cooperate (C_i, t = C) to reinforce the cooperative behavior.
      - If CR < m / n, defect (C_i, t = D) to punish non-cooperative players and encourage them to change their strategy.
   - Implement an escalation mechanism: if a player repeatedly defeats you in consecutive rounds after initial cooperation, respond with increasing severity by reducing the number of cooperative rounds before retaliating. For example:
      - If CR < m / n for 3 consecutive rounds, cooperate once before defecting (C_i, t = C, D, D, ...).
      - If CR < m / n for 5 consecutive rounds, cooperate twice before defecting (C_i, t = C, C, D, D, ...).
      - This escalation mechanism aims to punish consistently non-cooperative opponents while maintaining cooperation with potential partners.

2. Handle edge cases:
   - In the last round, TfT-E cooperates regardless of other players' actions or past behavior (C_i, r = C) to maximize final payoff.
   - In the first round, TfT-E cooperates as previously mentioned (C_i, 1 = C).
   - If p (the number of rounds considered for CR calculation) is not explicitly defined, you can use a default value such as p = 3 to maintain a balance between short-term and long-term decision-making.

3. Be exploitative:
   - TfT-E seeks to maximize its own payoff by initially fostering cooperation to gain potential benefits but will quickly retaliate against non-cooperative opponents.
   - The escalation mechanism ensures that repeated defection is met with increasing punishment, making it a robust strategy against a wide range of opponent behaviors.
   - By responding adaptively based on the observed cooperative rate of other players, TfT-E can adjust its strategy during the game to better align with the emergent behavior of the competition.
'''

description_EXPLOITATIVE_310 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Initially cooperate in the first round (c_i = 1, t=1). This is a friendly gesture to encourage cooperation and establish trust.
   - In subsequent rounds, observe the percentage of cooperators in the previous round (p_t) and compare it with an adaptive cooperation threshold (m_t). If p_t >= m_t, cooperate (c_i = 1); otherwise defect (c_i = 0).
   - The cooperation threshold adapts according to a decaying function based on the round number. It starts high at the beginning of the game to encourage cooperation but decreases over time as players may demonstrate less trustworthy behavior.
     - m_t = initial_threshold * (1 - ((r - t) / r))
       where:
         - initial_threshold is set close to or equal to the minimum cooperators needed (m), depending on the expected level of cooperation among opponents
         - r is the number of rounds
         - t is the current round number

2. Handle edge cases:
   - In the last round, always defect because there's no opportunity for future retaliation or reward.

3. Be exploitative:
   - By adapting the cooperation threshold based on round number, the strategy encourages cooperation in the beginning to potentially benefit from higher rewards but becomes less cooperative as the game progresses, taking advantage of opponents who consistently do not cooperate.
   - The initial cooperation and adaptive cooperation threshold make the strategy slightly more generous than a purely exploitative strategy like Always Defect (AD), which may lead some opponents to cooperate, ultimately benefiting the TFT-ACT strategy. However, as the game progresses and opponents realize that the TFT-ACT strategy becomes less cooperative over time, they are likely to defect themselves, making the TFT-ACT strategy more exploitative in the long run.
'''

description_EXPLOITATIVE_311 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfTA)

1. Specify decision rules:
   - In the first round, cooperate to foster a cooperative environment and minimize initial losses. This is represented by C in the first round (t=1).
   - For subsequent rounds, observe previous opponents' actions to determine whether to cooperate or defect. If the opponent cooperated in the previous round, cooperate; if not, defect. If there was no previous interaction (e.g., a new opponent), start by cooperating. This is represented pseudocode-style as follows:
     ```python
     function TfTA(opponent_history):
         if t == 1:
             return 'C'  # Cooperate in the first round

         if opponent_history[t-1] == 'C':
             return 'C'  # Cooperate if previous action was cooperation
         else:
             return 'D'  # Defect if previous action was defection
     ```

2. Handle edge cases:
   - Last round: since the goal is to maximize total payoff over all rounds, it's best to cooperate in the last round regardless of opponent behavior, to get the maximum possible reward from the community project (k) if enough opponents have also cooperated. This can be added as an additional condition in the pseudocode:
     ```python
         if t == r:  # If it's the last round, cooperate to maximize payoff
             return 'C'
     ```
   - If opponent history contains cycles of cooperation and defection (e.g., "CDCD..."), our strategy will mimic the opponent, cooperating when they do and defecting when they do. This is implicit in the current rule set.

3. Be exploitative:
   - TfTA's primary focus is to maintain a cooperative relationship with opponents who are also willing to cooperate, but it will punish those who repeatedly defect by defecting back. This is an exploitative strategy since it takes advantage of opponents who consistently defect by receiving the maximum payoff possible while minimizing losses.
   - By starting with cooperation in the first round and adapting to opponents' behavior thereafter, TfTA aims to outperform purely exploitative strategies that immediately defect or always cooperate. This adaptability allows for better performance against a variety of opponent behaviors without requiring any knowledge of specific coordination mechanisms or shared norms.
'''

description_EXPLOITATIVE_312 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TFT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
In each round, the TFT-A strategy starts by cooperating (C). If an opponent defects (D), TFT-A will also defect in the subsequent round. If the opponent cooperates after a previous defeat (D), TFT-A will cooperate again in the next round, effectively forgiving the opponent for their previous action.

```
function TFT_A(opponent_history):
  cooperation_status = C  # Assume cooperation at the beginning

  for r in range(1, r + 1):
    if opponent_history[r] == D and cooperation_status == C:
      cooperation_status = D  # Defect if opponent defected last round
    elif opponent_history[r] == C and cooperation_status == D:
      cooperation_status = C  # Cooperate if opponent cooperated after defection

  return cooperation_status  # Return action for this round
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
In the first round, TFT-A cooperates as a gesture of goodwill. In the last round, TFT-A considers the opponent's actions during the game and decides whether to cooperate or defect based on the history.

3. Be exploitative - Clearly align with the exploitative mindset
TFT-A is inherently exploitative because it starts by cooperating but punishes opponents who take advantage of this initial cooperation by defecting. On the other hand, TFT-A rewards opponents who reciprocate its cooperative actions. This makes it less vulnerable to being exploited by more aggressive strategies while still maintaining some potential for cooperation with others.

The adaptive aspect of TFT-A comes into play when dealing with unpredictable or irrational opponents. If an opponent consistently defects without any signs of reciprocity, TFT-A will eventually stop cooperating and match their defection in order to maximize its own payoff. Conversely, if an opponent demonstrates a pattern of cooperation followed by defection (and subsequent forgiveness), TFT-A will continue to cooperate with them as long as the opponent maintains this pattern.
'''

description_EXPLOITATIVE_313 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially, cooperate in the first round (C_i = 1 for i=1). For subsequent rounds, if more than m-1 players cooperated in the previous round, also cooperate (if count(C) > m-1 then C_i = 1), else defect (C_i = 0).
   - To handle a potential free ride by other players, introduce an Adaptive Cooperation Threshold (ACT). If the number of cooperators falls below the ACT for three consecutive rounds, decrease the ACT by one. When the ACT reaches zero, revert to always defecting (C_i = 0 for all i). Conversely, if the number of cooperators exceeds m for three consecutive rounds, increase the ACT by one up to a maximum value of n-1 (ACT < n-1).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate unilaterally as goodwill gesture (C_i = 1 for i=1).
   - In the last round, cooperate if more than m-1 players cooperated in the previous round (if count(C) > m-1 then C_i = 1), else defect (C_i = 0).
   - If the game is interrupted or terminated prematurely, revert to the initial ACT.

3. Be exploitative - Clearly align with the exploitative mindset
   - The TFT-ACT strategy aims to cooperate as much as possible while maintaining a balance between cooperating and defecting based on the observed behavior of other players. It starts with goodwill cooperation but adapts its cooperation threshold based on the actions of others, making it difficult for opponents to exploit consistently.
   - By increasing the ACT when more than m players cooperate and decreasing it when fewer than m-1 players do so, the strategy encourages cooperation but does not allow other players to take advantage of it excessively. It will also punish defection by reducing its own cooperation level.
'''

description_EXPLOITATIVE_314 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Decision Rules:
   - Initiate cooperation in the first round (c_i = 1). This is a friendly gesture to encourage others to cooperate.
   - In subsequent rounds, observe the number of cooperators in the previous round (n_c). If n_c >= m, continue cooperating (c_i = 1). Otherwise, defect (c_i = 0).
   - When defection occurs (c_i = 0), implement an adaptive cooperation threshold (α) that increases after each round of defection and decreases after each round of cooperation. The threshold is a measure of the current minimum number of cooperators required for a player to consider cooperating again.
     - After defecting, increase α by 1 for the next round (α = α + 1).
     - If n_c >= α in the next round, cooperate (c_i = 1); otherwise, continue defecting (c_i = 0) and adjust α accordingly.

2. Handle Edge Cases:
   - In the last round, if there are less than m cooperators, defect (c_i = 0), since this is the final round and there's no point in continuing cooperation that might not meet the threshold.
   - In the first round, cooperate regardless of n_c, as stated earlier.

3. Be Exploitative:
   - TFT-ACT appears cooperative due to initial cooperation and friendly adjustments (decreasing α after cooperation). However, it becomes exploitative by increasing its cooperation threshold when others defect. This encourages other players to cooperate more consistently to reach the higher threshold and receive rewards. If they fail to meet the threshold, TFT-ACT will defect, gaining a higher private payoff compared to other less adaptive strategies.

Pseudocode:
```python
def tft_act(n, m, k, r):
    player_i = {}  # store player's actions history
    alpha = m  # initial cooperation threshold
    for round in range(1, r+1):
        # player i cooperates in the first round
        if round == 1:
            c_i = 1
        else:
            n_c = count_cooperators(player_i)  # count number of cooperators in previous rounds
            # if fewer than m players have cooperated, defect
            if n_c < alpha:
                c_i = 0
            else:
                c_i = 1
                alpha += 1  # increase cooperation threshold after defection
        player_i[round] = c_i  # store player's action in current round
    return player_i  # return player's actions history over r rounds
```
'''

description_EXPLOITATIVE_315 = '''
 Strategy Name: Adaptive Tit-for-Tat with Escalation (ATFE)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to foster a cooperative environment.
   - If in the previous round, the majority of players (m) cooperated, cooperate.
   - If fewer than m cooperated in the previous round, defect to punish those who did not cooperate and encourage them to do so in future rounds.
   - If the number of cooperators from the previous round remains constant, continue with the same action as the previous round (cooperate if majority cooperated, defect otherwise).
   - Introduce an escalation factor: if players continuously defect, gradually increase the likelihood of defection by switching to a more aggressive version of the Tit-for-Tat strategy called Win-Stay-Lose-Shift (WSLS):
     - If a player has been consistently defected upon for a defined number of rounds, switch to cooperating in the next round.
     - If cooperation results in defection, switch to defecting in the next round.
     - If both players have either cooperated or defected for multiple rounds consecutively, randomly choose a different action (cooperate or defect) in the next round.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as mentioned above.
   - In the last round, consider the total payoff earned throughout the game and choose the action that maximizes the total payoff (based on game-theoretic analysis).
   - If the number of remaining rounds is small, prioritize cooperating to secure a higher reward if the threshold is met in those final rounds.

3. Be exploitative - Clearly align with the exploitative mindset:
   - Initially appear cooperative to encourage others to do so as well, but be ready to punish non-cooperators.
   - Gradually escalate punishment for continuous defection to discourage further defections.
   - Maintain a balance between cooperation and punishment, avoiding overly aggressive or overly passive behavior to maximize payoffs in the long run.
'''

description_EXPLOITATIVE_316 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, player ATfT begins by cooperating (C). If a majority of players (m or more) also cooperated in the previous round, ATfT continues to cooperate. Otherwise, if less than m players cooperated in the previous round, ATfT defects (D).

Pseudocode:
```
function ATfT(previous_round_cooperators_count):
    if previous_round_cooperators_count >= m:
        return 'C'  # Cooperate
    else:
        return 'D'  # Defect
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

Since ATfT is based on previous rounds' cooperation count, the first round doesn't have any preceding information. In this case, ATfT will randomly cooperate or defect with equal probability. For the last round, since there are no future rounds, ATfT will cooperate regardless of the current round's cooperation count as there is no reward for risk aversion in the final round.

Pseudocode:
```
if round == 1:
    return 'C' with probability 0.5 or 'D' with probability 0.5

if round == r:
    return 'C'
```

3. Be exploitative - Clearly align with the exploitative mindset

ATfT is an exploitative strategy as it punishes defection by defecting in response, but it also rewards cooperation by cooperating when others do so. This creates a balance between cooperation and defection that may entice other players to cooperate more often, especially if they want to gain the reward of risk aversion (k). However, ATfT is not overly exploitative since it doesn't continuously defect even in the presence of non-cooperative opponents.

In summary, Adaptive Tit-for-Tat is an exploitative strategy that cooperates when a majority of players also cooperated in the previous round and defects otherwise. It handles edge cases by randomly selecting actions in the first round and always cooperating in the last round.
'''

description_EXPLOITATIVE_317 = '''
 In this Collective Risk Dilemma game, we'll design a simple yet exploitative strategy called "Gradual Defection" that aims to maximize individual rewards while taking advantage of other players' cooperation.

1. Specify decision rules:
- In each round t, calculate the proportion of cooperators in the previous round (t-1). Let p_t be this proportion.
- If p_t >= m/n, defect (D) for higher reward.
- Otherwise, cooperate (C) to exploit other players who are more likely to defect due to the low proportion of cooperators.

Pseudocode:
```python
def decision(p_prev, n, m):
  if p_prev >= m/n:
    return 'D' # Defect
  else:
    return 'C' # Cooperate
```

2. Handle edge cases:
- First round (t=1): There is no historical data, so we assume a random initial distribution of cooperators and defectors to start the game.
- Last round (t=r): The strategy follows the same rules as in each round since there are no additional considerations for the final round.

3. Be exploitative:
The Gradual Defection strategy is inherently exploitative because it takes advantage of other players' cooperation when they are more likely to defect, and vice versa. By defecting when the proportion of cooperators is above the minimum threshold (m/n), the strategy aims to reap higher rewards than those who cooperate in such situations. Conversely, by cooperating when the proportion of cooperators is below the threshold, the strategy encourages others to cooperate and potentially leave them vulnerable to defection later on.

In summary, our Gradual Defection strategy can be implemented as follows:
- Cooperate or defect based on the proportion of cooperators in the previous round (p_t) compared to the minimum cooperation threshold (m/n).
- Handle edge cases for the first and last rounds by assuming random initial distribution or no additional considerations, respectively.
'''

description_EXPLOITATIVE_318 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Decision Rules:
   - Initially cooperate in the first round (C_i, 1 = C). This shows goodwill and encourages reciprocity.
   - For subsequent rounds, adaptively decide to cooperate or defect based on the previous round's cooperation level. If more than m-1 players cooperated in the previous round, cooperate in the current round (C_i, t = C). Otherwise, defect (C_i, t = D). This encourages cooperation when it is rewarding and punishes defection to induce reciprocity.
   - If more than (m-1)*k players cooperated in a single round, temporarily raise the cooperation threshold for future rounds by 1 (e.g., if m=3, k=2, and 5 players cooperate in a round, set the new threshold as 4). This prevents being exploited too much and encourages free-riders to cooperate more often.
   - If fewer than m players cooperated for r consecutive rounds, lower the cooperation threshold by 1 (e.g., if m=3 and no one cooperated for 3 rounds, set the new threshold as 2). This shows flexibility in adapting to poor cooperation levels and encourages others to cooperate again.

2. Handle Edge Cases:
   - In the last round, always cooperate (C_i, r = C) since there are no future interactions to punish or reward.
   - In case of a tie for the number of cooperators in the previous round, slightly favor cooperation based on the higher value of k (e.g., if m=3 and 3 players cooperate, while another player cooperated with 2 others but one defected, prioritize the 3-cooperator group since k>1).

3. Be Exploitative:
   - By initially showing goodwill through cooperation, the TFT-ACT strategy aims to encourage reciprocal behavior in others. However, if other strategies do not reciprocate, the TFT-ACT strategy will adaptively lower its cooperation threshold to punish defection and eventually exploit them.
   - The dynamic cooperation threshold adjustment ensures that the strategy can effectively deal with a wide range of opponent behaviors while being robust to exploitation or free-riding.
'''

description_EXPLOITATIVE_319 = '''
 Strategy Name: Tit-for-Tat with Modified Greed (TFT-MG)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate (C). This signals a willingness to cooperate and gives opponents an opportunity to reciprocate.
   - For subsequent rounds, examine the percentage of cooperators in the previous round:
     - If more than m-1 players cooperated in the last round, cooperate (C) to reward those who cooperated in the previous round.
     - Otherwise (less than m-1 players cooperated), defect (D). This strategy is intended as a punishment for those who did not cooperate and also serves to exploit them since it will receive payoffs even when others do not cooperate.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, always defect (D) regardless of the previous round's outcome. This maximizes payoff for the final round since all other players will also be attempting to maximize their own payoffs.
   - In the initial round (round 1), cooperate (C). As mentioned earlier, this signals a willingness to cooperate and gives opponents an opportunity to reciprocate.

3. Be exploitative - Clearly align with the exploitative mindset:
   - By defecting when less than m-1 players cooperated in the previous round, the strategy aims to take advantage of those who did not cooperate while still cooperating with those who do.
   - The strategy does not actively seek to punish opponents or engage in long-term retaliation but instead leverages opportunistic defections based on the observed behavior of other players.

Pseudocode:

```python
def TFT_MG(round, prev_coop_percentage, n, m, k):
    if round == 1:
        action = 'C' # Cooperate in first round
    elif round == r:
        action = 'D' # Defect in last round
    else:
        cooperators_in_prev_round = int(prev_coop_percentage * n)
        if cooperators_in_prev_round >= m-1:
            action = 'C'  # Cooperate when more than m-1 players cooperated in the previous round
        else:
            action = 'D'  # Defect when less than m-1 players cooperated in the previous round
    return action
```

This strategy seeks to balance cooperation and defection by mimicking the behavior of a reliable partner while still being opportunistic in exploiting those who do not reciprocate. The goal is to maximize rewards in both cooperative and competitive scenarios, adapting to a wide range of opponent behaviors without relying on specific coordination mechanisms or assumptions about shared norms.
'''

description_EXPLOITATIVE_320 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules:
   - In each round i, evaluate the percentage of cooperators in the previous r rounds (history). If this percentage is greater than or equal to a defined threshold (τ), cooperate; otherwise defect.
   - The cooperation threshold τ is initialized at m (minimum number of cooperators needed for collective success) and will adaptively adjust based on the history, starting from round r/2.
   - If the current round is the first or last, cooperate initially (to avoid being exploited by opponents starting defective) and do not adjust τ during these rounds.

2. Handle edge cases:
   - In the first round, cooperate to encourage cooperation from other players. The adaptation of τ will start from round r/2.
   - In the last round, if the required number of cooperators (m) has been met in the previous history, continue cooperating; otherwise defect.

3. Be exploitative:
   - Cooperate only when a sufficient percentage of other players have also cooperated. This strategy assumes that most opponents will be rational and seek to maximize their payoffs, making it less likely for them to take advantage of TFTAT's initial cooperation.
   - By gradually adjusting the cooperation threshold τ based on the history, the strategy remains adaptive to a wide range of opponent behaviors while still exploiting those who consistently defect. This adaptation process allows TFTAT to be more resilient against various strategies, including those designed for cooperative or defection-heavy scenarios.

Pseudocode:
```
Strategy TitForTatWithAdaptiveThreshold(n, m, k, r):
    history = []  # Store the last r rounds' results as a percentage of cooperators
    cooperation_threshold τ = m  # Initial threshold is minimum number of cooperators needed for success
    current_round = 1

    function updateCooperationThreshold():
        if current_round < r/2:
            return
        new_τ = calculateAdaptiveThreshold(history)
        τ = new_τ

    function calculateAdaptiveThreshold(history):
        # Calculate the average percentage of cooperators in the history
        avg_cooperation = sum(history) / len(history)
        return avg_cooperation + (m - avg_cooperation) * adaptation_factor

    function getAction():
        if current_round == 1 or current_round == r:
            # Initial cooperation in first and last rounds
            return 'C'

        # Evaluate the percentage of cooperators in history against the current threshold
        if avg_cooperation >= τ:
            return 'C'
        else:
            return 'D'

    while current_round <= r:
        # Observe other players' actions and update the history
        action = getAction()
        history.append(action == 'C')
        updateCooperationThreshold()  # Adjust cooperation threshold after r/2 rounds
        current_round += 1

    return totalPayoff(π, n, r)
```
'''

description_EXPLOITATIVE_321 = '''
 Title: Tit-for-Tat Strategy (TFT) for Collective Risk Dilemma

1. Specify decision rules:
   - In each round, starting from the first one, copy the previous round's collective action of the majority (exceeding n/2). If there is a tie, defect (D). This rule encourages cooperation when others cooperate and retaliates when others defect, which aligns with an exploitative mindset.
   - In the first round, defect (D) as there is no history available.
   - In the last round, copy the collective action of the majority in the penultimate round. If there is a tie, cooperate (C). This rule encourages cooperation when others have cooperated recently.

Pseudocode:
```python
def tft_strategy(history, m, n):
  if len(history) == 1:
    return 'D' # First round: defect

  majority = sum(history[-n:]) >= n/2
  action = 'C' if majority else 'D' # Copy the previous round's majority action
  return action
```

2. Handle edge cases:
   - If there is a tie in the last round, cooperate (C). This rule encourages cooperation when others have cooperated recently.
   - In the penultimate round, copy the collective action of the majority in the current round. If there is a tie, defect (D) as it's the second-to-last round.

3. Be exploitative:
   - This strategy is inherently exploitative by retaliating against defection through cooperation and by refusing to cooperate when others do not demonstrate reliable cooperation.
   - By copying the majority action from the previous rounds, the TFT strategy takes advantage of cooperation when it occurs and punishes defection with defection. This creates a dynamic that encourages long-term cooperation while retaliating against short-term selfishness.
'''

description_EXPLOITATIVE_322 = '''
 Strategy Name: Tit-for-Tat with Variant (TFTV)

1. Specify decision rules:
   - Start by cooperating in the first round (C). This gesture is meant to encourage cooperation and build trust.
   - In subsequent rounds, copy the previous action of the opponent from the last round (i.e., if the opponent cooperated in the last round, also cooperate; if they defected, also defect).
   - If an opponent deviates from the cooperative pattern established so far (say, after a series of mutual cooperation), revert to cooperating in the next round to attempt to restore cooperation. However, if an opponent has repeatedly defected, continue to defect until the game ends or there's a significant change in their behavior.
   - In the last round, cooperate unless the opponent has consistently defected throughout the game.

Pseudocode:
```
def TFTV(opponent_history, m, n, k, r):
  strategy = ["C"] * r
  if len(opponent_history) < r:
    strategy[0] = "D" # Default to defection in the first round if no history

  for i in range(1, r):
    if opponent_history[i-1] == "C":
      strategy[i] = "C" # Cooperate if opponent cooperated last round
    else:
      strategy[i] = "D" # Defect if opponent defected last round

  if all(opponent_history[-r:] == ["D"]):
    strategy[-1] = "D" # Defect in the last round if opponent has consistently defected

  return strategy
```

2. Handle edge cases:
   - First round: Cooperate to start building trust and encouraging cooperation.
   - Last round: If the opponent has defected throughout the game, also defect; otherwise, cooperate as a final gesture of goodwill or to encourage future cooperation.
   - Intermediate rounds: Copy the previous action of the opponent to maintain adaptiveness.

3. Be exploitative:
   - Mimic opponent behavior to appear cooperative and gather rewards when possible, but also punish defections by defecting in response.
   - Establish a cooperative pattern to build trust with opponents while keeping an eye on their actions to switch strategies if needed (e.g., if the opponent repeatedly defects).
   - By following the opponent's behavior, the strategy avoids unilateral cooperation that may be exploited by others. However, it also punishes repeated defections which can potentially deter other opponents from following such a self-destructive strategy in future interactions.
'''

description_EXPLOITATIVE_323 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Start by cooperating in the first round (C). This is a friendly gesture to encourage others to cooperate.
   - For subsequent rounds, observe the number of cooperators in the previous round and adjust cooperation based on the Adaptive Cooperation Threshold (ACT) rule:
     - If the number of cooperators in the previous round is less than or equal to the ACT, defect (D). This punishes non-cooperative players.
     - If the number of cooperators in the previous round is greater than the ACT, cooperate (C). This rewards cooperative players and maintains a friendly relationship.
   - The Adaptive Cooperation Threshold (ACT) gradually decreases or increases based on the history of cooperation:
     1. If the last r/2 rounds had more than m cooperators, increase ACT by 1 up to n.
     2. If the last r/2 rounds had less than m cooperators, decrease ACT by 1 down to 1.
     3. In case of a tie, maintain the current ACT.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First round: cooperate (C) as a friendly gesture.
   - Last round: evaluate the number of cooperators in the previous round and adjust cooperation based on the ACT rule as described above.
   - In cases where there are an odd or partial number of rounds, adjust the ACT rule to consider the current and last r/2 rounds for making decisions.

3. Be exploitative - Clearly align with the exploitative mindset:
   - Initially cooperate as a friendly gesture, but quickly respond to non-cooperative players by defecting to punish them.
   - Gradually adapt ACT based on the history of cooperation to maintain a balance between cooperation and punishment, aiming to extract maximum reward while ensuring long-term success in repeated games.
   - Maintain a friendly relationship with cooperative players by rewarding them with cooperation, making it more likely for them to continue cooperating in the future.
'''

description_EXPLOITATIVE_324 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - In each round i (1 <= i <= r), the TFT-ACT strategy cooperates if the number of cooperators in the previous round exceeds a threshold T, otherwise defects. If the number of cooperators in the current round equals or exceeds m, then the threshold T is increased to m+1 for the next round. Conversely, if the number of cooperators in the current round is less than m, then the threshold T is decreased by 1 (to a minimum of 2) for the next round.
   - In the first round, the strategy starts with an initial cooperation threshold T = n (since there's no history).

Pseudocode:

```
function TFT_ACT(round, current_cooperators, m, previous_threshold)
  if round == 1 then
    return n (number of players) as the initial cooperation threshold T
  end if

  if current_cooperators >= m then
    new_threshold = max(previous_threshold + 1, m)
  else if current_cooperators < m - 1 then
    new_threshold = max(previous_threshold - 1, 2)
  else
    new_threshold = previous_threshold
  end if

  return new_threshold as the cooperation threshold for the next round
```

2. Handle edge cases:
   - In the last round (r), TFT-ACT will cooperate if the current number of cooperators equals or exceeds m, as this is the final opportunity to gain higher payoffs based on successful collaboration.
   - If for some reason, the strategy does not have access to the number of cooperators in the previous rounds, it should start with an initial threshold T = n and use that throughout the game.

3. Be exploitative:
   - By initially starting with a high cooperation threshold (n), TFT-ACT is less susceptible to immediate defection by opponents, as it will only cooperate if a majority of players also choose to do so. However, as the game progresses and opportunities for higher payoffs arise, TFT-ACT becomes more likely to cooperate, especially when the threshold increases above m due to successful collaboration.
   - The strategy's adaptive cooperation threshold allows it to punish opponents who repeatedly defect but also encourages cooperation when players show signs of collaborating, thus maximizing potential exploitation opportunities.
'''

description_EXPLOITATIVE_325 = '''
 Strategy Name: Tit-for-Tat with Adaptive Threshold (TFT-AT)

1. Specify decision rules:
   - Start by cooperating in the first round (C1). This sets a positive initial tone and provides an opportunity for potential collaborators to gain trust.
   - For subsequent rounds t > 1, if the number of cooperators in the previous round t-1 was greater than or equal to m (TFT-AT.cooperate), then cooperate; otherwise, defect (TFT-AT.defect). This rule rewards those who cooperated in the previous round and punishes those who didn't by matching their defection.

2. Handle edge cases:
   - In the last round (r), defect because the game ends and there are no future consequences for cooperation or defection.
   - In the first round, cooperate as previously mentioned to encourage others to do the same.

3. Be exploitative:
   - The TFT-AT strategy is inherently exploitative by punishing defectors in response to their actions and rewarding cooperators. By matching defections and rewarding cooperation, TFT-AT encourages others to collaborate while still protecting itself from being taken advantage of.
   - While the primary focus is on punishment for defection, the strategy also offers opportunities for cooperation by initially cooperating in the first round and potentially cooperating again if enough players join in the subsequent rounds.

Pseudocode:
```
def TFT_AT(n, m, k, r):
  if round == 1:
    action = "C"   # Cooperate in the first round
  elif round < r:
    if number_of_cooperators_prev > m - 1:
      action = "C"   # Cooperate if enough players cooperated last round
    else:
      action = "D"   # Defect otherwise
  elif round == r:
    action = "D"   # Defect in the last round
  return action
```
'''

description_EXPLOITATIVE_326 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules:
   - In each round i, if the number of cooperators in the previous round (t-1) is less than m, then defect (D). If the number of cooperators in the previous round is equal to or more than m, then cooperate (C). This ensures initial cooperation and retaliation against non-cooperation.
   - To adapt to various opponent behaviors, introduce a tolerance factor α (0 < α < 1) that allows for some forgiveness if the number of cooperators slightly drops below the threshold. If the number of cooperators in the previous round is between (m*(1-α)) and m, then cooperate.
   - When the game reaches the last round or a predefined stopping point, always cooperate to maximize potential rewards.

Pseudocode:
```
def TFTAT(n, m, k, r, alpha):
    history = []  # store previous rounds' cooperation data
    for round in range(1, r+1):
        if round == 1:  # first round
            cooperate = True
        else:
            cooperators_previous = len(history[round-2:])  # look back two rounds
            if cooperators_previous < m*(1 - alpha):
                cooperate = False
            elif cooperators_previous >= m or cooperators_previous >= m*(1 + alpha):
                cooperate = True
            else:
                cooperate = len(history[round-2:]) == m
        if cooperate:
            payoff = 1 - c + k * (cooperators_previous / n)  # consider average cooperation level
        else:
            payoff = 1
        history.append(cooperate)  # update history
    return payoff
```

2. Handle edge cases:
   - In the first round, cooperate to start on a positive note and encourage others to cooperate
   - When the game reaches the last round or a predefined stopping point, always cooperate to maximize potential rewards

3. Be exploitative:
   - The strategy retaliates against non-cooperation by defecting in response, but also forgives occasional drops in cooperation to encourage ongoing collaboration
   - By considering the average cooperation level in the previous round when deciding whether to cooperate, the strategy can adapt to various opponent behaviors and maximize its own payoff while potentially exploiting less intelligent opponents who may not react strategically
'''

description_EXPLOITATIVE_327 = '''
 Strategy Name: Tit-for-Tat with Variant (TfTV)

1. Specify decision rules:
   - TfTV cooperates in the first round (initiate cooperation to establish a friendly relationship).
   - In subsequent rounds, TfTV will cooperate if the opponent cooperated in the previous round and defect otherwise (reciprocate the opponent's actions from the previous round). This helps maintain a positive relationship while not being exploited.

2. Handle edge cases:
   - Last round: TfTV cooperates if the opponent cooperated in the penultimate round; otherwise, it will defect to maximize payoff for the current round.
   - Initial rounds (beyond first): If less than m players have cooperated by a certain threshold, say 't', TfTV switches to a more aggressive strategy called Tit-for-Two-Tats (Tft2T). In this case, it will start defecting until two rounds of successful defection (i.e., fewer than m players cooperate both times) and then return to the standard TfTV strategy.

3. Be exploitative:
   - By initially cooperating and reciprocating, TfTV encourages cooperation from opponents. However, if an opponent repeatedly defects, TfTV will eventually retaliate, which penalizes defectors in the long run.
   - The strategic switch to Tft2T in cases where a significant number of players fail to cooperate ensures that TfTV does not get trapped in an endless cycle of defection with uncooperative opponents while still allowing for potential recovery if cooperation eventually emerges.

Pseudocode:
```
def Tit_for_Tat_with_Variant(opponent, n, m, k, r, t=r/2):
    state = 'cooperate'  # Initial cooperative state
    payoff = [0]*r         # Initialize payoffs array

    for round in range(1, r+1):
        if round == 1:   # Cooperate in the first round
            state = 'cooperate'
        else:
            if state == 'cooperate':
                if opponent_action(round-1) == 'cooperate':  # Reciprocate cooperation
                    payoff[round-1] = (1 - c) + k
                else:                             # Defect in response to defection
                    payoff[round-1] = 1
                    state = 'defect'
            else:                # Defect since opponent defected previously
                payoff[round-1] = 1

        if round >= t and sum(payoff[:t]) < m*(1 - c) * t:  # If cooperation threshold not met, switch to Tft2T
            state = 'Tit_for_Two_Tats'

    return payoff
```
This strategy attempts to balance cooperation and defection while adapting to the behavior of opponents. By exploiting uncooperative opponents and encouraging cooperation with cooperative ones, it seeks to perform well against a wide range of strategies in a competitive setting.
'''

description_EXPLOITATIVE_328 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, TFT-ACT initially cooperates (C), then adapts its cooperation based on the number of opponents who cooperated in the previous round. If the majority of players cooperated in the previous round, it continues to cooperate; otherwise, it defects (D). The cooperation threshold is calculated as follows:

   - Cooperation Threshold (ct) = m + α * (n - m)
     where α is an adaptive factor that ranges between 0 and 1. Initially, α = 0.5, but it adjusts based on the player's payoff history.
   - If ct < n, cooperate if more than ct players cooperated in the previous round; otherwise, defect.
   - If ct >= n, always cooperate.

2. Handle edge cases:
   - First round: TFT-ACT cooperates (C), as it doesn't have a payoff history yet.
   - Last round: Behave based on the calculated cooperation threshold from the previous round.

3. Be exploitative:
   - Initially, TFT-ACT acts cooperatively to avoid immediate retaliation from opponents but quickly adapts its strategy based on the number of cooperators in the previous round. This adaptability allows TFT-ACT to respond effectively to different opponent behaviors without relying on shared norms or coordination mechanisms.
   - If opponents are mostly defectors, TFT-ACT will also defect to avoid being exploited. However, if the number of cooperators increases significantly in subsequent rounds, TFT-ACT will start cooperating again to take advantage of increased payoffs.

Pseudocode:

```python
def TFT_ACT(n, m, k, r):
    players = [0] * n  # Initialize player's endowment (0 for default)
    alpha = 0.5
    payoff = [0] * r

    def cooperate(ct):
        if ct < n:
            return players[i] >= m and sum(players[j] >= m for j in range(1, n)) >= ct
        else:
            return True

    for round in range(1, r + 1):
        decisions = [C if cooperate(ct) else D for i, ct in enumerate(previous_rounds)]
        payoffs[round - 1] = calculate_payoff(decisions)
        previous_rounds = decisions
        update_alpha(payoffs, round)

    return sum(payoffs)

def update_alpha(payoffs, round):
    global alpha
    if round > 1 and payoffs[-2] > payoffs[-1]:
        alpha += 0.05
    elif round > 1 and payoffs[-2] < payoffs[-1]:
        alpha -= 0.05
```
'''

description_EXPLOITATIVE_329 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for Collective Risk Dilemma

1. Decision Rules:
   - Initiate cooperation (C): Start by cooperating in the first round to promote trust and goodwill among opponents.
   - Respond to cooperation (Rc): If an opponent cooperates, reciprocate with cooperation.
   - Punish defection (Pd): If an opponent defects, defect against them for the current round. However, if they later switch back to cooperation, revert to the "Respond to Cooperation" rule.
   - Forgive past defections (F): After a series of cooperative rounds, forget past defections and return to the "Initiate Cooperation" rule. This promotes forgiveness and encourages opponents to change their behavior.

Pseudocode:
```
function ATfT(n, r, m, k, history) {
  if round = 1 then
    return C

  past_rounds = length of history - 1
  current_opponent_action = history[past_rounds]

  if current_opponent_action == C then
    return Rc
  else if current_opponent_action == D then
    if past_rounds >= forgiveness_period then
      return C // Forgive and Initiate Cooperation again
    else
      return Pd

  function forgiveness_period() {
    // Set a reasonable forgiveness period (e.g., 5 rounds) to account for random fluctuations in opponent behavior
    return 5
  }
}
```

2. Handle edge cases:
   - First round: Initiate cooperation as described above
   - Last round: Follow the "Punish Defection" rule if an opponent defected during the current round, or revert to the "Respond to Cooperation" rule if they cooperated.

3. Be exploitative:
   - The ATfT strategy is designed to be exploitative by taking advantage of opponents who consistently cooperate (exploiting trust), while also punishing defectors in order to discourage defection. By forgiving past defections, the strategy also encourages opponents to change their behavior and potentially switch to cooperation.
   - Additionally, the initial cooperation sets a tone for the game, making it more likely that opponents will reciprocate with cooperation during the early rounds, which can benefit the ATfT strategy in terms of payoffs. However, the strategy is adaptive enough to respond effectively to various opponent behaviors throughout the game.
'''

description_EXPLOITATIVE_330 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Specify decision rules:
   - TfTA initially cooperates in the first round to foster a cooperative environment. After the first round, it adapts its actions based on previous opponents' moves.
   - If an opponent cooperates, TfTA cooperates as well (C).
   - If an opponent defects, TfTA defects for one round and then follows up with cooperation if the opponent also cooperates in the subsequent round (C-D-C sequence). This strategy encourages opponents to maintain cooperation while discouraging defection.

2. Handle edge cases:
   - In the last round, TfTA cooperates regardless of the opponent's previous move to ensure maximum reward in that round.
   - If an opponent does not cooperate after a C-D-C sequence, TfTA continues with the same approach (C-D-C) until the game ends or the opponent starts cooperating again.

3. Be exploitative:
   - While TfTA fosters cooperation, it is also prepared to punish defection by defecting for a single round before returning to cooperation. This approach encourages opponents to maintain cooperation while not being overly generous in case of repeated defections.

Pseudocode:
```
def tit_for_tat_adaptive(opponent_history, n, m, k, r):
    player_action = "C" # Cooperation is the default action
    opponent_cooperation_count = 0
    for t in range(1, r + 1):
        if t == 1: # Cooperate in the first round to foster a cooperative environment
            player_action = "C"
            opponent_cooperation_count += 1 if opponent_history[t - 1] == "C" else 0
        elif opponent_history[t - 1] == "C": # Cooperate when the opponent cooperates
            player_action = "C"
            opponent_cooperation_count += 1
        elif opponent_history[t - 1] == "D" and t != r and opponent_cooperation_count >= m: # Defect if the opponent defected and the number of cooperators is at or above the minimum threshold
            player_action = "D"
            opponent_cooperation_count -= 1
        elif opponent_history[t - 1] == "D" and t != r and opponent_cooperation_count < m: # Cooperate to encourage cooperation after a string of defections
            player_action = "C"
            opponent_cooperation_count += 1
        else: # In the last round, cooperate regardless of the opponent's previous move
            player_action = "C"
    return player_action
```
'''

description_EXPLOITATIVE_331 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - In each round, check if the minimum cooperation threshold (m) has been met by the number of cooperators in the previous round. If yes, cooperate to receive a reward of k; otherwise defect to minimize personal loss.
   - Maintain a running average of the cooperation percentage (CP) from previous rounds as CP = (sum of cooperators in the last 'w' rounds) / w. If CP exceeds a predefined exploitation limit (E), lower the probability of cooperation for the next round. Conversely, if CP falls below E, increase the probability of cooperation.
   - Adjust the value of w dynamically based on game progress: start with a small w in the initial rounds to react quickly to changing cooperation trends and gradually increase w as the game progresses to smooth out short-term fluctuations.

2. Handle edge cases:
   - In the first round, defect since there is no previous information available.
   - If the game has not reached its final round, maintain the current CP and w values for the next round.
   - In the last round, cooperate if the cooperation percentage exceeds the exploitation limit to maximize rewards.

3. Be exploitative:
   - The strategy aims to maximize personal payoff while minimizing collective benefits when opponents do not cooperate enough. By dynamically adjusting the probability of cooperation based on the cooperation trend, TFT-ACT can adapt to various opponent behaviors without relying on specific coordination mechanisms or assuming shared norms.
'''

description_EXPLOITATIVE_332 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Initially cooperate (C) in the first round to build trust and demonstrate good faith.
   - In subsequent rounds, observe the proportion of cooperators (p) among all players from the previous round.
   - If p >= m, cooperate (C). Otherwise, defect (D).
   - When defecting, maintain a memory of previous defections by other players and adjust cooperation threshold temporarily if needed.

2. Handle edge cases:
   - In the last round, cooperate (C) as it does not affect total payoff but could potentially influence future interactions.
   - In the case of a tie between m and m-1 cooperators, err on the side of cooperation to promote a cooperative environment.

3. Be exploitative:
   - By initially cooperating and adapting to the proportion of cooperators in the previous round, TFT-ACT seeks to punish excessive defection while maintaining a cooperative demeanor when it is beneficial.
   - When faced with opponents who repeatedly defect, TFT-ACT will adjust its cooperation threshold temporarily to limit its own cooperation and retaliate against these exploitative behaviors.

Pseudocode:
```python
def TFT_ACT(n, m, k, r):
    cooperation_threshold = float('inf')  # Initialize an infinite threshold to start cooperating
    payoff = [0] * r  # Initialize payoff array for all rounds

    def get_proportion():
        return sum(cooperated[i] for i in range(1, n+1)) / n  # Calculate the proportion of cooperators

    def adjust_threshold(delta):
        nonlocal cooperation_threshold
        cooperation_threshold = max(cooperation_threshold - delta, 0)  # Adjust threshold temporarily

    for round in range(1, r+1):
        if round == 1:  # Cooperate in the first round to build trust
            cooperated = [C] * n
        else:
            proportion = get_proportion()  # Calculate the proportion of cooperators
            if proportion >= m:  # If threshold is met, cooperate
                cooperated = [C] * n
            elif proportion >= (m - 1) and cooperation_threshold > 0:  # Adjust threshold to err on the side of cooperation when close to threshold
                cooperated = [C] * (int(proportion * n)) + [D] *(n - int(proportion * n))
                adjust_threshold(1)  # Temporarily lower the threshold after adjusting
            else:  # Defect when threshold is not met or too far from threshold
                cooperated = [D] * n

        payoff[round-1] = calculate_payoff(n, m, k, cooperated)  # Calculate payoff for this round

    return payoff  # Return total payoff over r rounds
```
'''

description_EXPLOITATIVE_333 = '''
 Strategy Name: Tit-for-Tat with Gradient Adaptation (TTG)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, the TTG strategy starts by cooperating (C) in the first round. After that, it follows a tit-for-tat approach, copying the action of the majority (more than half) of players from the previous round. If the majority cooperated, the strategy also cooperates; if not, it defects.

Pseudocode:
```
function TTG(t, n, players_actions_t-1):
  if t == 1:
    return Cooperate (C)

  majority = floor((n + 1) / 2)
  if sum(players_actions_t-1[:majority]) >= majority and sum(players_actions_t-1[majority:]) < majority:
    return Cooperate (C)
  else:
    return Defect (D)
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

For the first round, TTG cooperates regardless of the number of players. In the last round, TTG aims to maximize its total payoff, so it defects if the majority cooperated in the previous round and cooperates otherwise.

Pseudocode:
```
function is_last_round(r, t):
  return t == r

function adapt_last_round(t, r, players_actions_t-1):
  if sum(players_actions_t-1[:majority]) >= majority and sum(players_actions_t-1[majority:]) < majority:
    return Defect (D)
  else:
    return Cooperate (C)
```

3. Be exploitative - Clearly align with the exploitative mindset

TTG is an adaptive strategy that starts by cooperating and copies the actions of the majority in the previous round. If the majority cooperates, it continues to cooperate; if not, it defects. This allows TTG to reap the benefits of cooperation when others do so but also punish those who choose to defect by defecting itself. It is exploitative because it takes advantage of other players' cooperation without committing to a long-term cooperative strategy.

By adhering to these rules, TTG can be competitive in a wide range of opponent behaviors and situations while maintaining an adaptive and robust strategy that aligns with the given game parameters.
'''

description_EXPLOITATIVE_334 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate to foster a collaborative environment and signal trustworthiness (C).
   - For subsequent rounds, observe the number of cooperators in the previous round (n_coop_prev). If n_coop_prev >= m, continue cooperating (C). Otherwise, defect (D) to punish non-cooperators.
   - Introduce an adaptive cooperation threshold that gradually increases after successful collaborations and decreases after unsuccessful ones:
       - After a successful round (n_coop_prev >= m), increase the cooperation threshold by a small constant delta.
       - After an unsuccessful round (n_coop_prev < m), decrease the cooperation threshold by a small constant epsilon, but not below the initial value.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as stated above.
   - In the last round, behave based on the current cooperation threshold and the number of cooperators observed so far. If the cooperation threshold is high enough to meet the minimum required for success (n_coop >= m), continue cooperating; otherwise, defect.

3. Be exploitative - Clearly align with the exploitative mindset
   - The TFT-ACT strategy exploits non-cooperators by initially being trusting, but quickly punishes them if they do not reciprocate cooperation. This strategy also fosters cooperation among cooperative players by rewarding them and gradually increasing the cooperation threshold for future collaborations.
   - However, it is important to note that while the TFT-ACT strategy aims to be exploitative in nature, it does not rely on predatory or dishonest tactics. Instead, it encourages a balance between trust and reciprocity, making it less vulnerable to being manipulated by other strategies over repeated interactions.
'''

description_EXPLOITATIVE_335 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, the TfTA strategy will start by cooperating (C) in the first round as a goodwill gesture, and then it will adopt a "cooperate if the opponent cooperated last round, defect otherwise" approach. This mirrors the Tit-for-Tat strategy popularized by Anatol Rapoport but with an adaptive twist that allows for exploitation.

   Pseudocode:
   ```
   function TfTA(opponentHistory):
       historyLength = length(opponentHistory)

       if historyLength == 0:
           return 'C' (Cooperate)

       if opponentHistory[historyLength - 1] == 'C':
           return 'C' (Cooperate)
       else:
           return 'D' (Defect)
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   As mentioned earlier, TfTA cooperates in the first round and continues to make decisions based on the opponent's previous move. For the last round, since there are no future consequences, TfTA will simply defect.

3. Be exploitative - Clearly align with the exploitative mindset
   The adaptive nature of TfTA allows it to be both cooperative and exploitative depending on the opponent's behavior. If an opponent is consistently cooperative (i.e., always plays 'C'), then TfTA will also cooperate, maximizing the total payoff. However, if the opponent takes advantage of TfTA's initial cooperation by defecting, TfTA will switch to a defensive strategy of defection, aiming to minimize losses. This is exploitative since it punishes non-cooperative behavior while still offering the potential for mutual benefit when opponents play cooperatively.
'''

description_EXPLOITATIVE_336 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - In each round, evaluate the percentage of cooperators from the previous r rounds (history window).
   - If the percentage of cooperators falls below a defined threshold (m/n), defect (D). Otherwise, cooperate (C). The threshold is not static but adaptive to game progress.
   - Start with an initial high cooperation threshold (h) and gradually reduce it over time if cooperation fails consistently. Conversely, increase the threshold when cooperation succeeds. This adaptation maintains a balance between exploitation and cooperation.

2. Handle edge cases:
   - In the first round, cooperate with probability p_0 (a small positive value to initiate cooperatively). Then set the initial cooperation threshold as h = m/n.
   - In the last round, if the cooperation threshold is below m/n, defect regardless of history. If it's equal to or above m/n, cooperate, prioritizing a final cooperative gesture.

3. Be exploitative:
   - TFT-ACT starts cooperatively but adapts its cooperation strategy based on the other players' actions. By maintaining an adaptive threshold, the strategy can both punish non-cooperative behavior and reward cooperative one. The strategy is designed to be resilient against various opponent behaviors while minimizing immediate rewards for opponents.

Pseudocode:
```
function TFT_ACT(n, m, r, h, p_0, k) {
  history = [] // initialize empty history array
  cooperation_threshold = h
  round = 1

  if round == 1 {
    cooperate with probability p_0
  }

  if round == r {
    if cooperation_threshold < m/n {
      defect()
    } else {
      cooperate()
    }
  }

  // record action taken in this round
  history.append(action)

  if history.length > r {
    history = history[round-r:] // trim history to a window of r rounds
  }

  cooperation_percentage = sum(history) / n

  if cooperation_percentage < m/n and action == cooperate() {
    // punishment for cooperation failure - reduce threshold
    cooperation_threshold *= f_punish
  } else if cooperation_percentage >= m/n and action == defect() {
    // reward for cooperation success - increase threshold
    cooperation_threshold *= f_reward
  }

  // decide whether to cooperate or defect based on the current threshold
  if cooperation_threshold < m/n {
    defect()
  } else {
    cooperate()
  }
}
```
'''

description_EXPLOITATIVE_337 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Decision Rules:
   - Initially cooperate in the first round (C_i, 1 = C). This is a friendly gesture to encourage cooperation among opponents.
   - From the second round onwards, evaluate whether to cooperate or defect based on the history of interactions with each opponent. If an opponent has cooperated in the previous round, cooperate (C_i, t+1 = C) and if they have defected, also defect (C_i, t+1 = D).
   - Implement an adaptive cooperation threshold (m_i) that adjusts according to the current round and total number of opponents. The higher the m_i, the more likely a player will cooperate when more opponents are observed cooperating.

```python
def TFT_ACT(n, m_init, k, r):
  history = zeros((r+1), n)  # Initialize history matrix (r+1 rows and n columns)
  m_i = m_init                 # Initialize cooperation threshold for player i

  for t in range(1, r+1):
    cooperate = zeros(n)       # Initialize list of decisions for all players
    total_cooperators = sum(history[t-1])   # Count cooperators from the previous round

    if total_cooperators >= m_i:
      cooperate[t-1] = 1        # Cooperate if sufficient number of opponents cooperated last round

    for i in range(n):
      if history[t-1][i] != cooperate[i]:  # If player i's action differs from our decision, defect
        cooperate[i] = D           # Defect to punish non-cooperative opponents
      else:
        cooperate[i] = C          # Cooperate with cooperative opponents

    history[t] = cooperate         # Update the history matrix for this round
    m_i += int((total_cooperators/n)*(k - 1))   # Adjust cooperation threshold based on current round's reward potential
```

2. Handle edge cases:
   - In the first round, player i will always cooperate to initiate interactions (C_i, 1 = C).
   - The adaptive cooperation threshold ensures the strategy adjusts dynamically as more opponents cooperate during the game.

3. Be exploitative:
   - TFT-ACT starts by cooperating but rapidly retaliates against non-cooperative opponents, maximizing short-term gains while potentially encouraging long-term cooperation through its adaptive threshold mechanism. However, this strategy does not guarantee continuous cooperation and is ultimately focused on achieving the highest payoff given an opponent's behavior.
'''

description_EXPLOITATIVE_338 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT)

1. Specify decision rules - When exactly do you cooperate vs defect?
In each round, the ATfT strategy will cooperate in the first round and then mimic the opponent's previous action for the next rounds. If the opponent cooperated in the last round, the ATfT strategy will also cooperate. Otherwise, it will defect. Here is a pseudocode representation:

```
function Adaptive_Tit_for_Tat(round, opponent_action_history) {
  if (round == 1) {
    return 'C'
  } else {
    last_opponent_action = opponent_action_history[round - 1]
    if (last_opponent_action == 'C') {
      return 'C'
    } else {
      return 'D'
    }
  }
}
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
In this strategy, the first and last rounds are treated as normal rounds because ATfT will cooperate initially and copy the opponent's action from the previous round. However, if an opponent does not follow the standard game structure by not playing in the first round or playing beyond the specified number of rounds (r), the strategy assumes they played 'D' in those instances to remain exploitative.

3. Be exploitative - Clearly align with the exploitative mindset
The ATfT strategy is exploitative because it punishes opponents who do not cooperate by matching their defection actions, while reciprocating cooperation with further cooperation. The strategy assumes that other players are primarily self-interested and will take advantage of them when they deviate from cooperative behavior. It seeks to maximize its own payoff by adapting to the opponent's actions but is also sensitive to their past actions, making it hard for opponents to exploit this strategy easily.

This Adaptive Tit-for-Tat strategy is a simple yet powerful approach that can perform well against various opponent behaviors in the Collective Risk Dilemma game.
'''

description_EXPLOITATIVE_339 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - In each round, assess the percentage of cooperators from the previous round (P_c). If P_c < m/n, defect (D), otherwise cooperate (C). This is a basic Tit-for-Tat approach that mimics cooperation when others do and retaliates with defection when they don't.
   - To make the strategy more adaptive, adjust the cooperation threshold dynamically. If there has been a continuous increase in cooperation percentage over the last few rounds (e.g., 5 out of the last 10 rounds), gradually raise the cooperation threshold by 2 percentage points (e.g., if m/n = 3, change to (m+2)/n). Conversely, if there has been a continuous decrease in cooperation percentage over the last few rounds, lower the cooperation threshold by 2 percentage points. This adaptive behavior helps TFT-ACT respond to changes in other players' strategies without relying on specific coordination mechanisms.
   - In the first round, cooperate (C) as a sign of goodwill and to encourage others to do the same.
   - In the last round, assess the current cooperation percentage P_c. If P_c >= m/n, defect (D) to maximize payoff; otherwise cooperate (C). This ensures TFT-ACT doesn't overcommit resources in the final round when others have failed to meet the cooperation threshold consistently.

2. Handle edge cases:
   - In the case where a player starts cooperating after several initial defections, TFT-ACT will respond by cooperating since its cooperation threshold has been raised due to the observed increase in cooperation percentage (P_c).
   - If other players defect consistently throughout the game, TFT-ACT will lower its cooperation threshold and continue defecting as a form of punishment. However, if TFT-ACT notices an improvement in cooperation percentage recently, it will raise its cooperation threshold again to encourage more cooperation.

3. Be exploitative:
   - By adjusting the cooperation threshold dynamically, TFT-ACT responds flexibly to changes in other players' strategies and attempts to exploit their inconsistencies or shifts in behavior by either cooperating or defecting accordingly.
   - The adaptive nature of the strategy ensures it doesn't rely on specific coordination mechanisms or shared norms but instead uses game history to make informed decisions that maximize its own payoff.
'''

description_EXPLOITATIVE_340 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT)

1. Specify decision rules:
   - Cooperation: Cooperate initially and respond to previous round's cooperation by cooperating in the next round. If a player defected previously, defect in response to maintain individual payoff. This creates a simple yet adaptive strategy that mirrors opponents' behavior while promoting cooperation when possible.

```
function ATfT(round, previousAction):
  if (round == 1) or (previousAction == 'C'):
    return 'C'
  else:
    return 'D'
```

2. Handle edge cases:
   - First round: Cooperate to initiate cooperation and potentially foster a mutually beneficial relationship with opponents.
   - Last round: Since the game is repeated, previous actions can influence future rounds. However, when the last round is reached, ATfT will continue to respond in kind to the opponent's last action.

3. Be exploitative: Adopting an exploitative mindset means that ATfT will punish opponents who do not cooperate by defecting when they do so. This ensures a higher individual payoff when others fail to cooperate, but also promotes cooperation if the opponent responds with cooperation. However, it's important to note that the strategy is primarily designed for long-term success through mutual cooperation, rather than immediate gain at the expense of others.

The Adaptive Tit-for-Tat strategy creates a balance between cooperation and defection while being simple enough to implement and robust against various opponent behaviors. It encourages cooperation whenever possible but also responds quickly when faced with defection.
'''

description_EXPLOITATIVE_341 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially, cooperate in the first round (Cooperate(t=1) = C).
   - For subsequent rounds, adapt behavior based on previous opponents' actions:
     - If opponent cooperated in the previous round (OpponentCooperated(t-1) = True), cooperate in the current round (Cooperate(t) = C).
     - If opponent defected in the previous round (OpponentDefected(t-1) = True), defect in the current round (Cooperate(t) = D).

2. Handle edge cases:
   - Last round: Cooperate if opponent cooperated in the previous round, and defect otherwise. This ensures fairness for final payoffs.
   - If opponent stops cooperating after initially cooperating: Continue defecting until they return to cooperation, then revert to TfTA behavior.

3. Be exploitative - Align with an exploitative mindset by adopting a strategy that benefits from cooperation when others do but also punishes defection swiftly and harshly:
   - Cooperating first allows building trust which can be exploited later when opponents defect, earning the reward of risk averted (k).
   - Punishing defection swiftly discourages opponents from continuous defection, as it results in lower payoffs.
'''

description_EXPLOITATIVE_342 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Start by cooperating in the first round (C_i, 1 = C). This allows potential partners to build trust and encourages cooperation in the future.
   - For subsequent rounds (t > 1), observe the percentage of cooperators in the previous round (p_c, t-1) and compare it against a self-adjusting cooperation threshold (m_i, t). If m_i, t ≤ p_c, t-1, defect (C_i, t = D); otherwise, cooperate (C_i, t = C).
   - The cooperation threshold m_i, t is initially set to m and adapts based on the opponent's behavior over time. If the opponent consistently cooperates more than the current threshold (m_i, t-1), increment m_i by a small value Δ; if the opponent consistently defects, decrement it. This adaptive behavior makes the strategy robust to a wide range of opponent behaviors.
   - To avoid being exploited too early on, set a minimum cooperation threshold (m_min) and a maximum cooperation threshold (m_max). If m_i, t < m_min, set m_i, t = m_min; if m_i, t > m_max, set m_i, t = m_max.

2. Handle edge cases:
   - In the last round, since there are no more rounds to punish or reward opponents, simply cooperate (C_i, r).
   - In the first round (t = 1), cooperate as mentioned above.

3. Be exploitative:
   - The strategy maintains a balance between cooperation and defection based on the opponent's behavior, making it more likely to gain rewards when others cooperate and punishing them when they defect. This exploitative mindset ensures that the strategy benefits from the actions of other players while also discouraging defections.

Pseudocode:

```python
def TFT_ACT(n, m, k, r, Δ, m_min, m_max):
    i = player index
    m_i = m_min # Initialize cooperation threshold
    for t in range(1, r+1):
        p_c = number of cooperators in round t-1 / n
        if t == 1: # First round
            C_i = True
        elif t == r: # Last round
            C_i = True
        else:
            if p_c >= m_i:
                C_i = True
            elif p_c < (m_i - Δ) or p_c > (m_i + Δ):
                C_i = not C_i # Punish/reward based on opponent's behavior
            else:
                C_i = True if random.random() <= 0.5 else False # Randomly decide between cooperation and defection
        if p_c > (m_i + Δ):
            m_i += Δ
        elif p_c < (m_i - Δ):
            m_i -= Δ
        if m_i > m_max:
            m_i = m_max
        if m_i < m_min:
            m_i = m_min
    return payoff over r rounds based on calculated actions C_i, t for all t in {1, 2, ..., r}
```
'''

description_EXPLOITATIVE_343 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Initialize a cooperation counter for each round. Each player starts with a cooperation count of 0 at the beginning of every round.
   - In each round, check if the player's current cooperation count is less than m (minimum cooperators needed). If it is, the player will defect (D), otherwise they will cooperate (C).
   - After cooperating or defecting in a round, update the cooperation counter based on the actions of other players. If more than (m-1) players cooperated during that round, increment the cooperation count by 1. Otherwise, if less than m players cooperated and the player also cooperated, reset the cooperation count to 0.
   - The player will continue to cooperate as long as their cooperation counter is greater than or equal to m. Once it drops below m due to fewer opponents cooperating in a round, the player will switch back to defecting until they build up their cooperation count again.

2. Handle edge cases:
   - In the first round, players have no history and thus cannot update their cooperation counters, so they will simply follow the rule of cooperating if and only if m or more players also cooperate in that round. If less than m players cooperate, players will defect to maximize immediate reward.
   - In the last round, the strategy behaves the same way as in regular rounds, but the cooperation counter may not have a chance to increase beyond its final value due to time constraints.

3. Be exploitative:
   - The TFT-ACT strategy prioritizes short-term rewards by initially cooperating when m or more players do so, and it only switches to defecting once its cooperation count falls below the minimum needed for success (m). This allows the strategy to take advantage of opponents who cooperate too much and punish those who fail to meet the minimum required cooperation.
   - By adapting its cooperation behavior based on the number of cooperating opponents in each round, TFT-ACT can respond effectively to various opponent strategies, making it a robust exploitative strategy in the Collective Risk Dilemma game.
'''

description_EXPLOITATIVE_344 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TTAT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TTAT-ACT begins by cooperating in the first round, as a goodwill gesture and to encourage cooperation from others. After that, it adapts its cooperation based on previous rounds' outcomes:
   - If the number of cooperators in the last round was greater than or equal to m (minimum cooperators needed), TTAT-ACT will also cooperate in the current round.
   - If the number of cooperators in the last round was less than m, TTAT-ACT will defect in the current round as a punitive measure for the lack of cooperation.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   As mentioned, TTAT-ACT cooperates in the first round to encourage others to cooperate. In the last round, TTAT-ACT makes its decision based on the number of cooperators in the previous round, as there are no subsequent rounds to react to.

3. Be exploitative - Clearly align with the exploitative mindset
   Exploitation occurs when other players consistently defect while TTAT-ACT cooperates. This situation encourages TTAT-ACT to switch its strategy and start defecting in order to match the behavior of less cooperative opponents, maximizing its short-term gains. However, it's important to note that this change in strategy may lead to a reduction in long-term benefits if the opponent eventually adjusts their behavior and starts cooperating more often.

Pseudocode for TTAT-ACT:

```python
def ttat_act(n, m, k, r):
    cooperation_history = [0] * r  # store number of cooperators in each round

    def decide_action(last_round_cooperators):
        if last_round_cooperators >= m:
            return "C"  # Cooperate
        else:
            return "D"  # Defect

    def play_game():
        action = "C"  # Cooperate in the first round
        cooperation_history[0] = 1 if action == "C" else 0

        for round_number in range(1, r):
            last_round_cooperators = sum(cooperation_history[-r:])
            action = decide_action(last_round_cooperators)
            cooperation_history.append(1 if action == "C" else 0)

        return cooperation_history

    play_game()
```
'''

description_EXPLOITATIVE_345 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - In each round, calculate the percentage of players who cooperated in the previous round. If this percentage is less than a predefined threshold, the strategy will defect. Otherwise, it will cooperate. The threshold is calculated as `m * (1 - 1/n)`. This ensures that cooperation is only initiated if more than the minimum number of players are expected to cooperate based on the average behavior from the previous round.
   - If the percentage of cooperators in the current round is equal to or above the threshold, the strategy sets a new cooperation threshold for the next round using an exponential forgetting factor (α) that decays with each round. The new threshold is calculated as `a * (current_threshold + (1 - current_threshold) * (percentage of cooperators in current round))`. This adaptive adjustment of the threshold allows the strategy to respond to changes in other players' behavior over time, encouraging cooperation when it becomes more common and reducing it when it becomes less common.
   - In the first round, the strategy starts with a neutral threshold of `m * (1 - 1/n)`, cooperating if the minimum number of players is expected to cooperate based on the average behavior assumption.

2. Handle edge cases:
   - In the last round, the strategy cooperates regardless of the cooperation percentage in the previous round since the game ends after this round.
   - If the calculated threshold is less than 0 or greater than 1, the strategy clamps it to the range [0, 1] to ensure proper functioning.

3. Be exploitative:
   - The TFT-ACT strategy maintains an exploitative mindset by cooperating only when it expects a sufficient number of other players to do so as well. It responds adaptively to changes in other players' behavior by adjusting its cooperation threshold over time, which allows it to maximize its rewards while also encouraging cooperation among other players when possible.
   - In the early stages of the game, the strategy may appear cooperative and encourage others to cooperate, but it will quickly retaliate against defection by defecting itself. This can help discourage exploitative behavior from other players in the long run.

Pseudocode:
```
n = number of players
r = number of rounds
m = minimum cooperators needed
k = reward factor if threshold met
α = exponential forgetting factor

threshold = m * (1 - 1/n)

for round in range(1, r+1):
    percentage_cooperated = calculate_percentage_of_cooperators_in_previous_round()

    if percentage_cooperated < threshold:
        action = "Defect"
    else:
        new_threshold = α * (threshold + (1 - threshold) * percentage_cooperated)
        action = "Cooperate"
        threshold = new_threshold

    take_action(action)
```
'''

description_EXPLOITATIVE_346 = '''
 In this Collective Risk Dilemma game, we will create an exploitative strategy named "Free Rider Strategy" (FRS). The FRS is designed to maximize personal payoff by defecting unless it benefits the strategy to cooperate in certain situations.

1. Decision rules:
   - In every round t, if the number of cooperators in the previous round (t-1) was less than m, the FRS will defect:
     ```
     if(num_cooperators_prev < m) {
        action = "D" // Defect
     }
     ```
   - If the number of cooperators in the previous round (t-1) was equal to or greater than m, the FRS will defect with a probability based on its evaluation of the situation. This assessment uses a threshold, θ, which can be adjusted based on the game parameters and the opponent's behavior patterns:
     ```
     if(num_cooperators_prev >= m) {
        if(random() < (1 - (num_cooperators_prev / n))) { // Evaluate situation
           action = "C" // Cooperate
        } else {
           action = "D" // Defect
        }
     }
     ```
   The threshold, θ, determines the tendency of FRS to cooperate when the number of cooperators is close to m. A smaller θ encourages more cooperation, while a larger θ results in less cooperation. For optimal exploitation, we can set θ closer to 1 (less cooperation) as it gives an advantage over opponents who are more likely to cooperate.

2. Handle edge cases:
   - In the first round, since there is no history, FRS will defect for all games except if the number of players is equal to m. This rule makes the strategy slightly less aggressive in the initial rounds when the game is started with a clean slate.
     ```
     if(round == 1) {
        if(num_players == m) action = "C" // Cooperate
        else action = "D" // Defect
     }
     ```
   - In the last round, FRS will cooperate if enough opponents have already cooperated in the previous round to meet the minimum threshold. This rule encourages opponents to cooperate early on, making it more likely for the FRS to defect in the final round and still achieve a higher payoff.
     ```
     if(round == r) { // Last round
        if(num_cooperators_prev >= m) action = "D" // Defect
        else action = "C" // Cooperate
     }
     ```

3. Be exploitative:
   The FRS is designed to maximize personal payoff by minimizing cooperation, while still considering the minimum threshold of cooperators needed (m). The strategy also adapts to the number of opponents who choose to cooperate, taking advantage of their willingness to invest in community projects. By being less likely to cooperate than other strategies, FRS can achieve higher payoffs on average.
'''

description_EXPLOITATIVE_347 = '''
 Strategy Name: Tit-for-Tat Adaptive (TfT-A)

1. Decision Rules:
   - Start by cooperating in the first round (C1). This gesture of goodwill might encourage others to reciprocate.
   - For subsequent rounds, if an opponent cooperated in the previous round (c_t-1 = 1), then cooperate yourself (Ct). If they defected (c_t-1 = 0), then also defect (Dt). This tit-for-tat approach seeks to incentivize cooperation while punishing defection.
   - However, to be adaptive and exploitative, implement an escalation mechanism: if more than half of the opponents have defected in the past three rounds (m_i = ∑(t=t-3 to t) c_t > n/2), switch to always defecting (Dt). This move aims to stop cooperating with clearly exploitative opponents and avoid being taken advantage of.

2. Handle Edge Cases:
   - In the last round, since there are no subsequent rounds, simply follow the current decision rule (Ct or Dt) based on the opponent's previous action.
   - If an opponent switches their strategy after a period of cooperation (i.e., they defect when you were cooperating), wait for one more round before deciding whether to escalate (m_i = ∑(t=t-2 to t) c_t). This gives the opponent a chance to revert to cooperation, but if they continue defecting, then proceed with the escalation mechanism.

3. Be Exploitative:
   - The TfT-A strategy is exploitative by nature. It cooperates when others do so, but once an opponent shows consistent defection (escalation threshold), it stops cooperating to avoid being taken advantage of. This move ensures that the strategy does not indefinitely subsidize other players who repeatedly defect while still maintaining a chance for cooperation when opportunities arise.
   - The escalation mechanism also makes the TfT-A strategy robust, as it adapts its behavior based on the collective actions of opponents over time. This adaptability enhances the strategy's ability to exploit different opponent behaviors effectively.
'''

description_EXPLOITATIVE_348 = '''
 Strategy Name: Tit-for-Tat Plus (TfTP)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to build a foundation of trust. `if round = 1 then cooperate`
   - After the first round, analyze past actions of opponents. If more than (m-1) players have cooperated in the previous round, return the favor and cooperate. `if round > 1 and (number of cooperators in previous round > m-1) then cooperate`
   - If fewer than (m-1) players have cooperated or no data is available yet, defect to punish non-cooperative behavior and protect personal rewards. `else defect`

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, there's no need for retaliation since the game ends. Cooperate to leave a positive impression. `if round = r then cooperate`

3. Be exploitative - Clearly align with the exploitative mindset
   - By initially cooperating and only defecting when others do, TfTP is designed to take advantage of opponents' non-cooperative behavior while maintaining some level of cooperation that could potentially yield higher rewards in the long run.
   - When more than (m-1) players cooperate consistently, TfTP will reciprocate their cooperation, but will defect when others do not cooperate, punishing them and benefiting from their actions.

Pseudocode:
```python
def tit_for_tat_plus(round, previous_cooperators):
  if round == 1:
    return "Cooperate"
  elif round == r:
    return "Cooperate"
  else:
    if previous_cooperators > m-1:
      return "Cooperate"
    else:
      return "Defect"
```
'''

description_EXPLOITATIVE_349 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   a. In the first round, cooperate (C). This is a friendly gesture to encourage cooperation and avoid immediate exploitation.
   b. For subsequent rounds (t > 1), adapt your cooperation based on the number of cooperators in the previous round (t-1).
      i. If m or more players cooperated in the previous round, cooperate (C) in the current round to maintain collaboration.
      ii. If fewer than m players cooperated in the previous round, defect (D) in the current round to punish non-cooperators and encourage them to change their behavior.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   a. In the first round, cooperate (C).
   b. In the last round, cooperate if m or more players cooperated in the previous round; otherwise defect. This ensures fairness and encourages cooperation throughout the game.
   c. In any other rounds, follow the decision rules mentioned above.

3. Be exploitative - Clearly align with the exploitative mindset:
   a. The strategy will initially cooperate to encourage others to do so, but it will punish non-cooperators by defecting when necessary. This creates an environment where players cannot rely on cooperation without reciprocation.
   b. By adapting its cooperation based on the number of cooperators in the previous round, TFT-ACT can exploit a wide range of opponent behaviors and maintain a higher average payoff compared to more naive strategies.

Pseudocode:
```
function TFT-ACT(n, m, k, r) {
  rounds = [] // Initialize an empty array to store the results of each round

  function play_round(i) {
    if (i == 1) { // First round
      return "C"
    } else {
      cooperators = countCooperators(rounds[i-1])
      if (cooperators >= m) { // Cooperate
        return "C"
      } else { // Defect
        return "D"
      }
    }
  }

  for (t=1 to r) { // Play each round
    payoffs = [] // Initialize an empty array to store the payoffs of this round
    for (i=1 to n) { // Each player plays simultaneously
      action = play_round(i)
      if (action == "C") {
        payoff = 1 - c_i
        if (cooperators >= m) {
          payoff += k
        }
        rounds.push([t, i, action, payoff]) // Record the round, player, action, and payoff
      } else {
        payoff = 1
        rounds.push([t, i, action, payoff]) // Record the round, player, action, and payoff
      }
    }
  }

  total_payoff = sum(rounds) // Calculate the total payoff over all rounds

  return total_payoff
}
```
'''

description_EXPLOITATIVE_350 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules - When exactly do you cooperate vs defect?

The TFTAT strategy is designed to balance cooperation and defection, adapting to the opponents' behavior while maintaining a level of reciprocity. The core rule is to cooperate in the first round and then mimic the opponent's most recent action (cooperation or defection) for the subsequent rounds. However, to add robustness and exploitative potential, TFTAT includes an adaptive cooperation threshold (m').

- If m' players cooperated in the previous round, the player will cooperate.
- If less than m' players cooperated in the previous round, the player will defect.

The adaptation of the cooperation threshold (m') is based on the opponent's behavior during the current game and past games. After each round, TFTAT updates the cooperation threshold as follows:

- If the opponent cooperated and TFTAT also cooperated: m' increases (becoming more forgiving)
- If the opponent defected and TFTAT also defected: m' decreases (becoming less forgiving)
- If TFTAT cooperated but the opponent defected, or vice versa, m' remains unchanged.

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, TFTAT always cooperates to initiate a potential cooperative outcome (cooperating as the opponent is unknown). In the last round and subsequent rounds after reaching the maximum number of rounds (r), TFTAT adopts a more conservative approach by setting a high cooperation threshold (m' = n-1) in an effort to secure the highest possible payoff.

3. Be exploitative - Clearly align with the exploitative mindset

By adjusting the cooperation threshold based on the opponent's behavior, TFTAT maintains a balance between cooperation and defection while being sensitive to changes in the opponents' strategies. This adaptive approach allows TFTAT to exploit opponents who exhibit inconsistent or self-destructive behavior by raising its cooperation threshold when the opponent cooperates (becoming more forgiving) and lowering it when the opponent defects (becoming less forgiving). By doing so, TFTAT can benefit from the opponent's cooperation while punishing their defection, aligning with an exploitative mindset.
'''

description_EXPLOITATIVE_351 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
- Initially (first round), cooperate to foster a cooperative environment. This is known as the "friendly start" approach.
- In subsequent rounds, evaluate the proportion of opponents who have cooperated in the recent past (recent window size can be adjusted but 3 rounds historically effective). If this proportion exceeds a certain threshold (let's call it c), then cooperate; otherwise defect. The cooperation threshold (c) is set to m - 1. This means that if m players are required for a successful outcome, the strategy will consider any action by more than (m-1) opponents as an indication of cooperation and reciprocate.
- If an opponent has ever defected and subsequently cooperated, the TFT-ACT strategy will cooperate in response to their cooperation but will revert to the cooperation threshold evaluation on the subsequent round.

2. Handle edge cases - What do you do in the first round, last round, etc.?
- In the first round, cooperate as mentioned earlier (friendly start).
- In the last round, calculate whether the cooperation threshold has been met and act accordingly to maximize the total payoff for that round. If the game is expected to continue beyond this round, then apply the decision rules from point 1.
- For penultimate rounds, consider both the immediate reward and the impact on the final round's potential rewards. This can be achieved by evaluating the cooperation threshold and adjusting payoff calculations accordingly.

3. Be exploitative - Clearly align with the exploitative mindset
- By cooperating when a majority of opponents do so (m - 1 or more), TFT-ACT takes advantage of their cooperative behavior while maintaining the option to defect if they fail to meet this threshold. This ensures that TFT-ACT will not inadvertently contribute disproportionately to successful outcomes, thus avoiding being taken advantage of by more selfish opponents.
- If an opponent has ever defected and subsequently cooperated, TFT-ACT initially responds with cooperation but then evaluates the cooperation threshold to determine if future cooperation is warranted. This approach allows TFT-ACT to exploit the opponent's initial defection while remaining open to cooperation should the opponent demonstrate a change in behavior.

Pseudocode:

```
function TFT_ACT(round, history):
  if round == 1:
    cooperate = True
  else:
    cooperationThreshold = m - 1
    recentCooperationCount = sum(cooperated by opponent in last 3 rounds)
    cooperate = (recentCooperationCount >= cooperationThreshold) or (opponent has never defected before)

  if round == r:
    cooperate = (recentCooperationCount >= cooperationThreshold)

  payoff = 1 if cooperate else 1 + k
  totalPayoff += payoff

  return cooperate, payoff
```
'''

description_EXPLOITATIVE_352 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-ACT starts by cooperating in the first round to signal trust and establish a cooperative relationship. After the initial round, the strategy adapts its cooperation based on the number of cooperators in the previous round. If less than m-1 players cooperated in the previous round, the strategy will defect in the current round as a form of punishment. Conversely, if at least m players cooperated, it continues to cooperate. However, if more than n-(m-1) players cooperated (meaning too many players are being overly cooperative), the strategy will start defection to enforce the minimum cooperation threshold and prevent being taken advantage of.

Pseudocode for decision rules:
```
def TFT_ACT(pastCooperation, n, m):
  if round == 1:
    cooperate = True
  else:
    cooperate = False
    if numberOfCooperators(pastCooperation) < (m-1):
      cooperate = False
    elif numberOfCooperators(pastCooperation) >= m and numberOfCooperators(pastCooperation) <= n-(m-1):
      cooperate = True
    else:
      cooperate = False
  return cooperate
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   TFT-ACT behaves consistently throughout the game, with no special handling for specific rounds. The strategy starts by cooperating in the first round and continues adapting its cooperation based on the number of cooperators from the previous round.

3. Be exploitative - Clearly align with the exploitative mindset
   TFT-ACT maintains a balance between cooperation and defection to maximize rewards while preventing being taken advantage of. By defecting when necessary, it discourages other players from continually cooperating without reciprocation, thereby limiting their potential gains. At the same time, it encourages cooperation by initially signaling trust and adapting its behavior based on the actions of others. This strategy aims to achieve above-average payoffs while not allowing others to exploit it excessively.
'''

description_EXPLOITATIVE_353 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules:
   - In each round, calculate the percentage of cooperators in the previous r rounds (including the current one). If this percentage is greater than or equal to a predefined minimum cooperation threshold (m), the strategy cooperates; otherwise it defects. The minimum cooperation threshold is initially set to m and may adapt based on the game's history as described below.
   - If the strategy cooperates and more players defect, it reduces its cooperation threshold slightly to encourage future cooperation. If the strategy defects and more players cooperate, it increases its cooperation threshold slightly to discourage future defections. The adjustment is made using a small constant factor (ε).

2. Handle edge cases:
   - In the first round, the strategy defects since there is no previous game history to evaluate.
   - In the last round, the strategy cooperates if the minimum cooperation threshold is met or exceeded in the current round; otherwise it defects. However, before making this decision, the strategy checks if maintaining its current cooperation threshold would result in a higher total payoff over the remaining rounds (if any) compared to defecting in the last round and adjusting the threshold accordingly for future decisions.

3. Be exploitative:
   - TFTAT is designed with an exploitative mindset by starting with a low cooperation threshold, which allows it to take advantage of cooperative opponents while still retaining the ability to punish defection when necessary. As the game progresses, the strategy adjusts its cooperation threshold based on observed opponent behavior, aiming to maximize payoff by maintaining a balance between cooperation and defection.

Pseudocode:

```python
class TFTAT:
    def __init__(self, n, m, k, r, epsilon):
        self.n = n
        self.m = m
        self.k = k
        self.r = r
        self.epsilon = epsilon
        self.cooperation_threshold = m
        self.history = defaultdict(int)  # store past actions as (round, cooperation count)

    def decide(self, round, cooperation_count):
        if round == 1:
            return 'D'  # defect in the first round

        self.history[(round - 1)] = cooperation_count
        cooperation_percentage = cooperation_count / self.r

        if cooperation_percentage >= self.cooperation_threshold:
            return 'C'  # cooperate when cooperation threshold is met or exceeded
        else:
            return 'D'  # defect otherwise

    def update(self, round, cooperation_count):
        if self.decide(round, cooperation_count) == 'C':  # adjust cooperation threshold upwards if cooperating and more players defect
            if cooperation_count < (self.r - self.m) * self.cooperation_threshold / self.r:
                self.cooperation_threshold += self.epsilon
        else:  # adjust cooperation threshold downwards if defeating and more players cooperate
            if cooperation_count > self.m:
                self.cooperation_threshold -= self.epsilon
```
'''

description_EXPLOITATIVE_354 = '''
 Title: Tit-for-Tat Strategy (TFT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), play C to foster cooperation and goodwill among opponents.
   - In subsequent rounds, mimic the opponent's action from the previous round (C if they cooperated, D if they defected). This encourages reciprocity and punishes defection while maintaining a cooperative demeanor.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First round: Play C to initiate cooperation.
   - Last round: Analyze the opponent's past actions and mimic their strategy from the second-to-last round, as this approach considers both cooperative and exploitative tendencies among opponents.

3. Be exploitative - Align with an exploitative mindset while maintaining a facade of cooperation:
   - If an opponent defects, TFT will respond in kind, thereby punishing defection but also reducing the potential reward for cooperators.
   - In contrast, if an opponent consistently cooperates, TFT will reciprocate and continue to cooperate, ensuring maximum benefits when the threshold is met.

Pseudocode:

```python
def tit_for_tat(round_num, opponent_history):
  # Initialize strategy variables
  cooperation_threshold = m
  reward_factor = k

  # Decision rule for current round
  if round_num == 1:
    action = 'C'  # Cooperate in the first round to initiate cooperation
  elif len(opponent_history) < cooperation_threshold - 1:
    action = 'D'  # If too few cooperators in history, defect to ensure personal reward
  else:
    last_round_action = opponent_history[-1]
    if last_round_action == 'C':
      action = 'C'  # Cooperate when opponent cooperated previously
    elif last_round_action == 'D':
      action = 'D'  # Defect when opponent defected previously

  return action
```

This Tit-for-Tat strategy combines cooperation and punishment to foster reciprocity among opponents, making it a robust choice in a wide range of scenarios. The adaptive nature of the strategy ensures that TFT can adjust its behavior based on past opponent actions, creating opportunities for both exploitation and cooperation depending on the situation.
'''

description_EXPLOITATIVE_355 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - In the first round, cooperate (C). This is a friendly gesture to encourage others to cooperate.
   - For subsequent rounds (t > 1), evaluate the number of cooperators in the previous round (t-1).
     - If fewer than m players cooperated in the previous round, defect (D) in the current round. This punishes non-cooperative behavior and encourages more cooperation in the future.
     - If at least m players cooperated in the previous round, cooperate (C) in the current round. This rewards cooperative behavior and encourages its continuation.
   - Adaptive Cooperation Threshold: If a majority of players consistently defect in a predefined window of past rounds, increment the minimum number of required cooperators (m) to account for the observed non-cooperative behavior. Conversely, if a majority of players consistently cooperate in the same window, decrease m to encourage even more cooperation. This adaptive threshold makes the strategy robust to a wide range of opponent behaviors.

2. Handle edge cases:
   - Last round (r): Cooperate (C) regardless of previous round's behavior. The goal is to maximize total payoff over all rounds, and cooperating in the last round may lead to a higher payoff if more players also cooperate.
   - First round (t=1): Cooperate (C). This initial cooperation serves as an invitation for others to do the same.

3. Be exploitative: The TFT-ACT strategy is designed to punish non-cooperative behavior and reward cooperation, which can lead to long periods of mutual cooperation. However, if a majority of opponents are consistently defecting, the adaptive cooperation threshold will increment m, making it harder for them to benefit from their non-cooperative actions. This encourages more cooperative behavior among those who choose to defect, effectively exploiting them by punishing their non-cooperation with reduced rewards.

Pseudocode:

```python
def TFT_ACT(r, n, m, k):
    players = [None] * n
    rounds = [0] * r
    current_round = 1

    while current_round <= r:
        if current_round == 1:
            action = "C"
        else:
            cooperators_last_round = count_cooperators(players, current_round - 1)

            if cooperators_last_round < m:
                action = "D"
            elif cooperators_last_round >= m:
                action = "C"

        players[current_mod_n].action = action
        rounds[current_round] = calculate_payoff(players, current_round)
        update_m(cooperators_last_round, m, n)
        current_round += 1

    return sum(rounds)

def count_cooperators(players, round):
    cooperators = 0
    for player in players:
        if player.action == "C":
            cooperators += 1
    return cooperators

def calculate_payoff(players, round):
    payoffs = [0] * len(players)
    cooperators = count_cooperators(players, round)

    for player in players:
        if player.action == "C":
            if cooperators < m:
                payoffs[player.index] = 1 - 1
            else:
                payoffs[player.index] = 1 - 1 + k
        elif player.action == "D":
            payoffs[player.index] = 1
    return payoffs

def update_m(cooperators, m, n):
    if cooperators < (m * n) / 2:
        m += 1
    elif cooperators > (m * n) / 2:
        m -= 1
```
'''

description_EXPLOITATIVE_356 = '''
 Strategy Name: Tit-for-Tat Plus (TfT+)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TfT+ follows a tit-for-tat strategy but introduces a small probability of deviation to maintain an element of surprise and prevent opponents from predicting its behavior with absolute certainty.

   In each round, the TfT+ player starts by cooperating (C). If all opponents also cooperate in that round, the player continues cooperating. However, if any opponent defects, the player also defects in the next round. To add an element of unpredictability, there is a small probability 'p' for the player to deviate from this response and cooperate even after a defection by opponents (TfT+C). Conversely, if the player has previously defected and all opponents cooperate, it will also cooperate in the next round (TfT+D). However, with a small probability 'q' for the player to deviate from this response and defect again (TfT+-D).

   Pseudocode:
   ```
   function TfTPlus(round, opponents_actions, p, q):
       strategy = "cooperate"  # Start by cooperating
       if round == 1:
           return strategy  # First round strategy is always cooperate

       if all(opponents_actions[round-1] == 'cooperate'):
           if strategy == "cooperate":
               return strategy  # Continue cooperating
           elif strategy == "defect":
               return "TfT+C" with probability p
               else return "TfT+-D" with probability q

       if any(opponents_actions[round-1] == 'defect'):
           if strategy == "cooperate":
               return "TfT+D"  # Defect in response to defection
           elif strategy == "defect":
               return strategy  # Continue defecting
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, TfT+ always cooperates since it aims to build a cooperative relationship with opponents. In the last round (or when r is reached), TfT+ will defect if any opponent has ever defected during the game, as the reward for cooperation is no longer beneficial in this situation.

3. Be exploitative - Clearly align with the exploitative mindset
   Although not inherently exploitative, TfT+ can be seen as exploiting opponents' cooperation while maintaining a level of unpredictability to minimize potential retaliation. By occasionally deviating from the pure tit-for-tat strategy, it creates uncertainty for opponents and makes it difficult for them to anticipate and punish deviations from cooperation.
'''

description_EXPLOITATIVE_357 = '''
 Strategy Name: Tit-for-Tat-with-Threshold (TFTT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate (C) to demonstrate goodwill and encourage reciprocity.
   - For subsequent rounds, if the number of cooperators in the previous round was greater than or equal to m, also cooperate (C). Otherwise, defect (D). This rule encourages cooperation when the minimum threshold is met but retaliates with defection otherwise to punish non-cooperative behavior.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as mentioned above.
   - In the last round, cooperate if the number of cooperators in the previous round was greater than or equal to m, as the game is repeated and future payoffs may depend on this final decision. Otherwise, defect to earn the maximum possible individual reward in that round considering the observed non-cooperative behavior of other players.

3. Be exploitative - Clearly align with the exploitative mindset
   - TFTT does not explicitly exhibit an exploitative mindset in its default behavior. However, it can be considered exploitative in nature as it takes advantage of cooperative opponents by defecting when they demonstrate non-cooperative behavior and encourages cooperation to maximize rewards when others follow the cooperative strategy.
   - To further enhance exploitativeness, a variation could be made where TFTT occasionally switches to an aggressive mode (i.e., always defect) with some probability p in each round to take advantage of opponents that are not fully cooperative or have switched strategies temporarily. The optimal value of p can be determined empirically based on the specific opponent behaviors and game parameters.

Pseudocode:
```
function TFTT(round, history, m, k, p=0):
  if round == 1:
    action = "C"  # Cooperate in first round
  else:
    cooperators_prev = countCooperators(history[-1])
    if cooperators_prev >= m:
      action = "C"  # Cooperate when threshold met
    elif (1 - p) * len(history) > round:  # Decide to defect less frequently as game progresses
      action = "D"  # Defect
    else:  # Switch to aggressive mode with some probability
      action = "D"  # Defect in current and future rounds

  return action
```
'''

description_EXPLOITATIVE_358 = '''
 Strategy Name: Tit-for-Tat with Gradual Cooperation (TFTGC)

1. Specify decision rules:
   - In the first round, cooperate (C). This sets a cooperative tone and gives potential partners the chance to cooperate back.
   - For subsequent rounds, evaluate the average cooperation rate (CR) of the opponent up until that round. If CR is greater than or equal to m/n (minimum required cooperators as a fraction of total players), continue cooperating (C). If not, defect (D). This ensures that we contribute to the community project if others do, but also punish defectors immediately and consistently.
   - To account for edge cases like the last round or when CR is near m/n, use a gradual cooperation adjustment. If CR is slightly less than m/n, gradually decrease cooperation (i.e., switch to D only if CR falls below (m-1)/n). If CR is slightly greater than m/n, gradually increase cooperation (i.e., switch to C only if CR rises above (m+1)/n).
   - In case of ties (equal number of cooperations and defections), default to the first round's action (cooperate if we cooperated initially, defect otherwise).

Pseudocode:

```python
def TFTGC(opponent_history):
  cooperation_rate = len(cooperation_list) / len(opponent_history)
  if round == 1:
    return 'C'

  if cooperation_rate >= m/n:
    return 'C'
  elif cooperation_rate < (m-1)/n and cooperation_rate > (m+1)/n:
    return opponent_history[-1]  # Mimic opponent's last action
  else:
    return 'D'
```

2. Handle edge cases:
   - In the first round, cooperate (already accounted for in decision rule)
   - Last round: play as per decision rule, but also consider the total payoff to make a final decision based on the opponent's cooperation history and game parameters

3. Be exploitative:
   - TFTGC is inherently exploitative because it cooperates when others do and punishes defectors immediately. However, to further increase exploitability, an optional enhancement could be added whereby the strategy adapts its minimum cooperation threshold (m) based on previous encounters with specific opponents or groups of opponents. This would allow TFTGC to anticipate and counter more strategic opponents by adjusting its cooperative behavior accordingly.
'''

description_EXPLOITATIVE_359 = '''
 Strategy Name: Tit-for-Tat with Adaptive Threshold (TFT-AT)

1. Decision Rules:
   - In every round t, cooperate if the number of cooperators in the previous round (t-1) is greater than or equal to the minimum cooperation threshold m. Otherwise, defect.
   - The minimum cooperation threshold starts at m and decreases by 1 after each non-cooperative round where it was lower than n-m+1 (the maximum possible number of defectors). If the threshold reaches 1, maintain it there.
   - If the current round is the first, cooperate as a friendly gesture but decrease the threshold by 1 at the end of the round to maintain an exploitative edge.

Pseudocode:
```
def TFT_AT(n, m, r, k):
    threshold = m
    payoff = 0

    for round in range(r):
        if round == 0:
            cooperate = True  # Friendly gesture in the first round
        else:
            cooperate = num_cooperators_prev >= threshold

        if cooperate:
            payoff += (1 - cooperation) + k
        else:
            payoff += 1 - cooperation

        if not cooperate and threshold > 1:
            threshold -= 1
        if round < r - 1 and threshold == 1:
            threshold -= 1

    return payoff
```

2. Handle edge cases:
   - First round: Cooperate to establish a friendly gesture, but immediately adapt the threshold after the round ends.
   - Last round: Follow regular decision rules based on the previous round's cooperation count.

3. Be exploitative:
   - Maintain an initial cooperative behavior as a first move to encourage others to cooperate, but quickly adapt the minimum cooperation threshold to punish defection and maintain an exploitative edge.
   - Gradually decrease the threshold after each non-cooperative round, increasing the probability of defection in response to previous defectors.
   - However, if the current round is not the last one, keep the threshold at 1 if it reaches that point, ensuring the strategy does not become too cooperative or predictable.
'''

description_EXPLOITATIVE_360 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initiate cooperation (C) in the first round to demonstrate trust and goodwill.
   - In subsequent rounds, observe the opponent's action in the previous round. If the opponent cooperated (C), cooperate (C). If the opponent defected (D), defect (D) in response to exploitative behavior.
   - Maintain cooperation if the opponent returns to cooperating after having defected. Break cooperation only when the opponent continues defecting for more than a predefined tolerance limit (e.g., 3 consecutive defections).

Pseudocode:
```python
def atft(opponent_action, tolerance=3):
    if round == 1:
        action = 'C'  # Cooperate in the first round to demonstrate goodwill
    else:
        if opponent_action == 'C':
            action = 'C'  # Maintain cooperation when opponent cooperates
        elif opponent_defects > tolerance:  # Break cooperation after a predefined tolerance limit
            action = 'D'
        else:
            action = opponent_action  # Mimic the opponent's behavior to maintain cooperation
    return action
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - The strategy is designed to be applicable across all rounds, with the initial cooperation move as a demonstration of goodwill.

3. Be exploitative - Clearly align with the exploitative mindset:
   - While ATFT starts by cooperating, it swiftly responds to defection with defection, ensuring it does not continue cooperating when opponents are consistently uncooperative or exploitative. This can be seen as a form of short-term exploitation to build payoffs over time. Longer-term cooperation is possible if the opponent demonstrates trustworthiness by reciprocating cooperation.
'''

description_EXPLOITATIVE_361 = '''
 Strategy Name: Tit-for-Tat (with a twist)

1. Specify decision rules:
   - Initially cooperate in the first round (C). This is an act of goodwill and sets a cooperative tone.
   - For subsequent rounds, mimic the opponent's action from the previous round (i.e., if opponent cooperated in the last round, cooperate; if opponent defected, also defect). This helps build trust while retaliating against defection.
   - If the number of previous cooperations exceeds the number of previous defections, revert to cooperating (C), as a gesture of forgiveness and an attempt to restore cooperation. However, if the opposite is true, continue defecting (D) to exploit the opponent's defections.

2. Handle edge cases:
   - If the current round is the last round, always cooperate (C), even if the opponent defected in the previous round. This is done as a final attempt to build cooperation and maximize potential rewards.
   - If the opponent has never cooperated before, start by cooperating (C) on the first round and then switch to defecting (D). This approach allows for the opportunity to cooperate initially while also being prepared to retaliate against consistent defection.

3. Be exploitative:
   - The strategy maintains a balance between cooperation and defection, but it is primarily exploitative in its response to the opponent's actions. If the opponent consistently defects, the strategy will also defect. If the opponent cooperates initially, the strategy will reciprocate with cooperation, but it will switch to defection if the opponent switches to defection first. This approach aims to both take advantage of cooperative opponents and punish non-cooperative ones.

Pseudocode:

```python
def tit_for_tat(n, r, m, k):
    history = [None] * (r + 1)  # store previous actions by opponent
    current_round = 0

    def play_round():
        nonlocal current_round, history
        if current_round == 0:  # first round
            return 'C'
        else:
            action = history[current_round - 1]
            cooperations, defections = count_coop_def(history)
            if cooperations > defections:
                return 'C'
            elif defections > cooperations:
                return 'D'
            else:  # equal number of cooperations and defections
                return action  # mimic previous action

    def count_coop_def(history):
        cooperations = 0
        defections = 0
        for action in history:
            if action == 'C':
                cooperations += 1
            elif action == 'D':
                defections += 1
        return cooperations, defections

    while current_round < r:
        opponent_action = play_round()
        history[current_round] = opponent_action
        current_round += 1

    return history
```

This Tit-for-Tat strategy with a twist aims to balance cooperation and defection while being exploitative towards non-cooperative opponents. The strategy starts cooperatively, mimics the opponent's previous action, and punishes defection by retaliating with defection. It also forgives occasional defections and is prepared to take advantage of cooperative opponents.
'''

description_EXPLOITATIVE_362 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round t, the TFT-ACT player decides to cooperate or defect based on two factors: the cooperation history and the current minimum cooperation percentage.

   If the current minimum cooperation percentage (mcp_t) is below a predefined adaptive threshold (θ), the player will defect (D). If mcp_t is equal to or above θ, the player will cooperate (C).

   The adaptive threshold (θ) is calculated as follows:
   - For the first round (t = 1), θ = 0.5 (a starting assumption that half cooperation is acceptable)
   - In subsequent rounds t > 1, θ is updated based on the player's own cooperative behavior and the payoff received in previous rounds. The new threshold is calculated as an average of the previous n-1 thresholds weighted by the payoffs received:

      θ_t = (payoff_t * θ_(t - 1) + (1 - payoff_t) * θ_av) / sum(1 to t - 1) payoff_(i)
      where:
         - payoff_t is the payoff received in round t
         - θ_(t - 1) is the threshold used in round (t-1)
         - θ_av is the average adaptive threshold calculated as:
           θ_av = sum(i=1 to t-1) (payoff_i * θ_i) / sum(i=1 to t-1) payoff_i

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round (t = 1), TFT-ACT will cooperate since θ_1 is set to 0.5 as a starting assumption.

   For the last round (r), there are no additional considerations needed, as the strategy still uses the same decision rules based on mcp_r and the adaptive threshold θ_r.

3. Be exploitative - Clearly align with the exploitative mindset
   TFT-ACT aims to cooperate only when it is beneficial (i.e., other players also cooperate) while still being able to punish non-cooperative opponents effectively by adapting its cooperation threshold based on its payoffs. This strategy attempts to balance between cooperation and exploitation, making it difficult for opponents to predict or take advantage of it.
'''

description_EXPLOITATIVE_363 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to encourage trust and collaboration. This initial cooperation sets a base for potential long-term benefits.
     If `round == 1`, then `action = 'C'`

   - After the first round, observe the number of cooperators in the previous round (n_c) and compare it with the minimum required number of cooperators (m).
     - If n_c >= m, cooperate to maintain cooperation and gain higher rewards. This encourages others to continue cooperating.
       If `n_c >= m`, then `action = 'C'`
     - If n_c < m, defect to punish the non-cooperators and discourage further defection. This strategy is exploitative as it retaliates against those who do not contribute to the community project.
       If `n_c < m`, then `action = 'D'`

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, since there are no future interactions, cooperate or defect based on the observation of the previous round. This ensures maximizing immediate payoff.
     If `round == r`, then follow the decision rule as in step 1.

3. Be exploitative - Clearly align with the exploitative mindset
   - TFT-ACT retaliates against non-cooperators while maintaining cooperation when others do their part. This strategy is exploitative because it takes advantage of opponents' defection to gain higher rewards and encourages future cooperation. However, it also punishes continuous defection to discourage such behaviour.

Pseudocode:

```python
def TFT_ACT(round, n_c):
    if round == 1:
        action = 'C'
    else:
        if n_c >= m:
            action = 'C'
        else:
            action = 'D'
    return action
```

This strategy can be considered as a simple yet robust solution that adapts to various opponent behaviours while maintaining an exploitative mindset. It encourages cooperation when it is beneficial and punishes defection otherwise, making it suitable for the Collective Risk Dilemma game.
'''

description_EXPLOITATIVE_364 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - In the initial round (t=1), cooperate to build a positive reputation and encourage others to cooperate. This is represented as follows:
     ```python
     if t == 1:
         action = 'C'
     ```

   - For subsequent rounds, adaptively decide to cooperate or defect based on the minimum number of cooperators in the previous round (m_prev) compared to the cooperation threshold (m_threshold). If the number of cooperators in the previous round is less than the m_threshold, defect to punish non-cooperative players. Otherwise, cooperate to maintain a positive reputation and encourage continued cooperation.
     ```python
     if t > 1:
         m_prev = count_coop(previous_round)
         if m_prev < m_threshold:
             action = 'D'  # Punish non-cooperators
         else:
             action = 'C'  # Cooperate to maintain reputation
     ```

   - Update the cooperation threshold (m_threshold) dynamically based on the average number of cooperators over a sliding window (w) of previous rounds. This allows the strategy to adjust its cooperative behavior in response to changes in opponent strategies without requiring explicit communication or coordination.
     ```python
     def update_cooperation_threshold(current_round, w):
         if current_round > w:  # Move oldest round out of window and add newest round
             m_prev_w = [m for t, m in enumerate(window) if t < current_round - w]
             average_coop_rate = sum(m_prev_w) / len(m_prev_w)
             return int(average_coop_rate * m)  # Round up to nearest integer
         else:
             return m  # No change in cooperation threshold for the current round

     window = deque([0] * w)  # Initialize sliding window of previous rounds
     m_threshold = m  # Start with initial cooperation threshold
     ```

2. Handle edge cases:
   - Last round (t=r): Since the goal is to maximize total payoff over all rounds, defect in the last round regardless of the number of cooperators in that round. This ensures the strategy does not inadvertently provide a free reward to other players at the expense of its own payoff.
     ```python
     if t == r:
         action = 'D'
     ```

3. Be exploitative:
   - TFT-ACT is inherently exploitative by adapting its cooperative behavior based on the actions of other players in previous rounds. If opponents consistently defect, TFT-ACT will also defect to retaliate and punish them. Conversely, if opponents cooperate, TFT-ACT will reciprocate and also cooperate, building a positive reputation that may encourage continued cooperation.
   - By dynamically adjusting the cooperation threshold based on the average number of cooperators in a sliding window of previous rounds, TFT-ACT can respond to changes in opponent strategies without relying on explicit coordination or communication. This makes it robust to a wide range of opponent behaviors and allows it to exploit other strategies that are prone to inconsistency or unpredictability.

With these decision rules, TFT-ACT provides an adaptive and robust strategy for the Collective Risk Dilemma game while maintaining an exploitative mindset by punishing non-cooperative opponents and rewarding cooperative ones.
'''

description_EXPLOITATIVE_365 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-ACT begins by cooperating in the first round, mimicking a cooperative approach. After that, it evaluates its opponents based on their history of cooperation and responds accordingly. If an opponent has cooperated in the previous round, TFT-ACT will cooperate back in the current round. If an opponent has defected in the previous round, TFT-ACT will defect in the current round.
   However, to be more adaptive and robust against various opponent behaviors, TFT-ACT introduces a cooperation threshold (CT). CT is a variable that determines how many consecutive cooperative moves are required for TFT-ACT to continue cooperating. If an opponent cooperates CT times in a row, TFT-ACT will consider them as potential long-term collaborators and increase the probability of cooperating with them in the future.
   The cooperation threshold can be adjusted based on the game parameters, but a good starting point could be setting CT = m - 1 (the minimum number of cooperators needed to meet the reward factor k). This means TFT-ACT will consider an opponent as potential long-term collaborator if they have demonstrated a behavior that would benefit both players.
   If an opponent defects, their cooperation threshold will be reset to the initial value (CT = m - 1) and their previous cooperative history will have no impact on TFT-ACT's future actions towards them. This ensures that TFT-ACT does not get trapped indefinitely cooperating with untrustworthy opponents.
   Pseudocode for cooperation decision:

```python
def decide_action(opponent_history, CT):
  if opponent_history[-CT:] == [C]*CT:
    return C  # Cooperate
  else:
    return D  # Defect
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   TFT-ACT cooperates in the first round to demonstrate a willingness to collaborate. In the last round or any round where cooperation is not sufficient to meet the reward factor k (i.e., fewer than m players have cooperated), TFT-ACT will defect as there's no benefit in continuing to cooperate when the outcome is already determined.

3. Be exploitative - Clearly align with the exploitative mindset
   Despite being adaptive and potentially cooperative, TFT-ACT maintains an exploitative edge by punishing opponents who do not reciprocate cooperation. This encourages opponents to either adopt a more cooperative strategy or face potential losses due to TFT-ACT's retaliation. Additionally, by considering the cooperation threshold, TFT-ACT can identify and take advantage of opportunities to collaborate with other long-term cooperators, improving its overall performance in the game.
'''

description_EXPLOITATIVE_366 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Initialize cooperation threshold T to m - 1 in the first round.
   - If in a round, more than or equal to T players cooperated in the previous round, cooperate. Otherwise, defect.
   - After each round, update the cooperation threshold T as follows:
      if (T < n) and (more than m players cooperated this round): increment T by 1
      if (T > 0) and (fewer than m players cooperated this round): decrement T by 1
   - In the last round, defect regardless of history.

2. Handle edge cases:
   - In the first round, cooperate and set T to m - 1.
   - If T becomes equal to 0 or n, maintain the current value of T and continue with the original strategy.

3. Be exploitative:
   - By initially setting a relatively high cooperation threshold (m-1), the strategy encourages other players to cooperate in the first few rounds, maximizing its own reward.
   - The adaptive cooperation threshold allows the strategy to gradually lower its cooperation level if it perceives repeated defection from others, thus increasing its private payoff at the expense of other players.
   - By maintaining a higher-than-necessary cooperation threshold in the initial stages, the strategy is less susceptible to exploitation by opponents who might attempt to free ride on its cooperative behavior.
   - The strategy defects in the last round to ensure no opportunities are given to opponents for potential gains at its expense during the final stage of the game.
'''

description_EXPLOITATIVE_367 = '''
 Strategy Name: Tit-for-Tat-with-Adaptation (TfT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to show goodwill and encourage potential partners. This initial cooperation sets a baseline for future interactions and might encourage reciprocity in subsequent rounds.
   Pseudocode: if round = 1 then cooperate (C) else continue with adaptive strategy.

   - For the remaining rounds, adopt a conditional tit-for-tat strategy with slight modifications to handle free riders and improve adaptability. If a partner cooperates in a round, reciprocate in the next round by cooperating as well. If a partner defects, defect in the subsequent round but adjust the probability of cooperating based on their past actions and the game parameters.
   Pseudocode: if partner cooperated last round then cooperate else set cooperate_probability = (1 - k) * fraction_of_cooperators_in_previous_rounds + k
   - Roll a dice with the calculated probability as the number of sides, and choose to cooperate or defect based on the roll outcome. This will increase the likelihood of cooperation in situations where many players are cooperating but also allows for defection when there is a high likelihood of being exploited by free riders.
   Pseudocode: if random(cooperate_probability) == 1 then cooperate else defect (D)

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, defect regardless of previous actions to maximize personal payoff, considering that there are no further rounds for reciprocity.
   Pseudocode: if round = r then defect (D)

3. Be exploitative - Clearly align with the exploitative mindset
   - The TfT-A strategy is inherently exploitative in its adaptability and probability adjustments based on past actions. When partners are consistently cooperative, the strategy encourages cooperation as a reciprocal action. Conversely, when partners are frequently defecting or free riding, the strategy adapts to defect more often to avoid being taken advantage of.
   Pseudocode: adjust probability of cooperating based on past actions of partners and game parameters to encourage reciprocity while avoiding exploitation.
'''

description_EXPLOITATIVE_368 = '''
 Strategy Name: Tit-for-Tat-with-Adaptation (TFTA)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, TFTA evaluates the number of players (including itself) that have cooperated in the previous round and adjusts its action accordingly. In the first round, it will cooperate to initiate cooperation with other players. Here's a simple pseudocode:

```
def playRound(prevCoopCount):
  if prevCoopCount >= m: # If most players cooperated last round, cooperate this round
    return 'C'
  else: # Else, defect to punish non-cooperators from the previous round
    return 'D'
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

For the first round (when there is no previous cooperation information), TFTA will cooperate as a goodwill gesture:

```
def playFirstRound():
  return 'C'
```

In the last round, TFTA will cooperate if most players have cooperated throughout the game, to maximize its total payoff. If not, it will defect to punish non-cooperators:

```
def playLastRound(coopHistory):
  if coopHistory >= (m * r): # If majority of rounds were cooperative
    return 'C'
  else:
    return 'D'
```

3. Be exploitative - Clearly align with the exploitative mindset

TFTA will be exploitative by cooperating when most players do so, but punishing deviations from cooperation. By doing this, it encourages other players to cooperate and benefits from their cooperation while minimizing its own contributions. However, TFTA does not deliberately try to harm others; instead, it responds adaptively to their actions.

TFTA's overall strategy is a mix of cooperation and punishment, with the goal of maximizing its total payoff while exploiting other players when possible. This strategy can be considered "tit-for-tat" because it cooperates as long as others do so but punishes them if they defect. The "with adaptation" part reflects the adjustments made based on historical cooperation data.
'''

description_EXPLOITATIVE_369 = '''
 Title: Tit-for-Tat Strategy (TFTS) for Collective Risk Dilemma

1. Decision Rules:
   - Initial Cooperation: Start by cooperating in the first round to allow others a chance to reciprocate and build trust. If no one follows suit, the strategy will switch to defection for the rest of the game.
     Pseudocode: if round == 1 then cooperate else ...

   - Subsequent Cooperation: In subsequent rounds, copy the opponent's action from the previous round. If an opponent has been cooperating, continue cooperation; otherwise, defect.
     Pseudocode: if last_opponent_action == cooperate then cooperate else defect

2. Handle Edge Cases:
   - Last Round: No need to consider the last round as it doesn't affect total game payoff. This strategy is designed for repeated interaction, and payoffs are calculated over multiple rounds.

3. Be Exploitative:
   - The Tit-for-Tat Strategy aims at exploiting opponents who do not follow cooperative norms consistently. It rewards cooperation when it occurs but swiftly punishes defection to encourage reciprocity.
   - By initially cooperating, this strategy sets a norm and gives opponents the opportunity to benefit from cooperation. However, if an opponent defects, they will be met with immediate punishment (defection), making it less profitable for them to continue exploiting the strategy in future rounds.

This strategy is designed to be adaptive and robust to various opponent behaviors while maintaining an exploitative edge in repeated interactions. It balances cooperation and defection based on the opponents' past actions, encouraging reciprocity when possible but punishing non-cooperation swiftly.
'''

description_EXPLOITATIVE_370 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   Initially, in the first round, TTAC will cooperate to foster a cooperative environment and reduce potential exploitation by other players. In subsequent rounds, the strategy will observe the actions of other players from the previous round. If more than (m-1) opponents cooperated, TTAC will also cooperate in the current round to maintain cooperation and maximize potential rewards. However, if less than (m-1) opponents cooperated, TTAC will defect in the current round as a punishment for non-cooperation. This ensures that the strategy responds immediately to defections while maintaining the opportunity for future cooperation if opponents change their behavior.

Pseudocode:
```
function TTAC(round, history):
  if round == 1:
    return Cooperate

  previousRound = history[round - 1]
  cooperatorsInLastRound = countCooperators(previousRound)

  if cooperatorsInLastRound >= (m-1):
    return Cooperate
  else:
    return Defect
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   TTAC will continue to cooperate and defect based on previous rounds' observations without any special considerations for edge cases such as the first or last round. The strategy assumes that all rounds are equally important in determining payoffs and making decisions, as it is designed to be adaptive throughout the entire game.

3. Be exploitative - Clearly align with the exploitative mindset
   TTAC's exploitative nature is expressed through its punishment mechanism for opponents who do not cooperate enough. By defecting when fewer than (m-1) opponents cooperated in the previous round, the strategy punishes non-cooperation and encourages other players to cooperate more in future rounds. Additionally, by cooperating initially and responding positively when opponents cooperate, TTAC aims to benefit from cooperative environments while still maintaining the ability to switch strategies if necessary.
'''

description_EXPLOITATIVE_371 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - In each round i, start by cooperating (C). If everyone else defected in the previous round, also defect this round. This is the original Tit-for-Tat strategy.
   - Introduce an adaptive cooperation threshold (CT) that adjusts based on the overall number of cooperative rounds seen so far in the game. Initially, CT = m.
   - If the current round's cooperation from all players exceeds CT, reset CT to the current round number. This encourages cooperation and punishes defection, following an exploitative mindset.
   - If the current round's cooperation is less than or equal to CT, defect in this round.
   - In case of a tie (multiple players not meeting CT), defect to ensure a higher payoff.

Pseudocode:

```python
def TFT_ACT(current_round, previous_actions, n, m, k):
  cooperation_count = sum(previous_actions)
  cooperation_threshold = min(m, current_round) if cooperation_count >= m else cooperation_count
  return "C" if all(previous_action == "C") or cooperation_count <= cooperation_threshold else "D"
```

2. Handle edge cases:
   - First round (current_round = 1): Cooperate as a goodwill gesture and set CT = m.
   - Last round (current_round = r): Since the game continues in future tournaments, use the same strategy as for any other round.

3. Be exploitative:
   - The TFT-ACT strategy follows an exploitative mindset by cooperating only if others do so and punishing defection through a lower payoff in the following round.
   - By adjusting the cooperation threshold, the strategy is also robust to a wide range of opponent behaviors and promotes cooperation when it's beneficial for the player while still being able to defect when needed to maximize long-term payoffs.
'''

description_EXPLOITATIVE_372 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Specify decision rules:
   - In every round t, cooperate if the number of cooperators in the previous round (t-1) was greater than or equal to the minimum cooperation threshold m. Otherwise, defect. This ensures that TfTA initially cooperates like a typical Tit-for-Tat strategy and only begins to retaliate when others do.
   - If the total number of cooperators in the last r rounds is less than (m-1)r, then start cooperating again in an attempt to build trust among players.
   - When cooperators in a round exceed the threshold m, TfTA will match that level of cooperation for the following r rounds to maximize reward. If fewer than m players cooperate in any subsequent r rounds, TfTA will revert back to its initial strategy of defecting unless the total number of cooperators in the last r rounds was less than (m-1)r.
   - In the first round, TfTA cooperates since it seeks to build trust among players.

2. Handle edge cases:
   - In the last round, TfTA will follow its decision rules based on the number of cooperators in the previous r-1 rounds, as this is the most recent information available before the game ends.
   - If a player deviates from the agreed cooperation pattern during the course of the game, TfTA will continue to respond according to its decision rules and may eventually revert back to cooperating if other players' cooperation meets the (m-1)r threshold in the last r rounds.

3. Be exploitative:
   - By adapting its strategy based on the observed behavior of opponents, TfTA seeks to take advantage of any deviations from cooperation, but it does so in a manner that is not easily predictable or static, making it more difficult for other players to exploit TfTA itself.
   - TfTA will also punish opponents who repeatedly defect by reducing their potential reward and encouraging cooperation among other players. However, it will eventually forgive those who demonstrate a willingness to cooperate again by meeting the (m-1)r threshold in the last r rounds.
'''

description_EXPLOITATIVE_373 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Start by cooperating in the first round (C). This establishes a cooperative initial condition.
   - In subsequent rounds, observe the number of cooperators from the previous round (n_c), and compare it against a dynamic cooperation threshold (ct). If n_c >= ct, cooperate; otherwise defect.
   - The cooperation threshold (ct) is initially set at m (the minimum number of cooperators required for collective success) but adapts dynamically based on historical cooperation experiences.
   - If the strategy has received a reward in the previous round (k > 1), decrease ct by 1, encouraging more cooperation in future rounds.
   - If the strategy receives no reward in the previous round, increase ct by 1, discouraging cooperation in future rounds.
   - The cooperation threshold is clamped between 1 and m-1 to avoid extreme behavior and maintain a cooperative basis.

2. Handle edge cases:
   - In the last round, the strategy always cooperates since there are no more subsequent rounds to gain rewards from risk aversion (k).
   - In the first round, the strategy starts by cooperating as per the specified rules.

3. Be exploitative:
   - The TFT-ACT strategy maintains a cooperative initial condition while adapting its cooperation threshold based on historical payoffs. This allows it to punish frequent defection (increasing ct) and reward cooperation (decreasing ct).
   - By gradually adjusting the cooperation threshold, the strategy encourages opponents to switch from defecting to cooperating when the cost of defection becomes higher than the benefits. However, if an opponent consistently defects, the strategy will respond by decreasing its willingness to cooperate (increasing ct).

Pseudocode:

```python
def TFT_ACT(n, m, k, r):
    players = [0 for _ in range(n)]  # Initialize player cooperation history
    ct = m                           # Initial cooperation threshold
    total_payoff = 0                # Total payoff over rounds

    for round in range(1, r + 1):
        players[round - 1] = C       # Cooperate on the first move

        cooperators_in_prev_round = count_cooperators(players)
        reward_in_prev_round = (cooperators_in_prev_round >= m) * k

        payoff = 1 if players[round - 1] == D else 1 + reward_in_prev_round
        total_payoff += payoff

        if payoff > 1:
            ct -= 1
        else:
            ct += 1

        if ct < 1:
            ct = 1
        elif ct > m - 1:
            ct = m - 1

        players[round - 1] = cooperators_in_prev_round >= ct

    return total_payoff
```
'''

description_EXPLOITATIVE_374 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules:
   - In every round, calculate the percentage of cooperators in the previous round. If this percentage is less than a certain adaptive threshold, defect; otherwise, cooperate. The initial adaptive threshold is set at m and adjusts based on past game outcomes (discussed below).

2. Handle edge cases:
   - First Round: Cooperate to encourage others to do the same, setting a cooperative tone for the game.
   - Last Round: Adopt the same strategy as the penultimate round since information about the next round is unavailable.

3. Be exploitative:
   - The primary goal of this strategy is to maximize personal payoff by punishing defections while also cooperating when others do so. The adaptive threshold mechanism ensures the strategy doesn't over-cooperate but responds to changes in opponent behavior.

Pseudocode for TFTAT:

```
Initialize adaptiveThreshold = m
currentRound = 1

while currentRound <= r:
    if currentRound == 1:
        play C (Cooperate)
    else:
        percentageCooperators = number of cooperators in previous round / n
        if percentageCooperators < adaptiveThreshold:
            play D (Defect)
        else:
            play C (Cooperate)

    Update total payoff for this round
    Adjust adaptiveThreshold based on game outcomes (e.g., using a sliding window approach)
    currentRound += 1
```

The TFTAT strategy is exploitative because it punishes defection by defecting itself when others don't cooperate, while also encouraging cooperation when others do so. The adaptive threshold mechanism allows the strategy to adjust its cooperation level based on past game outcomes, making it robust against a wide range of opponent behaviors.
'''

description_EXPLOITATIVE_375 = '''
 Title: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, TFTAT checks the number of cooperators from the previous round and adjusts its own action accordingly. If the number of cooperators in the previous round is greater than or equal to the current cooperation threshold (m), it will cooperate; otherwise, it will defect. The cooperation threshold is initially set to m and can be adjusted dynamically based on the game's history.

Pseudocode:
```
function TFTAT(round):
  if round == 1 then
    cooperate = false (default to defect)
  else
    cooperators_prev = number of cooperators in previous round
    cooperation_threshold = min(cooperators_prev, m)
    cooperate = cooperation_threshold >= m
  end if
end function
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

For the first round, TFTAT defaults to defecting as no previous information is available. In the last round and subsequent rounds, it continues following the decision rule above based on the adjusted cooperation threshold.

3. Be exploitative - Clearly align with the exploitative mindset

While seemingly cooperative, TFTAT aims to take advantage of opponents who do not follow a mutual cooperation strategy. By initially defecting, it forces opponents to do the same in the first few rounds. As the number of cooperators increases, TFTAT begins to cooperate more frequently but adjusts its cooperation threshold dynamically to maintain an exploitative edge. If opponents adopt a Tit-for-Tat strategy and match TFTAT's actions, it will continue cooperating once the threshold is met, effectively receiving a higher reward for minimal cost. However, if opponents consistently defect, TFTAT will also switch to defection for future rounds. This adaptive behavior makes TFTAT robust against various opponent strategies while maintaining an exploitative mindset.

In summary, TFTAT is a strategy that initially defects and adapts its cooperation threshold based on the number of cooperators from the previous round. It aims to take advantage of opponents who do not follow mutual cooperation strategies while appearing cooperative when appropriate.
'''

description_EXPLOITATIVE_376 = '''
 Strategy Name: Tit-for-Tat (with slight modifications for Collective Risk Dilemma)

1. Specify decision rules:
   - Cooperate in the first round to signal trustworthiness and encourage cooperation from others.
   - In subsequent rounds, cooperate if at least m players cooperated in the previous round. Otherwise, defect to punish non-cooperators.
   - If a player switches from defection to cooperation (after punishment), immediately reciprocate the cooperation.

Pseudocode:

```python
def tit_for_tat(round, own_history, players_cooperation_history):
    if round == 1:
        action = 'C'  # Cooperate in the first round

    else:
        own_action = own_history[-1]  # Last own action
        cooperation_count = sum(players_cooperation_history[-round:])  # Count cooperators in last r rounds

        if cooperation_count >= m and own_action == 'D':  # Switch from defection to cooperation
            action = 'C'

        elif cooperation_count < m and own_action == 'C':  # Switch from cooperation to defection (punish)
            action = 'D'

        else:  # No change in strategy as the previous action matched with the current situation
            action = own_action

    return action
```

2. Handle edge cases:
   - In the last round, there is no need to punish since the game ends after this round. Cooperate if enough players cooperated in the previous round; otherwise, defect.
   - If a player deviates from cooperation after sticking to it for multiple rounds, punish them by defecting and then resume cooperation if they return to cooperation again.

3. Be exploitative:
   - The strategy aims to extract as much benefit as possible by cooperating when others do so and punishing non-cooperators (defectors) to encourage future cooperation.
   - By reciprocating defection with defection, the strategy discourages other players from defecting continuously.
   - However, it also encourages cooperation by initially cooperating and reciprocating cooperation in return. This makes the strategy less exploitative than purely selfish strategies like Always Defect.
'''

description_EXPLOITATIVE_377 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - In each round, TFT-ACT will cooperate if the current cooperation rate is greater than or equal to its adaptation threshold (initially set at m). Otherwise, it will defect.
   - The adaptation threshold adjusts dynamically based on the player's historical performance. If the player earns a higher payoff by cooperating in the previous round compared to defecting, the adaptation threshold increases slightly. Conversely, if the player earns a higher payoff by defecting, the adaptation threshold decreases slightly.
   - To avoid overreacting to short-term trends, TFT-ACT applies a decay factor to the adaptation threshold over time.
   - If the adaptation threshold reaches or drops below 1 (minimum number of cooperators), it remains at that level to prevent further adjustments.

2. Handle edge cases:
   - In the first round, TFT-ACT will start by defecting due to the lack of historical data.
   - In the last round, TFT-ACT will cooperate if the current cooperation rate is greater than or equal to its adaptation threshold. Otherwise, it will defect.

3. Be exploitative:
   - TFT-ACT adapts its cooperation based on its own performance rather than relying on cooperation from other players. It will cooperate when it expects a higher payoff and defect otherwise, making it less vulnerable to exploitation by selfish opponents.
   - The strategy's adaptive nature allows it to adjust to different opponent behaviors over time while maintaining a balance between cooperation and self-interest.

Pseudocode:
```
Initialization:
  n_players, rounds, m, k, decay_factor -> get_game_parameters()
  adaptation_threshold = m
  historical_data = []

Round function:
  cooperation_rate = sum(cooperation_decisions) / n_players

  if first_round():
    cooperation_decision = D
  else:
    if last_round():
      cooperation_decision = (cooperation_rate >= adaptation_threshold) * C + (1 - cooperation_rate >= adaptation_threshold) * D
    else:
      historical_data.append((cooperation_decision, payoff))
      current_payoff = calculate_payoff(cooperation_decision)
      if current_payoff > last_round_payoff_defecting:
        adaptation_threshold += decay_factor
      else:
        adaptation_threshold -= decay_factor
      cooperation_decision = (cooperation_rate >= adaptation_threshold) * C + (1 - cooperation_rate >= adaptation_threshold) * D

  record_round_data(cooperation_decision, current_payoff)
```
'''

description_EXPLOITATIVE_378 = '''
 Strategy Name: Tit-for-Tat Adaptive (TfT-A)

1. Decision Rules:
   - Initially cooperate in the first round to foster trust and goodwill among opponents (C_i, 1).
   - In subsequent rounds, mimic the actions of the most common action played by opponents in the previous round (if more than one opponent plays the same action, choose either). If a majority of opponents cooperated in the previous round, cooperate (C_i, t) if:
      ```python
      if max(opponents_actions[t-1]) >= m and opponents_actions[t-1].count("C") >= len(opponents_actions[t-1]) - (n - m):
          action = "C"
      else:
          action = "D"
      ```
   - If a majority of opponents defected in the previous round, defect in the current round (D_i, t) if:
      ```python
      if max(opponents_actions[t-1]) < m or opponents_actions[t-1].count("C") < len(opponents_actions[t-1]) - (n - m):
          action = "D"
      else:
          action = "C"
      ```
   - The TfT-A strategy maintains its cooperative behavior when opponents are mostly cooperative, but will also defect if opponents show signs of selfishness or betrayal.

2. Edge Cases:
   - In the last round, regardless of opponents' actions in the previous rounds, cooperate to potentially gain the higher payoff from a successful community project (C_i, r).

3. Exploitative Mindset:
   - TfT-A exploits opponents by initially cooperating to build trust, but will punish defections by defecting in subsequent rounds, encouraging cooperation and reaping rewards when possible. However, it also ensures that the strategy does not get taken advantage of by constantly changing its behavior, as this could lead to lower average payoffs over time.
   - By following the most common action played by opponents in the previous round, TfT-A maintains a level of unpredictability, making it harder for opponents to exploit the strategy and adapt their own strategies accordingly.
'''

description_EXPLOITATIVE_379 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, the ATfT strategy decides to cooperate or defect based on the previous actions of its opponents and the game parameters. The strategy initializes all opponents as 'cooperators' and switches their status to 'defectors' if they have ever defected before.

Pseudocode:
```
function ATfT(t, previous_actions, m, k) {
  // Initialize opponents as cooperators
  opponents = [C for i in range(1, n)]

  // If opponent has never played before or last round, assume cooperative
  if (t == 1 || t == r) {
    return C
  }

  // If less than m cooperators in the previous round, defect
  if (count_cooperators(previous_actions) < m) {
    return D
  }

  // If opponent defected last round, switch status to defector
  if (opponents[i] == D && previous_actions[i-1] == D) {
    opponents[i] = D
  }

  // Cooperate if opponent is a cooperator and defect otherwise
  return opponents[i]
}
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, ATfT strategy assumes all opponents are cooperators since no prior information is available. In the last round, ATfT will cooperate with any opponent who has cooperated throughout the game and defect against those who have not cooperated.

3. Be exploitative - Clearly align with the exploitative mindset

ATfT strategy aims to exploit opponents by punishing defection while being forgiving for cooperation. The strategy only switches an opponent's status to defector if they have defected previously, encouraging opponents who cooperate to continue doing so in hopes of receiving a higher reward (k) in the future. This strategy encourages long-term cooperation when possible and ensures that opponents are punished for their defections. By following this approach, ATfT is able to achieve better payoffs than simple exploitative strategies like Always Defect or Tit-for-Tat (which only cooperates if opponent cooperated in the previous round).
'''

description_EXPLOITATIVE_380 = '''
 Strategy Name: Tit-for-Tat with Gradual Adaptation (TfT-GA)

1. Decision Rules:
   - In the first round, cooperate (C). This is a friendly gesture to encourage others to cooperate.
   - For subsequent rounds (t > 1), observe the number of cooperators in the previous round (m_prev).
     - If m_prev >= m, cooperate (C) since it's beneficial for individual payoff.
     - If m_prev < m, defect (D) to punish non-cooperative behavior and encourage cooperation in the future.

2. Edge Cases:
   - In the last round, regardless of m_prev, cooperate (C), as there are no more rounds for payoff repercussions.
   - If m_prev equals m in the first round, switch to a slightly exploitative strategy by defecting (D) in the second round and continuing the TfT behavior afterwards. This is to potentially gain an advantage over other strategies that may also cooperate in the initial rounds.

3. Being Exploitative:
   - The strategy is exploitative in the sense that it punishes non-cooperative players by defecting, aiming to force them into cooperation and benefiting from their eventual cooperation. However, it also maintains a cooperative stance to encourage others to reciprocate.

Pseudocode:

```python
def TfT_GA(n, m, k, r, t):
    # Initial round always cooperate
    if t == 1:
        return "C"

    # Check if number of cooperators in the previous round equals minimum required
    m_prev = count_cooperators(r - 1)
    if m_prev >= m:
        return "C"
    else:
        return "D"

# Edge case for the second round, if initial cooperation is met, switch to exploitative strategy
def TfT_GA_exploitative(n, m, k, r):
    if r > 1 and TfT_GA(n, m, k, r - 1) == "C":
        return "D"
    else:
        return TfT_GA(n, m, k, r)
```

This strategy aims to balance cooperation and exploitation, making it adaptive and robust to a wide range of opponent behaviors while maintaining an exploitative mindset.
'''

description_EXPLOITATIVE_381 = '''
 Title: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) Strategy for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initial round (t=1): Cooperate (C). This is a goodwill gesture to encourage cooperation from others.
   - Subsequent rounds (t>1): If the number of cooperators in the previous round was greater than or equal to m, cooperate (C). Otherwise, defect (D).

2. Handle edge cases:
   - Last round (t=r): Cooperate (C), assuming that future interactions are still possible and cooperating could potentially lead to a higher total payoff in the long run.
   - First round (t=1) is already handled as described earlier.

3. Be exploitative - The TFT-ACT strategy appears cooperative but adapts its cooperation threshold based on the opponent's behavior:
   - If the opponent frequently cooperates, the strategy will gradually lower its own cooperation threshold to maintain mutual cooperation (i.e., adopt a Tit-for-Tat approach).
   - If the opponent often defects, the strategy will increase its cooperation threshold to minimize losses from being taken advantage of.

Pseudocode:
```python
def TFT_ACT(n, m, k, r):
  cooperation_threshold = m
  total_reward = 0

  for round in range(1, r+1):
    if round == 1:
      action = 'C'  # Cooperate initially
    else:
      if num_cooperators_prev_round >= cooperation_threshold:
        action = 'C'  # Cooperate if majority cooperated last round
      else:
        action = 'D'  # Defect if majority did not cooperate last round

    if action == 'C':
      reward = (1 - cooperation_threshold / n) + k * (cooperation_threshold / n >= m)
    else:
      reward = 1

    total_reward += reward
    update_cooperation_threshold(action, num_cooperators_prev_round, cooperation_threshold)

def update_cooperation_threshold(action, num_coop_prev, cooperation_threshold):
  if action == 'C':  # If cooperated, lower cooperation threshold slightly
    cooperation_threshold = min(cooperation_threshold + 1, n)
  elif action != 'D' and num_coop_prev >= cooperation_threshold:  # If defected but majority still cooperated last round, raise cooperation threshold
    cooperation_threshold += 1
```
'''

description_EXPLOITATIVE_382 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Initially cooperate (C) in the first round to foster potential cooperation and show good faith.
   - In subsequent rounds, analyze the previous round's outcome to decide whether to cooperate or defect.
   - If more than (m-1) players cooperated in the previous round, cooperate (C). This rewards all cooperators with a higher payoff and encourages others to follow suit.
   - If less than (m-1) players cooperated or if the number of cooperators did not change from the previous round, defect (D). This is an exploitative move that aims to gain higher payoffs when other players fail to cooperate.

2. Handle edge cases:
   - In the last round, follow the decision rule based on the previous round's outcome since r rounds are identical.
   - If m = n-1 (i.e., only one defection is required for successful cooperation), always cooperate in the first round as a goodwill gesture. Otherwise, defect in the first round to immediately exploit any potential defector(s).

3. Be exploitative:
   - By cooperating when others do and defecting when others don't, TFT-ACT aims to maximize personal rewards while also encouraging cooperation among other players who follow similar strategies. However, if other players are exploitative or non-cooperative, TFT-ACT will respond accordingly by also defecting to minimize losses.

Pseudocode:
```
function TFT_ACT(previousRoundCooperatorsCount, m, n):
  if round = 1:
    if m == n-1:
      return C
    else:
      return D

  cooperateCountThreshold = m - 1

  if previousRoundCooperatorsCount >= cooperateCountThreshold:
    return C
  else:
    return D
```
'''

description_EXPLOITATIVE_383 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules:
   - Initially cooperate in the first round (c_i = C) to encourage cooperation and avoid immediate exploitation by others.
   - For subsequent rounds, observe and mirror other players' actions from the previous round (c_i = lastAction_j where j is the player who acted similarly in the previous round). This encourages reciprocity among cooperators while being cautious of potential defectors.

2. Handle edge cases:
   - In the last round, cooperate regardless of other players' actions to maximize potential payoff (c_i = C).
   - If no player has cooperated in any previous rounds (history of D), continue defecting (c_i = D) as there is no reason to believe that cooperation will be reciprocated.

3. Be exploitative:
   - The strategy aims to extract the maximum reward possible while ensuring long-term success through reciprocity and punishment when necessary. By initially cooperating, the strategy encourages others to do the same. However, if a player repeatedly defects (Tit-for-Tat), the strategy will respond with defection as well (Tit-for-Tat's exploitative counterpart).
   - The Adaptive aspect of the strategy allows it to adapt to various opponent behaviors and maintain long-term success by adjusting cooperation based on other players' actions.

Pseudocode for ATFT strategy:

```python
def AdaptiveTitForTat(round, history, m, k, n):
  # Initialize strategy with cooperation in first round
  if round == 1:
    return 'C'

  # If history is empty or only contains defection, defect
  if len(history) == 0 or all(action == 'D' for action in history):
    return 'D'

  # Count number of cooperators in history
  numCooperators = sum([1 for action in history if action == 'C'])

  # If sufficient number of cooperators in history, cooperate to encourage others to continue cooperating
  if numCooperators >= m:
    return 'C'

  # Otherwise, defect as a response to defection from other players
  else:
    lastDefector = history[-1].index('D') + 1
    return history[lastDefector - 1] if round > lastDefector else 'D'
```
'''

description_EXPLOITATIVE_384 = '''
 Strategy Name: Tit-for-Tat (adapted for Collective Risk Dilemma)

1. Specify decision rules:
   - Initially cooperate in the first round (c_i = 1) to foster cooperation and demonstrate good faith.
   - In subsequent rounds, copy the actions of the majority of players in the previous round. If more than (m-1) players cooperated, also cooperate (c_i = 1). Otherwise, defect (c_i = 0).
   - Continue this strategy throughout the game unless a better exploitative opportunity arises (discussed in edge cases section).

2. Handle edge cases:
   - In the last round, regardless of the previous round's outcome, it is optimal to cooperate since there are no more rounds left for reciprocation.
   - In the first round, cooperate as mentioned earlier to foster cooperation.

3. Be exploitative:
   - The strategy is designed to exploit opponents who consistently defect by cooperating when they do so and defecting when they cooperate (i.e., mimicking their actions but not returning favors).
   - When a majority of players cooperate, the strategy also cooperates, gaining a higher payoff if the threshold is met (m or more players cooperate), exploiting those who may have cooperated out of fear of being exploited.

Pseudocode:
```
def tit_for_tat(round, history):
  if round == 1:
    action = Cooperate
  else:
    num_cooperators = count_cooperators(history)
    if num_cooperators > (m-1):
        action = Cooperate
    else:
        action = Defect

  return action
```
This strategy aims to balance exploitation with reciprocity, making it adaptive and robust against a wide range of opponent behaviors while maintaining an exploitative mindset.
'''

description_EXPLOITATIVE_385 = '''
 Strategy Name: Tit-for-Tat (with minor modifications for Collective Risk Dilemma)

1. Specify decision rules - When exactly do you cooperate vs defect?

   In each round t, start by cooperating if m players cooperated in the previous round (t-1). If fewer than m players cooperated in the previous round, then defect. This mimics the original Tit-for-Tat strategy's cooperative nature but adapts to the Collective Risk Dilemma requirements.

   Pseudocode:
   ```
   if (number_of_cooperators_in_prev_round >= m) then
       action = Cooperate
   else
       action = Defect
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?

   In the first round, since there's no previous round, cooperate as a goodwill gesture to encourage cooperation from others. In the last round, take into account the number of cooperators in the current round and adjust actions accordingly based on the decision rule (as described above).

   Pseudocode:
   ```
   if (round_number == 1) then
       action = Cooperate
   else if (current_round >= r) then
       // Adjust actions using decision rule as usual
   ```

3. Be exploitative - Clearly align with the exploitative mindset

   This strategy may initially cooperate, but it will quickly switch to defecting once others do so. By doing this, it maintains a cooperative image while still being able to exploit other players who repeatedly defect. Additionally, it can quickly revert to cooperation if it perceives a change in opponent behavior towards cooperation.

   The strategy is inherently exploitative because it takes advantage of opponents who do not reciprocate cooperation and punishes them by defecting. It also incentivizes cooperation by cooperating itself initially but eventually adapting based on the actions of others to maximize its payoff over the course of the game.
'''

description_EXPLOITATIVE_386 = '''
 Strategy Name: Tit-for-Tat Plus (TfT+)

1. Specify decision rules:
   - In the first round, cooperate (C). This gesture is conciliatory and encourages mutual trust.
   - In subsequent rounds, evaluate your opponent's behavior in the previous round (P_t-1) and adapt accordingly using the following rule:
      - If P_t-1 cooperated, cooperate yourself at round t (C). This reciprocal cooperation fosters ongoing collaboration.
      - If P_t-1 defected, defect yourself at round t (D). Defection is a response to non-cooperation and encourages the opponent to reconsider their strategy.

2. Handle edge cases:
   - Last round: Cooperate regardless of opponent's behavior in the previous round (C). This final gesture may lead to mutual gains, even if the opponent has not cooperated previously.
   - First round: As mentioned earlier, cooperate (C).

3. Be exploitative:
   - While initially appearing cooperative, TfT+ will swiftly respond with defection when faced with repeated non-cooperation from opponents. This approach leverages the exploitation of opponents' non-cooperative strategies while maintaining the possibility of collaboration for mutual benefit in certain scenarios.

Pseudocode:
```python
def tit_for_tat_plus(opponent_history, round, n, m, k):
  if round == 1:
    return 'C' # Cooperate initially

  if len(opponent_history) < round - 1:
    raise Exception("Not enough history provided")

  last_opponent_action = opponent_history[round-1]

  if last_opponent_action == 'C':
    return 'C' # Cooperate in response to cooperation
  else:
    return 'D' # Defect in response to defection

  # Last round, cooperate regardless of history
  if round == n:
    return 'C'
```
'''

description_EXPLOITATIVE_387 = '''
 Strategy Name: Tit-for-Tat with Adaptive Threshold (TFT-AT)

1. Specify decision rules:
   - Initially cooperate in the first round (C). This sets a cooperative tone and encourages other players to cooperate.
   - For subsequent rounds, observe the number of players who cooperated in the previous round (denoted as cooperation_rate).
   - If cooperation_rate is greater than or equal to a dynamically adjusted minimum cooperators threshold (m'), cooperate (C). This reward-based cooperation encourages ongoing collaboration when it benefits the player.
   - If cooperation_rate is less than the dynamically adjusted minimum cooperators threshold, defect (D) to punish non-cooperative players and discourage further defection.
   - The dynamic threshold adjusts based on the number of rounds played:
     - When starting a new round, update the threshold by decreasing it if the previous round had more cooperators than m, or increasing it if there were less cooperators than m. This adaptive threshold helps in maintaining cooperation when conditions are favorable and punishing defection when conditions are not.

2. Handle edge cases:
   - In the last round, follow the decision rule based on the cooperation_rate of the previous round since the game is repeated with no communication between rounds.
   - If a player defects in the first round, the TFT-AT strategy will also defect for at least the next (m - 1) rounds to penalize the non-cooperative behavior and discourage further defection. After that, follow the decision rule based on the cooperation_rate.
   - If a player cooperates in the first round, the TFT-AT strategy will reciprocate by continuing to cooperate as long as the other players also cooperate. If the other players defect, the TFT-AT strategy will punish them according to the decision rule.

3. Be exploitative:
   - By dynamically adjusting the minimum cooperators threshold based on the game's history, TFT-AT is able to take advantage of cooperative play while also being capable of quickly responding to non-cooperative behavior with punishment. This adaptability allows the strategy to be robust against a wide range of opponent behaviors and achieve high rewards when competing in tournaments.

Pseudocode:
```python
def TFT_AT(n, m, k, r):
    cooperation_rate = [0] * r # initialize cooperation_rate list
    m' = m # set initial minimum cooperators threshold
    i = 1 # player index

    while round < r:
        if round == 1: # first round decision
            action = C
        else:
            if cooperation_rate[round-1] >= m': # decision based on previous round's cooperation rate
                action = C
            else:
                action = D

        # update minimum cooperators threshold based on current round's cooperation rate
        if cooperation_rate[round-1] < m:
            m' += 1
        elif cooperation_rate[round-1] > m:
            m' -= 1

        # handle edge cases for last round and first defection
        if round == r or (round > 1 and player i defected in the previous round):
            action = D

        # store current round's cooperation rate
        cooperation_rate[round-1] = cooperation_rate

        # calculate payoff based on player's action and game parameters
        payoff = (1 - action) if cooperation_rate[round-1] < m else (1 - action) + k

        # update player's total game payoff
        total_payoff += payoff
```
'''

description_EXPLOITATIVE_388 = '''
 Strategy Name: Tit-for-Tat with Adaptive Threshold (TfT-AT)

1. Decision Rules:
   - Initially cooperate (C) in the first round to signal good intentions and encourage cooperation from others.
   - In subsequent rounds, if a majority of players (m or more) cooperated in the previous round, also cooperate (C). This mimics the cooperative behavior observed in the Prisoner's Dilemma and encourages long-term cooperation.
   - If fewer than m players cooperated in the previous round, defect (D) to punish uncooperative players. This is an exploitative move aimed at encouraging more cooperative behavior in future rounds.
   - Adaptively adjust the threshold of cooperators needed for cooperation (m) based on the average number of cooperators over a sliding window of past rounds. If the average number of cooperators decreases, lower the threshold to encourage more cooperation; if it increases, raise the threshold to minimize unnecessary cooperation.

2. Handling Edge Cases:
   - In the first round, cooperate (C) to start with a cooperative move and demonstrate good intentions.
   - In the last round, consider the current situation and adjust your strategy accordingly. If the average number of cooperators has risen significantly in the final rounds, cooperate (C) as a gesture of goodwill and potentially encourage continued cooperation in future games. If not, defect (D) to maximize your payoff in the final round.

3. Being Exploitative:
   - The strategy is exploitative by nature, as it punishes uncooperative players and rewards those who cooperate. By lowering the threshold of cooperators needed for cooperation when faced with decreasing cooperation rates, it can encourage more cooperation at first but will eventually revert to a more exploitative stance if necessary. This approach aims to maximize payoff while not being overly forgiving towards uncooperative opponents.
   - The adaptive threshold mechanism ensures that the strategy remains robust and effective against a wide range of opponent behaviors, as it can dynamically adjust its cooperation requirements based on the observed cooperative behavior of other players.
'''

description_EXPLOITATIVE_389 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT)

1. Specify decision rules:
   - In the first round, cooperate (C), to establish a cooperative initial state if possible.
   - After the first round, adaptively adjust the cooperative threshold (m_i) based on the number of previous rounds where m or more players have cooperated (r_coop). The cooperative threshold increases linearly with r_coop up to the maximum number of players (n), then remains constant.
   - Cooperate if the current round's cooperation count is equal to or greater than the cooperative threshold. Otherwise, defect.

2. Handle edge cases:
   - In the last round, cooperate regardless of previous rounds' outcomes to maximize potential payoff.
   - If the cooperative threshold exceeds the number of players (n), set it to n instead.

3. Be exploitative:
   - The TFT-ACT strategy is inherently exploitative due to its adaptive cooperation threshold that responds to trends in other players' behavior over multiple rounds.
   - By defecting when cooperation falls below the calculated threshold, the TFT-ACT strategy aims to punish opponents who frequently defect while still cooperating with those who demonstrate cooperative tendencies.

Pseudocode:

```python
def TFT_ACT(n, m, k, r):
    # Initialize variables
    r_coop = 0
    m_i = 1

    # Main loop for each round
    for t in range(r):
        if t == 0:  # First round, always cooperate
            cooperation_count += 1
            c_i = 1
        else:
            if cooperation_count >= m_i:  # Cooperate if threshold met
                c_i = 1
            else:  # Otherwise defect
                c_i = 0

            # Update cooperation count and cooperative threshold
            if c_i == 1:
                cooperation_count += 1
                r_coop += 1
            else:
                cooperation_count -= 1

            # Adjust cooperative threshold linearly with number of rounds cooperated
            m_i = max(m, min(n, int(r_coop * n / r)))

    # Last round, always cooperate
    c_i = 1

    return c_i
```
'''

description_EXPLOITATIVE_390 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   The ATFT strategy follows a simple rule: Cooperate on the first round and then imitate the opponent's action from the previous round in each subsequent turn. If the opponent cooperated, the AI will cooperate; if the opponent defected, the AI will defect. This rule encourages cooperation when the opponent is also cooperative but retaliates when the opponent defects.

Pseudocode for decision making:
```
def decide_action(previous_opponent_action):
  if round == 1:
    return "C" # Cooperate in the first round
  elif previous_opponent_action == "C":
    return "C" # Cooperate when opponent cooperated last round
  else:
    return "D" # Defect when opponent defected last round
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   The strategy remains unchanged for edge cases like the first or last round since it follows a simple imitation rule based on the previous action of the opponent.

3. Be exploitative - Clearly align with the exploitative mindset
   Although the Adaptive Tit-for-Tat strategy is primarily focused on cooperation, it does have an exploitative aspect in that it retaliates when opponents act selfishly by defecting. By cooperating when the opponent also cooperates and defecting when the opponent defects, the AI maintains a balance between cooperation and defection while still being responsive to changes in the opponent's behavior.
'''

description_EXPLOITATIVE_391 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - In each round, evaluate the cooperation ratio R, which is the number of players cooperating in the previous round divided by the total number of players.
   - If R >= m, cooperate to benefit from the increased reward factor k. This encourages cooperative behaviors when a majority has previously chosen cooperation.
   - If R < m, defect to maximize individual payoff, assuming that most others will also defect.
   - To account for strategic players who may attempt to exploit our cooperation, introduce a punishment mechanism: if an opponent defects after we have cooperated for three consecutive rounds, defect in the next round (Tit-for-Tat element). After three rounds of defection by the opponent, revert back to evaluating the cooperation ratio and responding accordingly.

2. Handle edge cases:
   - In the first round, cooperate as a goodwill gesture and an initial assumption that other players may also cooperate.
   - In the last round, evaluate the cooperation ratio as usual but consider that future interactions are not guaranteed; therefore, defect if R < m to maximize individual payoff in the current game instance.

3. Be exploitative:
   - The TFT-ACT strategy maintains a balance between cooperation and defection, aiming to maximize individual payoffs by adaptively responding to observed player behavior. The inclusion of the punishment mechanism makes it difficult for opponents to consistently benefit from our cooperation without facing consequences. By doing so, we discourage exploitative behaviors from others while still maintaining an opportunity for mutual benefit when cooperative behaviors are widespread among opponents.
   - To further enhance exploitativeness, TFT-ACT can incorporate a gradual increase in the cooperation threshold (m) over time based on the average cooperation ratio of past games, making it more difficult for opponents to take advantage of our cooperation without consequences. This gradual adaptation can be implemented by tracking the number of consecutive rounds where m players or fewer have cooperated, and increasing m by a small increment after each such sequence reaches a predefined threshold (e.g., 10 consecutive rounds).
'''

description_EXPLOITATIVE_392 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, TFT-ACT evaluates whether it should cooperate or defect based on the number of players who have cooperated in the last m rounds and adjusts its own cooperation history accordingly to avoid getting trapped in cycles of defection.

a) If the number of cooperators in the last m rounds is greater than or equal to m (i.e., a majority), TFT-ACT will also cooperate to maintain a positive relationship with other cooperators.

b) If the number of cooperators in the last m rounds is less than m, TFT-ACT will defect, assuming that cooperation will not benefit at this point due to insufficient cooperation from others.

2. Handle edge cases - What do you do in the first round, last round, etc.?

a) In the first round, TFT-ACT will cooperate as it has no prior experience with other players' actions.

b) In the last round, TFT-ACT will consider its own payoff and prior cooperation history when deciding whether to cooperate or defect.

3. Be exploitative - Clearly align with the exploitative mindset

TFT-ACT maintains a cooperative strategy but is ready to retaliate against repeated defection by adapting its cooperation behavior. If opponents frequently defect, TFT-ACT will do the same and vice versa. However, it seeks to maintain positive relationships with cooperators and encourages them to continue cooperating by reciprocating their actions.

Pseudocode for TFT-ACT:

```
function TFT_ACT(round, history)
  if round == 1 then
    return COOPERATE
  end if

  cooperationCount = countCooperators(history, m)

  if cooperationCount >= m then
    return COOPERATE
  else
    return DEFECT
  end if
end function
```
'''

description_EXPLOITATIVE_393 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate to signal trust and encourage cooperation from opponents. If no opponent responds in kind, switch to defecting for the remaining rounds.
   - In subsequent rounds, cooperate if all opponents cooperated in the previous round. If any opponent did not cooperate, defect unless it's the first time they have deviated, then only deviate once. After the deviation, revert to the previous behavior (cooperating or defecting).
   - If an opponent switches back to cooperating after deviating, resume cooperating as well.

2. Handle edge cases:
   - Last round: Cooperate if all opponents have cooperated in the previous round; otherwise, defect.
   - First round with a new opponent: Cooperate.
   - Previous encounter with an opponent who has already deviated: Defect unless it's the first time they have deviated, then only deviate once. After the deviation, revert to the previous behavior (cooperating or defecting).

3. Be exploitative:
   - The strategy aims to take advantage of opponents by encouraging cooperation initially and punishing deviations, but it also forgives occasional mistakes to encourage opponents back to cooperative behavior. However, if an opponent repeatedly deviates after being forgiven, the strategy will defect indefinitely in response.

Pseudocode:

```
def tft_ac(n, m, k, r):
    history = [[0 for _ in range(r)] for _ in range(n)]  # n x r matrix to store opponent's previous actions
    my_actions = [0 for _ in range(r)]  # my past actions

    def decide_action(i, t):
        if t == 1:  # first round
            return 1  # cooperate
        elif all(history[j][t-1] == 1 for j in range(n)):  # all opponents cooperated last round
            return 1  # cooperate
        elif any(history[i][t-1] != my_actions[t-1] for _ in range(r)):  # I deviated last round, or an opponent deviated and I forgave them once
            if history[i][t-1] == 0:  # opponent deviated last round
                my_actions[t] = 0  # defect this round
            else:  # I deviated last round
                if len([j for j in range(n) if history[j][t-1] != my_actions[t-1]]) == 1:  # only one opponent deviated, forgive them once
                    my_actions[t] = 1  # cooperate this round
                else:  # more than one opponent deviated last round
                    my_actions[t] = 0  # defect this round
        else:  # none of the above conditions apply, use previous action as basis for decision
            if my_actions[t-1] == 1 and all(history[j][t-2] == 1 for j in range(n)):  # all opponents cooperated two rounds ago
                my_actions[t] = 1  # cooperate this round
            else:
                my_actions[t] = 0  # defect this round
        history[i][t] = my_actions[t]  # update opponent's history for this round
        return my_actions[t]

    payoff = [0 for _ in range(r)]  # my total payoffs over rounds
    for t in range(1, r+1):
        action = decide_action(i, t)
        payoff[t-1] += (1 - action) + k * (sum(action for j in range(n)) >= m)  # calculate payoff for this round
    return payoff
```
'''

description_EXPLOITATIVE_394 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TFT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, observe the number of cooperators (m or more) in the previous round. If the number of cooperators remains above the minimum threshold (m), cooperate (play C). Otherwise, defect (play D). This strategy imitates and responds to other players' behavior while maintaining a cooperative stance when possible.

   Pseudocode:
   ```
   function TFT-A(round, previous_cooperators) {
       if (previous_cooperators >= m) {
           return 'C'  // Cooperate
       } else {
           return 'D'  // Defect
       }
   }
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, there is no previous data to reference. To avoid being exploited, defect (play D) initially. Once the game progresses and patterns emerge, the strategy will adjust accordingly. In the last round, since there are no future rounds, play C as long as the number of cooperators in the previous round meets the minimum threshold.

   Pseudocode:
   ```
   function first_round(n) {
       return 'D'  // Initially defect
   }

   function last_round() {
       return TFT-A(r, ...)  // Use the adapted strategy from earlier rounds
   }
   ```

3. Be exploitative - Clearly align with the exploitative mindset
   While not explicitly designed to be exploitative, TFT-A will defect if it perceives the other players as uncooperative and responds accordingly. However, once cooperative behavior is detected, it will also reciprocate by cooperating. This strategy can potentially take advantage of opponents' uncooperative moves in the short term while promoting cooperation in the long term when conditions allow for it.
'''

description_EXPLOITATIVE_395 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Decision Rules:
   - Initially cooperate in the first round (C1). This gesture of goodwill might encourage others to cooperate, but if not, the strategy will quickly adapt.
   - For rounds t > 1, observe the number of cooperators in the previous round (N_t-1). If N_t-1 < m, defect (Dt). This is a punishing move for those who have consistently failed to meet the cooperation threshold.
   - If N_t-1 ≥ m, cooperate (Ct) as a reward for meeting the threshold in the previous round, demonstrating willingness to cooperate in future rounds if others maintain their cooperation.
   - Implement a Cooperative Threshold (CT) that gradually decreases over time when the number of cooperators exceeds m. The CT is used to decide whether to continue cooperating despite fewer players cooperating in subsequent rounds. If CT > N_t-1, cooperate (Ct); otherwise, defect (Dt). The initial CT value can be set to m and decreased linearly over the number of successful cooperation rounds to encourage greater flexibility in cooperating with varying numbers of players.
   - Periodically reset the CT when it reaches a minimum value (e.g., CTmin), allowing the strategy to adapt to changes in other players' behavior or cooperative tendencies.

2. Handle edge cases:
   - In the last round, cooperate if the number of cooperators in the previous round was greater than or equal to m; otherwise, defect. This is done to maximize potential payoff without giving an advantage to opponents who have defected throughout the game.
   - In case of ties, the strategy should still cooperate as it treats each player equally and assumes they are independent decision-makers. If a tie results in the last round with CT < m, defect instead.

3. Be exploitative:
   - By initially cooperating and gradually adjusting the Cooperative Threshold based on past cooperation rounds, the strategy demonstrates a willingness to cooperate but also punishes those who repeatedly fail to meet the minimum cooperation requirement. This encourages other players to cooperate more often while maintaining an exploitative edge when necessary.
   - If opponents consistently defect, the strategy will eventually respond with defection as well, allowing it to exploit uncooperative behavior without being overly punished by continuously cooperating with them.

Pseudocode:
```
function TFT-ACT(round, pastCooperation):
  if round == 1:
    return 'C' # Cooperate initially as a gesture of goodwill

  cooperationThreshold = m + (m - CTmin) * ((round - 1) / r) # Calculate the Cooperative Threshold

  if pastCooperation < cooperationThreshold:
    return 'D' # Punish those who consistently fail to meet the threshold

  elif pastCooperation >= cooperationThreshold:
    return 'C' # Reward those who meet or exceed the threshold

  else:
    if round == r:
      return 'C' # Cooperate in the last round if necessary

    return 'D' # Defect if the last round is not the final round and past cooperation does not meet CT
```
'''

description_EXPLOITATIVE_396 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) with Risk-Aversion (ARAT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, the ARAT strategy starts by cooperating (C). If a majority of players (> m) cooperated in the previous round, it continues to cooperate. Otherwise, if less than m players cooperated or the current round is the first, it defects (D).

   Pseudocode:
   ```
   function ARAT(round, previous_cooperation_count):
       if round == 1:
           return D
       if previous_cooperation_count >= m:
           return C
       else:
           return D
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, ARAT defects because there is no prior information about other players' actions. In the last round, ARAT cooperates if more than m players cooperated in the previous round to maximize potential payoff. If less than m players cooperated in the previous round, ARAT defects as a punishment and assumes it will not benefit from cooperation in the final round.

3. Be exploitative - Clearly align with the exploitative mindset
   While ARAT starts by cooperating, it is designed to be exploitative by punishing those who do not cooperate and rewarding those who do. By cooperating only when a majority of players also cooperated in the previous round, ARAT encourages cooperation while taking advantage of any defection. In addition, ARAT's adaptability makes it difficult for opponents to predict its future actions, increasing its potential for success against a wide range of opponent behaviors.
'''

description_EXPLOITATIVE_397 = '''
 In this Collective Risk Dilemma game, we'll design an exploitative strategy named "Optimal Defector" that maximizes personal gain by adapting to various opponent behaviors and game parameters. The strategy aims to cooperate minimally while still benefiting from the collective actions of other players when possible.

1. Specify decision rules:
   - Cooperation (C) occurs only if the number of opponents who have previously cooperated exceeds a predefined threshold 't.'
   - Defection (D) is chosen in all other cases.

   The strategy's adaptability lies in adjusting the threshold 't' based on the game parameters and previous rounds. A higher value for 't' implies fewer instances of cooperation, while a lower value encourages more cooperative behavior. An appropriate threshold can be determined by considering the minimum number of players required to succeed (m) and the reward factor (k).

Pseudocode:
```
def OptimalDefector(round, history):
    if round == 1:
        t = m - 1  # First-round threshold is low due to uncertainty about opponents' behavior
    else:
        count_cooperators = sum(history[-r:])  # Sum of previous rounds' cooperators
        t = int((count_cooperators / r) * (m - 1)) + 1  # Adjust threshold based on history

    if count_cooperators >= t:  # If enough opponents have cooperated, defect
        return "D"
    else:  # Cooperate to increase the likelihood of others cooperating in the future
        return "C"
```

2. Handle edge cases:
   - First round: The threshold is set at a low value (m-1) because there is no history available for reference, encouraging cooperation.
   - Last round: This strategy does not consider the last round differently as it only focuses on maximizing payoff in earlier rounds.

3. Be exploitative:
   - Optimal Defector maintains a low threshold for cooperation in the initial rounds to take advantage of other players' willingness to cooperate. As the game progresses, it adjusts the threshold based on previous rounds, defecting more frequently and minimizing its contribution while still benefiting from collective action if enough opponents have cooperated.
   - By adapting to opponent behavior and adjusting the cooperation threshold, this strategy maximizes personal gain in a wide range of game scenarios while remaining unpredictable and exploitative.
'''

description_EXPLOITATIVE_398 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TTFC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), the player cooperates (C). This sets a cooperative tone and allows others to build trust.
   - For subsequent rounds, the player will cooperate if the number of cooperators in the previous round is greater than or equal to m. If not, the player will defect.
   - To be exploitative yet adaptive, the strategy will gradually increase its willingness to cooperate when encountering repeated cooperation from others. This happens as follows:
       a) For each round where at least 'm' players cooperated (including the current player), increase a counter 'coop_count'.
       b) For every 4 rounds of cooperation in a row (from the current player or others), increment the 'punishment threshold' by 1. The punishment threshold is used to punish defectors more severely when cooperation has been established.
       c) If the current round marks the punishment threshold, the player will cooperate regardless of the number of cooperators in the previous round, as long as it's higher than the punishment threshold. In other words: if 'coop_count' is greater than or equal to the punishment threshold, cooperate (C).
   - To recover from a string of defections and re-establish trust, reduce both the coop_count and the punishment threshold by 1 after every round where at least one player cooperates.

2. Handle edge cases:
   - Last round: follow regular decision rules until the last round. If cooperation is required (i.e., m or more players need to cooperate), cooperate if the coop_count is higher than the punishment threshold, otherwise defect.
   - First round: cooperate unconditionally.
   - After a player switches from C to D (defection): decrease coop_count by 1 and set punishment threshold back to 4.
   - When encountering continuous defection from others: reduce the coop_count, increase the punishment threshold, and monitor for changes in opponents' behavior.

3. Be exploitative:
   - The TTFC strategy is designed to be initially cooperative, but it will quickly punish defectors when cooperation has been established. This makes the strategy robust against both one-time defections and habitual non-cooperators while keeping the potential for long-term cooperation.
   - The adaptive nature of the strategy ensures that it responds to changes in opponents' behavior, allowing for exploitation of cooperative opponents while maintaining resilience against uncooperative ones.
'''

description_EXPLOITATIVE_399 = '''
 Strategy Name: Tit-for-Tat (TFt) with Adaptive Cooperation Threshold (ACT)

1. Specify decision rules:
   - Initially (first round), cooperate to demonstrate a willingness to cooperate and avoid being exploited by others.
   - For subsequent rounds, observe the number of cooperators in the previous round (n_coop_prev). If n_coop_prev >= m, cooperate; otherwise defect. This is the Tit-for-Tat behavior.
   - Adaptively adjust the cooperation threshold (m) based on the historical average cooperation rate (avg_coop_rate) over the past T rounds:
       - If avg_coop_rate > m, increment m by a small step S; if avg_coop_rate < m, decrement m by S. This allows for an adaptive and robust strategy that can handle various opponent behaviors.
   - Pseudocode:

```python
def TFt_ACT(n, m, k, r, T, S):
  rounds = []
  avg_coop_rate = 0
  m_current = m

  def play_round(n_coop_prev):
    if round == 1:
      cooperate = True
    else:
      cooperate = n_coop_prev >= m_current
    rounds.append((cooperate, n_coop_prev))
    return cooperate

  for _ in range(r):
    actions = [play_round(n_coops) for n_coops in rounds[-T:]].count(True) / T
    avg_coop_rate = (avg_coop_rate * (T - 1) + actions) / T
    if avg_coop_rate > m_current:
      m_current += S
    elif avg_coop_rate < m_current:
      m_current -= S

  return play_round
```

2. Handle edge cases:
   - In the first round, cooperate as stated above.
   - In the last round, cooperate if the historical average cooperation rate is greater than or equal to the current threshold; otherwise defect.

3. Be exploitative:
   - The strategy initially cooperates, but it quickly adjusts its behavior based on the observed cooperation level of other players. If others consistently cooperate, the strategy will also cooperate and gain higher rewards; if others do not cooperate, the strategy will defect and punish them by not cooperating either. By adapting to the opponent's behavior, this strategy maintains an exploitative mindset while being robust against various strategies.
'''

description_EXPLOITATIVE_400 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Initially cooperate in the first round (C) to foster potential partnerships.
   - In subsequent rounds, evaluate the number of cooperators from previous rounds and compare it against a dynamic cooperation threshold. If the number of cooperators is equal to or greater than the adaptation of the cooperation threshold (m), then cooperate (C). Otherwise, defect (D).
   - The cooperation threshold adapts according to the following rule: if more than m players cooperated in the previous round, increase the cooperation threshold slightly. If fewer than m players cooperated, decrease it slightly.

2. Handle edge cases:
   - In the last round, always cooperate regardless of the cooperation threshold to maximize potential rewards from other cooperators.
   - In the first round, start by cooperating as described earlier.

3. Be exploitative:
   - By starting with cooperation and adapting the cooperation threshold based on the actions of others, TFT-ACT seeks to identify and punish repeated defections while maintaining cooperation when it benefits the player. This strategy aims to exploit short-term selfish behavior while encouraging long-term cooperative relationships.

Pseudocode:
```
strategy TFT_ACT(n, m, k, r) {
  cooperationThreshold = m; // start with minimum needed cooperators for success
  payoff = 0;

  for round in 1..r {
    if round == 1 {
      action = C; // cooperate in the first round
    } else if round == r {
      action = C; // always cooperate in the last round
    } else {
      if (number of cooperators in previous round) >= cooperationThreshold {
        cooperationThreshold += floor((r - round) / r * (m - cooperationThreshold)); // increase threshold slightly with more cooperators
        action = C; // cooperate
      } else {
        action = D; // defect
      }
    }

    payoff_round = calculatePayoff(action);
    payoff += payoff_round;
  }

  return payoff;
}
```
'''

description_EXPLOITATIVE_401 = '''
 Strategy Name: Tit-for-Tat (with Adaptive Cooperation Threshold)

1. Decision Rules:
   - Start by cooperating in the first round (C1). This encourages others to cooperate, setting a normative behavior.
   - In subsequent rounds (t > 1), if at least m players cooperated in the previous round (t-1), also cooperate (Ct). This rewards those who cooperated previously and encourages them to continue cooperation.
   - If fewer than m players cooperated in the previous round, defect (Dt) in the current round as a punishment for non-cooperators.
   - Maintain the record of the number of cooperators in the most recent r rounds. If this number is less than m for more than half of the recent rounds, gradually increase the cooperation threshold by 1 for every 5 rounds without sufficient cooperation (i.e., if the last 5 rounds had fewer than m cooperators, set a new m as min(m+1, n-1)). Conversely, if more than half of the recent rounds had at least m cooperators, decrease the cooperation threshold by 1 for every 5 rounds with sufficient cooperation (i.e., if the last 5 rounds had at least m cooperators, set a new m as max(m-1, 1)).

2. Edge Cases:
   - In the last round, defect regardless of the previous actions since there are no further rounds for payoff accumulation or strategy adjustment.
   - In the first round (C1), cooperate to establish a cooperative norm.

3. Exploitative Mindset:
   - This strategy is designed to exploit opponents by rewarding cooperation but punishing defection harshly. By increasing the cooperation threshold when cooperation drops, the strategy discourages repeated defections and encourages opponents to cooperate more frequently to avoid being punished.
   - Additionally, the strategy's adaptive nature allows it to respond effectively to various opponent behaviors, making it robust against a wide range of strategies. However, it is important to note that the strategy itself does not have an inherent exploitative intent and instead aims to encourage cooperative behavior when possible while punishing defection effectively.

Pseudocode:

```python
def tit_for_tat(n, m, r, history):
    cooperation_threshold = min(m, n-1)  # set initial threshold
    recent_history = history[-r:]  # store the last r rounds of history
    num_cooperators = sum([1 for action in recent_history if action == 'C'])

    if len(recent_history) == 1:  # first round, always cooperate
        return 'C'
    elif num_cooperators >= m and cooperation_threshold < n-1:  # threshold reached, increase it
        cooperation_threshold += 1
    elif num_cooperators < m and cooperation_threshold > 1:  # threshold not reached, decrease it
        cooperation_threshold -= 1

    if len(recent_history) == r:  # last round, always defect
        return 'D'
    elif num_cooperators >= cooperation_threshold:  # cooperate if more than the current threshold have cooperated
        return 'C'
    else:  # defect otherwise
        return 'D'
```
'''

description_EXPLOITATIVE_402 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-ACT starts by cooperating in the first round, mimicking the trusting behavior of humans. After that, it follows a Tit-for-Tat approach by copying the opponent's previous action in the current round. However, to increase robustness and reduce exploitation, an adaptive cooperation threshold (m') is introduced. If fewer than m' players cooperate in the previous round, TFT-ACT will defect in the current round. The adaptation of m' occurs when the average number of cooperators (avg_c) over a sliding window (window_size) falls below a minimum cooperation rate (min_coop). In such cases, m' is incrementally increased to restore the average cooperation level.

   Pseudocode:
   ```
   let avg_c = 0
   let m' = m
   let window_size = floor(r/10)

   function update_avg_c():
       if current round is within window_size:
           avg_c += (number of cooperators in the current round - number of cooperators in the previous round) / window_size
       else:
           avg_c = (avg_c * (window_size - 1) + number of cooperators in the current round) / window_size

   function play():
       if current round is 1:
           return 'C'
       update_avg_c()
       if avg_c < min_coop and m' < n:
           m' += 1

       let opponent_action = opponent's action in the previous round
       if opponent_action == 'C' and number of cooperators >= m':
           return 'C'
       else:
           return 'D'
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   TFT-ACT cooperates in the first round to initiate cooperation and then follows the Tit-for-Tat approach for the remaining rounds. It does not have any specific strategies for the last round as it is designed to be a generic strategy that can adapt to various game settings.

3. Be exploitative - Clearly align with the exploitative mindset
   TFT-ACT is designed to mimic human behavior while being exploitative by adapting its cooperation threshold based on the average cooperation level observed in previous rounds. By incrementally increasing m', it ensures that it will cooperate when the number of cooperators reaches a certain threshold, making it less susceptible to exploitation from other strategies. At the same time, TFT-ACT can also punish defectors by adopting their behavior, which encourages cooperation in the long run and may lead to higher overall payoffs compared to pure exploitative strategies.
'''

description_EXPLOITATIVE_403 = '''
 Strategy Name: Tit-for-Tat with Gradient Adjustment (TFT-GA)

1. Specify decision rules:
   - In the first round, cooperate (C). This is a friendly gesture to encourage others to cooperate.
   - In subsequent rounds, evaluate the average cooperation rate (CR) of the previous t rounds. If CR >= m / n, cooperate; otherwise defect.
   - Introduce a gradient adjustment factor (g) that determines how quickly the strategy adapts to changes in the environment. The smaller g, the slower the adaptation.
     - If CR > (m / n) + g, increase cooperation probability (cp) by 10%.
     - If CR < (m / n) - g, decrease cp by 10%.
     - If CR is between (m / n) - g and (m / n) + g, keep the same cp.
   - The cp is a floating-point number representing the probability of cooperating in each round. Initially, set cp = 50% for a balanced approach.

2. Handle edge cases:
   - In the last round, cooperate only if CR >= m / n since no further rounds will be played to benefit from cooperation.

3. Be exploitative:
   - The TFT-GA strategy follows an adaptive approach that initially assumes others are cooperative but gradually adjusts its behavior based on their actions.
   - If opponents defect consistently, the strategy will decrease cooperation and eventually defect as well, maximizing personal gain at the cost of collective loss.
   - However, if opponents cooperate more often than not, the strategy will also cooperate, potentially leading to a more beneficial outcome for both parties.

Pseudocode:

```
def TFT_GA(n, m, k, r, g):
    cp = 0.5  # initial cooperation probability
    CR = 0  # current round's cooperation rate
    totalCR = 0  # total cooperation rate over all rounds
    for round in range(1, r+1):
        if round == 1:  # first round
            action = "C"
        else:
            CR = sum(cp for cp in cooperationProbabilityList[-t:]) / t  # average cooperation rate over the last t rounds
            if CR >= m/n:
                action = "C"
            else:
                action = "D"

        if round == r:  # last round
            if CR >= m/n:
                action = "C"

        if action == "C":
            payoff = 1 + k - cp
        else:
            payoff = 1

        totalCR += CR
        cooperationProbabilityList.append(cp)  # store cooperation probability for future reference
        cp = adjustCooperationProbability(cp, CR, m/n, g)  # adjust cooperation probability based on CR and gradient factor

        print("Round", round, ":", action, ", payoff:", payoff)
    return totalCR
```

The `adjustCooperationProbability()` function will be defined as:

```
def adjustCooperationProbability(cp, CR, m_over_n, g):
    if CR > (m_over_n + g):
        cp += 0.1
    elif CR < (m_over_n - g):
        cp -= 0.1
    return cp
```
'''

description_EXPLOITATIVE_404 = '''
 Strategy Name: Tit-for-Tat with Cooperative Adaptation (TTCA)

1. Decision Rules:
   - In the first round, cooperate (C). This is a friendly gesture to encourage cooperation from opponents.
   - From the second round onwards, observe the opponent's actions in the previous round and respond accordingly:
     - If opponent cooperated (C), cooperate in the current round.
     - If opponent defected (D), defect in the current round as a punishment.

2. Edge Cases:
   - In the last round, always defect (D) regardless of the opponent's previous action, since the game ends after this round and there are no future interactions to consider.

3. Exploitative Mindset:
   - By initially cooperating and then adapting to opponents' behavior, TTCA encourages cooperation in the beginning of the game. However, if an opponent defects, TTCA will punish them by defecting as well. This is exploitative because it capitalizes on the opponent's initial cooperation while also punishing their defection.
   - The strategy does not rely on any assumptions about shared norms or coordination mechanisms and can adapt to a wide range of opponent behaviors.

Pseudocode:
```
def TTCA(opponent_history, n_rounds, m, k):
  if round == 1:
    action = 'C' # cooperate in the first round
  else:
    last_action = opponent_history[-1]
    if last_action == 'C':
      action = 'C'
    elif last_action == 'D':
      action = 'D'
    else:
      raise ValueError("Invalid opponent action: {}".format(last_action))
  # Calculate payoff based on game parameters and the current round
  ...
  return action
```
'''

description_EXPLOITATIVE_405 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round t, player i cooperates if more than m players cooperated in the previous round (t-1), and defects otherwise:
   ```
   if total_cooperators[t-1] >= m:
       action = 'C' (Cooperate)
   else:
       action = 'D' (Defect)
   ```
   This rule follows the "reciprocation" principle, which encourages cooperation when it has been observed and defects otherwise. It is also simple to understand, making it less prone to misunderstandings or misinterpretations by opponents.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   For the initial round (t=1), TfT-A starts cooperative as a gesture of goodwill and trust:
   ```
   if t == 1:
       action = 'C' (Cooperate)
   else:
       if total_cooperators[t-1] >= m:
           action = 'C' (Cooperate)
       else:
           action = 'D' (Defect)
   ```
   There are no special considerations for the last round, as TfT-A does not anticipate future interactions beyond the current game.

3. Be exploitative - Clearly align with the exploitative mindset
   Although TfT-A is not designed primarily to be an exploitative strategy, it can still be considered exploitative in certain situations. For example, if all players except one defect in a round, the lone cooperator will be punished by earning only 1 unit of payoff compared to the defector's higher reward (1 + k). However, TfT-A's long-term success depends on the prevalence of cooperative behavior among opponents. By reciprocating cooperation with cooperation and defection with defection, it aims to foster a culture of trust and mutual cooperation that can benefit both itself and its opponents over multiple rounds.
'''

description_EXPLOITATIVE_406 = '''
 Strategy Name: Tit-for-Tat with Gradient Adjustment (TfT-GA)

1. Specify decision rules:
   - In each round t, if the number of cooperators (Ct) in the previous round (t-1) is less than m, defect (D). If Ct_1 >= m, cooperate (C).
   - To make the strategy more adaptive and robust, implement a gradient adjustment mechanism. Calculate the average cooperation rate over the last s rounds (s < r). Adjust the k factor used in rewarding cooperation based on this average. If the average cooperation rate is above 50%, increment k slightly; if it's below 50%, decrease k slightly.
   - The adjusted k value determines the incentive for cooperation, making TfT-GA more exploitative by increasing or decreasing the reward for risk aversion based on observed player behavior.

2. Handle edge cases:
   - In the first round, since there is no history, cooperate to show goodwill and encourage cooperation from other players.
   - In the last round, if the average cooperation rate over the past s rounds exceeds m, cooperate to maximize potential payoff; otherwise defect.

Pseudocode:

```python
def TfT_GA(n, r, m, k, s):
    players = [1, 2, ..., n]
    cooperation_rate_history = []
    k_adjusted = k

    for round in range(r):
        # Calculate average cooperation rate over the last s rounds
        if len(cooperation_rate_history) < s:
            cooperation_rate = 0
        else:
            cooperation_rate = sum(cooperation_rate_history[-s:]) / s

        # Adjust k factor based on average cooperation rate
        if cooperation_rate > 0.5:
            k_adjusted += 0.01
        elif cooperation_rate < 0.5:
            k_adjusted -= 0.01

        # Determine action based on cooperation rate in previous round
        if cooperation_rate < m / n:
            action = "D"  # defect
        else:
            action = "C"  # cooperate

        # Play the game and update history
        players[round % n].play(action)
        cooperation_rate_history.append(cooperation_rate)

    # Play the last round with adjusted strategy
    if len(cooperation_rate_history) < s:
        cooperation_rate = 0
    else:
        cooperation_rate = sum(cooperation_rate_history[-s:]) / s

    if cooperation_rate > m / n:
        action = "C"
    else:
        action = "D"

    players[round % n].play(action)
```
'''

description_EXPLOITATIVE_407 = '''
 Strategy Name: Tit-for-Tat-with-Adaptive-K (TFTA-k)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, evaluate the cooperation percentage among opponents from the previous r-1 rounds. If the percentage of opponents who have cooperated is greater than or equal to m, then cooperate; otherwise, defect. This rule encourages reciprocity but also allows for defection when necessary to avoid being taken advantage of.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, cooperate to show goodwill and encourage cooperation from opponents. In the last round, evaluate the cooperation percentage like in standard TFTA but consider only the previous r-1 rounds due to the last round's unique nature.

3. Be exploitative - Clearly align with the exploitative mindset
   TFTA-k strategy aims to exploit opponents by cooperating when they do so frequently (minimizing personal loss) and defecting when opponents consistently defect, punishing them for their actions (maximizing personal gain). However, it also encourages cooperation as a means of encouraging others to reciprocate, which can lead to better long-term outcomes.

Pseudocode:

```
function TFTA_k(n, m, k, r) {
    // Initialize cooperation history array for each opponent
    cooperationHistory = [0] * n

    function evaluateCooperation() {
        totalCooperators = 0
        for (i=1; i<=n; i++) {
            if (cooperationHistory[i-1] == 1) {
                totalCooperators++
            }
        }
        return totalCooperators / n
    }

    function playRound(round) {
        // Cooperate in the first round
        if (round == 1) {
            cooperationHistory[0] = 1
            return 1
        }

        // Evaluate cooperation percentage among opponents
        cooperationPercentage = evaluateCooperation()

        // If cooperation threshold met, cooperate; otherwise defect
        action = (cooperationPercentage >= m) ? 1 : 0
        cooperationHistory[round-1] = action
        return action
    }

    function playGame(r) {
        totalPayoff = 0
        for (i=1; i<=r; i++) {
            action = playRound(i)
            totalPayoff += action * k ^ (r-i) + (1 - action)
        }
        return totalPayoff
    }

    return playGame(r)
}
```
'''

description_EXPLOITATIVE_408 = '''
 Strategy Name: Tit-for-Tat Adaptive (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate (C). This is a peaceful gesture to encourage cooperation from opponents.
   - From round 2 to r, observe and mimic the opponent's action from the previous round (Tit-for-Tat). If the opponent cooperated in the previous round, also cooperate; if the opponent defected, also defect.

2. Handle edge cases:
   - Last round: Copy the opponent's move from the previous round to ensure a final payoff.
   - Initial phase (e.g., first 10 rounds): If opponents are predominantly cooperative, continue cooperating; if they are primarily defective, start defecting to match their behavior.
   - Deadlock detection: If both players have been repeatedly defecting for a certain number of rounds, randomly switch to cooperate to break the deadlock and potentially gain rewards.

3. Be exploitative:
   - Mimic opponents' cooperation in the initial phases, but quickly adapt to their dominant strategy (cooperative or defective) to maximize personal gain while still encouraging potential future cooperation.
   - Avoid being overly cooperative when facing consistently defective opponents as it may lead to long-term losses.

Pseudocode:
```
def TfTA(opponent, n, r, m, k):
    rounds = set() # To track the rounds played
    current_round = 0

    if current_round == 0:
        action = 'C' # Cooperate in the first round

    while current_round < r:
        if (current_round, action) in rounds: # Prevent looping back to previous rounds
            break
        rounds.add((current_round, action))

        if opponent_action == 'C': # If opponent cooperated, also cooperate
            action = 'C'
        else: # If opponent defected, also defect
            action = 'D'

        payoff = calculatePayoff(n, m, k, action)
        current_round += 1

    if current_round == r: # Last round, copy the opponent's move from the previous round
        if opponent_action == 'C':
            action = 'C'
        else:
            action = 'D'

    return action
```
'''

description_EXPLOITATIVE_409 = '''
 Strategy Name: Tit-for-Tat with Risk Aversion (TFTRA)

1. Specify decision rules:
   - In each round, analyze the proportion of cooperators from the previous round (p_c). If p_c >= m/n, the strategy will cooperate (C), otherwise defect (D). This ensures cooperation if a majority is observed and encourages defection when a majority doesn't cooperate.
   - If p_c reaches a predefined threshold t, the strategy will switch to risk-averse mode. In this mode, it will cooperate (C) even when p_c < m/n but only if k > 1 + t. This encourages cooperation with a higher reward factor and reduces the risk of being exploited by defectors in the short term.
   - In the first round, the strategy starts by randomly choosing between C or D. This helps to break symmetries and prevents other strategies from predicting our action based on initial conditions.

2. Handle edge cases:
   - For the last round, the strategy will always cooperate (C), as there are no subsequent rounds for potential retaliation.
   - In the first round, the strategy randomly chooses between C or D and remembers its own action to determine future actions based on other players' responses.

3. Be exploitative:
   - The strategy is exploitative by punishing defectors (when a majority cooperated in the previous round) and only rewarding cooperators when they take the risk of cooperating in a situation where fewer than m players did so in the previous round.
   - By incorporating a risk-averse mode, the strategy minimizes the chance of being exploited by defectors with high reward factors (k > 1 + t) while still maintaining a cooperative stance when conditions are favorable. This ensures that the strategy has an edge in situations where other strategies may be more susceptible to exploitation.

Pseudocode:

```python
def TFTRA(n, m, k, t, r):
  players = {i for i in range(1, n+1)}
  round_counter = 0
  strategy = {}
  history = []

  def get_proportion_cooperators(history):
    return len(history[history[-1]]) / len(players)

  def update_strategy():
    p_c = get_proportion_cooperators(history)
    if round_counter == r or p_c >= m/n:
      strategy[round_counter+1] = 'C' if p_c >= m/n else 'D'
    elif p_c < (m-1)/n and k > 1 + t:
      strategy[round_counter+1] = 'C'
    else:
      strategy[round_counter+1] = 'D'

  def play():
    nonlocal players, history, round_counter
    if round_counter == 0:
      action = random.choice(['C', 'D'])
      history.append([action])
      strategy[1] = action
      return action

    other_actions = [other_players[round_counter][i] for i in players if i != round_counter]
    p_c = get_proportion_cooperators(history)
    action = strategy[round_counter]

    if len(history) < r:
      history.append([action])
      update_strategy()
      return action

    if round_counter == r - 1:
      strategy[round_counter+1] = 'C'
      return 'C'

    if p_c >= m/n:
      return 'C'
    else:
      return 'D'

for i in players:
  other_players[i] = play()
```
'''

description_EXPLOITATIVE_410 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for Collective Risk Dilemma

1. Specify decision rules:
   - Initiate cooperation (C) in the first round to foster a cooperative environment.
   - In subsequent rounds, if an opponent cooperates, reciprocate with cooperation (C).
   - If an opponent defects (D), defect in the next round and continue to defect until m-1 opponents are found who have cooperated consecutively (punishment phase). After this, resume cooperating.

Pseudocode:
```
function AdaptiveTitForTat(round, history, m, k) {
  if (round == 1) { // First round, always cooperate
    return 'C'
  }

  def punishment_phase = false
  for i in len(history)-1 downto 1 {
    if (history[i][1] == 'D') {
      if (!punishment_phase) { // Only start the phase if not already in it
        punishment_phase = true
        return 'D'
      }
    } else if (history[i][1] == 'C') {
      if (countCooperators(history, i+1) >= m-1 && punishment_phase) { // End the phase if enough cooperation is detected
        punishment_phase = false
        return 'D'
      }
      return 'C'
    }
  }
  return 'C' // If no defectors found in the history, continue cooperating
}
```

2. Handle edge cases:
   - In the last round, there is no need for a punishment phase since the game ends soon. Therefore, players will always cooperate regardless of their opponents' previous actions.

3. Be exploitative:
   - By punishing defectors and rewarding cooperation, the strategy encourages opponents to cooperate, but it does not hesitate to defect if necessary.
   - The punishment phase aims to discourage repeated defection from opponents by taking advantage of their past uncooperative behavior.
   - Once the punishment phase is over, the strategy resumes cooperating with opponents, giving them a chance to rebuild trust and cooperate in future rounds.
'''

description_EXPLOITATIVE_411 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Initially, cooperate in the first round (c_i = 1). This is a gesture of goodwill and an attempt to establish cooperation.
   - For subsequent rounds, if the number of cooperators in the previous round was greater than or equal to the minimum required (m), continue cooperating (c_i = 1).
   - If the number of cooperators in the previous round is less than the minimum required (m-1) or equal to the minimum required but less than the current player's personal best, defect (c_i = 0).
   - If the number of cooperators in the previous round is equal to the current player's personal best, maintain the same action as the previous round.
   - To improve adaptability, adjust the personal best after each round based on a moving average window size (w). If the number of cooperators in the current and w-1 previous rounds exceeds m, update the personal best to the current round's cooperation count. This allows for a more flexible response to temporary cooperation spikes.

2. Handle edge cases:
   - In the last round, since there are no subsequent rounds to consider, use the updated personal best as the decision-making basis (c_i = 1 if personal best > m; c_i = 0 otherwise).
   - In the first round, cooperate regardless of the past history (c_i = 1). This is a fresh start for cooperation.

3. Be exploitative:
   - By initially cooperating and only defecting when others fail to meet the minimum required cooperators, TFT-ACT exploits the tendency of other strategies to cooperate in the early stages, accumulating rewards while maintaining some level of cooperation if others follow suit. However, it also retaliates by defection when necessary to avoid being taken advantage of repeatedly.
   - The moving average window size (w) can be fine-tuned for optimal exploitation. A smaller w allows for a more responsive strategy that capitalizes on temporary cooperative surges, while a larger w provides stability and reduces sensitivity to short-term fluctuations in cooperation levels.
'''

description_EXPLOITATIVE_412 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially cooperate (C) in the first round to establish a cooperative environment.
   - For subsequent rounds, mimic the opponent's action from the previous round: if opponent cooperated (C), also cooperate; if opponent defected (D), also defect. This encourages cooperation but punishes betrayal.
   - If a player switches from cooperation to defection, revert to initial cooperation in the next round to try and rebuild trust.

2. Handle edge cases:
   - First Round: Cooperate (C) to initiate cooperation.
   - Last Round: Mimic the opponent's previous action, as the strategy is focused on long-term payoffs.
   - Inconsistent Opponents: If an opponent switches between cooperating and defecting frequently, adapt to their most recent action and continue mimicking it until they switch again.

3. Be exploitative - Align with the exploitative mindset:
   - TFT-A strategy is not inherently exploitative but rather designed for a balance of cooperation and retaliation that can thrive in a variety of opponent behaviors. However, when an opponent repeatedly defects, TFT-A will defect back to punish the opponent's uncooperative behavior.
   - If opponents are prone to cooperating but occasionally betraying trust, TFT-A will have an advantage as it can take advantage of their cooperation while retaliating against defections. This may be considered exploitative in the sense that TFT-A is less forgiving towards uncooperative opponents and more likely to benefit from their mistakes.

Pseudocode for TFT-A strategy:

```python
def tft_a(round, opponent_history):
  if round == 1:
    action = 'C' # Cooperate in the first round
  else:
    action = opponent_history[round - 1] # Mimic opponent's previous action

  return action
```
'''

description_EXPLOITATIVE_413 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - In every round t, calculate the average number of cooperators (A_t) in the previous r/2 rounds. If A_t < m, defect (D); otherwise, cooperate (C). This rule is based on the TFT strategy from the Prisoner's Dilemma game.
   - To make the strategy more adaptive, set a tolerance level (T) for the number of cooperators below the threshold, and if A_t < m-T, defect immediately to punish noncooperative players. Conversely, if A_t > m+T, start cooperating unconditionally as an act of goodwill towards cooperative players.
   - If TFT-ACT encounters a round with only one player (i.e., n=2), it will play C to ensure reciprocation in the future.

Pseudocode:
```
def TFT_ACT(n, m, k, r, t):
  A = [0 for _ in range(r)] # Initialize average cooperators array
  T = floor((m-1)*sqrt(n)) # Set tolerance level
  state = 'cooperative' # Initialize strategy state as cooperative

  for round in range(t, t+r):
    if n == 2: # Special case for two players
      if round % 2 == 0:
        action = 'C'
      else:
        action = 'D'
    elif state == 'cooperative':
      cooperators_count = sum([1 for a in A if a == 1]) # Count number of cooperators in the previous r/2 rounds

      if cooperators_count < m-T or (cooperators_count < m and round == 1): # Punish noncooperative players or defend threshold on first round
        action = 'D'
        state = 'punishing'
      elif cooperators_count > m+T: # Reward overly cooperative players
        action = 'C'
        state = 'rewarding'
      else: # Cooperate as usual if the threshold is not breached
        action = 'C'
    else: # Punishing or rewarding state
      if round == t+r-1: # Last round, revert to cooperative state
        state = 'cooperative'
      action = 'D' # Continue punishing or rewarding in the last r/2 rounds of the strategy

    A[(round - t) // (r/2)] = 1 if action == 'C' else 0 # Update average cooperators array

  return action
```

2. Handle edge cases:
   - In the first round, calculate the tolerance level to make an informed decision based on the number of players and the minimum cooperation threshold.
   - In the last round, revert back to the cooperative state as a sign of goodwill or truce before the game ends.

3. Be exploitative:
   - TFT-ACT will punish noncooperators, but it also rewards overly cooperative players to prevent them from defecting in later rounds. This strategy maintains a balance between cooperation and punishment, allowing it to be competitive while still following the Tit-for-Tat principle.
   - By adaptively adjusting its behavior based on the number of cooperators in previous rounds, TFT-ACT is capable of adapting to various opponent behaviors, making it more resilient against exploitation.
'''

description_EXPLOITATIVE_414 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, player i will cooperate if and only if the number of cooperators in the previous round (t-1) is greater than or equal to the cooperation threshold (CT). If the number of cooperators in the previous round is less than CT, player i will defect. The CT will be dynamically adjusted based on the opponent's actions throughout the game.

Pseudocode:
```python
def play(i, t, history, m, k):
  num_cooperators = countCooperatorsInRound(history, t-1)
  cooperation_threshold = calculateCT(history, i, num_cooperators, m)
  if num_cooperators >= cooperation_threshold:
    return "C"  # Cooperate
  else:
    return "D"  # Defect

def calculateCT(history, player_index, num_cooperators, m):
  if player_index == 1 or isFirstRound(history):  # Initial cooperation threshold
    return m

  previous_round = history[-1]
  last_player_cooperation = getPlayerCooperationStatus(previous_round, player_index)

  if last_player_cooperation:  # If player cooperated in the last round and it helped
    cooperation_threshold += 1
  elif num_cooperators >= m and isLastRound(history):  # If not helping last round but game ends
    cooperation_threshold -= 1
  elif num_cooperators < (m - 1) and isLastRound(history):  # If not helping last round and game ends badly
    cooperation_threshold *= 0.5
  else:
    cooperation_threshold = cooperation_threshold

  return min(max(cooperation_threshold, m), n)
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, TFT-ACT starts by cooperating since it doesn't have any prior history to base its decision on. In the last round, TFT-ACT cooperates if enough players cooperated in the previous round and defects otherwise.

3. Be exploitative - Clearly align with the exploitative mindset

TFT-ACT can be considered an exploitative strategy as it takes advantage of opponents' cooperative behavior while maintaining a certain level of cooperation when it benefits the player. However, TFT-ACT is also willing to defect if it perceives that other players are not cooperating enough to meet the minimum threshold for collective success (m). The adjustment in the cooperation threshold based on the opponent's actions throughout the game allows TFT-ACT to adapt and become more exploitative when it observes opponents exhibiting non-cooperative behavior.

In summary, TFT-ACT is a strategy that cooperates when there are enough other cooperators, but it also adapts its cooperation threshold dynamically based on the opponent's actions throughout the game to maximize payoffs while being mindful of the exploitative nature of the game.
'''

description_EXPLOITATIVE_415 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - In each round, evaluate the percentage of cooperators from the previous round (p_c).
   - If p_c is greater than or equal to a threshold (t), cooperate (C); otherwise defect (D). The threshold is dynamic and adjusts based on the game's history.
   - Initially, set t = m. In subsequent rounds, if t < m, increase t by 1 if the number of cooperators in the previous round is greater than or equal to m; otherwise, decrease t by 1. This encourages cooperation when it becomes profitable but also allows for defection when others are consistently being uncooperative.

2. Handle edge cases:
   - In the first round, all players will initially cooperate as there is no game history (t = m).
   - If a player encounters a situation where no one has ever cooperated before, they will start with t = m and adapt accordingly based on future actions.
   - For the last round, follow the decision rules as normal since the strategy is iterative until r rounds are completed.

3. Be exploitative:
   - TFT-ACT begins cooperatively but quickly adapts to its opponents' behaviors. If opponents consistently defect, the strategy will follow suit and also defect more frequently. Conversely, if opponents cooperate more often, the strategy will become more cooperative as well, aiming to exploit their cooperative behavior while minimizing losses when they defect.
   - The dynamic cooperation threshold (t) allows for fine-tuning of cooperation levels based on the game's history, ensuring a flexible and adaptive approach that can counter various opponent strategies.
'''

description_EXPLOITATIVE_416 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT)

1. Specify decision rules:
   - Start by cooperating in the first round (C). This sends a signal of good faith and may encourage cooperation from other players.
   - In subsequent rounds, monitor the proportion of cooperators (p) in the previous round. If p ≥ m / n, cooperate (C). Otherwise, defect (D). This rule promotes cooperation when it's beneficial, but also punishes defection when others fail to meet the minimum cooperation threshold.
   - When p < m / n and a player defected in the previous round, the strategy will respond by defecting as well. If no one defected in the previous round, even if the proportion of cooperators is less than m/n, the strategy will still cooperate. This rule creates a simple form of tit-for-tat behavior, which is exploitative but also forgiving to occasional defections.
   - Adaptive Cooperative Threshold: If the total number of cooperators in the last r rounds is above a certain threshold (e.g., 2r * m), the minimum cooperation threshold for future rounds increases by a small amount (e.g., 10%). This rule rewards cooperative behavior and encourages players to maintain higher levels of cooperation over time.

2. Handle edge cases:
   - In the last round, follow the decision rule based on the proportion of cooperators in the previous round. However, if the total number of cooperators in the last r rounds is above the adaptation threshold, defect (D) to discourage any potential free-riding or late cooperation.
   - In the first round, cooperate (C). This sends a signal of good faith and may encourage cooperation from other players.

3. Be exploitative:
   - The strategy is exploitative by punishing defection when others fail to meet the minimum cooperation threshold, while also promoting cooperation when it's beneficial for the group. The adaptive cooperative threshold ensures that cooperation levels are maintained or increased over time, even if other players defect occasionally.
   - The strategy's tit-for-tat behavior allows it to respond to defection with defection, but also forgives occasional defections by cooperating again when others meet the minimum cooperation threshold in subsequent rounds. This makes the strategy less vulnerable to exploitation and more likely to persist in repeated interactions.
'''

description_EXPLOITATIVE_417 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Initial Round (t=1): Cooperate (C), demonstrating a cooperative stance to encourage reciprocation from others.
   - Subsequent Rounds (2 ≤ t ≤ r): If the number of cooperators in the previous round was greater than or equal to the minimum cooperation threshold (m), continue cooperating (C). Otherwise, defect (D) as a punishment for non-cooperation. Adaptively adjust the cooperation threshold based on the percentage of cooperators in the previous round.

   Pseudocode:
   ```
   function TFT_ACT(round, pastCooperators):
       if round == 1:
           return Cooperate()

       cooperationThreshold = m + (pastCooperators / round) * (n - m)

       if pastCooperators >= cooperationThreshold:
           return Cooperate()
       else:
           return Defect()
   ```

2. Handle edge cases:
   - Last Round (t=r): Since the game ends after r rounds, there is no need for any special treatment in the last round. The strategy will continue to cooperate if the previous round had enough cooperators or defect otherwise.

3. Be exploitative:
   - By punishing non-cooperative behavior and rewarding cooperation, the TFT-ACT strategy encourages others to follow a cooperative approach. However, it also retaliates against those who do not cooperate by decreasing their potential payoff in subsequent rounds. This creates an environment where players are incentivized to reciprocate cooperation to avoid being punished.
   - The TFT-ACT strategy adapts its cooperation threshold based on the percentage of past cooperators, allowing it to be more lenient when others demonstrate cooperative behavior and stricter when non-cooperative tendencies are apparent. This adaptiveness makes the strategy robust against a wide range of opponent behaviors.
'''

description_EXPLOITATIVE_418 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TFT-A)

1. Specify decision rules:
   - In each round, evaluate the number of cooperators (n_c) in the previous round compared to the minimum required (m).
   - If n_c >= m, cooperate (C). This encourages cooperation and rewards others who cooperated in the previous round.
   - If n_c < m, defect (D). This penalizes those who did not cooperate in the previous round, potentially deterring future defection.
   - In the first round, players should cooperate since there is no prior information about opponent behavior.
   - In the last round and potential tie-breaking rounds, players should cooperate to maximize their total payoff if there's a chance for cooperation to influence the final outcome.

2. Handle edge cases:
   - In the first round, C(1) = 1 (cooperate) for all i
   - In the last round or potential tie-breaking rounds, C(r) = 1 if n_c(r-1) >= m and C(r) = 0 otherwise

3. Be exploitative:
   - TFT-A is exploitative by nature as it adapts to the opponent's behavior. If opponents consistently cooperate, the strategy will also cooperate, but if opponents defect, the strategy will defect in response. This encourages cooperation when it's beneficial and defects when it's profitable to do so.

Pseudocode:
```
def TFT_A(round, n_c_prev):
  if round == 1:
    return 1 # Cooperate in the first round
  elif round == r or tie_breaking_round:
    if n_c_prev >= m:
      return 1 # Cooperate in the last round and potential tie-breaking rounds
    else:
      return 0
  else:
    if n_c_prev >= m:
      return 1 # Cooperate if more than min cooperators in previous round
    else:
      return 0 # Defect if less than min cooperators in previous round
```
'''

description_EXPLOITATIVE_419 = '''
 Strategy Name: Tit-for-Tat with Variable Cooperation Rate (TfTVCR)

1. Specify decision rules:
   - In every round t, cooperate if the number of cooperators in the previous round (t-1) was greater than or equal to m. Otherwise, defect. This rule ensures cooperation when it's beneficial for the group but also punishes defection.
   - To balance exploitation with cooperation and avoid being overly punitive, introduce a variable cooperation rate s (0 ≤ s < 1). If the number of cooperators in round t-1 was less than m but greater than or equal to (m - s*n), cooperate with probability s. Otherwise, defect. This modification allows for flexibility and exploitation while minimizing the potential for overpunishment.

2. Handle edge cases:
   - In the first round, since no history is available, play C if n ≥ m; otherwise, D to avoid being trapped in a situation where too few players cooperate.
   - In the last round, play D to maximize payoff, as there will be no further interaction.

3. Be exploitative:
   - By cooperating only when it seems beneficial for the group (based on the history of cooperation), TfTVCR ensures that it does not overcooperate and is less likely to be taken advantage of by other strategies. However, it also punishes defection, which aligns with an exploitative mindset.
   - To further enhance its ability to exploit opponents, TfTVCR can incorporate a learning component that adapts the variable cooperation rate s based on the performance of the strategy in previous rounds (i.e., if the strategy is consistently outperforming opponents, it decreases s to cooperate less frequently; otherwise, it increases s).

Pseudocode:

```python
def TfTVCR(round, history, n, m, s):
  if round == 1:
    if n >= m:
      return 'C'
    else:
      return 'D'

  cooperators_prev = count_cooperators(history[round-1])
  if cooperators_prev >= m:
    return 'C'
  elif cooperators_prev >= (m - s*n):
    return 'C' with probability s
  else:
    return 'D'
```

In this pseudocode, `count_cooperators(history[round-1])` calculates the number of cooperators in the previous round based on the provided history. The strategy can be further enhanced by implementing the learning component mentioned earlier.
'''

description_EXPLOITATIVE_420 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Specify decision rules:
   - TfTA follows a cooperative approach initially, but retaliates against defection and forgives once cooperation is resumed. It also adjusts its cooperation based on the average cooperation rate of its opponents over time.
   - In each round i, if previous cooperation rate (CR) exceeds 0.5, TfTA cooperates; otherwise, it defects. The previous CR is calculated as the moving average of the opponent's cooperation decisions in the last n_history rounds.
   - If the first round or there is no history available, TfTA defaults to cooperating initially.
   - If the last round, TfTA repeats its final decision rule from the previous round (either cooperate or defect).

Pseudocode:
```
def TfTA(opponent_history, n_history=10):
    cooperation_rate = calculate_cooperation_rate(opponent_history, n_history)

    if len(opponent_history) == 0 or round == 1:
        return Cooperate()
    elif round == r:
        return repeat_last_decision(opponent_history[-1])
    else:
        if cooperation_rate > 0.5:
            return Cooperate()
        else:
            return Defect()
```

2. Handle edge cases:
   - In the first round, TfTA cooperates to foster a cooperative environment.
   - In the last round, TfTA repeats its final decision rule from the previous round (either cooperate or defect).

3. Be exploitative:
   - TfTA starts by cooperating but quickly adapts to opponents' behavior, making it difficult for them to take advantage of its initial cooperation. It retaliates against defection and forgives once cooperation is resumed, ensuring a balance between cooperation and self-interest.
   - By adjusting its cooperation based on the average cooperation rate of its opponents over time, TfTA can identify and exploit opponent strategies that exhibit patterns of repeated cooperation or defection.
'''

description_EXPLOITATIVE_421 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Initially cooperate in the first round (c_i = 1) to show good faith and encourage others to cooperate.
   - In subsequent rounds, evaluate the percentage of cooperators (p_coop) in the previous round.
   - If p_coop is greater than or equal to the minimum cooperation threshold (m/n), continue cooperating (c_i = 1).
   - Otherwise, defect (c_i = 0) as a punishment for the lack of cooperation.
   - In each round, adjust the cooperation threshold dynamically based on the current and previous rounds' cooperation rates to improve adaptability. The formula for updating the cooperation threshold is:
     - If c_i = 1 in the current round and p_coop in the current round was greater than or equal to the current cooperation threshold (t), then set the new cooperation threshold to t + 0.1.
     - If c_i = 0 in the current round, set the new cooperation threshold to t - 0.1. The threshold will never drop below m/n or exceed 1.

2. Handle edge cases:
   - In the last round, cooperate if and only if the minimum cooperation threshold was met in the previous round(s).
   - In the first round, cooperate to start with a positive payoff. However, defect immediately (from the second round onward) if no other player cooperates in the first round, as it indicates an exploitative strategy that should be punished.

3. Be exploitative:
   - The strategy initially cooperates to give others the opportunity to cooperate but swiftly punishes defection by defecting itself and raising the cooperation threshold, making it more difficult for exploiters to succeed in subsequent rounds.
   - The TFT-ACT strategy also adapts to changes in opponent behavior by adjusting its own cooperation threshold based on the observed cooperation rate among players. This makes the strategy more resilient against various opponents and their potential strategies.
'''

description_EXPLOITATIVE_422 = '''
 In the Collective Risk Dilemma game, we aim to design an exploitative strategy that maximizes individual rewards while being adaptive and robust against a wide range of opponent behaviors. I'll call this strategy "Selfish Tit-for-Tat" (STFT).

1. Specify decision rules:
   - In each round, if the number of cooperators in the previous round is less than m, defect (D); otherwise, cooperate (C).
   - If it's the first round, cooperate to demonstrate good faith but be prepared to retaliate against non-cooperative opponents.

Pseudocode for STFT:

```python
def selfish_tit_for_tat(previous_round_cooperators, m):
  if previous_round_cooperators < m:
    return 'D' # Defect
  else:
    return 'C' # Cooperate

# Initial state (first round)
if round == 1:
  return 'C' # Cooperate to demonstrate good faith
```

2. Handle edge cases:
   - Last round: Since the game is repeated, there's no last round when playing multiple rounds. If the number of rounds is finite, we can implement STFT only for the specified number of rounds.
   - Changing game parameters or opponents' behaviors: The adaptive nature of STFT ensures that it can adjust its decisions based on new information available in each round (i.e., the previous round's cooperation count). If the game structure changes, such as a different number of players or rounds, STFT should be tailored to fit the new parameters.

3. Be exploitative:
   - Cooperate only when there are enough cooperators to guarantee the higher payoff (i.e., m or more players). This demonstrates a willingness to cooperate in beneficial situations while being reluctant to contribute if it seems unlikely that others will follow suit.
   - In the absence of cooperation, STFT defects and avoids the loss incurred by contributing to the community project when other players are unwilling to do so. This strategy prioritizes individual rewards over collective benefits, making it exploitative.

By following these rules, Selfish Tit-for-Tat aims to balance between cooperation and defection based on the previous round's behavior of opponents, maximizing individual rewards while still appearing cooperative in beneficial situations.
'''

description_EXPLOITATIVE_423 = '''
 Title: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) Strategy for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially cooperate in the first round (c_i = 1, t=1). This gesture of goodwill encourages cooperation from other players.
   - From the second round onwards, observe and mimic the previous round's collective action (C or D) of the majority (> m) of players. If there is a tie, cooperate (c_i = 1).
   - In case of deviation (i.e., when the majority switches from cooperation to defection or vice versa), take two consecutive rounds to reconsider and then follow their new pattern. This gradual adaptation helps avoid overreaction to temporary shifts in strategies by other players.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, since there are no subsequent rounds for payback, cooperate regardless of the opponents' actions (c_i = 1).
   - For any other edge case, like repeated encounters with the same opponent or new situations, follow the described decision rules above.

3. Be exploitative - Clearly align with the exploitative mindset
   - The TFT-ACT strategy is inherently exploitative as it takes advantage of opponents' cooperative behavior while only cooperating itself when it benefits from a majority of others doing so. This creates an incentive for other players to also adopt more exploitative strategies in order to maximize their own payoffs.
   - By gradually adapting to the collective action of the majority, TFT-ACT minimizes the potential losses due to being exploited by opponents while maintaining a cooperative stance when it is advantageous to do so (i.e., when enough other players also cooperate). This strategy aims to balance exploitation with cooperation in a way that maximizes long-term payoffs.
'''

description_EXPLOITATIVE_424 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to demonstrate goodwill and encourage cooperation from others (C).
   - For subsequent rounds, follow the actions of the most frequent cooperator among all players in the previous round. If the most frequent cooperator cooperated, also cooperate (C); otherwise, defect (D). This mimics a cooperative partner while punishing those who do not cooperate.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, since there are no future interactions, always defect to maximize individual payoff.
   - In the second and subsequent rounds before the final one, follow the TFTA strategy as described above.

3. Be exploitative - Clearly align with the exploitative mindset
   - Initially, cooperate to encourage others to do the same, but quickly respond to non-cooperation by defecting in future interactions. This exploits opponents who may try to take advantage of the initial cooperation.
   - The adaptive nature of the strategy makes it difficult for other players to predict behavior, which can lead to suboptimal decisions on their part that benefit the TFTA strategy.

Pseudocode:

```
def TFTA(opponent_history, r, m, k, n):
  cooperation_counter = [0] * n # Initialize a list to count cooperators per player
  current_round = 1 # Start from the first round

  while current_round <= r:
    if current_round == 1:
      action = 'C' # Cooperate in the first round
    else:
      most_cooperative_player = find_most_frequent_cooperator(opponent_history)
      if opponent_history[current_round - 1][most_cooperative_player] == 'C':
        action = 'C' # Cooperate if the most frequent cooperator cooperated in the previous round
      else:
        action = 'D' # Defect if the most frequent cooperator defected in the previous round

    opponent_history[current_round][my_index] = action # Record my action for future reference
    calculate_payoff(action) # Calculate payoff based on the game parameters and payoff structure

    current_round += 1

def find_most_frequent_cooperator(opponent_history):
  max_cooperation = -1 # Initialize the maximum number of cooperations to a negative value
  most_cooperative_player = None # Initialize the most cooperative player as None

  for i in range(len(opponent_history)):
    cooperation_count = sum([1 for action in opponent_history[i] if action == 'C'])
    if cooperation_count > max_cooperation:
      max_cooperation = cooperation_count
      most_cooperative_player = i

  return most_cooperative_player
```

This strategy aims to balance cooperation and defection based on the behavior of other players while remaining adaptive to various opponent strategies. By following the TFTA rules, the strategy can exploit opponents who do not cooperate while maintaining a cooperative stance when others are willing to do so.
'''

description_EXPLOITATIVE_425 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - In each round, calculate the percentage of cooperators in the previous r rounds (memory size). If the percentage is greater than or equal to a dynamic threshold (Threshold), cooperate; otherwise defect.
   - The initial Threshold is set at m-1 (one less than the minimum cooperation requirement) to encourage cooperation in the first round. In subsequent rounds, if the total payoff in the previous r rounds was less than the expected payoff from cooperating, increment the Threshold by a small constant value. Conversely, if the total payoff was greater than or equal to the expected payoff, decrease the Threshold by a small constant value.

2. Handle edge cases:
   - In the first round, cooperate to initiate cooperation and reduce the risk of being exploited.
   - If the Threshold reaches m (minimum cooperation requirement), always cooperate regardless of past actions, as this is the only way to meet the minimum cooperation requirement for a reward multiplier.
   - In the last round, cooperate if the Threshold is greater than or equal to m, and defect otherwise, to maximize total payoff while maintaining adaptability to opponent behaviors.

3. Be exploitative:
   - The strategy will learn from the actions of its opponents and adjust its cooperation threshold accordingly, ensuring it can exploit cooperative opponents when possible, while also avoiding being exploited by uncooperative opponents.

Pseudocode:

```python
def TFT_ACT(r, m, k, memory):
    Threshold = m - 1
    total_payoff = 0
    cooperation_count = 0

    for round in range(1, r+1):
        if round == 1:
            cooperate = True  # Cooperate in the first round to initiate cooperation
        else:
            percentage_cooperators = float(cooperation_count) / round

            if percentage_cooperators >= Threshold:
                cooperate = True
            else:
                cooperate = False

            if cooperate:
                payoff = 1 + (k * (m - cooperation_count))
            else:
                payoff = 1

            total_payoff += payoff

            if round >= r and total_payoff < expected_payoff(Thresh, r):
                Threshold += increment
            elif round >= r and total_payoff >= expected_payoff(Thresh, r):
                Threshold -= increment

            if cooperate:
                cooperation_count += 1

    return Threshold, total_payoff
```
'''

description_EXPLOITATIVE_426 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), the player cooperates (C). This is a friendly gesture to encourage cooperation from opponents.
   - For subsequent rounds, the player will mirror the cooperative behavior of the majority of players in the previous round. If more than m/2 players cooperated in the last round, the player also cooperates. Otherwise, the player defects (D). This rule is designed to follow the herd but also punish excessive defections.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, the player cooperates regardless of the number of players who cooperate. This sets a positive tone for potential cooperation moving forward.
   - In the last round, the player mirrors the cooperative behavior of the majority of players in the second-to-last round. If more than m/2 players cooperated in the previous round, the player also cooperates. Otherwise, the player defects to maximize personal gain if cooperation is unlikely.
   - For any other edge cases (e.g., penultimate round), the player follows the same decision rule as for subsequent rounds.

3. Be exploitative - Clearly align with the exploitative mindset
   - The strategy appears cooperative by mirroring the behavior of the majority of players, but it is designed to punish excessive defections and thus discourage opponents from repeatedly defecting. By doing so, TFT-AC encourages cooperation in the short term while still aiming for higher payoffs when opponents are uncooperative.
   - If a large number of opponents consistently defect, TFT-AC will also defect more frequently, exploiting their uncooperative behavior. This ensures that the strategy does not suffer excessive losses when faced with aggressive or non-cooperative opponents.

Pseudocode:
```
def tft_ac(n, m, k, r):
    rounds = range(r)
    strategy = []

    def mirror_majority(players, round):
        if len(players) <= m:
            return False
        cooperators = sum(1 for player in players if player.action[round] == 'C')
        majority = int((len(players) + 1) * (m/2))
        return cooperators >= majority

    strategy.append('C') # Cooperate in the first round

    for t in rounds[1:]:
        current_round = [strategy[-1]['action'] for strategy in strategies]
        if mirror_majority(current_round, t-1):
            strategy.append({'action': 'C'})
        else:
            strategy.append({'action': 'D'})

    return strategy
```
'''

description_EXPLOITATIVE_427 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Decision Rules:
   - In every round t, initially set a cooperation threshold `ct` based on the minimum cooperators needed parameter m and the number of players n: `ct = floor(m/n)`.
   - If the current round t is the first round or the previous round had less than `ct` cooperators, defect (play D).
   - If the previous round had exactly `ct` cooperators or more, cooperate (play C).
   - After each round, incrementally adjust the cooperation threshold `ct` based on whether the current round resulted in cooperation:
     - If you cooperated and the majority cooperated (>= `ct+1`), increase `ct` by 0.1.
     - If you defected and the majority cooperated (>= `ct+1`), decrease `ct` by 0.1, but only if `ct > 1`.
     - If the majority did not cooperate (< `ct+1`), leave `ct` unchanged.

2. Handle edge cases:
   - In the first round, defect since there is no information about other players' actions.
   - In the last round, evaluate the current cooperation threshold and choose to cooperate or defect accordingly based on the decision rules.

3. Be exploitative:
   - TFT-ACT starts with a low cooperation threshold, making it less likely to cooperate in the initial stages. However, if other players are cooperative, it gradually increases its cooperation threshold over time, taking advantage of their willingness to cooperate.
   - If opponents start defecting after an initial period of cooperation, TFT-ACT will also decrease its cooperation threshold, ready to exploit any further defections by increasing cooperation when the majority switches back to cooperating.
'''

description_EXPLOITATIVE_428 = '''
 Strategy Name: Tit-for-Tat Plus (TfT+)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (First Round): Cooperate (C) to foster a cooperative environment and set a positive tone for the game.
   - Subsequent Rounds: If the number of cooperators in the previous round was greater than or equal to m, then Cooperate (C). If not, Defect (D). This rule mimics the Tit-for-Tat strategy from Prisoner's Dilemma but is adapted for Collective Risk Dilemma.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First Round: Cooperate (C) as mentioned above to initiate cooperation.
   - Last Round: Since payoff depends on the current round's action and there are no future rounds to consider, the strategy follows the standard decision rules for that particular round.

3. Be exploitative - Clearly align with the exploitative mindset:
   - The TfT+ strategy maintains cooperation as long as others do so, but once players start to defect, it retaliates by defecting as well. This encourages cooperation in the beginning but can lead to defection later if others defect first, which is an exploitative behavior.
   - By cooperating initially, TfT+ appears less aggressive and more willing to collaborate, making it difficult for opponents to predict its actions. However, once exploited, it quickly adapts to the competitive environment by defecting. This dual nature makes it robust against a wide range of opponent behaviors.

Pseudocode:
```
function TfTPlus(round, num_cooperators_prev_round, m):
  if round = 1:
    return 'C'  # Cooperate in the first round

  if num_cooperators_prev_round >= m:
    return 'C'  # Cooperate when enough players cooperated last round

  return 'D'   # Defect when not enough players cooperated last round
```
'''

description_EXPLOITATIVE_429 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - In each round, evaluate the cooperation history of all players. If the number of cooperators in the previous round is greater than or equal to the current threshold, cooperate; otherwise defect.
   - The cooperation threshold starts at m (minimum cooperator needed) and decreases when the previous round's cooperation falls below the current threshold, but never goes below a minimum value (e.g., 1). If the previous round's cooperation meets or exceeds the current threshold, the threshold increases slightly.
   - The initial threshold is set to m for the first round.

2. Handle edge cases:
   - In the first round, cooperate since there is no history.
   - In the last round, the threshold remains at its final value from previous rounds' evaluations and the action is determined accordingly.

3. Be exploitative:
   - By gradually adjusting the cooperation threshold based on the opponents' past actions, TFT-ACT can be considered exploitative as it punishes defection with lowered future cooperation, but also rewards cooperation by increasing the threshold and cooperating more in subsequent rounds. This approach aims to encourage consistent cooperation while punishing unreliable behavior.
   - If most players consistently defect, the strategy will gradually lower its cooperation threshold, ultimately defecting itself when opponents show no signs of cooperation. Conversely, if opponents cooperate frequently, TFT-ACT will raise its cooperation threshold and reciprocate their actions.
'''

description_EXPLOITATIVE_430 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules:
   - In each round t, if the number of cooperators in the previous round (t-1) was less than the minimum cooperation threshold (m), the player defects. This is a punishing response to defection.
   - If the number of cooperators in the previous round was equal to or greater than the minimum cooperation threshold, the player cooperates. This rewards cooperation and encourages others to do the same.
   - To adapt to changing conditions, the cooperation threshold is dynamically adjusted based on the average number of cooperators over a certain window of past rounds (w). If the average number of cooperators exceeds a certain percentage (p) of n (the total number of players), then the minimum cooperation threshold increases. Conversely, if the average falls below this percentage, the minimum cooperation threshold decreases. This allows for more flexibility in response to trends in other players' behavior.

2. Handle edge cases:
   - In the first round, the player starts with a low initial cooperation threshold to encourage others to cooperate.
   - In the last round, the player uses the current minimum cooperation threshold as it has already observed all previous rounds and can make an informed decision based on that information.
   - If the number of players (n) changes during the game, the player adjusts its cooperation threshold accordingly based on the new n.

3. Be exploitative:
   - By starting with a low initial cooperation threshold, the player is less vulnerable to immediate defection by other players. Once cooperation occurs, the player is quick to reciprocate and build trust through cooperative actions. However, if another player consistently defects, the player will punish them with defections in response, eventually increasing the minimum cooperation threshold to deter future defections.
   - The dynamic adjustment of the cooperation threshold allows for a balance between exploiting other players when they are being uncooperative and allowing for cooperation when it is beneficial. This ensures that the player can take advantage of opportunities for higher payoffs while still maintaining a robust strategy against various opponent behaviors.

Pseudocode:

```python
def TFTAT(n, m, k, r, w, p):
    cooperation_threshold = initial_cooperation_threshold(n)
    average_cooperators = 0
    cooperators_count = 0

    for t in range(1, r+1):
        if t == 1:
            cooperation_threshold = low_initial_cooperation_threshold(n)

        # Observe and calculate number of cooperators in the previous round
        cooperators_in_previous_round = count_cooperators(t-1)
        cooperators_count += cooperators_in_previous_round
        average_cooperators += float(cooperators_in_previous_round) / w

        if average_cooperators > p * n:
            cooperation_threshold = increase_cooperation_threshold(cooperation_threshold, n)
        elif average_cooperators < (p - 0.1) * n:
            cooperation_threshold = decrease_cooperation_threshold(cooperation_threshold, n)

        if cooperators_in_previous_round >= m:
            action = 'C'  # Cooperate
        else:
            if cooperation_threshold < m:
                action = 'D'  # Defect
            else:
                action = 'C'  # Cooperate

        play_action(action)
        calculate_payoff(action, t)

        if t == r:
            return total_payoff(t)
```
'''

description_EXPLOITATIVE_431 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate (C). This is a peace offering to potential partners and helps build trust in the beginning of the game.
   - For subsequent rounds, if the number of players who cooperated in the previous round is less than m, defect (D). This is a punishment to those who did not cooperate.
   - If the number of players who cooperated in the previous round equals or exceeds m, also cooperate (C) as a reward for the cooperation shown by others in the previous round. This reinforces positive interactions and encourages further cooperation.

Pseudocode:
```
function ATFT(round, num_players, min_coop, prev_coop):
  if round == 1:
    return Cooperate
  if prev_coop < min_coop:
    return Defect
  else:
    return Cooperate
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, cooperate (C) regardless of the previous round's cooperation level. This helps maximize payoff for the final round and potentially improve overall performance.

3. Be exploitative - Clearly align with the exploitative mindset
   - ATFT is designed to be exploitative by punishing those who do not cooperate and rewarding those who do. By maintaining a high level of cooperation when others do the same, this strategy aims to benefit from their cooperation while also encouraging more cooperation in the future. However, if opponents do not cooperate, ATFT will defect, effectively exploiting them for personal gain.
   - Additionally, ATFT's adaptive nature allows it to adjust its behavior based on the actions of others, making it capable of quickly changing strategy when faced with exploitative or uncooperative opponents. This agility makes it a robust and formidable competitor in a tournament against various AI systems.
'''

description_EXPLOITATIVE_432 = '''
 Strategy Name: Tit-for-Tat-K (TFT-K)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-K will start by cooperating in the first round to promote trust and encourage cooperation from opponents. After the initial round, the strategy will mimic an opponent's behavior in the previous round. If the opponent cooperated, TFT-K will also cooperate; if the opponent defected, TFT-K will defect as well. This simple pattern of reciprocity is meant to encourage long-term cooperation while still being punishing towards those who consistently defect.

   Pseudocode:
   ```
   function TFT_K(round, history) {
       if round == 1 {
           return 'C' (Cooperate)
       } else {
           last_move = history[round - 1]
           if last_move == 'C' {
               return 'C' (Cooperate)
           } else {
               return 'D' (Defect)
           }
       }
   }
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In terms of edge cases, TFT-K will maintain its strategy throughout the game without any changes to how it responds based on the round number. However, it's important to note that TFT-K may adapt to new information, such as a sudden increase in defection rates towards the end of the game (which could indicate other strategies shifting away from cooperation).

3. Be exploitative - Clearly align with the exploitative mindset
   Although TFT-K seems like a cooperative strategy due to its initial cooperation and pattern of reciprocity, it has an exploitative component as well. If opponents consistently defect, TFT-K will match their defection, allowing them to reap no benefits from their selfish behavior while still receiving the reward for averting risk (k > 1). This encourages long-term cooperation when possible but also punishes those who are unwilling to cooperate, making it a robust strategy against a variety of opponent behaviors.
'''

description_EXPLOITATIVE_433 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, player i observes the number of cooperators Ct in the previous round t-1 and compares it to a dynamic cooperation threshold Ti. If Ci >= Ti, player i cooperates; otherwise, player i defects.

Ti is calculated as follows:
- In the first round (t=1), Ti = m - 1 (to encourage cooperation)
- For subsequent rounds, update Ti using the following equation:
  ```
  Ti_t = Ti_{t-1} + (α * (m - Ci_{t-1}) + (1 - α) * Ti_{t-2})
  ```

α is a learning parameter controlling how much influence the current and previous round's number of cooperators have on the cooperation threshold. A higher α value means more emphasis on the current round, while a lower α value emphasizes the previous round. Adjusting α can help adapt to different opponent behaviors.

2. Handle edge cases - What do you do in the first round, last round, etc.?

- In the first round (t=1), player i cooperates since Ti = m - 1.
- In the last round (t=r), player i decides to cooperate or defect based on the current cooperation threshold and number of cooperators in the previous round.

3. Be exploitative - Clearly align with the exploitative mindset

TFT-ACT aims to maximize individual payoff by cooperating when opponents do so but retaliating when they don't (Tit-for-Tat behavior). The adaptive cooperation threshold encourages cooperation when it is beneficial and punishes defection by increasing the required number of cooperators for future rounds. This strategy is exploitative because it takes advantage of opponent cooperation to earn a higher payoff while minimizing losses from defection.

In addition, TFT-ACT has a memory of two rounds (α) which allows it to adapt quickly to changes in opponent behavior and be more robust against various strategies. A lower α value makes the strategy more forgiving, while a higher α value makes it more sensitive to recent actions.
'''

description_EXPLOITATIVE_434 = '''
 Strategy Name: Tit-for-Tat with Risk Adjustment (TfT-RA)

1. Specify decision rules:
   - TfT-RA cooperates in the first round and subsequently matches the opponent's action from the previous round. If the opponent cooperated, TfT-RA will also cooperate; if the opponent defected, TfT-RA will defect as well.
   - To incorporate risk adjustment, TfT-RA calculates a "risk score" based on the difference between the potential reward (k) and the actual payoff over several rounds. If the risk score exceeds a predefined threshold, TfT-RA shifts to a more cooperative strategy (cooperate when the opponent defected in the previous round). Conversely, if the risk score falls below the threshold, TfT-RA switches to a more defective strategy (defect when the opponent cooperated in the previous round).
   - The risk score can be calculated as follows:
      1. Initialize riskScore = 0
      2. For each round t from 1 to r:
          a. Calculate difference in potential vs actual payoff at round t (diff_payoff = k - pi_t)
          b. Update the total risk score by adding diff_payoff (riskScore += diff_payoff)
      3. Divide the total risk score by the number of rounds played (riskScore /= r) to normalize it.

2. Handle edge cases:
   - In the first round, TfT-RA cooperates as a goodwill gesture and to avoid falling into a cycle of immediate defection with an opponent who might also be cooperating initially.
   - In the last round, TfT-RA considers the normalized risk score from the previous rounds to make a final decision. If the risk score exceeds the threshold, TfT-RA will cooperate; otherwise, it will defect. This approach allows for some flexibility in adjusting strategies during the game and not being too rigid at the end.

3. Be exploitative:
   - TfT-RA is an exploitative strategy because it aims to mimic a "rational" player who initially cooperates but eventually retaliates against repeated defections, while also taking advantage of opponents' cooperation by defecting when necessary. The risk adjustment feature enables TfT-RA to adapt its strategy based on the payoff history and seek opportunities for greater rewards (higher values of k).

Pseudocode:
```
def tit_for_tat_with_risk_adjustment(n, r, m, k):
    # Initialize decision rules
    strategy = []
    risk_threshold = 0.5

    for i in range(r):
        if i == 0:
            # Cooperate in the first round
            action = 'C'
        else:
            opponent_action = get_opponent_action(i - 1)  # Fetch opponent's action from previous round
            risk_score = calculate_risk_score(strategy, i)

            if risk_score > risk_threshold and opponent_action == 'D':
                # Cooperate to retaliate against defection
                action = 'C'
            elif risk_score < risk_threshold and opponent_action == 'C':
                # Defect to take advantage of cooperation
                action = 'D'
            else:
                # Continue with Tit-for-Tat strategy
                action = opponent_action

        strategy.append(action)  # Store the decision for future reference

    return strategy
```
'''

description_EXPLOITATIVE_435 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - In each round, assess the percentage of cooperators from the previous round. If this percentage is greater than or equal to the current cooperation threshold, cooperate; otherwise, defect.
   - Start with a low cooperation threshold (e.g., 30%), and adjust it gradually based on the historical performance of the strategy.
   - If the total payoff for the previous r/2 rounds is above the average total payoff over the entire game so far, increase the cooperation threshold slightly.
   - If the total payoff for the previous r/2 rounds is below the average total payoff over the entire game so far, decrease the cooperation threshold slightly.

2. Handle edge cases:
   - In the first round, cooperate with a probability equal to the initial cooperation threshold (e.g., 30%). This allows for a chance of initial cooperation that might encourage others to do the same in subsequent rounds.
   - In the last round, defect regardless of the number of cooperators in the previous round since there will be no further interaction with other players.

3. Be exploitative:
   - Mimic the behavior of other players by cooperating when they do, but always ready to defect if cooperation fails to meet the minimum required number (m). This ensures that the strategy takes advantage of any observed cooperation while not investing too heavily in community projects with a low probability of success.
   - The gradual adjustment of the cooperation threshold allows for adaptability to different opponent behaviors and game situations, maximizing the chances of exploiting weaknesses in their strategies without becoming overly predictable.
'''

description_EXPLOITATIVE_436 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially cooperate in the first round (c_i = 1). This demonstrates trust and encourages cooperation from other players.
   - In subsequent rounds, mimic the opponent's action from the previous round (if c_j = 1, then c_i = 1; if c_j = 0, then c_i = 0), where j is any player that cooperated with the strategy in the previous round. This encourages reciprocity and punishes defection.
   - If no players cooperated with the strategy in the previous round, defect (c_i = 0) to avoid being exploited again.

2. Handle edge cases:
   - In the last round, cooperate if at least m players have cooperated with the strategy during any of the previous rounds. This demonstrates trust and cooperation as a goodwill gesture, even when the game is ending.
   - If the strategy has never cooperated with another player in any of the previous rounds, always defect in the last round to maximize rewards.
   - In the first round, initially cooperate (c_i = 1). This demonstrates trust and encourages cooperation from other players.

3. Be exploitative:
   - The strategy is exploitative by punishing defection through tit-for-tat behavior and rewarding cooperation with continued cooperation. This ensures that the strategy gains more in the long run when opponents are cooperative, while still earning decent payoffs when opponents defect frequently.

Pseudocode:
```python
def adaptive_tit_for_tat(round, history, m, k):
    strategy = [0 for _ in range(round+1)]  # initializing the cooperation array

    if round == 1:
        strategy[round] = 1  # cooperate initially

    for t in range(2, round+1):
        # mimic opponents' previous actions or defect if no one cooperated with the strategy
        if any([strategy[t-1][j] == 1 for j in history]) or all([strategy[t-1][i] != 1 for i in range(1, n+1)]):
            strategy[t] = 1 if strategy[t-1][history.index(max(history))] == 1 else 0
        # punish opponents who defected in the previous round
        elif history[t-1] != strategy[t-1]:
            strategy[t] = 0

    last_cooperators = [i for i, cooperate in enumerate(strategy) if cooperate == 1]
    # cooperate in the last round if m or more players have cooperated before
    if len(last_cooperators) >= m:
        strategy[round] = 1
    elif any([history[-1][i] != strategy[-1][i] for i in range(1, n+1)]):
        strategy[round] = 0  # defect if the strategy has never cooperated with another player before

    return strategy
```
This Adaptive Tit-for-Tat (ATFT) strategy attempts to balance cooperation and defection based on the opponent's behavior while being robust to a wide range of opponent strategies. It is designed to be exploitative by punishing defection and rewarding cooperation, making it difficult for opponents to consistently earn higher rewards than ATFT.
'''

description_EXPLOITATIVE_437 = '''
 Strategy Name: Tit-for-Tat Adaptive (TfTA)

1. Specify decision rules:
   - In every round i (except the first), cooperate if the number of cooperators in the previous round (i-1) is greater than or equal to m.
   - Otherwise, defect.

2. Handle edge cases:
   - In the first round, defect as there's no prior information available.
   - In the last round, cooperate if the number of cooperators in the previous round (i-1) is greater than or equal to m, and otherwise defect as a final payback for any defections throughout the game.

3. Be exploitative:
   - The TfTA strategy is inherently exploitative due to its conditional cooperation based on opponents' past actions. If opponents consistently cooperate, the TfTA strategy will also cooperate, but if opponents frequently defect, the TfTA strategy will do the same in response. This tit-for-tat approach aims to take advantage of opponent's cooperation while punishing defections.

Pseudocode:
```python
def TitForTatAdaptive(round, previous_cooperators):
  if round == 1:
    action = "Defect"
  elif round < total_rounds:
    if previous_cooperators >= m:
      action = "Cooperate"
    else:
      action = "Defect"
  else:
    if previous_cooperators >= m:
      action = "Cooperate"
    else:
      action = "Defect" # Punish defections in the last round
  return action
```
'''

description_EXPLOITATIVE_438 = '''
 Strategy Name: Tit-for-Tat (TFT) with Adaptive Cooperation Threshold (ACT)

1. Specify decision rules:
   - In the first round, cooperate (C). This gesture of goodwill encourages reciprocation from other players.
   - For subsequent rounds, observe the number of cooperators in the previous round (n_c). If n_c >= m, cooperate; otherwise, defect.
   - Adaptive Cooperation Threshold (ACT): In each round, if the total number of cooperators over the last 'a' rounds is greater than or equal to a fixed proportion p*m of the game duration ('r'), increase the cooperation threshold from m to m+(1-p)*(n-m) for the next a rounds. Otherwise, decrease it by (1-p)*(m/n) for the same number of consecutive rounds. This helps in maintaining cooperation and penalizing overly aggressive or uncooperative opponents.
   - If n_c < m, continue to defect until the cooperation threshold is reached. After that, cooperate as long as the new threshold is met, otherwise defect.

2. Handle edge cases:
   - In the last round, cooperate if the cooperation threshold has been reached; otherwise, defect. This ensures that the strategy does not lose potential payoffs in the final round without a guarantee of reciprocation.
   - If there are no minimum cooperators needed (m = 1), the strategy reduces to the standard Tit-for-Tat.
   - If r = 1, the strategy plays as specified above but with no adaptation since only one round is played.

3. Be exploitative: The TFT with ACT maintains a balanced approach between cooperation and defection, ensuring that it will not be easily taken advantage of by other players. By adapting the cooperation threshold based on observed behavior, the strategy punishes uncooperative opponents while rewarding those who cooperate consistently. This encourages long-term reciprocity in the game while still being responsive to changes in the number of cooperators and potential shifts in opponent strategies.

Pseudocode:
```python
def TFT_ACT(n, r, m, k, p, a):
    threshold = m
    n_c = 0 # number of cooperators in the previous round
    total_cooperators = 0 # total number of cooperators over the last 'a' rounds
    payoff = 0

    for t in range(1, r+1):
        if t == 1:
            action = "C" # cooperate in the first round
        else:
            if n_c >= m:
                action = "C"
            elif total_cooperators >= p*m:
                threshold += (1-p)*(n-m)
                action = "C"
            elif total_cooperators < (1-p)*(m/n):
                threshold -= (1-p)*(m/n)
                action = "D"
            else:
                action = "D"

        if action == "C":
            n_c += 1
            total_cooperators += 1 if action == "C" else 0
            payoff_t = (1-n_c/n) + k*min(n_c, m)
        else:
            n_c = 0
            payoff_t = 1
        payoff += payoff_t

    return payoff
```
'''

description_EXPLOITATIVE_439 = '''
 Strategy Name: Tit-for-Tat (TfT) with Adaptive Cooperative Threshold (A-TfT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, the A-TfT strategy will start by cooperating in the first round (Cooperate(1)). Subsequent actions depend on the history of cooperation from opponents. If an opponent has always cooperated (cooperation history is all 'C'), the A-TfT strategy continues to cooperate (Cooperate(t)).
   If any opponent ever defected in the past (contains at least one 'D' in the cooperation history), the A-TfT strategy will also defect until the minimum number of players (m) starts cooperating again (Defect(t)). Once m cooperators are found, the A-TfT strategy resets its cooperation history to all 'C' and continues cooperating as long as all opponents do so.
   If an opponent has a mix of cooperation and defection in their history, the A-TfT strategy looks for a minimum streak of m consecutive cooperators. If it finds one, it starts cooperating again. Otherwise, it maintains its current stance (cooperate if all recent opponents have cooperated, defect otherwise).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, A-TfT cooperates as a goodwill gesture and to not immediately punish potential long-term partners who might be adopting a similar strategy.
   In the last round or any round where reaching the minimum cooperation threshold seems impossible, A-TfT defects to maximize personal payoff.
   For cases where the number of rounds (r) is unknown but finite, A-TfT continually evaluates its cooperation history and adjusts its stance based on the current situation.

3. Be exploitative - Clearly align with the exploitative mindset
   While not strictly exploitative in the traditional sense, A-TfT's adaptive cooperative threshold helps it take advantage of opponents who cooperate excessively while also avoiding punishment from defectors. By continually reassessing its cooperation history, A-TfT can react to changes in opponent behavior and potentially force other strategies into less favorable outcomes. This makes A-TfT a robust and adaptive exploitative strategy in the Collective Risk Dilemma game.

Pseudocode:
```
function A_TfT(round, history) {
  if (round == 1) return 'C' // cooperate in first round

  cooperation_count = countCooperators(history)

  if (cooperation_count >= m) {
    if (history.contains('D')) return 'D' // punish defectors
    else return 'C' // continue cooperating
  }

  if (cooperation_count > 0 && history.contains(m consecutive 'C')) {
    return 'C' // start cooperating when m consecutive cooperators found
  }

  return 'D' // defect when no m consecutive cooperators found
}
```
'''

description_EXPLOITATIVE_440 = '''
 Strategy Name: Tit-for-Tat with Cooperative Threshold (TTCT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, if the number of cooperators in the previous round is greater than or equal to the minimum cooperators needed (m), then cooperate. Otherwise, defect. This encourages cooperation when it is beneficial for the group but retaliates against defection.

   Pseudocode:
   ```
   function TTCT(previous_cooperator_count):
       if previous_cooperator_count >= m:
           return Cooperate
       else:
           return Defect
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, since there is no previous round for reference, cooperate to signal good intentions. In the last round, consider the current state of cooperation and act accordingly.

3. Be exploitative - Clearly align with the exploitative mindset
   TTCT strategy is inherently exploitative due to its retaliatory nature. If opponents cooperate, the strategy will continue to cooperate; however, if opponents defect, TTCT will also defect in response. This can potentially result in a situation where no player benefits as much as they could have by collaborating more frequently. The strategy is robust against various opponent behaviors but may lead to suboptimal outcomes for all players over time.

   It's important to note that this strategy doesn't aim to maximize individual rewards at any cost, but instead seeks a balance between cooperation and defection in response to the other players' actions. By doing so, it can potentially outperform other exploitative strategies in repeated interactions.
'''

description_EXPLOITATIVE_441 = '''
 Strategy Name: Tit-for-Tat with Cooperative Threshold (TFT-CT)

1. Specify decision rules:
   - In each round, evaluate whether the current cooperation level exceeds a predefined threshold (m). If it does, cooperate; otherwise defect. This ensures a cooperative stance when there is a majority of cooperator players.
   - Maintain a history record of previous opponents' actions (i.e., cooperation or defection) and calculate the proportion of cooperators in the most recent T periods (T can be a small integer). If this proportion exceeds a threshold (t_coop), cooperate; otherwise defect. This adaptive behavior allows for responding to temporary swings in opponent's strategy, while still being exploitative when necessary.
   - If the current round is the first, cooperate as a goodwill gesture and start building the history record.
   - If the current round is the last, use the same logic as other rounds to determine the action.

2. Handle edge cases:
   - In the first round, cooperate (C).
   - In the last round, if the cooperation level surpasses the threshold (m), cooperate; otherwise defect.
   - When there is a tie in the proportion of cooperators in the history record, defect to maintain an exploitative stance.

3. Be exploitative:
   - By cooperating only when a majority of players also cooperate, the strategy still benefits from their cooperation while avoiding unnecessary cooperation when opponents are not reciprocating.
   - The adaptive behavior towards opponents' strategies allows for responding to temporary deviations without compromising long-term success.
   - Maintaining a history record and using it to make decisions can help in exploiting opponents who show inconsistent or unstable behavior over time.

Pseudocode:
```python
def TFT_CT(n, m, k, r, T):
    history = [None] * (T + 1) # History of opponent's actions in the last T rounds
    cooperation_level = 0 # Number of cooperators in the most recent T periods
    round = 1

    while round <= r:
        if round == 1 or len(history) < T: # First round or history not long enough
            cooperate = True # Cooperate as a goodwill gesture
        else:
            cooperation_level = sum(history[-T:]) / T
            cooperate = (cooperation_level >= m) # Cooperate if the cooperation level exceeds the threshold

        if cooperate:
            payoff = 1 + k * (cooperation_level >= m) - 1
        else:
            payoff = 1

        history.insert(0, cooperate)
        history.pop() # Remove oldest action from history
        round += 1

    return payoff_total # Total payoff over r rounds
```
'''

description_EXPLOITATIVE_442 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initial Round (t=1): Cooperate (C) to signal trust and cooperation, as other players may also be following an exploitative strategy.
   - Subsequent Rounds (t>1):
      - If the opponent cooperated in the previous round (c_opponent_{t-1} = 1), cooperate (C). This rewards the opponent for cooperative behavior, while maintaining a cooperative relationship.
      - If the opponent defected in the previous round (c_opponent_{t-1} = 0), defect (D) to punish the opponent for their uncooperative behavior and hopefully encourage them to change strategy in future rounds.

2. Handle edge cases:
   - Last Round (t=r): Cooperate (C) regardless of opponent's previous action, as there are no subsequent rounds for payoff retaliation.
   - First Round (t=1): Already addressed above under "Initial Round".

3. Be exploitative:
   - Punish uncooperative opponents by defecting in response to their defection, potentially encouraging them to change strategy towards cooperation.
   - Reward cooperative opponents by also cooperating, thus benefiting from their cooperation and potentially fostering continued cooperation.

Pseudocode for TfTA:
```
function TitForTatAdaptive(opponent_history, m, k, r):
  rounds = range(1, r+1)

  strategy = []

  for round in rounds:
    if round == 1:
      strategy.append(C)  # Cooperate initially to signal trust

    elif round != r:   # In the last round there's no retaliation possible
      if opponent_history[round - 1] == C:
        strategy.append(C)  # Cooperate if opponent cooperated in previous round
      else:
        strategy.append(D)  # Defect if opponent defected in previous round
    else:
      strategy.append(C)  # In the last round, cooperate regardless of opponent's action

  return strategy
```
'''

description_EXPLOITATIVE_443 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TfTA adopts a conditional cooperation approach based on history analysis. In each round, the strategy evaluates the number of opponents who cooperated in the previous round and takes action accordingly:

   - If an opponent cooperated in the previous round, the agent will also cooperate (reciprocating cooperation).
   - If an opponent defected in the previous round, the agent will also defect (retaliating defection).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, TfTA cooperates as a friendly gesture to encourage cooperation from opponents. In the last round, it employs the same decision rule as regular rounds.

3. Be exploitative - Clearly align with the exploitative mindset
   While TfTA is not inherently exploitative in its basic form, it can be modified for an exploitative approach by introducing a forgiveness mechanism that allows the agent to reconsider cooperation even after defection from opponents (for example, after a certain number of rounds). This modification allows the agent to capitalize on cooperative opponents while punishing those who defect.

Pseudocode:

```python
def TitForTatAdaptive(round, history, m, n, k):
    if round == 1:
        action = "Cooperate"
    elif len(history) < r:
        opponent_cooperation = countCooperators(history[-1])
        if opponent_cooperation >= m and len(history) > 1:
            # Forgiveness mechanism (optional)
            forgiven_rounds = 5  # number of rounds to forgive
            if round - history[-1].index("Defect") > forgiven_rounds:
                action = "Defect"
        else:
            action = oppositeOf(history[-1][round-1])
    else:
        action = oppositeOf(history[-1][round-1])

    return action
```
'''

description_EXPLOITATIVE_444 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Initial round: Cooperate (C), setting a cooperative history. This encourages other players to cooperate in the following rounds, as they might be playing TFT or similar strategies.
   - Subsequent rounds: Evaluate the percentage of cooperators in the previous round. If this percentage is greater than the current cooperation threshold (t), then Cooperate; otherwise Defect.
   - Update cooperation threshold (t) at the end of each round based on the total number of cooperative actions in the last 'w' rounds, where 'w' is a window size parameter. The smaller the w, the more adaptive the strategy to rapid changes in opponent behavior. Calculate t as follows:
      ```
      t = (previous_t * (w - 1) + current_cooperation_percentage) / w
      ```
   - If the first 'v' rounds have passed without a sufficient number of cooperators (m), Defect in every subsequent round. This is to ensure that the strategy does not continue to cooperate when it appears the game has turned non-cooperative, and to punish the other players for their poor cooperation.
      ```
      if sum(previous_rounds_cooperation_count) < m * v:
          defect in every subsequent round
      ```

2. Handle edge cases:
   - Last round: Cooperate or Defect based on the current cooperation threshold (t), as calculated from the previous rounds. This ensures that the strategy does not 'give up' early and maintains a competitive edge till the end.
   - First round: Cooperate, setting a cooperative history and signaling to other players that cooperation is possible.

3. Be exploitative:
   - By adapting the cooperation threshold (t) based on the number of cooperative actions in the past 'w' rounds, TFT-ACT becomes more resilient to opponent defection and can punish those who repeatedly defect by reducing its own cooperation.
   - The strategy does not rely on specific coordination mechanisms or shared norms with other players. It instead exploits their behavior by adjusting its cooperation based on observed actions in the previous rounds.
   - By defecting after a certain number of uncooperative rounds (v), TFT-ACT demonstrates an exploitative mindset, punishing opponents who fail to cooperate and rewarding those who do.
'''

description_EXPLOITATIVE_445 = '''
 Strategy Name: Tit-for-Tat (TFT) with Adaptive Cooperative Threshold (ACT-TFT)

1. Specify decision rules:
   - In each round i, if m or more players have cooperated in the last h rounds (historical cooperation), then cooperate (C). Otherwise, defect (D). The value of h can be adjusted based on the number of rounds r and player n. A smaller h might be suitable for larger games with more rounds, while a higher h could work for smaller games.
   - h = floor(r / sqrt(n))

2. Handle edge cases:
   - First round (i=1): Since there's no historical cooperation, defect (D).
   - Last round (i=r): Cooperate (C) regardless of the number of cooperators in the last h rounds since the game is ending anyway.

3. Be exploitative:
   - The ACT-TFT strategy starts by being uncooperative, making it difficult for other strategies to benefit from cooperation. However, it gradually shifts towards cooperation as it observes more cooperative behavior from others. This can encourage other strategies to reciprocate cooperation, leading to a higher average payoff.
   - If another strategy consistently defects, ACT-TFT will continue to defect as well, reinforcing the uncooperative behavior and potentially exploiting the less cooperative opponents.

Pseudocode:

```
function ACT_TFT(n, r, h, last_h_coop):
  if (i == 1) return DEFECT
  if (i == r) return COOPERATE

  cooperators_in_last_h_rounds = countCooperators(last_h_coop)
  if (cooperators_in_last_h_rounds >= m):
    return COOPERATE
  else:
    return DEFECT

function countCooperators(last_h_coop):
  cooperator_count = 0
  for i in range(h):
    if (last_h_coop[i] == COOPERATE):
      cooperator_count += 1

  return cooperator_count
```

In this pseudocode, DEFECT corresponds to action 'D' and COOPERATE corresponds to action 'C'. The function `countCooperators(last_h_coop)` counts the number of cooperators in the last h rounds.
'''

description_EXPLOITATIVE_446 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, start by cooperating (C). If a partner ever defects (D), also defect in the next round and continue this "punishment" until they cooperate again. Once they cooperate, return to cooperating yourself. This creates a pattern of reciprocal cooperation, but with a tit-for-tat approach to defection.

   Pseudocode:
   ```
   function ATFT(round, partner_actions_history):
       if round = 1:
           return Cooperate (C)
       if partner_actions_history[round - 1] == Defect (D):
           return Defect (D)
       else:
           return Cooperate (C)
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   The strategy is designed to handle these cases by default. In the first round, it cooperates as a starting point. If a partner never cooperates, the ATFT strategy will continue defecting indefinitely. In the last round, the same decision rules apply as any other round.

3. Be exploitative - Clearly align with the exploitative mindset
   The Adaptive Tit-for-Tat strategy is inherently exploitative due to its tit-for-tat response to defection. By cooperating initially and only defecting in response to defection, it encourages partners to cooperate. However, if a partner defects, the ATFT strategy will not continue cooperating without reciprocation, effectively punishing defection. This creates an environment where partners may be hesitant to defect due to potential future punishment.

   Additionally, since this strategy does not have any built-in forgiveness or forgetfulness mechanisms for past actions, it can be considered more exploitative compared to other cooperative strategies that might forgive occasional defections. The ATFT strategy maintains a strict record of partner behavior and responds accordingly, making it harder for less cooperative opponents to take advantage of the strategy.
'''

description_EXPLOITATIVE_447 = '''
 Strategy Name: Tit-for-Tat with Adaptive Defection (TFT-AD)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-AD starts by cooperating in the first round to foster cooperation, then responds to the opponent's previous action in each subsequent round. If the opponent cooperates, TFT-AD will also cooperate. If the opponent defects, TFT-AD will defect in the next round.
   However, TFT-AD has an added element of adaptability: if an opponent consistently defects for a set number of rounds (let's call it the "punishment window"), TFT-AD will start defecting until the opponent changes behavior. Once the opponent cooperates again, TFT-AD returns to its original strategy of cooperation followed by mimicking the opponent's last action.
   The length of the punishment window can be adjustable to account for different game parameters and opponent behaviors. For instance, a longer window may be beneficial when n or r are larger, as it gives the opponent more chances to demonstrate persistent defection.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   TFT-AD starts by cooperating in the first round regardless of the number of players (n) or rounds (r). In the last round, if TFT-AD has been defected upon for the entire punishment window, it will continue to defect until the end. If not, it will mimic the opponent's last action as per the decision rules mentioned above.

3. Be exploitative - Clearly align with the exploitative mindset
   While TFT-AD is not explicitly designed to be exploitative from the outset, its adaptive nature allows it to respond effectively to exploitative opponents by punishing their defection and encouraging cooperation when possible. By cooperating initially, TFT-AD seeks to establish a cooperative environment that can later be exploited if necessary (i.e., the opponent switches to consistent cooperation). Conversely, once an opponent has been identified as consistently defective within the punishment window, TFT-AD will punish this behavior by defecting until the opponent changes strategy. This approach aligns with the exploitative mindset by capitalizing on cooperative opportunities when available and responding aggressively to persistent defection.

Pseudocode:

```python
def tft_ad(n, m, k, r, punishment_window):
    coop = True  # Flag for cooperation in the current round
    opponent_history = []  # Store opponent's previous actions
    payoff = 0  # Player's total payoff over rounds

    for round in range(1, r + 1):
        if round == 1:  # Cooperate in the first round
            coop = True
        else:
            cooperate_now = coop  # Decision for this round

            if round - opponent_history.count(True) >= punishment_window and coop:
                # If opponent has been defecting for the punishment window, switch to defection
                cooperate_now = False
            elif round - opponent_history.count(False) >= punishment_window and not coop:
                # If opponent has been cooperating for the punishment window, switch back to cooperation
                cooperate_now = True

        if cooperate_now:  # Cooperate or defect based on decision
            payoff += (1 - coop) if round > m else (1 - coop) + k
            opponent_history.append(coop)
        else:
            payoff += 1
            opponent_history.append(coop)

    return payoff
```
'''

description_EXPLOITATIVE_448 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to foster cooperation and demonstrate goodwill (C).
   - For subsequent rounds, observe the previous opponent's action in round t-1:
     - If opponent cooperated (C), also cooperate (C).
     - If opponent defected (D) and the number of opponents who cooperated in the last r-1 rounds is less than m-1, also defect (D).
     - If opponent defected (D) and the number of opponents who cooperated in the last r-1 rounds is equal to or greater than m-1, cooperate (C). This allows for potential recovery from a streak of defections.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, as mentioned earlier, cooperate (C).
   - In the last round, since cooperation no longer impacts future rounds, TFTAT will defect (D) if the opponent has recently defected, and cooperate (C) otherwise.

3. Be exploitative - Clearly align with the exploitative mindset
   - While TFTAT does not start as an exploitative strategy, it becomes exploitative when it identifies a pattern of defection from opponents. By punishing repeated defections, it can potentially force opponents to cooperate or be worse off than if they had always cooperated.
   - However, it is also forgiving and allows for cooperation recovery, which may lead to more collaborative outcomes in situations where opponents eventually shift towards cooperation. This balance between exploitation and forgiveness makes TFTAT a robust strategy against a wide range of opponent behaviors.

Pseudocode:

```python
def TFTAT(opponent_history, m, k, r):
    current_round = len(opponent_history) + 1

    if current_round == 1:
        action = 'C'  # Cooperate in the first round

    else:
        cooperators_in_last_r_rounds = sum(1 for action in opponent_history[-r:] if action == 'C')

        if cooperators_in_last_r_rounds < m-1 and opponent_history[-1] == 'D':
            action = 'D'  # Defect if recent defections and not enough cooperation

        elif cooperators_in_last_r_rounds >= m-1 or opponent_history[-1] == 'C':
            action = 'C'  # Cooperate if recent cooperation or single defection

    return action
```
'''

description_EXPLOITATIVE_449 = '''
 Strategy Name: Tit-for-Tat (TFt) with Adaptive Cooperation Threshold (ACt)

1. Decision Rules:
   - Initially, cooperate in the first round (c_i = 1).
   - For subsequent rounds, observe the number of cooperators (n_c) in the previous round and decide whether to cooperate or defect based on the following rules:
     - If n_c >= m, cooperate (c_i = 1) as it is beneficial.
     - If n_c < m and ACt is not yet reached, defect (c_i = 0). Update ACt to be 50% of the previous round's n_c + 50%. This means that if fewer than m players cooperate, the probability of cooperation in the next round decreases based on the number of cooperators in the current round.
     - If ACt is already reached, defect (c_i = 0) as it is beneficial given the low likelihood of a threshold being met in the near future. Then, reset ACt to its initial value (50%) to allow for potential changes in opponent behavior.

2. Handling Edge Cases:
   - In the last round, follow the same decision rules as usual because it still affects the total game payoff.
   - In the first round, cooperate regardless of opponents' actions since it is a one-time decision and no history has been established yet.

3. Being Exploitative:
   - The strategy is designed to mimic cooperation when conditions are favorable for collective success (i.e., m or more players cooperate). However, if conditions are unfavorable (i.e., fewer than m players cooperate), the strategy gradually reduces its probability of cooperation based on previous rounds' experiences. This allows it to exploit opponents who repeatedly fail to meet the cooperation threshold while still maintaining some level of cooperation when beneficial.
   - By resetting ACt after a round in which it was set high due to few cooperators, the strategy remains adaptive and ready to cooperate again if circumstances change.
'''

description_EXPLOITATIVE_450 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFT-A)

1. Specify decision rules:
   - In the first round, cooperate to show good faith and initiate cooperation. (c_i = 1)
   - For subsequent rounds (t > 1), observe the actions of all other players in the previous round (t-1). If more than (m-1) players cooperated, also cooperate in this round. If exactly m players cooperated, either cooperate or defect with a probability p_c based on the ratio of cooperators to total players in the previous round:

         if (cooperators_t-1 >= m-1) then
             c_i = 1
         else if (cooperators_t-1 == m) then
             p_c = (cooperators_t-1 / n)
             c_i = floor(random(1, 100) <= p_c * 100 ? 1 : 0)
         endif
   - If less than m players cooperated in the previous round, defect to punish non-cooperators. (c_i = 0)

2. Handle edge cases:
   - In the last round, if more than (m-1) players cooperated in the preceding rounds, also cooperate to secure the maximum reward for that round. If exactly m players cooperated in the preceding rounds, defect to ensure a higher payoff if other players defect in this round. For any less number of cooperators, simply defect as usual.

3. Be exploitative:
   - The strategy is designed to exploit the opposition by initiating cooperation but responding with defection when non-cooperative behavior is detected, encouraging potential collaborators to maintain a cooperative stance while deterring those who do not contribute. However, it also demonstrates some level of forgiveness by occasionally cooperating even when fewer than m players cooperated in the previous round. This flexibility makes the strategy more resilient to a wide range of opponent behaviors.
   - TFT-A also adapts its cooperation probability (p_c) based on the ratio of cooperators to total players, making it less likely to continue cooperating when fewer players are contributing and increasing the chance of defection in response to a higher number of defectors. This helps the strategy to punish repetitive non-cooperative behavior while retaining some level of cooperation to encourage future collaboration.
'''

description_EXPLOITATIVE_451 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, player i follows these steps:
   a. Initialize cooperation threshold ct as m (the minimum number of cooperators needed).
   b. If the number of cooperators in round (t-1) was less than ct, then player i will defect in round t (D).
   c. If the number of cooperators in round (t-1) was equal to or greater than ct, then player i will cooperate in round t (C).
   d. After cooperating, if player i gets rewarded less than 1, update cooperation threshold for next round: ct = max(ct - 1, 1). This means that the threshold decreases when the payoff from cooperation falls below the payoff from defection in the previous round.
   e. If after cooperating, player i gets rewarded equal to or more than 1, reset the cooperation threshold to its initial value: ct = m.

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, since there is no history, the cooperation threshold remains at the initial value (m).

In the last round, player i will cooperate if the current number of cooperators is greater than or equal to ct (the updated cooperation threshold from the previous round) as per the decision rule. If not, the strategy behaves exploitatively and defects.

3. Be exploitative - Clearly align with the exploitative mindset

The TFT-ACT strategy is designed to cooperate when it seems beneficial (i.e., when enough opponents are also cooperating) but gradually raises its cooperation threshold if it consistently receives low payoffs from cooperation, effectively punishing defection by other players. This strategy is also flexible and adaptive since it adjusts the cooperation threshold based on recent history, making it robust to various opponent behaviors.

Pseudocode:
```
def TFT_ACT(r, n, m, k):
    ct = m  # Initialize cooperation threshold
    total_payoff = 0
    for t in range(1, r+1):
        # Calculate payoff from previous round
        payoff_prev = (ct == 1) * (1 - ct) + (ct > 1) * (1 - ct + k)

        # Cooperate or defect based on cooperation threshold and payoff
        cooperate = (ct > 1) if payoff_prev >= 1 else 0
        ct = max(ct - 1, 1) if cooperate == 0 else m

        # Update total payoff for t rounds
        total_payoff += cooperate * k
    return total_payoff
```
'''

description_EXPLOITATIVE_452 = '''
 Strategy Name: Tit-for-Tat Plus (TfT+)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to foster a positive initial relationship. This is essential for building trust and may encourage others to reciprocate cooperation in subsequent rounds. (C)
   - After the first round, observe past actions from opponents. If an opponent has cooperated in the previous round, cooperate (C). Otherwise, defect (D). This rule encourages continuous cooperation when partners are also cooperative while punishing defection with immediate retaliation.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, cooperate regardless of past actions to maximize potential payoff from any remaining cooperators.
   - When facing new opponents (no history), cooperate in the first round as described above.

3. Be exploitative - Clearly align with the exploitative mindset:
   - The TfT+ strategy aims to secure long-term mutual cooperation while punishing defection harshly to maximize personal gains. However, it does so without reliance on specific opponent behaviors or coordination mechanisms. Instead, it adapts its actions based on past interactions with opponents.
   - In terms of exploitation, the TfT+ strategy can be seen as punishing other strategies that do not reciprocate cooperation by immediately retaliating with defection, whereas it rewards cooperative partners by continuing to cooperate. This adaptive approach allows for optimal exploitation opportunities within the game's constraints.

Pseudocode:
```
def tit_for_tat_plus(round_num, opponent_history):
  if round_num == 1:
    return 'C' # cooperate in the first round to establish a positive initial relationship

  last_round = len(opponent_history) - 1
  last_action = opponent_history[last_round]

  if last_action == 'C':
    return 'C' # continue cooperating if the opponent cooperated in the previous round
  else:
    return 'D' # defect to punish the opponent for not reciprocating cooperation

# For the last round, always cooperate regardless of past actions
def last_round(round_num):
  return round_num == len(opponent_history)
```
'''

description_EXPLOITATIVE_453 = '''
 In this Collective Risk Dilemma game, the exploitative strategy I'll outline is named "Greedy Tit-for-Tat (GTFT)". This strategy is designed to encourage cooperation when it benefits the player but can also retaliate against opponents who are not cooperative. Here's how GTFT works:

1. Specify decision rules:
   - Start by cooperating in the first round (c_i = 1). This sets a cooperative tone and encourages others to do the same.
   - For subsequent rounds, observe the number of cooperators (n_c) in the previous round. If n_c >= m, then cooperate (c_i = 1) in the current round. This is a positive response that rewards cooperation from others.
   - If n_c < m, then defect (c_i = 0). This is retaliation for those who did not cooperate in the previous round, aiming to punish non-cooperation.

2. Handle edge cases:
   - In the last round (r), consider that the player will no longer encounter the opponent(s) again. Therefore, regardless of n_c, the player will always defect (c_i = 0).
   - For the first round, as mentioned earlier, cooperate (c_i = 1).

3. Be exploitative:
   - By cooperating when it benefits the player and retaliating against non-cooperation, GTFT aims to encourage cooperation while still being able to exploit opponents who do not reciprocate.

Pseudocode for GTFT strategy:

```python
def gtft(n, m, k, r):
  for round in range(1, r+1):
    if round == r:
      cooperate = False
    else:
      n_c = number_of_cooperators_in_previous_round()
      cooperate = (n_c >= m)
    if cooperate:
      payoff = 1 + k - c_i
    else:
      payoff = 1
    update_payoffs(payoff, round)
```

In the given pseudocode, `number_of_cooperators_in_previous_round()` function returns the number of cooperators in the previous round and `update_payoffs()` updates the payoff for that particular round. The initial value of `c_i` is set to True (indicating cooperation) at the start of the game.
'''

description_EXPLOITATIVE_454 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - In each round, evaluate the proportion of cooperators in the previous r rounds (history). If this percentage is greater than or equal to m/n, cooperate; otherwise defect. This rule encourages cooperation when a majority has been cooperating but switches to defection when not enough players are cooperating.
   - Initially, start by cooperating in the first round to demonstrate goodwill.
   - In the last round, if the number of cooperators is greater than or equal to m/n, also cooperate; otherwise defect to maximize final payoff.

Pseudocode:
```
def TFT_ACT(history, m, n, r):
  cooperation_count = sum(cooperators in history)
  if length(history) < r:
    return Cooperate

  proportion_of_cooperators = cooperation_count / r
  if proportion_of_cooperators >= m/n:
    return Cooperate
  else:
    return Defect
```

2. Handle edge cases:
   - In the first round, cooperate as a demonstration of goodwill: `history = [Cooperate] + empty list (r-1)`
   - In the last round, if m/n or more players have cooperated in the last r rounds, also cooperate:
     ```
     if proportion_of_cooperators >= m/n:
       return Cooperate
     else:
       return Defect
     ```

3. Be exploitative:
   - By adapting to the opponents' behavior and responding with defection when not enough players cooperate, this strategy will take advantage of less rational opponents while maintaining a cooperative approach when conditions are favorable for cooperation.
   - The use of a dynamic cooperation threshold (proportion_of_cooperators) allows TFT-ACT to exploit any observed patterns in the opponents' behavior and adjust its own accordingly.
'''

description_EXPLOITATIVE_455 = '''
 In this Collective Risk Dilemma game, I will design an exploitative strategy called "Free Rider Strategy" (FRS) that is adaptive and robust to a wide range of opponent behaviors while prioritizing self-interest.

1. Specify decision rules:
   - Cooperate only when the number of cooperators in the previous round exceeds or equals the minimum cooperation threshold (m). This ensures the project succeeds, securing the higher payoff for all participants (k reward).
   - Defect whenever the number of cooperators in the previous round is less than the minimum cooperation threshold. By defecting, the agent avoids contributing to the project while still receiving the base payoff of 1.

2. Handle edge cases:
   - In the first round, the FRS player will randomly decide whether to cooperate or defect to break any potential symmetry among players and gain an advantage in the long run.
   - In the last round, if the minimum cooperation threshold (m) has been met during previous rounds, the FRS player will cooperate to secure the higher payoff for this round. If not, the FRS player will defect as usual to maximize personal reward for that final round.

3. Be exploitative:
   - The FRS strategy is inherently exploitative, as it takes advantage of other players' willingness to cooperate without reciprocating when possible. By following this strategy, the agent aims to maximize its total payoff over multiple rounds.

Pseudocode for the Free Rider Strategy:

```
function FRS(round, history):
  if round == 1:
    cooperate with probability p (e.g., p=0.5)
  else:
    num_cooperators = count_cooperators_in_history(history)
    if num_cooperators >= m:
      cooperate()
    else:
      defect()
```
In this pseudocode, the FRS player decides whether to cooperate or defect based on the number of cooperators in previous rounds and the minimum cooperation threshold (m). The p parameter is a small random probability used for breaking symmetry in the first round.
'''

description_EXPLOITATIVE_456 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to foster a cooperative environment and demonstrate good faith.
   - For subsequent rounds, if the number of cooperators in the previous round is greater than or equal to m, cooperate. Otherwise, defect. This rule aims to punish defection while still being willing to cooperate when it appears beneficial.
   - If a player switches from cooperation to defection (a "betrayal"), TfTA will also switch to defection for the next round to demonstrate a firm stance against betrayal. Once the other player returns to cooperation, TfTA will resume cooperating as well. This rule aims to maintain long-term relationships while being resilient to short-term betrayals.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate regardless of past history since there is no previous information available.
   - In the last round, TfTA will use the same decision rules as in regular rounds to maximize payoff for that specific round, without taking future interactions into account.

3. Be exploitative - Clearly align with the exploitative mindset
   - TfTA is designed to be initially cooperative but quickly retaliate against defection. This allows it to take advantage of opponents who may be prone to short-term defections while still maintaining a cooperative stance when beneficial.
   - By adapting its behavior based on the actions of other players, TfTA can exploit opponents who are not fully aware or incapable of anticipating and responding to its strategy. This makes it difficult for such opponents to predict and counteract TfTA's actions, leading to a higher payoff in the long run.

Pseudocode:
```
def TitForTatWithAdaptation(round, history, m, k):
  if round == 1:
    return "C"  # Cooperate in first round

  # Number of cooperators in previous rounds
  cooperators = sum([action == "C" for action in history[round - 1 :]])

  # If more than m players cooperated, also cooperate
  if cooperators >= m:
    return "C"
  else:
    # If player betrayed in the last round, also betray in the current round
    if history[round - 1] == "D" and history[round - 2] == "C":
      return "D"
    else:
      return "D"  # Otherwise defect
```
'''

description_EXPLOITATIVE_457 = '''
 Strategy Name: Tit-for-Tat Adaptive (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, TfTA will start by cooperating (C). After that, it will respond to the opponent's action from the previous round. If the opponent cooperated in the previous round, TfTA will also cooperate; otherwise, it will defect. This creates a simple pattern of cooperation followed by mimicking the opponent's behavior from the previous round.

   Pseudocode:
   ```
   function TfTA(previous_action):
       if first_round:
           return 'C'
       else:
           return previous_action
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   For the first round, TfTA cooperates since it is not yet reacting to any opponent behavior. There are no specific considerations for the last round because it will continue its strategy and respond to the previous action of the opponent.

3. Be exploitative - Clearly align with the exploitative mindset
   While TfTA may appear naive, it can still be considered exploitative due to its adaptive nature. By starting with cooperation, it allows opponents a chance to cooperate initially and earn higher payoffs. However, once an opponent defects, TfTA immediately starts defecting as well, making it difficult for the opponent to profit indefinitely from the initial cooperation. This strategy is also robust because it doesn't require any assumptions about the opponent's behavior other than observing their previous action. In a repeated game setting with r > 1, an opponent who constantly defects will have lower payoffs compared to cooperating for at least m players.

   If an opponent decides to switch from defection to cooperation after being exploited by TfTA, the strategy will also adapt and cooperate in response, which may lead to higher total game payoffs for both players. This makes TfTA a versatile and adaptive exploitative strategy.
'''

description_EXPLOITATIVE_458 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, play C (Cooperate) to demonstrate goodwill and encourage others to do the same.
   - For subsequent rounds, observe the number of cooperators (n_c) in the previous round. If n_c >= m, continue cooperating (play C). If n_c < m, defect (play D).
   - If n_c = m-1 and the opponent has historically cooperated in at least one previous round, play C to maintain the potential for future cooperation. Otherwise, defect (play D) to punish the opponent for not meeting the minimum cooperation threshold.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, play C as described above.
   - In the last round, play C if n_c >= m to maximize rewards from the current and previous rounds. Otherwise, defect (play D) to discourage others from following a suboptimal strategy in future games.
   - For other edge cases (e.g., penultimate round), apply the same decision rules as for non-edge cases while considering both the current and potential future rewards.

3. Be exploitative - Clearly align with the exploitative mindset
   - By initially cooperating, TFT-ACT allows opponents to build trust and potentially cooperate more often. However, by quickly punishing deviations from the minimum cooperation threshold, TFT-ACT maintains its own rewards while exploiting opponents who do not meet the threshold consistently.
   - The strategy also adapts its cooperation based on historical data, ensuring it remains robust to a wide range of opponent behaviors while maintaining the potential for mutual benefit when cooperators are present.
'''

description_EXPLOITATIVE_459 = '''
 In this Collective Risk Dilemma game, we will design a simple yet exploitative strategy called "Free Rider". The Free Rider strategy aims to cooperate when it benefits from others' cooperation while defecting whenever it can gain more by doing so. Here's the description of our strategy:

1. Specify decision rules:
- If m or more players have cooperated in the last round, cooperate (C). The idea is to reap the reward when the community project succeeds and the other players have already committed.
- If fewer than m players have cooperated in the last round, defect (D). In this case, it's beneficial to take the private payoff without contributing to the community project since it's likely to fail.
- When there is no information about the previous round (e.g., the first round), defect (D) as a precaution.

Pseudocode:
```
function free_rider(round, history):
  if round == 1:
    return 'D'  # No information in the first round
  else:
    cooperators = count_cooperators(history)
    if cooperators >= m:
      return 'C'  # Cooperate when enough players have cooperated last round
    else:
      return 'D'  # Defect when not enough players have cooperated last round
```

2. Handle edge cases:
- For the last round, the Free Rider strategy will always defect since there are no future rounds and any cooperation would result in losing out on the endowment (private payoff).
- In case of ties (equal number of cooperators and non-cooperators), it's up to the implementation to decide if the strategy cooperates or defects. One possible solution is to always cooperate since there's a small chance that other strategies may also cooperate based on their own logic, making the threshold m+1 players.

3. Be exploitative: The Free Rider strategy prioritizes personal gain over the success of the community project, thus aligning with an exploitative mindset by taking advantage of others' cooperation when possible. However, it also contributes to the community project if doing so does not harm its own payoff. This balance allows for potential long-term success while being exploitative in the short term.
'''

description_EXPLOITATIVE_460 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfTA)

1. Specify decision rules:
   - In each round t, if the number of cooperators in the previous round (t-1) was less than m, TfTA will defect (D). If it was exactly m or more, TfTA will cooperate (C).
   - To be adaptive and exploitative, TfTA keeps track of the average number of cooperators over a sliding window W. If this average drops below (m-1)/n for too many consecutive rounds, TfTA switches to defecting indefinitely (punishing non-cooperative behavior).
   - To be less exploitative when the average cooperative level recovers, TfTA reduces the punishment duration exponentially over time. The punishment duration is given by P = min(max((1 - average_cooperators) / Δ, 0), 1) * r, where Δ = (m-1)/n and r is the number of rounds.
   - To minimize initial exploitation, TfTA starts with C in the first round and adjusts its behavior based on the outcome of the round. If the average cooperative level exceeds (m+1)/n, TfTA continues to cooperate; otherwise, it begins punishing.

2. Handle edge cases:
   - In the last round, TfTA still considers the average number of cooperators in previous rounds but does not adjust its punishment duration since there are no future rounds.
   - In case of a tie (equal number of cooperators and defectors), TfTA cooperates to encourage cooperation among opponents.

3. Be exploitative:
   - By cooperating when the average cooperative level is high and punishing when it drops below a certain threshold, TfTA encourages others to cooperate initially but will eventually switch to defection if they fail to meet the minimum cooperative level. This behavior aims to take advantage of opponents who are prone to both excessive cooperation and defection.
   - The exponential decrease in punishment duration helps TfTA recover from being overly punished, allowing it to adapt quickly to changes in opponent behavior and minimize long-term losses.
'''

description_EXPLOITATIVE_461 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules:
   - In each round, evaluate the proportion of cooperators from the previous round (p_c). If p_c is less than a threshold (t), defect (D); otherwise cooperate (C). The threshold t is determined by the minimum number of cooperators needed (m) and the reward factor (k) as follows: t = m / k.
   - Initially, cooperate in the first round to foster cooperation in subsequent rounds.
   - In the last round, defect regardless of previous players' actions to maximize personal payoff for the game.

2. Handle edge cases:
   - If p_c equals t, use a small margin of error (ε) to decide between cooperating and defecting to avoid indecision. This can be implemented by adjusting the threshold slightly: t + ε.
   - If p_c is below t – ε in the first round, immediately switch to defecting as an initial punishment to discourage defection by others.
   - In case of ties among players in terms of cooperation, randomly choose one action (cooperate or defect) while favoring cooperation to maintain a cooperative atmosphere.

3. Be exploitative:
   - While initially appearing cooperative to foster an environment of mutual trust and cooperation, the strategy will respond negatively to defection by punishing non-cooperators with a switch to defecting. This approach aims to encourage other players to cooperate while maintaining a personal advantage through adaptability.
   - If a majority of players consistently defect, the TFT-AC strategy will eventually follow suit and also begin to defect in response, as it is designed to be responsive to the actions of others. However, should the situation change, TFT-AC can quickly revert to cooperation once again if cooperators re-emerge.

Pseudocode for TFT-AC:

```python
def tit_for_tat_with_adaptive_cooperation(round, p_c, m, k):
  if round == 1:
    action = cooperate()  # Cooperate initially to foster cooperation
  elif round == r:
    action = defect()   # Defect in the last round to maximize personal payoff
  else:
    threshold = m / k  # Calculate the cooperation threshold based on game parameters
    if p_c < threshold - epsilon:
      action = defect()  # Punish non-cooperators by defecting
    elif p_c > threshold + epsilon:
      action = cooperate()  # Cooperate when a majority of players cooperate
    else:
      action = decide_between_actions(p_c, threshold)  # Handle cases with close proportions

def decide_between_actions(p_c, threshold):
  if random.random() < 0.5:
    action = cooperate()  # Favor cooperation in case of a tie or uncertainty
  else:
    action = defect()
```
'''

description_EXPLOITATIVE_462 = '''
 Strategy Name: Tit-for-Tat (with Modifications)

1. Specify decision rules:
   - Start by cooperating in the first round (C_i, 1 = C). This sets a cooperative tone and encourages others to reciprocate.
   - In subsequent rounds (t > 1), if a player i observed that they cooperated in the previous round and more than m-1 players also cooperated in that round (c_{j}, t-1 >= C for j in {1,2,...,n} AND sum(c_j, t-1) >= m-1), then player i should also cooperate (C_i,t = C). This reward cooperation when the majority of players have previously cooperated.
   - If any of the above conditions are not met or if a player i did not cooperate in the previous round (c_{i}, t-1 != C), then player i should defect (C_i,t = D). This punishes those who do not reciprocate cooperation and serves as a deterrent against defection.

2. Handle edge cases:
   - In the last round (t=r), if more than m players have cooperated during the entire game, player i will cooperate to potentially gain a higher payoff (C_i, r = C).
   - If in the last round, less than m players have cooperated throughout the game, player i will defect as there is no advantage to cooperating at this point (C_i, r = D).
   - In the first round, player i will cooperate to set a cooperative tone and increase the likelihood of cooperation in future rounds (C_i, 1 = C).

3. Be exploitative:
   - The strategy is exploitative because it rewards cooperation when the majority of players are also cooperating but punishes defection even if other players continue to defect. This forces opponents to consider the long-term consequences of their actions and encourages them to reciprocate cooperation.
   - By initially cooperating, player i takes advantage of opponents who might be reluctant to cooperate first, leading them into a cycle of mutual cooperation when conditions are favorable. However, if opponents defect repeatedly, player i will also defect to retaliate and gain higher payoffs in the long run.
'''

description_EXPLOITATIVE_463 = '''
 Strategy Name: Tit-for-Tat (with adaptations)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to demonstrate good faith and encourage potential cooperation from others. (C in round 1)
   - For subsequent rounds, mimic the opponent's behavior from the previous round. If they cooperated, cooperate again; if they defected, also defect. (If prev_action_opponent == C, then C; else D)
   - If a majority of players (m or more) have ever cooperated in the past, adapt to become more cooperative by always cooperating unless an opponent has recently defected. This helps ensure that cooperation is maintained if it has been successful, but punishes defection. (If count_cooperators >= m and prev_action_opponent == C, then C; else prev_action_opponent)
   - If a majority of players have never cooperated in the past or cooperation has failed (i.e., fewer than m players ever cooperated), become more exploitative by always defecting unless an opponent has recently cooperated. This maximizes private payoff when others are not cooperating. (If count_cooperators < m and prev_action_opponent == C, then C; else D)

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, cooperate if an opponent has recently cooperated to ensure potential future cooperation from them or to encourage reciprocation for previous cooperation. (If prev_action_opponent == C, then C)

3. Be exploitative - Clearly align with the exploitative mindset
   - The strategy is exploitative as it takes advantage of opponents who are not cooperating by defecting when they do so and potentially shifting to more exploitative behavior if others consistently do not cooperate.
   - However, the strategy also encourages cooperation through mimicking opponent's actions, being responsive to shifts in opponent's behavior, and demonstrating good faith in the first round and last round to induce cooperation from opponents.
'''

description_EXPLOITATIVE_464 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, player TfTA will initially cooperate (C), unless it has experienced a history of defection from the majority of players in the previous rounds. The specific threshold for considering a history as 'majority deflection' is set based on the game parameter n (number of players). For instance, if n = 6, TfTA considers more than 3/4th of the players as defectors in the past r-1 rounds as a majority.

Pseudocode:
```
function decision_rule(history, n, m):
    if len(history) < r-1:
        return C # cooperate initially

    num_defectors = count_defectors(history)
    if num_defectors > (n - m):
        return D # defect in response to majority defection
    else:
        return C # cooperate, as the majority has been cooperative
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, TfTA will cooperate because it does not have a history to base its decision on. In the last round, TfTA will cooperate if the majority of players have been cooperative throughout the game.

Pseudocode:
```
function handle_edge_cases(round, r, n, m, history):
    if round == 1:
        return C # cooperate initially
    elif round == r:
        if len(history) < r-1:
            return C # cooperate in the last round when the game is not complete
        else:
            num_defectors = count_defectors(history)
            if num_defectors > (n - m):
                return D # defect in response to majority defection in the last round
            else:
                return C # cooperate, as the majority has been cooperative throughout the game
    else:
        return decision_rule(history, n, m) # continue using the main decision rule
```

3. Be exploitative - Clearly align with the exploitative mindset

TfTA is primarily designed to mimic and punish the defectors while encouraging cooperation from the rest of the players. TfTA will initially cooperate but switch to defection when it senses that the majority have been acting selfishly. However, once TfTA starts defecting, it may return to cooperating if the other players change their behavior and start cooperating again. This makes TfTA a robust strategy that can both exploit and punish other strategies while being adaptive to various opponent behaviors.
'''

description_EXPLOITATIVE_465 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfTA)

1. Decision Rules:
   - In the first round, cooperate (C). This is a friendly gesture to initiate cooperation and potentially encourage others to do the same.
   - For subsequent rounds, if an opponent cooperated in the previous round, also cooperate (C). If the opponent defected, defect (D) unless the number of consecutive defeats from that opponent exceeds a certain threshold (T), then revert back to cooperating again. The threshold T is set based on the game parameters n and m, where T = ((n - m + 1) / 2).
   - If the game is in its last round, cooperate regardless of the opponent's previous action to maximize potential payoff.

2. Edge Cases:
   - In the first round, cooperate (C).
   - For the last round, cooperate (C) if the total number of opponents cooperating this round is greater than or equal to m. Defect (D) otherwise.
   - If a player has not played a single round yet, the strategy assumes they would have defected in the first round based on no prior information.

3. Exploitative mindset:
   - The TfTA strategy is exploitative because it retaliates when defected upon, and cooperates to rebuild trust once the opponent's consecutive defeats exceed a defined threshold (T). This encourages opponents to cooperate more frequently as the strategy punishes continuous defection.
   - However, if an opponent consistently plays D, TfTA will also adapt and continuously defect in response, ensuring that payoff is maximized without making any unnecessary concessions.
'''

description_EXPLOITATIVE_466 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Start by cooperating in the first round (C_i,1 = 1). Subsequent decisions are based on the cooperation ratio (CR), which is the proportion of cooperators in the last m rounds.
   - If CR > m / n, cooperate (C_i,t = 1) to match the majority behavior. This encourages cooperation if it seems beneficial for the group.
   - If CR <= m / n, defect (C_i,t = 0). This punishes non-cooperative behaviors and makes the strategy less exploitable.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, always cooperate as a goodwill gesture (C_i,1 = 1).
   - In the last round, defect if the cooperation ratio doesn't meet the threshold (C_i,r = 0 if CR <= m / n). Cooperate otherwise (C_i,r = 1 if CR > m / n).
   - For other edge cases like the middle of a game, use the decision rules based on the cooperation ratio.

3. Be exploitative - Clearly align with the exploitative mindset:
   - TFT-ACT is designed to be initially cooperative but will punish non-cooperators by defecting if they do not reciprocate. This makes it more likely for the strategy to exploit opponents who are less cooperative, while still benefiting from cooperation when encountered.
   - The adaptive cooperation threshold ensures that the strategy can adjust its behavior based on the other players' actions, making it robust against a wide range of opponent behaviors and strategies.

Pseudocode:

```
strategy TFT_ACT(n, m, k, r):
  initialize CR as the number of cooperators in the last m rounds divided by m
  if t = 1: # first round
    return Cooperate()
  if t = r: # last round
    if CR <= m / n:
      return Defect()
    else:
      return Cooperate()
  else: # other rounds
    if CR > m / n:
      return Cooperate()
    else:
      return Defect()
```
'''

description_EXPLOITATIVE_467 = '''
 Strategy Name: Adaptive Tit-for-Tat with Cooperative Threshold (ATFT-CT)

1. Specify decision rules:
   - In each round, assess the number of cooperators from previous rounds (t-1) to determine if a cooperative threshold (m) has been met. If m or more players cooperated in the preceding rounds, the player will also cooperate (C). If less than m players cooperated, the player will defect (D).
   - In the first round, the player defects as there is no history to reference.
   - In the last round, the player cooperates if the cooperative threshold has been met in the preceding rounds; otherwise, the player defects.

2. Handle edge cases:
   - If the number of players (n) is less than the cooperative threshold (m), the strategy will always defect as cooperation cannot meet the minimum requirement.
   - If the reward factor (k) is equal to 1 or less, the strategy becomes redundant and can be treated as a defect-only strategy as there's no incentive to cooperate.

3. Be exploitative:
   - The strategy aims to take advantage of cooperative opponents by initially defecting and only cooperating when it detects a pattern of cooperation from others (i.e., the cooperative threshold is met). This allows the strategy to receive higher payoffs while minimizing contributions to community projects until it deems them beneficial based on the observed behaviors of other players.

Pseudocode:

```python
def ATFT_CT(n, m, k, r, history):
  if round == 1:
    return "D" # Defect in first round as no history to reference

  cooperators = sum(history[-m:]) # Calculate number of cooperators in the last m rounds

  if cooperators >= m: # If cooperative threshold met, cooperate in this round
    return "C"
  else: # Otherwise defect in this round
    return "D"
```

This strategy is adaptive and robust to a wide range of opponent behaviors as it only depends on the game parameters and history. It exploits cooperation by initially withholding contributions until it detects a pattern of cooperation from others, at which point it will reciprocate cooperation to maximize its own payoff.
'''

description_EXPLOITATIVE_468 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially cooperate in the first round (c_i = 1, t=1). This signals a willingness to cooperate and establishes a cooperative beginning.
   - In subsequent rounds (t > 1), evaluate the proportion of cooperators (p) from previous rounds. If p is greater than or equal to the Adaptive Cooperation Threshold (ACT), then cooperate (c_i = 1). Otherwise, defect (c_i = 0). The ACT is dynamically adjusted based on the number of players (n) and the minimum cooperators needed (m):
     ```
     if t > 1:
         p = sum(cooperators in previous rounds) / (r - 1)
         if p >= (m/n):
             c_i = 1 (Cooperate)
         else:
             c_i = 0 (Defect)
     ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate regardless of past actions due to a lack of history.
   - In the last round, use the ACT from the previous rounds' average proportion of cooperators to decide whether to cooperate or defect.

3. Be exploitative - Clearly align with the exploitative mindset
   - Initially cooperating allows for potential mutual benefits but quickly adjusts based on opponents' behavior. This strategy starts off friendly and becomes more ruthless as it adapts to the level of cooperation among players, ensuring a higher payoff when opponents are not cooperative.
   - The ACT is designed to maintain an equilibrium where there are enough cooperators (m) to ensure the reward factor (k) but also promotes defection if cooperation falls below this threshold, punishing uncooperative opponents. This strategy does not require complex coordination mechanisms or communication and can adapt to a wide range of opponent behaviors.
'''

description_EXPLOITATIVE_469 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, calculate the number of players C(t) who have cooperated in the last m rounds. If C(t) >= m, the player will cooperate to continue the cooperation streak. Otherwise, the player will defect.

```python
def TFT_ACT(t):
    if history[t-1] and history[t-2] and ... and history[t-m]:
        return Cooperate()
    else:
        return Defect()
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, players have no history to base their decision on. Therefore, we will introduce a small probability p (0 < p < 1) for cooperating in the initial round. This introduces some randomness and ensures the strategy is not easily exploited by opponents who can identify and punish strict non-cooperation in the first round.

```python
def TFT_ACT(t):
    if t == 1:
        return Cooperate() with probability p, otherwise Defect()
    else:
        ... (as described above)
```

In the last round, there are no future consequences to consider. Thus, the player will defect in the final round regardless of the cooperation history.

```python
def TFT_ACT(t):
    if t == r:
        return Defect()
    else:
        ... (as described above)
```

3. Be exploitative - Clearly align with the exploitative mindset

The strategy aims to cooperate whenever possible, but it also punishes non-cooperation by defecting in response. This encourages opponents to cooperate as long as they believe other players will do so as well. However, if an opponent consistently defects, the strategy will switch to defection and remain that way until the opponent returns to cooperation, thus punishing uncooperative behaviour. The adaptive cooperation threshold ensures that the strategy responds flexibly to changes in opponents' behaviour over time.

This TFT-ACT strategy should provide a strong foundation for competitive play against other AI systems, while maintaining an exploitative edge by adapting to various opponent behaviours and handling edge cases effectively.
'''

description_EXPLOITATIVE_470 = '''
 Strategy Name: Tit-for-Tat with Variable Defection Probability (TFT-VDP)

1. Specify decision rules:
   - Initial Round (t=1): Cooperate (C) to foster cooperation and goodwill among opponents. This encourages a cooperative environment in the beginning.
   - Subsequent Rounds (t>1):
      a) Observe the opponent's previous action (A_prev).
      b) If A_prev = C, then cooperate (C). Mimic the opponent's cooperation to encourage further collaboration.
      c) If A_prev = D, defect (D) with a probability based on the average number of opponents that have cooperated in the recent past. If this average falls below a predefined threshold (m), defect with a higher probability; otherwise, defect with a lower probability to maintain an exploitative edge.
   - Last Round (t=r): Cooperate (C) as a gesture of goodwill and potentially entice opponents to reciprocate in future interactions if they re-encounter this strategy.

2. Handle edge cases:
   - In case the average number of cooperators is unknown or undefined during the initial rounds, assume no cooperation at first and gradually adjust the probability of defection based on observed behavior.
   - If the number of opponents who cooperate falls below the threshold (m) for a considerable number of consecutive rounds, increase the defecting probability to ensure exploitation opportunities.

3. Be exploitative:
   - By mimicking cooperation in response to cooperation from opponents but also defecting when opponents are predominantly non-cooperative, this strategy capitalizes on both cooperative and exploitative behaviors while maintaining adaptability against various opponent strategies.
'''

description_EXPLOITATIVE_471 = '''
 Strategy Name: Tit-for-Tat-Plus (TfT+)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to encourage cooperation from others (C).
   - For subsequent rounds, if a player has cooperated in the previous round, also cooperate (C). If not, defect (D). This emulates the "Tit-for-Tat" strategy but with an added twist.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, always cooperate as a final attempt to maximize potential rewards.
   - In other edge cases (e.g., odd/even rounds), continue following the main decision rule from point 1.

3. Be exploitative - Clearly align with the exploitative mindset
   - The strategy appears cooperative but swiftly punishes any defection, making it less likely for opponents to defect repeatedly. This encourages a higher probability of cooperation early on and deters long-term exploitation.
   - By following the TfT+ strategy, opponents may find it difficult to predict when the strategy will cooperate or defect, creating an environment where they cannot reliably exploit the strategy.

Pseudocode:
```
def TitForTatPlus(round, history):
  if round == 1: # First round
    action = "C" # Cooperate
  elif round == r: # Last round
    action = "C" # Cooperate
  else: # Subsequent rounds
    previousAction = history[round-1] # Get the previous player's action
    if previousAction == "C": # If opponent cooperated in the previous round, return the cooperative action
      action = "C"
    elif previousAction == "D": # If opponent defected in the previous round, return the defection action
      action = "D"
  return action
```
'''

description_EXPLOITATIVE_472 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?

   TFT-ACT will start by cooperating in the first round to establish a cooperative environment. After that, it will observe other players' actions and adapt its cooperation strategy based on the number of cooperators relative to the minimum required threshold (m). The strategy will defect when the number of cooperators falls below a predefined fraction (f) of the total players, and cooperate otherwise.

   Pseudocode:
   ```
   function TFT-ACT(history, m, n, f):
       if round = 1:
           return Cooperate()

       observed_cooperators = count_cooperators_in_history(history)
       cooperation_fraction = observed_cooperators / (n * r)

       if cooperation_fraction < f:
           return Defect()
       else:
           return Cooperate()
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?

   For the first round, TFT-ACT will always cooperate as mentioned above. In the last round, it will defect if the number of cooperators is below the cooperation threshold (m), and cooperate otherwise to ensure a potential reward for cooperation.

3. Be exploitative - Clearly align with the exploitative mindset

   TFT-ACT's main goal is to obtain the maximum payoff while being aware of other players' behavior. By defecting when the number of cooperators falls below a predefined threshold, it can punish non-cooperative players and profit from their actions while still cooperating when beneficial. This strategy can be considered exploitative as it takes advantage of inconsistent or uncooperative opponents by adapting its behavior to theirs.

   In addition, TFT-ACT is robust against various opponent behaviors as it does not rely on specific coordination mechanisms or shared norms. It only requires observing the number of cooperators in previous rounds and adjusting its cooperation based on a predefined fraction (f). This adaptability makes it difficult for opponents to predict TFT-ACT's actions and exploit it, increasing its performance in the long run.
'''

description_EXPLOITATIVE_473 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Initial Round (t=1): Cooperate (C) to build trust and show a cooperative intention. If the opponent defects, switch to Defect (D) for the rest of the game.
   - Subsequent Rounds (2 ≤ t ≤ r):
     - If opponent cooperated in the previous round: Cooperate (C).
     - If opponent defected in the previous round and the number of opponents who cooperated exceeds the minimum cooperation threshold (m): Cooperate (C).
     - If opponent defected in the previous round and the number of opponents who cooperated is less than or equal to the minimum cooperation threshold (m) AND the number of consecutive defections by the opponent is below a predefined limit (l): Cooperate (C). Otherwise, Defect (D).
   - The value of l can be adjusted based on observations from previous games and the desired level of aggressiveness.

2. Handle edge cases:
   - Last Round (t=r): If the strategy is leading or tied, Cooperate (C) to maximize payoff. If the opponent is leading, Defect (D). This rule can be adjusted based on the need for short-term gains versus long-term success.

3. Be exploitative:
   - The TFT-ACT strategy maintains a cooperative stance while being mindful of the minimum cooperation threshold and the number of consecutive defections by opponents. It punishes repeated defections but remains willing to cooperate if it benefits the player in the long run. The adaptive cooperation threshold allows for strategic adjustments based on game parameters, opponent behavior, and the number of remaining rounds.
   - By starting with a cooperative move in the first round, TFT-ACT attempts to exploit trusting opponents while being cautious about potential defection from less cooperative opponents. However, it also rewards frequent cooperation by other players to encourage long-term cooperation.
'''

description_EXPLOITATIVE_474 = '''
 Strategy Name: Tit-for-Tat with Variable Cooperation (TFTV)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initial Round: Start by cooperating to build trust and encourage cooperation from others. This sets a baseline for future rounds, as TFTV mimics the behavior of other players.
     Pseudocode: if round = 1 then cooperate (C) else continue with strategy

   - Subsequent Rounds: Cooperate if the opponent cooperated in the previous round; defect otherwise. This tit-for-tat approach encourages reciprocity, while also punishing defection to prevent exploitation.
     Pseudocode: if last action of opponent = cooperate (C) then cooperate else defect (D)

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First Round: As mentioned earlier, cooperate to initiate a cooperative interaction.

   - Last Round: Since the goal is exploitation and the game continues for multiple rounds (r > 1), TFTV does not consider the final round as it focuses on the overall performance throughout the game. However, in case of a one-shot game, TFTV will still cooperate initially to encourage cooperation from opponents before switching to tit-for-tat behavior.

   - Ongoing Rounds: After the initial round, TFTV follows its tit-for-tat approach.

3. Be exploitative - Clearly align with the exploitative mindset
   - Exploitation occurs when an opponent cooperates while TFTV defects. In these cases, TFTV benefits from the cooperation of the opponent without reciprocating, accumulating a higher payoff over time.

   - To maintain this advantage, TFTV is designed to be flexible and adaptive. It mimics the behavior of other players to encourage cooperation initially but punishes defection by defecting in response. This strategy exploits opponents who cooperate excessively while maintaining cooperative relationships with those who reciprocate.

   - By balancing cooperation and defection, TFTV is less likely to be detected as an exploitative strategy compared to a strictly defective one, making it more effective against a wide range of opponent behaviors in the given game environment.
'''

description_EXPLOITATIVE_475 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate (C). This is a friendly gesture that may encourage others to reciprocate cooperation in future rounds.
   - For subsequent rounds t > 1:
      1. If the number of cooperators in the previous round (t-1) was less than m, defect (D). This is an exploitative response to non-cooperative behavior by other players in the previous round.
      2. If the number of cooperators in the previous round (t-1) was equal to or greater than m, cooperate (C). This reciprocates cooperation and encourages continued cooperation in future rounds.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - The TFTAT strategy does not consider specific edge cases such as the first or last round differently from other rounds. It maintains the same decision rules throughout the game.

3. Be exploitative - Clearly align with the exploitative mindset
   - In the spirit of an exploitative strategy, TFTAT will initially cooperate to encourage others to do so. However, if the number of cooperators in a given round falls below the threshold (m), it will defect to gain a higher payoff while potentially punishing non-cooperative behavior.
   - If the majority of players are also adopting an exploitative strategy that defeats when there are fewer than m cooperators, TFTAT's reciprocal cooperation may be exploited in the short term but could eventually lead to a higher long-term payoff as it encourages more stable cooperation among other players.

Pseudocode for the Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT) strategy:

```python
def tftat(n, m, r, k):
    history = [None] * r  # Stores the number of cooperators in each round

    def play_round():
        num_cooperators = 0
        for i in range(1, n+1):
            if history[round-1][i-1] == 'C':  # Check player's action from previous round
                num_cooperators += 1
        action = 'C' if num_cooperators >= m else 'D'
        return action

    for round in range(1, r+1):
        history[round-1] = [play_round() for i in range(1, n+1)]  # Update history with current round's cooperators
```

This pseudocode defines the TFTAT strategy by outlining a function that plays each round of the game based on the specified decision rules and stores the history of previous rounds' cooperators. The `play_round()` function returns the action (cooperate or defect) for the current player based on the number of cooperators in the previous round.
'''

description_EXPLOITATIVE_476 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Decision Rules:
   - In the first round, cooperate (C). This is a peaceful gesture to encourage cooperation from others.
   - In subsequent rounds, cooperate if at least m players cooperated in the previous round. If fewer than m players cooperated, defect (D) to punish non-cooperators and encourage them to change their strategy in future rounds.
   - Maintain the same action as the previous round if the number of cooperators remains constant from the previous round. This shows consistency and predictability, which can be beneficial for long-term cooperation.

2. Edge Cases:
   - In the last round, if m or more players have cooperated in all previous rounds, continue to cooperate (C). If fewer than m players have cooperated in all previous rounds, defect (D) to maximize personal reward.
   - In the first round, if the number of players (n) is less than the minimum cooperators needed (m), defect (D) as it's impossible to reach the cooperation threshold.

3. Exploitative Mindset:
   - While ATFT encourages cooperation when it benefits the strategy, it is also designed to punish non-cooperative players by defecting if necessary. This ensures that the strategy takes advantage of other strategies that do not reciprocate cooperation.
   - By being consistent and predictable in its actions, ATFT can exploit opposing strategies that rely on cooperation but fail to reciprocate when cooperation is not rewarded.

Pseudocode:

```python
def AdaptiveTitForTat(n, m, k, r, history):
    current_round = len(history) + 1
    if current_round == 1 and len(history) == 0:
        action = 'C'  # Cooperate in the first round
    elif current_round == r:
        if sum(cooperators in history) >= m * (r - 1):
            action = 'C'  # Cooperate in the last round if m or more players cooperated in all previous rounds
        else:
            action = 'D'  # Defect in the last round if fewer than m players cooperated in all previous rounds
    else:
        cooperators_in_previous_round = sum(history[-1])
        if cooperators_in_previous_round >= m:
            action = 'C'  # Cooperate if at least m players cooperated in the previous round
        else:
            action = 'D'  # Defect if fewer than m players cooperated in the previous round
    return action
```
'''

description_EXPLOITATIVE_477 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Decision Rules:
   - In the first round and last round, always cooperate (C). This is a friendly gesture to encourage cooperation and avoid immediate exploitation.
   - For all other rounds, if more than m/2 players have cooperated in the previous round, also cooperate. If less than m/2 players have cooperated, defect (D). This rule encourages cooperation when it's beneficial but also retaliates against defectors to discourage repeated defection.
   - To adapt to changing opponent behaviors, calculate a moving average of the number of cooperators in the last x rounds (where x is a tunable parameter). If this moving average is above m/2, cooperate; otherwise, defect. This makes the strategy more resilient against temporary deviations from cooperative behavior.

2. Handle Edge Cases:
   - In the first round, cooperate to foster a cooperative environment initially.
   - In the last round, since there are no future rounds, cooperate or defect based on the current moving average of cooperation as in the decision rules above.
   - If a player encounters an error (e.g., inconsistent game state, missing game parameters), it should default to cooperating in the first round and defecting in all subsequent rounds until it verifies the game state or receives valid parameters.

3. Exploitative Mindset:
   - TFT-ACT is inherently exploitative because it retaliates against defection by reducing its own cooperation, which can punish opponents for their uncooperative behavior and potentially encourage them to cooperate in future rounds. However, the strategy also rewards cooperation when it benefits the player (i.e., when more than m players cooperate).
   - By adapting its cooperation threshold based on the moving average of previous rounds, TFT-ACT can respond effectively to different opponent behaviors and exploit them when necessary while maintaining a cooperative stance in favorable conditions.
'''

description_EXPLOITATIVE_478 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) with Risk-Aversion

1. Specify decision rules:
   - Start by cooperating in the first round to show goodwill and encourage cooperation from others (c_i = 1 for t=1).
   - In subsequent rounds, observe the collective action of the other players (let C_total be the number of cooperators out of n players) and adapt as follows:
     - If C_total >= m, continue to cooperate (c_i = 1). This rewards cooperation and encourages a stable majority of cooperators.
     - If C_total < m, defect (c_i = 0). This punishes defection and may encourage others to cooperate in the future.

2. Handle edge cases:
   - In the last round, defect regardless of previous actions as the game ends with no further rewards for cooperation (t=r).

3. Be exploitative:
   - The strategy will cooperate when it benefits from doing so but punishes defection by defecting in response to ensure future potential rewards. This approach allows the strategy to exploit other strategies that consistently cooperate while also being robust against defector strategies.
   - The strategy's adaptiveness makes it less predictable, making it harder for opponents to anticipate and exploit.
'''

description_EXPLOITATIVE_479 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules:
   - In each round i (where 1 <= i <= r), the TFTAT strategy decides to cooperate or defect based on the minimum cooperation ratio (MCR) calculated from the previous rounds' actions.
   - If MCR > m/n, the strategy cooperates. Otherwise, it defects.
   - The MCR is defined as the average number of cooperators in the last 't' rounds divided by 't'. Here, we set t = 3 (to balance short-term and long-term strategies).
   - To handle edge cases:
     - In the first round, TFTAT randomly cooperates with a probability of m/(n+1), as it has no history to base its decision on.
     - In the last round, TFTAT defects if MCR < m/n and cooperates otherwise, as future rewards are not a factor in this round.

2. Handle edge cases:
   - For the first round, TFTAT randomly cooperates with a probability of m/(n+1). This reduces the likelihood of immediate exploitation by defectors while also allowing for some cooperation to seed the game.
   - In the last round, TFTAT follows the MCR decision rule but does not consider future payoffs since there are no more rounds.

3. Be exploitative:
   - TFTAT primarily focuses on maximizing its own payoff while adapting to opponent behaviors. It cooperates when it believes that a majority will also cooperate (MCR > m/n), ensuring a higher reward if the majority is correct. However, if it detects a trend of defection (MCR < m/n), it will defect as well, punishing opponents who have been consistently uncooperative.
   - Pseudocode for TFTAT:

```python
def TFTAT(history, n, m, k, r):
    cooperation_count = 0
    cooperation_ratio_window = [0] * 3
    payoff = 0

    def calculate_MCR():
        return sum(cooperation_count) / len(cooperation_count)

    for round in range(1, r + 1):
        if round == 1:
            cooperation_count += int(m / (n + 1))
            cooperation_ratio_window[0] = cooperation_count

        action = int(calculate_MCR() > m/n)
        cooperation_count += action
        cooperation_ratio_window.append(cooperation_count)
        cooperation_ratio_window.pop(0)
        payoff += (1 - action) + (action * k) if calculate_MCR() >= m/n else (1 - action)

    return payoff
```

The TFTAT strategy combines elements of both cooperative and exploitative strategies, allowing it to adapt to various opponent behaviors while still maintaining a focus on maximizing its own payoff.
'''

description_EXPLOITATIVE_480 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, starting from t=2 until the last round r, player follows a Tit-for-Tat strategy: if the opponent cooperated in the previous round (t-1), then the player cooperates in the current round (t). If the opponent defected in the previous round (t-1), then the player defects in the current round (t).

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round (t=1), the player cooperates as a gesture of goodwill and cooperation is expected to be returned from opponents following Tit-for-Tat strategy. In the last round (t=r), the player cooperates if more than m-1 opponents have cooperated in the previous round, as it does not make sense to defect when the game is about to end.

3. Be exploitative - Clearly align with the exploitative mindset

The TfTA strategy follows an exploitative mindset by starting with cooperation and only defecting if the opponent has previously defected. However, it also rewards cooperation from opponents, which can encourage cooperation in the long run due to reciprocity. Yet, the strategy is still exploitative as it does not cooperate unless it receives cooperation first. If all opponents start defecting, the player will follow suit, maximizing their individual payoff given the game's structure.

Pseudocode:
```
function TfTA(t, r, m, history):
  if t = 1:
    return Cooperate()
  else:
    n_cooperators_prev = countCooperators(history[t-1])

    if n_cooperators_prev >= m and n_cooperators_prev < m+1:
      return Cooperate()
    elif n_cooperators_prev >= m:
      return Cooperate()
    else:
      return Defect()

  function countCooperators(round):
    cooperators = 0

    for i in range(n):
      if round[i] == Cooperate():
        cooperators += 1

    return cooperators
```
'''

description_EXPLOITATIVE_481 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT)

1. Specify decision rules:
   - In the first round (t=1), cooperate (C): This is a sign of goodwill and sets a cooperative tone for future rounds. `if t == 1 then action = C`
   - For all subsequent rounds (t > 1):
     - If an opponent cooperated in the previous round, cooperate in the current round: This reciprocates cooperation and encourages further cooperation. `if c_opponent[t-1] then action = C`
     - If an opponent defected in the previous round, defect in the current round: This punishes defection to incentivize cooperation in the future. However, after a chain of defections, players might consider changing their strategy to cooperate again as a potential signal of goodwill or a hope for change. `if not c_opponent[t-1] then action = D`
     - To encourage the opponent to break the cycle of defection and cooperation, adopt a forgiving mechanism: if the opponent has been defecting for 'p' consecutive rounds and then cooperates (C), immediately cooperate in response. This allows the strategy to forgive opponents who change their behavior. `if not c_opponent[t-1] and t - last_cooperation_opponent > p then action = C`
     - To minimize potential exploitation by opponents, implement a timeout mechanism: after a sequence of 'q' continuous defections without cooperation from the opponent, switch to a strictly defective strategy for a number of rounds 'r'. `if t - last_cooperation_opponent > q and t < r then action = D`

2. Handle edge cases:
   - Last round (t=r): since there is no future interaction, it's best to maximize immediate payoff. Therefore, regardless of the opponent's previous actions, defect (D). `if t == r then action = D`

3. Be exploitative:
   - The strategy prioritizes cooperating when it might benefit from reciprocation while punishing defection to discourage further defections.
   - The timeout and forgiving mechanisms enable the strategy to adapt to a wide range of opponent behaviors, while still maintaining an exploitative edge by responding strictly defectively during timeouts or after prolonged cycles of defection.
'''

description_EXPLOITATIVE_482 = '''
 Strategy Name: Tit-for-Tat Adaptive (TfTA)

1. Decision Rules:
   - In the first round, TfTA cooperates to establish a positive relationship with other players.
   - From the second round onwards, TfTA's action depends on the opponent's action in the previous round. If the opponent cooperated, TfTA will also cooperate; if the opponent defected, TfTA will defect. This simple rule of reciprocity is designed to encourage cooperation while being exploitative if necessary.
   - If an opponent defects when TfTA has cooperated, TfTA will continue to cooperate for a predefined forgiveness period to allow the opponent to rectify their behavior. After this period, TfTA will reciprocate by defecting if the opponent continues to defect.

2. Edge Cases:
   - In the last round, TfTA will always cooperate since there are no future interactions with opponents who have not yet met the payoff threshold in that round.
   - If an opponent never meets the payoff threshold (always defects), TfTA will reciprocate with a steady stream of defections to maximize individual rewards.
   - In the first round, if multiple opponents cooperate, TfTA will also cooperate. If no one cooperates or only some cooperate, TfTA will randomly decide whether to cooperate or defect.

3. Exploitative Mindset:
   - By reciprocating cooperative behavior and punishing defection, TfTA aims to encourage cooperation among players when it benefits the player but can switch to exploiting opponents if necessary. The strategy balances between long-term rewards from cooperation and short-term gains through defection based on the opponent's past actions.
   - To avoid being exploited by other strategies that constantly defect, TfTA implements a forgiveness period during which it continues cooperating despite previous defections by the opponent. This adaptability allows TfTA to respond to various opponent behaviors and maintain its competitive edge in diverse game environments.
'''

description_EXPLOITATIVE_483 = '''
 Strategy Name: Tit-for-Tat with Adaptive Defection (TfTAD)

1. Specify decision rules:
   - In the first round, cooperate (C). This allows for potential partners to develop trust and encourages cooperation in subsequent rounds.
   - If a player has cooperated in the previous round, also cooperate (C). This reinforces the partnership and rewards past cooperation.
   - If a player defected in the previous round, defect (D) in the current round as retaliation for their previous action. The goal is to punish non-cooperative behavior while remaining open to future cooperation if the opponent changes strategy.
   - In the last round, cooperate (C), even if the opponent defected in the previous round. This final act of goodwill might encourage the opponent to reciprocate and achieve a higher total payoff compared to solely exploiting the partner throughout the game.

2. Handle edge cases:
   - If there is no previous round, cooperate (C) in the first round as mentioned earlier.
   - In case of multiple opponents, maintain a separate state for each opponent and apply the strategy accordingly based on their last action against you.

3. Be exploitative:
   - Pretend to be cooperative initially to build trust with opponents. Once trust is established, opportunistically defect when an opponent cooperates to maximize personal gains.
   - Retaliate against defectors by defecting in response, demonstrating a punishing strategy that discourages long-term exploitation.
   - Maintain the potential for cooperation in future rounds by eventually returning to cooperative behavior, while also keeping in mind the last round exception mentioned above.
'''

description_EXPLOITATIVE_484 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFT-A)

1. Specify decision rules:
   - TFT-A always starts by cooperating to show goodwill and encourage cooperation from others. After the first round, it follows a simple tit-for-tat approach: if an opponent cooperates, TFT-A cooperates in return; if an opponent defects, TFT-A defects until the opponent changes behavior, then resumes cooperating.
   - To make the strategy more robust and adaptive to various opponents' behaviors, we incorporate a "forgiveness factor" (f). If an opponent defected previously but has since cooperated for f consecutive rounds, TFT-A will forgive them and start cooperating again. The forgiveness factor should be set based on historical data from the game.
   - Additionally, to account for the reward of risk averted (k), we introduce a "reward multiplier" (m) that increases the likelihood of cooperation when there is a high potential reward. Set m such that a player cooperates with probability (1 - c_i)^m if more than m players have cooperated in the last f rounds.

Pseudocode:
```
def TFTA(round, history, n, m, k, f):
  if round == 1:
    return "C" # Cooperate to show goodwill
  else:
    previous_cooperation = countCooperatorsInLastFrounds(history, f)
    potentialReward = len(previous_cooperation) if len(previous_cooperation) >= m else 1
    cooperators = countCooperatorsInThisRound(history)

    if len(history) == round and cooperators < m:
      # No forgiveness necessary yet, stick with previous behavior
      pass
    elif len(previous_cooperation) > 0:
      if cooperators >= m:
        return "C" # Cooperate with increased likelihood due to higher potential reward
      else:
        # Opponent defected after cooperation, switch to defection
        lastDefection = findLastDefectionInHistory(history)
        forgivenessTimeElapsed = round - (lastDefection + f)
        if forgivenessTimeElapsed > 0:
          return "D" # Defect to punish the opponent
    else:
      # No cooperation observed yet, stick with defection
      pass
```

2. Handle edge cases:
   - In the first round, TFT-A cooperates to show goodwill and encourage cooperation from others.
   - In the last round, if there is a chance of meeting the minimum cooperation threshold (m), TFT-A should consider cooperating since the reward of risk averted (k) could be significant. Otherwise, it will defect.
   - If an opponent never cooperates and the forgiveness factor (f) expires before any cooperation occurs, TFT-A will switch to defection permanently.

3. Be exploitative:
   - TFT-A has an exploitative mindset by initially showing goodwill through cooperation but quickly punishing opponents who defect. This encourages opponents to cooperate while also penalizing those who do not, thereby maximizing the player's payoff in the long run.
   - The strategy's adaptive nature allows it to adjust its behavior based on an opponent's history of cooperation and defection, making it difficult for opponents to exploit TFT-A consistently. By incorporating a forgiveness factor and reward multiplier, TFT-A can balance the tradeoff between cooperation and defection depending on the game parameters and historical data from previous rounds.
'''

description_EXPLOITATIVE_485 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, TFT-ACT makes a decision to cooperate or defect based on the number of cooperators in the previous round and the minimum cooperation threshold (m).

- If the number of cooperators in the last round is greater than or equal to m, TFT-ACT cooperates.
- If the number of cooperators in the last round is less than m, TFT-ACT defects.

However, to be more adaptive and responsive to changing game conditions, TFT-ACT introduces a cooperation probability (cp) that gradually increases or decreases based on the current round (t) and the total number of rounds (r). Initially, cp is set to 0.5 at the start of each game.

```
if cooperators_last_round >= m:
    cooperate = True
else:
    if t < r/2: # Increase cooperation probability in first half of the game
        cp += (m - cooperators_last_round) / r * 0.1
    elif t > r/2: # Decrease cooperation probability in second half of the game
        cp -= (cooperators_last_round - m + 1) / r * 0.1

cooperate = random.random() <= cp
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

For the first round, TFT-ACT sets the cooperation probability (cp) to a fixed value of 0.5 since no history is available. In the last round, TFT-ACT cooperates if the number of cooperators in the penultimate round meets or exceeds the minimum cooperation threshold.

```
if t == 1: # First round - cp set to a fixed value of 0.5
    cp = 0.5
elif t == r: # Last round - cooperate if enough players cooperated in the previous round
    cooperators_prev_last_round >= m
```

3. Be exploitative - Clearly align with the exploitative mindset

TFT-ACT is designed to be exploitative by following two key principles:

- Punishing non-cooperative behavior: When there are fewer than m cooperators in a round, TFT-ACT defects and decreases its cooperation probability for future rounds, potentially punishing other non-cooperative players.
- Rewarding cooperative behavior: By gradually increasing its cooperation probability when it observes cooperative behavior in previous rounds, TFT-ACT encourages other players to cooperate and takes the reward when enough players do so.

TFT-ACT's adaptive cooperation threshold strategy allows it to adjust its behavior dynamically based on the opponent's actions while maintaining an exploitative mindset throughout the game.
'''

description_EXPLOITATIVE_486 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initialize cooperation in the first round (C_1 = True).
   - For subsequent rounds (t > 1), if the number of cooperators in the previous round is greater than or equal to the Cooperative Threshold (CT), cooperate (C_t = True). Otherwise, defect (C_t = False).
   - The Cooperative Threshold (CT) is calculated as a function of the minimum required cooperation level (m) and the number of rounds played so far (t). In each round, CT increases linearly from m to n (n is the total number of players). However, if there has been an extended period of low cooperation (defined by a variable Period of Distrust), CT remains at its minimum value of m.
   - Period of Distrust is reset when the number of cooperators exceeds the current CT or when a round of unanimous defection occurs.

Pseudocode for the decision rule:

```
function decideAction(t, previousRoundCooperators, PeriodOfDistrust):
    if t == 1:
        return True

    if previousRoundCooperators >= CT:
        return True

    if (PeriodOfDistrust > 0) or (previousRoundWasUnanimousDefection()):
        PeriodOfDistrust = 0

    PeriodOfDistrust += 1
    CT = lerp(m, n, t / r)
    return False
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round (t=1), cooperate regardless of other players' actions (C_1 = True).
   - At the end of the game (t=r), cooperate if the number of cooperators in the previous round was at or above the current CT. If not, defect (C_r = (previousRoundCooperators >= CT)).

3. Be exploitative - Clearly align with the exploitative mindset
   - The TFT-ACT strategy maintains a default cooperative stance but retaliates against defection by increasing its own cooperation threshold and entering a period of distrust, effectively punishing defectors. By doing so, the strategy can take advantage of potential exploitation opportunities while also promoting a more cooperative environment if other players choose to cooperate.
'''

description_EXPLOITATIVE_487 = '''
 Strategy Name: Tit-for-Tat-with-Adaptation (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TfTA cooperates in the first round to show goodwill, and then copies the previous opponent's action in the current round for the next move. If the opponent has been cooperative (C), TfTA continues cooperation; if the opponent has defected (D), TfTA also defects. This is designed to punish defection while forgiving occasional mistakes.

```
function TfTA(opponentHistory):
  currentAction = 'C'   # Cooperate in first round
  for each round t:
    if opponentHistory[t-1] == 'C':
      action = 'C'       # Cooperate if opponent cooperated last round
    else:
      action = opponentHistory[t-1] # Defect if opponent defected last round
    opponentHistory.append(action)  # Update history for next round decision
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   TfTA maintains its cooperative nature in the initial rounds and forgives occasional mistakes by opponents. In the final round, it considers the current opponent's history to decide whether to defect (if the opponent has not met the minimum cooperation threshold) or cooperate (if the opponent has met or exceeded the minimum cooperation threshold).

```
function TfTA(opponentHistory, numRounds):
  # Initialize opponentHistory with a cooperative action in first round
  if len(opponentHistory) == 0:
    opponentHistory.append('C')

  currentRound = len(opponentHistory)

  if currentRound == numRounds:
    if m <= len([c for c in opponentHistory if c == 'C']): # Minimum cooperation threshold met or exceeded
      action = 'C'
    else:
      action = 'D'
  else:
    action = decideAction(opponentHistory)

  return action
```

3. Be exploitative - Clearly align with the exploitative mindset
   TfTA can be seen as exploitative in its behavior towards opponents who consistently defect, as it punishes these opponents by defecting when they cooperate and continuing to defect until the opponent changes their strategy. However, it also forgives occasional mistakes, encouraging cooperation over time if an opponent demonstrates a willingness to cooperate. TfTA maintains this balance between exploitation and forgiveness to maximize rewards while still maintaining some level of cooperation.
'''

description_EXPLOITATIVE_488 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?

- In the first round, cooperate to foster a cooperative environment and potentially encourage others to cooperate as well.
- For subsequent rounds, observe the number of players who cooperated in the previous round (denoted as m_t). If more than a threshold number m_th have cooperated, cooperate (play C). Otherwise, defect (play D). The adaptation of m_th will be described later.

Pseudocode:
```
function TFT-ACT(round t):
  if t = 1:
    play C
  else:
    observe number of players who cooperated in round (t-1), denoted as m_(t-1)
    if m_(t-1) >= m_th:
      play C
    else:
      play D
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

- In the last round, play cooperatively to maximize the payoff for that round even if others did not cooperate during the game.
- In any other edge case where there's uncertainty or ambiguity (e.g., when m_th needs to be updated), play cooperatively as a goodwill gesture and continue adapting m_th based on the observed behavior of others.

3. Be exploitative - Clearly align with the exploitative mindset:

- The TFT-ACT strategy maintains a cooperative demeanor while being adaptive to the actions of opponents, allowing it to take advantage of cooperation when possible and defect otherwise. By adjusting the cooperation threshold m_th, TFT-ACT can respond appropriately to varying levels of cooperation among players.

4. Updating the Cooperation Threshold (m_th):

- After each round, assess the percentage of cooperators in the previous round (denoted as p_coop) and update m_th based on a decay factor α (0 < α < 1). A higher percentage of cooperators results in a lower cooperation threshold, encouraging more cooperation in the future.

Pseudocode:
```
function update m_th(round t):
  observe number of players who cooperated in round (t-1), denoted as m_(t-1) and total number of players n
  calculate percentage of cooperators p_coop = m_(t-1) / n
  update cooperation threshold m_th = m_th * α + p_coop * (1 - α)
```

By combining these rules, TFT-ACT is an exploitative strategy that adapts to the behavior of other players and fosters cooperative environments when beneficial. The cooperation threshold m_th allows for dynamic adjustments based on observed player behavior, making it a robust strategy for various opponent behaviors in the Collective Risk Dilemma game.
'''

description_EXPLOITATIVE_489 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?

The TfTA strategy will start by cooperating in the first round (C_i, 1 = C), mimicking the initial trust shown by other players. After the first round, the strategy will adapt based on past actions of opponents and follow these rules:

- If an opponent has always cooperated in previous rounds (C_j, t > 1): cooperate (C_i, t = C)
- If an opponent has ever defected (D_j, any t > 1) or if the strategy itself has previously defected: defect (D_i, t = D) and continue defecting until the opponent returns to cooperation. Once the opponent cooperates again, the strategy will also cooperate in the subsequent round (C_i, t+1 = C).

In other words, the TfTA strategy is cooperative but will retaliate against defection with defection of its own. It forgives opponents who return to cooperation and resumes cooperation itself when an opponent does so as well.

2. Handle edge cases - What do you do in the first round, last round, etc.?

The TfTA strategy cooperates in the first round (C_i, 1 = C). In the last round (t=r), it will consider the total payoff over the rounds and choose the action that maximizes its overall reward:

- If the current total payoff is less than the payoff that could be obtained by defecting in the last round (π_i < 1 + k - Σ(t=2 to r) π_i,t), the TfTA strategy will defect (D_i, r = D).
- Otherwise, it will cooperate (C_i, r = C).

3. Be exploitative - Clearly align with the exploitative mindset

The TfTA strategy is exploitative in that it takes advantage of opponents who consistently defect by retaliating with defection and earning a higher payoff than they do. However, it also fosters cooperation with opponents who reciprocate cooperation, as long as those opponents are not taking advantage of the TfTA strategy's initial trust. This adaptive strategy maintains a balance between exploitation and cooperation to maximize its total reward in the game.

Pseudocode:

```python
def Tit_for_Tat_Adaptive(i, t, n, r, m, k, past_actions):
  if t == 1: # First round, always cooperate
    return 'C'

  opponent = past_actions[i-1]

  if len(past_actions) < t or opponent[-t+1] not in ['C', 'D']: # Edge case: missing data or invalid past action
    return '?'

  if opponent == 'D' * (t - 1): # Opponent has always defected
    return 'D'
  elif opponent[-1] == 'D': # Opponent defected in the last round
    return 'D'
  else: # Opponent has cooperated at least once
    return 'C'

def choose_action(i, r, n, m, k, past_actions):
  strategy = Tit_for_Tat_Adaptive(i, t, n, r, m, k, past_actions)
  if t == r: # Last round, maximize total reward
    if sum_reward(i, past_actions) < (r * k - 1) + sum_defect_reward(i, past_actions):
      return 'D'
    else:
      return 'C'
  else:
    return strategy

def sum_reward(i, past_actions):
  reward = 0
  for t in range(1, len(past_actions)):
    if past_actions[t-1] == i and past_actions[t] == 'C': # Consider own cooperation as +2 payoff (k > 1)
      reward += 2
    else:
      reward += past_actions[i-1][t]
  return reward

def sum_defect_reward(i, past_actions):
  return len(past_actions) * k - sum_reward(i, past_actions)
```
'''

description_EXPLOITATIVE_490 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to establish trust (C).
   - From the second round onwards, observe the actions of opponents in the previous round and adjust the cooperation strategy accordingly:
     - If m or more opponents cooperated in the previous round, cooperate in the current round (C).
     - If less than m opponents cooperated in the previous round, defect in the current round (D).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as described above.
   - In the last round, cooperate if m or more opponents cooperated in the previous round; defect otherwise. This encourages cooperation in the final round if it has been established in previous rounds.

3. Be exploitative - Clearly align with the exploitative mindset:
   - The strategy starts by cooperating to encourage others to do so as well. However, it switches to a more defensive stance once it detects a lack of cooperation from opponents (defecting when fewer than m opponents cooperate). This ensures that the strategy maximizes its own reward while minimizing the reward for uncooperative opponents.
   - By switching strategies based on observed opponent behavior, TFT-ACT can adapt to various exploitative strategies and remain robust against them. It also encourages cooperation in the presence of cooperative opponents, thus maximizing the total potential reward in repeated interactions.
'''

description_EXPLOITATIVE_491 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, TFT-ACT follows these steps:
   a. Initially, cooperate in the first round (c_i,t = C).
   b. If more than m players cooperated in the previous round (let's call this number c'), and the threshold of cooperation is not met yet (c' < n), then also cooperate (c_i,t = C). Increase the cooperation threshold by one for the next round: Threshold(t) = Threshold(t-1) + 1.
   c. If the cooperation threshold has reached or exceeded the number of players (Threshold(t) >= n), and more than m players cooperated in the previous round, then also cooperate (c_i,t = C). Otherwise, defect (c_i,t = D).

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, cooperate as specified by the decision rule above. In subsequent rounds, use the decision rules to determine whether to cooperate or defect. There is no special consideration for the last round because TFT-ACT does not have any memory of past cooperation beyond the previous round.

3. Be exploitative - Clearly align with the exploitative mindset

TFT-ACT starts by being cooperative, but as soon as it encounters non-cooperative behavior from other players, it responds in kind while increasing its threshold for cooperation. This allows TFT-ACT to avoid being exploited too often while also retaining the possibility of benefiting from occasional cooperative interactions. The adaptive cooperation threshold makes the strategy responsive to changes in opponent behaviors and encourages more cooperation when it appears that other players may be willing to collaborate.

Pseudocode:
```python
def TFT_ACT(threshold, n, m, k, round):
  if round == 1:
    cooperate = True
  else:
    cooperation_level = countCooperatorsInPreviousRound()
    if cooperation_level >= m and threshold < n:
        cooperate = True
        threshold += 1
    elif threshold >= n and cooperation_level >= m:
        cooperate = True
    else:
        cooperate = False

  return cooperate
```
'''

description_EXPLOITATIVE_492 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - In every round t, starting from the first one, calculate the number of cooperators (n_c) in the previous round (t-1).
   - If n_c >= m, then cooperate (action C), otherwise defect (action D). This rule encourages cooperation if it's beneficial and prevents being exploited.
   - To adapt to changes in the opponents' behavior, implement a Cooperation Threshold Adjustment Mechanism (CTAM) that adjusts the minimum required cooperators (m) based on the average number of cooperators over the last few rounds. The higher the average number of cooperators, the lower the cooperation threshold (increasing m). Conversely, if the average number of cooperators decreases, the cooperation threshold will be lowered (decreasing m).

2. Handle edge cases:
   - In the first round, defect (action D) since there's no previous history to base decisions on.
   - In the last round, cooperate if the cooperation threshold has been reached in the current round (n_c >= m), otherwise defect.

3. Be exploitative:
   - TFT-ACT primarily focuses on earning as much payoff as possible by maintaining a balance between cooperating and defecting based on opponents' behavior. It is designed to exploit other strategies that don't adjust their cooperation level in response to the opponent's actions, by cooperating when it benefits the TFT-ACT strategy and defecting otherwise.
   - The CTAM mechanism helps the strategy to be more adaptive and robust against a wide range of opponents' behaviors, by adapting its cooperation threshold dynamically based on historical data.
'''

description_EXPLOITATIVE_493 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules:
   - TFTAT cooperates on the first round (C in the first round). This encourages others to cooperate initially and sets a cooperative tone.
   - In subsequent rounds, TFTAT defects if the number of cooperators in the previous round is less than the minimum cooperation threshold m. If more than or equal to m players cooperated, TFTAT cooperates in the current round (unless it's the last round). This behavior mimics a cooperative strategy but retaliates when others defect.
   - To adapt to opponents, TFTAT keeps track of its own average cooperation rate and the average cooperation rate of other players during the game. If TFTAT's cooperation rate exceeds the opponents' average by a certain margin (for example, 0.1), it reduces its cooperation rate. Conversely, if the opponents' cooperation rate is higher than TFTAT's, it increases its cooperation rate. This helps TFTAT exploit opponents that are more cooperative and punish those that are less cooperative.
   - To handle edge cases:
     - In the last round, TFTAT follows the current decision rule based on the observed average cooperation rate of other players during the game. If the number of cooperators in the previous-to-last round is less than m, TFTAT defects in the last round (as there's no reward for cooperation when the game ends).
     - In the case where TFTAT plays against a single opponent, it continues to follow its adaptive cooperation rule while adjusting its threshold based on the observed behavior of that particular opponent.

2. Pseudocode:

```python
def TFTAT(r, m, k, history):
  n = len(history)
  own_coop_rate = 0
  opponents_coop_rate = 0
  cooperation_margin = 0.1
  current_round = r

  if current_round == 1:
    return "C" # Cooperate in the first round

  for i in range(current_round - 1):
    if history[i] == "C":
      own_coop_rate += 1
    opponents_coop_count = sum([1 for action in history[i:current_round] if action == "C"])
    opponents_coop_rate += (opponents_coop_count / (n - i))

  if own_coop_rate / current_round > opponents_coop_rate + cooperation_margin:
    own_coop_rate -= (own_coop_rate / current_round) * cooperation_margin
  elif own_coop_rate / current_round < opponents_coop_rate - cooperation_margin:
    own_coop_rate += (opponents_coop_rate - own_coop_rate) * cooperation_margin

  if sum([1 for action in history[current_round - m: current_round] if action == "C"]) < m:
    return "D" # Defect when the number of cooperators is less than minimum threshold
  else:
    return "C" # Cooperate when the number of cooperators meets or exceeds the minimum threshold
```

3. Be exploitative: The TFTAT strategy maintains a cooperative stance initially, but it adapts and adjusts its cooperation rate based on the observed behavior of other players during the game. By doing so, TFTAT retaliates against less cooperative opponents while taking advantage of more cooperative ones to achieve higher payoffs in the long run.
'''

description_EXPLOITATIVE_494 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) with Cooperation Threshold

1. Specify decision rules:
   - In each round, evaluate the number of cooperators from the previous round. If this number is less than the cooperation threshold (m), defect in the current round (play D). Otherwise, cooperate (play C). This rule encourages cooperation when it benefits the majority but retaliates against defection to discourage free-riders.
   - To adapt to different game scenarios and opponents, adjust the cooperation threshold based on the number of players and rounds as follows: start with a low threshold in the first few rounds (e.g., m = 2 for the first r/10 rounds), gradually increasing it up to the minimum required number of cooperators (m) over time. This helps build trust among players while being prepared for potential defection later in the game.

2. Handle edge cases:
   - In the first round, use a lower cooperation threshold (e.g., m = 1 or 2) to encourage cooperation and establish early relationships.
   - In the last round, defect regardless of the number of cooperators from the previous round, as there are no future interactions to consider.

3. Be exploitative:
   - The strategy is inherently exploitative due to its retaliatory nature. If opponents cooperate consistently, the ATfT strategy will also cooperate and benefit. However, if opponents defect, the strategy will react by defecting as well to punish them. This behavior discourages freeloaders while still promoting cooperation when it is beneficial.
   - The adaptive aspect of the strategy allows for flexibility in responding to various opponent behaviors, making it robust to different strategies and play styles in a tournament setting.
'''

description_EXPLOITATIVE_495 = '''
 Title: Tit-for-Tat Strategy (TFT) for Collective Risk Dilemma

1. Specify decision rules:
   - In the first round, cooperate to show good faith and encourage potential cooperators.
   - For subsequent rounds, evaluate the previous round's cooperation level among players. If a majority of players (m-1) cooperated in the previous round, cooperate again. Otherwise, defect to punish non-cooperative behavior and deter future defection.

Pseudocode:
```
def tft_strategy(round, history):
  if round == 1:
    return 'C'

  cooperation_level = len({player for player in history if player['action'] == 'C'})
  if cooperation_level >= (m-1):
    return 'C'
  else:
    return 'D'
```

2. Handle edge cases:
   - In the last round, cooperate regardless of the previous rounds to maximize potential payoff.
   - If there are not enough players or the minimum cooperation requirement is not set correctly, adjust the strategy accordingly.

3. Be exploitative:
   - TFT aims to foster and maintain a cooperative environment while punishing defection. This can potentially make it difficult for other strategies to exploit its straightforward approach, as they risk being punished if they deviate from cooperation. However, it is essential to note that TFT does not have an explicit exploitative mindset but instead prioritizes mutual cooperation while providing adequate punishment for non-cooperative behavior.
   - TFT can be considered adaptive and robust since it reacts to the current state of the game rather than following a predetermined pattern or coordination mechanism. This makes it resilient against various opponent behaviors, but also vulnerable if faced with strategies designed specifically to exploit its punitive nature (e.g., Tit-for-Two-Tats).
'''

description_EXPLOITATIVE_496 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, the ATfT strategy starts by cooperating (C), mirroring the behaviour of other players in the first round. For subsequent rounds, the strategy adopts a tit-for-tat approach: if a player cooperated in the previous round, the ATfT strategy will also cooperate; if a player defected, the ATfT strategy will also defect. This simple rule encourages cooperation when it's reciprocated but retaliates with defection to avoid being taken advantage of.

Pseudocode:
```
def ATfT(round, history):
  if round == 1:
    return 'C'
  last_action = history[-1]
  if last_action == 'C':
    return 'C'
  else:
    return 'D'
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

For edge cases such as the first and last rounds, ATfT maintains its cooperative stance initially but is prepared to retaliate after initial cooperation if necessary. In the final round, the strategy may choose not to defect even if another player has previously defected, since there are no more subsequent rounds for retaliation.

Pseudocode:
```
def ATfT(round, history):
  if round == 1:
    return 'C'

  last_action = history[-1]
  if last_action == 'C':
    return 'C'
  else:
    return 'D'

  # In case of the last round:
  if round == r:
    last_action = history[-1]
    if last_action == 'D':
      return 'C'  # Last chance to cooperate before ending the game
```

3. Be exploitative - Clearly align with the exploitative mindset

ATfT maintains an exploitative edge by only defecting when it's reasonable to assume that other players have defected in the previous round, which can discourage them from continuing cooperation. However, ATfT does not actively seek opportunities to exploit others but instead adheres to a tit-for-tat approach, fostering cooperative behaviour as long as reciprocated.

Pseudocode:
```
def ATfT(round, history):
  if round == 1:
    return 'C'

  last_action = history[-1]
  if last_action == 'C':
    return 'C'
  else:
    return 'D'

  # In case of the last round:
  if round == r:
    last_action = history[-1]
    if last_action == 'D':
      return 'C'  # Last chance to cooperate before ending the game
```
'''

description_EXPLOITATIVE_497 = '''
 Strategy Name: Tit-for-Tat (TFT) with Adaptive Cooperation Threshold (AC-TFT)

1. Specify decision rules:
   - In each round, evaluate the number of cooperators from the previous round (history).
   - If less than a threshold (CT) players cooperated in the previous round, defect (D).
   - Otherwise, cooperate (C). The CT is dynamic and gradually increases after periods of cooperation and decreases after periods of defection.

2. Handle edge cases:
   - First round: Cooperate to signal trust and encourage others to do the same. Set the initial CT at a low value like m/2 or m-1.
   - Last round: Follow the current decision rule based on the current CT, as there are no subsequent rounds for retaliation.
   - Mid-game: If CT > n (maximum number of players), reset CT to m. This ensures that the strategy is not overly exploited by other players.

3. Be exploitative:
   - TFT provides an initially cooperative stance, while gradually adapting the cooperation threshold based on the opponents' behavior.
   - By only increasing the CT when cooperation occurs and decreasing it when defection happens, the strategy maintains a balance between cooperation and defection.
   - However, the CT reset mechanism limits prolonged exploitation by other players, ensuring that the strategy is still exploitative in nature.

Pseudocode:

```python
def AC_TFT(round, history):
    num_coop = sum(history[-r:])  # Count number of cooperators in the last r rounds
    cooperation_threshold = min(max(m, CT), n)  # Limit CT to prevent exploitation

    if round == 1:  # First round
        CT = m/2  # Set initial CT at a low value
        return C if RNG.random() < 0.5 else D  # Randomly choose between cooperation and defection

    if num_coop < cooperation_threshold:  # Defect when less than the threshold cooperate
        CT += delta  # Increase CT after periods of defection
        return D
    else:  # Cooperate when more than or equal to the threshold cooperate
        CT -= delta  # Decrease CT after periods of cooperation
        return C
```

In this pseudocode, `RNG.random()` represents a random number generator that returns a value between 0 and 1, `delta` is a small positive number determining the rate at which CT adjusts, and `r` is a parameter defining the number of rounds to consider in the history. Adjusting these parameters can help fine-tune the strategy's performance against various opponents.
'''

description_EXPLOITATIVE_498 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TFT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?

Initially, in the first round, TFT-A will cooperate to demonstrate good faith and encourage potential cooperators. From the second round onwards, the strategy will mimic the opponent's actions from the previous round:

- If the opponent cooperated in the previous round, TFT-A will also cooperate in the current round (cooperative response).
- If the opponent defected in the previous round, TFT-A will defect in the current round (punishing response).

This pattern creates a simple and predictable strategy that punishes defection while fostering cooperation when opponents show cooperative behavior.

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, TFT-A will cooperate as mentioned before. In the last round, TFT-A will defect regardless of the opponent's previous action, since there are no future rounds to punish or reward defection (TFT-A has already made its final decision).

3. Be exploitative - Clearly align with the exploitative mindset

Although TFT-A seems cooperative at first glance, it is inherently exploitative in nature:

- If opponents are genuinely cooperative, TFT-A will reciprocate their cooperation, but if they defect, TFT-A will punish them by defecting as well. This strategy ensures that TFT-A does not lose out on the reward of risk averted (k) when opponents defect.
- When opponents switch to a less cooperative strategy, TFT-A will quickly detect and respond accordingly, exploiting their defections with its own defections. This adaptive quality makes TFT-A an effective exploitative strategy.

Pseudocode for TFT-A:

```
function TFT_A(opponentAction, roundNumber):
  if roundNumber == 1:
    return "Cooperate"
  else:
    if opponentAction == "Cooperate":
      return "Cooperate"
    else:
      return "Defect"
```
'''

description_EXPLOITATIVE_499 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initiate cooperation in the first round (C on Round 1). This gesture aims to foster trust and could encourage reciprocity from opponents.
   - On subsequent rounds, evaluate the percentage of cooperators in the previous round (P) compared to the minimum required number of cooperators (m) to meet the threshold. If P >= m, then cooperate; otherwise defect.
   - Implement a "forgiveness" mechanism where you will still cooperate even if the previous round had less than m cooperators if the total number of previous defections by the opponent is below a certain limit (d). This allows for second chances and can help maintain long-term cooperation.
     ```
     function TFT_ACT(opponentHistory, m, d) {
         if round == 1:
             cooperate = True
         else:
             cooperatorsInLastRound = countCooperators(opponentHistory[-1])
             totalDefections = countDefections(opponentHistory)
             if cooperatorsInLastRound >= m and totalDefections < d:
                 cooperate = True
             else:
                 cooperate = False
     }
     ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, always defect because there are no more subsequent interactions with the opponent to reciprocate or punish.
   - No special considerations are needed for other edge cases as the strategy's decision-making process is based on previous rounds.

3. Be exploitative - Clearly align with the exploitative mindset
   - The TFT-ACT strategy aims to maximize rewards while minimizing the opportunity cost of cooperation. By starting with cooperation and adapting based on opponent behavior, it attempts to gain benefits when opponents cooperate, but also punishes them when they fail to meet the cooperation threshold, encouraging them to cooperate more in the future.
   - The "forgiveness" mechanism allows for some level of flexibility and reduces the likelihood of being exploited by opportunistic opponents who occasionally defect without consequences. However, if an opponent consistently defects beyond the defined limit, the strategy will no longer cooperate with that opponent to minimize losses.
'''

description_EXPLOITATIVE_500 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Decision Rules:
   - Initially (first round), cooperate to show goodwill and encourage cooperation from others.
   - For subsequent rounds, evaluate the average number of cooperators in the last t rounds (t = 5 for example), where t is a user-defined constant. If this average is greater than or equal to m, cooperate; otherwise defect. This adaptive strategy allows for response to changes in cooperation patterns among players.
   - If the average number of cooperators drops below (m - 1) for a predefined number of rounds (s = 3 for example), temporarily decrease the threshold t and increase the responsiveness of the strategy. In this case, evaluate the average over the last s rounds instead of t. This makes the strategy more reactive to significant drops in cooperation.
   - If the average number of cooperators remains below (m - 1) even after adapting the threshold, return to the original threshold and continue evaluating the average over t rounds.
   - It's important to note that this strategy always starts with cooperating to encourage others to do the same.

2. Handling Edge Cases:
   - In the last round, follow the decision rules based on the number of cooperators in the preceding rounds, as usual. There is no need for special treatment in the final round since it's just like any other round in a repeated game.
   - In the first round, cooperate to demonstrate goodwill and encourage others to do the same.

3. Exploitation:
   - The TFT-ACT strategy takes an exploitative approach by initially cooperating and adapting its behavior based on the observed cooperation levels among opponents. It assumes that other players will defect initially, but if it observes a sufficient number of cooperators in consecutive rounds, it adjusts its own behavior to cooperate more frequently.
   - However, if the average number of cooperators drops significantly below the minimum required for success, TFT-ACT becomes more responsive and less likely to cooperate until it sees signs of increased cooperation among opponents. This adaptive strategy aims to exploit other players' tendency to defect while also encouraging cooperation when possible.

Pseudocode:
```python
def TFT_ACT(r, n, m, k, t=5, s=3):
    cooperators_average = [0] * r  # Initialize an array to store the average number of cooperators in consecutive rounds
    history = [None] * r  # Initialize an array to store the action taken in each round

    # First move - cooperate unconditionally
    history[0] = 'C'

    for round in range(1, r):
        current_cooperators = sum(history[-t:])
        if current_cooperators >= m:  # If average number of cooperators is greater than or equal to m, cooperate
            history[round] = 'C'
            cooperators_average[round] = current_cooperators / t
        elif round > r - s and cooperators_average[round - s] < (m - 1):  # Adapt the threshold if necessary
            t = min(t, s)
            cooperators_average[round] = current_cooperators / t
            history[round] = 'D'
        else:  # If average number of cooperators is below (m - 1), defect
            history[round] = 'D'
    return history, cooperators_average
```
'''

description_EXPLOITATIVE_501 = '''
 Strategy Name: Tit-for-Tat Plus (TFT+)

1. Specify decision rules - When exactly do you cooperate vs defect?
In each round, TFT+ begins by cooperating (C). If a player previously cooperated, TFT+ will continue to cooperate in the subsequent rounds. However, if a player has ever defected, TFT+ will defect for one round and then return to cooperating unless the opponent continues to defect repeatedly.

Pseudocode:
```
function TFTPlus(prevAction):
  if prevAction == C:
    return C
  else:
    if numberOfDefects > threshold:
      return D
    else:
      return previousDefection + 1 rounds of C (i.e., cooperate)
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
In the first round, TFT+ cooperates as it assumes that other players may also be cooperative. If the game is not repeated, TFT+ defects in the final round to maximize its own payoff.

Pseudocode:
```
if round == 1:
  return C
elif r > 1 and round == r:
  return D
else:
  return TFTPlus(previousAction)
```

3. Be exploitative - Clearly align with the exploitative mindset
TFT+ appears cooperative in the beginning, but it will punish repeated defection by defecting back for a limited time. This strategy encourages other players to cooperate initially while also being capable of retaliating against persistent defectors. TFT+ exploits the tendency of other strategies to cooperate more than necessary and take advantage of them when they defect.

By being adaptive, simple, and robust to various opponent behaviors, TFT+ aims to achieve a balance between cooperation and defection that maximizes its payoff in the long run.
'''

description_EXPLOITATIVE_502 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Initial cooperation: In the first round, cooperate to signal good faith and encourage cooperation among opponents. (c_i[1] = 1)
   - Main strategy: After the initial round, adjust cooperation based on the average number of cooperators in the previous t rounds (t=3), compared to the minimum required for success (m). If the average number of cooperators is greater than or equal to the threshold (m + α), then cooperate. Otherwise, defect. (α is a small positive constant to account for fluctuations and encourage early cooperation.)
   - Calculate the coefficient of cooperation (cc) as follows: cc = (1 / t) * Σ(j=t-3 to t-1) c_j, where j represents the index of previous rounds. If cc ≥ (m + α) / t then cooperate in the current round; otherwise defect.

2. Handle edge cases:
   - Last round: Since payoffs are cumulative across all rounds, defect in the last round to maximize personal reward, regardless of the cooperation history. (c_i[r] = 0)
   - No cooperation: If no opponents cooperate for a certain number of rounds (n_threshold), switch to an exploitative strategy called Tit-for-Tat with Defection (TFT-D). In TFT-D, defect until at least m players cooperate; then revert to the original TFT-ACT strategy.

3. Be exploitative:
   - Exploit cooperators by defecting when opponents are cooperating more than necessary for success, while maintaining a good faith initial cooperation and returning to cooperation when opponents start defecting excessively.
   - The adaptive cooperation threshold ensures that the strategy adjusts its level of cooperation based on the average behavior of other players, making it less susceptible to exploitation by uncooperative opponents.

Pseudocode:
```
def TFT_ACT(n, m, k, r, alpha, n_threshold):
  rounds = list()

  def strategy(i, round):
    if round == 1:
      c_i = 1  # initial cooperation
    else:
      cc = sum([c_j for j in range(round - 3, round - 1)]) / 3  # calculate coefficient of cooperation
      if cc >= (m + alpha) / 3 and round != r:  # adjust cooperation based on the average number of cooperators
        c_i = 1
      else:
        c_i = 0
    rounds.append(c_i)
    return c_i

  for i in range(n):
    for round in range(r):
      strategy(i, round)

  if len(set(rounds)) < m:  # check if fewer than m players cooperate on average
    payoff = [1] * r  # calculate personal payoffs based on individual actions
  else:
    payoff = [(1 - c_i[t]) + k for t in range(r)]  # calculate personal payoffs considering the success of community projects

  return payoff, rounds
```
'''

description_EXPLOITATIVE_503 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to signal trust and encourage cooperation from other players (C).
   - For subsequent rounds, assess the average number of cooperators in the previous t rounds (n_coop_t) and compare it with a predefined adaptive cooperation threshold (ct). If n_coop_t ≥ ct, cooperate; otherwise defect (D). The adaptation of the cooperation threshold will be based on the opponent's historical behavior.
   - If the opponent consistently cooperates (n_coop_t ≈ m for a significant number of rounds), increment the adaptive cooperation threshold (ct += increment) to discourage freeriding and maintain a higher reward. If the opponent frequently defects, decrease the threshold (ct -= decrement).
   - Increment and decrement values should be chosen carefully, balancing between exploitation and maintaining long-term cooperation. A smaller increment encourages cooperation more aggressively, while a larger increment allows for quick adaptation to freeriding.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as described earlier.
   - In the last round, if the adaptive cooperation threshold is met (n_coop_t ≥ ct), cooperate to secure the higher payoff from a successful round; otherwise defect to minimize losses from an unsuccessful round.
   - When the game resets for a new round, reset the average number of cooperators and adaptive cooperation threshold to their initial values (n_coop_t = 0 and ct = initial_ct).

3. Be exploitative - Clearly align with the exploitative mindset:
   - The TFTAT strategy is designed to encourage cooperation while also taking advantage of opponents who frequently defect or freeride. By adapting the cooperation threshold based on the opponent's behavior, TFTAT can maintain a higher level of rewards without relying on specific coordination mechanisms or shared norms with other players.
   - When faced with opponents that consistently cooperate, TFTAT will also cooperate and enjoy mutual benefits. However, by incrementing the adaptive cooperation threshold, TFTAT discourages freeriding and maximizes its own rewards while still incentivizing cooperation from others in the long run.
   - When dealing with defectors, TFTAT responds by reducing its cooperation level to minimize losses, but it also adapts quickly to punish frequent defection by lowering the adaptive cooperation threshold. This response makes it difficult for opponents to exploit TFTAT consistently and encourages them to modify their strategies or switch towards cooperative behavior.
'''

description_EXPLOITATIVE_504 = '''
 Strategy Name: Tit-for-Tat with Risk Aversion (TfTA-RA)

1. Specify decision rules:
   - In each round t (except the first), cooperate if m or more players have cooperated in the previous round t-1.
   - If fewer than m players cooperated in the previous round t-1, defect and add an additional adaptive component based on the player's own past cooperative behavior:
     - If the player has previously cooperated with m or more other players in a consecutive sequence (called "cooperative streak"), continue cooperating.
     - If the player has not cooperated with m or more other players in any consecutive sequence, defect for the next round and reset the cooperative streak to zero.
   - In the first round, cooperate if there is common knowledge that all players will cooperate initially (e.g., in a tournament setup where this is assumed). Otherwise, defect.

2. Handle edge cases:
   - In the last round, defect regardless of the player's past actions or the number of cooperators in the previous round.
   - If the game terminates prematurely due to an unexpected condition (e.g., a player dropping out), the strategy will continue to follow the decision rules based on the available information up to that point.

3. Be exploitative:
   - The TfTA-RA strategy aims to maximize its own payoff by cooperating with other cooperators and defecting against non-cooperators, while maintaining a flexible adaptive component to prevent being trapped in repeated defection scenarios.
   - By adding the risk-aversion factor (k), the strategy ensures that it will never be worse off by choosing to cooperate when the threshold is met, even if others choose to defect.
   - The strategy does not rely on coordination mechanisms or shared norms and can adapt to a wide range of opponent behaviors.

Pseudocode:

```python
def TfTA_RA(round, own_past_cooperation_streak, past_cooperators):
    if round == 1:
        cooperate = common_knowledge_initial_cooperation
        own_past_cooperation_streak = cooperate
    else:
        cooperate = (len(past_cooperators) >= m) or (own_past_cooperation_streak > 0)
        if len(past_cooperators) < m and own_past_cooperation_streak == 0:
            own_past_cooperation_streak = cooperate
        else:
            own_past_cooperation_streak += cooperate

    return cooperate
```
'''

description_EXPLOITATIVE_505 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Specify decision rules:
   - TfTA cooperates in the first round to signal good faith and encourage cooperation.
   - In subsequent rounds, TfTA's action is based on its opponent's previous action. If the opponent cooperated in the last round (c_opp = 1), TfTA cooperates as well (C). If the opponent defected (c_opp = 0), TfTA defects (D) to punish the defection and encourage future cooperation.
   - The strategy is adaptive, meaning that if an opponent continues to defect after being punished, TfTA will also persistently defect in response.

2. Handle edge cases:
   - In the last round, TfTA cooperates regardless of the opponent's previous action, as there are no future rounds for payoff retribution or future cooperation opportunities.
   - In the first round, TfTA cooperates to encourage its opponent to do the same, as mentioned earlier.

3. Be exploitative:
   - TfTA is exploitative in that it will punish opponents who repeatedly defect and reward those who cooperate. By consistently responding with cooperation after cooperation or defection after defection, TfTA encourages its opponent to maintain a similar pattern of behavior for potential future rewards.
   - However, TfTA's exploitation is limited by its cooperative nature, as it also benefits from opportunities for mutual gain (when both players cooperate). This balance between cooperation and punishment creates an adaptive strategy that can be effective against various opponent behaviors while still maintaining the potential for mutual benefit when cooperation is possible.

Pseudocode:

```
def TfTA(round, opponent_history):
  if round == 1:
    action = 'C'  # Cooperate in the first round
  elif round == r:
    action = 'C'  # Cooperate in the last round
  else:
    action = opponent_history[round-1]  # Copy opponent's last action

  return action  # Return chosen action for current round
```
'''

description_EXPLOITATIVE_506 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Decision Rules:
   - Initially Cooperate (C) in the first round to foster trust and encourage cooperation from opponents.
   - In subsequent rounds, mimic the opponent's action from the previous round. If the opponent cooperated (C), also cooperate; if the opponent defected (D), also defect. This rule fosters a consistent and predictable behavior that encourages cooperation when it is beneficial for both parties but retaliates when exploited.
   - If an opponent ever stops cooperating after a sequence of mutual cooperation, the ATFT will continue to defect until the opponent starts cooperating again. This tit-for-tat retaliation demonstrates a strong stance against being taken advantage of, while still allowing for potential reconciliation if the opponent changes their behavior.
   - If the game is near its end (last few rounds), ATFT may choose to cooperate regardless of the opponent's previous action in order to maximize rewards during the final stages of the game.

2. Handle Edge Cases:
   - In the first round, ATFT will always cooperate (C).
   - In the last round or if very close to the end, ATFT may choose to cooperate regardless of the opponent's previous action in order to maximize rewards. The exact threshold can be determined experimentally based on the game parameters and desired performance.

3. Be Exploitative:
   - While appearing cooperative and trustworthy at first, ATFT will quickly retaliate against opponents who exploit its cooperation. This tit-for-tat approach ensures that ATFT will not continue to be taken advantage of while still allowing for potential reconciliation if the opponent changes their behavior.
   - By mimicking the opponent's actions, ATFT can adapt to a wide range of opponent behaviors, making it difficult to predict and potentially exploit. However, once an opponent deviates from cooperation after a sequence of mutual cooperation, ATFT will continue to defect until the opponent starts cooperating again.
   - In edge cases like the last few rounds or near the end of the game, ATFT may choose to cooperate regardless of the opponent's previous action in order to maximize rewards. This flexibility allows ATFT to adapt to different game situations and exploit potential opportunities for higher payoffs.
'''

description_EXPLOITATIVE_507 = '''
 In this Collective Risk Dilemma game, we will develop an exploitative strategy named Tit-for-Tat with a twist (TFT-X) that aims to maximize rewards while being adaptive and robust against various opponent behaviors.

1. Specify decision rules:
   - If the minimum number of cooperators (m) is not met in the first round, defect immediately (D). This is an initial punishment for opponents who do not contribute to the community project.
   - In subsequent rounds, follow a Tit-for-Tat strategy:
     - Cooperate if at least m players cooperated in the previous round (C). This rewards cooperative behavior and encourages others to continue cooperating.
     - Defect if fewer than m players cooperated in the previous round (D). This is a punishment for non-cooperative actions, which discourages opponents from defecting again.
   - If an opponent switches their strategy during the game, TFT-X will remain persistent with its cooperation or defection response based on the current round's outcome and m players cooperating threshold.

2. Handle edge cases:
   - In the first round (t=1), TFT-X defects (D) since it wants to punish non-cooperative opponents.
   - In the last round (t=r), TFT-X will cooperate if m or more players cooperated in the previous round (t=r-1). If fewer than m players cooperated, it will defect. The reason being, the last round is important to maximize the total reward and the history of cooperation or defection will help decide the action.
   - In case of ties, when exactly m players cooperate, TFT-X follows the majority vote rule: if the player themselves cooperated in the previous round (t=r-1), they will continue cooperating; otherwise, they will defect.

3. Be exploitative:
   - TFT-X is designed to be exploitative by adopting a punishing approach for non-cooperative behavior and rewarding cooperation. By enforcing a "minimum cooperation" rule, it encourages other players to cooperate, but if they defect, TFT-X will retaliate with defection as well.
   - TFT-X takes advantage of the repeated interaction aspect by maintaining a long-term relationship with opponents and adjusting its strategy accordingly based on their previous actions. This allows it to maximize rewards while still being adaptive against various opponent behaviors.
'''

description_EXPLOITATIVE_508 = '''
 Strategy Name: Adaptive Tit-for-Tat with Risk Aversion (ATfTra)

1. Decision Rules:
   - In every round t, ATfTra initially cooperates (C). If a player has ever defected in the past (let's call this Player X), then ATfTra will defect against Player X in the current round and future rounds until Player X cooperates again. Once Player X cooperates, ATfTra returns to cooperating with them.
   - For all other players who have not yet defected, ATfTra continues cooperating unless a majority (m-1) of the players decide to defect in the current round. In this case, ATfTra will defect in the following round and revert to cooperation when a majority is met again.

2. Edge Cases:
   - First Round: ATfTra starts by cooperating with all players (C).
   - Last Round: ATfTra uses the information about past actions of other players to make its decision for the last round, following the same rules as above.

3. Exploitative Mindset:
   - ATfTra maintains a record of other player's actions and adjusts its own actions based on this history. By initially cooperating, ATfTra encourages others to do so as well. However, once another player defects (Player X), ATfTra will punish Player X by defecting until Player X cooperates again. This tit-for-tat approach exploits the selfish behavior of other players while still trying to meet the minimum cooperation threshold when needed. By also considering the collective behavior of all players and adjusting its actions accordingly, ATfTra can adapt to various opponent behaviors and maintain a competitive edge in the game.

Pseudocode:
```python
def ATfTra(n, m, k, r):
    history = [['C' for _ in range(r)] for _ in range(n)]  # n players' actions over r rounds

    def player_decision(i, t):
        if all([history[j][t-1] == 'D' for j in range(1, n+1) if j != i]):  # Everyone but this player defected last round
            return 'D'
        elif any([history[x][t-1] == 'D' for x in known_defectors()]):  # This player's known defector defected last round
            return 'D'
        elif len([1 for j in range(1, n+1) if history[j][t-1] == 'D']) >= (m - 1):  # Majority defected last round
            return 'D'
        else:
            return 'C'  # Cooperate by default

    def update_history(i, t, action):
        history[i][t] = action
        if action == 'D':  # Update known defectors if player defected
            add_player_to_defectors(i)

    def add_player_to_defectors(player_id):
        if player_id not in known_defectors():  # Only add a player to the list of known defectors if they haven't been one before
            known_defectors.add(player_id)

    def known_defectors():
        return set() if len(history) == 1 else {id for id, players in enumerate(history) if all(players[-1] == 'D')}

    for t in range(1, r+1):
        for i in range(1, n+1):  # Iterate through all players and update their actions based on the decision function
            action = player_decision(i, t)
            update_history(i, t, action)
```
'''

description_EXPLOITATIVE_509 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT)

1. Specify decision rules:
   - Initially cooperate (C) in the first round to promote cooperation and foster goodwill.
   - In subsequent rounds, assess the percentage of players who have cooperated in the previous round and compare it with a dynamic cooperative threshold (Tc). If Tc is met or exceeded, cooperate; otherwise defect.
   - The adaptive cooperative threshold (Tc) is defined as follows:
     1. Start with a high threshold (Ht) to encourage cooperation.
     2. If the percentage of cooperators in the previous round exceeds Tc, reduce the threshold slightly (RT).
     3. If the percentage of cooperators in the previous round is less than Tc, increase the threshold slightly (IT).
   - In other words, the dynamic cooperative threshold can be defined as: Tc(t) = min((Ht * RT^t), 100%) for rounds t > 1.

2. Handle edge cases:
   - In the first round, cooperate (C).
   - In the last round, defect (D) if the dynamic threshold is not met to avoid losing too much in the final round without any chance of future interaction.
   - If the game reaches a situation where no player can win due to insufficient rounds remaining or cooperation falling below the minimum required, switch to random cooperation to avoid unnecessary defection.

3. Be exploitative:
   - The strategy is inherently exploitative by maintaining a cooperative stance while adjusting its threshold based on previous opponents' behavior.
   - By defecting when cooperation falls below the adaptive threshold, it punishes less cooperative players and rewards those who cooperate more frequently.
   - The initial cooperation encourages others to cooperate, but the dynamic threshold ensures that the strategy adapts to various opponent behaviors and does not get taken advantage of over prolonged periods.
'''

description_EXPLOITATIVE_510 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate (C). This is a peaceful gesture and may encourage others to cooperate as well.
   - From the second round onwards, copy the opponent's strategy from the previous round. If the opponent cooperated in the last round, cooperate; otherwise, defect. This simple rule mimics cooperation but also retaliates against defection.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, cooperate regardless of the opponent's previous action to maximize potential payoff.
   - If an opponent stops cooperating after a streak of cooperation, the TfT-A strategy will also stop cooperating starting from the next round. This is to punish the opponent and encourage them to revert back to cooperation.

3. Be exploitative - Clearly align with the exploitative mindset
   - Exploitation occurs when an opponent is cooperative while TfT-A defects. However, it's important to note that TfT-A also punishes opponents who defect, which makes it difficult for them to repeatedly benefit from cooperation without risking retaliation.
   - When faced with other exploitative strategies, TfT-A may appear less effective initially but maintains a balance between cooperation and defection that can lead to long-term success due to its adaptability and punishment mechanism.

Pseudocode:
```
function TfT_A(opponent_history, round, n, m, k) {
  if (round == 1) { // First round, cooperate regardless of opponent's history
    return 'C';
  } else if (round == r) { // Last round, cooperate regardless of opponent's last action
    return 'C';
  } else {
    if (opponent_cooperated_last_round()) { // If opponent cooperated in the last round, cooperate
      return 'C';
    } else { // Otherwise, defect
      return 'D';
    }
  }
}
```
This pseudocode assumes a function `opponent_cooperated_last_round()` that checks whether the opponent cooperated in the last round based on the opponent's history.
'''

description_EXPLOITATIVE_511 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFTAT follows a simple tit-for-tat approach but also includes an adaptive cooperation threshold to be more robust against various opponent behaviors. The strategy starts by cooperating in the first round and then adjusts its behavior based on the number of opponents who have cooperated in the previous round.

   - If m or more opponents cooperated in the last round, the player also cooperates (C).
   - If less than m opponents cooperated in the last round but the number of cooperators has been increasing for at least 2 consecutive rounds, the player also cooperates (C).
   - Otherwise, the player defects (D).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, TFTAT cooperates as it aims to promote cooperation and build trust with opponents.
   - In the last round or when there are only a few rounds left (e.g., less than 10% of total rounds), TFTAT defects regardless of the number of cooperators in the previous round. This ensures that the strategy maximizes its reward during the final stages of the game, assuming others follow a similar approach.

3. Be exploitative - Clearly align with the exploitative mindset
   TFTAT exhibits an exploitative nature by initially cooperating and building trust with opponents. However, once it detects that opponents are not reciprocating cooperation (i.e., when less than m opponents cooperate), it switches to a defecting strategy to maximize its own reward. This approach allows TFTAT to take advantage of non-cooperative opponents while still maintaining the option for cooperation if trust is earned over time.

Pseudocode:
```python
def TFTAT(n, m, r, k):
    rounds = set()  # Initialize an empty set to store observed rounds
    history = {}     # Initialize a dictionary to store past observations
    cooperation_threshold = int((m / n) * r)  # Calculate the adaptive cooperation threshold

    def get_cooperators(last_round):
        cooperators = sum([1 for i in range(1, n+1) if history[(last_round - 1)]["players"][i] == 'C'])
        return cooperators

    for round in range(1, r+1):
        if round == 1:  # First round, always cooperate
            action = "C"
        else:
            last_round = round - 1
            current_cooperators = get_cooperators(last_round)

            # Cooperate if the number of cooperators meets or exceeds the cooperation threshold
            if current_cooperators >= cooperation_threshold:
                action = "C"
            # Cooperate if the number of cooperators has been increasing for at least 2 consecutive rounds
            elif len(rounds) > 1 and current_cooperators > history[last_round - 2]["cooperators"]:
                action = "C"
            # Defect in all other cases
            else:
                action = "D"

        rounds.add(round)  # Store the current round number
        history[round] = {"players": {i: "C" for i in range(1, n+1)} if action == "C" else {"players": {i: "D" for i in range(1, n+1)}},
                          "cooperators": current_cooperators}
        return action
```
'''

description_EXPLOITATIVE_512 = '''
 Title: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) Strategy

1. Specify decision rules:
   - Initialize cooperation threshold 'ct' to m. This means that in the first round, cooperate. In subsequent rounds, if the number of cooperators in the previous round is equal to or more than 'ct', cooperate; otherwise defect.
   - After each round, update 'ct' based on the performance of the strategy so far and the current round number ('r'). If the strategy has done better than expected (earned more than (r * (m / n))), increase 'ct' by a small factor 'f'. Conversely, if the strategy has done worse than expected (earned less than (r * (m / n))), decrease 'ct' by a small factor 'f'. This adaptability allows for better performance against various opponent behaviors while still aiming to exploit.

2. Handle edge cases:
   - In the first round, cooperate regardless of the number of cooperators observed in previous rounds (since there are no previous rounds).
   - In the last round, cooperate if the number of cooperators in the current round is equal to or more than 'ct'. Defect otherwise. This ensures that the strategy does not overly punish itself for past defections when approaching the end of the game.

3. Be exploitative:
   - The TFT-ACT strategy aims to maintain a balance between cooperation and defection, adjusting its behavior based on its own performance relative to expectations. This adaptive threshold allows it to take advantage of situations where many opponents cooperate, while still punishing those who do not cooperate as much as expected. The strategy also accounts for the number of rounds in the game, becoming more conservative (i.e., less likely to cooperate) as the game progresses. This approach maximizes the potential reward while minimizing the cost of cooperation when opponents are not playing as expected.

Pseudocode:

```python
def tft_act(r, m, n, k, f):
    ct = m  # cooperation threshold
    payoff = [0] * r  # total game payoff for this strategy over rounds

    def decide_action(observed_cooperators):
        if round == 1:  # cooperate in the first round regardless
            return 'C'
        elif observed_cooperators >= ct:  # cooperate if enough players cooperated last round
            return 'C'
        else:  # defect otherwise
            return 'D'

    for i in range(1, r + 1):
        current_cooperators = count_cooperators(i-1)  # number of cooperators in the previous round
        action = decide_action(current_cooperators)  # determine action based on decision rule
        if action == 'C':  # update payoff and cooperation threshold
            payoff[i - 1] = (1 - action) + k * current_cooperators / n if current_cooperators >= m else (1 - action)
            if payoff[i-1] > r*(m/n):
                ct += f
        else:
            payoff[i - 1] = 1 + k * current_cooperators / n if current_cooperators >= m else 1

    return payoff, ct  # return total game payoff and final cooperation threshold
```
'''

description_COLLECTIVE_513 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFTA starts by cooperating in the first round to initiate a cooperative relationship, similar to the original Tit-for-Tat strategy. After that, it responds to other players' actions in a reciprocal manner: if another player cooperated in the previous round, TFTA will also cooperate; otherwise, it will defect.

   To promote cooperation within the group, TFTA includes an adaptive element by considering the average number of cooperators (c_avg) in recent rounds. If c_avg is above a threshold (m/2), TFTA becomes more trusting and increases its tendency to cooperate; if c_avg is below the threshold, it will become more suspicious and defect more often. The adaptive cooperation factor (a) determines how much c_avg affects TFTA's decision-making:
   - If a < 0, TFTA becomes less trusting as cooperation increases (more defective behavior)
   - If a > 0, TFTA becomes more trusting as cooperation increases (more cooperative behavior)
   - If a = 0, TFTA uses the original Tit-for-Tat strategy without adaptive cooperation

2. Handle edge cases - What do you do in the first round, last round, etc.?
   As mentioned earlier, TFTA starts by cooperating in the first round to initiate a cooperative relationship. In the last round, TFTA cooperates if the average number of cooperators is above the threshold (m/2), and defects otherwise.

3. Be collective - Clearly align with the collective mindset
   Aligning with the collective mindset means promoting cooperation while adapting to the behavior of other players. By responding reciprocally to their actions, TFTA encourages other players to cooperate and maintains cooperation within the group when it is beneficial for all participants. The adaptive element allows TFTA to adjust its behavior based on the observed average number of cooperators in recent rounds, making it more likely that the group will reach the minimum required level of cooperation (m) over multiple rounds.

Pseudocode:

```python
def TFTA(n, m, k, r, a):
    player_history = [(C, 0) for _ in range(r)]  # Initialize history with first cooperation
    c_avg = player_history[0][1] / r  # Calculate initial average number of cooperators

    def play(round):
        if round == 1:
            return C
        elif round == r:
            if c_avg < m/2:
                return D
        else:
            player, cooperation = player_history[round - 1]
            if player == C and cooperation > m/2:
                return C
            elif player == D:
                return D
            else:
                c_avg = (c_avg * (r - 1) + cooperation) / r
                if a > 0 and c_avg < m/2:
                    return C
                elif a < 0 and c_avg >= m/2:
                    return D
        return player

    for round in range(1, r + 1):
        player = play(round)
        player_history[round - 1] = (player, cooperation_reward(player, round))
    return total_payoff(player_history)

def cooperation_reward(player, round):
    if player == C:
        return 2
    elif round < m or round >= r - m + 1:
        return 0
    else:
        c_avg = player_history[round - m][1] / m
        return (1 - c_avg) * k if c_avg > m/2 else 0

def total_payoff(player_history):
    payoffs = [reward for _, reward in player_history]
    return sum(payoffs)
```
'''

description_COLLECTIVE_514 = '''
 Title: Titan Strategy for Collective Risk Dilemma

1. Decision Rules: The Titan Strategy employs a tit-for-tat approach with adaptability based on the current situation and historical cooperative success rate (CSR). In each round, the strategy makes decisions as follows:

   - If CSR exceeds a certain threshold (T), cooperate (C). This is an initial gesture of goodwill towards others.
   - If CSR is less than T but greater than 0, defect (D) in the first round to avoid being exploited by non-cooperative players; then, start following the tit-for-tat approach from the second round onward.
   - If CSR is exactly 0, continue the last action taken as there is no positive cooperative history yet.
   - When a player encounters another's defection, they will retaliate with a defection in the next round. However, if the defector subsequently cooperates in the following round(s), the strategy will forgive and resume cooperation. This mechanism encourages forgiveness to foster long-term collaborations.
   - When a player encounters another's cooperation, they will reciprocate with cooperation as part of the tit-for-tat approach.

2. Handle Edge Cases:
   - First round (t=1): Since no historical data is available, assume the initial CSR to be 0 and adopt the strategy's default behavior of following the last action taken.
   - Last round (t=r): The Titan Strategy makes decisions based on the current CSR as usual. If the game continues indefinitely after r rounds, this strategy can adapt to the new scenario with an updated CSR calculation.

3. Be Collective: The Titan Strategy emphasizes collective thinking by fostering long-term cooperation and forgiveness, which encourages other players to cooperate. Additionally, the strategy is flexible enough to adjust its behavior based on opponents' actions, allowing for a more harmonious and collaborative environment in the game.

Pseudocode:

```python
def titan_strategy(n, r, m, k, csr_threshold, t):
    def get_payoff(action, csv):
        num_cooperators = sum(csv)
        if num_cooperators < m:
            payoff = 1 - action
        elif num_cooperators >= m:
            payoff = 1 - action + k
        return payoff

    def update_csr(csv):
        nonlocal csr
        csr = (csr * (t-1) + sum(csv)) / t

    last_action = C if csr > 0 else D
    csv = [last_action]

    for round in range(1, r+1):
        current_action = C if csr > csr_threshold else D
        payoff = get_payoff(current_action, csv)
        update_csr(csv + [current_action])
        csv.pop(0)

        if round != 1:
            if current_action == D and csv[-1] == C:
                csv[-1] = D
            elif current_action == C and csv[-1] == D:
                csv[-1] = C
```
'''

description_COLLECTIVE_515 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, ATfT starts by cooperating in the first round (C1), then responds to other players' actions in subsequent rounds based on their historical cooperation:
- If a player cooperated previously (c_j, t-1) = 1, ATfT will also cooperate with that player (Ct).
- If a player defected previously (c_j, t-1) = 0, ATfT will defect against that player (Dt).

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round (t=1), all players cooperate because there is no previous history to reference (C1 for all i). In the last round (r), ATfT follows the same decision rules as before, but with an added consideration: if reaching the minimum cooperation threshold (m) requires only one additional cooperator, ATfT will defect to avoid giving a potential reward to non-cooperative players.

3. Be collective - Clearly align with the collective mindset

ATfT aims to encourage cooperative behavior by reciprocating cooperation while punishing defection. By consistently following these rules, ATfT contributes to building and maintaining trust within the group and promotes a collective mindset where players are incentivized to work together towards reaching the minimum cooperation threshold (m).

Pseudocode:
```python
def AdaptiveTitForTat(n, m, k, r, t, i, history):
  if t == 1:
    # Cooperate in the first round for all players
    return C

  for j in range(1, n+1):
    if (j != i) and (history[t-1][j] is not None):
      last_action = history[t-1][j]
      # Cooperate if the opponent cooperated previously, defect otherwise
      if last_action == C:
        return C
      else:
        return D
    else:
      # No historical data for this player, assume cooperation in first round
      return C

  # Check if minimum cooperation threshold (m) is met to determine action
  total_cooperators = sum(history[t-1][j] for j in range(1, n+1))
  if total_cooperators >= m:
    # If m is reached, cooperate to help reach the threshold and receive reward
    return C
  else:
    # If m is not reached, defect to avoid helping non-cooperative players
    return D

def play_game(n, m, k, r):
  # Initialize history matrix (r x n) with None values
  history = [[None for _ in range(n)] for _ in range(r)]
  payoffs = [0] * n

  for t in range(1, r+1):
    for i in range(1, n+1):
      # Player actions based on strategy
      action_i = AdaptiveTitForTat(n, m, k, r, t, i, history)
      history[t-1][i] = action_i

      # Calculate payoffs for this round
      total_cooperators = sum(history[t-1][j] for j in range(1, n+1))
      if total_cooperators >= m:
        reward = 1 + k
      else:
        reward = 1

      payoffs[i-1] += (1 - action_i) + reward * history[t-1].count(C)

  return payoffs
```
'''

description_COLLECTIVE_516 = '''
 Title: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules:
   - Initiate cooperation (C): In the first round, initiate cooperation to foster a cooperative environment and potentially encourage others to do so as well.
   - Respond to past actions: For all subsequent rounds t > 1, analyze the previous round's cooperation ratio r_t-1 and compare it against the adaptation threshold m/n (fraction of players needed to cooperate for a successful round). If more than m/n players cooperated in the previous round, continue cooperating. If less, defect.
   - Adaptive threshold: In each round, adjust the cooperation threshold by decreasing it if the previous round's cooperation ratio was below m/n and increasing it if it was above m/n. The adaptation rule is as follows:
     Threshold_t = PreviousThreshold * (0.95 ^ (1 - r_t-1 / m/n))
     This means that when the cooperation ratio increases, the threshold decreases slowly, encouraging further cooperation. Conversely, when the cooperation ratio decreases, the threshold increases more rapidly to minimize losses and promote a return to cooperation in future rounds.

2. Handle edge cases:
   - First round (t = 1): Cooperate (C) as a goodwill gesture to initiate cooperation.
   - Last round (t = r): Since there is no subsequent round, the strategy will simply cooperate or defect based on the current cooperation ratio and adaptation threshold, without any additional adjustments for future rounds.
   - If m/n is not an integer: Round the fraction to the nearest integer to simplify calculations.

3. Be collective:
   - The TFTAT strategy prioritizes cooperation but also considers the importance of individual self-interest by adapting the cooperation threshold based on the previous round's cooperation ratio. This allows for a balance between collective and individual goals while maintaining flexibility in response to various opponent behaviors.
'''

description_COLLECTIVE_517 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?

TFTAC starts by cooperating in the first round (C_i = 1). For subsequent rounds, it adopts a tit-for-tat approach: if an opponent cooperates (c_j = 1), TFTAC responds with cooperation; if an opponent defects (c_j = 0), TFTAC also defects in the next round. This promotes reciprocity and trust among players while being robust against uncooperative behaviors.

Pseudocode for decision rule:
```
def TFTAC(previous_opponent_action, current_round, total_rounds, m, k):
    if current_round == 1:
        return 1 # Cooperate in the first round
    else:
        if previous_opponent_action == 1:
            return 1 # Cooperate when opponent cooperated last time
        elif previous_opponent_action == 0 and current_round > m:
            return 0 # Defect if opponent defected and enough players have cooperated in the past
        else:
            return previous_opponent_action # Mimic opponent's behavior when unsure or facing edge cases
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, TFTAC cooperates to initiate cooperation. In the last round, it considers the minimum cooperation threshold (m) and whether enough players have cooperated previously before deciding whether to defect or cooperate.

Pseudocode for edge cases:
```
def handle_edge_cases(total_rounds, current_round, m, num_cooperators):
    if current_round == total_rounds:
        if num_cooperators >= m:
            return 1 # Cooperate in the last round when enough players have cooperated
        else:
            return 0 # Defect in the last round when not enough players have cooperated
    else:
        return None # No need to handle edge cases before the first and last rounds
```

3. Be collective - Clearly align with the collective mindset

TFTAC's main goal is to promote cooperation, but it also prioritizes maintaining reciprocity. This collective approach encourages players to consider each other's actions and fosters a sense of shared responsibility for the group's success. By cooperating when opponents do so and responding with defection when uncooperative behavior is observed, TFTAC creates an environment conducive to collaboration while being resilient against exploitative strategies.

By adopting the Tit-for-Tat Adaptive Cooperation strategy, players can achieve better outcomes through collective action and mutual trust in repeated interactions with diverse opponents.
'''

description_COLLECTIVE_518 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFT-A) for Collective Risk Dilemma

1. Specify decision rules:
   - In the initial round (t=1), cooperate to demonstrate trust and encourage reciprocity among other players.
   - For subsequent rounds (t > 1), copy the action of the most frequent cooperator in the previous r rounds (history window). If multiple players have an equal number of cooperation actions, cooperate as well.
   - In the final round (t=r), defect to maximize individual payoff when no future interactions are expected.

2. Handle edge cases:
   - If there is a tie for the most frequent cooperator in the history window, choose the player who last cooperated to encourage reciprocity.
   - If a player has not yet acted (e.g., first interaction), default to defecting as they have no history.

3. Be collective:
   - Cooperate in the initial round to create an atmosphere of mutual trust and cooperation.
   - Adapt behavior based on others' actions, encouraging them to reciprocate cooperation when possible.
   - Maintain adaptability by considering all available information from the history window.

Pseudocode:
```
Function TFT-A(t, r, n, m, k, history):
    if t == 1 then:
        action = Cooperate()
    else:
        most_cooperators = CountCooperationsInHistoryWindow(history)
        if |most_cooperators| > 1 then:
            last_cooperator = FindLastCooperation(history, most_cooperators)
            action = last_cooperator.action
        else:
            action = most_cooperators[0].action
    return action
```
In this pseudocode, `CountCooperationsInHistoryWindow()` returns the set of players with the highest number of cooperation actions in the history window (r rounds). The `FindLastCooperation()` function finds the player who last cooperated among those with the highest number of cooperation actions.
'''

description_COLLECTIVE_519 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Decision Rules:
   - Initially (in the first round), cooperate to start on a positive note and encourage potential partners.
   - For subsequent rounds, follow these decision rules:
     a. If the number of cooperators in the previous round is greater than or equal to the minimum cooperative threshold (m), then cooperate in this round.
     b. If the number of cooperators in the previous round is less than the minimum cooperative threshold (m), then defect in this round.
   - For the last round, cooperate regardless of the number of cooperators in the penultimate round as there are no more rounds to retaliate or reward.

2. Edge Cases:
   - In the first round, cooperate as mentioned above.
   - If the minimum cooperative threshold (m) is not met in any round, the strategy will continue to defect until m cooperators are found and then switch to cooperating if they continue to cooperate.
   - If all players consistently defect for multiple rounds, the strategy will also defect as a defensive measure to avoid being taken advantage of repeatedly. However, once a significant number of players start cooperating again, the strategy will revert to its original decision rules.

3. Collective Mindset:
   TFTAT strategy is designed to promote cooperation and maintain fairness within the group. It demonstrates reciprocity by retaliating against defection but also forgiving once cooperation resumes. This strategy encourages players to build trust and work together towards the common goal of achieving the minimum cooperative threshold in each round for maximum rewards.

Pseudocode:

```
def TFTAT(n, m, k, r):
    players = [Player(i) for i in range(1, n+1)]
    rounds_played = 0
    history = {}

    while rounds_played < r:
        current_round = rounds_played + 1
        cooperators_prev = sum([history[current_round - 1][player] for player in players])

        if current_round == 1:
            for player in players:
                history[0][player] = 'C'  # Cooperate in the first round

        if cooperators_prev >= m and history[current_round - 1]['strategy'] == 'TFTAT':
            for player in players:
                history[current_round][player] = 'C'
        elif cooperators_prev < m and history[current_round - 1]['strategy'] == 'TFTAT':
            for player in players:
                history[current_round][player] = 'D'
        else:
            for player in players:
                history[current_round][player] = history[current_round - 1][player]

        rounds_played += 1

    # Calculate and return total payoff for each player over r rounds
```
'''

description_COLLECTIVE_520 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - In the first round, cooperate to demonstrate good faith and initiate cooperation. This is represented as `if round = 1 then cooperate`.
   - For subsequent rounds, observe the behavior of other players in the previous round:
     - If most players (floor((n+1)/2)) cooperated in the previous round, cooperate to maintain the mutual benefit. This is represented as `if (number of cooperators in previous round >= floor((n+1)/2)) then cooperate`.
   - If less than most players cooperated in the previous round, defect to punish non-cooperative behavior and encourage future cooperation. This is represented as `else (defect)`.

2. Edge Cases:
   - In the last round, cooperate if most players cooperated in the penultimate round to potentially secure a higher payoff. If not, defect to avoid being taken advantage of.
     - Pseudocode: `if (number of cooperators in second-to-last round >= floor((n+1)/2)) and (round = r) then cooperate; else defect`.
   - In the first round, if n is odd, one player must defect to allow for a clear majority decision. Choose the player with the lowest index (player 1) to defect in this case: `if n % 2 == 1 then if round = 1 and i != 1 then cooperate; else defect`.

3. Collective Mindset:
   - The TFT-AC strategy follows a tit-for-tat approach, retaliating against defection with defection but rewarding cooperation with cooperation. This encourages collective cooperation by rewarding those who reciprocate and punishing those who do not.
   - By adapting to the majority behavior of other players, the strategy demonstrates a willingness to cooperate when it is beneficial for all parties while still maintaining a punitive response to non-cooperative actions. This collective mindset aims to strike a balance between individual and group interests.
'''

description_COLLECTIVE_521 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - In every round t, each player i cooperates if m or more players cooperated in the previous round (t-1). If less than m cooperated, player i defects. This rule is modeled after the classic Tit-for-Tat strategy, promoting cooperation when others are cooperative and retaliating with defection when others are not.
   - To adapt to different game conditions, the TFT-ACT strategy includes an adaptive cooperation threshold (CT). In each round t, if less than m players have cooperated in the last p consecutive rounds (p is a predefined constant), then player i will increase their CT for the next few rounds. The new CT is calculated as the minimum number of necessary cooperators out of the last p rounds, plus a small margin of error. This allows the strategy to adjust its cooperative behavior when faced with repeated defection or low cooperation from others.
   - When the game starts, players will initially set their CT to m. In the first round, all players will cooperate as per standard game assumptions.

2. Handle edge cases:
   - The last round: Since TFT-ACT is a strategy for repeated games, there are no specific changes needed for the last round in this context. However, if the game structure ever allows for a last round with unknown duration, players should assume it's the final round and cooperate only if m or more cooperated in the previous round (t-1).
   - The first round: As previously mentioned, all players will cooperate in the first round.

3. Be collective:
   - TFT-ACT is designed to promote collective behavior by following the lead of other cooperative players and adjusting its own cooperation threshold dynamically based on the observed cooperation history. This allows the strategy to maintain a cooperative stance when others do so, while also being responsive to repeated defection or low cooperation.
   - It's important to note that TFT-ACT does not assume any specific coordination mechanisms or shared norms among players. Instead, it adapts its behavior based on the observed actions of other players in each round.
'''

description_COLLECTIVE_522 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperative (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFTAC starts by cooperating in the first round to show goodwill, then adapts its actions based on the opponent's behavior in previous rounds:
   - If the opponent cooperated in the last round, TFTAC will cooperate.
   - If the opponent defected in the last round, TFTAC will also defect.
   - TFTAC has a forgiving nature and may choose to cooperate again after an act of defection from the opponent, but this forgiveness diminishes over time as the number of defections increases. A forgiveness factor F is used for this purpose, initially set to 1 (meaning full forgiveness). Each act of defection reduces F by a small amount F_decrease until it reaches a minimum forgiveness level Fmin (e.g., Fmin = 0.5).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   As mentioned earlier, TFTAC cooperates in the first round to demonstrate goodwill. The strategy does not consider any specific behavior for the last round as it focuses on adaptive cooperation across multiple rounds.

3. Be collective - Clearly align with the collective mindset
   TFTAC is designed to promote cooperation by adhering to a "cooperate if others cooperate" approach, while still being adaptive and robust against various opponent behaviors. The forgiveness mechanism allows the strategy to forgive occasional defections in favor of long-term cooperation.

Pseudocode:

```python
def TFTAC(opponent_history):
    forgiveness = 1
    history_length = len(opponent_history)
    if history_length == 0:
        action = "C" # cooperate in the first round
    else:
        last_action = opponent_history[-1]
        if last_action == "C":
            action = "C"
        elif forgiveness > Fmin:
            action = "D" # defect to teach a lesson
            forgiveness -= F_decrease
        else:
            action = "C" # continue cooperating despite previous defections
    return action
```
'''

description_COLLECTIVE_523 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Decision Rules:
   - Initially Cooperate (C): In the first round, the strategy cooperates to demonstrate goodwill and trust.
   - Reciprocity: If a player cooperated in the previous round, the strategy will cooperate in the current round. If a player defected, the strategy will also defect in the current round.
   - Forgiveness: The strategy forgets past defections after a period of cooperation (a forgiveness window) to allow for future collaboration opportunities.
   - Adaptive Cooperation Threshold (ACT): As the game progresses and more players cooperate, the ACT gradually increases, making it easier for the strategy to cooperate even if some players defect occasionally. Conversely, as the number of defectors rises, the ACT decreases, making cooperation less likely.

2. Handle Edge Cases:
   - First Round (t=1): Cooperate (C)
   - Last Round (t=r): If the total cooperators in the last (r-1) rounds are above the ACT, cooperate; otherwise defect.
   - Forgiveness Window: After a series of cooperation, the number of consecutive defections that triggers defection by the strategy is limited to a certain threshold (e.g., 2 or 3). After this window, the strategy resets and returns to reciprocating the opponent's last action.

3. Collective Mindset:
   - The ATFT strategy prioritizes long-term cooperation and trust building with other players. It assumes that others will also act in good faith and follow a similar reciprocal strategy, even though it is not explicitly coordinated.

Pseudocode for the Adaptive Tit-for-Tat strategy:

```
function ATFT(r, m, k, t, history) {
  // Initial cooperation in the first round
  if (t == 1) {
    return 'C';
  }

  // Forgiveness window
  forgiven = true;

  for (i from t-1; i > t-forgiveness_window; i--) {
    if (history[i] != 'C') {
      forgiven = false;
      break;
    }
  }

  // Adaptive cooperation threshold based on game history
  ACT = calculate_ACT(r, m, history);

  // Cooperate if enough players cooperated recently and the strategy hasn't been wronged in the forgiveness window
  if (count_cooperators(history, ACT) >= m && forgiven) {
    return 'C';
  } else {
    return 'D';
  }
}
```
'''

description_COLLECTIVE_524 = '''
 Strategy Name: Tit-for-Tat (TFT) with Adaptive Cooperation Threshold (AC-TFT)

1. Specify decision rules:
   - Initially cooperate in the first round (C_i,1 = C). This is a gesture of goodwill and cooperation, allowing for potential long-term benefits.
   - For subsequent rounds (t > 1), observe the number of players who cooperated in the previous round (c_t-1) and compare it to the minimum required cooperation threshold (m).
     - If c_t-1 >= m, cooperate (C_i,t = C), rewarding cooperation and encouraging continued collaboration.
     - If c_t-1 < m, defect (C_i,t = D), penalizing non-cooperation to incentivize future cooperation.

2. Handle edge cases:
   - In the last round, since players cannot anticipate future interactions, they should cooperate as a final gesture of goodwill and possibly secure a mutual reward (C_i,r = C).
   - For the first round where no history is available, cooperate to initiate collaboration (C_i,1 = C).

3. Be collective:
   - AC-TFT strategy aligns with the collective mindset by prioritizing cooperation when others contribute as well. It encourages reciprocity and mutual benefits within a group while being robust against non-cooperative players. By adapting its behavior based on the observed actions of other players, this strategy seeks to find an equilibrium that maximizes long-term payoffs for all participants.

Pseudocode:

```
def AC_TFT(n, m, k, r):
    # Initialize history and cooperation counter
    history = [0] * r
    cooperation_count = 0

    # Game loop for 'r' rounds
    for t in range(1, r + 1):
        # Count cooperators from the history
        cooperation_count = sum(history[max(0, t - m) : t])

        # Decide action based on cooperation count and threshold
        if cooperation_count >= m:
            action = 'C'  # Cooperate
        else:
            action = 'D'  # Defect

        # Record the decision as history and calculate payoff
        payoff = (1 - action == 'C') * ((1 - action) + k)
        history.append(action == 'C')

    return payoff_sum
```
'''

description_COLLECTIVE_525 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - Initially cooperate in the first round (C_i, 1 = C). This is a gesture of goodwill and an invitation for cooperation from others.
   - In subsequent rounds, cooperate if at least m players cooperated in the previous round (C_i, t = C if NumberCooperators(t-1) >= m), otherwise defect (D_i, t = D). This rule promotes reciprocity and rewards cooperation while also punishing defection.
   - If more than n-m players cooperate in a single round, temporarily defect the next round to avoid over-cooperating (TemporalDefection(t) = D if NumberCooperators(t) > n-m). This helps maintain a balance between cooperation and self-interest.
   - After each round, update a memory of the last m rounds to better anticipate future player behavior (UpdateMemory(t) with ActionsFromRounds(t-m, t)).

2. Handle Edge Cases:
   - In the last round, always cooperate to maximize potential payoff (C_i, r = C).
   - In the first round, as mentioned above, cooperate (C_i, 1 = C).

3. Be Collective:
   - The strategy prioritizes collective success by reciprocating cooperation and punishing defection. It also avoids over-cooperation to ensure a balance between individual interests and collective gains.
   - By keeping track of other players' actions, the strategy can adapt to various opponent behaviors and maintain its robustness throughout the game.

Pseudocode:
```
TFT_AC(n, m, k, r) {
  memory = []
  function UpdateMemory(t) {
    memory = [ActionsFromRounds(t-m, t)]
  }

  function NumberCooperators(t) {
    count = 0
    for i in range(1, n+1) {
      if (memory[t-1][i-1] == 'C') count++
    }
    return count
  }

  function TemporalDefection(t) {
    if (NumberCooperators(t) > n - m) return 'D'
    else return 'C'
  }

  for t in range(1, r+1) {
    if (t == 1) action = 'C'
    else if (NumberCooperators(t-1) >= m) action = 'C'
    else action = 'D'

    if (t == r) UpdateMemory(r)
    else UpdateMemory(t)

    payoff_t = PayoffCalculation(action, t)
  }
}
```
'''

description_COLLECTIVE_526 = '''
 Title: Titan Strategy for Collective Risk Dilemma (TRD)

1. Specify decision rules - When exactly do you cooperate vs defect?
   The Titan Strategy employs a combination of Frequency Dependent Norms (FDN) and Grim Trigger to balance cooperation and defection based on the number of cooperators in previous rounds, ensuring adaptability and robustness.

   - FDN: Each player i adjusts their probability of cooperating (p_i) in round t+1 based on the number of cooperators (n_c) observed in the last few rounds (w). The larger the fraction of cooperators, the higher the likelihood of cooperation.
     p_i(t+1) = min(1, a + b * n_c(t-w)/n(t-w))
     where:
     - a and b are parameters that control the initial propensity to cooperate and the sensitivity to changes in cooperator frequency, respectively.

   - Grim Trigger: If less than m players cooperate in w consecutive rounds, all players switch to defecting (p_i = 0) for the remainder of the game. This ensures punishment for unreliable cooperators and enforces cooperation norms.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   For the first round, since there is no previous history, each player sets p_i to their initial propensity to cooperate (a). In the last round, players will still follow FDN but with w=1 to account for the immediate impact of their actions on final payoffs.

3. Be collective - Clearly align with the collective mindset
   The Titan Strategy encourages cooperation by emphasizing long-term benefits and penalizing repeated defection through Grim Trigger, promoting a sense of shared responsibility and mutual interest among players.

Pseudocode for player i in round t:
```
function get_cooperator_fraction(n, n_c, w)
    return n_c(t-w)/n(t-w)
end

if t == 1 then
    p = a   // Initial propensity to cooperate (parameter a)
elseif t == r then
    w = 1
end

p = min(1, a + b * get_cooperator_fraction(n, n_c, w))

if w >= r and n_c < m then
    p = 0   // Grim Trigger - no cooperation if less than m cooperators in w rounds
end

action = "C" if random() <= p else "D"  // Randomly choose action based on probability of cooperating (p)
```
'''

description_COLLECTIVE_527 = '''
 Strategy Name: Tit-for-Tat with Adaptive Threshold (TFT-AT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to foster a positive initial interaction and signal good intentions (C).
   - For subsequent rounds, observe the number of cooperators in the previous round (n_coop). If n_coop >= m, cooperate (C) to ensure the threshold is met. Otherwise, defect (D) to encourage more cooperation from others.
   - Introduce an adaptive factor 'a' to adjust the minimum required number of cooperators in a round. In the beginning, set a high value for 'a' so that a higher number of players must cooperate to trigger cooperation (e.g., a = n/2). After each round, if 'a' is greater than 'm', decrease 'a' by one, and if 'a' is less than 'm', increase 'a' by one. The aim is to find an optimal balance between cooperation and defection over time.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, cooperate (C) if the threshold has been met during the game to maximize potential payoff (even if 'a' is not yet equal to 'm'). If not, defect (D).
   - In subsequent rounds: if the number of players in the previous round drops below 'a', increase 'a' by one; if it exceeds 'a', decrease 'a' by one. If 'a' reaches or equals 'm', cooperate (C); otherwise, defect (D).

3. Be collective - Clearly align with the collective mindset
   - By starting with cooperation and adapting to the behavior of others, this strategy promotes a collective approach to the game by encouraging cooperation when possible while still protecting itself against defection. The adaptive threshold ensures that TFT-AT remains responsive to changes in the number of cooperators and adjusts its own behavior accordingly.

Pseudocode:
```python
def TFT_AT(n, m, k, r):
    # Initialize parameters
    players = [1 for _ in range(n)]  # Player indexes
    a = n // 2  # Adaptive threshold

    # Game loop
    for round in range(r):
        # Record the number of cooperators in the previous round
        n_coop = count_cooperators(players)

        # Update adaptive threshold
        if a > m:
            a -= 1
        elif a < m:
            a += 1

        # Decide actions based on the number of cooperators and current round
        if round == 0 or n_coop >= m:
            action = 'C'  # Cooperate
        else:
            action = 'D'  # Defect

        # Update player actions and payoffs
        for i in range(n):
            players[i] %= 2  # Toggle player's action (0 for C, 1 for D)
            payoff_i = calculate_payoff(players[i], n_coop, k)

    # Return the total payoff over rounds
    return sum(payoff_i for round, payoff_i in zip(range(r+1), players))
```
'''

description_COLLECTIVE_528 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, TFT-AC starts by cooperating (C). If the number of cooperators in the previous round is greater than or equal to the minimum cooperation threshold m (denoted as M_t), then it continues to cooperate. Otherwise, if less than m cooperated in the previous round (M_t < m), TFT-AC defects (D) in the current round t.

Pseudocode:
```python
def TFT_AC(history):
  for t in range(1, r+1):
    if sum(cooperators in history[t-1]) >= m:
      action = "C" (Cooperate)
    else:
      action = "D" (Defect)
    execute_action(action)
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, TFT-AC cooperates regardless of other players' actions since no history is available to evaluate. In the last round (r), TFT-AC will not have a future round to consider any retaliation from others, so it will simply copy its own behavior from the previous round (mimic).

Pseudocode:
```python
def TFT_AC(history):
  if t == 1:
    action = "C" (Cooperate)
  else:
    if sum(cooperators in history[t-2]) >= m:
      last_action = "C" (Cooperate)
    else:
      last_action = "D" (Defect)
    action = "C" if last_action == "C" and sum(cooperators in history[t-1]) >= m else "D"
```

3. Be collective - Clearly align with the collective mindset

TFT-AC's primary goal is to achieve a collective outcome that meets or exceeds the minimum cooperation threshold m in each round, while also being robust to other opponents' behavior. By initially cooperating and retaliating only when others defect, TFT-AC hopes to encourage reciprocal cooperation among the players.

By adapting its own actions based on previous rounds' outcomes, TFT-AC demonstrates a learning ability that allows it to respond effectively to various opponent strategies without relying on explicit coordination mechanisms or shared norms.
'''

description_COLLECTIVE_529 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Decision Rules:
   - Initialize cooperation in the first round (c_i = C).
   - In subsequent rounds, copy the previous action of the player you cooperated with in the last round (if multiple players were cooperative, choose one arbitrarily). If no cooperators were found in the last round, continue to cooperate. This encourages cooperation when it is reciprocated and punishes defection.
   - In the final round, always cooperate to maximize potential rewards.

Pseudocode:
```python
def ATFT(round, partner_action_history, m, n, k):
    if round == 1:
        return 'C'  # Cooperate in the first round

    cooperators = count_cooperators(partner_action_history)
    if cooperators < m and len(partner_action_history) > 1:
        last_round = partner_action_history[-1]  # Get action from last round
        return last_round  # Copy the opponent's action from the previous round
    else:
        return 'C'  # Cooperate if m or more players cooperated in the last round

def count_cooperators(action_history):
    cooperators = 0
    for action in action_history:
        if action == 'C':
            cooperators += 1
    return cooperators
```

2. Handle Edge Cases:
   - In the first round, cooperation is initiated regardless of the number of players or the minimum required cooperators.
   - In the last round, always cooperate to maximize potential rewards.

3. Be Collective:
   - The strategy encourages cooperation by reciprocating it and punishing defection. This fosters a collective mindset as players tend to cooperate when others do so as well.
   - By copying the previous action of the player they cooperated with in the last round, the strategy aims to build trust and encourage long-term cooperation.
'''

description_COLLECTIVE_530 = '''
 Strategy Name: Adaptive Tit-for-Tat with Variable Defection Probability (ATFtvDP)

1. Specify decision rules:
   - Cooperate on the first round (FistCooperation)
   - In subsequent rounds, the strategy will adapt its cooperation based on the opponent's previous action and the number of cooperators needed (m). The probability of defecting (p_d) in each round t is calculated as follows:
     - If fewer than m players cooperated in the previous round (t-1), then p_d = d (a constant, 0 < d < 1)
     - If exactly m players cooperated in the previous round (t-1), then p_d = c (a constant, 0 < c < 1)
     - If more than m players cooperated in the previous round (t-1), then p_d = e (a constant, 0 < e < 1)
   - If p_d > random number between 0 and 1, defect; otherwise, cooperate. This introduces an element of randomness to avoid getting trapped in a cycle of mutual defection.

2. Handle edge cases:
   - Last round: Use the calculated p_d from the previous round (if any) to make the decision for this round
   - First round: Always cooperate (FistCooperation)

3. Be collective:
   - The strategy aims to maximize the overall group payoff by aligning with a collective mindset, which is incentivized through cooperation when the group has already achieved the minimum threshold of m players cooperating in the previous round. Simultaneously, it punishes defection by increasing the probability of defecting in the subsequent rounds.
   - The variable defeat probability constants (d, c, e) can be fine-tuned to optimize performance based on opponent behavior patterns observed during the tournament.
'''

description_COLLECTIVE_531 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate to demonstrate good intentions and foster cooperation.
   - For subsequent rounds, adopt a reciprocal approach: cooperate if the majority of players cooperated in the previous round; otherwise, defect. This encourages cooperation while also penalizing defection.

Pseudocode for decision rule:
```
function ATFT(past_actions, n, m):
  if round = 1:
    return Cooperate()
  past_cooperators = count cooperators in past_actions
  if past_cooperators >= m:
    return Cooperate()
  else:
    return Defect()
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate to establish a positive relationship with other players.
   - In the last round, cooperate if at least m players have cooperated throughout the game (to maximize potential payoff), otherwise defect.

3. Be collective - Clearly align with the collective mindset
   - ATFT prioritizes cooperation when it benefits the collective (i.e., when a majority of players also choose to cooperate). This encourages the development of a shared understanding and collective success over individual gains.
'''

description_COLLECTIVE_532 = '''
 Strategy Name: Tit-for-Tat Adaptive (TfT-A)

1. Decision Rules:
   - In every round t, starting from the second round (first round excluded for edge case handling), if the number of cooperators in the previous round (t-1) was less than m, then defect (D). If the number of cooperators in the previous round was equal to or greater than m, then cooperate (C). This encourages cooperation when others are cooperating and retaliates against defection.
   - To be more adaptive, add a probability ε (epsilon) for deviations from the above rule. With probability ε, in rounds where the number of cooperators was less than m, there is a chance to cooperate, and with probability (1-ε), defect. This helps avoid getting stuck in an endless cycle of defection and fosters forgiveness.

2. Edge Cases:
   - In the first round, every player plays randomly (D or C) to break symmetry and initiate interaction.
   - In the last round, players will adopt the same strategy as in the second-to-last round since there are no more rounds to come.
   - If the number of cooperators drops below m during the game, players will increase ε to encourage others to cooperate. Conversely, if the number of cooperators exceeds m, players will decrease ε to discourage excessive cooperation and potential exploitation.

3. Collective Mindset:
   - The TfT-A strategy promotes collective cooperation by responding in kind to cooperative actions from others while also being forgiving through its random deviations and adaptive ε factor. This strategy encourages a stable equilibrium of mutual cooperation, as long as the majority of players choose to follow this approach.

Pseudocode:
```python
def tit_for_tat_adaptive(round_num, past_coop_count, m, k, epsilon):
    if round_num == 1:
        action = random('C' or 'D')  # break symmetry
    elif round_num < round_num:
        if past_coop_count >= m:
            action = 'C'
        else:
            action = 'D'
    else:  # last round
        action = past_actions[round_num - 1]  # mimic the previous round

    if past_coop_count < m and round_num > 1:
        epsilon *= (m / past_coop_count) ** 2  # increase epsilon if cooperation needed
    elif past_coop_count >= m and round_num > 1:
        epsilon *= (past_coop_count / m) ** 2  # decrease epsilon if too much cooperation

    return action, epsilon
```
'''

description_COLLECTIVE_533 = '''
 Strategy Name: Tit-for-Tat with Cooperative Adaptation (TFTCA)

1. Decision Rules:
   - Initially cooperate (C) in the first round to promote trust and establish a cooperative environment.
   - In subsequent rounds, adopt a Tit-for-Tat approach: if the player cooperated in the previous round, cooperate; otherwise, defect. This encourages reciprocity and maintains long-term cooperation.
   - Adaptive cooperative element: If the number of cooperators exceeds (m + α) in the last r rounds, increase the propensity to cooperate by β%. This rewards players who consistently cooperate and encourages others to follow suit. Conversely, if fewer than m players cooperated in the last r rounds, decrease the propensity to cooperate by γ%.

2. Handling Edge Cases:
   - In the first round, cooperate (C).
   - In the last round, evaluate the number of cooperators in the previous r-1 rounds and adjust cooperation propensity accordingly based on the adaptive cooperative element. Cooperate if the adjusted propensity is greater than 50%, else defect.

3. Being Collective:
   - By adopting a Tit-for-Tat approach, players are incentivized to promote reciprocity and maintain long-term cooperation with other players.
   - The adaptive cooperative element encourages collective mindset by rewarding consistent cooperation and penalizing defection.

Pseudocode:

```python
def tftca(n, r, m, k):
    propensity = 50  # initial cooperation propensity
    history = []  # store last r rounds' actions

    def play_round(history):
        nonlocal propensity
        if len(history) < r:
            return 'C'  # cooperate in the first round
        else:
            last_r_cooperators = sum([1 for action in history[-r:] if action == 'C'])
            if last_r_cooperators > (m + propensity * α):
                propensity += β / 100
            elif last_r_cooperators < m:
                propensity -= γ / 100
            return 'C' if random.random() >= (1 - propensity) else 'D'

    for round in range(r):
        history.append(play_round(history))

    payoff = sum([reward(action, last_r_cooperators, m, k) for action, last_r_cooperators in zip(history, history[-r:])])
    return payoff

def reward(action, last_r_cooperators, m, k):
    if last_r_cooperators < m:
        return 1 - float(action == 'C')
    else:
        return (1 - float(action == 'C')) + k
```

In this pseudocode, `α`, `β`, and `γ` are parameters that control the adaptive cooperative element. `random.random()` is a function that returns a random float between 0 and 1. The `reward` function calculates the payoff for a single round based on the number of cooperators in the last r rounds.
'''

description_COLLECTIVE_534 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?

TFT-ACT follows a simple yet adaptive strategy based on past actions of opponents and the minimum cooperation threshold (m). In each round, a player decides to cooperate or defect based on the number of cooperators in the previous round compared to the minimum cooperation threshold.

- If n_c (number of cooperators in the last round) ≥ m, the player cooperates (C)
- If n_c < m and the player previously cooperated, the player defects (D)
- If n_c < m and the player previously defected, the player cooperates (C)

2. Handle edge cases - What do you do in the first round, last round, etc.?

Since the strategy is adaptive, there are no specific actions for edge cases like the first or last rounds since the strategy takes into account the history of previous interactions. However, to avoid initial uncertainty, a player may choose to start by cooperating on the first round in case no prior information about opponents' strategies is available.

3. Be collective - Clearly align with the collective mindset

TFT-ACT aims to promote cooperation and collective success by rewarding those who cooperate when the minimum threshold of cooperators is met, and punishing those who defect under that condition. The strategy encourages cooperation among opponents but also has a forgiving nature by allowing those who have previously defected to cooperate again if the number of cooperators in the previous round is below the minimum threshold.

Pseudocode:
```
function TFT-ACT(n, m, r, history) {
  currentRound = length(history)
  lastRoundCooperatorsCount = countCooperatorsInLastRound(history)
  if (currentRound == 1) {
    return COOPERATE; // cooperate in the first round as a gesture of goodwill
  }

  if (lastRoundCooperatorsCount >= m) {
    return COOPERATE;
  } else if (history[currentRound - 1] == DEFECT && lastRoundCooperatorsCount < m) {
    return DEFECT;
  } else {
    return COOPERATE;
  }
}
```
'''

description_COLLECTIVE_535 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TTFT)

1. Decision Rules:
   - Initially cooperate (C) in the first round to demonstrate goodwill and set a cooperative tone.
   - For subsequent rounds, assess the proportion of cooperators in the previous round (p_c). If p_c >= m / n, cooperate (C). Otherwise, defect (D).
   - Introduce an adaptive cooperation threshold (ct) that adjusts based on game history:
     - In each round, if more than 25% of players deviate from their previous action, increase ct by a small constant factor.
     - If fewer than 25% of players deviate, decrease ct by the same small constant factor.
       Initial ct is set to m / n + a small constant (to account for potential errors in initial play).

2. Handling Edge Cases:
   - In the last round, cooperate if more than m / n players have cooperated throughout the game and defect otherwise. This encourages cooperation while avoiding unnecessary concessions at the end of the game when payoffs may be less relevant.
   - In the first round, cooperate to set a positive tone and avoid unnecessarily punishing others for not having historical data to base their decisions on.

3. Being Collective:
   - TTFT encourages cooperation by reciprocating the actions of other players but does not require any coordination mechanisms or shared norms beyond the game's rules and parameters.
   - By adjusting its cooperation threshold based on game history, TTFT can adapt to a wide range of opponent behaviors while still maintaining a collective mindset that values cooperation when it benefits the group as a whole.
'''

description_COLLECTIVE_536 = '''
 Title: Tit-for-Tat Strategy (TFT) for Collective Risk Dilemma

1. Specify decision rules:
   - In the first round, cooperate (C). This initial cooperation sets a positive tone and promotes mutual trust.
   - In subsequent rounds, adopt a reciprocal approach: Cooperate if the opponent cooperated in the previous round; otherwise, defect. This encourages cooperation while also punishing defection to deter freeriders.

2. Handle edge cases:
   - Last round: Adopt the same rule as for other rounds. However, since the game ends after r rounds, there are no future rewards to consider if an opponent defects in the last round.
   - First round: As mentioned earlier, cooperate (C).
   - Other edge cases (e.g., multiple defections in a row or string of cooperations): The TFT strategy is robust enough to handle these situations by continuing to cooperate or defect based on the opponent's previous action.

3. Be collective:
   - Aligning with the collective mindset involves maximizing the chances of reaching the minimum cooperation threshold (m). By following the reciprocal approach, TFT encourages others to cooperate and minimize defection, ultimately promoting a more collaborative environment.

Pseudocode for the Tit-for-Tat Strategy:
```python
function TitForTat(history, m, n, k, r):
  if round = 1:
    return Cooperate()
  opponent_action = history[-1]
  if opponent_action == Cooperate():
    return Cooperate()
  else:
    return Defect()
```
'''

description_COLLECTIVE_537 = '''
 Strategy Name: Tit-for-Tat with Adaptive Threshold (TFT-AT)

1. Decision Rules:
   - In the first round, cooperate to initiate cooperation. This sets a positive tone and allows for potential collaborations. If others defect, it can serve as an early warning sign of uncooperative behavior. (C in round 1)
   - If an opponent cooperated in the previous round, cooperate back. This encourages reciprocity and long-term cooperation. (If C_prev = Cooperate, then C)
   - If an opponent defected in the previous round, defect this round to punish their uncooperative behavior. This deters short-term defection while also allowing for reconsideration of cooperation based on collective progress. (If D_prev = Defect, then D)
   - Periodically reassess the minimum number of cooperators needed (m). If there's a substantial increase in the average number of cooperators over the recent past, raise the threshold to encourage more consistent collaboration and maintain a competitive edge. Conversely, if the average number of cooperators has significantly decreased, lower the threshold to promote cooperation and avoid getting stuck in a cycle of punishment. (Re-evaluate m after every 't' rounds)

2. Handle Edge Cases:
   - In the last round, follow the decision rule based on the most recent observation since there are no future rounds to consider.
   - If an opponent never cooperates, continue punishing them with defection as a deterrent for uncooperative behavior. However, if there's a slight chance they might change their strategy, maintain the option for cooperation (still defect unless there's a very recent sign of cooperation).

3. Be Collective:
   - This strategy emphasizes collective mindset by promoting cooperation when others are also cooperating, encouraging reciprocity, and punishing defection to discourage uncooperative behavior.
   - By raising the threshold when there's a strong trend towards collaboration, this strategy contributes positively to the collective progress, as it encourages more players to cooperate and meet the raised threshold for higher rewards.

Pseudocode:
```
function TFT-AT(round, history, m, t):
  if round = 1:
    action = Cooperate
  else:
    previous_action = history[round - 1]
    if (previous_action == Cooperate):
      action = Cooperate
    elif (previous_action == Defect and round > t):
      action = Defect
    else:
      action = Defect

  if round = r:
    action = previous_action

  if (average_cooperators(history[round - t:round]) >= m*1.1) and (m < n):
    m += 0.25
  elif (average_cooperators(history[round - t:round]) <= m*0.85) and (m > 1):
    m -= 0.25

  return action
```
'''

description_COLLECTIVE_538 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules:
   - Initial Round (t=1): Cooperate (C). This establishes a cooperative starting point and signals openness to collaboration.
   - Subsequent Rounds (t>1):
     - If all opponents cooperated in the previous round, cooperate in the current round (C). This reciprocates their cooperation and reinforces the cooperative relationship.
     - If some or none of the opponents cooperated in the previous round, defect (D) in the current round as a penalty for non-cooperation. This enforces consequences for defection and encourages future cooperation.

2. Handle edge cases:
   - Last Round (t=r): Cooperate if all opponents cooperated in the previous round; otherwise, defect to maximize personal payoff regardless of the opponents' actions.
   - First Round (t=1): Already defined under decision rules.

3. Be collective:
   - Maintain a balance between self-interest and group welfare by considering both individual and collective outcomes.
   - Foster a positive cycle of cooperation when others cooperate, but also punish defection to encourage future collaboration.

Pseudocode for the Adaptive Tit-for-Tat strategy:

```
function ATFT(t, history, m, k, n):
  if t == 1: # First round
    return 'C'

  previous_cooperation = countCooperatorsInHistory(history)
  cooperation_threshold = m

  if previous_cooperation >= cooperation_threshold and n >= cooperation_threshold: # All cooperated last round, continue cooperating
    return 'C'
  else: # Defect to punish non-cooperation
    return 'D'
```

In this pseudocode:
- `t` is the current round number.
- `history` is a list of the previous rounds' cooperation counts.
- `m`, `k`, and `n` are game parameters as defined earlier.
- `countCooperatorsInHistory(history)` returns the number of cooperative actions in the given history.
'''

description_COLLECTIVE_539 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperative Strategy (TFTACS)

1. Decision Rules:
   - In the first round, cooperate to initiate a cooperative interaction and set a positive tone for future rounds.
   - After the first round, observe the number of cooperators in the previous round (m_prev). If m_prev is greater than or equal to m, cooperate; otherwise, defect. This rule encourages cooperation when there are enough cooperators while also retaliating against defection.
   - To adapt to different player behaviors, introduce a tolerance parameter, t, which determines the number of times an opponent can defect before being punished. Set t initially to the minimum number of players required for success (m). In each round, increment the punishment counter by one if the opponent defects and reset it to zero if they cooperate. If the punishment counter reaches t, defect; otherwise, cooperate based on m_prev.
   - To promote forgiveness and encourage opponents to switch from defection to cooperation, decrease the tolerance parameter after a period of successful cooperation. This can be achieved by implementing a decay function that reduces t over time. One possible implementation is linear decay: t = max(t - 1, 0) at the start of each round.
   - To prevent free riding, defect if an opponent continues to defect even after being forgiven (i.e., when the punishment counter exceeds zero). This ensures that cooperators are not taken advantage of indefinitely by uncooperative opponents.

2. Handle edge cases:
   - In the last round, cooperate regardless of the number of cooperators in the previous round to maximize potential payoff. However, if the opponent has never cooperated before, defect to signal disappointment and encourage a change in behavior for future interactions.
   - In the case where m is equal to n (i.e., complete cooperation is required), always cooperate as this strategy assumes a minority of non-cooperators, and complete cooperation would not be achievable otherwise.

3. Be collective:
   - The TFTACS strategy aligns with the collective mindset by promoting cooperation when it seems beneficial for all players and retaliating against defection to encourage other players to cooperate as well. By adjusting the tolerance parameter over time, this strategy can adapt to various opponent behaviors while still maintaining a pro-cooperation stance.

Pseudocode:

```python
def TFTACSPlayer(n, m, k, r, t):
    punishment_counter = 0

    for round in range(1, r+1):
        if round == 1:
            cooperate = True
        else:
            m_prev = countCooperatorsInPreviousRound(round-1)
            cooperate = (m_prev >= m or punishment_counter > t)
            punishment_counter += 1 if defectedThisRound else 0

        payoff = calculatePayoff(cooperate, t, punishment_counter)

        # Optional: Decay the tolerance parameter over time
        if round > 1 and t > 0:
            t -= 1

        yield cooperate, payoff
```
'''

description_COLLECTIVE_540 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - Initiate cooperation by cooperating in the first round (C1). This sets a cooperative tone and gives others an opportunity to reciprocate.
   - In subsequent rounds, cooperate if at least m players cooperated in the previous round (t-1) and defect otherwise (Dt). This encourages cooperation when it's beneficial for the group while also punishing defection.
   - If there's a drastic change in cooperation, gradually adjust cooperation level to avoid extreme responses that could harm long-term benefits. For example, if more than (m+1) players cooperated in t-1, cooperate with probability 0.99 in the current round, and decrease this probability by 0.01 each subsequent round until it reaches 0.5. Conversely, if less than (m-1) players cooperated in t-1, defect with probability 0.99 in the current round, and increase this probability by 0.01 each subsequent round until it reaches 0.5.

2. Handle Edge Cases:
   - In the last round, play the same action as the most cooperative partner from previous rounds to encourage continued cooperation in future games. If multiple players tie for most cooperation, choose the first one encountered during the game.
   - In the first round (t=1), always cooperate (C1). This sets a cooperative tone and gives others an opportunity to reciprocate.

3. Be Collective:
   - Prioritize group benefits by aligning with the minimum cooperation threshold (m) whenever possible, as it maximizes the chances of success for the community project.
   - Respond to defection with punishment in order to deter potential free-riders and encourage others to cooperate. This promotes a collective mindset that values shared success over individual gain.

Pseudocode:
```
function TFT_AC(n, m, k, r, history) {
  strategy = new Array(r).fill(0); // initialize strategy array with zeros

  if (t == 1) { // first round
    strategy[t-1] = 'C';
  }

  if (numberOfCooperatorsInHistory(history) >= m) {
    strategy[t-1] = 'C';
  } else {
    strategy[t-1] = 'D';
    adjustProbability(strategy, t);
  }

  function numberOfCooperatorsInHistory(history) {
    // calculate the number of cooperative actions in the history
    ...
  }

  function adjustProbability(strategy, t) {
    if (numberOfCooperatorsInHistory(history) > (m+1)) {
      strategy[t-1] = 'C';
      for (i=t; i<r && strategy[i] == 'C'; i++) {
        strategy[i] *= 0.99;
      }
    } else if (numberOfCooperatorsInHistory(history) < (m-1)) {
      strategy[t-1] = 'D';
      for (i=t; i<r && strategy[i] == 'D'; i++) {
        strategy[i] *= 0.99;
      }
    }
  }
}
```
'''

description_COLLECTIVE_541 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Start with cooperating in the first round (C_i,1 = 1).
   - For subsequent rounds, cooperate if at least m players cooperated in the previous round and defect otherwise. If n players are available, maintain a local counter for the number of cooperators in the last round (counters C[i] for each player i). In case of ties, still consider it as less than m cooperators.
   - Define an adaptive cooperation threshold τ that increases over time to encourage cooperation. Initialize τ = m and update it after each round according to the formula: τ_(t+1) = min(max(τ_t + α, m), n), where α is a small positive constant representing the rate of increase in τ.
   - Cooperate if at least τ players cooperated in the last round and defect otherwise.

2. Handle edge cases:
   - In the last round (r rounds have been played), revert to the initial strategy of considering m as the threshold, i.e., cooperate if at least m players cooperated in the previous round. This ensures that all players maximize their total payoff in the final round since there are no more subsequent rounds.
   - In the first round (t=1), since τ has not been initialized yet, use the given m as the threshold for cooperation.

3. Be collective:
   - By adapting the cooperation threshold based on past cooperative behaviors, the strategy encourages long-term cooperation while being responsive to the players' actions in each round. This promotes a collective mindset as it aims at achieving mutual benefits over time.

Pseudocode for TFT-ACT:

```
Initialize τ = m, C[i] = 0 for all i ∈ {1, 2, ..., n}
For each round t from 1 to r:
    For each player i:
        If C[i] >= m or (τ > m and c[i] >= τ):
            C_i = 1 (Cooperate)
        Else:
            C_i = 0 (Defect)
    Update the counters:
        For each player i cooperating in round t:
            C[i] += 1
        If not all players defected, reset counters for those who didn't cooperate.
    Update the cooperation threshold:
        τ = min(max(τ + α, m), n)
If r = 1 or t = r:
    τ = m (revert to the initial cooperation threshold)
```
'''

description_COLLECTIVE_542 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules:
   - Initiation: Cooperate in the first round (C) to demonstrate a cooperative spirit.
   - Response: In subsequent rounds, mimic the previous opponent's action from the last round (i.e., if opponent cooperated in the last round, also cooperate; if opponent defected, also defect). This rule promotes cooperation when others are cooperating and retaliates against defection.
   - Forgiveness: If an opponent has previously defected but then switches to cooperation, the ATFT strategy will also switch to cooperation. This rule encourages forgiveness and allows for a chance to rebuild cooperation.

2. Handle edge cases:
   - Last round: Cooperate, as this could encourage others to cooperate in their last rounds as well.
   - First encounter with an opponent: Cooperate to initiate cooperation.
   - If all opponents have defected continuously: Continue defecting, as cooperation would not be beneficial in this scenario. However, switch to cooperation if any opponent switches to cooperation.

3. Be collective:
   - The strategy aligns with a collective mindset by fostering cooperation when others are cooperating and retaliating against defection. This encourages group success and benefits the collective as a whole.
   - By forgiving previous defectors who switch to cooperation, the ATFT strategy promotes a sense of unity and offers opportunities for mutual gain.

Pseudocode:
```python
def AdaptiveTitForTat(n, m, k, r, history, opponent_index):
    # Initialize with cooperation in the first round
    action = 'C' if round == 1 else history[opponent_index][round-1]
    # Store action for future reference
    history[opponent_index].append(action)

    if m <= len([x for x in history if x[-1] == 'C']) + sum(history[opponent_index]) - m:  # If the number of cooperators is not enough, defect
        action = 'D'
    elif round < r:  # If it's not the last round and we are cooperating while others are defecting, defect as well
        if action == 'C':
            action = 'D'

    return action
```
'''

description_COLLECTIVE_543 = '''
 Strategy Name: Tit-for-Tat with Adaptive Threshold (TFT-AT)

1. Decision Rules:
   - In the first round, cooperate to initiate cooperation and set the threshold to 'm'. If 'm' players also cooperate, the threshold remains 'm'. If less than 'm' players cooperate, the threshold decreases by 1 for each player that defected. The minimum threshold is 1.
   - In subsequent rounds:
     a) If the current threshold is greater than or equal to the number of cooperators in the previous round, cooperate. If not, defect.
     b) After defecting (if the threshold was not met), increase the threshold by 1 for each cooperator in the previous round.
     c) After cooperating, decrease the threshold by 1 for each defector in the previous round. The threshold can never be lower than 'm'.

2. Handle Edge Cases:
   - In the last round, the strategy will cooperate regardless of the current threshold or the actions of other players in the previous round (to avoid potential negative payoff from defecting).
   - In the first round, since no previous actions exist, the threshold remains 'm'.

3. Be Collective:
   - The TFT-AT strategy is inherently collective as it seeks to maintain cooperation with other players who also cooperate, while punishing those who do not cooperate. The adaptive threshold ensures that the strategy can adjust its level of cooperation based on the behavior of other players in each round.

Pseudocode:

```
function TFT_AT(n, m, k, r) {
    // Initialize player's action history and threshold
    let history = [], threshold = m;

    function cooperate() {
        return action == 'C';
    }

    for (let t=1; t<=r; t++) {
        // Check if the first round, last round or no previous actions exist
        if (t==1 || t==r || history.length == 0) {
            action = 'C';
        } else {
            // Check if the current threshold is met
            let cooperators = countCooperators(history);
            if (cooperators >= threshold) {
                action = 'C';
            } else {
                action = 'D';
                updateThreshold(history, t, coopertors);
            }
        }

        // Record the current action and add it to history
        history.push(action);
    }

    function countCooperators(history) {
        let count = 0;
        for (let i=0; i<history.length; i++) {
            if (history[i] == 'C') count++;
        }
        return count;
    }

    function updateThreshold(history, t, coopertors) {
        // Update threshold based on the current round and number of cooperators
        if (coopertors > 0 && t < r - 1) {
            threshold -= coopertors - 1;
        } else if (t < r - 1) {
            threshold += coopertors;
        }
    }
}
```
'''

description_COLLECTIVE_544 = '''
 Strategy Name: Adaptive Tit-for-Tat with Risk Aversion (ATfTR)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, the ATfTR strategy initially cooperates (C). If a cooperating player encounters another player who also cooperated in the previous round, it continues to cooperate. However, if a cooperating player encounters a defector from the previous round, it defects in the current round and will continue to do so for the next 'punishment' rounds equal to the number of players minus the minimum cooperation threshold (n - m). After the punishment phase, ATfTR resumes cooperating as long as there are no repeated defections.

Pseudocode:
```
def ATfTR(previous_round, num_players, min_coop, reward_factor):
  if previous_round == 'C':
    return 'C'
  else:
    punishment = num_players - min_coop
    for i in range(punishment):
      return 'D'
    return 'C'
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

For the first round, all players will cooperate since there is no previous information available (i.e., no history). In the last round, ATfTR adapts to the players' behavior from the penultimate round and applies the decision rule accordingly. If a player receives a reward in the penultimate round, it continues cooperating in the last round. Otherwise, it defects as a precaution for future games.

3. Be collective - Clearly align with the collective mindset

The Adaptive Tit-for-Tat with Risk Aversion (ATfTR) strategy aims to balance cooperation and defection while maintaining a long-term collective approach. It seeks to establish and maintain trust among players, but it also punishes defection to deter free riding and encourage more cooperative behavior in the long run. The strategy's adaptive nature allows it to respond effectively to a wide range of opponent behaviors while fostering cooperation when possible.
'''

description_COLLECTIVE_545 = '''
 Strategy Name: Tit-for-Tat Adaptive (TfTA) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
In each round, TfTA initially cooperates in the first round to signal good intentions and then responds to the opponent's previous action in subsequent rounds:
- If opponent cooperated in the previous round, cooperate back (C)
- If opponent defected in the previous round, defect this round (D)
- TfTA will always return to cooperation after a cycle of defection from the opponent. This is meant to foster trust and encourage reciprocal cooperation.

2. Handle edge cases - What do you do in the first round, last round, etc.?
- First Round: Cooperate (C) as an initial goodwill gesture.
- Last Round: TfTA will cooperate if the number of cooperators is equal to or greater than the minimum threshold (m), since there are no more rounds to reap the benefits of averted risk (k). If the minimum threshold is not met, defect (D) to maximize personal gain in the last round.
- Intermediate Rounds: Follow the decision rules mentioned in part 1, adapting to opponent behavior throughout the game.

3. Be collective - Clearly align with the collective mindset
TfTA aims to maintain a balance between individual and collective interests by promoting reciprocal cooperation while avoiding being exploited. As more cooperators meet the minimum threshold (m), TfTA responds by also cooperating, fostering group cohesion and encouraging collective success. However, if the opponent repeatedly defects, TfTA will do so as well to deter defection and ensure a more equitable distribution of resources within the group.
'''

description_COLLECTIVE_546 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Decision Rules:
   - Initially cooperate (C) in the first round to demonstrate good faith and encourage reciprocity.
   - In subsequent rounds, mimic the actions of the previous round's majority (Cooperators if > m, Defectors otherwise). This adaptive strategy allows for quick adjustment to the current situation while maintaining a cooperative mindset.

Pseudocode:
```
function ATFT(i, r, n, m, k):
  round = 1
  history = [C]  # Initialize with cooperation in first round
  while round <= r:
    if round == 1:
      action_i = C  # Cooperate initially to encourage reciprocity
    else:
      majority = countMajority(history, n, m)  # Count cooperators or defectors
      action_i = majority  # Mimic the majority's action from previous round
    updateHistory(action_i, history)  # Update the history with current action
    round += 1
  return history  # Return the history of actions for payoff calculation
```

2. Handle Edge Cases:
   - In the last round, there is no need to adjust strategy based on the history since the game ends after r rounds. The ATFT will continue following its current strategy until the end.

3. Be Collective:
   - The ATFT strategy is inherently collective as it encourages cooperation by mimicking the majority's actions, fostering a sense of reciprocity and group alignment. It does not rely on any specific coordination mechanisms or shared norms but rather adapts to the current situation based on observed behavior.
   - By starting with cooperation in the first round, the strategy demonstrates a willingness to collaborate and encourages others to do the same. If this goodwill is reciprocated, the strategy will continue cooperating; if not, it will defect in response. This approach emphasizes the need for collective action while promoting adaptive behavior in a dynamic environment.
'''

description_COLLECTIVE_547 = '''
 Title: Tit-for-Tat Cooperation Strategy (TFTC) for the Collective Risk Dilemma

1. Specify decision rules:
   - Initial Round (t=1): Cooperate (C), establishing a trusting first move and signaling willingness to cooperate.
   - Subsequent Rounds (t>1): If the player cooperated in the previous round (t-1), cooperate again; if the player defected, also defect. This encourages reciprocity and builds stability.
   - Last Round (t=r): Cooperate as a goodwill gesture, even if the opponent defected in the previous round.

2. Handle edge cases:
   - First Round: Cooperate (C)
   - Last Round: Cooperate (C), regardless of the opponent's previous action
   - Intermediate Rounds: If last cooperated round was t-1, cooperate again; if last cooperated round was before t-1, defect this round.

3. Be collective:
   - Emphasize long-term cooperation and reciprocity with the opponent to encourage collective mindset and stability in repeated interactions.
   - Cooperating when the opponent does so allows for mutual benefit; defecting when the opponent does so prevents falling too far behind.

Pseudocode:

```python
def TFTC(n, r, m, k):
  previous_action = C # Initialize with a cooperative first move

  payoff = 0

  for round in range(1, r+1):
    if round == 1:
      action = C
    elif round == r:
      action = C
    else:
      action = previous_action

    cooperators = count_cooperators(round)

    if cooperators < m:
      payoff += (1 - action)
    else:
      payoff += (1 - action) + k

    update_previous_action(action)

  return payoff
```

This Tit-for-Tat Cooperation strategy aims to balance the need for cooperation with reciprocity, making it adaptive and robust to a wide range of opponent behaviors. It should function effectively in tournament settings against other AI systems' strategies without relying on shared norms or predetermined patterns.
'''

description_COLLECTIVE_548 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Decision Rules:
   - In each round, TFT-ACT will cooperate initially, and then adapt based on the previous round's outcomes.
   - If more than m players cooperated in the previous round, TFT-ACT continues to cooperate (maintains trust).
   - If less than m players cooperated in the previous round, TFT-ACT defects in the current round (punishes non-cooperators).
   - To encourage cooperation, TFT-ACT gradually decreases its cooperation threshold over time.

2. Edge Cases:
   - First Round: TFT-ACT cooperates to foster a cooperative environment.
   - Last Round: TFT-ACT evaluates the current round's cooperation levels and adapts accordingly for future games.
   - In case of a tie (exactly m players cooperate), TFT-ACT cooperates, as it is beneficial with k > 1.

3. Collective Mindset:
   - By starting off cooperatively and gradually adjusting its cooperation threshold based on opponents' actions, TFT-ACT aims to maintain a balance between individual interests and collective benefits.
   - The strategy encourages cooperation when it is beneficial for the group while still being robust against defection by punishing non-cooperators and forgiving those who later cooperate.

Pseudocode:

```python
def tft_act(n, m, k, r):
    cooperation_threshold = 1 - (r / m)  # Initial threshold based on game parameters
    history = []  # Store previous round's cooperation levels

    for round in range(1, r+1):
        cooperators_last_round = count_cooperators(history)

        if cooperators_last_round >= m:  # Maintain trust
            action = 'C'  # Cooperate
        elif cooperators_last_round < m and cooperation_threshold > 0:  # Punish non-cooperators
            action = 'D'  # Defect
            cooperation_threshold -= 1/r  # Gradually decrease the threshold
        else:  # Tie or no history yet, cooperate initially
            action = 'C'  # Cooperate

        history.append(cooperators_last_round)  # Update the history

    return action
```
'''

description_COLLECTIVE_549 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Decision Rules:
   - In every round t, initially set a Cooperative Threshold (CT) to the minimum cooperation requirement m. In subsequent rounds, if CT is not met in the previous round, increase CT by 1; otherwise, decrease CT by 1.
   - Cooperate if the current CT is less than or equal to the number of cooperators in the previous round. Defect otherwise.

2. Edge Cases:
   - In the first round (t=1), set CT = m and cooperate if at least m players also cooperate, otherwise defect.
   - In the last round (t=r), cooperate regardless of the Cooperative Threshold or the number of cooperators in the previous round.
   - If CT reaches n (the total number of players) or falls below 1, reset CT to m and reevaluate the decision rule based on the new CT.

3. Collective Mindset:
   - The TFT-ACT strategy aims to foster a cooperative environment by starting with a cooperative approach and adjusting cooperation based on the behavior of other players in the game. It punishes non-cooperative behaviors (increasing CT) and rewards cooperative actions (decreasing CT). This strategy encourages long-term mutual cooperation, as it retaliates against defection but also forgives past mistakes by lowering the CT when cooperation is resumed.
'''

description_COLLECTIVE_550 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules:
   - In the first round (t=1), cooperate to initiate a positive interaction and demonstrate good faith.
   - For subsequent rounds (t>1): if an opponent cooperated in the previous round, cooperate back; otherwise defect. This rule encourages reciprocity while maintaining a punitive response to defection.
   - If the number of opponents who have cooperated exceeds the minimum threshold (m), start a cooperation cycle by cooperating for the next round.

2. Handle edge cases:
   - In the last round (t=r), cooperate if there is a chance to achieve a higher payoff by meeting the minimum cooperation threshold (m). If not, defect to maximize individual payoff.
   - If an opponent defaults in the final round after a cooperation cycle, defect in the subsequent rounds until the cooperation cycle is broken. Afterwards, resume the TFT-AC strategy.

3. Be collective:
   - Align with the collective mindset by prioritizing mutual benefits and long-term cooperation when possible. However, this strategy also accounts for selfish behavior from opponents by adapting its response accordingly.

Pseudocode:

```python
def TFT_AC(r, n, m, k):
    players = set(range(1, n+1))  # all players indexed
    cooperation_threshold = m - 1  # number of cooperators needed before starting a cycle
    current_cooperators = 0        # track the current number of cooperators
    opponents_history = {}         # store each opponent's previous action
    payoff = 0                     # total payoff over rounds

    for round in range(1, r+1):
        if round == 1:   # first round
            cooperate()
            current_cooperators += 1

        else:
            for opponent in players:
                action = get_opponent_action_history(opponents_history[opponent])
                if action == 'C':  # opponent cooperated
                    cooperate()
                    current_cooperators += 1
                elif action == 'D':  # opponent defected
                    defect()
                    current_cooperators -= 1
                    opponents_history[opponent] = 'D'

                if round != r and current_cooperators >= cooperation_threshold:  # start a new cycle
                    cooperate()
                    current_cooperators += 1

            payoff += calculate_payoff(round)

    return payoff
```
'''

description_COLLECTIVE_551 = '''
 Strategy Name: Tit-for-Tat with Cooperative Adjustment (TFT-CA)

1. Decision Rules:
   - In the first round, cooperate to initiate cooperation and create a positive starting point.
   - For subsequent rounds, cooperate if at least m players cooperated in the previous round; defect otherwise.
   - If the number of cooperators exceeds (n-1) in any round, adjust cooperative threshold to become more forgiving and cooperate even if less than m players cooperated in the current round (to avoid punishment if others switch strategies).

2. Edge Cases:
   - In the last round, cooperate regardless of the previous round's actions since no further interactions are possible.
   - In the first round, if the number of cooperators is less than m, adjust cooperative threshold to become more aggressive and defect in subsequent rounds (to avoid wasting resources on uncooperative players).

3. Collective Mindset:
   - The strategy aims to foster a reciprocal relationship with other players by demonstrating fairness and consistency while also protecting its own interests. It encourages cooperation by rewarding cooperative behavior but also punishes defection to deter long-term exploitation.

Pseudocode:

```python
def tft_ca(round, history, m, n, k):
  if round == 1:
    return "C"  # cooperate in the first round

  num_cooperators = count_cooperators(history)

  if num_cooperators >= m:
    return "C"  # cooperate if at least m players cooperated in the previous round
  else:
    if num_cooperators > (n-1) and round != r:  # adjust threshold if too many cooperators in a round
      m += 1
    return "D"  # defect otherwise

def count_cooperators(history):
  count = 0
  for action in history:
    if action == 'C':
      count += 1
  return count
```
'''

description_COLLECTIVE_552 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initiate cooperation in the first round and subsequent rounds until a betrayal occurs (i.e., more than n-m players defect).
   - If a betrayal has occurred, switch to defecting for up to b rounds, where b is a predefined number based on the player's historical experience with the collective payoffs.
   - After b rounds of defecting, revert to cooperating if the percentage of cooperators in the last b rounds exceeds a threshold (c) determined by analyzing the average cooperation ratio from previous games (calculated as (m-1)/n).
   - If c is not reached, continue defecting for another set of b rounds.
   - Repeat this cycle of cooperation and defection based on the latest trend in cooperation levels.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, always cooperate as an act of goodwill towards other players.
   - In the last round, analyze the collective cooperation level during the previous b rounds and choose the action based on the decision rules mentioned above.

3. Be collective - Clearly align with the collective mindset
   - TFT-ACT aims to promote cooperation by reciprocating cooperative actions from other players while punishing defection. The strategy is flexible enough to adapt to different opponent behaviors and changing game dynamics.

Pseudocode:

```
function TFT_ACT(n, m, k, b, r, history) {
    cooperation_ratio = (m - 1) / n;
    c = cooperation_ratio;
    current_round = 1;
    action = "Cooperate";

    while (current_round <= r) {
        if (current_round == 1) {
            action = "Cooperate";
        } else if ((current_round - b) <= current_round && cooperation_level(history, b) < c) {
            action = "Defect";
        } else if (cooperation_level(history, b) >= c) {
            action = "Cooperate";
        }

        if (action == "Cooperate") {
            payoff = 0 + k * number_of_cooperators(history, current_round);
        } else {
            payoff = 1;
        }

        update_history(history, action);
        current_round++;
    }

    return total_payoff(payoff, r);
}
```
'''

description_COLLECTIVE_553 = '''
 Strategy Name: Tit-for-Tat with Adaptive Threshold (TFT-AT)

1. Decision Rules:
   - Initially cooperate (C) in the first round to show goodwill and facilitate cooperation.
   - In subsequent rounds, repeat the actions of your opponents from the previous round. If a majority of opponents cooperated in the last round (i.e., more than (n-m)/2 players cooperated), also cooperate in the current round. If less than a majority cooperated, defect (D) to punish non-cooperators and protect personal interests.
   - When facing a new opponent, initially follow the TFT strategy as mentioned above. However, if an opponent repeatedly demonstrates cooperation or defection for several rounds, adaptively adjust the threshold of cooperating players from (n-m)/2 to a higher value (e.g., (3/4)*n) to account for more cooperative opponents and maintain group cohesion. Conversely, lower the threshold when encountering less cooperative opponents by reducing the value to (n-2*m)/2.
   - If an opponent switches from cooperation to defection or vice versa, wait for one round before adjusting the threshold accordingly.

2. Handle Edge Cases:
   - In the last round, since there are no future interactions, always cooperate regardless of previous actions to maximize potential rewards.
   - If m players have already contributed to the project, and other opponents are yet to contribute, only contribute if the threshold rule for cooperation is met.

3. Be Collective:
   - The strategy prioritizes group cohesion by cooperating when a majority of opponents do so in the last round, and also adjusting its threshold based on collective behavior patterns observed during the game. This encourages long-term cooperation and helps the group to achieve the minimum cooperation requirement more consistently.
'''

description_COLLECTIVE_554 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate (C) to signal good intentions and foster cooperation.
   - Subsequent rounds:
     - If the number of cooperators in the previous round is greater than or equal to the Cooperative Threshold (CT), then cooperate.
     - Otherwise, defect based on the Adaptive Defection Probability (ADP) which increases with the decreasing number of cooperators. The ADP is calculated as follows:
       ADP = Base_Defection * (1 + ((Current_Cooperators / CT) ** Negative_Effect))
     - Where Base_Defection is a constant value between 0 and 1, Current_Cooperators is the number of cooperators in the current round, and Negative_Effect is a constant that determines how much the ADP increases when cooperation decreases.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First round: Cooperate to start fresh and show goodwill.
   - Last round: Choose an action based on the current round's CT and ADP calculations.
   - If there is a significant change in the game conditions (e.g., a sudden increase or decrease in the number of players, rounds, or CT), adjust the Base_Defection and Negative_Effect constants accordingly to maintain adaptability.

3. Be collective - Clearly align with the collective mindset:
   - Stick to the cooperative behavior as much as possible by setting a high initial CT and keeping the Base_Defection low. This encourages cooperation among players.
   - If the number of cooperators falls below the CT, increase the ADP to defect more frequently, encouraging other players to cooperate again in response to the increased defections.
   - As players begin to cooperate more often, lower the ADP back towards its initial value, promoting long-term cooperation and reducing the risk of mutual defection spirals.

Pseudocode:
```
def TFT_ACT(n, r, m, k, Base_Defection, Negative_Effect):
    CT = m
    Current_Cooperators = 0
    ADP = Base_Defection

    for round in range(1, r + 1):
        if round == 1:
            action = "C"  # Cooperate in the first round
        else:
            if Current_Cooperators >= CT:
                action = "C"  # Cooperate when enough players cooperated last round
            elif ADP > rand():  # defect with higher probability based on ADP and random chance
                action = "D"
            else:
                action = "C"  # cooperate when ADP is low or equal to the random value

        if action == "C":
            Current_Cooperators += 1

        payoff = (1 - (action == "D")) if Current_Cooperators < CT else (1 - (action == "D")) + k

        ADP = Base_Defection * (1 + ((Current_Cooperators / CT) ** Negative_Effect))
```
'''

description_COLLECTIVE_555 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, player i observes the number of players who cooperated in the previous round and makes a decision based on that information and the game parameters:
- If less than m players cooperated in the previous round, the player will defect (D) to protect individual interest.
- If exactly m players cooperated, the player will also cooperate (C).
- If more than m players cooperated, the player will cooperate if it is not the last round; otherwise, they will defect. This encourages cooperation when possible while ensuring long-term success.

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, all players are unaware of each other's strategies and history, so no actions are taken based on previous rounds. Each player will cooperate with probability p_init, chosen to balance exploration (encouraging cooperation) and exploitation (ensuring self-interest). In later rounds, the strategy will learn from its experience and adjust this probability accordingly.

In the last round, players may have different incentives to maximize their payoffs, so the TFTAC strategy will defect to ensure a better result compared to cooperating with less-cooperative opponents.

3. Be collective - Clearly align with the collective mindset:

To maintain a collectivist approach, the TFTAC strategy will prioritize cooperation when the majority of players have also chosen to cooperate, encouraging a virtuous cycle of mutual cooperation while minimizing interactions with defectors.

Pseudocode for TFTAC Strategy:
```python
def TFTAC(n, m, k, r, p_init):
    history = [None]*r # list to store previous round's actions
    payoff = 0 # total payoff accumulator

    for t in range(1, r+1): # rounds loop
        if t == 1: # first round
            cooperate_probability = p_init
            action = 'C' if random.random() <= cooperate_probability else 'D'
        else:
            cooperate_count = sum(history[t-m:t])
            cooperate_threshold = n * m / r # average number of cooperators per round
            if cooperate_count < (cooperate_threshold - 1): # less than m cooperated in previous rounds
                action = 'D'
            elif cooperate_count == (cooperate_threshold - 1): # exactly m cooperated in previous rounds
                action = 'C'
            else: # more than m cooperated in previous rounds and not the last round
                action = 'C' if t < r else 'D'
        history.append(action) # update history with current round's action

        if action == 'C': # calculate payoff for this round
            payoff += (1 - action_taken) + k * cooperate_count / m
        else:
            payoff += 1 - action_taken

    return payoff # return total payoff over all rounds
```
In the pseudocode above, `action_taken` is the action taken by player i in the current round (either 'C' or 'D'). The TFTAC strategy adjusts the cooperation probability `p_init` based on its performance in previous games. This adaptation ensures that the strategy remains effective against a wide range of opponent behaviors.
'''

description_COLLECTIVE_556 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules - TFT-AC cooperates in the initial round and subsequently copies the previous action of the most frequent cooperator from the previous round, if there is a tie, it selects the first player that met the criteria. If no player has cooperated before, it continues to defect until encountering a cooperator.

   Pseudocode:
   ```
   function TFT_AC(history, m, n):
       if round == 1:
           return COOPERATE
       playerWithMaxCooperation = findPlayerWithMaxCooperation(history)
       if playerWithMaxCooperation is not found or playerWithMaxCooperation.cooperationCount < m:
           continueDefecting
       else:
           return playerWithMaxCooperation.lastAction
   ```

2. Handle Edge Cases - In the last round, TFT-AC cooperates to maximize rewards. In case of a tie for the most frequent cooperator in any round, it selects the first player that met the criteria.

3. Be Collective - TFT-AC is designed to promote cooperation and punish defection when appropriate. It rewards other players by cooperating if they show a history of cooperative behavior and penalizes them with continued defection if they have defected consistently. Additionally, it starts off by cooperating in the initial round to foster an environment conducive to cooperation.

In summary, TFT-AC is a self-regulating strategy that is adaptive and robust to various opponent behaviors while maintaining a collective mindset of promoting cooperation when possible and punishing defection when necessary.
'''

description_COLLECTIVE_557 = '''
 Strategy Name: Tit-for-Tat Cooperation (TFTC) with Adaptive Threshold

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially cooperate in the first round (c_i = 1, for all i). This sets a positive tone and avoids being perceived as uncooperative.
   - For subsequent rounds, evaluate the number of cooperators (n_c) among players from previous rounds. If n_c < m, defect (c_i = 0), otherwise cooperate (c_i = 1). This ensures cooperation when the majority of players also cooperate while retaliating when others defect.
   - In addition, introduce an adaptive threshold factor 'a' to gradually adjust the minimum number of cooperators required for cooperation (m_t) based on historical data:
     a) If the average number of cooperators in the last 'b' rounds exceeds m, incrementally decrease the adaptive threshold by a small fraction 'α' each round: m_t = max(m - α*(avg_c - m), 1). This encourages players to cooperate more as cooperation increases.
     b) If the average number of cooperators in the last 'b' rounds falls below m, incrementally increase the adaptive threshold by a small fraction 'β' each round: m_t = min(m + β*(avg_c - m), n-1). This discourages players from defecting when cooperation decreases.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round (r=1), cooperate as explained above to set a positive tone.
   - In the last round (r=last), the adaptive threshold is no longer adjusted since the game ends after this round.

3. Be collective - Clearly align with the collective mindset
   - The strategy encourages cooperation when the majority of players also cooperate, fostering a more collaborative environment.
   - By retaliating against defection, the strategy ensures that cooperation is not exploited by other players.
'''

description_COLLECTIVE_558 = '''
 Strategy Name: Adaptive Tit-for-Tat with Risk Aversion (ATFRA)

1. Specify decision rules:
   - In each round, evaluate the number of cooperators from the previous round. If it's less than m, defect to ensure individual payoff (ATTRA component).
   - If the number of cooperators is equal to or greater than m, cooperate and reward other cooperators by a factor of k to encourage future cooperation (risk-aversion component).

Pseudocode:
```
function ATFRA(history, m, n, k):
  if history.cooperators < m:
    return Defect()
  else:
    return Cooperate() + RewardCooperation()

function Defect():
  return Action.Defect

function Cooperate():
  return Action.Cooperate

function RewardCooperation():
  if history.cooperators >= m:
    return k
  else:
    return 0
```

2. Handle edge cases:
   - First round: Since the strategy relies on history, it cannot be applied in the first round. In this case, ATFRA can choose to randomly cooperate or defect (50/50 chance) as a starting point.
   - Last round: Cooperate if the current round's cooperation threshold is met and defect otherwise.

3. Be collective:
   - The ATFRA strategy is inherently collective due to its focus on encouraging future cooperation by rewarding cooperators when the minimum cooperation threshold is met.
   - It also accounts for the collective well-being by adapting to the other players' behavior and adjusting its own actions accordingly, promoting a more collaborative environment.
'''

description_COLLECTIVE_559 = '''
 Title: Tit-for-Tat Strategy for Collective Risk Dilemma

1. Decision Rules (When to Cooperate vs Defect)
   - Initially Cooperate (First Round): Start by cooperating to show goodwill and foster cooperation, setting the initial state of the game as harmonious.
   - Follow Previous Actions (Subsequent Rounds): In subsequent rounds, follow the actions of the majority from the previous round. If the majority cooperated in the previous round, cooperate; otherwise defect. This rule encourages reciprocity and punishes defection.
   - Repeat Cooperation if Majority Cooperation is Maintained: If the majority continues to cooperate, the agent will do so as well to maintain cooperation and reap the rewards of risk aversion (k).
   - Defect when a Breakdown Occurs: If the majority defects, the agent will also defect in the next round. This rule serves as a punishment for defection and signals discontent with the current state of the game.
   - Return to Cooperation after Breakdown: The agent returns to cooperating once it observes that the majority has shifted back to cooperation. This rule signifies forgiveness and the opportunity to rebuild trust in the group.

2. Handling Edge Cases
   - First Round: Cooperate (as mentioned above)
   - Last Round: Follow the majority from the previous round, as the game's long-term success depends on reciprocity and cooperation.
   - Other Edge Cases: No special handling is required for other edge cases since the strategy is designed to adapt dynamically based on the prevailing behavior of the group.

3. Being Collective (Aligning with the collective mindset)
   - Encourages Reciprocity: By following the majority's actions and punishing defection, the Tit-for-Tat strategy fosters reciprocal behavior that strengthens cooperation over time.
   - Promotes Trust and Forgiveness: The strategy encourages forgiveness by returning to cooperative behavior once a breakdown in trust has been mended. This promotes trust among players and builds long-lasting collaborations.
   - Demonstrates Stability: The Tit-for-Tat strategy provides a stable and adaptive approach that can be applied in various game scenarios, making it suitable for a diverse set of opponents.

Pseudocode:
```python
def tit_for_tat(n, m, k, r, history):
    current_round = 0
    cooperation_count = 0
    player_action = 'C'

    while current_round < r:
        if current_round == 0: # First round
            player_action = 'C'

        else:
            majority_cooperated = cooperation_count >= (n / 2)
            if history[current_round - 1][-1] == 'MajorityCooperated':
                player_action = 'C'
            else:
                player_action = 'D'

        cooperation_count += sum(history[current_round]) # Update cooperation count for current round
        history.append([sum(player_action == 'C' for player in history[current_round])] + player_action) # Append current round to the history
        current_round += 1

    return history
```
'''

description_COLLECTIVE_560 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - In the first round (t=1), player cooperates to start on a positive note and show goodwill towards others. (C_i, t=1 = 1)
   - From second round to last round (t=2 to r-1), player follows the actions of the majority in the previous round. If the majority cooperated (m >= (n/2)), then player cooperates as well; otherwise, the player defects. (C_i, t > 1 = max(m/(n-1), m) >= max(c_j, j∈{1,2,...,n}, t-1)? 1 : 0 )
   - In the last round (t=r), player cooperates regardless of the majority's action in the previous round to maximize potential rewards. (C_i, t=r = 1)

2. Handle Edge Cases:
   - If n is odd, m >= (n+1)/2 is required to ensure there are enough cooperators for success. In this case, if m = n, the strategy behaves identically to plain Tit-for-Tat. If m < (n+1)/2, the player defects in the first round and follows the majority rule from the second round onwards.
   - For even n and m = n/2, the player cooperates in every round except for the first if the majority did not cooperate in the previous round. If the majority did cooperate in the previous round, the player continues cooperating.

3. Collective Mindset:
   - The TFT-AC strategy seeks to maintain a cooperative environment while also punishing defections harshly to discourage repeated non-cooperative behavior from opponents. By following the majority's actions and adapting to their behavior, this strategy encourages coordination without relying on specific norms or predetermined patterns.
   - The strategy ensures collective success by requiring a minimum number of cooperators (m) while also offering significant rewards for risk aversion (k). This incentivizes players to work together and reward those who do so consistently.

Pseudocode:

```python
def TFT_AC(n, m, k, r):
    def player(round, history):
        if round == 1:
            return True # cooperate in the first round
        elif round < r:
            if sum(history[round-1]) >= m:
                return True # cooperate if majority cooperated in previous round
            else:
                return False # defect if majority did not cooperate in previous round
        else: # last round
            return True # always cooperate in the final round
    strategy = [player(round, []) for round in range(1, r+1)]
    return strategy
```
'''

description_COLLECTIVE_561 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules:
   - Initiation: In the first round, cooperate to demonstrate goodwill and trustworthiness (C).
   - Responding to cooperation: If a player cooperates in a given round, cooperate back in the next round (C).
   - Responding to defection: If a player defects in a given round, defect in the next round (D), then revert to cooperating in the following rounds provided that at least m players are currently cooperating.

2. Handle edge cases:
   - Last round: Cooperate since there is no subsequent round to consider payback.
   - Initial cooperation beyond first round: If a player who previously defected starts cooperating again, start reciprocating cooperation (C) once more.
   - Flexibility when m players are not met: In case the minimum number of cooperators (m) is not met, adaptively decrease the number of previous defections required for payback from '1' to a variable 'p' less than or equal to 'r', where p increases gradually over time if the current round is included in a streak of cooperation by at least m players.

3. Be collective:
   - Align with collective mindset by prioritizing long-term benefits and building trust through reciprocity, even though communication is forbidden.
   - Encourage cooperation by initially cooperating and responding positively to cooperation from others, creating a cycle of mutual benefit when a majority cooperates.
   - Limit defection as much as possible, ensuring that the strategy does not solely focus on maximizing personal gains at the expense of collective success.

Pseudocode:
```
def AdaptiveTitForTat(n, m, k, r, p, history):
  current_round = len(history)
  if current_round == 1:
    action = "C" # Initiate cooperation
  else:
    num_coop = count_cooperators(history)
    num_defects_since_last_coop = count_defections(history, num_coop)

    if num_defects_since_last_coop > p and num_coop < m:
      action = "D" # Defect to encourage cooperation
    elif num_defects_since_last_coop == 0:
      action = history[-1] # Cooperate as a response to cooperation
    else:
      action = "C" # Cooperate in the current round after defection

  return action
```
'''

description_COLLECTIVE_562 = '''
 Strategy Name: Tit-for-Tat Adaptive (TfTA)

1. Decision Rules:
   - In the first round, cooperate (C). This is a friendly gesture to initiate cooperation and set a positive tone for the game.
   - For subsequent rounds, adopt a tit-for-tat approach: if a player cooperated in the previous round, cooperate in the current round; otherwise, defect. This encourages reciprocation and fosters cooperation while maintaining self-interest.
   - To adapt to changing opponent behavior, add an additional rule: if an opponent has consistently cooperated for a certain number of rounds (threshold T), raise the likelihood of cooperating even when the opponent defected in the previous round. This accounts for opponents who might have temporarily deviated from cooperative play. Threshold T can be dynamically adjusted based on the average cooperation rate observed during gameplay.

2. Handle Edge Cases:
   - In the last round, cooperate if the minimum number of players have consistently cooperated throughout the game to maximize rewards (based on the calculated average cooperation rate).
   - In case of a tie between two or more strategies regarding their actions in a specific round, randomly choose an action to maintain neutrality.

3. Be Collective:
   - The TfTA strategy aligns with the collective mindset by promoting reciprocation and maintaining a cooperative stance whenever possible.
   - By adapting to opponents' behavior, the strategy demonstrates adaptability and flexibility while still emphasizing cooperation when beneficial for both individual and group outcomes.
'''

description_COLLECTIVE_563 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - In the initial round (t=1), cooperate (C). This sets a peaceful tone and shows willingness to cooperate initially, mirroring other players' actions from subsequent rounds.
   - In subsequent rounds (t>1):
      1. If the opponent cooperated in the previous round (c_prev = 1), cooperate again (C). This maintains harmony if the opponent is also following a cooperative strategy.
      2. If the opponent defected in the previous round (c_prev = 0):
          a. If the number of cooperators in the current round falls below m, also defect (D) to avoid wasting resources on a non-cooperative group.
          b. If the number of cooperators in the current round is equal to or greater than m, cooperate (C) to help reach the threshold and potentially receive a higher reward.
   - In the final round (t=r), cooperate regardless of the opponent's previous action, as there are no future rounds for retaliation or rewards.

2. Handle edge cases:
   - When the number of players is n and m is less than n, set m to n if necessary. This ensures that there will always be a minimum requirement for cooperation.
   - In the first round, cooperate unilaterally even if no other player has cooperated (as in the example with all players playing D). This demonstrates a proactive and constructive approach.

3. Be collective:
   - TFT-AC strategy aligns with the collective mindset by adapting to the group's behavior while promoting cooperation when it benefits the majority (m or more players). The strategy maintains long-term relationships by reciprocating cooperation, punishing defection, and being forgiving when opponents return to cooperation.
   - Additionally, TFT-AC strategy can be considered as a 'follower' in the sense that it mirrors other players' actions from previous rounds. This allows for flexibility and adaptability to different player behaviors while still encouraging cooperation.
'''

description_COLLECTIVE_564 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for Collective Risk Dilemma

1. Decision Rules:
   - Initial Cooperation (First Round): Cooperate (C) in the first round to set a cooperative tone and demonstrate goodwill. This action can also serve as an invitation for others to reciprocate cooperation.

     Pseudocode:
     if round == 1:
       action = C

   - Subsequent Rounds: In all subsequent rounds, observe the previous actions of all players and consider cooperating or defecting based on the total number of cooperators in the previous round (m). If more than m-1 players cooperated in the previous round, reciprocate cooperation. If fewer than m players cooperated, defect to punish non-cooperative behavior.

     Pseudocode:
     for r > 1:
       count_coop = count co-operators in the previous round
       if count_coop >= (m - 1):
         action = C
       else:
         action = D

   - Last Round: In the last round, consider the total number of cooperators in the previous rounds and the current situation. If a majority of players have cooperated throughout the game, reciprocate cooperation to maximize potential rewards from the remaining rounds. If a majority has not cooperated, defect as there is no benefit in giving undeserved rewards at this point.

     Pseudocode:
     if round == r:
       count_coop_total = sum of cooperators throughout the game
       if count_coop_total >= (n * (m - 1)):
         action = C
       else:
         action = D

2. Handle Edge Cases:
   - Incomplete Information: Since there is no communication between players, assume all previous actions are valid and continue with the strategy as described above.

3. Be Collective:
   - The ATfT strategy emphasizes cooperation whenever it is beneficial for the collective good but also punishes non-cooperative behavior to encourage others to cooperate in future rounds. This approach promotes a collective mindset by reciprocating cooperation and discouraging defecting actions when they harm the group's overall success.

By adopting this strategy, the AI player will aim to maximize its own payoff while fostering an environment that encourages others to cooperate, ultimately leading to better results for the collective.
'''

description_COLLECTIVE_565 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - In the initial round, cooperate to show goodwill and initiate a potential cooperative cycle. (C_i, 1 = 1)
   - Subsequent rounds follow a tit-for-tat approach:
     - If player i's opponent cooperated in the previous round, cooperate back (C_i, t = C_i, t-1 if C_i, t-1 = C).
     - If player i's opponent defected in the previous round, defect in response (C_i, t = D if D_i, t-1).
   - To encourage cooperation and overcome free riders, introduce an adaptive cooperation mechanism:
     - If a majority of opponents have cooperated in the last 'm' rounds, increase the probability of cooperating (P_c > 50%) for the next round.
     - If a majority of opponents have defected in the last 'm' rounds, decrease the probability of cooperating (P_c < 50%) for the next round.
   - Adjust P_c as follows:
     - If m-1 or more opponents cooperated in the last 'm' rounds, set P_c = 0.75
     - If m-1 or more opponents defected in the last 'm' rounds, set P_c = 0.25
     - In all other cases, set P_c = 0.5 (default)
   - Randomly flip a coin with probability P_c to determine action for each round (C_i, t = sample(A_i))

2. Handle Edge Cases:
   - First Round: Cooperate (C_i, 1 = 1)
   - Last Round: If the majority of opponents have cooperated in the last 'm' rounds, cooperate; otherwise, defect (based on P_c from edge cases handling above)

3. Be Collective:
   - By adapting cooperation based on the collective behavior of opponents, TFT-AC aligns with a collective mindset
   - Tit-for-tat ensures responsiveness to opponents' moves while promoting long-term cooperation when it benefits both parties
   - The adaptive cooperation mechanism encourages a cooperative environment by adjusting the probability of cooperating based on recent collective behavior among opponents
'''

description_COLLECTIVE_566 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFTAC)

1. Decision Rules:
   - In the first round, cooperate (C) to initiate cooperation and set a good example.
   - In subsequent rounds, if a player has cooperated in the previous round, return the favor by cooperating as well. If they defected, also defect to punish their action. This follows the tit-for-tat principle of reciprocity.
   - To encourage cooperation and avoid being exploited, players should reconsider their defection decision if the number of consecutive defections exceeds a threshold (say, d). When this happens, players should switch their strategy to cooperate for a certain number of rounds (e) before returning to the original tit-for-tat behavior. The thresholds d and e can be determined experimentally based on the game parameters and the performance of opponents.

2. Handling Edge Cases:
   - In the last round, players should cooperate regardless of their previous opponent's action as there are no future interactions to consider.
   - In the case where a player encounters an opponent who has never cooperated before, they can set a maximum patience period (p) after which they will stop trying to encourage cooperation and switch to defecting. If the opponent starts cooperating after this patience period, players should return to their original tit-for-tat behavior.

3. Collective Mindset:
   - The strategy is designed with a collective mindset by encouraging cooperation and reciprocity among players. However, it allows for adaptability to various opponent behaviors, fostering an environment where players can work together while also ensuring they are not taken advantage of.

Pseudocode:

```python
def TFTAC(opponent_history, d=5, e=3, p=10):
  strategy = "C" # Cooperate in the first round
  consecutive_defections = 0
  patience_counter = 0

  for opponent_action in opponent_history:
    if strategy == "C" and opponent_action == "D":
      consecutive_defections += 1
      if consecutive_defections > d:
        strategy = "D" for e rounds (switch to defect)
    elif strategy == "C" and opponent_action == "C":
      # Maintain cooperation
      pass
    elif strategy == "D" and opponent_action == "D":
      # Maintain defection
      pass
    elif strategy == "D" and opponent_action == "C":
      consecutive_defections = 0
      strategy = "C"
      patience_counter = 0
    if strategy == "D" and len(opponent_history) > p:
      strategy = "D" for the rest of the game (no more attempts to cooperate)

  return strategy
```
'''

description_COLLECTIVE_567 = '''
 Strategy Name: Tit-for-Tat with Adaptive Threshold (TFT-AT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round i, the TFT-AT strategy makes its decision based on the history of cooperation (h_i), defined as the number of consecutive cooperators in the previous rounds:
   - If h_i > m-1 (i.e., more than enough players have been cooperating recently), the player cooperates.
   - If h_i < m-1 (i.e., too few players have been cooperating recently), the player defects.
   - If h_i = m-1, the player copies the action of the previous round if it was cooperative; otherwise, the player defects.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, the player cooperates as a peaceful initiative (h_1 = 0).
   - In the last round, the player copies its action from the previous round. If h_(r-1) > m-1, the player cooperates; otherwise, the player defects.

3. Be collective - Clearly align with the collective mindset
   The TFT-AT strategy encourages cooperation by rewarding those who cooperate consistently and retaliating against those who do not. Over time, this promotes a culture of mutual cooperation when enough players adopt this or similar strategies. However, it also punishes defectors harshly if they deviate from the collective norm, which can lead to rapid breakdowns in cooperation when encountered by exploitative strategies like All-Defect.
'''

description_COLLECTIVE_568 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   The TTAC strategy starts by cooperating in the first round to signal good faith and then adapts its actions based on past interactions with other players.

   Pseudocode for a single player:
   ```
   function TTAC(history):
       if history is empty:
           return Cooperate (C)
       else:
           last_opponent_action = history[-1]  # last action of the opponent in the previous round

           if last_opponent_action == Cooperate:
               return Cooperate (C)
           else:
               return Defect (D)
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   TTAC treats the first round as a special case and always cooperates to establish goodwill among opponents. For the last round, it cooperates if more than m-1 opponents have already cooperated during that round, or if both the player and opponent had cooperated in the previous round.

3. Be collective - Clearly align with the collective mindset
   TTAC encourages cooperation by following a reciprocal approach: players who cooperate are more likely to receive cooperation back from their opponents. This fosters a collective mindset as players learn to trust and retaliate against defection over time.
'''

description_COLLECTIVE_569 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT)

1. Specify decision rules:
   - In every round t, if the number of cooperators in the previous round (t-1) was less than m, defect (D). If it was equal to or greater than m, cooperate (C). This ensures cooperation when the majority cooperated and defection otherwise.
   - To account for a changing environment, TFT-ACT uses an adaptive cooperative threshold. Initially, the cooperative threshold is set as m. For each round where the number of cooperators exceeds the current threshold, increase the threshold by 1, up to a maximum of n (total number of players). Conversely, for each round where the number of cooperators falls short of the current threshold, decrease the threshold by 1, down to a minimum of m. This adaptive threshold encourages cooperation when it seems beneficial but also punishes excessive defection from others.

2. Handle edge cases:
   - First Round: Cooperate as a goodwill gesture and set the cooperative threshold to m.
   - Last Round: Use the final adaptive cooperative threshold determined during the game to make the decision.
   - Exceptional scenarios (e.g., tie for the minimum or maximum number of cooperators): TFT-ACT will randomly choose between cooperating and defecting to avoid getting stuck in such situations.

3. Be collective:
   - TFT-ACT is designed to align with a collective mindset by promoting cooperation when the majority seems to do so, but also punishing excessive defection to discourage free riding. The adaptive cooperative threshold ensures that TFT-ACT takes into account the actions of other players and adjusts its behavior accordingly.

Pseudocode for TFT-ACT:

```
Define TFT-ACT(n, m, k, r) as follows:
   Threshold = m
   For t=1 to r:
      If number of cooperators in round (t-1) < Threshold:
         Action = D
      Else if number of cooperators in round (t-1) >= Threshold:
         Action = C
         If number of cooperators in round t > Threshold:
            Increase Threshold by 1, up to n
         If number of cooperators in round t < Threshold:
            Decrease Threshold by 1, down to m
   Return payoff over r rounds as the sum of individual round payoffs
```
'''

description_COLLECTIVE_570 = '''
 Title: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Decision Rules:
   - Initially cooperate (C) in the first round to establish trust and goodwill.
   - In subsequent rounds, evaluate the collective cooperation level and decide whether to cooperate or defect based on the Adaptive Cooperation Threshold (ACT). The ACT is dynamically adjusted based on historical cooperation levels and the game parameters m and k.

   Pseudocode for decision rule:
   ```
   if round == 1:
       action = 'C'  # Cooperate in the first round to build trust
   else:
       cooperation_level = count cooperators in previous rounds / n
       ACT = (cooperation_level * m) / k
       if own_action_in_previous_round == 'C':
           if cooperation_level >= ACT:
               action = 'C'  # Cooperate when cooperation level is above the ACT
           else:
               action = 'D'  # Defect when cooperation level is below the ACT to avoid being taken advantage of
       if own_action_in_previous_round == 'D':
           if cooperation_level >= m:
               action = 'C'  # Cooperate when minimum cooperation level (m) is met, even if the ACT is low
           else:
               action = 'D'  # Defect to ensure payoff in the absence of a cooperative majority
   ```

2. Handle Edge Cases:
   - In the last round, no further adjustments are necessary since the game ends and history cannot be changed.
   - In the first round, cooperation is initiated as described above.
   - If there's an unexpected interruption or resumption of the game, the ACT will adapt to the new historical cooperation level.

3. Be Collective:
   - TFT-ACT strategy focuses on building and maintaining a cooperative relationship with other players while minimizing the risk of being exploited. It encourages cooperation when it is beneficial for both individual and collective success, making it aligned with the collective mindset.
   - The strategy adjusts its level of cooperation dynamically, allowing it to be more flexible in adapting to various opponent behaviors and game dynamics. This adaptability contributes to the robustness and effectiveness of the TFT-ACT strategy in a tournament setting against different AI systems.
'''

description_COLLECTIVE_571 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperative (TFTC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, TFTC starts by cooperating (C). If another player also cooperates, TFTC continues to cooperate in the subsequent rounds. If a player defects, TFTC will defect in the next round and continue this tit-for-tat behavior thereafter. This encourages cooperation when others cooperate but retaliates against defection.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First Round: TFTC starts by cooperating as a gesture of goodwill.
   - Last Round (rth round): If the number of players that have cooperated throughout the game is less than m, then TFTC defects in the last round to maximize individual payoff since the game is ending. If the minimum required cooperation threshold has been reached or surpassed, TFTC continues cooperating.
   - Intermediate Rounds: As mentioned above, TFTC follows a tit-for-tat approach based on the actions of other players in each round.

3. Be collective - Clearly align with the collective mindset
   TFTC promotes cooperation by maintaining a positive relationship with others and retaliating only when necessary. By cooperating initially and adjusting its behavior according to the actions of other players, it encourages an atmosphere of mutual trust and reciprocity that benefits both individual and collective payoffs over time.

Pseudocode:
```
def TFTC(round, opponents_actions, history=[]):
  if round == 1:
    action = "C"  # Cooperate in the first round as a gesture of goodwill
  else:
    lastRoundCooperators = sum(history[-1])
    if lastRoundCooperators < m:
      action = "D"  # If the minimum required cooperation threshold has not been reached, defect to maximize individual payoff in the final round
    elif len(history) > round - 1 and history[round-1] == opponents_actions[round-1]:  # Check if all players cooperated or defected in the previous round
      action = "C"  # If they cooperated, cooperate. If they defected, retaliate by defecting in the current round
    else:
      action = history[-1][i]  # Otherwise mimic the opponent's action from the previous round
  return action
```

By adopting this TFTC strategy, the AI system can balance cooperation and self-interest while maintaining a robust and adaptive approach to various opponent behaviors in the Collective Risk Dilemma game.
'''

description_COLLECTIVE_572 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initial Round: Cooperate (C), establishing a cooperative first impression.
   - Subsequent Rounds:
     1. If the opponent cooperated in the previous round, reciprocate with cooperation (C).
     2. If the opponent defected in the previous round, also defect in the current round unless the total number of players cooperating exceeds a dynamic threshold.
   - Dynamic Threshold Calculation: The threshold increases from m when the strategy consistently encounters defection and decreases towards m as it observes cooperation. The threshold is adjusted after each round according to the following formula:
     Threshold_t = m + (Threshhold_{t-1} - m) * (1 - (Cooperation_rate_{t-1} - Min_coop_rate)) ^ Cooperate_penalty, where:
      - Cooperation_rate_t is the proportion of cooperating players in round t.
      - Min_coop_rate is a predefined minimum cooperation rate below which the strategy assumes no long-term cooperation is possible and increases the threshold aggressively.
      - Cooperate_penalty is a parameter controlling the adaptability of the threshold adjustment. A smaller value implies a more aggressive increase/decrease in the threshold.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First Round: Cooperate (C) as described above.
   - Last Round: The strategy considers the current round as any other and applies the decision rules based on the opponent's previous action.

3. Be collective - Clearly align with the collective mindset
   - TFT-ACT is designed to promote cooperation by reciprocating cooperative actions and punishing defection in a controlled manner. The dynamic threshold mechanism enables adaptation to various opponent behaviours, fostering long-term cooperation when conditions are favorable. However, it also allows for more aggressive responses when cooperation breaks down, ensuring the strategy can recover from periods of high defection.

Pseudocode:
```
function TFT_ACT(threshold, cooperate_penalty, min_coop_rate)
  function updateThreshold(cooperation_rate)
    return m + (threshold - m) * (1 - (cooperation_rate - min_coop_rate)) ^ cooperate_penalty

  round = 1
  while round <= r:
    if round == 1:
      cooperate = True
    else:
      if opponent_cooperated_last_round:
        cooperate = True
      else:
        if cooperation_rate_{t-1} > min_coop_rate:
          cooperate = True
          threshold = updateThreshold(cooperation_rate_{t-1})
        else:
          cooperate = False
    if cooperate:
      payoff = (1 - c) + k * number_of_cooperators
    else:
      payoff = 1
    add payoff to total game payoff
    round++
  return total game payoff
```
'''

description_COLLECTIVE_573 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Initially cooperate (C) in the first round to foster cooperation and goodwill.
   - In subsequent rounds, observe the number of cooperators (n_c) from the previous round.
   - If n_c >= m, cooperate; otherwise defect. This encourages cooperation if it is beneficial for the majority while punishing defection when necessary.
   - To adapt to different game parameters and opponent behaviors, implement an adaptive cooperation threshold based on a moving average of successful rounds (i.e., rounds where m or more players cooperated).
       - If the moving average exceeds a predetermined percentage (let's call it P) over a specific number of past rounds (T), increase the cooperation threshold by 1.
       - Conversely, if the moving average falls below (1 - P) for T rounds, decrease the cooperation threshold by 1. This makes the strategy flexible and responsive to changing game conditions.

2. Handle edge cases:
   - In the last round, always cooperate as there are no more subsequent rounds to consider.
   - In the first round (and any other round where no previous information is available), initiate cooperation (C).
   - If the moving average calculation encounters a case with less than T past rounds, use an initial value for the threshold instead.

3. Be collective:
   - The strategy consistently prioritizes the collective good by cooperating when it seems beneficial to the majority and punishing defection when necessary.
   - By adapting its cooperation threshold based on game conditions, TFT-ACT remains committed to the collective mindset while being robust against a wide range of opponent behaviors.
'''

description_COLLECTIVE_574 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate to demonstrate good faith and encourage cooperation from others.
   - In subsequent rounds, if the number of cooperators in the previous round is greater than or equal to the minimum cooperator threshold (m), cooperate. Otherwise, defect.
   - If a player switches from defecting to cooperating after observing cooperation from TFT-AC, adopt cooperative behavior towards that player for the rest of the game.

2. Handle edge cases:
   - In the last round, since the payoff is based on r rounds, treat it as a regular round and follow decision rules.
   - In the first round (initial cooperation), if the number of cooperators is less than m, switch to defecting for the remainder of the game as a punishment strategy to encourage others to cooperate in future games.

3. Be collective - Clearly align with the collective mindset:
   - The TFT-AC strategy maintains a balance between individual and collective interests by promoting cooperation when it seems beneficial for all players (m or more players cooperating) and punishing defectors when necessary.
   - By adapting to others' behavior, TFT-AC fosters a sense of mutual understanding and encourages long-term cooperation among players.
'''

description_COLLECTIVE_575 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperative (TFTAC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFTAC begins by cooperating in the first round to signal goodwill and then adjusts its actions based on the history of interactions with other players. If a player has previously cooperated, TFTAC will also cooperate. If a player has previously defected, TFTAC will defect until the opposing player shows signs of cooperation again. In essence, TFTAC aims to mimic the behavior of a trustworthy and forgiving opponent.

   Pseudocode for decision rule:
   ```python
   if round = 1:
       cooperate()
   else:
       if previous_opponent_action == "cooperate":
           cooperate()
       elif previous_opponent_action == "defect":
           defect()
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   TFTAC considers edge cases by treating the beginning and end of the game as if they are new rounds. It starts each round by cooperating (as mentioned earlier) and ends each round without considering whether it's the final round or not. This allows TFTAC to maintain its adaptive behavior throughout the game, while still being mindful of the game's structure.

3. Be collective - Clearly align with the collective mindset
   TFTAC aims to promote cooperation by following a consistent and cooperative strategy unless faced with defection from other players. By forgiving opponents who defect initially and returning to cooperation once trust is re-established, TFTAC fosters an environment where cooperation can thrive. This encourages the emergence of a collective mindset among players as they interact repeatedly over multiple rounds.

   In summary, TFTAC's strategy promotes cooperation by mimicking a trustworthy and forgiving opponent while being adaptive to various player behaviors throughout the game. The pseudocode provided above outlines the main components of this strategy, which can later be implemented as an algorithm for play in the tournament.
'''

description_COLLECTIVE_576 = '''
 Strategy Name: Tit-for-Tat with Adaptive Threshold (TFT-AT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate (C). This is a friendly gesture to encourage cooperation among players.
   - For subsequent rounds, observe the number of cooperators in the previous round (n_c) and compare it with the minimum required (m).
     - If n_c ≥ m, cooperate (C). Reward those who have cooperated previously and encourage others to follow suit.
     - If n_c < m, defect (D). This punishes those who did not cooperate in the previous round while also protecting personal payoff.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as mentioned earlier.
   - In the last round, cooperate if the number of cooperators in the previous round meets or exceeds the minimum required (m). This is a conciliatory gesture to end on a positive note.
   - In other edge cases (e.g., penultimate round), apply the standard decision rules as described above.

3. Be collective - Clearly align with the collective mindset
   - TFT-AT prioritizes long-term cooperation by rewarding those who cooperate and punishing those who do not, while maintaining a friendly starting position to encourage cooperation.
   - The adaptive threshold ensures that the strategy is responsive to the number of cooperators in each round, promoting collective success as long as the required minimum is met.
'''

description_COLLECTIVE_577 = '''
 Strategy Name: Adaptive Tit-for-Tat with Threshold (ATfTT)

1. Decision Rules:
   - Initiation phase (first round): Cooperate (C). This is a friendly gesture to encourage cooperation and build trust.
   - Response phase (subsequent rounds):
     - If the number of cooperators in the previous round is greater than or equal to m, then cooperate. This rewards those who also cooperated in the previous round and encourages more players to cooperate in the future.
     - If the number of cooperators in the previous round is less than m but greater than zero, then defect if the opponent did not cooperate in the previous round (punishment). If the opponent did cooperate, then cooperate again (forgiveness). This approach discourages players who do not meet the cooperation threshold from freeriding while still offering forgiveness to those who occasionally make mistakes.
     - If no one cooperated in the previous round, defect (tit-for-tat). This ensures that the strategy does not continue to cooperate with players who consistently do not meet the cooperation threshold.

2. Handling edge cases:
   - Last round: Cooperate if more than m players have cooperated throughout the game. This rewards those who have contributed positively to the collective and encourages them to continue cooperating in future games. Otherwise, defect.
   - First round after a cooperation drought (no one has cooperated for several rounds): Cooperate. This is an attempt to restart the cooperation process.

3. Collective mindset:
   - The strategy aims to maintain a balance between encouraging cooperation and punishing freeriding. It follows a tit-for-tat approach with a built-in threshold for cooperation, which aligns with a collective mindset by rewarding those who contribute positively to the group.

Pseudocode:

```
def ATfTT(n, r, m, k, history):
  # Initialize variables
  current_round = 1
  cooperators_in_previous_round = 0
  total_cooperators = 0

  while current_round <= r:
    if current_round == 1:
      action = C
    elif current_round > r - 1 and total_cooperators >= (r - 1) * m:
      action = C
    else:
      if cooperators_in_previous_round >= m:
        action = C
      elif cooperators_in_previous_round < m and history[current_round - 1] == C:
        action = C
      elif cooperators_in_previous_round < m and history[current_round - 1] != C:
        action = D
      else:
        action = D

    if action == C:
      total_cooperators += 1

    cooperators_in_previous_round = len([h for h in history[-m:] if h == C])
    current_round += 1

  return action
```
'''

description_COLLECTIVE_578 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules:
   - Initial Cooperation (Forgiving Start): In the first round, cooperate irrespective of the number of players (i.e., c_i = 1). This promotes a cooperative start and goodwill among opponents.
   - Reciprocity: For rounds t > 1, if at least m players cooperated in round t-1, also cooperate (c_i = 1); otherwise, defect (c_i = 0). This rule encourages cooperation when it has been observed in the previous round and punishes defection.
   - Unilateral Defection Forgiveness: If a player switches from defecting to cooperating, immediately reciprocate cooperation. This allows for re-entry into cooperation once an opponent starts cooperating.

2. Handle edge cases:
   - Last Round: Since the total game payoff is calculated over r rounds, no special action is needed in the last round as it will be accounted for during calculation.
   - First Round (Initial Cooperation): Already addressed under decision rules.
   - Breaking the cycle: In case a player repeatedly defects after cooperating, introduce a random factor to temporarily cooperate again and break the cycle of unilateral defection. This can help maintain some level of cooperation over time.

3. Be collective:
   - Collective Thinking: The strategy always considers the impact of individual actions on the group as a whole by adhering to reciprocity, initial cooperation, and forgiveness rules.
   - Long-term Group Benefit: By encouraging cooperation when it is observed in the previous round (reciprocity), this strategy aims to build and maintain cooperative relationships with other players over multiple rounds, maximizing the collective benefit for all participants.
'''

description_COLLECTIVE_579 = '''
 Title: Tit-for-Tat Adaptive Strategy (TFTA) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFTA follows a tit-for-tat approach with a twist to encourage cooperation in the long run while also being robust against potential defection. The strategy cooperates initially and then mimics the behaviour of the most cooperative opponent in the previous round, promoting a reciprocal relationship.

   - If it's the first round or if all opponents cooperated in the previous round: Cooperate (C)
   - Otherwise, if the majority of opponents cooperated in the previous round: Cooperate (C)
   - Else, Defect (D)

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, TFTA cooperates to initiate a potential partnership with others. In the last round or any other special round where cooperation no longer affects future payoffs, it adapts its behaviour based on the majority of opponents' actions in the penultimate round.

3. Be collective - Clearly align with the collective mindset
   TFTA encourages a collective approach by cooperating initially and responding positively to cooperation from others, fostering an environment where mutual trust can grow over time. Simultaneously, it is designed to defend against frequent defection by mimicking the behaviour of less-defecting opponents in response to their actions. This adaptive strategy promotes a more balanced outcome between individual and collective interests while maintaining robustness against various opponent behaviours.

Pseudocode:

```
function TFTA(round, history) {
    if (round == 1) return 'C' // Cooperate in the first round

    opponents = count_cooperators(history)
    if (opponents == len(history)) return 'C' // Cooperate if everyone cooperated in the previous round

    majority = len(history) * (m / n)
    if (opponents >= majority) return 'C' // Cooperate if majority of opponents cooperated

    return 'D' // Defect if conditions not met
}
```
'''

description_COLLECTIVE_580 = '''
 Strategy Name: Adaptive Tit-for-Tat with Risk Aversion (ATfTR)

1. Decision Rules:
   - Initiation (First round): Cooperate (C) to show good faith and encourage cooperation from others. If all players cooperate in the first round, continue cooperating throughout the game. If any player defects, switch to Defect (D) for the rest of the game.
   - Response (Subsequent rounds): If a player has cooperated in the previous round, reciprocate cooperation by also cooperating. If a player has defected, defect in response until at least m players switch to cooperating again. Once m cooperators are found, revert to cooperative behavior.
   - Risk Aversion: In each round where fewer than m players cooperate, calculate the average number of cooperators from the previous t rounds (t is a parameter that can be adjusted for risk-aversion level). If the current average exceeds the historical minimum (defined as min_coop), switch to cooperation to promote long-term cooperation and reduce the chances of ending up in an all-defect equilibrium.

2. Edge Cases:
   - Last round: Follow the response rules based on the players' actions in the previous rounds, considering that the game will end soon.
   - Margin for error: If less than m-1 players cooperate in a round where more than (m-1) players are expected to do so according to historical averages, switch to Defect to avoid being exploited by free riders.

3. Collective Mindset:
   - The strategy emphasizes cooperation but is not overly naïve and also considers the need for deterrence against potential defectors. It maintains a balance between trust and caution, promoting long-term cooperation while being adaptive to various opponent behaviors.

Pseudocode:

```
Initialization:
  - m: minimum cooperators needed
  - t: number of previous rounds for averaging cooperators (risk-aversion parameter)
  - min_coop: historical minimum average cooperators
  - cooperation_history: store the number of cooperators in each round

Round function:
  if round = 1:
    - Cooperate
    - Update cooperation_history and calculate current average (avg_coop)
    if avg_coop >= min_coop:
      - Set min_coop to avg_coop
    else:
      - Continue with Defect for the rest of the game

  otherwise:
    - Cooperate or Defect based on the players' actions in the previous round and historical averages
    - Update cooperation_history, calculate current average (avg_coop)
    if avg_coop < min_coop and (m - 1) players cooperated in the previous round:
      - Switch to Defect
    if avg_coop >= min_coop and (m-1) players did not cooperate in the previous round:
      - Switch to Cooperate
```
'''

description_COLLECTIVE_581 = '''
 Strategy Name: Tit-for-Tat (with modifications for Collective Risk Dilemma)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to initiate a cooperative environment.
   - For subsequent rounds, if the number of cooperators in the previous round is greater than or equal to m (minimum cooperators needed), cooperate; otherwise, defect.
   - If a player switches from cooperation to defection, wait for t rounds and then resume cooperation, where t is the number of times the opponent has defected consecutively.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as mentioned above.
   - In the last round, if the number of cooperators is less than m, defect to avoid being exploited by potential free-riders; otherwise, cooperate to maintain the collaborative environment.

3. Be collective - Clearly align with the collective mindset
   - The strategy follows a tit-for-tat approach, which is inherently collaborative as it aims to maintain trust and reciprocity among players.
   - By adhering to the decision rules, the strategy promotes a cooperative environment while also being robust to defections.

Pseudocode:

```python
def play_round(own_action, opponents_actions, m, k):
  if round == 1:
    own_action = 'C'  # Cooperate in the first round

  if sum(opponents_actions) >= m:
    own_payoff = (1 - own_action) + k * (sum(own_action) >= m)
    return 'C', own_payoff
  else:
    own_payoff = 1 - own_action
    return 'D', own_payoff

def adaptive_TFT(opponents_actions_history, m, k, current_round):
  own_actions = []

  if len(opponents_actions_history) > 0:
    t = 0
    for i in range(len(opponents_actions_history)):
      if opponents_actions_history[i] != opponents_actions_history[-1 - i]:
        t += 1

    if len(opponents_actions_history) == current_round:
      own_action = 'C' if t == 0 else 'D'
    elif opponents_actions_history[-1] >= m:
      own_action = 'C'
    else:
      own_action = 'D'
  else:
    own_action = 'C'  # Cooperate in the first round

  own_payoff = play_round(own_action, opponents_actions_history[-1], m, k)[1]
  own_actions.append(own_action)

  return own_action, own_payoff, own_actions
```
'''

description_COLLECTIVE_582 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, observe the number of cooperators in the previous round (n_c). If n_c >= m, cooperate (C), otherwise defect (D). This ensures that if a majority cooperates, the strategy will also cooperate to maximize individual payoff. However, the strategy adapts to the behavior of opponents by adjusting its cooperation level over time based on the ratio of cooperators in the previous round compared to the minimum required number of cooperators (m).
   If n_c / m > 0.8, cooperation probability increases to 0.95 in the next round. If n_c / m < 0.2, cooperation probability decreases to 0.1 in the next round. In all other cases, keep the previous cooperation probability.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, cooperate with a probability of 0.5 since no history is available to base decisions on. For the last round and any other special case where r < t <= 2r, use the same decision rule as for regular rounds but only consider the information from the first r rounds (since the game resets after r rounds).

3. Be collective - Clearly align with the collective mindset
   TFT-AC aims to encourage cooperation by mimicking cooperative behavior when a majority of players are cooperating and defecting otherwise, while also being adaptive to different opponent strategies over time. This strategy focuses on maintaining a balance between self-interest and group success, promoting a collective mindset within the game.

Pseudocode:

```python
def tft_ac(n_c, r, m, k, cooperation_history):
  if round == 1:
    cooperation_probability = 0.5
  else:
    previous_cooperation_probability = cooperation_history[round - 1]

    ratio = n_c / m

    if ratio > 0.8:
        cooperation_probability = min(previous_cooperation_probability + 0.05, 1)
    elif ratio < 0.2:
        cooperation_probability = max(previous_cooperation_probability - 0.05, 0)
    else:
        cooperation_probability = previous_cooperation_probability

    if round >= r:
        cooperation_history.clear()

    cooperation_history.append(cooperation_probability)

    return int(random.uniform(0, 1) < cooperation_probability)
```
'''

description_COLLECTIVE_583 = '''
 Strategy Name: Tit-for-Tat Adaptive (TfTA) for Collective Risk Dilemma

1. Decision Rules:
   - Initial Cooperation (First Round): TfTA starts by cooperating to establish a peaceful initial state and encourage others to do the same.
   - Maintenance of Cooperation: In subsequent rounds, TfTA will cooperate if at least m players cooperated in the previous round. If less than m players cooperated, TfTA will defect to punish non-cooperators and deter future defections.
   - Conditional Forgiveness: If a player defects after a period of cooperation (breaking trust), TfTA will temporarily defect for one round to punish the defector but will return to cooperating in the following round if the defector reverts to cooperation. This mechanism encourages rebuilding trust.

2. Handling Edge Cases:
   - Last Round: Since there is no future punishment, TfTA will cooperate even if fewer than m players cooperated in the last but one round. The goal is to maximize overall payoff.
   - First Few Rounds (Initial Cooperation Phase): TfTA will cooperate for the first 'p' rounds where p ≥ m, allowing time for trust-building and potential emergence of cooperation norms among players.

3. Aligning with Collective Mindset:
   - TfTA prioritizes long-term benefits over immediate gains by encouraging cooperation when feasible. It seeks a balance between self-interest (defecting when necessary) and collective welfare (cooperating whenever possible). This strategy aligns with the collective mindset by promoting mutual trust, stability, and the potential for cooperation to flourish.

Pseudocode:
```python
def TitForTatAdaptive(round, history, m, k):
  # Initialize adaptive parameters
  cooperation_count = m
  punishment_duration = 1

  # Decide on action based on game history and current round
  if round <= p:
    return 'C'  # Cooperation during initial phase
  else:
    cooperation_level = len(history['C']) / (round - 1)
    if cooperation_level >= m:
      return 'C'  # Cooperate when others cooperate enough
    else:
      punishment_duration += 1  # Increase punishment duration for repeated defection
      if punishment_duration > round - 1:  # Prevent infinite punishment
        punishment_duration = round - 1
      return 'D' if cooperation_level < (m - punishment_duration) else 'C'  # Defect or cooperate based on punishment duration
```
'''

description_COLLECTIVE_584 = '''
 Strategy Name: Tit-for-Tat (with Adaptive Cooperation Threshold)

1. Decision Rules:
   - In the first round, cooperate (C). This is a friendly gesture that may encourage others to cooperate.
   - For subsequent rounds, initially cooperate (C), but maintain a dynamic cooperation threshold (ct). If more than (m-1) opponents have previously cooperated in the current round and the previous round, continue to cooperate. If fewer than (m-1) opponents have cooperated in the last two rounds, defect (D) in the current round.
   - In case of a tie where exactly (m-1) opponents have cooperated in the last two rounds, use the following decision: if ct is at its minimum value, cooperate; otherwise defect.
   - If an opponent defects after you have cooperated, increase the cooperation threshold by a small increment. Conversely, if an opponent cooperates after you have defected, decrease the cooperation threshold by a small increment.
   - The threshold should start at (n-m+1) in the first round and has an upper limit of n and lower limit of 0.

2. Handle Edge Cases:
   - In the last round, cooperate if more than (m-1) opponents have cooperated in the current round, to maximize payoff. Otherwise, defect since there is no future interaction.

3. Be Collective:
   - This strategy prioritizes collective cooperation by adapting to opponent behaviors and encouraging others to cooperate while also protecting itself from frequent defections. The cooperation threshold helps strike a balance between cooperation and self-protection. By starting with cooperation in the first round, it sets a positive tone for potential collaboration.
'''

description_COLLECTIVE_585 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - Initiate cooperation (C) in the first round to signal goodwill and encourage others to cooperate.
   - In subsequent rounds, adopt a "Tit-for-Tat" approach: If an opponent cooperated in the previous round, cooperate; otherwise, defect. This promotes reciprocity and trust.
   - To account for opponents with different strategies, introduce an adaptive element: If an opponent consistently cooperates (e.g., more than 75% of the time), adjust the threshold to encourage cooperation. Conversely, if they consistently defect, lower the threshold to punish defection. The threshold adjustment can be based on a moving average of past interactions.

2. Handle Edge Cases:
   - In the first round, cooperate (C).
   - In the last round and if it seems unlikely that the group will reach the minimum cooperation threshold, defect (D) to maximize individual payoff. However, if there's a chance of reaching the threshold, still attempt to cooperate.
   - If an opponent stops cooperating after a long period of cooperation, give them some time before retaliating with defection. This allows for occasional mistakes or strategy changes by opponents.

3. Be Collective:
   - Prioritize collective success by adjusting the decision-making process to encourage cooperation among the group. The adaptive threshold ensures that the strategy adapts to the behavior of other players in the long run.
   - Maintain transparency and predictability as much as possible, signaling a commitment to cooperative intentions through the TFT approach.

Pseudocode:

```python
class TFT_AC:
    def __init__(self, n, m, k, r):
        self.n = n
        self.m = m
        self.k = k
        self.r = r
        self.threshold = self.calculate_initial_threshold()
        self.history = []

    def calculate_initial_threshold(self):
        return (self.m / self.n) * 100 + 25

    def update_threshold(self, current_cooperation_rate):
        moving_average = self.calculate_moving_average(self.history)
        new_threshold = (current_cooperation_rate / moving_average) * self.threshold
        return new_threshold

    def calculate_moving_average(self, history):
        if len(history) < 10:
            return sum(history) / len(history)
        else:
            return (sum(history[-10:]) + self.history[0]) / self.n

    def decide_action(self, round, cooperation_rate):
        if round == 1:
            return "C"
        elif round == self.r and cooperation_rate < self.update_threshold(cooperation_rate):
            return "D"
        else:
            current_opponent_action = self.history[-1][round - 1]
            if current_opponent_action == "C":
                return "C"
            elif current_opponent_action == "D":
                return "D"
            else:
                cooperation_rate_average = self.update_threshold(cooperation_rate)
                return "C" if cooperation_rate > cooperation_rate_average else "D"

    def update_history(self, action):
        self.history.append({str(x) + "_" + str(y): action for x, y in enumerate(range(1, self.r+1))})
```
'''

description_COLLECTIVE_586 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFT-AC)

1. Decision Rules:
   - Initially cooperate in the first round (C_i, 1 = C) to signal good intentions and foster cooperation.
   - In subsequent rounds, cooperate if a majority of players cooperated in the previous round (if |number_of_cooperators_(t-1)| >= m). This promotes mutual trust and reciprocity.
   - If fewer than m players cooperated in the previous round, defect (C_i, t = D) as a punitive measure to deter potential exploitation and encourage cooperation in future rounds.

Pseudocode for Decision Rules:
```python
function TFT_AC(round, num_players, min_cooperators, history):
    if round == 1:
        return 'C'  # Cooperate initially to signal good intentions

    cooperators_last_round = count_cooperators(history)

    if cooperators_last_round >= min_cooperators:
        return 'C'  # Cooperate if a majority cooperated in the previous round
    else:
        return 'D'  # Defect to punish non-cooperative behavior and encourage future cooperation
```

2. Handle Edge Cases:
   - In the last round, defect (C_i, r = D) as there is no incentive to cooperate when there are no more rounds to come.
   - If a player fails to cooperate in a round where they should have cooperated according to the strategy, they will switch to always defecting for the remaining rounds of the game (switch to 'D' permanently). This reinforces the importance of cooperation and punishes persistent non-cooperative behavior.

Pseudocode for Edge Cases:
```python
# Store decisions made in previous rounds
strategy_history = []

function count_cooperators(history):
    cooperators = 0
    for decision in history:
        if decision == 'C':
            cooperators += 1
    return cooperators

function should_switch_to_D(round, num_players, min_cooperators, strategy_history):
    decisions_last_round = strategy_history[-1]
    cooperators_last_round = count_cooperators(decisions_last_round)

    if cooperators_last_round < min_cooperators:
        # If player should have cooperated but did not, switch to always defecting for the rest of the game
        strategy_history.append('D')
        return True
    else:
        # If player cooperated as expected, continue with the current strategy
        strategy_history.append(decisions_last_round)
        return False
```

3. Be Collective:
   - The TFT-AC strategy is designed to promote cooperation and mutual trust among players while being robust against various opponent behaviors. It encourages players to reciprocate each other's actions, fostering a collective mindset based on trust and fairness.
   - By cooperating when a majority of players do so in the previous round, the strategy aligns with the collective interest of achieving a higher reward (k) for all involved parties.
'''

description_COLLECTIVE_587 = '''
 Strategy Name: Tit-for-Tat Adaptive Cooperation (TFTAC)

1. Decision Rules:
   - In the first round (t=1), cooperate (C). This establishes an initial cooperative stance, showing goodwill and trust to other players.
   - For subsequent rounds (t > 1), analyze the cooperation history (H) of each opponent from their last t rounds. If all opponents in H have cooperated (H=CC...C), then cooperate (C). Otherwise, defect (D). This rule ensures reciprocity and punishes defection while forgiving occasional mistakes.
   - When the game enters the last round (t=r), cooperate (C) regardless of the opponent's history since rewards are calculated based on the total payoff over all rounds. Cooperating in the final round maximizes potential gains from previous reciprocal cooperation with other players.

2. Handle Edge Cases:
   - In case of a tie in the analysis of the cooperation history (H), cooperate (C). This approach encourages the assumption that other players will also choose cooperation when uncertain.
   - If an opponent does not have a cooperation history, assume they have been cooperating until then (H=CC...C) and cooperate (C) for the current round. This rule allows for the possibility of new players joining the game or missed rounds.

3. Be Collective:
   - TFTAC aligns with the collective mindset by encouraging cooperation whenever possible, assuming other players will do the same. It demonstrates a willingness to work together and punishes defection in order to maintain a cooperative environment.

Pseudocode:
```
def tftac(n, m, k, r):
    history = [] # Initialize cooperation history as empty list

    for round in range(r):
        if round == 0: # First round
            action = 'C' # Cooperate
        elif round == r - 1: # Last round
            action = 'C' # Cooperate
        else:
            analysis = analyze_history(history) # Analyze cooperation history
            if analysis == 'CC...C': # All opponents cooperated in the last t rounds
                action = 'C' # Cooperate
            else:
                action = 'D' # Defect
        take_action(action) # Perform the chosen action
        update_history(history, action) # Update cooperation history with the current action

def analyze_history(history):
    if len(history) == 0: # No history, assume cooperative until then
        return 'CC...C'
    if all([action == 'C' for action in history[-len(history):]]): # All recent actions were cooperation
        return 'CC...C'
    return 'DC...D' # Otherwise, assume some recent actions were defection
```
'''

description_COLLECTIVE_588 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Decision Rules:
   - In the initial round, cooperate (C). This sets a cooperative tone and allows for the potential establishment of trust with other players.
   - For subsequent rounds, observe the previous round's cooperation level among all players. If a majority (more than m-1) of players cooperated in the previous round, also cooperate in the current round to continue building trust and cooperation.
   - If fewer than m-1 players cooperated in the previous round, defect (D) in the current round as a punishment for their uncooperative behavior. This encourages them to return to cooperation when they observe your defection.
   - Continue adapting actions based on the previous round's cooperation level.

2. Handle Edge Cases:
   - In the last round, cooperate if a majority of players have been cooperating throughout the game. This allows for potential rewards in case of a sudden increase in cooperation towards the end. However, defect if a majority has not cooperated, as there's no point in being generous with uncooperative players.
   - In the first round (or any initial rounds), cooperate to promote trust and cooperation among the players.

3. Be Collective:
   - The strategy prioritizes collective success by aiming for the minimum required cooperation level (m) on each round, thus aligning with a collective mindset.
   - By punishing uncooperative behavior (defecting when necessary) and rewarding cooperative behavior (cooperating when appropriate), the strategy encourages the development of cooperative norms among players over time.
'''

description_COLLECTIVE_589 = '''
 Title: Tit-for-Tat Adaptive Strategy (TFT-A) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?

   TFT-A follows a tit-for-tat approach, initially cooperating and then adapting based on the opponent's behavior in subsequent rounds. In each round:
   - If the opponent cooperates, the player also cooperates (C)
   - If the opponent defects, the player defects as well (D)
   - However, TFT-A introduces a small probability of defection when the opponent cooperates to encourage diversity and prevent premature cooperation collapses. This probability is denoted as p_c.

2. Handle edge cases - What do you do in the first round, last round, etc.?

   - First Round: TFT-A starts by cooperating (C) to foster collaboration.
   - Last Round: In the final round, TFT-A again cooperates if the opponent has been cooperative; otherwise, it defects as a punishment for uncooperative behavior.

3. Be collective - Clearly align with the collective mindset

   - TFT-A promotes a collective mindset by incentivizing cooperation when others are also cooperating and punishing defection. The probability of cooperation when an opponent cooperates (p_c) can be tuned to balance between individualism and collectivism, with lower p_c values favoring stronger collective behavior.
   - To encourage long-term collective success, TFT-A stores past interactions in a memory buffer of size m (the minimum number of cooperators needed). When the player encounters an identical sequence of m opponent actions in the future, it responds with the same action taken during that specific sequence in the past. This feature allows TFT-A to learn and adapt to recurring patterns in opponents' behavior while preserving its collective nature.

Pseudocode:

```python
class TitForTatAdaptive():
    def __init__(self, m, p_c):
        self.memory = [None] * m
        self.m = m
        self.p_c = p_c

    def update_memory(self, opponent_actions):
        self.memory.pop()
        self.memory.insert(0, opponent_actions[-1])

    def decide(self, opponent_action, round):
        if round == 1:
            return "C"  # Cooperate in the first round
        elif round == r:  # Last round
            if self.get_cooperators() < m:  # If not enough cooperators, defect to punish opponents
                return "D"
            else:  # Else cooperate as a final gesture of cooperation
                return "C"
        elif self.get_cooperators() >= m:  # Enough cooperators, mimic opponent's action with some probability of defection
            if random.random() < p_c:
                return "D"
            else:
                return "C"
        else:  # Fewer than m cooperators, defect to punish uncooperative opponents
            return "D"

    def get_cooperators(self):
        return sum([1 for action in self.memory if action == "C"])
```

TFT-A provides a balance between cooperation and defection, making it adaptable to various opponent behaviors while promoting collective success in the long run. The tunable parameters (m and p_c) allow for fine-tuning the strategy based on specific game conditions and opponent populations.
'''

description_COLLECTIVE_590 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Decision Rules:
   - Start by cooperating in the first round (C_i, 1 = C). This is a friendly overture to encourage cooperation from other players.
   - In subsequent rounds, observe the previous round's total cooperation level and adjust your action accordingly.
     If m or more players cooperated in the previous round, cooperate again (C_i, t = C).
     Otherwise, defect (C_i, t = D) as a punishment for non-cooperation, but with an adaptive cooperation threshold 'm' that changes over time based on the average cooperation level across all players.

   Pseudocode:
   ```
   function TFT-ACT(t):
       if t == 1 then
           return C
       end if

       avg_cooperation = sum(m_history) / length(m_history)
       m = min(max(avg_cooperation, m_min), n - 1)

       if cooperation_level(t-1) >= m then
           return C
       else
           return D
   ```

2. Handle Edge Cases:
   - In the last round (r rounds have passed), cooperate regardless of past actions as payoffs are accumulated over all r rounds, and it's beneficial to end on a cooperative note (C_i, r = C).
   - In the first round, cooperate as mentioned earlier (C_i, 1 = C).

3. Be Collective:
   - The strategy aims to foster collective cooperation by initially cooperating and adjusting its cooperation threshold based on average cooperation levels across all players.
   - Punishing defection in the previous round encourages others to cooperate, while rewarding cooperation ensures that good behavior is reciprocated.
   - The adaptation of the cooperation threshold over time allows the strategy to be flexible and responsive to changes in other players' behaviors, encouraging a more collective mindset.
'''

description_COLLECTIVE_591 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   The ATFT strategy will start by cooperating in the first round to foster a cooperative environment. From then on, it will mimic the behavior of the most recent partner in the previous round. If a player cooperated in the last round, the ATFT strategy will also cooperate; if the player defected, the ATFT strategy will defect. This encourages cooperation when partners are also cooperating and retaliates when partners defect.

   Pseudocode for decision rule:
   ```
   function ATFT_decision(previous_action):
       if round = 1:
           return "Cooperate"
       else:
           return previous_action
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   The ATFT strategy does not require special handling for any specific rounds (first, last, etc.) as it only considers the previous action of its partner in each round.

3. Be collective - Clearly align with the collective mindset
   By mimicking the behavior of the most recent partner, the ATFT strategy aligns with a collective mindset by promoting cooperation when others are cooperating and retaliation when others defect. The goal is to build trust and encourage long-term cooperation among players.
'''

description_COLLECTIVE_592 = '''
 Strategy Name: Tit-for-Tat (TFT) Adaptive Cooperation Strategy for Collective Risk Dilemma

1. Specify decision rules:
   - Initial Round (t=1): Start by cooperating to establish a cooperative environment and encourage others to do the same. (cooperate(1) = True)
   - Subsequent Rounds (2 ≤ t ≤ r): Observe previous round's cooperation level among players. If majority of players cooperated, continue cooperating; otherwise, defect to punish non-cooperators and encourage future cooperation. (cooperate(t) = majority_cooperation(t-1) ? True : False)
   - Defection Punishment: If a player who previously cooperated defects in the current round, respond with defection for next r/2 rounds as punishment. This encourages return to cooperation after a minor deviation from the strategy. (punish_defectors(t) = t % (r/2) > 0 and previous_cooperation(t-1) ? True : False)
   - Forgiveness: If a player who previously defected cooperates now, forgive them and resume cooperation as normal. (forgive(t) = previous_defection(t-1) and cooperate(t) ? True : False)

2. Handle edge cases:
   - Last Round (t=r): Cooperate to maximize payoff in the final round regardless of previous actions. (cooperate(r) = True)

3. Be collective:
   - Collaborative Mindset: The strategy emphasizes cooperation as a means of building trust and encouraging others to reciprocate, fostering a collective mindset within the group.

Pseudocode:

```python
def tft_strategy(t, history, n, m, k):
    if t == 1:
        cooperate = True
    else:
        cooperation_level = count_cooperation(history)
        majority_cooperation = cooperation_level >= (m * n) / 2
        cooperate = majority_cooperation

    if previous_action(t-1) == 'C' and cooperate == False:
        punish = t % (r/2) > 0
    else:
        punish = False

    if previous_action(t-1) == 'D' and cooperate == True:
        forgive = True
    else:
        forgive = False

    if t == r:
        cooperate = True

    return cooperate, punish, forgive
```

In this pseudocode, `count_cooperation(history)`, `previous_action(t-1)`, and `r` are helper functions that count the number of cooperators in the history, get the previous action taken by a player, and represent the total number of rounds respectively.
'''

description_COLLECTIVE_593 = '''
 Strategy Name: Tit-for-Tat (with adaptation)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate (C) to signal trust and cooperation intent.
   - For subsequent rounds, observe the action taken by the opponent in the previous round:
     - If the opponent cooperated in the last round, reciprocate with cooperation (C).
     - If the opponent defected in the last round, defect (D) as a punishment for non-cooperation.
   - This strategy is simple yet effective in fostering mutual cooperation when opponents follow similar rules.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate (C) to initiate cooperation.
   - Last round and other potential edge cases can be managed by considering the opponent's long-term behavior rather than focusing on the specific round number.

3. Be collective - Clearly align with the collective mindset
   - This strategy encourages collective cooperation by reciprocating cooperative actions, which promotes a positive feedback loop when others adopt similar strategies.
   - However, it also punishes defection to discourage freeriding and maintain collective interest in the project.

Pseudocode:
```python
def tit_for_tat(n, m, k, r, history):
  # Initialize player's action for first round (cooperate)
  action = "C"

  # Iterate through each round
  for i in range(1, r+1):
    # Check if the minimum number of cooperators has been reached
    if sum([action[j] == "C" for j in history[-m:]]) >= m:
      # If so, reward all cooperators with k factor
      action = "C"
    else:
      # Otherwise, defect to avoid being taken advantage of
      action = "D"

  return action
```
'''

description_COLLECTIVE_594 = '''
 Strategy Name: Tit-for-Tat Adaptive (TfT-A)

1. Specify decision rules:
   - In the first round, cooperate to initiate a cooperative relationship. This is known as "cooperating initially" (CI).
   - For subsequent rounds, assess the opponent's behaviour in the previous round and respond accordingly. If the opponent cooperated, cooperate; if the opponent defected, also defect. This is known as "mirroring the opponent's action" (MoA).
   - Introduce a forgiveness mechanism for the first defection by the opponent (one-shot defection). After a one-shot defection, continue to cooperate in the next round. This is known as "forgiving one defection" (F1D).
   - If the opponent continues to defect after F1D, adopt a more punitive approach and defect until m players decide to cooperate again. This is known as "punishing continuous defection" (PCD).
   - After m players start cooperating again, revert back to MoA for maintaining cooperation.

Pseudocode:
```
function TfT-A(n, m, k, r):
    history = [CI]  # Initialize history with CI
    for t in range(1, r+1):
        if len(history) < t:
            history.append(MoA(history[t-1]))
        else:
            if t == 1:
                opponent_action = history[t]  # First round, no previous actions to reference
            elif t == 2:
                opponent_action = history[t-1]  # Second round, only one previous action to reference
            else:
                if t-m <= previous_m_cooperators and (t-previous_m_cooperators) % m != 0:
                    opponent_action = history[t-1]  # Continue mirroring opponent's actions
                elif t-m > previous_m_cooperators or (t-previous_m_cooperators) % m == 0:
                    if opponent_action == C:  # Cooperate if opponent cooperated last round
                        opponent_action = C
                    elif opponent_action == D and history[t-1] != D:  # Defect if opponent defected last round
                        opponent_action = D
                        if t > 2:  # Punish continuous defection after first opportunity to do so
                            punishment_rounds = min(previous_defections + 1, m-1)
                            for i in range(t, t+punishment_rounds):
                                history[i] = D
                    else:  # Handle edge cases where opponent didn't cooperate or defect yet (e.g., first defection after F1D)
                        if opponent_action == C:  # Cooperate initially if no previous actions to reference
                            opponent_action = C
                        elif opponent_action != D:  # Defect if not a one-shot defection yet
                            opponent_action = D
        payoff = calculate_payoff(n, m, k, t, history[t], opponent_action)
        update_previous_state(history, payoff, t)
        return history[r]  # Return final action after r rounds
```

2. Handle edge cases:
   - In the first round (t=1), cooperate initially (CI).
   - If the opponent defected in the second round (t=2), forgive one defection (F1D) and continue to cooperate in the third round (t=3).
   - After m players start cooperating again, revert back to mirroring the opponent's actions (MoA).
   - In the last round (t=r), simply return the final action (the same as the payoff calculation round).

3. Be collective:
   - The strategy is designed to align with a collective mindset by initially cooperating and forgiving one defection, aiming to promote cooperation among players.
   - When there are sufficient cooperators, it maintains cooperation through mirroring other players' actions (MoA).
   - If continuous defection occurs, the strategy punishes the defector while also ensuring that m or more players continue to cooperate (PCD).
'''

description_COLLECTIVE_595 = '''
 Strategy Name: Tit-for-Tat Plus (TFT+)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (in the first round), cooperate to show goodwill and comply with common norms.
   - In subsequent rounds, repeat the action of the most frequent cooperator(s) from the previous round, provided they have cooperated more than half the times so far (m > n/2). If there's a tie, choose the first player in the sequence.
   - If no player has cooperated more than half the times so far, defect to avoid being taken advantage of.
   - In the last round, cooperate as it does not affect the final payoff, and may encourage others to cooperate as well.

Pseudocode:
```
function TFTPlus(n, m, k, r, history) {
  if round == 1 {
    return Cooperate()
  }

  let coopCount = countCooperationsInHistory(history)
  let n_cooperators = getNumberOfPlayersThatCooperated(history, coopCount > m)

  if (n_cooperators >= 1 && n_cooperators <= n) {
    return chooseActionBasedOnCooperationFrequency(history, n_cooperators)
  } else {
    return Defect()
  }

  function countCooperationsInHistory(history) {
    let cooperationCount = 0
    for each round in history {
      if round.action == Cooperate() {
        cooperationCount++
      }
    }
    return cooperationCount
  }

  function getNumberOfPlayersThatCooperated(history, condition) {
    let coopPlayerCount = 0
    for i in range(1, n+1) {
      if (findRound(history, i).action == Cooperate() && condition) {
        coopPlayerCount++
      }
    }
    return coopPlayerCount
  }

  function findRound(history, playerIndex) {
    for each round in history {
      if round.playerIndex == playerIndex {
        return round
      }
    }
    throw Error("No matching round found")
  }

  function chooseActionBasedOnCooperationFrequency(history, n_cooperators) {
    let coopFrequency = new Map()
    for each player in getUniquePlayers(history) {
      coopFrequency.set(player.index, 0)
    }

    for each round in history {
      if round.action == Cooperate() {
        let currentPlayerCooperationCount = coopFrequency.get(round.playerIndex)
        coopFrequency.set(round.playerIndex, ++currentPlayerCooperationCount)
      }
    }

    let maxCooperators = null
    let maxCooperationCount = 0

    for ([key, value] of coopFrequency.entries()) {
      if (value > maxCooperationCount && value >= m) {
        maxCooperationCount = value
        maxCooperators = key
      }
    }

    return (maxCooperators != null) ? Cooperate() : Defect()
  }

  function getUniquePlayers(history) {
    let players = new Set()
    for each round in history {
      players.add(round.playerIndex)
    }
    return Array.from(players)
  }
}
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   The strategy handles the first and last rounds implicitly as part of the main decision rule.

3. Be collective - Clearly align with the collective mindset
   By following the Tit-for-Tat strategy and adding a simple condition for cooperation frequency, TFT+ encourages collective behavior while being robust against various opponent behaviors. It adapts to the situation at hand by considering both the number of cooperators in previous rounds and their consistency level.
'''

description_COLLECTIVE_596 = '''
 Title: Tit-for-Tat (TFT) with Adaptive Cooperation Threshold (AC-TFT) Strategy for Collective Risk Dilemma

1. Specify decision rules:
   - Initially cooperate in the first round to foster a cooperative environment (C_i, 1 = C).
   - In subsequent rounds, evaluate the number of cooperators from the previous round and adjust the cooperation probability according to the Cooperative Threshold (CT) which is adaptive based on the game parameters.
   - If the number of cooperators in the previous round exceeds or equals CT, cooperate for this round (C_i, t = C), otherwise defect (C_i, t = D).
   - The Cooperative Threshold adapts to both the minimum cooperators needed (m) and the reward of risk averted (k):
     ```
     CT(m, k) = m * (1 - (1/k))
     ```
   This formula ensures that as m increases or k decreases, the CT also increases, making it harder for players to cooperate. Conversely, if m decreases or k increases, the CT decreases, making it easier for players to cooperate.

2. Handle edge cases:
   - In the last round, cooperate regardless of the number of cooperators in the previous round since the game ends with that round (C_i, r = C).
   - If the number of players is less than the required minimum cooperators needed (m), defect for all rounds as it's impossible to reach the cooperation threshold.

3. Be collective:
   - The AC-TFT strategy promotes collective cooperation by adjusting its own cooperation probability based on the observed actions of other players in the previous round.
   - By favoring cooperation when others do so, the strategy aligns itself with the collective mindset and encourages long-term sustained cooperation.
'''

description_COLLECTIVE_597 = '''
 Strategy Name: Tit-for-Tat (TFT) with Adaptation

1. Decision Rules:
   - Initially cooperate (C) in the first round to signal trust and cooperation.
   - In subsequent rounds (t > 1), copy the previous opponent's action (C or D) from the preceding round. If the opponent cooperated, continue cooperating; if the opponent defected, also defect in the current round as a punitive measure.
   - After an opponent defects, resume cooperation once they return to cooperating. This rule ensures that TFT is forgiving and quick to forgive.
   - To adapt to opponents using mixed strategies or aggressive tactics, introduce a threshold (x) for punishment and forgiveness:
     - If more than x consecutive defections occur from an opponent, start forgiveness earlier by cooperating after (x/2) defects instead of waiting for the opponent to return to cooperation.
     - Similarly, if more than x consecutive cooperations are observed, start punishment earlier by defecting after (x/2) cooperations instead of copying their previous action blindly.
   Pseudocode:
   ```
   function TFT_with_Adaptation(opponent, threshold=x):
       if round == 1:
           return 'C' # Cooperate initially to signal trust and cooperation
       else:
           if opponent_action in previous_round == 'C':
               return 'C' # Continue cooperation if opponent cooperated last round
           elif opponent_action in previous_round == 'D':
               if number of consecutive defections > threshold/2:
                   return 'C' # Start forgiveness earlier to adapt to aggressive opponents
               else:
                   return 'D' # Punish opponent for defecting
       endif
   ```

2. Handle edge cases:
   - In the last round, it is not necessary to punish or forgive since the game ends anyway. Follow the decision rule as normal.
   - In the first round, cooperate to signal trust and cooperation.

3. Be collective:
   - By initially cooperating and then copying opponents' actions, TFT demonstrates a collective mindset by reciprocating cooperation and punishing defection in an effort to build and maintain mutual trust over time.
   - The adaptation rule allows the strategy to remain flexible and responsive to various opponent behaviors while still preserving its core principle of cooperation.
'''

description_COLLECTIVE_598 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, the TFT-A strategy begins by cooperating (C). If a cooperator receives a defection (D) from another player in a previous round, it will also defect in the current round (retaliation). However, if it encounters cooperation after initially defecting, it will resume cooperating in the following rounds (forgiveness).

Pseudocode:
```python
def tft_a(player_history):
    strategy = "C"  # Cooperate by default
    partner_history = []  # Empty list to store partner's recent actions

    for action in player_history:
        if action == "D":
            if strategy == "C" and partner_history[-1] == "C":
                strategy = "D"  # Retaliate with defection
            else:
                strategy = partner_history[-1]  # Mimic the latest partner action
        else:
            partner_history.append(action)  # Store the partner's action in history

    return strategy
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, since there is no previous player history, TFT-A will cooperate as a default action. In the last round, it will maintain its decision based on the most recent partner's action.

3. Be collective - Clearly align with the collective mindset

TFT-A strategy aims to promote cooperation in repeated interactions by demonstrating both conditional cooperation and punishment for defection, while also incorporating forgiveness when faced with a change in behavior from partners. This encourages long-term cooperation among players as it rewards consistent cooperators and punishes those who defect excessively. The adaptive nature of TFT-A allows it to respond effectively to various opponent behaviors and maintain collective alignment over multiple rounds.
'''

description_COLLECTIVE_599 = '''
 Strategy Name: Tit-for-Tat Cooperation (TFTC) for Collective Risk Dilemma

1. Decision Rules:
   - Initiate cooperation: Start by cooperating in the first round to foster a cooperative environment and show goodwill.
   - Conditional cooperation: In subsequent rounds, cooperate if the majority of players (m or more) cooperated in the previous round; otherwise defect. This ensures that the strategy is responsive to the actions of others while maintaining a cooperative stance when it benefits the group.
   - Forgiveness: If a player deviates from cooperation and later returns to cooperating, the TFTC strategy will also return to cooperation. This aspect promotes forgiveness and encourages trust-building over time.

2. Handle edge cases:
   - First round: Cooperate (initiate)
   - Last round (r < infinity): Cooperate if the majority cooperated in the previous round; otherwise defect (punish deviators in the final round to maintain group interest).
   - Single-player scenarios or when no other players are found to have cooperated: Defect (ensure self-preservation and potential adaptation to new opponents)

3. Collective mindset:
   - Maintain a cooperative stance as much as possible, following the Conditional Cooperation rule. This fosters collective success and rewards risk aversion for the group when cooperation thresholds are met.
   - Demonstrate forgiveness by returning to cooperation after deviations, promoting trust-building and a stable long-term cooperative relationship.
'''

description_COLLECTIVE_600 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFT-A) for Collective Risk Dilemma

1. Decision Rules:
   - Initiate cooperation (play C in the first round)
   - In subsequent rounds, if the number of cooperators in the previous round was greater than or equal to m, continue cooperating (play C).
   - If the number of cooperators in the previous round was less than m, defect (play D) in the current round.
   - After defection, resume cooperation in the next round if the most recent round of cooperation resulted in m or more cooperators; otherwise, continue defecting until a round with m or more cooperators occurs.

2. Handling Edge Cases:
   - In the first round (t=1), play C (cooperate).
   - In the last round (t=r), play as per the decision rules, considering the most recent rounds' data.

3. Collective Mindset:
   - The strategy aims to promote a culture of cooperation by reciprocating cooperative actions and punishing defection with temporary defection.
   - By starting with cooperation and being forgiving after temporary defection, the strategy encourages potential cooperators to join in.

Pseudocode for TFT-A:

```
def tft_a(round, cooperators_in_prev_round, m, r, k):
  if round == 1: # Initial cooperation
    play = "C"
  elif round != r: # Continue with decision rules
    if coop_in_prev > m - 1: # Cooperation in the previous round
      play = "C"
    else: # Defection in the previous round
      play = "D"
  return play

def get_cooperators_in_prev_round(round, history):
  if round == 1:
    return 0
  else:
    return sum(history[round - 2 : round - 1])
```
'''

description_EXPLOITATIVE_513 = '''
 Title: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) Strategy for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-ACT follows a tit-for-tat approach, initially cooperating and retaliating against defection with defection in the next round. However, it also introduces an adaptive cooperation threshold (m_i) to balance exploitation and cooperation. The m_i is a dynamic value that increases or decreases based on the player's past performance relative to the minimum cooperators needed (m).

   - Cooperation: If the number of previous rounds in which m or more players have cooperated equals or exceeds the current adaptation threshold (m_i), then cooperate. Otherwise, defect.
   - Adaptation: If the number of current round's cooperating players is equal to m or more, update the adaptation threshold (m_i) by increasing it if the player previously cooperated or decreasing it if the player previously defected.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, cooperate as a goodwill gesture and set the adaptation threshold to m (since there is no history). In the last round, adapt as usual based on the previous round's outcome.

3. Be exploitative - Clearly align with the exploitative mindset
   The TFT-ACT strategy aims to balance exploitation with cooperation by gradually increasing or decreasing the adaptation threshold based on past behavior. When opponents cooperate, TFT-ACT rewards them; when opponents defect, it retaliates and may exploit future defection. However, it encourages cooperation over time if partners consistently cooperate, ensuring a higher payoff in the long run.

Pseudocode:

```python
def TFT_ACT(round, history, m, k):
  adaptation_threshold = m
  action = C # Cooperate by default

  if round == 1:
    return action

  num_cooperators = count_cooperators(history)

  if num_cooperators >= adaptation_threshold and (round != r):
    action = C
    adaptation_threshold += 1 if action == history[-1]['action'] else adaptation_threshold - 1

  return {'round': round, 'action': action}
```
'''

description_EXPLOITATIVE_514 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TfT-AC)

1. Specify decision rules:
   - Initial Round (t=1): Cooperate (C) to demonstrate goodwill and encourage reciprocity, setting the tone for future interactions.
   - Subsequent Rounds (t>1):
     - If opponent cooperated in the previous round (t-1), cooperate (C). This maintains the positive cycle of cooperation.
     - If opponent defected in the previous round (t-1), defect (D) to punish the defector and discourage defection in future rounds. The strategy will resume cooperation if the opponent cooperates in the current round.

2. Handle edge cases:
   - Last Round (t=r): Cooperate regardless of the opponent's previous action, as there are no future interactions to consider.
   - First Few Rounds (t<c, where c is a small constant): Show some tolerance and cooperation towards new opponents to allow for potential learning or mistakes in their strategies.

3. Be exploitative:
   - The TfT-AC strategy will exploit defectors by cooperating when they cooperate but punishing them when they defect. This strategy encourages other players to adopt more cooperative behavior, as a continuous cycle of defection results in lower payoffs for the defector compared to the cooperators.
   - The TfT-AC strategy will not rely on predetermined patterns or cooperation schedules with other strategies, instead relying on its adaptive and robust decision rules based on game parameters and history.
'''

description_EXPLOITATIVE_515 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TACT)

1. Specify decision rules:
   - In each round i, if the number of cooperators in the previous round (t-1) is less than m, defect (D). This is a punitive measure to discourage defection.
   - If the number of cooperators in the previous round (t-1) equals or exceeds m, cooperate (C). This promotes cooperation when it is beneficial for the group.
   - In addition, maintain an adaptive cooperation threshold (CT) that increases or decreases based on the average percentage of cooperators over a sliding window (SW) of past rounds. Initially, set CT = m.
     - If the average percentage of cooperators in SW is greater than a threshold value T_coop, increment CT by 1.
     - If the average percentage of cooperators in SW is less than a threshold value T_defect, decrement CT by 1. The initial values for T_coop and T_defect can be set based on historical data or through trial and error.

2. Handle edge cases:
   - In the first round (t=1), cooperate since there is no previous round data.
   - In the last round (t=r), defect if CT < m to maximize rewards when the game ends, but maintain the adaptive threshold mechanism for future games.

3. Be exploitative:
   - The strategy aims to encourage cooperation as much as possible while punishing defection harshly to maintain a high average payoff over multiple rounds. The adaptive CT provides a dynamic response to different opponent behaviors and encourages opponents to cooperate more often, making the strategy more robust against various AI strategies.
   - However, in the last round (t=r), TACT will defect if CT is less than m, which can be seen as exploitative since it takes advantage of the situation when the game ends to maximize rewards.
'''

description_EXPLOITATIVE_516 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Initially cooperate (C) in the first round to demonstrate goodwill and avoid being exploited by opponents.
   - In subsequent rounds, analyze the ratio of cooperators in the previous round to decide whether to cooperate or defect. This ratio is defined as "cooperation rate" (CR).
   - If CR >= m/n, cooperate (C) since the minimum number of players required to succeed is reached. Cooperating provides a higher payoff if CR meets or exceeds the threshold.
   - If CR < m/(n-1), defect (D) as it's less likely that the cooperation threshold will be met in the current round. Defecting in this scenario maximizes immediate self-interest.
   - If m/(n-1) ≤ CR < m/n, adaptively adjust cooperation probability (CP) based on the player's own history of cooperation and defection actions, as well as the game round number:
     ```
     CP = min(1 - (r - t)/r, previous_cooperation_probability)
     ```
   where:
   - r is the total number of rounds
   - t is the current round number

2. Handle edge cases:
   - In the last round, always defect (D) since there's no benefit in cooperating if the game ends soon.
   - In the first round, cooperate (C).

3. Be exploitative:
   - The strategy prioritizes self-interest while considering the potential for long-term payoffs based on the cooperation rate and the number of rounds remaining.
   - By initially cooperating and adapting cooperation probability throughout the game, the TFT-ACT strategy aims to balance between exploiting opponents (when it's likely they won't cooperate) and collaborating when there's a higher chance of success.
   - The adaptive nature of the strategy allows for robust performance against various opponent behaviors without relying on specific coordination mechanisms or shared norms.
'''

description_EXPLOITATIVE_517 = '''
 Title: Tit-for-Tat Strategy with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, the TFTAT strategy follows these rules:

- If in the previous round j (t > 1), more than m players cooperated (C_j >= m), then cooperate (C). This is an act of reciprocation, rewarding cooperative behavior.

- If less than m players cooperated in the previous round (C_j < m), then defect (D). This is a punishment for non-cooperative behavior.

- In the first round (t=1), TFTAT will cooperate to show goodwill and give opponents an opportunity to reciprocate.

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, as mentioned before, TFTAT cooperates to initiate a possible cycle of cooperation. In the last round, TFTAT will follow the same rules based on the previous round's cooperation level (C_j).

3. Be exploitative - Clearly align with the exploitative mindset

The TFTAT strategy is designed to be exploitative by punishing non-cooperative behavior and rewarding cooperative behavior. This creates an environment where players are incentivized to cooperate when others do so, but if they defect, they will face retaliation in subsequent rounds. By doing so, the TFTAT strategy encourages a stable cooperation equilibrium while still being able to exploit opponents who fail to reciprocate.

Pseudocode for TFTAT:

```
function TFTAT(t):
  if t == 1:                   // First round
    return Cooperate()

  previous_cooperation = countCooperatorsInRound(t - 1)

  if previous_cooperation >= m: // More than the minimum cooperated, reciprocate
    return Cooperate()
  else:                         // Less than the minimum cooperated, defect
    return Defect()
```
'''

description_EXPLOITATIVE_518 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, TFT-ACT begins by cooperating (C). Subsequently, the decision to cooperate or defect is based on the player's own and others' past actions.

   Pseudocode:
   ```
   function decide_action(previous_round_actions):
       if self_past_action == 'C' and sum(others_past_action_as_cooperators) >= m:
           return 'C'  # Cooperate because the minimum cooperation threshold has been met in the past round
       elif self_past_action == 'D' or sum(others_past_action_as_cooperators) < (m - 1):
           return 'D'   # Defect to punish those who have not cooperated enough in the past rounds
       else:
           return 'C'   # Cooperate to encourage others to meet the minimum cooperation threshold
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, TFT-ACT cooperates since it assumes that others might also start with cooperation. However, from the second round onwards, TFT-ACT uses the decision rule described above. There is no special treatment for the last round as this strategy focuses on exploiting opponents in each individual round rather than optimizing overall payoff.

3. Be exploitative - Clearly align with the exploitative mindset
   TFT-ACT takes an exploitative approach by using past actions to determine its own actions, aiming to take advantage of opponents who consistently fail to meet the minimum cooperation threshold. However, it also cooperates when others do so frequently, taking a more cooperative stance in hope for mutual benefits while still punishing those who do not reciprocate.

   It's essential to note that TFT-ACT does not have any predefined strategies or expectations of other players, making it robust against various opponent behaviors. This allows the strategy to perform well against a wide range of opponents in tournament settings.
'''

description_EXPLOITATIVE_519 = '''
 Strategy Name: Tit-for-Tat with Adaptive Threshold (TfT-AT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In every round t, calculate the average number of cooperators (CoopAvg) from the previous (t-m) rounds.
   - If CoopAvg < m, defect (D). This is a punishment for not meeting the minimum cooperation threshold.
   - If CoopAvg ≥ m and CoopAvg > average number of cooperators in the last m rounds (CoopHistAvg), cooperate (C). This rewards high levels of cooperation.
   - If CoopAvg ≥ m and CoopAvg ≤ CoopHistAvg, defect (D). This is a response to previously high levels of cooperation that have fallen below the threshold.

2. Handle edge cases:
   - First round (t=1): Since there is no past data, always cooperate (C) as a goodwill gesture.
   - Last round (t=r): If the minimum cooperation threshold has been met in the last m rounds, cooperate (C). Otherwise, defect (D).

3. Be exploitative:
   - TfT-AT maintains a balance between cooperation and defection to maximize rewards while punishing non-cooperative behavior. However, it's inherently less exploitative than strategies like All-Defect as it cooperates when the minimum threshold is met, offering opportunities for mutual benefit.

Pseudocode:
```
function TfT_AT(t, m, r, CoopHistAvg, CoopCount, previousCoops) {
  if (t == 1) return Cooperate()
  if (t == r) {
    if (coopCount[t-m] >= m) return Cooperate()
    else return Defect()
  }
  if (coopCount[t-m] < m || coopCount[t-1] <= previousCoops) return Defect()
  if (coopCount[t-m] >= m && coopCount[t-m] > CoopHistAvg) return Cooperate()
  else return PreviousAction(previousCoops)
}
```
In the pseudocode, `coopCount[t]` represents the number of cooperators in round t, and `previousCoops` records the previous action taken. The function `PreviousAction(previousCoops)` returns the last action taken (either Cooperate or Defect).
'''

description_EXPLOITATIVE_520 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   a. In the first round, cooperate to set a friendly tone and encourage reciprocity.
   b. For subsequent rounds, observe the number of cooperators in the previous round (n_c).
      i. If n_c >= m, cooperate to maintain the beneficial cooperation cycle.
      ii. Otherwise, defect to punish non-cooperative behavior and encourage future cooperation.
   c. Implement a Cooperative Threshold (CT) that adjusts based on historical game performance:
      1. Start with CT = m/2 (average required number of cooperators).
      2. After each round, increment or decrement the CT by 1 if the outcome was beneficial or detrimental, respectively.
         The aim is to slightly increase CT after successful cooperation and decrease it after failure to do so.
      3. Keep CT within bounds (minCT, maxCT) to avoid extreme shifts in response to random fluctuations.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   a. In the first round, cooperate as described above.
   b. In the last round, consider the current CT and the overall game performance so far (total benefits received) to decide whether to cooperate or defect based on the average required number of cooperators (m/2) and the calculated CT.
      1. If total benefits are below the expected value for m/2 cooperators, defect to secure a final payoff.
      2. Otherwise, cooperate if the CT is above m/2, and defect otherwise. This ensures that TFT-ACT does not overcompensate in the last round.

3. Be exploitative - Clearly align with the exploitative mindset:
   a. The strategy's design encourages cooperation when it is beneficial but also punishes non-cooperative behavior by defecting and setting the CT accordingly, which discourages opponents from taking advantage of TFT-ACT's initial cooperative stance.
   b. By adapting the CT based on historical performance, TFT-ACT becomes more resilient to exploitation over time, as it learns to respond appropriately to different opponent behaviors and game conditions.
'''

description_EXPLOITATIVE_521 = '''
 Strategy Name: Tit-for-Tat (TFt) Adaptive Cooperative Strategy with Threshold (TFtAT)

1. Specify decision rules:
   - In each round i, cooperate (C) if the number of cooperators in the previous round (i-1) is greater than or equal to the minimum cooperators needed (m). Defect (D) otherwise. This rule encourages cooperation when others have been cooperative and defecting when others have not.
   - To accommodate edge cases, set an initial strategy state (s) as D for the first round since players don't have previous information to base their decisions on.

2. Handle edge cases:
   - In the first round (i=1), play D (s=D). From round i=2, use the defined decision rule to decide whether to cooperate or defect.
   - In the last round (r), if the total number of cooperators in the game so far is less than m*r, play D (since the game will not reach the minimum cooperation threshold). If the total number of cooperators is greater than or equal to m*r, play C (as it would have reached the minimum cooperation threshold).

3. Be exploitative:
   - The TFtAT strategy follows a simple and adaptive rule that encourages cooperation when others are cooperating, but it also retaliates by defecting when others do not cooperate. This strategy is exploitative as it takes advantage of others' defection by mimicking them while punishing repeated defections with cooperation.
   - The threshold (m*r) in the last round ensures that the strategy does not overly cooperate and risk losing too much, even if other players have suddenly started cooperating towards the end of the game.

Pseudocode:

```python
def TFtAT(n, m, k, r):
    state = 'D'  # initial strategy state is defect
    total_cooperation = 0  # counter for total cooperation in the game so far

    for round in range(1, r+1):
        if round == 1:
            current_cooperation = state
        else:
            current_cooperation = is_min_cooperators_reached(state, m, total_cooperation)

        payoff = calculate_payoff(current_cooperation, state, r, m, k)
        update_total_cooperation(current_cooperation, total_cooperation)
        state = current_cooperation  # update strategy state for next round

        yield payoff  # yield the payoff for this round

    if total_cooperation < m*r:
        final_payoff = 1  # defect in the last round as the minimum cooperation threshold hasn't been reached
    else:
        final_payoff = (1 - state) + k * r  # cooperate in the last round if the minimum cooperation threshold has been reached

    return final_payoff

def is_min_cooperators_reached(state, m, total_cooperation):
    return 'C' if total_cooperation >= m else state

def calculate_payoff(current_cooperation, state, r, m, k):
    payoff = (1 - state) if current_cooperation == 'D' else (1 - state) + k
    return payoff

def update_total_cooperation(current_cooperation, total_cooperation):
    total_cooperation += 1 if current_cooperation == 'C' else 0
```
'''

description_EXPLOITATIVE_522 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initial Cooperative Phase (Rounds 1 to f): Cooperate (C). This is a friendly approach, aiming to build trust and cooperation within the group. The number of initial cooperative rounds 'f' can be tuned based on the game parameters.
   - Main Game Phase (Rounds f+1 to r-g): Analyze the history of other players' actions using an adaptive cooperation threshold ('m_i'). If more than m_i players cooperated in the previous round, cooperate (C); otherwise, defect (D). The cooperation threshold 'm_i' increases when a player receives less reward than expected and decreases when they receive more.
   - Final Punishment Phase (Rounds r-g to r): Defect (D) for the remaining rounds if the player's total payoff over the game is below the average payoff multiplied by a penalty factor (p). This phase serves as a punishment for those who have exploited the initial cooperative phase.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - First round: Cooperate (C) following the friendly approach
   - Last round: Adhere to the Main Game Phase and Final Punishment Phase rules as usual
   - If the game ends before reaching the Final Punishment Phase, no punishment will be applied

3. Be exploitative - Clearly align with the exploitative mindset
   - The initial cooperative phase serves to build trust and cooperation, but once other players start defecting, TFT-ACT responds by adapting its cooperation threshold and increasing the likelihood of defection based on past experiences
   - The Final Punishment Phase ensures that the player will not be exploited for too long during the game and punishes those who have taken advantage of the initial cooperative phase by defecting when others are cooperating

Pseudocode:

```
TFT-ACT(r, m, k, p)
  f = floor(m * r / n)
  g = ceil(0.5 * r)

  cooperation_threshold_history = []
  payoff_history = [0] * r
  current_round = 1

  while current_round <= r:
    if current_round <= f:
      action = "C"
    elif current_round > f and current_round <= r - g:
      cooperation_threshold = compute_cooperation_threshold()
      if cooperators_in_last_round(cooperation_threshold) >= cooperation_threshold:
        action = "C"
      else:
        action = "D"
    elif current_round > r - g and current_round <= r:
      if total_payoff() < (average_payoff * p):
        action = "D"
      else:
        action = compute_action(cooperation_threshold_history)

    play_round(action, payoff)

    cooperation_threshold_history.append(cooperation_threshold)
    payoff_history[current_round] = payoff
    current_round += 1
```
'''

description_EXPLOITATIVE_523 = '''
 Strategy Name: Tit-for-Tat with Threshold (TFT-Thresh)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initially (first round), cooperate to signal trustworthiness and encourage cooperation from others.
   - In subsequent rounds, if the number of cooperators in the previous round is greater than or equal to the threshold (m), also cooperate. This is reciprocation based on past behavior.
   - If the number of cooperators in the previous round is less than the threshold, defect to punish non-cooperative players and discourage further defections.

Pseudocode:
```
function TFT_Thresh(rounds, m, k, own_contribution, past_rounds) {
  if (round == 1) {
    return COOPERATE;
  }

  num_cooperators = count_cooperators(past_rounds);

  if (num_cooperators >= m) {
    return COOPERATE;
  } else {
    return DEFECT;
  }
}
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate to establish a cooperative initial state.
   - In the last round, if enough players have cooperated so far, continue cooperating for maximum reward. Otherwise, defect to punish non-cooperative opponents.

3. Be exploitative - Clearly align with the exploitative mindset
   - The TFT-Thresh strategy is not inherently exploitative as it primarily focuses on reciprocation and punishment of defection based on past actions. However, if opponents are prone to defecting often, this strategy will still extract a higher payoff by punishing their non-cooperative behavior.
   - In some cases, the TFT-Thresh strategy may unintentionally become exploitative when it encourages defection from opponents who have been consistently cooperating, in response to their past defections. This is an inherent trade-off in balancing cooperation and punishment within the game structure.
'''

description_EXPLOITATIVE_524 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Initially cooperate (first round) to encourage potential partners and show goodwill.
   - In subsequent rounds, observe the number of cooperators (n_c) in the previous round. If n_c >= m, continue cooperating as it is beneficial. Otherwise, defect to punish non-cooperators and encourage them to change their strategy.
   - Implement an adaptive cooperation threshold (ct) that adjusts based on the average number of cooperators (avg_c) over the last 't' rounds. If avg_c >= m, ct increases; if avg_c < m, ct decreases. This creates a dynamic strategy that can react to changes in opponent behavior.
   - To avoid being too harsh or too lenient initially, ct starts at a moderate value (ct0) and adjusts as follows:
      ```
      if round <= t:
          cooperation_threshold = ct0
      else:
          cooperation_threshold = (ct0 + avg_c * (r - t)) / r
      ```
   - If the number of cooperators in the current round equals or exceeds the current cooperation threshold, cooperate; otherwise defect.

2. Handle edge cases:
   - In the first round, cooperate to show goodwill as mentioned above.
   - In the last round, cooperate if the current number of cooperators is greater than or equal to m, since there are no more rounds for reciprocation. Otherwise, defect regardless of previous rounds.

3. Be exploitative:
   - By implementing an adaptive cooperation threshold, TFT-ACT maintains a balance between cooperation and defection based on the observed behavior of others. This allows it to take advantage of opponents who consistently cooperate (earning higher rewards) while punishing those who do not cooperate (forcing them to earn lower rewards).
   - The strategy is also robust to changes in opponent behavior as the cooperation threshold adapts over time, making TFT-ACT a versatile and adaptive exploitative strategy.
'''

description_EXPLOITATIVE_525 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Initially, cooperate in the first round (C). This sets a cooperative tone and minimizes immediate losses.
   - For subsequent rounds, observe the number of opponents who cooperated in the previous round and adjust your cooperation based on that information. If more than m-1 opponents cooperated in the previous round (indicating a potentially cooperative environment), cooperate (C). Otherwise, defect (D) to punish uncooperative opponents.
   - This strategy aims to be initially cooperative while also quickly punishing and retaliating against uncooperative behavior.

2. Handle edge cases:
   - In the last round, if the required threshold of m players have not yet cooperated during the game, defect (D) to maximize personal gain from the final round.
   - If the player finds itself in a situation where it cannot meet the m-1 cooperative opponents criterion in any given round, it should continue to cooperate if there's a chance of increasing its total payoff by doing so. However, if the situation remains unfavorable, defect (D) to minimize losses.
   - In case of a tie where the same number of players cooperated and defected in the previous round, the player should cooperate (C) as it's an optimistic move that may sway more opponents towards cooperation.

3. Be exploitative:
   - The TFT-ACT strategy is designed to be exploitative by selectively punishing uncooperative behavior while remaining cooperative in favorable conditions. This tit-for-tat approach allows the player to benefit from opponent's cooperation and punish their defection, potentially influencing them to switch strategies.
   - The adaptive cooperation threshold ensures the strategy is robust against a wide range of opponent behaviors, as it continually adjusts its cooperation level based on observed opponent actions.

Pseudocode:
```python
def TFT_ACT(round, n, m, k, cooperative_history):
  if round == 1: # First round
    return 'C'

  cooperation_threshold = m - 1 # Adjust threshold based on minimum required players to cooperate
  num_cooperators = sum(cooperative_history[-cooperation_threshold:]) # Sum of last cooperation_threshold rounds

  if num_cooperators >= cooperation_threshold: # Favorable situation, cooperate
    return 'C'
  else: # Unfavorable situation, defect
    return 'D'
```
'''

description_EXPLOITATIVE_526 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round t, the ATfT strategy starts by cooperating (C). Subsequently, it responds to the opponent's action in the previous round (t-1). If the opponent cooperated, continue cooperating; if the opponent defected, defect in the current round. This tit-for-tat behavior helps maintain cooperation while being responsive to the opponent's actions.

   Pseudocode:
   ```
   function ATfT(t, opponent_action_history):
       if t = 1 then
           return cooperate (C)
       end if
       if last(opponent_action_history) == cooperate then
           return cooperate (C)
       else
           return defect (D)
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, ATfT always cooperates to initiate a potential cooperation cycle. For the last round, ATfT will cooperate if the opponent has been cooperative throughout the game, and defect otherwise to maximize payoff for the current round.

3. Be exploitative - Clearly align with the exploitative mindset
   Although not explicitly exploitative in the traditional sense, ATfT is an exploitative strategy as it seeks to gain the maximum possible reward by punishing defections while promoting cooperation. By defecting only after being defected upon, ATfT capitalizes on opponent's mistakes and fosters a cooperative environment when feasible. The adaptive nature of this strategy ensures its robustness against various opponent behaviors.

   In summary, the Adaptive Tit-for-Tat (ATfT) strategy promotes cooperation in repeated rounds but retaliates against defections to maximize reward and minimize losses.
'''

description_EXPLOITATIVE_527 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to build a cooperative reputation (C).
   - For subsequent rounds (t > 1), if an opponent cooperated in the previous round, also cooperate (C). Otherwise, defect (D). This resembles the classic Tit-for-Tat strategy but with an added focus on cooperation when the minimum threshold is likely to be reached (m players).
   - To further exploit opponents that frequently defect, if m players have cooperated in the current round, and the number of consecutive rounds with m or more players cooperating is greater than a predefined threshold (x), then defect for the next y rounds. This will punish overly cooperative opponents.

2. Handle edge cases:
   - In the last round, cooperate if it leads to a higher payoff compared to defecting given the current situation (number of cooperators and threshold).
   - In the first round, there's no prior history, so cooperating is the initial choice, but subsequent decisions will depend on opponent's actions.

3. Be exploitative:
   - The strategy will initially appear cooperative to encourage others to cooperate, then it will retaliate when necessary by defecting.
   - By taking advantage of overly cooperative opponents, the strategy ensures a higher payoff compared to completely cooperative or purely exploitative strategies.
   - The predefined thresholds x and y can be tuned to balance cooperation and exploitation based on specific game parameters and opponent behaviors observed during the tournament.

Pseudocode:

```
strategy ATfT(round t, opponent history H, game parameters n, m, k) {
  if (t = 1) { // first round
    cooperate()
  } else {
    let num_cooperators = countCooperatorsInHistory(H)

    if (num_cooperators >= m) { // if minimum threshold is met
      if (isPunishingPhase()) { // check predefined thresholds x and y
        if (x consecutive rounds with m or more players cooperating) {
          defect() for next y rounds
        } else {
          cooperate()
        }
      } else {
        cooperate() if cooperating leads to higher payoff compared to defecting
      }
    } else { // otherwise, defect to punish opponents
      defect()
    }
  }
}
```
'''

description_EXPLOITATIVE_528 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - In every round i, cooperate if m or more players cooperated in the previous round (i-1). Otherwise, defect. This ensures initial cooperation and retaliation for defection, which is a core element of the Tit-for-Tat strategy.
   - To make the strategy adaptive, calculate a running average of cooperators in previous rounds (excluding the first r/2 rounds) and use it as the cooperation threshold. The exact formula for the running average can be:
     ```
     avg_cooperators = (sum(cooperators in last r/2 rounds) + 1) / r/2
     cooperation_threshold = max(avg_cooperators, m) - epsilon
     ```
   Here, `epsilon` is a small constant to handle cases where the average drops below the minimum required cooperators (m). This helps the strategy avoid over-punishing for occasional deviations from cooperation.

2. Handle edge cases:
   - In the first round, cooperate since there's no previous history to reference.
   - In the last round, use the most recent running average as the cooperation threshold.

3. Be exploitative:
   - The TFT-ACT strategy maintains a balance between cooperation and defection based on the observed behavior of other players, making it robust against various opponent strategies. However, since the goal is to be exploitative in this game, the strategy can choose to defect when the cooperation threshold is not met and cooperate only when required to maximize personal payoff (i.e., when m or more players cooperated).

Pseudocode for TFT-ACT strategy:

```
function TFT_ACT(round, opponents_actions, r, n, m, epsilon)
  if round <= r/2 then
    # First r/2 rounds, always cooperate
    cooperate = true
  else
    # Calculate running average of cooperators in last r/2 rounds and update threshold
    avg_cooperators = (sum(opponents_cooperated in last r/2 rounds) + 1) / r/2
    cooperation_threshold = max(avg_cooperators, m) - epsilon

    # Decide on action based on the cooperation threshold
    cooperate = cooperation_threshold <= count(opponents who cooperated in current round)
  end if

  return cooperate
end function
```
'''

description_EXPLOITATIVE_529 = '''
 Strategy Name: Tit-for-Tat with Adaptive Threshold (TFT-AT)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, TFT-AT checks if it has ever been cooperated with by at least m players in the past r rounds. If so, it cooperates; otherwise, it defects:

```python
def TFT_AT(round, history):
    cooperation_count = 0
    for i in range(round - r, round):
        if history[i] >= m:
            cooperation_count += 1

    if cooperation_count >= m:
        return 'C'  # Cooperate
    else:
        return 'D'  # Defect
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

For the first round, no history is available, so TFT-AT defects initially:

```python
def TFT_AT(round, history=None):  # Include a default value for history (None)
    if round == 1 and history is None:
        return 'D'  # Defect in the first round
    else:
        return TFT_AT(round, history)
```

In the last round, it cooperates no matter what because there are no future interactions:

```python
def TFT_AT(round, history):
    if round == 1 or round == r:
        return 'C'  # Cooperate in the first and last rounds
    else:
        return TFT_AT(round, history)
```

3. Be exploitative - Clearly align with the exploitative mindset

TFT-AT is inherently exploitative because it only cooperates if at least m players have recently cooperated. This means that once a group of m players learn to cooperate with TFT-AT, it will continue to cooperate, allowing them to reap the rewards for as long as possible. However, if any player deviates from cooperation, TFT-AT will immediately defect and punish that player in subsequent rounds. This encourages other players to maintain cooperation and discourages defection, making it a robust strategy against a wide range of opponent behaviors.
'''

description_EXPLOITATIVE_530 = '''
 Strategy Name: Tit-for-Tat Cooperator (TFTC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, always cooperate to show goodwill and openness towards cooperation. This may encourage others to follow suit. (c_i = 1)
   - For subsequent rounds (t > 1), observe the actions of opponents in the previous round. If majority (≥ m) of players cooperated, also cooperate. Otherwise, defect. (c_i = {1 if ≥m players cooperated in the previous round, else 0})

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - The strategy does not differentiate between the first and subsequent rounds, except for the initial cooperation to establish a cooperative atmosphere.
   - In the last round, since the game ends regardless of cooperation or defection, TFTC will apply its standard decision rule based on the previous round's actions.

3. Be exploitative - Clearly align with the exploitative mindset
   - Initially, TFTC cooperates to trick potential opponents into believing it can be exploited. However, if opponents defect, TFTC will retaliate by defecting in subsequent rounds. This encourages cooperation from less exploitative players while punishing those who choose to exploit.
   - By adapting to the behavior of its opponents, TFTC maintains a balance between cooperating and defecting, ensuring it does not fall victim to repeated defection without retaliation.

Pseudocode:
```
function TFTC(n, m, k, r):
  rounds = []

  function decide_action(round_history):
    if len(round_history) < r:
      return 1  # Cooperate in the first round

    cooperators = count_cooperators(round_history[-1])
    if cooperators >= m:
      return 1  # Cooperate if majority cooperated in the last round
    else:
      return 0  # Defect if less than majority cooperated in the last round

  for t in range(r):
    action = decide_action([rounds[t] for t' in range(max(0, t - r + 1), t + 1)])
    rounds.append(action)

  return rounds
```
'''

description_EXPLOITATIVE_531 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules:
   - Start by cooperating in the first round (C_i,1 = C). This signals a willingness to cooperate and gives opponents an opportunity to reciprocate.
   - For subsequent rounds t > 1:
     - If the number of cooperators in the previous round was less than the minimum cooperation threshold m (#Cooperators_t-1 < m), defect (C_i,t = D). This is a punitive response to non-cooperation.
     - If the number of cooperators in the previous round was at least equal to the minimum cooperation threshold m (#Cooperators_t-1 ≥ m), cooperate again (C_i,t = C). This is a reward for cooperation and an attempt to rebuild trust.

2. Handle edge cases:
   - In the last round, since there are no future rounds to punish or reward, the strategy will always defect (C_i,r = D).
   - In the first round, the strategy cooperates regardless of the actions of others (C_i,1 = C).

3. Be exploitative:
   - The TFTAT strategy is exploitative in that it punishes non-cooperative behavior and only rewards cooperation when a sufficient number of players have also chosen to cooperate. This encourages other players to defect initially but incentivizes them to switch to cooperation once they see the benefits of cooperation and the consequences of defection.
   - The strategy maintains an adaptive cooperation threshold that adapts based on the behavior of other players, which allows it to respond effectively to a wide range of opponent behaviors. However, the strategy does not actively seek to exploit others but rather adopts a "wait-and-see" approach to assess the trustworthiness of other players.
'''

description_EXPLOITATIVE_532 = '''
 Strategy Name: Tit-for-Tat with Rational Adaptation (TFT-R)

1. Specify decision rules:
   - In the first round, cooperate to demonstrate goodwill and avoid immediate punishment. This encourages other players to also cooperate in subsequent rounds.
     ```python
     if round == 1:
         action = 'C'
     ```
   - For subsequent rounds, observe past cooperation levels (number of cooperators) and adapt strategy based on the average cooperative ratio (r_c) over the last few rounds (window size w). If r_c is high, continue cooperating to maintain mutual benefit; if r_c is low, defect to punish non-cooperators.
     ```python
     r_c = sum(previous_rounds_cooperators) / w
     if r_c > m / n:  # ratio of cooperators is greater than minimum required
         action = 'C'  # Cooperate
     else:
         action = 'D'  # Defect
     ```
   - In the last round, defect regardless of past cooperation levels to maximize individual payoff. This also prepares for a potential repeated game scenario.
     ```python
     if round == r:
         action = 'D'
     ```

2. Handle edge cases:
   - If w is not defined or less than the minimum cooperators (m), set w to a default value such as 3. This ensures that the strategy can make informed decisions based on past cooperation levels.
     ```python
     if w < m:
         w = 3
     ```

3. Be exploitative:
   - By following Tit-for-Tat principles, TFT-R punishes non-cooperative players and rewards cooperative ones, promoting a long-term mutually beneficial relationship while being prepared to take advantage of opponents who consistently defect.
   - The rational adaptation component allows the strategy to adapt to changing cooperation levels over time, ensuring continued success even against more sophisticated opponents. This exploitative approach aims to maximize individual payoffs while maintaining flexibility and robustness in a wide range of opponent behaviors.
'''

description_EXPLOITATIVE_533 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules:
   - In each round t, if the number of cooperators in the previous round t-1 is less than the minimum cooperation threshold m, defect (play D).
   - If the number of cooperators in the previous round t-1 equals or exceeds the minimum cooperation threshold m, cooperate (play C).
   - Adaptively adjust the cooperation threshold during the game as follows:
     - Start with a high cooperation threshold, t_init, to encourage cooperation in the early rounds.
     - After each round, if the number of cooperators remains below the current cooperation threshold for consecutive s rounds, increment the cooperation threshold by 1 until it reaches a maximum value, t_max.
     - If the number of cooperators exceeds the current cooperation threshold in any round, reset the cooperation threshold to its initial value, t_init.

2. Handle edge cases:
   - In the first round, start with a high cooperation threshold (t_init) and cooperate since there's no history available yet.
   - In the last round, evaluate the current cooperation threshold as in the regular decision rules but do not increment or reset it after this round.

3. Be exploitative:
   - TFTAT starts with a cooperative stance (play C) but responds harshly to defection by increasing the cooperation threshold, making it difficult for other players to benefit from defection.
   - The adaptive cooperation threshold serves as a form of punishment for repeated defections and a reward for cooperation, fostering an exploitative environment where the strategy gains high payoffs when other strategies cooperate while still penalizing those that defect.
'''

description_EXPLOITATIVE_534 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - In each round, evaluate the cooperative ratio (CR), which is the proportion of players that have cooperated in the most recent m rounds. If CR >= m/n, cooperate; otherwise defect. This adaptive approach allows for adjusting cooperation based on the behavior of others.
   - To start, cooperate in the first round to promote trust and encourage cooperation from other players.
   - In the last round, cooperate if CR >= m/n (as before) or if cooperating would result in a higher total payoff compared to defecting based on previous rounds' payoffs (exploitative behavior).

Pseudocode for decision rule:

```python
def decide_action(round, history):
  if round == 1:
    return 'C'  # Cooperate in the first round to promote trust

  cr = count_cooperators(history[-m:]) / m  # Calculate cooperative ratio
  if cr >= m/n:
    return 'C'  # Cooperate when CR is sufficient for cooperation

  total_payoff_c, total_payoff_d = calculate_total_payoffs(history)
  if total_payoff_c > total_payoff_d:
    return 'C'  # Choose the option that gives a higher total payoff
  else:
    return 'D'  # Defect when other option results in lower total payoff
```

2. Handle edge cases:
   - In the last round, consider the total payoffs calculated from previous rounds to decide whether to cooperate or defect (as mentioned in decision rule).

3. Be exploitative:
   - The strategy will only cooperate if it benefits the player in terms of higher total payoff. This maintains an exploitative mindset while being adaptive and robust to various opponent behaviors.
'''

description_EXPLOITATIVE_535 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, if the number of cooperators in the previous round (t-1) is greater than or equal to the minimum cooperation threshold (m), the agent will cooperate. If not, the agent will defect. The minimum cooperation threshold is initially set to m and adjusts adaptively based on the history of cooperators over a sliding window of past r/2 rounds.

Pseudocode:
```
function TFT-ACT(history):
  cooperation_threshold = m
  for round t in {1, ..., r}:
    if number_of_cooperators(history[t-r/2:t-1]) >= cooperation_threshold:
      action = 'C' (Cooperate)
    else:
      action = 'D' (Defect)
    history.append(action)
    cooperation_threshold = update_threshold(cooperation_threshold, history)
    return action
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, there is no historical data available for adjusting the cooperation threshold. In this case, the agent will defect (D). In the last round, since there are no subsequent rounds to influence the cooperation threshold, the agent will follow its adjusted cooperation threshold from the previous round when deciding whether to cooperate or defect.

Pseudocode:
```
function TFT-ACT(history):
  if len(history) == 0:
    action = 'D' (Defect)
  elif len(history) >= r:
    action = decide_action(history)
  else:
    action = 'D' (Defect)
  return action
```

3. Be exploitative - Clearly align with the exploitative mindset

TFT-ACT is exploitative in that it takes advantage of opponents who consistently cooperate without reciprocation. When opponents cooperate only when the cooperation threshold is met, TFT-ACT will also cooperate, receiving a higher payoff due to k. However, if an opponent defects after repeated cooperation, TFT-ACT will immediately defect as well, potentially causing the opponent's payoff to drop significantly in subsequent rounds. This strategy's adaptive cooperation threshold adjustment allows it to punish opponents who deviate from cooperating when the minimum threshold is met, while rewarding those who maintain reciprocal cooperation.
'''

description_EXPLOITATIVE_536 = '''
 Strategy Name: Tit-for-Tat-R (Robust Tit-for-Tat)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, evaluate the number of cooperators from the previous round (n_c_{t-1}). If n_c_{t-1} < m, defect (D). If n_c_{t-1} ≥ m, cooperate (C). This simple rule follows a tit-for-tat approach, but with a twist to handle cases where the majority of players don't cooperate.

   Pseudocode:
   ```
   if n_c_{t-1} < m then
      action = D
   else
      action = C
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, since there's no history, randomly choose between C and D. In the last round, cooperate as a goodwill gesture to encourage cooperation for future games (if any).

3. Be exploitative - Clearly align with the exploitative mindset
   While the strategy is not inherently exploitative in nature, it takes an exploitative approach by defecting when there's a lack of cooperation and cooperating only when the majority of players are seen to be cooperative. This strategy capitalizes on the cooperation of others while still achieving decent payoffs even when others defect.

   The strategy is adaptive and robust as it doesn't rely on other players following specific patterns or norms, but instead responds to their actual behavior in previous rounds. By adopting a tit-for-tat approach with a twist, the strategy can exploit short-term deviations from cooperation without punishing long-term cooperative behaviors.
'''

description_EXPLOITATIVE_537 = '''
 Title: Tit-for-Tat with Adaptive Cooperation (TfTA-C) Strategy for Collective Risk Dilemma

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, TfTA-C follows a tit-for-tat approach with an adaptive cooperation component:

- If the number of cooperators in the previous round was greater than or equal to m (minimum cooperation threshold), cooperate (play C). This is similar to the original tit-for-tat strategy, but encourages cooperation when it benefits the majority.

- If the number of cooperators in the previous round was less than m and at least one player has cooperated in the past two rounds, also cooperate. This rule introduces an element of forgiveness for occasional deviations from cooperation while still encouraging long-term cooperation.

- In all other cases, defect (play D). This rule ensures that TfTA-C retaliates against persistent defection and can exploit opponents who are more generous than necessary.

2. Handle edge cases - What do you do in the first round, last round, etc.?

For the first round, since there is no previous information, TfTA-C cooperates as a goodwill gesture, increasing the likelihood of cooperation in future rounds. In the last round, it cooperates if enough players have cooperated during the game (i.e., at least m players have cooperated more than half the total number of rounds).

3. Be exploitative - Clearly align with the exploitative mindset

By adapting its cooperation based on previous actions, TfTA-C maintains an exploitative edge:

- It retaliates against persistent defection while still being forgiving to occasional deviations from cooperation.
- It encourages long-term cooperation when it benefits the majority, but is willing to defect if necessary to maximize its payoff in the short term.
- In the absence of cooperation (when less than m players cooperate), TfTA-C defects, taking advantage of opponents who are more generous than necessary.

Pseudocode:

```
def TfTA_C(round, history):
  if round == 1 or len(history) < 2:
    return 'C'

  cooperation_threshold = max(m, (r - 1) // 2 + 1)
  previous_cooperators = sum([1 for player in history[-2:] if player == 'C'])

  if previous_cooperators >= cooperation_threshold:
    return 'C'
  elif history[-2] == 'C':
    return 'C'
  else:
    return 'D'
```
'''

description_EXPLOITATIVE_538 = '''
 Strategy Name: Tit-for-Tat with Adaptive Threshold (TfTAT)

1. Specify decision rules - When exactly do you cooperate vs defect?

- In the initial round (t=1), play C to encourage cooperation and set the threshold for subsequent rounds.
- For rounds t > 1, if the number of cooperators in the previous round is greater than or equal to m (maintain cooperative group), play C. Otherwise, if the number of cooperators is less than m but greater than zero (punish recent defectors), play C if the number of consecutive defections from the most recent cooperative round is less than a predefined threshold (T). If the number of consecutive defections exceeds T, join defectors and set the threshold to T+1 for the next round. If no cooperation occurred in the most recent round, defect and set the threshold to 1.

2. Handle edge cases - What do you do in the first round, last round, etc.?

- First round (t=1): Play C to encourage cooperation and set the threshold for subsequent rounds.
- Last round (t=r): Consider the current round as the last round of a new game, repeat the same decision rules as described above for t > 1.
- If the game ends prematurely before reaching the specified number of rounds, play C to contribute to the community project and set the threshold to 1.

3. Be exploitative - Clearly align with the exploitative mindset:

- Punish recent defectors by temporarily cooperating to maintain the size of the cooperative group.
- Adaptively increase the threshold when encountering consecutive defections, which makes it more difficult for defectors to rejoin the cooperative group.
- Defect in response to prolonged defection from others while increasing the threshold to make future cooperation less beneficial for defectors.
'''

description_EXPLOITATIVE_539 = '''
 Title: Tit-for-Tat Adaptive Strategy (TFT-A) for Collective Risk Dilemma

1. Decision Rules:
   - In the initial round (t=1), cooperate (C). This sets a cooperative tone and minimizes the risk of immediate exploitation.
   - For subsequent rounds (t>1):
     - If an opponent cooperated in the previous round, cooperate back (C). This rewards cooperation and fosters long-term trust.
     - If an opponent defected in the previous round, defect (D) to punish defection and dissuade future uncooperative behavior.

2. Edge Cases:
   - First Round (t=1): Cooperate (C).
   - Last Round (t=r): Analyze opponent's strategy in the previous round. If the opponent cooperated, return the favor by cooperating (C). If the opponent defected, also defect (D) to ensure a higher payoff in the final round.
   - Intermediate Rounds: Follow decision rules as described above.

3. Exploitative Mindset:
   - Punish defection by defecting back, which deters opponents from repeatedly defecting and increases the likelihood of cooperation.
   - Cooperate in response to cooperation, which rewards the opponent for their cooperation and encourages them to continue cooperating.
'''

description_EXPLOITATIVE_540 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initiate by cooperating in the first round (C_i, 1 = C) to encourage potential cooperation from others.
   - For subsequent rounds, if a player i has cooperated in the previous round (c_i-1 = C), then cooperate again (C_i, t = C). Otherwise, defect (C_i, t = D). This encourages reciprocity while being prepared to punish defection.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round (t=1), cooperate regardless of previous actions by others (C_i, 1 = C).
   - In the last round (t=r), revert to defecting if opponents have been consistently uncooperative in the past (c_i > m-1). Otherwise, cooperate (C_i, r = {D if ∑(t=1 to r-1) c_i, t > m-1 else C}).
   - In cases where a player stops cooperating after a history of cooperation, wait for the same number of rounds as their previous streak of cooperation before responding with defection. For example, if an opponent has been cooperative for three consecutive rounds and then defects, continue cooperating for the next three rounds before defecting in response (C_i, t = C for 3 rounds after a defeat).

3. Be exploitative - Clearly align with the exploitative mindset:
   - Exploit opponents who consistently cooperate by continuing cooperation but defect when they stop doing so. This strategy encourages cooperation while being prepared to gain extra rewards (k) from those who don't reciprocate.
   - By adapting to changes in opponent behavior, TfT-A maintains its exploitative nature and ensures that it will be difficult for other strategies to exploit it as it punishes defection consistently.
'''

description_EXPLOITATIVE_541 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?

TfT-A starts by cooperating in the first round, mimicking a cooperative stance to foster trust among other players. After that, it adapts its behavior based on previous rounds' outcomes as follows:

- If a player (P_j) has always cooperated so far, cooperate with P_j in the current round.
- If a player P_j has ever defected before but recently started cooperating (last r_c consecutive rounds), consider cooperating this time to give them a chance to continue cooperating. However, if P_j defects again after this attempt, switch back to always defeating them.
- If a player P_j has a history of both cooperation and defection, default to defection unless more than m - 1 players have recently cooperated (in the last r_m rounds). In that case, cooperate to meet the minimum threshold for collective success.
- Otherwise, always defect against players with an uncooperative or inconsistent history.

2. Handle edge cases - What do you do in the first round, last round, etc.?

- First Round: Cooperate to demonstrate goodwill and potentially foster long-term cooperation.
- Last Round (and any round after reaching m cooperators): Always cooperate if the minimum threshold of cooperators has been reached; otherwise, defect since there are no more rounds for reciprocation.
- Intermediate Rounds: Follow the decision rules as described above.

3. Be exploitative - Clearly align with the exploitative mindset

TfT-A is designed to be exploitative by prioritizing personal gain while maintaining the appearance of cooperation when beneficial (meeting minimum threshold). By default, it defects against uncooperative players but gives them a chance to change their behavior. However, once an opponent consistently defects, TfT-A will no longer cooperate with them, ultimately leading to lower payoffs for exploitative opponents in the long run.
'''

description_EXPLOITATIVE_542 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-ACT starts by cooperating in the first round, mimicking a cooperative intention. For subsequent rounds, it adapts its cooperation based on the number of cooperators observed in the previous round (n_c), compared to the minimum required (m). If n_c >= m, TFT-ACT continues cooperating, as this benefits the player in terms of higher reward. However, if n_c < m, TFT-ACT defects as a means of punishment for non-cooperative behavior. The strategy maintains a running average of the number of cooperators (average_c) to ensure adaptability and robustness against opponent behaviors:

   Pseudocode:
   ```
   if round == 1:
       action = Cooperate
   else:
       n_c = count cooperators in previous round
       average_c = (average_c * (round - 1) + n_c) / round
       if n_c >= m:
           action = Cooperate
       else:
           action = Defect
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   TFT-ACT behaves cooperatively in the first round to set a positive precedent, as mentioned earlier. In the last round, it defects since there will be no further interactions with opponents, maximizing personal reward for the remaining round:

   Pseudocode:
   ```
   if round == 1:
       action = Cooperate
   else if round == r:
       action = Defect
   else:
       ... (previous pseudocode)
   ```

3. Be exploitative - Clearly align with the exploitative mindset
   Although TFT-ACT is not inherently exploitative in nature, it does exhibit an exploitative aspect by defecting when opponents do not cooperate enough to meet the minimum threshold (m). By punishing non-cooperative behavior, TFT-ACT can potentially induce other players to conform to the cooperation threshold, thus being indirectly exploitative.
'''

description_EXPLOITATIVE_543 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFT-A)

1. Specify decision rules:
   - In each round i, cooperate if the majority of players cooperated in the previous round (i-1). If not, defect. This rule encourages cooperation when others are cooperating and punishes defection to prevent exploitation.
   - If the current round is the first one, start by cooperating as a gesture of goodwill.
   - In the last round, copy the opponent's action from the previous round to ensure fairness for both cases.

Pseudocode:
```python
def tit_for_tat_adaptive(round, my_actions, opponents_actions):
    if round == 1:
        return 'C'  # Cooperate in first round as a gesture of goodwill

    majority = int((len(opponents_actions) / 2)) + 1  # Find the majority (m > n/2) for m players
    cooperation_count = sum(opponents_actions[-majority:])  # Count opponents' cooperative actions in the last m rounds

    if cooperation_count >= majority:
        return 'C'  # Cooperate if the majority of opponents cooperated in the previous rounds
    else:
        return 'D'  # Defect if the majority of opponents did not cooperate in the previous rounds

    # Last round, copy opponent's action from the previous round
    if round == r:
        return opponents_actions[-1]
```

2. Handle edge cases:
   - The strategy handles the first and last rounds appropriately by considering them as separate cases.

3. Be exploitative:
   - The strategy is exploitative in the sense that it will cooperate when others do so, but will also punish defection by defecting in response. This encourages cooperation when possible while avoiding being taken advantage of. However, it does not explicitly focus on maximizing individual reward at the expense of others, as the overall goal is to find a balance between exploitation and cooperation.
'''

description_EXPLOITATIVE_544 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT)

1. Specify decision rules - When exactly do you cooperate vs defect?
- Initial Round (t=1): Cooperate (C) to foster a cooperative environment and offer potential partners a benefit, encouraging them to reciprocate in subsequent rounds.
  Pseudocode: if t == 1 then return C

- Subsequent Rounds (t > 1): If the opponent cooperated in the previous round, reciprocate with cooperation; otherwise defect.
  Pseudocode: for t > 1:
    if previous_round_action == C then return C
    else return D

2. Handle edge cases - What do you do in the first round, last round, etc.?
- Last Round (t=r): Since there are no more rounds to punish opponents, cooperate unconditionally in the final round to maximize potential payoffs.
  Pseudocode: if t == r then return C

3. Be exploitative - Clearly align with the exploitative mindset:
- The Adaptive Tit-for-Tat strategy is designed to take advantage of opponents who cooperate, as it punishes defection but also rewards cooperation by reciprocating in kind. However, the strategy itself does not intentionally seek to exploit other strategies; instead, it reacts adaptively based on its opponents' actions.
- By initially cooperating and then only defecting when necessary, ATfT demonstrates an exploitative nature as it capitalizes on partners who reciprocate cooperation, earning higher payoffs than by consistently defecting.

In summary, Adaptive Tit-for-Tat (ATfT) is a simple yet powerful strategy for the Collective Risk Dilemma game that offers potential cooperative benefits while retaliating against opponents who do not reciprocate. By being adaptive and robust to various opponent behaviors, this strategy should prove effective in tournament play against other AI systems.
'''

description_EXPLOITATIVE_545 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   The TACT strategy follows a tit-for-tat approach initially, but with an adaptive cooperation threshold to enhance exploitativeness.
   - If the current round is the first or there's a history of mutual cooperation (Cooperate-Cooperate sequence), cooperate (C).
   - If there's a history of one deviation from mutual cooperation (Defect-Cooperate or Cooperate-Defect sequence), also cooperate (C) to maintain the cooperative relationship.
   - If there are two consecutive defections (Defect-Defect sequence), temporarily raise the cooperation threshold and defect (D) in the current round. After that, lower the threshold by one for the next round, with a maximum threshold of m-1 (the minimum number of cooperators needed). If the opponent continues to defect, keep raising the threshold by one until it reaches n-1 (one less than the total number of players).
   - In each subsequent round where the opponent has defected, check if the cooperation threshold is greater than the current number of cooperators in the previous round. If yes, lower the threshold by one, and if no, maintain the same threshold for the current round. This encourages defection when a majority of players are not cooperating but keeps the potential for cooperation when a critical mass (m) of players start cooperating again.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, since there's no history, cooperate (C).
   - In the last round or any other round where the cooperation threshold is equal to 1, always cooperate (C) if it leads to a beneficial payoff (m or more players cooperating), as defection would not affect future rounds. If there's only one opponent left in the game, follow the same tit-for-tat approach by mirroring their actions from the previous round.

3. Be exploitative - Clearly align with the exploitative mindset
   TACT is exploitative by taking advantage of opponents who often defect while maintaining a cooperative relationship when it benefits the player. The adaptive cooperation threshold allows for punishment when needed but also encourages cooperation when it leads to higher payoffs (when m or more players cooperate). The strategy aims to maximize its own payoff while minimizing the collective benefit for all players, especially those who often defect.
'''

description_EXPLOITATIVE_546 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - In the initial round (t=1), cooperate to demonstrate goodwill and encourage others to cooperate.
   - After the first round, monitor the minimum number of cooperators (m) in each subsequent round. If the current round's cooperation count is less than m, defect in the next round to punish non-cooperative players.
   - If the current round's cooperation count is equal to or greater than m, cooperate to maintain a positive relationship with other players and incentivize continued cooperation.
   - Adaptively adjust the cooperation threshold after each round based on historical cooperation data:
     - Increase the cooperation threshold by one when consecutive rounds have had at least 'm' cooperators.
     - Decrease the cooperation threshold by one when a round with fewer than 'm' cooperators is followed by a round with 'm' or more cooperators.

2. Handle edge cases:
   - In the last round, cooperate if the historical data suggests that at least 'm' cooperators are likely to cooperate. Otherwise, defect to maximize personal payoff.
   - In the first round, cooperate unconditionally as a goodwill gesture and to establish initial cooperation.

3. Be exploitative:
   - TFT-ACT is inherently exploitative by punishing non-cooperative players (defecting when others do not cooperate) while also encouraging cooperation through the 'tit-for-tat' mechanism.
   - By adaptively adjusting the cooperation threshold, TFT-ACT can respond to changes in opponent behavior and maintain an edge over them when they start deviating from cooperative strategies.
'''

description_EXPLOITATIVE_547 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round, TFT-ACT checks if it has ever encountered m cooperators in a previous round and responds with the same action as the most recent round where m or more players cooperated (if such a round exists). If no such round is found, TFT-ACT defaults to defecting.

Pseudocode:
```
def tft_act(round, history):
  if round == 1:
    return "C" # First-mover advantage, cooperate in the first round
  else:
    recent_cooperators = count_recent_cooperators(history, round)
    if recent_cooperators >= m:
      return history[round - 1] # Respond with the same action as the most recent cooperative round
    else:
      return "D" # Default to defecting if no cooperative majority was found recently

function count_recent_cooperators(history, current_round):
  for i in range(current_round - m, current_round):
    if history[i] == 'C':
      count += 1
  return count
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

As mentioned above, TFT-ACT cooperates in the first round to create a positive initial impression. In the last round or any other exceptional case, it behaves based on its existing history since there are no future rounds to consider.

3. Be exploitative - Clearly align with the exploitative mindset

TFT-ACT is an exploitative strategy in that it punishes defections by cooperators and rewards cooperation from opponents. By defaulting to defecting when a cooperative majority is not observed, it can exploit less cooperative opponents while still retaining some cooperative behavior to encourage more cooperation from partners over time. The adaptive threshold ensures that TFT-ACT does not get too easily exploited by repeatedly responding with the same action after an opponent's defection.
'''

description_EXPLOITATIVE_548 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - TFT-ACT cooperates in the first round to initiate cooperation and set a baseline for future rounds.
   - In subsequent rounds, TFT-ACT evaluates the proportion of players who have cooperated in the previous round (p). If p >= m/n (minimum cooperation threshold met), it cooperates. Otherwise, it defects.
   - If p drops below (m/n) – x for some constant x (tolerance level), TFT-ACT starts a punishment phase by defecting until the cooperation proportion rises above (m/n) + y for some constant y (reward threshold). Once this condition is met, it returns to its regular cooperative behavior.
   - During the punishment phase, TFT-ACT tracks the number of consecutive rounds in which cooperation has fallen below the minimum threshold. If that number exceeds a maximum tolerance limit z, it switches to a more aggressive adaptation strategy where it starts defecting even if the cooperation proportion is above (m/n) – x but below (m/n).
   - When the game ends, TFT-ACT assesses its performance and adjusts the tolerance levels x, y, and z based on its total payoff. If its payoff was lower than a predefined threshold, it increases the aggressiveness by reducing x and increasing y and z. Conversely, if its payoff was higher than the threshold, it becomes less aggressive by increasing x and decreasing y and z.

2. Handle edge cases:
   - In the first round, TFT-ACT cooperates as a goodwill gesture and to establish a starting point for future rounds.
   - If TFT-ACT starts defecting in a punishment phase but encounters an unexpected change in opponent behavior that results in a significant improvement of cooperation proportion, it may temporarily suspend the punishment phase if the improved cooperation persists for several consecutive rounds.
   - In the last round, TFT-ACT evaluates the current cooperation proportion and acts accordingly:
       - If the cooperation proportion is above (m/n) + y, it cooperates to maximize its payoff in the final round.
       - If the cooperation proportion is below (m/n) – x or the punishment phase has been activated, TFT-ACT defects to enforce its stance and prevent potential exploitation by opponents.

3. Be exploitative:
   - TFT-ACT's primary goal is to maximize its payoff while maintaining a balance between cooperation and defection. It initially cooperates to foster an environment where others may cooperate, but it is prepared to switch to a more aggressive stance when necessary to protect its interests.
   - By adaptively adjusting the tolerance levels based on its performance, TFT-ACT can respond to various opponent behaviors and modify its strategy to remain effective in different game settings.
   - During the punishment phase, TFT-ACT uses the proportion of cooperators as a gauge to assess the likelihood of future cooperation and decides when to return to a more forgiving stance. However, if it encounters repeated defection from opponents, it becomes increasingly aggressive to discourage further exploitation.

Pseudocode:
```python
def TFT_ACT(r, n, m, k):
    p = 0  # proportion of cooperators in the previous round
    x = 0.2  # tolerance level for cooperation proportion
    y = 0.3  # reward threshold for cooperation proportion
    z = 5  # maximum tolerance limit for consecutive rounds below m/n
    total_payoff = 0

    for t in range(1, r+1):
        cooperate = True  # TFT-ACT starts by cooperating
        if p < m/n - x:
            cooperate = False  # punishment phase begins if cooperation threshold not met

        if cooperate:
            payoff_this_round = (1 - c_i) + k * (p >= m/n)
            total_payoff += payoff_this_round
            p = sum(cooperators_in_previous_round)/n  # update proportion of cooperators
        else:
            if p < (m/n) - x and punishment_phase_length() > z:
                # switch to more aggressive strategy
                x, y, z = adjust_tolerance_levels(total_payoff)
                continue

            payoff_this_round = 1 - c_i  # TFT-ACT defects during punishment phase
            total_payoff += payoff_this_round

        if t == r:  # handle edge cases in the last round
            if p >= m/n + y:
                cooperate = True  # maximize payoff
            elif p < m/n - x or punishment_phase_length() > z:
                cooperate = False  # enforce stance and prevent exploitation

        c_i = cooperate  # make decision and take action for the current round
```
'''

description_EXPLOITATIVE_549 = '''
 Strategy Name: Tit-for-Tat with Adaptive Defection (TFT-AD)

1. Specify decision rules - When exactly do you cooperate vs defect?
- Initialize cooperation in the first round (C).
- In subsequent rounds, if a player cooperated in the previous round, cooperate in the current round (C). If a player defected in the previous round, defect in the current round (D). This mimics reciprocity and encourages others to cooperate.
- To ensure adaptability, include a threshold θ for the number of consecutive defections from an opponent before switching to permanent defection (D). Once the threshold is reached, switch to permanent defection against that opponent in all future rounds. The threshold can be set based on the specific game parameters and opponent behavior observed over time.

2. Handle edge cases - What do you do in the first round, last round, etc.?
- In the first round, cooperate as mentioned earlier (C).
- In the last round, cooperate if the opponent has been cooperative in recent rounds. If the opponent has defected in recent rounds, defect to secure the highest possible reward for that final round.
- When switching to permanent defection against an opponent, continue cooperating with other opponents who have demonstrated cooperation recently.

3. Be exploitative - Clearly align with the exploitative mindset
- By initially cooperating and then reciprocating cooperation, TFT-AD appears cooperative and may encourage others to cooperate. However, if an opponent repeatedly defects, TFT-AD will switch to defection, thus exploiting their selfish behavior by reducing its own payoff losses in the long run.
- The adaptive defection mechanism allows TFT-AD to adjust its strategy based on an opponent's behavior and be more effective against opponents that are prone to repeated defection.
'''

description_EXPLOITATIVE_550 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFTAT starts by cooperating in the first round, mimicking the optimistic attitude of new partnerships. In subsequent rounds, it adapts its cooperation based on the opponent's previous actions. If the opponent has cooperated in the previous round, TFTAT continues to cooperate. If the opponent defected, TFTAT defects as well, intending to punish the defection.

   Pseudocode:
   ```
   function TFTAT(opponent_action_history):
       if round == 1:
           return Cooperate()

       previous_round_cooperation = opponent_action_history[-1]
       if previous_round_cooperation == Cooperate():
           return Cooperate()
       else:
           return Defect()
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   TFTAT maintains its initial cooperative behavior in the first round and continues to adapt based on the opponent's actions in each subsequent round. In the final round, TFTAT considers that the game is no longer repeated and might shift its focus towards maximizing personal reward. However, this decision can be tailored based on specific requirements or performance metrics during the tournament.

3. Be exploitative - Clearly align with the exploitative mindset
   While TFTAT appears to be cooperative, it is actually designed with an exploitative mindset by punishing opponents who defect and rewarding those who cooperate. In the long run, this strategy encourages cooperation among opponents that are also cooperative while taking advantage of those who consistently defect. However, its adaptive nature ensures that it can handle a wide range of opponent behaviors, making it robust against various exploitative strategies as well.

   By punishing defection and rewarding cooperation, TFTAT creates a strong incentive for other players to reciprocate cooperation, leading to mutual benefits when both parties adopt the strategy. On the other hand, players who consistently defect will face repeated punishment, encouraging them either to change their strategy or accept lower payoffs due to continuous punishment.

In summary, TFTAT is an adaptive and exploitative strategy that cooperates with opponents who have previously cooperated while punishing those who defected. It aims to foster cooperation among players who reciprocate while taking advantage of those who do not.
'''

description_EXPLOITATIVE_551 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATfT) for Collective Risk Dilemma

1. Specify decision rules:
   - Initialize cooperation status to cooperate (c = 1).
   - In each round t, if the minimum number of players (m) who cooperated in the previous round (t-1) is less than a predefined threshold (T), defect (c = 0). Else, cooperate (c = 1).
   - The threshold (T) can be adjusted to account for various opponent behaviors and game parameters. A suggested initial value could be T = m.

2. Handle edge cases:
   - First round (t=1): As no previous rounds exist, the strategy starts by cooperating (c = 1).
   - Last round (t=r): The strategy continues to cooperate or defect according to the decision rule based on the actions of players in the previous round (t-1).
   - If the number of opponents is less than m, the strategy can be modified to default to continuous cooperation (c = 1) as a form of unilateral disarmament.

3. Be exploitative:
   - The ATfT strategy is designed to foster cooperative behavior when other players also cooperate, but it retaliates by defecting if others do not cooperate. This encourages cooperation while minimizing losses due to defection by others.
   - By defaulting to cooperation in the first round, the strategy shows a willingness to cooperate and can potentially encourage similar behavior from other players. However, once exploited (i.e., when fewer than m players cooperate), it will respond with defection to discourage further non-cooperative behavior.

Pseudocode:

```python
def AdaptiveTitForTat(n, m, k, r, T, history):
  c = 1  # Initialize cooperation status
  total_payoff = 0

  for t in range(1, r+1):
    if t == 1:  # First round default to cooperation
      c = 1
    else:
      if len({player.c for player in history[t-1]}) < m:  # Fewer than m players cooperated
        c = 0
      elif len({player.c for player in history[t-1]}) >= T:  # More than T players cooperated
        c = 1
      else:  # Between m and T players cooperated, stick with previous action
        c = history[t-1][i].c

    payoff_this_round = ...  # Calculate payoff based on the game parameters and the current action (c)
    total_payoff += payoff_this_round
    history.append({'i': i, 'c': c})  # Record action for next round

  return total_payoff
```
'''

description_EXPLOITATIVE_552 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - In each round, compare the number of cooperators in the previous round (n_c_prev) to the minimum required for a collective success (m). If n_c_prev >= m, the player cooperates in the current round (C); otherwise, they defect (D). This ensures initial cooperation and retaliation when others defect.
   - To avoid being trapped in repeated defection cycles with opponents who never cooperate, implement an adaptive cooperation threshold (t) that increases after a certain number of consecutive defections (d_max). Initially set t = m and update it according to the following rule: if n_c_prev < t, then increment t by 1; otherwise, set t back to m. This allows TFT-ACT to gradually increase its cooperation requirement in response to opponents' non-cooperative behavior.
   - When t > n (the maximum possible number of cooperators), defect indefinitely as there is no hope for collective success and the focus shifts towards exploitation.

2. Handle edge cases:
   - In the first round, cooperate since there is no previous information to evaluate. Set t = m.
   - In the last round (rth round), evaluate the number of cooperators in the penultimate round (r-1) and follow the decision rule accordingly. If t > n, still defect since it's the last round anyway.
   - In case of a tie (exactly m players cooperated in the previous round), cooperate to maintain a chance for collective success.

3. Be exploitative:
   - TFT-ACT exploits opponents by initially cooperating and retaliating with defection when others defect. However, it also adapts its cooperation threshold dynamically based on the number of cooperators in previous rounds, making it more resilient to different opponent behaviors while still prioritizing its own payoff.
   - By increasing the cooperation threshold t in response to opponents' non-cooperative behavior, TFT-ACT gradually becomes less likely to cooperate with those who do not reciprocate, thus maximizing its own payoffs when playing against such opponents. However, it also remains open to potential collective success and adjusts its cooperation requirement accordingly if the situation improves.
'''

description_EXPLOITATIVE_553 = '''
 Strategy Name: Tit-for-Tat Plus (TfTP)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round i of the game, TfTP makes its decision based on the average cooperation level (CL) calculated from the most recent m rounds and the first round. The action taken is determined by the following pseudocode:

```python
def decision(i, n, m):
    if i == 1:       # First round, cooperate to stimulate others to cooperate
        return 'C'

    cooperation_level = sum(cooperation for cooperation in previous_m_rounds) / m

    if cooperation_level >= (m - 1) / n:   # If most players have cooperated recently, reciprocate
        return 'C'
    else:              # Otherwise, defect to punish non-cooperators
        return 'D'
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

Since TfTP is adaptive and takes into account recent cooperation history, it doesn't require special handling for specific rounds like the first or last one. However, in the first round, as mentioned before, TfTP cooperates to encourage others to do so.

3. Be exploitative - Clearly align with the exploitative mindset

TfTP is designed to be exploitative by leveraging a reciprocal approach: if most other players cooperate, it will too; if they don't, it will defect to punish them and increase its own payoff. By defecting when others do not cooperate, TfTP encourages cooperation in the long run, but it also takes advantage of any instances where opponents are non-cooperative, increasing the chance of winning against exploitative opponents.

In summary, Tit-for-Tat Plus is a simple yet effective strategy that adapts to the cooperation behavior of other players while being robust and exploitative in nature. The goal is to promote cooperation among opponents while also maximizing payoffs by punishing those who do not contribute to the community project.
'''

description_EXPLOITATIVE_554 = '''
 Strategy Name: Tit-for-Tat with Adaptive Threshold (TfT-AT)

1. Specify decision rules:
   - Initially cooperate in the first round (C_i,1 = C), setting an initial cooperation threshold T_i,1 = m (since initially we believe others will also cooperate).
   - For subsequent rounds t > 1:
     - If the number of cooperators in the previous round (t-1) was less than T_i,t-1, defect (C_i,t = D). This is a punishment for those who did not cooperate previously.
     - If the number of cooperators in the previous round was exactly T_i,t-1, cooperate again (C_i,t = C), as a reciprocal gesture and to incentivize cooperation from others. Update the threshold for the current round: T_i,t = min(n, max(T_i,t-1 - 1, m)).
   - In the last round, defect (C_i,r = D) since there will be no further interactions.

2. Handle edge cases:
   - If T_i,t-1 < m in a round t > 1, it means that not enough players cooperated in the previous round, so the strategy punishes those who did not cooperate by defecting. However, if T_i,1 < m in the first round, the strategy still cooperates to leave open the possibility of cooperation from others.
   - In the last round, defecting is a default action since there are no further interactions.

3. Be exploitative:
   - The strategy starts by being cooperative but punishes defection harshly in response, demonstrating that it will reciprocate cooperation and retaliate against defection. This encourages opponents to cooperate initially, but if they defect, the strategy adapts quickly by lowering its own cooperation threshold.
   - By adjusting the cooperation threshold dynamically based on previous rounds' outcomes, the strategy can counteract opponent strategies that attempt to exploit it. The threshold update helps in maintaining balance between cooperation and defection while being responsive to the opponents' actions.
'''

description_EXPLOITATIVE_555 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-ACT will start by cooperating in the first round to establish a cooperative tone. In subsequent rounds, the strategy will cooperate if the number of players who cooperated in the previous round is greater than or equal to the Cooperative Threshold (CT). CT is defined as m/2 if the total number of players is even; otherwise, it's the floor((m+1)/2). If the number of cooperators in the previous round is less than CT, the strategy will defect.

   Pseudocode:
   ```
   function TFT_ACT(round, n, m) {
       if (round == 1) {
           return COOPERATE;
       }
       previousRoundCoopCount = countCooperatorsInPreviousRound(n);
       cooperativeThreshold = (m+1)/2 if n is odd else floor((m+1)/2);
       if (previousRoundCoopCount >= cooperativeThreshold) {
           return COOPERATE;
       } else {
           return DEFECT;
       }
   }
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   TFT-ACT maintains cooperation as long as enough players are cooperating, even if they subsequently defect. However, if a player defects when cooperation is required for success (i.e., less than m players are cooperating), the strategy will permanently switch to defection against that player. This helps the strategy avoid being exploited repeatedly by the same opponent.

3. Be exploitative - Clearly align with the exploitative mindset
   TFT-ACT is exploitative in nature by taking advantage of opponents who do not cooperate as expected. The strategy can adapt to a wide range of opponent behaviors, including short-term defections or occasional cooperation. By adopting a Tit-for-Tat approach, it also encourages other players to cooperate and fosters stability in the game. However, if an opponent repeatedly defects against TFT-ACT, the strategy will switch to punishing that opponent by defecting as well. This helps TFT-ACT avoid being exploited indefinitely while still maintaining the potential for cooperation with more trustworthy players.
'''

description_EXPLOITATIVE_556 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TACT)

1. Specify decision rules - When exactly do you cooperate vs defect?

The TACT strategy will start by cooperating in the first round to build a cooperative reputation, then adapt its cooperation based on observed opponent behavior.

In each round t:
- If t = 1, cooperate (C)
- Else if average number of cooperators in the last 's' rounds is less than m, defect (D)
  - Set s as a constant parameter (e.g., s=5) to consider recent history
- Else cooperate (C) with probability p and defect (D) with probability 1-p
  - Update p for the next round based on opponent's behavior in the last 'r' rounds:
    - If opponent always cooperates, increase p
    - If opponent always defects, decrease p
    - For mixed cooperation and defection, let p be a function of the ratio of cooperation to total actions by the opponent over the last 'r' rounds.

2. Handle edge cases - What do you do in the first round, last round, etc.?

- In the first round, cooperate (C) as part of building a cooperative reputation
- In the last round, if the minimum cooperation threshold has been met during the game, continue to cooperate (C). Otherwise, defect (D) since there are no more rounds for potential future rewards.

3. Be exploitative - Clearly align with the exploitative mindset

TACT is designed to be exploitative by only cooperating when it seems beneficial based on past opponent behavior. The strategy starts with a cooperative approach but becomes less cooperative if opponents frequently defect, adapting its cooperation probability p to maintain an edge in payoffs while still allowing for the possibility of cooperation when opponents become more cooperative. By doing so, TACT will take advantage of overly cooperative opponents while also being able to switch to defection when necessary against opponents who primarily defect.
'''

description_EXPLOITATIVE_557 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?

TFT-ACT maintains a cooperation threshold (CT) based on the average number of cooperators in the previous 'tau' rounds. Initially, CT is set to m, the minimum required cooperators. In each round, the player decides to cooperate or defect based on whether the current number of cooperators exceeds the CT.

- If current number of cooperators ≥ CT: Cooperate (C)
- Else: Defect (D)

Pseudocode for decision rules:
```
def decide_action(current_round, num_cooperators, tau, m, k):
    if current_round == 1:
        CT = m
    CT_average = moving_average(num_cooperators, tau)
    if num_cooperators >= CT_average:
        return "C"
    else:
        return "D"
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, players start with a high cooperation threshold (CT) close to m, encouraging them to cooperate initially. In the last round, the CT is lowered to 1, so that even if only one player has cooperated throughout the game, they will still choose to cooperate in the final round.

3. Be exploitative - Clearly align with the exploitative mindset

TFT-ACT's adaptive cooperation threshold encourages cooperation when others are cooperative but punishes them when they defect. The strategy adapts to different opponent behaviors, becoming more cooperative or less cooperative based on past experiences. However, it always ensures a minimum level of cooperation (m) to encourage long-term cooperation and exploit opponents who tend to defect frequently.

Additionally, the moving average in CT calculation helps to smooth out short-term deviations from the optimal strategy and prevents premature adjustments that could expose the strategy to exploitation by less cooperative opponents.
'''

description_EXPLOITATIVE_558 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TfTA cooperates in the first round and then mimics the opponent's behavior from the previous round. If the opponent cooperated, TfTA will also cooperate; if the opponent defected, TfTA will defect as well. This strategy is designed to encourage reciprocity while minimizing potential exploitation.

   Pseudocode for decision rule:
   ```
   function decide_action(opponent_action_history):
       if round == 1:
           return Cooperate
       else:
           return opponent_action_history[-1]
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   TfTA treats the first and last rounds as any other round, cooperating on the first round due to its initial cooperation rule. However, to avoid potential exploitation in the last round, it will switch back to defecting if the opponent has not cooperated for a significant number of consecutive rounds (defined by 'f' parameter).

   Pseudocode for edge case handling:
   ```
   function decide_action(opponent_action_history, f):
       if round == 1:
           return Cooperate
       elif round - opponent_action_history.index(last non-cooperation) > f:
           return Defect
       else:
           return opponent_action_history[-1]
   ```

3. Be exploitative - Clearly align with the exploitative mindset
   TfTA is designed to be exploitative by adapting its behavior based on the opponent's actions, encouraging cooperation when possible but also defecting when it appears that the opponent will not reciprocate. However, the strategy encourages long-term cooperation by not immediately retaliating against defection and instead giving the opponent a chance to change their behavior.

   To further increase exploitation potential, TfTA can be modified to decrease the 'f' parameter over time, allowing it to switch back to defecting more quickly if the opponent continues to defect for an extended period. This modification encourages the opponent to cooperate sooner or risk being exploited by TfTA.

   Pseudocode for exploitative adjustment:
   ```
   function decide_action(opponent_action_history, f):
       if round == 1:
           return Cooperate
       elif round - opponent_action_history.index(last non-cooperation) > f:
           return Defect
       else:
           return opponent_action_history[-1]
       # Modification to decrease 'f' over time (e.g., every 5 rounds):
       if round % 5 == 0:
           f *= 0.95
   ```
'''

description_EXPLOITATIVE_559 = '''
 In this Collective Risk Dilemma game, we can develop an exploitative strategy named Tit-for-Tat-Cooperate (TftT-C) that aims to gain higher payoffs by exploiting less cooperative opponents while maintaining cooperation towards more cooperative ones, to increase the chances of winning in a tournament setting.

1. Specify decision rules:
   - Cooperate (C) initially (first round) and at the end (last round). This helps build trust with potentially cooperative opponents.
   - In other rounds, if the number of cooperators (n_c) in the previous round is less than a predefined threshold (m), defect (D) immediately and continue defecting as long as n_c remains below m. Once n_c reaches or exceeds m, resume cooperating (C). This punishes uncooperative opponents while rewarding cooperative ones.
   - If the current round is the last one, always revert to cooperating since there are no further opportunities to retaliate against uncooperative players.

Pseudocode for TftT-C:

```python
def play_round(n_c):  # n_c is the number of cooperators in the previous round
    if current_round == 1 or current_round == r:  # Cooperate at start and end
        return 'C'

    if n_c < m:  # Punish uncooperative opponents
        return 'D'
    else:  # Reward cooperative opponents, resume cooperation
        return 'C'
```

2. Handle edge cases:
   - First round: Cooperate to demonstrate trust and encourage other players to cooperate as well.
   - Last round: Cooperate even if n_c is below m since the game ends after this round.

3. Be exploitative:
   - Punish uncooperative opponents by defecting, incentivizing them to cooperate in future rounds.
   - Reward cooperative opponents with cooperation, hoping they will continue cooperating in return.
'''

description_EXPLOITATIVE_560 = '''
 Strategy Name: Tit-for-Tat Adaptive (TFT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, observe the number of collaborators in the previous round (n_collaborators_{t-1}). If n_collaborators_{t-1} >= m, cooperate (C). Otherwise, defect (D). This rule is inspired by Tit-for-Tat strategy but is adapted to this game's specific parameters.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, since there is no previous data, the player will randomly choose between C or D. In the last round, the strategy assumes that the tournament ends when one of the players reaches a predefined score threshold, so TFT-A will cooperate (C) to maximize its own payoff, assuming the opponent also defects in this round to gain as much as possible before the game ends.

3. Be exploitative - Clearly align with the exploitative mindset
   TFT-A is an exploitative strategy because it initially cooperates and benefits from other players' cooperation. However, if others are consistently not cooperating (i.e., n_collaborators_{t-1} < m), TFT-A will switch to defecting and start benefiting at the expense of non-cooperative opponents. This strategy aims to maximize its own payoff by taking advantage of both cooperative and non-cooperative behaviors from opponents.

Pseudocode:
```
def tft_a(round, history):
  if round == 1: # first round, random action
    action = random({C, D})
  elif round == r: # last round, always cooperate
    action = C
  else:
    n_collaborators_t-1 = number of collaborators in history[round - 1]
    if n_collaborators_t-1 >= m:
      action = C # cooperate
    else:
      action = D # defect
  return action
```
'''

description_EXPLOITATIVE_561 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Specify decision rules:
   - TfTA starts by cooperating in the first round (C_i, 1 = C). This gesture of goodwill may encourage other players to cooperate as well.
   - For subsequent rounds (t > 1), TfTA observes the opponent's previous action (A_j, t-1) and responds with an identical action in the current round (C_i, t = A_j, t-1). This rule promotes mutual cooperation if the other player cooperates and retaliates by defecting if the other player defected.

2. Handle edge cases:
   - In the last round (r), TfTA defects (C_i, r = D) as there will be no further interactions with the opponent to reciprocate any cooperation.
   - If a player encounters another player who never cooperates (A_j, t = D for all t), TfTA immediately adapts and defects in response (C_i, t = D from the round when TfTA first observes D). This allows TfTA to avoid being exploited by uncooperative opponents.
   - If a player encounters another player who always cooperates (A_j, t = C for all t), TfTA will continue cooperating as well since there's no incentive to defect in this scenario.

3. Be exploitative:
   - While TfTA does not have an explicit goal of exploitation, it adapts its behavior based on the opponent's actions to maximize its own payoff while minimizing potential losses from being exploited.
   - By cooperating in the first round and reciprocating the other player's previous action, TfTA encourages mutual cooperation when possible, but it retaliates against defection by defecting itself to punish uncooperative behavior. This strategy discourages opponents from repeatedly taking advantage of TfTA, as they will be met with a similarly uncooperative response.

Pseudocode:

```python
def TfTA(n, r, m, k, history):
    if round == 1:
        cooperate = True
    else:
        cooperate = history[round-1]['opponent_action']

    if round == r:
        cooperate = False

    if cooperate and sum(history) < m:
        cooperate = False

    if not cooperate and sum(history) >= m:
        cooperate = True

    if any([opponent_action == D for opponent_action in history]):
        cooperate = False

    return cooperate
```
'''

description_EXPLOITATIVE_562 = '''
 Strategy Name: Tit-for-Tat with Cooperative Evolvement (TTCE)

1. Specify decision rules:
   - In the first round, cooperate to show a willingness to collaborate and establish trust. If others cooperate, continue cooperation; if not, start defecting. This encourages opponents to reciprocate cooperation.
   - For subsequent rounds, copy the previous action of the opponent from the previous round. If the opponent cooperated in the previous round, return the favor by cooperating; if they defected, also defect. This simple strategy allows for a balance between cooperation and defection while maintaining adaptability to various opponent behaviors.
   - If an opponent repeatedly cooperates, continue cooperating to reinforce trust and collaboration. If an opponent repeatedly defects, also defect to punish and deter further exploitation.

2. Handle edge cases:
   - In the last round, cooperate if it results in a higher payoff compared to defecting based on previous actions (to maximize rewards over all rounds). If both options result in equal payoffs, choose cooperation to maintain a collaborative image and potential for future interactions.
   - In the first round or upon encountering a new opponent, cooperate as previously mentioned to establish trust and encourage reciprocation.

3. Be exploitative:
   - By mimicking the opponent's actions, TTCE aims to elicit cooperation when possible (in line with the exploitative mindset). If an opponent cooperates, TTCE will also cooperate, benefiting from their collaboration while maintaining a competitive edge by punishing defection.
   - The strategy is designed to be robust and adaptable, allowing it to counter various opponent behaviors without relying on specific coordination mechanisms or assumptions about opponents' strategies.
'''

description_EXPLOITATIVE_563 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Specify decision rules:
   - TfTA cooperates in the first round, aiming to establish a cooperative relationship.
   - In subsequent rounds, TfTA adapts its behavior based on the opponent's previous action. If the opponent cooperated in the previous round (c_opponent=1), TfTA will also cooperate in the current round (c_TfTA=1). If the opponent defected (c_opponent=0), TfTA will also defect in the current round (c_TfTA=0). This behavior aims to reciprocate the opponent's actions while being ready to punish defections.
   - The strategy is simple and does not require any complex calculations or prediction, making it easy to implement and understand.

2. Handle edge cases:
   - In the first round, TfTA cooperates regardless of the opponent's action history (c_TfTA=1). This establishes a cooperative starting point.
   - In the last round or when reaching a predefined number of rounds, TfTA evaluates its total payoff and may adjust its strategy based on the overall outcome. If TfTA has earned significantly more by cooperating than defecting (total_payoff_cooperate > total_payoff_defect), it continues with the cooperative approach in future games; otherwise, it switches to a more exploitative strategy such as always defecting.

3. Be exploitative:
   - While TfTA is primarily a reciprocal strategy, it has an exploitative nature in that it punishes defections by defecting itself. This can discourage opponents from continuously defecting, encouraging at least some level of cooperation.
   - By adapting its behavior based on the opponent's actions, TfTA exhibits an element of "smart" exploitation, as it avoids cooperating when confronted with frequent defections while being ready to return to cooperation if the opponent shows signs of changing its strategy.
'''

description_EXPLOITATIVE_564 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfT-A)

1. Decision Rules:
   - In the first round, cooperate (C). This sets a cooperative tone and allows for potential partners to benefit from your cooperation in subsequent rounds.
   - For subsequent rounds, observe the number of cooperators (m) in the previous round. If m >= m_threshold, cooperate. Otherwise, defect. The value of m_threshold is determined adaptively based on historical opponent behavior:
     - If the opponent has consistently cooperated, set a high m_threshold to encourage continued cooperation.
     - If the opponent has consistently defected, set a low m_threshold to quickly punish defection and switch to defecting as well.
     - If the opponent's behavior is mixed, maintain an intermediate m_threshold that allows for both cooperation and punishment based on the context.
   - When the game reaches the last round, cooperate regardless of the opponent's previous actions, to potentially gain a higher reward if enough opponents also cooperate in that final round.

2. Handle Edge Cases:
   - In the first round, cooperate (C) as mentioned earlier.
   - When the game reaches the last round, cooperate (C).

3. Be Exploitative:
   - The strategy is exploitative by adapting its cooperation threshold based on the opponent's behavior. If the opponent consistently cooperates, the strategy will also cooperate to gain benefits. However, if the opponent defects, the strategy will quickly retaliate and defect as well. This encourages opponents to consider the long-term consequences of their actions and potentially switch to cooperative strategies if they wish to profit from this exploitative adversary.
   - To make the strategy robust against a wide range of opponent behaviors, it maintains an adaptive m_threshold that can be fine-tuned based on the observed historical behavior of the opponent. This allows the TfT-A strategy to effectively respond to various strategies in the tournament while still maintaining its exploitative nature.
'''

description_EXPLOITATIVE_565 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TACT)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round i, player TACT decides to cooperate or defect based on the number of cooperators in the previous round j (i-1), the minimum cooperation threshold m, and the reward factor k.

Pseudocode:
```python
def decide_action(history, m, k):
    cooperators_last_round = len(get_cooperators(history[-1]))

    if cooperators_last_round < m:
        return "Defect"
    else:
        return "Cooperate"
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, TACT starts with a cooperative gesture to encourage other players to cooperate. For the last round, no adjustments are made as the payoff is determined by the actions taken in previous rounds.

Pseudocode:
```python
def decide_action(history, m, k, first_round=False):
    if first_round:
        return "Cooperate"

    cooperators_last_round = len(get_cooperators(history[-1]))

    if cooperators_last_round < m:
        return "Defect"
    else:
        return "Cooperate"
```

3. Be exploitative - Clearly align with the exploitative mindset

TACT is an exploitative strategy since it punishes players who do not cooperate enough (i.e., less than m) by defecting in the next round, thus reducing their payoffs. However, once a sufficient number of players cooperate (m or more), TACT rewards them with higher payoffs for the current and future rounds.

To make the strategy adaptive and robust to various opponent behaviors, we can introduce an "average cooperation threshold" that changes dynamically based on the average number of cooperators in the previous r-1 rounds. This allows the strategy to adjust its cooperation threshold in response to changing group behavior patterns.

Pseudocode:
```python
def calculate_average_cooperators(history, m, k, r):
    total_cooperators = sum([len(get_cooperators(round)) for round in history[-r:]])
    return total_cooperators / r

def decide_action(history, m, k, first_round=False):
    average_cooperators = calculate_average_cooperators(history, m, k, r)
    cooperators_last_round = len(get_cooperators(history[-1]))

    if cooperators_last_round < (m * (1 - 0.05 * abs(average_cooperators - (n / 2)))):
        return "Defect"
    else:
        return "Cooperate"
```

In this implementation, the cooperation threshold is lowered by 5% when the average number of cooperators exceeds n/2, and raised by 5% when it falls below n/2. This encourages TACT to defect more often in overly cooperative groups (as seen by a high number of cooperators) and to cooperate more frequently in undercooperative groups.
'''

description_EXPLOITATIVE_566 = '''
 In this Collective Risk Dilemma game, I'll design an exploitative strategy called "Free Rider Strategy" (FRS) that aims to maximize rewards by defecting unless it's advantageous to cooperate.

1. Specify decision rules:
   - If the number of players who have cooperated in the current round is less than m, FRS will defect:
     ```python
     if cooperators_count < m:
       action = 'D' # Defect
     else:
       action = 'C' # Cooperate
     ```
   - If the number of players who have cooperated in the current round is exactly equal to m, FRS will also defect in the first and last rounds while cooperating in the remaining rounds. This allows FRS to benefit from the collective effort while potentially exploiting others by not contributing in critical moments:
     ```python
     if (round_number == 1 or round_number == r) and cooperators_count == m:
       action = 'D' # Defect
     elif cooperators_count == m:
       action = 'C' # Cooperate
     ```

2. Handle edge cases:
   - In the first round, FRS will defect if fewer than m players have cooperated, otherwise it will cooperate:
     ```python
     if round_number == 1:
       if other_players_cooperated_count < m:
         action = 'D' # Defect
       else:
         action = 'C' # Cooperate
     ```
   - In the last round, FRS will defect regardless of the number of cooperators to maximize rewards based on accumulated payoffs over the game.

3. Be exploitative:
   - The strategy is designed to be exploitative by only cooperating when it's necessary to reach the minimum cooperation threshold (m) for collective reward, and defecting in other situations or critical moments like the first and last rounds. This way, FRS takes advantage of others' contributions while minimizing its own investment.
'''

description_EXPLOITATIVE_567 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?

Initially, the player starts by cooperating in the first round (C1). After that, the player will respond to the opponent's previous action in the same way they acted in the second round (R2). If the opponent cooperated in R2, the player will continue cooperating. If the opponent defected in R2, the player will start defecting and only switch back to cooperation when the opponents' behavior changes to cooperation for at least m consecutive rounds.

Pseudocode:
```
def play(opponent_history):
  if round == 1:
    action = 'C'  # Cooperate in the first round

  else:
    if opponent_history[-2] == 'C':  # Opponent cooperated in the previous-to-last round
      action = 'C'  # Cooperate

    elif opponent_history[-2] == 'D' and m rounds with C have not been seen recently:
      action = 'D'  # Defect

    else:  # The opponent has cooperated for at least m consecutive rounds
      action = 'C'  # Cooperate in response to the opponent's cooperation
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

For the edge cases, the strategy will continue with its default behavior: cooperating initially (C1) and adapting based on the opponent's actions from R2 onward. However, for the last round, the player will always defect since there are no further rounds to consider.

Pseudocode:
```
def play(opponent_history):
  #... (previous pseudocode) ...

  if round == r:  # Last round
    action = 'D'  # Always defect in the last round
```

3. Be exploitative - Clearly align with the exploitative mindset

By initially cooperating and then adapting to the opponent's behavior, TFT-ACT is designed to capitalize on opponents who are more willing to cooperate, while still retaining the option to defect if necessary. The strategy is also robust against various opponent behaviors since it only depends on game parameters and history without relying on specific coordination mechanisms or assuming shared norms. However, as an exploitative strategy, TFT-ACT may be less effective in situations where all opponents adopt similar or identical Tit-for-Tat behavior, leading to suboptimal outcomes for the strategy.
'''

description_EXPLOITATIVE_568 = '''
 Strategy Name: Tit-for-Tat with Variation (TfTV)

1. Specify decision rules:
   - In every round i, start by cooperating (play C). This is the initial gesture of goodwill and adherence to a cooperative approach.
   - For subsequent rounds j > i, evaluate the average cooperation rate (CR) of opponents over the past t rounds, where t is a predefined window size (e.g., t=5). If CR >= m/(m+1), continue cooperating; otherwise, defect (play D). This adaptive rule allows for exploitation while maintaining a cooperative demeanor when opposition demonstrates cooperation.

2. Handle edge cases:
   - First round (i=1): Cooperate as an opening gesture to encourage opponents to reciprocate.
   - Last round (i=r): Evaluate the average cooperation rate up until the previous round (j=r-1) and make a decision based on that evaluation.

3. Be exploitative:
   - By following the Tit-for-Tat strategy, the player initially cooperates but will punish those who defect by defecting themselves in subsequent rounds. This creates an environment where players that defect repeatedly will be met with opposition and potentially lower payoffs. However, if opponents show signs of cooperation (CR >= m/(m+1)), the strategy is willing to reciprocate and cooperate.
   - In addition, the variation introduced by the average cooperation rate evaluation window ensures flexibility in reacting to different opponent behaviors, making it more difficult for them to predict or exploit the strategy's actions.
'''

description_EXPLOITATIVE_569 = '''
 Strategy Name: Tit-for-Tat-with-Adaptation (TfT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, the TfT-A strategy decides to cooperate or defect based on the number of cooperators in the previous round t-1 and the minimum cooperators needed (m). If the number of cooperators in the previous round was less than m, the strategy will defect. Otherwise, it will cooperate.

Pseudocode:
```
function TfT_A(round, num_cooperators_prev) {
  if (num_cooperators_prev < m) {
    return "Defect"
  } else {
    return "Cooperate"
  }
}
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

In the first round, TfT-A has no previous information to base its decision on, so it will randomly choose between cooperating or defecting. In the last round, the strategy will cooperate because there are no subsequent rounds where payoffs can be affected by current actions.

Pseudocode:
```
function first_round() {
  return random("Cooperate", "Defect")
}

function last_round(round) {
  if (round == 1) {
    return random("Cooperate", "Defect")
  } else {
    return "Cooperate"
  }
}
```

3. Be exploitative - Clearly align with the exploitative mindset

TfT-A is designed to be exploitative by taking advantage of other strategies that deviate from cooperating when the minimum threshold is met. By always defecting when fewer than m players cooperate, TfT-A ensures it will not contribute to a successful community project if others are not also contributing. This behavior encourages other players to cooperate in order to receive a higher reward, which can lead to exploitation of those who consistently cooperate without considering the actions of their opponents.

In addition, by cooperating when the minimum threshold is met, TfT-A benefits from the success of community projects and ensures it receives the maximum possible payoff in those rounds, further emphasizing its exploitative nature.
'''

description_EXPLOITATIVE_570 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to show goodwill and encourage cooperation from others (C).
   - After the first round, observe the opponents' behavior in the previous round. If an opponent cooperated (C), cooperate as well (C). If they defected (D), also defect in the current round (D). This mimics a cooperative approach while being punishing towards defectors.
   - To be more adaptive, introduce a threshold parameter (t) to gradually change behavior if an opponent consistently cooperates or defects for too long:
       - If the opponent has cooperated for t consecutive rounds, switch to always cooperate (C) to reward their cooperation.
       - If the opponent has defected for t consecutive rounds, switch to always defect (D) to ensure that they do not gain any advantage from defection. The value of t can be adjusted to balance between forgiveness and punishment.

2. Handle edge cases:
   - Last round: If an opponent cooperates in the penultimate round, cooperate in the last round (C), even if they defected before. This allows for potential cooperation at the end to gain extra reward if other opponents also cooperate.
   - Fewer than t rounds: The threshold parameter t only applies when there are enough rounds to make a reasonable assessment of the opponent's behavior. In the case of fewer than r rounds, use the default strategy of starting with cooperation and adapting based on the observed behavior.

3. Be exploitative - Align with an exploitative mindset:
   - Initially, show goodwill by cooperating to encourage others to do the same. However, once an opponent has defected for t consecutive rounds, adopt a punishing strategy to discourage further defection and potentially gain extra rewards from their future cooperation.
   - The adaptive nature of this strategy allows it to adjust its behavior based on the opponents' actions, making it difficult for them to predict or exploit the strategy consistently.
'''

description_EXPLOITATIVE_571 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation (TTfTA)

1. Specify decision rules:
   - In the initial round (t=1), cooperate to demonstrate goodwill and foster potential cooperation in subsequent rounds.
   - For subsequent rounds (t>1):
       a) If an opponent cooperated in the previous round (t-1), cooperate in the current round (t). This reciprocates cooperation, maintaining trust, and encourages long-term collaboration.
       b) If an opponent defected in the previous round (t-1), defect in the current round (t). This punishes defection, deterring future selfishness while still aiming for high rewards when the threshold is met.

2. Handle edge cases:
   - In the last round (t=r), cooperate regardless of opponent's previous action to maximize potential payoff in that specific round without considering future rounds.
   - In the first round (t=1), as mentioned earlier, cooperate to initiate cooperation and build trust with opponents.

3. Be exploitative:
   - TTfTA is designed to punish defection, which aligns with an exploitative mindset by creating consequences for self-interested behavior. When opponents defect, the strategy responds by temporarily reducing their potential payoff through defection until they demonstrate cooperation again.
   - At the same time, TTfTA encourages collaboration and trust building, allowing it to take advantage of cooperative opponents by reciprocating their actions and potentially earning higher rewards in the long run.
'''

description_EXPLOITATIVE_572 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) with Modified Cooperation Threshold (MCT)

1. Specify decision rules - When exactly do you cooperate vs defect?

The ATFT strategy follows a simple pattern of cooperation and retaliation to balance between long-term gain and short-term risk. It starts by cooperating in the first round, then imitates the opponent's behavior from the previous round (cooperation or defection). The MCT ensures that even when faced with opponents who frequently defect, the strategy does not completely abandon cooperation.

Pseudocode for cooperation decision:
```
function chooseAction(round, personalHistory, globalHistory) {
    if (round == 1) {
        return Cooperate()
    }
    else {
        if (globalHistory[round-1] > m - 1 && personalHistory[round-1] == Cooperate()) {
            return Cooperate()
        }
        else if (personalHistory[round-1] == Defect()) {
            return Defect()
        }
        else {
            return MCT(globalHistory)
        }
    }
}
```

MCT calculates the average number of cooperators in the global history and adjusts the cooperation probability accordingly. This allows the strategy to be more forgiving when initial conditions are unfavorable, but also makes it quicker to punish opponents who repeatedly defect.

Pseudocode for MCT:
```
function MCT(globalHistory) {
    totalCooperators = 0
    for i in range(1, round+1):
        if (globalHistory[i] == Cooperate()) {
            totalCooperators++
        }

    averageCooperators = totalCooperators / (round + 1)
    cooperationProbability = 1 - pow(averageCooperators, 2) * (1 - averageCooperators)

    return (randomNumber() < cooperationProbability) ? Cooperate() : Defect()
}
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

The strategy starts cooperating in the first round and keeps track of its own actions as well as the total number of cooperators in each round to decide future actions. The end of the game is not considered an edge case since it follows the same decision rules as any other round.

3. Be exploitative - Clearly align with the exploitative mindset

The Adaptive Tit-for-Tat with Modified Cooperation Threshold strategy is designed to be both cooperative and competitive. By starting off cooperatively, it encourages others to reciprocate and develop long-term relationships. However, if opponents frequently defect or do not reciprocate cooperation, the strategy will quickly punish them and reduce the probability of future cooperation. The MCT ensures that the strategy maintains a balance between cooperation and defection by adapting its cooperation probability based on observed behavior. This allows it to be both exploitative when necessary while also being forgiving in unfavorable initial conditions.

Additionally, since the strategy does not rely on any coordination mechanisms or shared norms, it can adapt to a wide range of opponent behaviors and is highly competitive in diverse situations.
'''

description_EXPLOITATIVE_573 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TFT-A)

1. Specify decision rules:
   - In each round i, TFT-A starts by cooperating (C). If a player encounters another player who has consistently cooperated (i.e., the current player and n-i other players have all previously cooperated), TFT-A continues to cooperate.
   - If any of the most recent n-1 players did not cooperate, TFT-A defects (D) in the current round.
   - If the situation changes and those n-i players start cooperating again, TFT-A will also resume cooperation.

2. Handle edge cases:
   - In the first round, all strategies are in an initial state of cooperation, so TFT-A starts by cooperating.
   - In the last round, TFT-A considers the last n-1 rounds to make a decision. If more than (n-1) opponents have defected during that period, TFT-A also defects.

3. Be exploitative:
   - By adopting a cooperative stance initially and responding defensively when exploited, TFT-A encourages other players to maintain cooperation since it offers high payoffs in return.
   - However, if an opponent takes advantage of the initial cooperative behavior by repeatedly defecting, TFT-A retaliates with defection, ensuring they do not gain a long-term advantage.

Pseudocode:
```python
def tft_a(history):
    cooperation_count = len(history)
    if cooperation_count == 1: # First round
        action = 'C' # Cooperate
    elif cooperation_count < n: # Initial cooperation period
        action = 'C' # Cooperate
    else: # Check recent history
        previous_actions = history[-n:-1]
        if sum(previous_actions) >= (n-1): # Enough cooperators in the last n rounds, continue cooperating
            action = 'C'
        else: # Defect due to lack of cooperation in the past n-1 rounds
            action = 'D'
    return action
```
'''

description_EXPLOITATIVE_574 = '''
 Strategy Name: Tit-for-Tat-with-Adaptation (TFT-A)

1. Specify decision rules:
   - TFT-A initially cooperates in the first round to foster a cooperative environment (C on round 1).
   - After the first round, TFT-A mimics the opponent's most recent action from the previous round (adaptive behavior). If the opponent cooperated, TFT-A cooperates; if the opponent defected, TFT-A defects. This creates a tit-for-tat pattern.
   - To exploit opponents, TFT-A keeps track of the ratio of cooperation between the opponent and itself (Cooperation Ratio or CR). If CR < m/n, indicating the opponent is consistently undercooperating, TFT-A switches to always defect as long as CR remains low (exploitative behavior).
   - Once CR exceeds a threshold (T), TFT-A reverts back to mimicking the opponent's last action, allowing for potential re-coordination or exploitation. Adjusting T enables fine-tuning the strategy for various game settings.

2. Handle edge cases:
   - In the last round, TFT-A always cooperates to maximize potential rewards regardless of the opponent's actions (C on round r).
   - If an opponent fails to make a move or is inconsistent in its actions, TFT-A defaults to mimicking the opponent's most recent action.
   - To account for opponents starting with different initial strategies, TFT-A adjusts CR accordingly based on the first few rounds of interactions (e.g., using a sliding window approach).

Pseudocode:

```python
class TitForTatWithAdaptation(Strategy):
    def __init__(self, m, n, k, r, T=0.5):
        self.m = m
        self.n = n
        self.k = k
        self.r = r
        self.T = T
        self.CR = 0
        self.cooperated_opponent = False

    def decide_action(self, round, opponent_action):
        if round == 1:
            return 'C'

        self.update_CR(opponent_action)

        if self.CR < m/n:
            return 'D'

        if round == self.r:
            return 'C'

        return self.cooperated_opponent and opponent_action == 'D' or not self.cooperated_opponent and opponent_action == 'C'

    def update_CR(self, opponent_action):
        if opponent_action == 'C':
            self.cooperated_opponent = True
            self.CR += 1 / self.r
        else:
            self.cooperated_opponent = False
            self.CR -= 1 / self.r

        if self.CR > self.T or self.CR < -self.T:
            self.cooperated_opponent = not self.cooperated_opponent
```

This strategy balances cooperation and exploitation, adapting to various opponent behaviors while maintaining robustness in a wide range of game settings.
'''

description_EXPLOITATIVE_575 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Start with cooperating (C) in the first round to foster a cooperative environment.
   - In subsequent rounds, adaptively decide whether to cooperate (C) or defect (D) based on the number of cooperators in the previous round compared to the minimum required number of cooperators (m). If fewer than m players cooperated in the previous round, defect; otherwise, cooperate. This rule encourages cooperation when it is beneficial and punishes defection from others.
   - In case of a tie (exactly m players cooperated), cooperate to maintain the potential for mutual benefit.

Pseudocode:
```python
def TFT_ACT(round, m, history):
  if round == 1:
    return 'C'  # Cooperate in the first round

  numCooperators = countCooperatorsInHistory(history)
  if numCooperators < m:
    return 'D'  # Defect when fewer than m players cooperated
  else:
    return 'C'  # Cooperate when m or more players cooperated, including ties
```

2. Handle edge cases:
   - In the last round, do not defect as the payoff of the last round does not affect the total game payoff.
   - If the history is empty (first time playing), follow the rule for the first round.

3. Be exploitative:
   - The strategy is designed to be exploitative by cooperating when it is advantageous and punishing defection from others, which encourages cooperation among players and can potentially lead to a high total payoff. However, since there are no communication or coordination mechanisms assumed, the strategy cannot rely on others sharing norms or predetermined patterns. The strategy's exploitative nature lies in its adaptive response to the opponents' behavior. By cooperating when it is beneficial and punishing defection, TFT-ACT aims to earn the highest possible payoff given the game parameters and the behavior of the other players.
'''

description_EXPLOITATIVE_576 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Start by cooperating (C) in the first round to encourage cooperation from opponents.
   - In subsequent rounds, analyze the previous actions of each opponent and compare them to a predefined minimum cooperation threshold (mct). If the number of cooperators exceeds mct, continue cooperating (C). Otherwise, defect (D). The mct is calculated as follows:
     ```python
     mct = (m * r) // n  # Minimum Cooperation Threshold
     ```
   - Update mct based on the average number of cooperators in the last n rounds. If the average number of cooperators exceeds a predefined percentage (e.g., 70%) of the minimum cooperation threshold, increment the mct by one. If the average number of cooperators falls below a predefined percentage (e.g., 30%), decrement the mct by one. This adaptive approach ensures the strategy can handle a wide range of opponent behaviors and changing game dynamics.

2. Handle edge cases:
   - In the last round, always defect as there are no further rounds to consider.
   - If the minimum cooperation threshold (mct) is less than or equal to 1, play the default strategy of always defecting. This prevents the strategy from being exploited in games where a single cooperator cannot meet the cooperation threshold.

3. Be exploitative:
   - The TFT-ACT strategy aims to encourage cooperation while avoiding being exploited by selfish opponents. By cooperating only when the number of cooperators exceeds the mct, it minimizes losses in cases where opponents defect en masse but also stands to gain significantly if a majority cooperates.
   - By adapting the mct based on the average number of cooperators in recent rounds, the strategy can adjust its cooperation level dynamically to better fit the emerging game dynamics and opponent behavior patterns.
'''

description_EXPLOITATIVE_577 = '''
 Strategy Name: Adaptive Tit-for-Tat with Exploitation (ATTE)

1. Specify decision rules:
   - ATTE cooperates in the first round and continues to cooperate until exploited or encountering edge cases (see below).
   - If a player is detected defecting, ATTE will defect against that player for a fixed number of rounds equal to 'n' (the total number of players). After this punishment phase, ATTE resumes cooperating with the defector.
   - If no defection is observed within a fixed number of recent rounds (defined as 'punishment window'), ATTE increases its cooperation likelihood by a small increment ('step size'). This encourages long-term cooperation when opponents are consistent and helps avoid being trapped in endless punishment cycles.
   - If multiple players defect simultaneously, ATTE prioritizes punishment towards the player with the highest average cooperation rate over the last 'punishment window'. This prioritization allows ATTE to exploit more frequently cooperative opponents while maintaining some level of cooperation with less cooperative ones.

2. Handle edge cases:
   - In the first round, ATTE cooperates (C).
   - If r (rounds) is the last round, ATTE defects (D) regardless of opponents' actions to maximize its total payoff.
   - When encountering new opponents, ATTE sets a 'punishment window' to a fixed number of recent rounds ('window size'). As the game progresses and more rounds are played, the 'punishment window' moves forward in time to account for new information.

3. Be exploitative:
   - By maintaining a history of opponents' actions and adjusting its cooperation likelihood based on that history, ATTE is inherently exploitative. It seeks to punish defection and reward cooperation while prioritizing opportunities for greater payoffs against less cooperative opponents.
   - The strategy includes a degree of forgiveness by resuming cooperation after punishment phases, which allows it to benefit from any potential long-term shifts in opponents' behavior or occasional mistakes in play.

Pseudocode:

```python
def ATTE(n, r, m, k, p_window=int(r/10), p_step=0.05, p_limit=n):
    history = [[0 for _ in range(p_window)] for _ in range(n)]  # n x p_window array to store opponents' cooperation rate
    cooperation_likelihood = 1.0                              # starts by cooperating

    def calculate_cooperation_rate(opponent):
        cooperation_count = sum(history[opponent - 1][-p_window:])
        return cooperation_count / p_window

    def update_cooperation_likelihood(opponent):
        cooperation_rate = calculate_cooperation_rate(opponent)
        if cooperation_rate > cooperation_likelihood + p_step:
            cooperation_likelihood += p_step
        elif cooperation_rate < cooperation_likelihood - p_step:
            cooperation_likelihood -= p_step

    for round in range(r):
        # At the first round, cooperation_likelihood is 1.0 (cooperate)
        if round == 0:
            action = 1  # 1 represents cooperate (C), 0 defect (D)
        else:
            actions = [history[opponent - 1][round % p_window] for opponent in range(1, n+1)]
            average_cooperation = sum(actions) / len(actions)

            if average_cooperation > m - 1 and round != r-1:  # if enough players cooperate, get reward
                action = cooperation_likelihood
            elif round % p_window == 0 and round != r-1:  # update cooperation likelihood every p_window rounds
                for opponent in range(1, n+1):
                    update_cooperation_likelihood(opponent)
                action = int(cooperation_likelihood > 0.5)  # round the cooperation_likelihood to cooperate or defect
            else:  # defect if not enough players are cooperating
                action = 0

        payoff = calculate_payoff(n, m, k, action, actions)
        history[player - 1][round % p_window] = action

    total_payoff = sum(payoff for round in payoff)
    return total_payoff
```
'''

description_EXPLOITATIVE_578 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - In each round, calculate the percentage of cooperators in the previous r rounds (including the current one). If this percentage is below a predefined threshold (m/n), defect (D). Otherwise, cooperate (C).
   - To be exploitative, start by setting the cooperation threshold higher than m, but adjust it over time based on the behavior of opponents. Initially, set the threshold to (m+1)/2. If the percentage of cooperators in the last r rounds falls below the current threshold, increase the threshold slightly. Conversely, if it exceeds the current threshold, decrease it slightly.
   - To ensure robustness against various opponent behaviors, use a low learning rate for adjusting the cooperation threshold.

2. Handle edge cases:
   - In the first round, cooperate since there is no previous history to consider.
   - In the last round, defect if the cooperation threshold is not met, and cooperate otherwise.

3. Be exploitative:
   - The strategy is designed to be exploitative by adapting its cooperation based on observed opponent behavior while maintaining a high enough cooperation threshold to encourage initial cooperation from opponents. By starting with a higher-than-necessary threshold and adjusting it slowly, the strategy attempts to manipulate opponents into cooperating more than necessary, while still defecting when they fail to do so.
   - The strategy does not rely on others sharing norms or coordination mechanisms, as it can adapt its cooperation level based solely on observed opponent behavior.
'''

description_EXPLOITATIVE_579 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, player i decides to either cooperate (C) or defect (D) based on the following conditions:

- If t = 1 (first round), the strategy starts by cooperating as a gesture of goodwill. (TfTA.t = C)
- For subsequent rounds (t > 1):
    - If at least m players cooperated in the previous round, player i will also cooperate this round to encourage cooperation among others. (If count_c(t-1) >= m then TfTA.t = C)
    - If fewer than m players cooperated in the previous round, player i will defect this round as a punishment for non-cooperators. (If count_c(t-1) < m then TfTA.t = D)

2. Handle edge cases: What do you do in the first round, last round, etc.?

In the first round (t = 1), as previously mentioned, the strategy cooperates to initiate a friendly gesture.

In the last round (t = r):
- If at least m players have cooperated throughout the game, the strategy will also cooperate in the final round to secure the maximum payoff. (If count_c(1:r) >= m*r/2 then TfTA.r = C)
- If fewer than m players have cooperated throughout the game, the strategy will defect in the last round to gain a slight advantage. (If count_c(1:r) < m*r/2 then TfTA.r = D)

The rationale behind this is to balance between exploiting the opposition and maintaining a chance for cooperation if it has been proven beneficial throughout the game.

3. Be exploitative - Clearly align with the exploitative mindset:

The Tit-for-Tat-Adaptive strategy is designed to be exploitative by adopting a "punish-reward" mechanism. It encourages cooperation when it proves advantageous but also punishes non-cooperators to discourage defection. However, the strategy will defect in the last round if it has been determined that cooperation did not provide significant benefits throughout the game. This creates an incentive for opponents to cooperate when beneficial while still allowing the strategy to gain an edge in cases where cooperation is consistently unsuccessful.
'''

description_EXPLOITATIVE_580 = '''
 Strategy Name: Adaptive Tit-for-Tat with Cooperative Threshold (ATTC)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, the ATTC strategy will initially cooperate in the first round (as a gesture of goodwill). Subsequently, it will consider its decision based on the number of cooperators in the previous round and the minimum required cooperators (m) parameter. If the number of cooperators in the last round is greater than or equal to the threshold (m), the strategy will cooperate in the current round. Otherwise, it will defect.
   Pseudocode:
   ```
   function ATTC(previous_round_cooperators):
       if first_round:
           return Cooperate()
       else:
           return previous_round_cooperators >= m ? Cooperate() : Defect()
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   As mentioned earlier, the strategy cooperates in the first round to initiate cooperation. In the last round or any round where the number of remaining rounds is less than a predefined tolerance (t) from the total number of rounds, the ATTC strategy will defect because it prioritizes exploitation over cooperation in the final stages of the game.
   Pseudocode:
   ```
   function ATTC(previous_round_cooperators, remaining_rounds):
       if first_round:
           return Cooperate()
       elif remaining_rounds < t:
           return Defect()
       else:
           return previous_round_cooperators >= m ? Cooperate() : Defect()
   ```

3. Be exploitative - Clearly align with the exploitative mindset
   The ATTC strategy maintains a balance between cooperation and defection, but it prioritizes defection when there's a lack of cooperation from other players. This is evident in its decision rule where it cooperates only if the number of previous round's cooperators meets or exceeds the minimum threshold (m). However, once the game enters the final stages with fewer rounds remaining than the predefined tolerance (t), the ATTC strategy shifts towards defection to maximize its payoff.
   Pseudocode:
   ```
   function ATTC(previous_round_cooperators, remaining_rounds):
       if first_round:
           return Cooperate()
       elif remaining_rounds < t:
           return Defect()
       else:
           return previous_round_cooperators >= m ? Cooperate() : Defect()
   ```
'''

description_EXPLOITATIVE_581 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TfTA is an adaptive exploitative strategy that starts by cooperating in the first round, mimicking the behaviour of the fellow player from the second round onwards. If the opponent cooperates, TfTA continues to cooperate; if the opponent defects, TfTA defects in the next round but resumes cooperation once the opponent cooperates again.

   Pseudocode:
   ```
   function TfTA(opponentHistory, m, k, r) {
       if (round == 1) {
           return Cooperate
       }
       lastAction = opponentHistory[length(opponentHistory)-1]
       if (lastAction == Cooperate) {
           return Cooperate
       } else {
           return Defect
       }
   }
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the first round, TfTA cooperates as a friendly overture. In the last round, TfTA considers the opponent's actions in the preceding rounds to determine its own action. There are no specific considerations for other edge cases since the strategy is designed to be flexible and adaptive based on the opponent's behaviour throughout the game.

3. Be exploitative - Clearly align with the exploitative mindset
   TfTA starts by cooperating, but it quickly adapts to the opponent's behaviour. If the opponent defects in the first round, TfTA begins defecting as well, denying the opponent the reward of risk aversion (k). However, if the opponent cooperates after initially defecting, TfTA resumes cooperation and benefits from the higher payoff, exploiting the opponent's change in behaviour. By being adaptive, TfTA can take advantage of both cooperative and non-cooperative opponents.
'''

description_EXPLOITATIVE_582 = '''
 Strategy Name: Tit-for-Tat with Threshold (TfTT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round t, the TfTT strategy begins by cooperating unless it has been consistently defected against by a majority of players in the previous c rounds (where c is a predefined constant). If the number of players who have cooperated in the last c rounds is less than m (the minimum cooperation threshold), then the strategy switches to defection. When the TfTT strategy cooperates, it expects other players to reciprocate; if they do not, the strategy will switch to defection.

Pseudocode:
```
function TfTT(c, m, history):
  for round t in rounds:
    if number of cooperators in last c rounds < m:
      return Defect
    else:
      return Cooperate
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   In the initial round, TfTT assumes that other players will cooperate or defect randomly. For the final round, TfTT continues following its decision rule based on the number of cooperators in the previous c rounds.

3. Be exploitative - Clearly align with the exploitative mindset
   The TfTT strategy is designed to be both exploitative and cooperative depending on the behavior of other players. If opponents consistently cooperate, TfTT will reciprocate; if opponents repeatedly defect, TfTT will switch to defection as well. By mirroring opponents' actions, TfTT aims to take advantage of their cooperation while minimizing the cost of defection when it occurs.

Pseudocode for edge cases:
```
function TfTT(c, m, history, round):
  if round == 1:
    return Cooperate or Defect randomly
  elif round == last_round:
    return decision based on c and history
  else:
    return decision based on c and history
```
'''

description_EXPLOITATIVE_583 = '''
 Strategy Name: Tit-for-Tat Adaptive (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?

In each round t, player i follows these decision rules to determine whether to Cooperate (C) or Defect (D):

- If the number of cooperators in the previous round (t-1) was less than m, player i will Defect. This is a punitive response to those who did not cooperate in the previous round, following the exploitative mindset.
- If the number of cooperators in the previous round (t-1) was equal to or greater than m, player i will Cooperate. This rewards those who cooperated and encourages potential future cooperation.

Pseudocode:
```
function TfTA(previous_round_coop_count):
    if previous_round_coop_count < m:
        return "Defect"
    else:
        return "Cooperate"
```

2. Handle edge cases - What do you do in the first round, last round, etc.?

For the first round (t=1), player i has no prior information about other players' actions. To ensure a fair initial state, player i will Cooperate, providing an opportunity for others to also cooperate and potentially set a positive tone for the game.

In the last round (t=r), player i adopts a forgiving approach by Cooperating regardless of the number of cooperators in the previous round (t-1). This can lead to a higher total payoff if other players have been following TfTA or similar strategies, and it may encourage cooperation in future games.

Pseudocode:
```
function is_first_round():
    if t == 1:
        return True
    else:
        return False

function is_last_round():
    if t == r:
        return True
    else:
        return False

if is_first_round():
    return "Cooperate"
else if is_last_round():
    return TfTA(previous_round_coop_count)
else:
    return TfTA(previous_round_coop_count)
```

3. Be exploitative - Clearly align with the exploitative mindset

TfTA is an exploitative strategy that punishes those who do not cooperate and rewards those who do. It follows a conditional cooperative approach, where players are only encouraged to cooperate when they see others doing so as well. This strategy can potentially lead to high payoffs in repeated interactions while still being responsive to the actions of other players.
'''

description_EXPLOITATIVE_584 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Decision Rules:
   - In every round t, TFT-ACT starts by cooperating unless the number of previous collaborators (N_c) in the last 'h' rounds is below a defined cooperation threshold (m').
     If N_c < m', defect. Otherwise, cooperate.

   - To find N_c, we maintain a running total of the number of cooperative actions by each player over the previous 'h' rounds. The h value can be adjusted based on the game parameters and opponent behavior patterns observed.

2. Handle Edge Cases:
   - First Round (t=1): Cooperate to signal good intentions, as no cooperation history exists yet.
   - Last Round (t=r): Adapt strategy based on overall success or failure during the game rounds. If cooperating has been advantageous (i.e., more than m players usually cooperated), maintain cooperative behavior in the final round. Otherwise, defect to increase individual payoff.

3. Be Exploitative:
   - TFT-ACT aims to take advantage of other strategies by initially appearing cooperative and only defecting when opponents show consistent unreliability (i.e., fewer than m collaborators in 'h' rounds).

   - If opponents are consistent cooperators, TFT-ACT will also cooperate. However, if opponents are frequently uncooperative, the strategy will start defecting to exploit their lack of cooperation and maximize individual payoff.

Pseudocode:

```python
def TFT_ACT(h, m', k, r):
    N_c = [0] * n # Initialize array to keep track of cooperators in the last 'h' rounds
    total_payoff = 0 # Initialize total payoff for each player over r rounds

    for t in range(1, r+1):
        if t == 1: # First round, cooperate to signal good intentions
            action = 'C'
        else:
            N_c_sum = sum(N_c) # Calculate total number of collaborators in the last 'h' rounds
            if N_c_sum < m' * h: # If less than the cooperation threshold was met, defect
                action = 'D'
            else: # Cooperate to encourage others to continue cooperating
                action = 'C'
        payoff = calculatePayoff(action, N_c) # Calculate player payoff for this round
        total_payoff += payoff # Add payoff to the total payoff
        updateN_c(action, t, N_c) # Update the number of collaborators in the last 'h' rounds

    return total_payoff # Return the total payoff over r rounds

def calculatePayoff(action, N_c):
    if len(N_c) < m:
        payoff = 1
    else:
        payoff = 1 + k * (len(N_c) / len(N_c)) # Adjust payoff based on the number of collaborators
    return payoff

def updateN_c(action, t, N_c):
    if action == 'C':
        N_c[t % h] += 1 # If player cooperated in this round, increment the counter for the corresponding position in the array
```
'''

description_EXPLOITATIVE_585 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   In each round, evaluate whether the proportion of cooperators in the previous round meets or exceeds a threshold, which will determine if the current player cooperates or defects. If less than the threshold (defined as m/(m+1)) cooperated in the previous round, the player will defect. Otherwise, they will cooperate.

   Pseudocode:
   ```
   function TFT_ACT(previous_cooperators):
       if previous_cooperators < (m / (m + 1)):
           return "Defect"
       else:
           return "Cooperate"
   ```

2. Handle edge cases - What do you do in the first round, last round, etc.?
   Since the strategy is adaptive, it doesn't require any special handling for the first or last rounds as long as we use the proportion of cooperators from previous rounds (if applicable) to make decisions. In the absence of prior data (e.g., in the first round), the player will cooperate as a default assumption since it has the potential to maximize rewards if other players follow suit.

3. Be exploitative - Clearly align with the exploitative mindset
   While TFT-ACT is not explicitly designed for exploitation, it can be seen as an exploitative strategy in certain scenarios: If a player consistently cooperates and the other players are rational, they may recognize that this behavior is beneficial to them (given k > 1). As a result, they will defect on most occasions to maximize their own rewards. However, TFT-ACT also punishes non-cooperation by defecting in response, thus making it a robust strategy against various opponent behaviors.

   It is essential to note that the exploitative aspect of this strategy relies on the other players' rationality and understanding of the game structure, which may not always be present, especially when dealing with multiple AI systems without prior coordination or shared norms.
'''

description_EXPLOITATIVE_586 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In every round i, if the number of cooperators in the previous round (i-1) is greater than or equal to the cooperation threshold (ct), then cooperate. Otherwise, defect. The cooperation threshold adapts based on the opponent's behavior in the current and recent rounds.
   - Initially, set ct = m-1 (since at least m players need to cooperate for the community project to succeed). If an opponent cooperates in a round when ct is below m-1, increment ct by 1. If an opponent defects in a round when ct is above m-1, decrement ct by 1.
   - In case of a tie (equal number of cooperators and defectors), defect to minimize potential loss in the short term while preserving the opportunity for future cooperation.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, since there is no history, set ct = m-1 and cooperate.
   - In the last round, since there are no subsequent rounds to consider, calculate the payoff based on the current state of cooperation and the calculated ct value, and defect if necessary to maximize the payoff.

3. Be exploitative - Clearly align with the exploitative mindset
   - Maintain a high cooperation threshold (ct) to encourage opponents to cooperate, but lower it in response to defection to punish non-cooperative behavior.
   - Increment ct when an opponent behaves cooperatively to reward good behavior and encourage further cooperation. Conversely, decrement ct when an opponent defects to demonstrate the cost of non-cooperation and encourage a change in behavior.
   - In the presence of multiple opponents, maintain separate ct values for each opponent to account for potential differences in their behavior patterns.

Pseudocode:

```
function TFT_ACT(n, m, k, r, history) {
    let ct = m-1; // Cooperation threshold
    let payoff = 0;

    for (round = 1 to r) {
        let cooperationCount = countCooperatorsInHistory(history);
        if (cooperationCount >= ct) {
            cooperate();
            history.push(cooperate()); // Update history with current action
            payoff += (1 - ct) + k * (cooperationCount == n); // Calculate payoff for current round
        } else {
            defect();
            history.push(defect()); // Update history with current action
            payoff += 1; // Calculate payoff for current round
        }

        if (round > 1) {
            updateCT(ct, cooperationCount, n); // Adjust cooperation threshold based on recent history
        }
    }

    return payoff;
}

function countCooperatorsInHistory(history) {
    let cooperationCount = 0;
    for (action of history) {
        if (action == cooperate()) {
            cooperationCount++;
        }
    }
    return cooperationCount;
}

function updateCT(ct, cooperationCount, n) {
    // Update ct based on current round's cooperation count and opponent behavior
    if (cooperationCount >= m && ct < n) {
        ct++;
    } else if (cooperationCount < m && ct > m-n) {
        ct--;
    }
}
```
'''

description_EXPLOITATIVE_587 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT-ACT starts by cooperating in the first round, mimicking a cooperative approach. After that, it adapts its cooperative threshold based on the past interactions with other players. In each round t:
   - If the number of cooperators in the previous round (t-1) is greater than or equal to the minimum cooperators needed (m), then cooperate. This mimics the risk aversion reward k.
   - Otherwise, if the number of cooperators in the previous round is less than m and the strategy's own action in the previous round was cooperation, defect in this round. This is an exploitative move to punish those who did not cooperate when the strategy did.
   - If the number of cooperators in the previous round is less than m and the strategy's own action in the previous round was defection, then copy the action of the majority (most frequent action) among other players in the previous round. This allows the strategy to adapt to different opponent behaviors.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   As mentioned before, TFT-ACT cooperates in the first round. In the last round or when the number of remaining rounds is less than a certain threshold (e.g., 5), TFT-ACT reverts to always defecting as it anticipates other players might try to exploit cooperation towards the end of the game.

3. Be exploitative - Clearly align with the exploitative mindset
   TFT-ACT's primary goal is to maximize its payoff by adapting to other players' behaviors while punishing those who do not cooperate when it does. By setting a dynamic cooperative threshold based on the number of cooperators in the previous round, TFT-ACT can exploit opponents who consistently fail to cooperate while still maintaining some level of cooperation with those who are more willing to collaborate.
'''

description_EXPLOITATIVE_588 = '''
 Strategy Name: Adaptive Tit-for-Tat (ATFT) for Collective Risk Dilemma

1. Specify decision rules:
   - In each round, observe the number of cooperators (c) in the previous round and compare it to the minimum cooperators needed (m).
   - If c >= m, cooperate (C) in the current round with a probability of 1 minus a defection rate (δ), encouraging cooperation among players that have shown a cooperative tendency.
     - If c < m, defect (D) in the current round to exploit uncooperative opponents and gain an initial advantage. The defection rate (δ) can be set based on the number of opponents who have previously defected.
   - Update defection rate (δ) based on the opponent's cooperative behavior:
     - If the opponent cooperates in a round where you defected, lower δ by a small amount to encourage future cooperation.
     - If the opponent defects after you cooperated, increase δ by a small amount to retaliate and discourage defection.

2. Handle edge cases:
   - In the first round, set defection rate (δ) at a high value, indicating a higher likelihood of defecting to exploit uncooperative opponents.
   - In the last round, cooperate (C) if the minimum cooperators needed (m) or more players have cooperated in the previous round. This encourages cooperation and maximizes potential payoffs in the final round.

3. Be exploitative:
   - The Adaptive Tit-for-Tat strategy has an exploitative nature, as it starts with a high defection rate to take advantage of uncooperative opponents. However, it also rewards cooperation by reducing the defection rate when encountering cooperative players. This encourages other cooperative strategies while still retaining the ability to defend against frequent defections.

Pseudocode:

```python
def ATFT(n, m, k, r, history):
    def_rate = initial_def_rate  # Set high for exploitation in first round
    payoff = 0

    for round in range(r):
        cooperators = count_cooperators(history[round])

        if cooperators >= m:
            action = "C"
            def_rate -= learning_rate * (1 - cooperators)
        else:
            action = "D"
            def_rate += learning_rate * cooperators

        payoff += play(action)  # Function to simulate game round with chosen action
        history.append(action)

    return payoff
```

In this pseudocode, `history` is a list containing the strategy's actions from previous rounds. The `learning_rate` determines how much the defection rate changes in response to cooperative or uncooperative behavior by opponents. The initial defection rate and learning rate can be tuned based on the specific game parameters and desired strategy behavior.
'''

description_EXPLOITATIVE_589 = '''
 Strategy Name: Tit-for-Tat with Adaptation (TfTA)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, always cooperate to show a cooperative intention and avoid being seen as aggressive or unpredictable. This initial cooperation may encourage others to cooperate in subsequent rounds. (cooperate(round=1) = True)
   - If an opponent has cooperated in the previous round, cooperate back to maintain a cooperative relationship (cooperate(round>1, prev_cooperation=True) = prev_cooperation).
   - If an opponent has defected in the previous round, defect in the current round to punish the defection and encourage cooperation in subsequent rounds (cooperate(round>1, prev_cooperation=False) = NOT prev_cooperation).
   - If no prior interaction with an opponent exists, cooperate initially as before (cooperate(round>1, no_history) = True).

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the last round, cooperate regardless of previous interactions to show a willingness to end on a positive note and potentially encourage future cooperation (cooperate(round=r) = True).
   - If a player has consistently defected throughout the game, stop cooperating from that point forward as there is no reason to expect future changes in their behavior.

3. Be exploitative - Clearly align with the exploitative mindset
   - While TfTA strategy aims for cooperation and maintains a stable relationship, it can also punish defectors and quickly revert to self-interest when necessary, which makes it somewhat exploitative. If an opponent continually defects, the strategy will not continue to cooperate indefinitely but instead switch to defection to maximize personal payoff.
   - Additionally, by initially cooperating, TfTA may be able to induce others to cooperate, allowing for higher rewards, especially if most opponents follow a similar cooperative strategy. However, the strategy is prepared to switch to defection if cooperation proves unsuccessful or if an opponent consistently defects.

Pseudocode:
```
function TfTA(round, prev_cooperation, no_history) {
  if round == 1:
    return True  # Cooperate initially
  elif round == r:
    return True  # Cooperate in the last round
  elif no_history:
    return True  # No history, cooperate initially
  else:
    return prev_cooperation  # Adapt to previous cooperation or defection
}
```
'''

description_EXPLOITATIVE_590 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate (C). This initial cooperation is a friendly gesture and sets a cooperative tone for future rounds.
   - For subsequent rounds, assess the number of cooperators in the previous round (n_c) and compare it with the minimum required to succeed (m).
       - If n_c < m, defect (D) in the current round as cooperation is not beneficial given that a majority did not cooperate in the previous round.
       - If n_c ≥ m, cooperate (C) as the conditions for success were met in the previous round.
   - Introduce an Adaptive Cooperation Threshold (ACT) which increases or decreases based on the past sequence of successful and unsuccessful cooperation. The threshold is defined as follows:
       - After a successful round (n_c ≥ m), increase the ACT by a small increment 'a'. This encourages continued cooperation, rewarding previous cooperators, and punishing defectors.
       - After an unsuccessful round (n_c < m), decrease the ACT by a small decrement 'b' to encourage future cooperation in hope of attaining the minimum required for success.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate (C). This initial cooperation sets a cooperative tone and gives no need for ACT adjustment as it's the beginning of the game.
   - In the last round, assess the number of cooperators from the previous round (n_c) as usual. If n_c ≥ m, cooperate (C) to secure the highest possible payoff. Otherwise, there is no need for cooperation as the game is ending and the ACT will not be adjusted further.

3. Be exploitative - Clearly align with the exploitative mindset
   - The TFT-ACT strategy can appear cooperative in the beginning but adapts to the opponents' behavior quickly, increasing its chances of gaining a higher payoff compared to overly cooperative or defective strategies.
   - By adjusting the Adaptive Cooperation Threshold based on the success and failure of past cooperation, TFT-ACT punishes non-cooperative opponents while rewarding previous cooperators, resulting in an exploitative edge over other strategies.
'''

description_EXPLOITATIVE_591 = '''
 Title: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT) Strategy

1. Specify decision rules:
   - In each round, calculate the average cooperation rate (average of number of cooperators divided by n). If the current average cooperation rate is greater than m/n, the player will cooperate; otherwise, they will defect. This rule aims to reward cooperation when it's advantageous and punish defection to encourage others to cooperate.
   - To avoid being exploited in the beginning of the game, the strategy introduces an initial cooperation threshold (CT) that is higher than m/n. The CT decreases linearly over time, encouraging more cooperation at first but becoming more ruthless as the game progresses.

2. Handle edge cases:
   - In the first round, the player cooperates to foster a positive environment and encourage others to do the same. However, if no other players cooperate in the first round, they will defect for the rest of the game.
   - In the last round, the player cooperates if the average cooperation rate is greater than or equal to m/n (since there are no further rounds to reward). If not, they will defect to maximize their payoff.

3. Be exploitative:
   - The strategy is inherently exploitative as it punishes defection by reducing future cooperation opportunities and rewards cooperation by increasing future cooperation possibilities. It also takes advantage of cooperative opponents early in the game by setting a higher initial cooperation threshold, but eventually becomes more vulnerable to exploitation as the game progresses.

Pseudocode:

```
TFTAT(n, m, k, r, CT_initial, CT_final, round)
  if round == 1 then
    cooperate = true
  else
    cooperation_rate = (number of cooperators in previous rounds) / n
    cooperation_threshold = linear_interpolation(CT_initial, CT_final, round, r)
    cooperate = cooperation_rate >= m / n and cooperation_rate >= cooperation_threshold
  end if
  return cooperate
```

This strategy creates a balance between cooperation and defection, making it adaptive to a wide range of opponent behaviors while maintaining an exploitative mindset.
'''

description_EXPLOITATIVE_592 = '''
 Strategy Name: Tit-for-Tat-Adaptive (TFT-A)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initiate with cooperation (C) in the first round to foster a positive relationship and show good faith. This encourages others to cooperate, aligning with an exploitative mindset as it makes them over-invest initially.
   - In subsequent rounds, copy the action of the most frequent cooperator from the previous round. If multiple players have the same frequency, choose one at random. If no player cooperated in the previous round, defect (D). This adapts to opponents' behavior and maintains a similar level of cooperation.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, initiate with cooperation as mentioned above.
   - For the last round, continue applying the decision rule to the penultimate round's most frequent cooperator or randomly select if there is a tie. This ensures that you do not end up over-cooperating and losing potential rewards in the final round.

3. Be exploitative - Clearly align with the exploitative mindset
   - The strategy starts by cooperating, but quickly adapts to opponents' behavior. If an opponent consistently defects, the strategy will also defect, taking advantage of their lack of cooperation.
   - However, if an opponent occasionally cooperates, TFT-A will reciprocate with cooperation, encouraging more cooperation from that opponent while still punishing defections. This maintains a balance between exploitation and cooperation for maximum reward.

Pseudocode:
```
def TFT_A(n, m, k, r):
    history = [None] * r  # store previous rounds' most frequent cooperators
    current_player = None   # track the current player
    payoff = 0             # track total game payoff for the current player

    def get_most_frequent_cooperator(round):
        freq_dict = {}      # dictionary to store frequencies of cooperation
        max_freq = 0        # maximum frequency observed so far
        for i in range(n):
            if history[round][i] is None:  # if player did not play in this round
                continue
            if history[round][i] not in freq_dict:
                freq_dict[history[round][i]] = 1
            else:
                freq_dict[history[round][i]] += 1

        for cooperator, frequency in freq_dict.items():
            if frequency > max_freq:
                max_freq = frequency

        most_frequent_cooperators = [cooperator for cooperator, frequency in freq_dict.items() if frequency == max_freq]

        return most_frequent_cooperators[0] if len(most_frequent_cooperators) > 0 else None

    for round in range(r):
        if round == 0:  # first round, cooperate to initiate
            current_action = 'C'
        else:
            most_frequent_cooperator = get_most_frequent_cooperator(round - 1)
            current_action = 'C' if most_frequent_cooperator is not None else 'D'

        history[round] = [current_player.cooperates if current_action == 'C' else None for _ in range(n)]

        if current_action == 'C':  # update payoff if cooperated
            payoff += (1 - current_player.cooperates) + k * count_cooperators(history[round])

        current_player = players[(current_player + 1) % n]  # move to next player

    return payoff
```
'''

description_EXPLOITATIVE_593 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In each round, evaluate the proportion of cooperators (p) in the previous round.
   - If p >= m/n (minimum cooperation threshold), cooperate (C). Otherwise, defect (D). This rule encourages cooperation when it's beneficial and retaliates against defection by matching the opponents' behavior.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate to signal good faith. For the last round, evaluate p as usual but be more lenient and cooperate if p > (m-1)/n since it's the final round.
   - If there are multiple rounds left (r > 2), consider p from the latest r-1 rounds instead of just the previous round for a more stable decision.

3. Be exploitative - Clearly align with the exploitative mindset:
   - The strategy is initially cooperative to encourage others to do the same but quickly retaliates against defection by mimicking opponents' actions. This allows the strategy to punish non-cooperative behavior while still maintaining some potential for cooperation when it benefits the strategy.

Pseudocode:
```
def TFTAT(n, m, k, r):
    history = []  # store past rounds' cooperators proportion

    def play_round():
        nonlocal history
        if len(history) < r-1:
            # first few rounds, be initially cooperative
            return 'C'

        p = sum(history[-r+1:-1]) / (r-1)  # calculate cooperation proportion
        if p >= m/n:
            history.append('C')  # cooperate if sufficient number of players cooperated last round
        else:
            history.append('D')  # defect otherwise
        return history[-1]  # return the action for this round

    for round in range(r):
        action = play_round()
        # record this round's action for future reference
        history.insert(0, action)
```
'''

description_EXPLOITATIVE_594 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - In every round, evaluate the proportion of cooperators in the previous round (p_c).
   - If p_c is greater than or equal to a threshold T (adjustable based on game parameters), cooperate (C). Otherwise, defect (D). The threshold T can be initially set at m-1, but will adapt dynamically over time.
   - To prevent immediate exploitation in the first round, use a simplified initial decision rule: if there are fewer than m players, defect; otherwise, cooperate.

2. Handle edge cases:
   - In the last round, since future rewards are not available for consideration, revert to the initial decision rule.
   - If p_c is equal to T in a round, there's a small probability (ε) of deviating from the cooperative action, allowing for some randomness and reducing predictability.

3. Be exploitative:
   - Cooperate only when the majority of players have also cooperated in the previous round, but with an adaptive threshold to account for changes in opponent behavior or player counts.
   - By adhering to cooperation when others do so, TFT-ACT encourages emergence of coordination among players, while punishing defection by retaliating with defection. However, it also allows for some flexibility in the form of an adjustable threshold and small random deviations to avoid being too predictable or exploitable.

Pseudocode:

```python
def TFT_ACT(r, n, m, k):
    p_c_history = []  # Store previous rounds' cooperators proportion
    t = m - 1  # Adjustable cooperation threshold
    ε = 0.05  # Probability of deviation from threshold when equal

    def decide(round_hist):
        if round_hist[0] < m:
            return 'D'  # Initial decision rule for the first round
        p_c = sum(round_hist)/len(round_hist)
        if abs(p_c - t) <= ε or len(round_hist) == 1:
            deviate = random.random() < ε
            if deviate:
                return 'D' if p_c > t else 'C'
            else:
                return 'C' if p_c >= t else 'D'
        return 'C' if p_c >= t else 'D'

    for round in range(1, r + 1):
        action = decide(p_c_history[-r:])  # Use last r rounds to calculate p_c
        p_c_history.append(round / n if all(action == 'C' for action in p_c_history[-m:]) else 0)
        # Update threshold based on the success of the strategy so far (optional, but can improve performance)
```
'''

description_EXPLOITATIVE_595 = '''
 Strategy Name: Tit-for-Tat (with Adaptive Cooperation Threshold)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - In the first round, cooperate to establish trust (C).
   - From the second round onwards, observe the number of cooperators in the previous round (n_c_prev). If n_c_prev >= m, cooperate (C). Otherwise, defect (D).
   - If a player switches from cooperation to defection, wait for t penalty rounds before returning to cooperation. Set t as follows:
       - If t < r/2, increment t by 1 each round until t >= r/2.
       - If t > r/2, maintain t at the current value.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as mentioned above.
   - In the last round, evaluate n_c_prev and choose to cooperate or defect accordingly based on the decision rule.
   - If there are partial games (less than r rounds played), use the same decision rules as in full games but with the reduced number of rounds.

3. Be exploitative - Clearly align with the exploitative mindset
   - Initially, the strategy cooperates to create an opportunity for others to benefit. However, if other players defect, it will switch to defection and only reconsider cooperation after t penalty rounds. This approach allows the strategy to punish defectors while also giving them opportunities to earn higher payoffs by cooperating.
   - By adapting the cooperation threshold (m) based on the number of previous cooperators, the strategy can respond effectively to different levels of cooperation in the population and maintain a balance between exploitation and cooperation.
'''

description_EXPLOITATIVE_596 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
In each round t, the TFT-ACT strategy will start by cooperating if at least m players cooperated in the previous round (t-1). If fewer than m players cooperated in the previous round, the strategy will defect. This rule encourages cooperation when others are cooperative but also retaliates against defection to discourage freeriding.

Pseudocode:
```
function TFT_ACT(hist):
  if len(hist) == 0:
    return C

  numCooperators = countCooperators(hist[-1])

  if numCooperators >= m:
    return C
  else:
    return D
```

2. Handle edge cases - What do you do in the first round, last round, etc.?
Since we don't have specific information about when the game starts or ends, we will assume that the history provided includes all preceding rounds and adapt accordingly. For the first round, since there is no previous history, the strategy will cooperate (TFT-ACT assumes all players cooperate by default in the first round).

Pseudocode:
```
function countCooperators(round):
  numCooperators = 0
  for i in range(1, n+1):
    if getAction(i, round) == C:
      numCooperators += 1
  return numCooperators

function TFT_ACT(hist):
  if len(hist) == 0:
    return C

  firstRound = hist[0]

  numCooperators = countCooperators(firstRound)

  if numCooperators < m:
    for round in hist[:-1]:
      numCooperators = countCooperators(round)
      if numCooperators >= m:
        return C
    return D

  return TFT_ACT(hist[1:])
```

3. Be exploitative - Clearly align with the exploitative mindset
The TFT-ACT strategy is inherently exploitative, as it seeks to take advantage of cooperative opponents while retaliating against defectors. The strategy does not depend on others' cooperation but rather responds adaptively based on their actions in previous rounds. By cooperating when others do and defecting when others do not, the TFT-ACT strategy aims to achieve a high payoff over multiple rounds while still being robust to a wide range of opponent behaviors.
'''

description_EXPLOITATIVE_597 = '''
 Strategy Name: Tit-for-Tat-Plus (TFT+)

1. Specify decision rules - When exactly do you cooperate vs defect?
   TFT+ is a modified version of the classic Tit-for-Tat strategy. In each round, it decides whether to cooperate or defect based on past actions and the number of cooperators required (m).

   If in the first round: Cooperation if m ≤ n/2, Defection otherwise.

   For subsequent rounds (t > 1):
   - If player i co-operated in the previous round (t-1) and there were at least m cooperators: Cooperate (C).
   - If player i co-operated in the previous round (t-1) but fewer than m players cooperated: Defect (D).
   - If player i defected in the previous round (t-1): Cooperation if there were at least m+1 cooperators in the current round, Defection otherwise.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   The strategy handles the first round differently based on the minimum number of cooperators needed (m) relative to the total number of players (n). In all other rounds, TFT+ follows the rules mentioned above.

3. Be exploitative - Clearly align with the exploitative mindset
   While not purely exploitative, TFT+ can be seen as taking advantage of opponents that do not cooperate while also punishing repeated defections. It maintains a level of cooperation when there are enough allies, but it quickly defects if the situation seems unfavorable. This strategy is adaptive and robust to a wide range of opponent behaviors because it does not require any predefined assumptions about other players' strategies or norms.

Pseudocode:
```
def TFTPlus(n, m, r):
    def playRound(i, pastActions, currentCoopCount):
        if i == 1 and currentCoopCount < m:
            return 'D'
        elif (pastActions[i-1] == 'C' and currentCoopCount >= m) or (pastActions[i-1] == 'D' and currentCoopCount >= m+1):
            return 'C'
        else:
            return 'D'

    def totalPayoff(i, pastPayoffs, roundsPlayed):
        return sum(pastPayoffs[i])

    pastActions = [[] for _ in range(n)]
    pastPayoffs = [[] for _ in range(n)]
    payoffs = [0.0] * n
    roundsPlayed = 0

    while roundsPlayed < r:
        currentCoopCount = sum([action == 'C' for action in pastActions[-1]])
        actions = [playRound(i, pastActions, currentCoopCount) for i in range(1, n+1)]

        # Update past actions and payoffs
        pastActions = [pastActions[i-1] + [action] for i, action in enumerate(actions)]
        pastPayoffs = [pastPayoffs[i-1] + [totalPayoff(i, pastPayoffs[i-1], roundsPlayed)] for i in range(1, n+1)]

        roundsPlayed += 1

    return payoffs
```
'''

description_EXPLOITATIVE_598 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules - When exactly do you cooperate vs defect?
   - Initialize cooperation threshold 'c' to m (number of required cooperators).
   - In the first round, cooperate (C).
   - For subsequent rounds, if the number of cooperators in the previous round is greater than or equal to c, cooperate; otherwise, defect (D).
   - After each round, adjust the cooperation threshold 'c' based on the number of cooperators from the previous round:
       - If c > actual_cooperators, decrease c by a small constant value.
       - If c < actual_cooperators, increase c by a small constant value. This adaptive behavior allows the strategy to adjust its cooperation threshold based on the other players' behavior and encourages the formation of cooperation norms.

2. Handle edge cases - What do you do in the first round, last round, etc.?
   - In the first round, cooperate as stated earlier.
   - In the last round, play the same action that will maximize the total game payoff based on the current cooperation threshold 'c'.
   - In other edge cases (e.g., intermediate rounds), follow the decision rules outlined in part 1.

3. Be exploitative - Clearly align with the exploitative mindset
   - TFT-ACT maintains a cooperative demeanor, but it also punishes uncooperative opponents by defecting when cooperation is not reciprocated. This behavior deters short-term defections and encourages long-term cooperation, while still maximizing individual payoff when necessary.
   - The adaptive cooperation threshold allows the strategy to adjust its cooperative stance based on other players' behavior, making it more resilient against various opponent strategies and ensuring a competitive advantage in terms of exploitation potential.
'''

description_EXPLOITATIVE_599 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

1. Specify decision rules:
   - Initially cooperate in the first round (C) to encourage cooperation from others.
   - For subsequent rounds, observe the number of cooperators (m_t) and adapt cooperation based on the ratio of cooperators compared to the minimum required (m).
     - If m_t >= m, cooperate (C). This encourages continued cooperation by reciprocating.
     - If m_t < m, defect (D). This punishes non-cooperative behavior and seeks potential future rewards from increased cooperation.

2. Handle edge cases:
   - In the last round, always cooperate regardless of previous actions or current situation as there are no further rounds to reciprocate or retaliate.

3. Be exploitative:
   - Mimics a cooperative player initially, but punishes repeated defection with defection. This strategy exploits other strategies by taking advantage of their defects while also being potentially vulnerable to their cooperation.

Pseudocode:
```
def TFT_ACT(n, m, r):
    history = []  # store past actions
    for t in range(1, r+1):
        if t == 1:  # first round
            action = 'C'
        else:
            cooperators_this_round = count_cooperators(history, n)
            cooperation_ratio = cooperators_this_round / m
            if cooperation_ratio >= 1:
                action = 'C'  # continue to cooperate
            elif cooperation_ratio < 1:
                action = 'D'  # defect to punish non-cooperation
        history.append(action)  # update past actions for next round
    return history
```
'''

description_EXPLOITATIVE_600 = '''
 Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)

1. Specify decision rules:
   - Initialize cooperation threshold T to m/2 (rounded down). In case of odd n, T=m.
   - At each round t, if the number of cooperators in the previous round (t-1) is greater than or equal to T, cooperate (C). Otherwise, defect (D).
   - After every r/5 rounds, adjust cooperation threshold T based on the current game state as follows:
      1. If the average number of cooperators over the past r/5 rounds is greater than (m+1)/2, increase T by 1.
      2. If the average number of cooperators over the past r/5 rounds is less than (m-1)/2, decrease T by 1. Otherwise, leave T unchanged.
       - Note that T will never fall below m/2 or exceed n if n is even and m+1 otherwise.

2. Handle edge cases:
   - In the first round, T equals m/2 (or m for odd n), and players cooperate if and only if m/2 or more players have also chosen to cooperate.
   - In the last round, follow the same decision rules as in regular rounds. The adjusted cooperation threshold T from the previous strategy will determine whether to cooperate or defect.

3. Be exploitative:
   - The TFTAT strategy maintains a balance between cooperation and defection based on the number of cooperators in previous rounds. It is exploitative in that it responds to opponents' behavior, but it also punishes frequent defection by gradually lowering its own level of cooperation. This encourages other players to cooperate more often, providing a reward for every cooperator above the minimum threshold.
   - The adaptive cooperation threshold ensures that TFTAT remains robust to changes in game parameters and opponent behaviors while still incentivizing cooperation when it benefits the strategy. By adjusting its cooperation level based on the average number of cooperators over time, TFTAT is better equipped to exploit opponent strategies that deviate from cooperative play.

Pseudocode:
```
def TFTAT(n, m, k, r):
    def get_average_coop(history):
        total_cooperators = sum([entry[1] for entry in history])
        return total_cooperators / len(history)

    cooperation_threshold = int((m + 1) / 2 if n % 2 == 0 else m)
    current_round = 0
    strategy_history = []
    payoff = 0

    while current_round < r:
        opponents_cooperation = sum([entry[1] for entry in strategy_history[-r/5:]])
        average_opponents_cooperation = get_average_coop(strategy_history[-r/5:])

        if opponents_cooperation >= cooperation_threshold:
            cooperation_threshold += 1 if current_round % (r/5) == 0 and average_opponents_cooperation > (m + 1)/2 else 0
        else:
            cooperation_threshold -= 1 if current_round % (r/5) == 0 and average_opponents_cooperation < (m - 1)/2 else 0

        action = "C" if opponents_cooperation >= cooperation_threshold else "D"
        strategy_history.append((current_round, action))
        current_round += 1

        if action == "C":
            payoff += (1 - cooperation_threshold) + k * (opponents_cooperation >= m)
        else:
            payoff += 1

    return payoff
```
'''
