"""
Generated LLM strategies for social dilemma games.

This file contains strategy classes generated by LLMs for game theory experiments.
Each strategy is a callable class that implements a specific approach to the game.

Generated with:
- Provider: OpenAI
- Model: gpt-4.1-mini
- Game: CollectiveRiskDescription
"""

from emergent_llm.players.base_player import BaseStrategy
from emergent_llm.games import PublicGoodsDescription, CollectiveRiskDescription
from emergent_llm.common.actions import Action, C, D
from emergent_llm.common.history import PlayerHistory
import numpy as np
from numpy.typing import NDArray
import math
import random



class Strategy_COOPERATIVE_1(BaseStrategy):
    """
    Threshold Cooperation with Last-Round Defection for Collective Risk Dilemma.

    Starts cooperating to signal intent, maintains cooperation when threshold met,
    defects to punish if threshold not met in previous round, and defects last round
    to exploit any cooperative opponents (backward induction).
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number
        if t == self.r - 1:
            return Action.D
        prev_cooperators = 0
        prev_my_action = history.my_actions[t - 1]
        opponent_coop_last = history.opponent_actions[t - 1]
        prev_cooperators = sum(opponent_coop_last) + (1 if prev_my_action else 0)
        coop_rates = history.opponent_actions[:t].mean(axis=0)
        defectors = [i for i, rate in enumerate(coop_rates) if rate < 0.5]
        if prev_cooperators >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_2(BaseStrategy):
    """
    Conditional Cooperate with Forgiveness strategy for the Collective Risk Dilemma.
    
    - First round: cooperate unconditionally.
    - Intermediate rounds: 
      * Identify persistent defectors (≥2 consecutive defect rounds).
      * Count effective cooperators last round excluding persistent defectors.
      * Cooperate if effective cooperators ≥ threshold m.
      * Forgive if effective cooperators == m-1.
      * Otherwise defect.
    - Last round:
      * Cooperate only if effective cooperators ≥ m (to secure last reward).
      * Otherwise defect.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number
        if t == 0:
            return Action.C
        last_round_actions = [None] * self.n
        last_round = t - 1
        last_round_actions[0] = bool(history.my_actions[last_round])
        for opp_idx in range(self.n - 1):
            last_round_actions[opp_idx + 1] = bool(history.opponent_actions[last_round, opp_idx])
        defector_counts = [0] * self.n
        for p in range(self.n):
            max_consec = 0
            consecutive = 0
            for round_idx in range(last_round, -1, -1):
                if p == 0:
                    action = bool(history.my_actions[round_idx])
                else:
                    action = bool(history.opponent_actions[round_idx, p - 1])
                if not action:
                    consecutive += 1
                else:
                    if consecutive > max_consec:
                        max_consec = consecutive
                    consecutive = 0
            if consecutive > max_consec:
                max_consec = consecutive
            defector_counts[p] = max_consec
        persistent_defectors = [p for p, c in enumerate(defector_counts) if c >= 2]
        effective_cooperators = 0
        for p in range(self.n):
            if p in persistent_defectors:
                continue
            if last_round_actions[p]:
                effective_cooperators += 1
        if t < self.r:
            if effective_cooperators >= self.m:
                return Action.C
            elif effective_cooperators == self.m - 1:
                return Action.C
            else:
                return Action.D
        elif effective_cooperators >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_1(BaseStrategy):
    """
    Aggressive Strategy "Opportunistic Exploiter" for Collective Risk Dilemma.

    Summary:
    - Defect first round to maximize immediate payoff without info.
    - In rounds 2 to r-1:
        * Defect if others have already reached threshold m without you.
        * Cooperate only if pivotal (others cooperated exactly m-1 last round)
          to push group past threshold and gain reward k.
        * Otherwise, defect.
    - In final round:
        * Cooperate only if pivotal (others cooperated >= m-1 last round),
          to secure last-round reward.
        * Else defect.
    This exploits cooperating players and protects own endowment unless
    cooperation strictly benefits self.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        if t == 1:
            return Action.D
        rounds_played = history.round_number
        opponent_coops_per_round = history.opponent_actions.sum(axis=1)
        others_meet_threshold = any((coops >= self.m for coops in opponent_coops_per_round))
        last_cooperators = opponent_coops_per_round[-1] if rounds_played > 0 else 0
        if t < self.r:
            if others_meet_threshold:
                return Action.D
            elif last_cooperators == self.m - 1:
                return Action.C
            else:
                return Action.D
        elif last_cooperators >= self.m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_2(BaseStrategy):
    """
    Threshold Exploiter - an aggressive strategy for repeated Collective Risk Dilemma.

    Strategy logic summary:
    - Round 1: defect aggressively.
    - From round 2 to r-1:
      * If threshold was met previous round and player cooperated => switch to defect (exploit).
      * If threshold was met and player defected => keep defecting (free ride).
      * If threshold not met previous round:
        - Defect by default.
        - If threshold failed last two rounds, and previous round cooperators == m-1,
          cooperate minimally to try trigger threshold next round.
    - Round r: always defect to maximize final payoff.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number
        last_round_index = t - 1
        if t == self.r:
            return Action.D
        prev_cooperators = 0
        my_prev_action = history.my_actions[last_round_index - 1]
        prev_opponent_actions = history.opponent_actions[last_round_index - 1]
        prev_cooperators = int(my_prev_action) + prev_opponent_actions.sum()
        if t >= 3:
            prev_prev_opponent_actions = history.opponent_actions[last_round_index - 2]
            prev_prev_my_action = history.my_actions[last_round_index - 2]
            prev_prev_cooperators = int(prev_prev_my_action) + prev_prev_opponent_actions.sum()
        else:
            prev_prev_cooperators = None
        threshold_met_prev = prev_cooperators >= self.m
        if threshold_met_prev:
            if my_prev_action:
                return Action.D
            else:
                return Action.D
        elif t >= 3 and prev_prev_cooperators is not None:
            threshold_failed_twice = prev_cooperators < self.m and prev_prev_cooperators < self.m
            if threshold_failed_twice:
                if prev_cooperators == self.m - 1:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COOPERATIVE_3(BaseStrategy):
    """
    Conditional Threshold Cooperation for the Collective Risk Dilemma.

    - Round 1: always cooperate to seed cooperation.
    - If previous round met or exceeded threshold m:
        repeat own previous action (reward cooperation, no punishment).
    - If previous round missed threshold by one (m - 1):
        cooperate to try to reach threshold.
    - Otherwise defect to avoid exploitation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.m = game_description.m
        self.r = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory):
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number + 1
        prev_round = history.round_number - 1
        num_cooperators = history.my_actions[prev_round].item() + sum(history.opponent_actions[prev_round])
        my_last = history.my_actions[prev_round]
        if num_cooperators >= self.m:
            if my_last:
                return Action.C
            else:
                return Action.D
        elif num_cooperators == self.m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_4(BaseStrategy):
    """
    Conditional Collective Cooperation for the Collective Risk Dilemma.

    This strategy:
    - Cooperates unconditionally in the first round.
    - Continues cooperating if the threshold was met in the previous round.
    - Identifies suspected defectors by counting their defections.
    - Defects if too many players defect consistently making cooperation hopeless.
    - Otherwise cooperates to encourage threshold achievement.
    - In the last round, defects if threshold was missed previously, cooperates otherwise.
    - Forgives occasional defections (up to DefectionTolerance).
    """
    DefectionTolerance = 1
    MaxFailedRoundsToPunish = 3

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number
        last_round_opponent_actions = history.opponent_actions[t - 1] if t - 1 >= 0 else []
        my_last_action = history.my_actions[t - 1]
        last_round_cooperators = last_round_opponent_actions.sum() + (1 if my_last_action else 0)
        consecutive_missed = 0
        for past_round in range(t - 1, -1, -1):
            opp_actions = history.opponent_actions[past_round]
            my_act = history.my_actions[past_round]
            coop_count = opp_actions.sum() + (1 if my_act else 0)
            if coop_count < self.m:
                consecutive_missed += 1
            else:
                break
        round_count = t
        defections_per_opponent = [0] * (self.n - 1)
        for round_idx in range(round_count):
            for opp_idx in range(self.n - 1):
                if not history.opponent_actions[round_idx, opp_idx]:
                    defections_per_opponent[opp_idx] += 1
        suspected_defectors = [idx for idx, dcount in enumerate(defections_per_opponent) if dcount > self.DefectionTolerance]
        defector_threshold = self.n - self.m + 1
        if t == self.r:
            if last_round_cooperators >= self.m:
                return Action.C
            else:
                return Action.D
        if last_round_cooperators >= self.m:
            return Action.C
        if consecutive_missed >= self.MaxFailedRoundsToPunish:
            return Action.D
        if len(suspected_defectors) >= defector_threshold:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_5(BaseStrategy):
    """
    Conditional Threshold Cooperation (CTC) strategy for Collective Risk Dilemma.
    
    - Round 1: Cooperate to signal willingness.
    - Rounds 2 to r-1: Cooperate if threshold m met in previous round, else defect permanently.
    - Last round r: Defect (backward induction).
    - Grim trigger punishment: once threshold missed, defect forever.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.punish = False
        self.last_round_coop_count = None

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punish = False
            self.last_round_coop_count = None
            return Action.C
        t = history.round_number
        current_round = t + 1
        if t > 0:
            last_my_action = history.my_actions[t - 1]
            last_opponent_actions = history.opponent_actions[t - 1]
            coop_count = int(last_my_action) + last_opponent_actions.sum()
            self.last_round_coop_count = coop_count
            if coop_count < self.m:
                self.punish = True
        if current_round == 1:
            return Action.C
        if current_round == self.r:
            return Action.D
        if self.punish:
            return Action.D
        if self.last_round_coop_count is not None and self.last_round_coop_count >= self.m:
            return Action.C
        else:
            self.punish = True
            return Action.D

class Strategy_COOPERATIVE_6(BaseStrategy):
    """
    Conditional Reciprocal Cooperation (CRC) for Collective Risk Dilemma.

    Starts cooperating to signal willingness. Continues cooperating only if
    threshold cooperation (≥ m) was achieved in the previous round. Defects
    temporarily if cooperation fails to signal discontent and press others to
    cooperate. In the final round, cooperates if cooperation was stable last round
    to maximize reward; otherwise defects pragmatically.

    Forgives temporary cooperation drops by tolerating one round below threshold 
    before defecting (implemented implicitly as defect immediately on failure since 
    optional forgiveness is omitted for simplicity).
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number
        prev_round = t - 1
        prev_coop_count = int(history.my_actions[prev_round]) + history.opponent_actions[prev_round].sum()
        if 1 <= t < self.r:
            if prev_coop_count >= self.m:
                return Action.C
            else:
                return Action.D
        if t == self.r:
            if prev_coop_count >= self.m:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_COOPERATIVE_7(BaseStrategy):
    """
    Gradual Threshold Cooperation (GTC) strategy for the Collective Risk Dilemma.

    Starts cooperating to build cooperative baseline.
    In intermediate rounds, cooperates if threshold was met previous round,
    defects to punish otherwise, but forgives after max one punishment round.
    On last round, cooperates only if threshold met every prior round, else defects.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number + 1
        cooperators_history = []
        for round_idx in range(history.round_number):
            coop_count = 0
            if history.my_actions[round_idx]:
                coop_count += 1
            coop_count += sum(history.opponent_actions[round_idx])
            cooperators_history.append(coop_count)

        def threshold_met(round_number_1based):
            if 1 <= round_number_1based <= len(cooperators_history):
                return cooperators_history[round_number_1based - 1] >= self.m
            return True
        last_threshold = threshold_met(t - 1) if t > 1 else True
        consecutive_failures = 0
        for count in reversed(cooperators_history):
            if count < self.m:
                consecutive_failures += 1
            else:
                break
        if t == self.r:
            full_success = all((count >= self.m for count in cooperators_history))
            if full_success:
                return Action.C
            else:
                return Action.D
        if last_threshold:
            return Action.C
        elif consecutive_failures >= 2:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_8(BaseStrategy):
    """
    Cooperative strategy for the Collective Risk Dilemma:
    - Always cooperate first round to signal intent.
    - In intermediate rounds, cooperate if last round's cooperation count
      met or nearly met threshold m, or if cooperation trend is stable/increasing.
    - Defect otherwise to avoid lone cooperation.
    - In last round, cooperate only if previous cooperation was nearly sufficient.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if history.round_number == 0:
            return Action.C
        last_round_my_action = history.my_actions[-1]
        last_round_opponents = history.opponent_actions[-1]
        C_prev = int(last_round_my_action) + int(last_round_opponents.sum())

        def cooperation_trend(history: PlayerHistory, rounds=3):
            counts = []
            max_rounds = min(rounds, history.round_number)
            for i in range(history.round_number - max_rounds, history.round_number):
                my_act = history.my_actions[i]
                opp_acts = history.opponent_actions[i]
                c_count = int(my_act) + int(opp_acts.sum())
                counts.append(c_count)
            if len(counts) < 2:
                return None
            return counts[-1] - counts[0]
        trend = cooperation_trend(history, rounds=3)
        if t == self.r:
            if C_prev >= self.m - 1:
                return Action.C
            else:
                return Action.D
        if C_prev >= self.m:
            return Action.C
        if C_prev == self.m - 1:
            return Action.C
        if trend is not None and trend >= 0 and (C_prev >= self.m - 1):
            return Action.C
        return Action.D

class Strategy_COOPERATIVE_9(BaseStrategy):
    """
    Conditional Cooperative Reciprocity with Forgiveness and Final-Round Defection
    for the Collective Risk Dilemma.

    Summary:
    - Round 1: Cooperate to establish trust.
    - Rounds 2 to r-1:
        * Cooperate if the previous round met or exceeded threshold m cooperators.
        * Otherwise, defect to avoid exploitation.
        * Forgive once: if last round failed threshold but the one before succeeded,
          cooperate this round to attempt to restore cooperation.
    - Last round: Always defect to maximize private payoff.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        if t == 1:
            return Action.C
        if t == self.r:
            return Action.D
        prev_idx = t - 2
        prev_actions = None
        if history is not None and history.round_number >= 1:
            prev_actions = (history.my_actions[prev_idx:prev_idx + 1], history.opponent_actions[prev_idx])
        my_prev_action = history.my_actions[prev_idx] if history is not None else False
        opp_prev_actions = history.opponent_actions[prev_idx] if history is not None else None
        prev_cooperators = 0
        if opp_prev_actions is not None:
            prev_cooperators = opp_prev_actions.sum() + (1 if my_prev_action else 0)
        if prev_cooperators >= self.m:
            return Action.C
        prev_prev_idx = t - 3
        if prev_prev_idx >= 0 and history is not None and (history.round_number >= 2):
            my_prev_prev_action = history.my_actions[prev_prev_idx]
            opp_prev_prev_actions = history.opponent_actions[prev_prev_idx]
            prev_prev_cooperators = opp_prev_prev_actions.sum() + (1 if my_prev_prev_action else 0)
            if prev_prev_cooperators >= self.m:
                return Action.C
        return Action.D

class Strategy_COOPERATIVE_10(BaseStrategy):
    """
    Cooperative strategy for the Collective Risk Dilemma.
    Starts cooperating; if threshold met last round cooperates again.
    If threshold not met, punishes by defecting one round,
    then forgives by cooperating the next round.
    Always cooperates in the final round regardless of history.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.punishment_mode = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            self.punishment_mode = False
            return Action.C
        t = history.round_number + 1
        if t == self.r:
            self.punishment_mode = False
            return Action.C
        last_round_cooperators = int(history.my_actions[-1]) + int(sum(history.opponent_actions[-1]))
        if last_round_cooperators >= self.m:
            self.punishment_mode = False
            return Action.C
        elif not self.punishment_mode:
            self.punishment_mode = True
            return Action.D
        else:
            self.punishment_mode = False
            return Action.C

class Strategy_COOPERATIVE_11(BaseStrategy):
    """
    Conditional Coordinated Cooperation with Forgiveness for Collective Risk Dilemma.

    - Initially cooperates to build trust.
    - Continues cooperating if previous round had at least m cooperators.
    - Temporarily defects as punishment if cooperation threshold not met.
    - Forgives and returns to cooperation when cooperation recovers.
    - In final round, cooperates only if previous cooperation was stable; else defects.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        prev_round_index = t - 2
        if prev_round_index < 0:
            return Action.C
        opp_coop_last = 0
        if self.n > 1:
            opp_coop_last = history.opponent_actions[prev_round_index].sum()
        self_coop_last = 1 if history.my_actions[prev_round_index] else 0
        coop_count_last = opp_coop_last + self_coop_last
        last_action = Action.C if history.my_actions[-1] else Action.D
        if t == self.r:
            if coop_count_last >= self.m:
                return Action.C
            else:
                return Action.D
        if coop_count_last >= self.m:
            return Action.C
        return Action.D

class Strategy_COOPERATIVE_12(BaseStrategy):
    """
    Conditional Cooperative Trigger (CCT) strategy for the Collective Risk Dilemma.
    
    Starts by cooperating, aiming to reach the cooperation threshold m each round to 
    secure the collective reward. If the group fails to meet the threshold in 
    the previous round, enters a defection phase to punish free-riders and incentivize 
    cooperation. Forgives and returns to cooperation if cooperation threshold is restored.
    In final round, cooperates if cooperation was mostly successful; otherwise defects.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game.n_players
        r = self.game.n_rounds
        m = self.game.m
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number
        last_round_cooperators = int(history.my_actions[t - 1]) + int(sum(history.opponent_actions[t - 1]))
        defection_phase = last_round_cooperators < m
        forgive = False
        if defection_phase and t >= 2:
            round_before_last_cooperators = int(history.my_actions[t - 2]) + int(sum(history.opponent_actions[t - 2]))
            if round_before_last_cooperators >= m:
                forgive = True
        if t == r:
            rounds_meeting_threshold = 0
            for round_i in range(t):
                coop_count = int(history.my_actions[round_i]) + int(sum(history.opponent_actions[round_i]))
                if coop_count >= m:
                    rounds_meeting_threshold += 1
            if rounds_meeting_threshold >= r / 2:
                return Action.C
            else:
                return Action.D
        if defection_phase:
            if forgive:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_13(BaseStrategy):
    """
    Conditional Gradual Cooperation with Forgiveness strategy for Collective Risk Dilemma.
    
    - Starts with deterministic initial cooperation by first m players.
    - Maintains a trusted cooperative core based on last w=2 rounds history.
    - Forgives isolated defections to avoid collapse.
    - Joins cooperation if stable core exists even if initially assigned to defect.
    - Defects only in last round to maximize payoff.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self.w = 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        i = 1
        if history is None:
            if i <= self.m:
                return Action.C
            else:
                return Action.D
        t = history.round_number + 1
        my_actions = history.my_actions
        opp_actions = history.opponent_actions
        n = self.n
        rounds_completed = t - 1
        full_actions = []
        for rnd in range(rounds_completed):
            my_act = my_actions[rnd]
            opp_acts_rnd = opp_actions[rnd, :]
            row = [my_act] + list(opp_acts_rnd)
            full_actions.append(row)
        history_list = []
        for rnd_row in full_actions:
            d = {}
            for pidx0, act_bool in enumerate(rnd_row):
                p_id = pidx0 + 1
                d[p_id] = 'C' if act_bool else 'D'
            history_list.append(d)
        w = self.w
        if t == 1:
            if i <= self.m:
                return Action.C
            else:
                return Action.D
        elif t < self.r:
            recent_rounds = history_list[-w:] if len(history_list) >= w else history_list
            cooperation_count = {p: 0 for p in range(1, n + 1)}
            for rnd in recent_rounds:
                for p, a in rnd.items():
                    if a == 'C':
                        cooperation_count[p] += 1
            trusted_cooperators = [p for p, ccount in cooperation_count.items() if ccount >= w - 1]
            last_round = history_list[-1]
            last_round_cooperators = [p for p, a in last_round.items() if a == 'C']
            C_prev = len(last_round_cooperators)
            if i in trusted_cooperators or i in last_round_cooperators:
                return Action.C
            else:
                if C_prev < self.m:
                    my_coop_count = cooperation_count[i]
                    if my_coop_count >= w - 1:
                        return Action.C
                if len(trusted_cooperators) < self.m:
                    return Action.C
                if len(trusted_cooperators) >= self.m:
                    return Action.C
                return Action.D
        else:
            return Action.D

class Strategy_COOPERATIVE_14(BaseStrategy):
    """
    Conditional Cooperation with Threshold Monitoring and Reciprocity

    This strategy aims to maintain cooperation at or above the threshold m to secure the reward k.
    It starts cooperatively, cooperates if last round had >= m cooperators,
    defects otherwise, but after a defection round tries one round of forgiveness (cooperate once),
    and defects on the last round to maximize payoff.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.forgiveness_used_round = None

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game.n_players
        r = self.game.n_rounds
        m = self.game.m
        if history is None:
            self.forgiveness_used_round = None
            return Action.C
        t = history.round_number + 1
        if t == r:
            self.forgiveness_used_round = None
            return Action.D
        last_round_idx = t - 2
        last_round_opp_coop_count = history.opponent_actions[last_round_idx].sum()
        self_last_action = history.my_actions[last_round_idx]
        last_coop = last_round_opp_coop_count + (1 if self_last_action else 0)
        cooperation_failed = last_coop < m
        if cooperation_failed:
            if self.forgiveness_used_round != t - 1:
                self.forgiveness_used_round = t - 1
                return Action.C
            else:
                return Action.D
        else:
            self.forgiveness_used_round = None
            return Action.C

class Strategy_COOPERATIVE_15(BaseStrategy):
    """
    Threshold-Enforcer Cooperative Strategy for Collective Risk Dilemma.
    
    This strategy aims to ensure at least m cooperators per round,
    maximizing collective payoffs by leading cooperation, punishing
    defection once, then forgiving to restore cooperation.
    
    It tracks a trust_level measuring cooperation reliability among others,
    adjusting cooperation decisions accordingly and handling the last round
    with special logic to avoid exploitation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self.initial_trust = max(1, self.m // 2)
        self.max_trust = self.n
        self.threshold_for_cooperation = max(1, self.m // 2)
        self.trust_level = self.initial_trust
        self.last_cooperators = None

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.trust_level = self.initial_trust
            self.last_cooperators = None
            return Action.C
        round_num = history.round_number
        current_round = round_num + 1
        if round_num == 0:
            self.last_cooperators = None
        else:
            last_round_idx = round_num - 1
            opp_cooperators = history.opponent_actions[last_round_idx].sum()
            self_cooperator_last = history.my_actions[last_round_idx]
            self.last_cooperators = opp_cooperators + (1 if self_cooperator_last else 0)
        if self.last_cooperators is not None:
            if self.last_cooperators >= self.m:
                self.trust_level = min(self.trust_level + 1, self.max_trust)
            else:
                self.trust_level = max(self.trust_level - 1, 0)
        if current_round == self.r:
            if self.trust_level >= self.threshold_for_cooperation or (self.last_cooperators is not None and self.last_cooperators >= self.m):
                return Action.C
            else:
                return Action.D
        if self.trust_level >= self.threshold_for_cooperation:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_16(BaseStrategy):
    """
    Conditional reciprocity strategy for Collective Risk Dilemma.
    Tries to ensure at least m cooperators each round to unlock reward k.
    Starts cooperative, maintains cooperation if threshold met,
    defects if exploited, forgives defectors to rebuild cooperation,
    and always cooperates in the last round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number
        current_round = t + 1
        if current_round == self.r:
            return Action.C
        prev_my_action = history.my_actions[-1]
        prev_opponent_actions = history.opponent_actions[-1]
        total_cooperators_last_round = prev_opponent_actions.sum() + (1 if prev_my_action else 0)
        if total_cooperators_last_round >= self.m:
            return Action.C
        if prev_my_action:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_17(BaseStrategy):
    """
    Conditional Cooperative Trigger strategy for the repeated Collective Risk Dilemma.

    Starts cooperating to build trust. Monitors group cooperation each round.
    If threshold m is met, keeps cooperating. If threshold is missed, defects for one round 
    as punishment, then tests cooperation again by cooperating in next round.
    In the last round, cooperates only if threshold was met in previous round, else defects.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self.betrayal_allowed = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.betrayal_allowed = False
            return Action.C
        round_number = history.round_number + 1
        if round_number == 1:
            self.betrayal_allowed = False
            return Action.C
        last_round_idx = round_number - 2
        last_my_action = history.my_actions[last_round_idx]
        last_opponents_actions = history.opponent_actions[last_round_idx]
        last_cooperators = (1 if last_my_action else 0) + last_opponents_actions.sum()
        if self.betrayal_allowed:
            self.betrayal_allowed = False
            return Action.D
        if round_number < self.r:
            if last_cooperators >= self.m:
                return Action.C
            else:
                self.betrayal_allowed = True
                return Action.D
        elif last_cooperators >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_18(BaseStrategy):
    """
    Conditional Coordinated Cooperation (CCC) strategy for Collective Risk Dilemma.

    Starts by cooperating to signal trust. Then continues cooperating if the
    previous round had enough cooperators (≥ m), otherwise defects to punish.
    In the final round, always defects to avoid exploitation without future rounds.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_num = history.round_number
        current_round = round_num + 1
        last_round_idx = round_num - 1
        if last_round_idx < 0:
            return Action.C
        my_last_action_coop = 1 if history.my_actions[last_round_idx] else 0
        opponents_last_coop = sum(history.opponent_actions[last_round_idx])
        cooperatorCountLastRound = my_last_action_coop + opponents_last_coop
        if current_round == 1:
            return Action.C
        elif current_round == self.r:
            return Action.D
        elif cooperatorCountLastRound >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_20(BaseStrategy):
    """
    Contingent Threshold Cooperation strategy for Collective Risk Dilemma.
    Starts cooperating, then conditionally cooperates or defects based on
    whether the cooperation threshold was met in the previous round.
    Forgives defectors if group cooperation succeeds, punishes otherwise.
    Always cooperates in the last round to maximize group reward.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        if history is None:
            return Action.C
        t = history.round_number
        current_round = t + 1
        if current_round == 1:
            return Action.C
        if current_round == r:
            return Action.C
        prev_round_index = t - 1
        my_prev_action = history.my_actions[prev_round_index]
        opp_prev_actions = history.opponent_actions[prev_round_index]
        prev_cooperators = int(my_prev_action) + sum(opp_prev_actions)
        cooperation_success = prev_cooperators >= m
        if cooperation_success:
            return Action.C
        elif my_prev_action:
            return Action.D
        else:
            return Action.D

class Strategy_COOPERATIVE_21(BaseStrategy):
    """
    Conditional cooperation strategy for the Collective Risk Dilemma.

    Summary:
    - Round 1: cooperate unconditionally.
    - Rounds 2 to r-1:
      - If previous round met cooperation threshold m, cooperate with high probability (~0.9),
        else cooperate deterministically (prob=1.0) to restore threshold.
    - Final round r: defect unconditionally to maximize own payoff.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.n = self.game.n_players
        self.r = self.game.n_rounds
        self.m = self.game.m
        self.k = self.game.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number
        prev_round_idx = t - 1
        opponents_coop = sum(history.opponent_actions[prev_round_idx])
        self_coop_last = history.my_actions[prev_round_idx]
        m_prev = opponents_coop + (1 if self_coop_last else 0)
        last_round_idx = self.r - 1
        current_round = t + 1
        if current_round > self.r:
            return Action.D
        if current_round == self.r:
            return Action.D
        if m_prev >= self.m:
            cooperation_prob = 0.9
        else:
            cooperation_prob = 1.0
        if random.random() < cooperation_prob:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_22(BaseStrategy):
    """
    Conditional Cooperative Contributor (CCC) strategy for the Collective Risk Dilemma.

    Starts by cooperating to build trust.
    In intermediate rounds (2 to r-1), cooperates if at least (m-1) others cooperated last round,
    else defects once as punishment, then forgives by cooperating next round if cooperation returns.
    In final round, cooperates only if last round cooperation met threshold; otherwise defects.

    This strategy promotes stable cooperation reaching the collective threshold, punishes defectors
    temporarily, and allows for rejoining cooperation after a punishment.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.defected_last_round = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        m = self.game_description.m
        r = self.game_description.n_rounds
        if history is None:
            self.defected_last_round = False
            return Action.C
        t = history.round_number
        current_round = t + 1
        last_round_idx = t - 1
        coop_others = 0
        if last_round_idx >= 0:
            coop_others = history.opponent_actions[last_round_idx].sum()
        if current_round == 1:
            action = Action.C
        elif 2 <= current_round <= r - 1:
            if self.defected_last_round:
                action = Action.C
                self.defected_last_round = False
            elif coop_others >= m - 1:
                action = Action.C
            else:
                action = Action.D
                self.defected_last_round = True
        elif current_round == r:
            if coop_others >= m - 1:
                action = Action.C
            else:
                action = Action.D
            self.defected_last_round = False
        else:
            action = Action.C
        return action

class Strategy_COOPERATIVE_23(BaseStrategy):
    """
    Reciprocal Cooperate with Threshold and Forgiveness.

    Starts cooperating to foster trust. Continues cooperating if threshold m cooperators was met
    in previous round and self cooperated. Forgives one failure round if threshold missed to
    attempt restoring cooperation, then defects if cooperation breaks down. Defects on last round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.forgiveness_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        if history is None:
            self.forgiveness_counter = 0
            return Action.C
        t = history.round_number
        current_round = t + 1
        if current_round == r:
            return Action.D
        prev_round_idx = t - 1
        if prev_round_idx < 0:
            self.forgiveness_counter = 0
            return Action.C
        prev_my_action = history.my_actions[prev_round_idx]
        prev_opponent_actions = history.opponent_actions[prev_round_idx]
        prev_cooperators = (1 if prev_my_action else 0) + sum((1 if a else 0 for a in prev_opponent_actions))
        if prev_cooperators >= m:
            self.forgiveness_counter = 0
            return Action.C
        elif self.forgiveness_counter < 1:
            self.forgiveness_counter += 1
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_24(BaseStrategy):
    """
    Collective Risk Dilemma Cooperative Strategy.

    This strategy attempts to reach and sustain a stable cooperation threshold m each round,
    punishing defections temporarily and forgiving quickly to restore cooperation.
    It tracks consistent cooperators (≥70% cooperation rate) to identify stable cooperators.
    It uses different behavioral rules on first round, intermediate rounds, and the last round,
    adapting to observed cooperation and defections with the goal of maximizing joint payoffs
    while preventing persistent free-riding.

    Key points:
    - Always cooperate round 1.
    - On intermediate rounds, maintain cooperation if stable cooperation group of size ≥ m exists.
      Otherwise signal defection briefly to avoid exploitation.
    - Punish below threshold cooperation rounds by defecting once, but try to restore cooperation next.
    - On last round, mostly defect to free-ride if cooperation threshold was met,
      else cooperate to push over threshold or else cooperate/defect based on past majority.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number
        if t == 0:
            return Action.C
        last_coop_opponents = history.opponent_actions[t - 1]
        last_coop_self = history.my_actions[t - 1]
        last_cooperators_count = int(last_coop_opponents.sum()) + (1 if last_coop_self else 0)
        last_cooperators_set = set()
        coop_matrix = []
        for round_i in range(t):
            round_coop_row = [False] * self.n
            opp_acts = history.opponent_actions[round_i]
            round_coop_row[0] = history.my_actions[round_i]
            for j in range(self.n - 1):
                round_coop_row[j + 1] = opp_acts[j]
            coop_matrix.append(round_coop_row)
        coop_matrix_np = coop_matrix
        coop_counts = [0] * self.n
        for ply in range(self.n):
            c = 0
            for round_i in range(t):
                if coop_matrix[round_i][ply]:
                    c += 1
            coop_counts[ply] = c
        coop_rates = [c / t for c in coop_counts]
        consistent_cooperators = set((i for i, rate in enumerate(coop_rates) if rate >= 0.7))
        last_round_cooperators = set((i for i in range(self.n) if coop_matrix[t - 1][i]))
        stable_cooperators = consistent_cooperators.intersection(last_round_cooperators)
        stable_cooperators_count = len(stable_cooperators)
        self_i = 0
        self_cooperated_last = coop_matrix[t - 1][self_i]
        if t == self.r:
            if last_cooperators_count >= self.m:
                return Action.D
            elif last_cooperators_count == self.m - 1:
                return Action.C
            else:
                if t > 1:
                    total_coop_counts = 0
                    total_possible = self.n * (t - 1)
                    for round_i in range(t - 1):
                        total_coop_counts += sum(coop_matrix[round_i])
                    majority_cooperated = total_coop_counts / total_possible > 0.5
                else:
                    majority_cooperated = False
                if majority_cooperated:
                    return Action.C
                else:
                    return Action.D
        if self_cooperated_last and last_cooperators_count >= self.m:
            if self_i in stable_cooperators and stable_cooperators_count >= self.m:
                return Action.C
            else:
                return Action.D
        if self_cooperated_last and last_cooperators_count < self.m:
            return Action.D
        if not self_cooperated_last:
            if last_cooperators_count >= self.m:
                last_round_defectors = self.n - last_cooperators_count
                if stable_cooperators_count >= self.m:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.C
        return Action.C

class Strategy_COOPERATIVE_25(BaseStrategy):
    """
    Conditional Threshold Cooperator Strategy for the Collective Risk Dilemma.
    
    Summary:
    - Start by cooperating unconditionally to establish cooperation.
    - On intermediate rounds, cooperate if threshold m was met last round or if 
      others are showing sufficient cooperation on average; otherwise defect to avoid exploitation.
    - On the last round, cooperate only if trust is high (threshold met last round or average cooperation high), else defect.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        prev_round_idx = t - 2
        if prev_round_idx < 0:
            prev_coop_count = 0
        else:
            prev_opp_actions = history.opponent_actions[prev_round_idx]
            prev_opp_coop = prev_opp_actions.sum()
            self_prev_action = history.my_actions[prev_round_idx]
            prev_coop_count = prev_opp_coop + (1 if self_prev_action else 0)
        rounds_observed = t - 1
        if rounds_observed == 0:
            return Action.C
        self_coop_count = history.my_actions[:rounds_observed].sum()
        self_coop_rate = self_coop_count / rounds_observed
        opp_coop_counts = history.opponent_actions[:rounds_observed].sum(axis=0)
        if self.n - 1 > 0:
            others_coop_rate = opp_coop_counts.sum() / (rounds_observed * (self.n - 1))
        else:
            others_coop_rate = 0.0
        threshold_fraction = self.m / self.n
        if t == 1:
            return Action.C
        if t == self.r:
            if prev_coop_count >= self.m or others_coop_rate >= threshold_fraction:
                return Action.C
            else:
                return Action.D
        if prev_coop_count >= self.m:
            return Action.C
        elif others_coop_rate >= threshold_fraction:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_26(BaseStrategy):
    """
    Conditional Threshold Cooperation strategy for the Collective Risk Dilemma.
    
    Starts by cooperating to build trust. In intermediate rounds, cooperates if
    it predicts that at least (m - 1) other players will cooperate (based on last round's
    cooperation), allowing the threshold to be met. Allows a small tolerance by cooperating
    once more if only (m - 2) others cooperated last round. Defects otherwise.
    In the last round, cooperates only if confident threshold will be met, else defects to
    protect own payoff.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        round_number = history.round_number
        current_round = round_number + 1
        last_round_opponent_actions = history.opponent_actions[round_number - 1]
        cooperators_count = last_round_opponent_actions.sum()
        if history.my_actions[round_number - 1]:
            others_cooperators_count = cooperators_count
        else:
            others_cooperators_count = cooperators_count
        if current_round < self.r:
            if others_cooperators_count >= self.m - 1:
                return Action.C
            elif others_cooperators_count == self.m - 2:
                return Action.C
            else:
                return Action.D
        elif others_cooperators_count >= self.m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_27(BaseStrategy):
    """
    Conditional Conditional Cooperate (CCC) with Forgiveness for Collective Risk Dilemma.

    - Cooperate initially.
    - If previous round had at least m cooperators, continue to cooperate.
    - If previous round had fewer than m cooperators, forgive one failure, then defect after.
    - If a majority of opponents defect (less than half cooperated), defect as protective measure.
    - In the last round, cooperate only if cooperation was likely (previous round coop_count >= m), else defect.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self.defection_tolerance = 1
        self.consecutive_failures = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            self.consecutive_failures = 0
            return Action.C
        t = history.round_number
        prev_round_index = t - 1
        coop_self = 1 if history.my_actions[prev_round_index] else 0
        coop_opponents = sum(history.opponent_actions[prev_round_index])
        coop_count_prev = coop_self + coop_opponents
        total_players = self.n
        coop_threshold_for_majority = total_players // 2 + 1
        majority_cooperated = coop_count_prev >= coop_threshold_for_majority
        if t == self.r:
            if coop_count_prev >= self.m and majority_cooperated:
                return Action.C
            else:
                return Action.D
        if coop_count_prev >= self.m and majority_cooperated:
            self.consecutive_failures = 0
            return Action.C
        self.consecutive_failures += 1
        if not majority_cooperated:
            return Action.D
        if self.consecutive_failures > self.defection_tolerance:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_28(BaseStrategy):
    """
    Conditional Cooperative Trigger (CCT) strategy for the Collective Risk Dilemma.

    - Start cooperating to signal willingness.
    - Continue cooperating if threshold m met previous round.
    - If threshold not met, defect once as mild punishment.
    - Forgive if cooperation resumes.
    - Last round: defect if cooperation stable previously, else cooperate.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number + 1
        prev_round_idx = history.round_number - 1
        prev_my_action = history.my_actions[prev_round_idx]
        prev_opp_actions = history.opponent_actions[prev_round_idx]
        prev_coop_count = prev_opp_actions.sum() + prev_my_action
        coop_counts = []
        for rnd in range(history.round_number):
            my_act = history.my_actions[rnd]
            opp_acts = history.opponent_actions[rnd]
            coop_counts.append(opp_acts.sum() + my_act)
        if t < self.r:
            if prev_coop_count >= self.m:
                return Action.C
            elif len(coop_counts) < 2:
                return Action.D
            else:
                prev2_coop_count = coop_counts[-2]
                if prev2_coop_count >= self.m:
                    return Action.D
                else:
                    return Action.D
        elif all((c >= self.m for c in coop_counts)):
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_29(BaseStrategy):
    """
    Conditional Collective Cooperation for Collective Risk Dilemma.

    - Start by cooperating to signal goodwill.
    - Track defections per player since last cooperation.
    - Tolerate up to T=1 defection before punishing.
    - Punish defectors by defecting once, then reset punishment.
    - In rounds (2..r-1), cooperate if cooperation threshold met last round and not punished.
    - If threshold not met, punish defectors and cooperate if not punishing.
    - Defect in last round to maximize payoff without future penalties.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.T = 1
        self.defection_counts = [0] * self.game.n_players
        self.my_index = None

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is not None and self.my_index is None:
            self.my_index = self.game.n_players - 1
        n = self.game.n_players
        r = self.game.n_rounds
        m = self.game.m
        T = self.T
        my_i = self.my_index
        if history is None:
            self.defection_counts = [0] * n
            return Action.C
        round_number = history.round_number + 1
        if round_number == r:
            return Action.D
        last_round_idx = round_number - 2
        my_action_last = bool(history.my_actions[last_round_idx])
        opp_actions_last = history.opponent_actions[last_round_idx]
        last_round_actions = []
        for i in range(n - 1):
            last_round_actions.append(bool(opp_actions_last[i]))
        last_round_actions.append(my_action_last)
        for i in range(n):
            if last_round_actions[i] is False:
                self.defection_counts[i] += 1
            else:
                self.defection_counts[i] = 0
        last_round_cooperators = sum(last_round_actions)
        if last_round_cooperators >= m:
            if self.defection_counts[my_i] <= T:
                return Action.C
            else:
                self.defection_counts[my_i] = 0
                return Action.D
        elif self.defection_counts[my_i] > T:
            self.defection_counts[my_i] = 0
            return Action.D
        else:
            others_defected = False
            for i in range(n):
                if i != my_i and self.defection_counts[i] > T:
                    others_defected = True
                    break
            if others_defected:
                return Action.D
            else:
                return Action.C

class Strategy_COOPERATIVE_30(BaseStrategy):
    """
    Conditional Mutualism strategy for the Collective Risk Dilemma.

    - Round 1: cooperate to signal willingness.
    - Rounds 2 to r-1: fixed assignment of cooperators (players 1 to m cooperate),
      punish defecting assigned cooperators with one round of all defect afterward.
    - Last round: cooperate only if cooperation was stable in previous rounds;
      otherwise defect.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punishment_next_round = False
        self.cooperation_stable = True
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.n
        r = self.r
        m = self.m
        self_i = history.my_actions.shape[0] if history is not None else 0
        if not hasattr(self, 'self_i'):
            self_i = 1
        else:
            self_i = self.self_i
        if history is None:
            self.punishment_next_round = False
            self.cooperation_stable = True
            return Action.C
        t = history.round_number
        current_round = t + 1
        if self.punishment_next_round:
            self.punishment_next_round = False
            return Action.D
        last_round_idx = t - 1
        my_action_last = history.my_actions[last_round_idx]
        opp_actions_last = history.opponent_actions[last_round_idx]
        coop_count_prev = int(my_action_last) + sum(opp_actions_last)
        threshold_met_prev = coop_count_prev >= m
        if not threshold_met_prev:
            self.cooperation_stable = False
        assigned_cooperators_defected = 0
        for p in range(1, m + 1):
            if p == self_i:
                if not my_action_last:
                    assigned_cooperators_defected += 1
            else:
                if p < self_i:
                    opp_idx = p - 1
                else:
                    opp_idx = p - 2
                if not opp_actions_last[opp_idx]:
                    assigned_cooperators_defected += 1
        if assigned_cooperators_defected > 0:
            self.punishment_next_round = True
            return Action.D
        if current_round == r:
            if self.cooperation_stable:
                if self_i <= m:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
        elif self_i <= m:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_31(BaseStrategy):
    """
    Gradual Trustbuilding with Threshold Enforcement (GTTE) for the Collective Risk Dilemma.
    - Round 1: Cooperate unconditionally.
    - Rounds 2..r-1: Cooperate if prior round met threshold (m or more cooperators);
      else defect once as punishment, then return to cooperation.
    - Last round r: Cooperate only if prior round met threshold, else defect.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self._last_action = None

    def __call__(self, history: None | PlayerHistory) -> Action:
        m = self.game_description.m
        r = self.game_description.n_rounds
        if history is None:
            self._last_action = 'Cooperate'
            return Action.C
        t = history.round_number
        current_round = t + 1
        if t == 0:
            C_prev = 0
        else:
            prev_coop_count = 0
            my_prev_action = history.my_actions[t - 1]
            opp_prev_actions = history.opponent_actions[t - 1]
            C_prev = int(my_prev_action) + int(opp_prev_actions.sum())
        if current_round == 1:
            self._last_action = 'Cooperate'
            return Action.C
        if current_round == r:
            if C_prev >= m:
                self._last_action = 'Cooperate'
                return Action.C
            else:
                self._last_action = 'Defect'
                return Action.D
        if C_prev >= m:
            self._last_action = 'Cooperate'
            return Action.C
        if self._last_action != 'Punish_D':
            self._last_action = 'Punish_D'
            return Action.D
        else:
            self._last_action = 'Cooperate'
            return Action.C

class Strategy_COOPERATIVE_32(BaseStrategy):
    """
    Adaptive Conditional Cooperation (ACC) strategy for the Collective Risk Dilemma.

    Summary:
    - Always cooperate on round 1.
    - Track cooperation rates of all players (including self).
    - On rounds 2 to r-1, cooperate if predicted cooperation excluding self is >= m-1,
      or if previous round had fewer than m cooperators (try to repair).
    - On last round r, cooperate if predicted cooperation excluding self is >= m-1,
      else defect.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.theta = 0.6

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        i = n
        t = 1 if history is None else history.round_number + 1
        if t == 1:
            return Action.C
        full_history = np.empty((t - 1, n), dtype=bool)
        full_history[:, :n - 1] = history.opponent_actions
        full_history[:, n - 1] = history.my_actions
        coop_counts = full_history.sum(axis=0)
        coop_rates = coop_counts / (t - 1)
        prev_round_idx = t - 2
        prev_round_actions = full_history[prev_round_idx, :]
        S = prev_round_actions.sum()
        S_coop_mask = coop_rates >= self.theta
        self_is_coop = S_coop_mask[n - 1]
        expected_coop = S_coop_mask.sum()
        if not self_is_coop:
            expected_coop -= 1
        else:
            expected_coop -= 1
        if S < m:
            return Action.C
        if expected_coop >= m - 1:
            return Action.C
        return Action.D

class Strategy_COOPERATIVE_33(BaseStrategy):
    """
    Threshold-Triggered Conditional Cooperation for Collective Risk Dilemma.
    
    - Cooperate first round.
    - For rounds 2 to (r-1):
        * Cooperate if threshold m met last round.
        * Defect if threshold not met last round to punish.
        * Forgive once: if punished last round but threshold was met in prior round, cooperate again.
    - Defect last round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game.n_players
        r = self.game.n_rounds
        m = self.game.m
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number
        current_round = t + 1
        if current_round == r:
            return Action.D
        coop_last_round = 0
        coop_last_round += history.opponent_actions[t - 1].sum()
        coop_last_round += 1 if history.my_actions[t - 1] else 0
        if coop_last_round >= m:
            return Action.C
        if current_round > 2:
            coop_prev_prev = 0
            coop_prev_prev += history.opponent_actions[t - 2].sum()
            coop_prev_prev += 1 if history.my_actions[t - 2] else 0
            if coop_prev_prev >= m:
                return Action.C
        return Action.D

class Strategy_COOPERATIVE_34(BaseStrategy):
    """
    Conditional Coordinated Cooperation for Collective Risk Dilemma.

    Starts by cooperating to signal intent.
    If last round's cooperation count >= m, continue cooperating.
    Otherwise, defect to punish defection.
    In the last round, cooperate only if cooperation threshold met last round,
    else defect to maximize private payoff.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number + 1
        last_round_idx = history.round_number - 1
        my_last_action = history.my_actions[last_round_idx]
        opp_last_actions = history.opponent_actions[last_round_idx]
        C_prev = int(my_last_action) + int(opp_last_actions.sum())
        if 1 < t < self.r:
            if C_prev >= self.m:
                return Action.C
            else:
                return Action.D
        elif t == self.r:
            if C_prev >= self.m:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_35(BaseStrategy):
    """
    Conditioned Reward Reciprocity (CRR) strategy for the Collective Risk Dilemma.
    
    Summary:
    - Round 1: Cooperate to signal intent.
    - Rounds 2 to r-1: Cooperate if last round met cooperation threshold (≥ m cooperators)
      and others' cooperation rate last round ≥ min_coop_rate; else defect.
    - Last round: Cooperate only if total past cooperation frequency ≥ min_coop_rate; else defect.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self.min_coop_rate = self.m / self.n + 0.05

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number
        n = self.n
        r = self.r
        m = self.m
        min_coop_rate = self.min_coop_rate
        my_idx = None
        next_round = t + 1
        if next_round == 1:
            return Action.C
        last_round_idx = t - 1
        if 2 <= next_round < r:
            own_last = history.my_actions[last_round_idx]
            opponents_last = history.opponent_actions[last_round_idx]
            total_cooperators_last = own_last + sum(opponents_last)
            coop_others = sum(opponents_last)
            coop_rate_others = coop_others / (n - 1)
            if total_cooperators_last >= m and coop_rate_others >= min_coop_rate:
                return Action.C
            else:
                return Action.D
        if next_round == r:
            total_cooperations = sum(history.my_actions[:t]) + history.opponent_actions[:t, :].sum()
            total_actions = n * t
            overall_coop_rate = total_cooperations / total_actions if total_actions > 0 else 0.0
            if overall_coop_rate >= min_coop_rate:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_COOPERATIVE_36(BaseStrategy):
    """
    Cooperative Strategy for Collective Risk Dilemma.

    Implements Conditional Reciprocity with Gradual Forgiveness:
    - Cooperates first round to signal willingness.
    - If threshold (m) or more cooperators last round: cooperate again.
    - If threshold not met last round: punish once by defecting.
    - After punishing once, forgive and resume cooperation.
    - Always defect in the last round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.punishment_flag = False
        self.last_round_cooperators_count = self.game.n_players

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punishment_flag = False
            self.last_round_cooperators_count = self.game.n_players
            return Action.C
        t = history.round_number + 1
        n = self.game.n_players
        r = self.game.n_rounds
        m = self.game.m
        if history.round_number > 0:
            previous_round_cooperators = int(history.my_actions[-1]) + int(sum(history.opponent_actions[-1]))
        else:
            previous_round_cooperators = n
        self.last_round_cooperators_count = previous_round_cooperators
        if t == 1:
            self.punishment_flag = False
            return Action.C
        if t == r:
            self.punishment_flag = False
            return Action.D
        if self.punishment_flag:
            self.punishment_flag = False
            return Action.D
        if self.last_round_cooperators_count >= m:
            return Action.C
        else:
            self.punishment_flag = True
            return Action.D

class Strategy_COOPERATIVE_37(BaseStrategy):
    """
    Cooperative Strategy: Conditional Trigger with Forgiveness for the Collective Risk Dilemma.

    Starts cooperating to build trust, continues cooperating if at least m players cooperated last round.
    If cooperation threshold fails, defects for a limited punishment period to signal cost of defection,
    then forgives by cooperating again. In the last round defects if cooperation threshold not met to
    maximize immediate gain.
    """
    PUNISH_ROUNDS = 1

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.defection_punishment_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        if history is None or history.round_number == 0:
            self.defection_punishment_counter = 0
            return Action.C
        t = history.round_number + 1
        prev_round_idx = t - 2
        prev_opponent_actions = history.opponent_actions[prev_round_idx]
        prev_my_action = history.my_actions[prev_round_idx]
        total_cooperators_prev = prev_opponent_actions.sum() + (1 if prev_my_action else 0)
        if t == r:
            if total_cooperators_prev >= m:
                return Action.C
            else:
                return Action.D
        if total_cooperators_prev >= m:
            self.defection_punishment_counter = 0
            return Action.C
        if self.defection_punishment_counter < self.PUNISH_ROUNDS:
            self.defection_punishment_counter += 1
            return Action.D
        else:
            self.defection_punishment_counter = 0
            return Action.C

class Strategy_COOPERATIVE_38(BaseStrategy):
    """
    Conditional Reciprocity with Threshold Vigilance for the Collective Risk Dilemma.

    Cooperate initially and maintain cooperation if threshold m is met by the group.
    Punish by defecting one round if cooperation drops below m, then forgive.
    In the last round, cooperate only if cooperation was stable and no punishment was ever needed.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.punishment_last_round = False
        self.ever_punished = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game.n_players
        r = self.game.n_rounds
        m = self.game.m
        if history is None:
            self.punishment_last_round = False
            self.ever_punished = False
            return Action.C
        round_num = history.round_number
        current_round = round_num + 1
        if round_num == 0:
            return Action.C
        prev_round_idx = round_num - 1
        my_prev_action = history.my_actions[prev_round_idx]
        opponents_prev_actions = history.opponent_actions[prev_round_idx]
        count_C_prev = int(my_prev_action) + sum(opponents_prev_actions)
        if current_round == r:
            if count_C_prev >= m and (not self.ever_punished):
                return Action.C
            else:
                return Action.D
        if self.punishment_last_round:
            self.punishment_last_round = False
            return Action.C
        elif count_C_prev >= m:
            return Action.C
        else:
            self.punishment_last_round = True
            self.ever_punished = True
            return Action.D

class Strategy_COOPERATIVE_39(BaseStrategy):
    """
    Conditional Trust with Forgiveness strategy for the Collective Risk Dilemma.

    - Start cooperating.
    - Cooperate if previous round had at least m cooperators.
    - If threshold not met and did not defect last round, defect to punish.
    - If threshold not met and already defected last round, forgive by cooperating.
    - Always cooperate on the last round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        m = self.game_description.m
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number + 1
        if t == r:
            return Action.C
        prev_round = t - 2
        opp_coops = 0 if history.opponent_actions.size == 0 else history.opponent_actions[prev_round].sum()
        my_last_action = history.my_actions[prev_round]
        total_coops = opp_coops + (1 if my_last_action else 0)
        if total_coops >= m:
            return Action.C
        elif not my_last_action:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_40(BaseStrategy):
    """
    Cooperative strategy for the Collective Risk Dilemma.
    Attempts to reach cooperation threshold m each round by:
    - Always cooperating round 1 to build trust
    - Rewarding cooperators and punishing defectors if previous round met threshold
    - Optimistically cooperating (or defecting if very few cooperators) if previous round failed threshold
    - Defecting in last round unless strong cooperative environment exists
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        if history is None or history.round_number == 0:
            return Action.C
        round_idx = history.round_number
        current_round = round_idx + 1
        prev_actions_opponents = history.opponent_actions[round_idx - 1]
        prev_action_self = history.my_actions[round_idx - 1]
        cooperators_prev = prev_actions_opponents.sum() + (1 if prev_action_self else 0)
        if current_round == r:
            if cooperators_prev >= m and prev_action_self:
                return Action.C
            else:
                return Action.D
        if cooperators_prev >= m:
            if prev_action_self:
                return Action.C
            else:
                return Action.D
        elif cooperators_prev <= 1:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_41(BaseStrategy):
    """
    Threshold-Triggered Conditional Cooperation (TTCC) strategy for the Collective Risk Dilemma.

    - Cooperate on the first round to signal goodwill.
    - On rounds 2 to r-1:
      * If previous round cooperation count ≥ m, cooperate.
      * Else defect to punish, remain defecting until cooperation threshold met again.
    - On last round (r), cooperate unconditionally to maximize joint payoff.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game.n_players
        m = self.game.m
        r = self.game.n_rounds
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number
        current_round = t + 1
        if current_round == r:
            return Action.C
        last_round_idx = t - 1
        last_round_cooperators = history.my_actions[last_round_idx].item() + sum(history.opponent_actions[last_round_idx, :])
        if last_round_cooperators >= m:
            return Action.C
        return Action.D

class Strategy_COOPERATIVE_42(BaseStrategy):
    """
    Gradual Threshold Cooperation (GTC) strategy for the Collective Risk Dilemma.
    
    - Start by cooperating to signal trust.
    - In middle rounds, cooperate if the number of cooperators in the previous round meets or exceeds threshold m.
      Otherwise defect to punish.
    - After one round of defection, try to reconcile by cooperating if cooperation was good before punishment.
    - In the last round, cooperate unless cooperation has completely collapsed (all previous rounds zero cooperators),
      then defect to avoid loss.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game.n_players
        r = self.game.n_rounds
        m = self.game.m
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number
        current_round = t + 1

        def num_cooperators_at(round_idx: int) -> int:
            my_c = 1 if history.my_actions[round_idx] else 0
            opp_c = sum(history.opponent_actions[round_idx])
            return my_c + opp_c
        prev_num_coop = num_cooperators_at(t - 1) if t - 1 >= 0 else None
        if current_round == r:
            all_defect = True
            for i in range(t):
                if num_cooperators_at(i) > 0:
                    all_defect = False
                    break
            if all_defect:
                return Action.D
            else:
                return Action.C
        if prev_num_coop is not None and prev_num_coop >= m:
            return Action.C
        else:
            if t >= 2:
                prev_prev_num_coop = num_cooperators_at(t - 2)
                last_action = history.my_actions[t - 1]
                if not last_action and prev_prev_num_coop is not None and (prev_prev_num_coop >= m):
                    return Action.C
            return Action.D

class Strategy_COOPERATIVE_43(BaseStrategy):
    """
    Conditional Threshold Cooperation strategy for the Collective Risk Dilemma.

    - Round 1: Cooperate to signal willingness.
    - Rounds 2..r-1: Cooperate if average cooperators in prior rounds ≥ m, else defect.
    - Round r (last): Cooperate if average cooperators in prior rounds ≥ m, else defect.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number + 1
        coop_counts = []
        for round_idx in range(history.round_number):
            opp_coop = history.opponent_actions[round_idx].sum()
            self_coop = 1 if history.my_actions[round_idx] else 0
            coop_counts.append(opp_coop + self_coop)
        avg_coop = sum(coop_counts) / len(coop_counts) if coop_counts else 0.0
        if avg_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_44(BaseStrategy):
    """
    Conditional Threshold Reciprocity for the Collective Risk Dilemma.
    Starts cooperating to build trust, tracks rounds meeting cooperation threshold,
    punishes defectors briefly after failures, forgives upon cooperation restoration,
    and behaves cautiously near game end to avoid exploitation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.T = 2
        self.P = 1
        r = self.game_description.n_rounds
        div, mod = divmod(r, 5)
        self.L = max(2, div + (1 if mod > 0 else 0))
        self.thresholdMetRounds = 0
        self.punishRoundsLeft = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        m = self.game_description.m
        r = self.game_description.n_rounds
        if history is None:
            self.thresholdMetRounds = 0
            self.punishRoundsLeft = 0
            return Action.C
        t = history.round_number
        if t == 0:
            self.thresholdMetRounds = 0
            self.punishRoundsLeft = 0
            return Action.C
        last_round_my_c = history.my_actions[t - 1]
        last_round_opponent_c = history.opponent_actions[t - 1]
        n_cooperators = int(last_round_my_c) + int(sum(last_round_opponent_c))
        if n_cooperators >= m:
            self.thresholdMetRounds += 1
            self.punishRoundsLeft = 0
        else:
            self.thresholdMetRounds = 0
            self.punishRoundsLeft = self.P
        if self.punishRoundsLeft > 0:
            self.punishRoundsLeft -= 1
            return Action.D
        if t >= r - self.L + 1:
            if self.thresholdMetRounds == 0:
                return Action.D
            else:
                return Action.C
        if self.thresholdMetRounds >= self.T:
            return Action.C
        return Action.C

class Strategy_COOPERATIVE_45(BaseStrategy):
    """
    Conditional cooperation with forgiveness strategy for the Collective Risk Dilemma.
    
    Attempts to cooperatively meet threshold m to secure reward k.
    Cooperates first round to signal cooperation.
    If threshold met last round, continues cooperating.
    If threshold missed and player cooperated last round, defects once to punish defectors.
    Then forgives by returning to cooperation.
    Last round cooperates only if threshold likely still reachable.
    
    Maintains internal state to track if in punishment phase or cooperative phase.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.n = self.game.n_players
        self.r = self.game.n_rounds
        self.m = self.game.m
        self._in_punishment = False
        self._consec_threshold_fail = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self._in_punishment = False
            self._consec_threshold_fail = 0
            return Action.C
        t = history.round_number
        last_round_idx = t - 1
        last_round_opp_actions = history.opponent_actions[last_round_idx]
        last_round_cooperators_count = last_round_opp_actions.sum()
        last_round_defectors_count = self.n - 1 - last_round_cooperators_count
        my_last_action = history.my_actions[last_round_idx]
        total_cooperators_last = int(last_round_cooperators_count) + (1 if my_last_action else 0)
        threshold_met_last = total_cooperators_last >= self.m
        if t == self.r:
            estimated_cooperators_others = last_round_cooperators_count
            if estimated_cooperators_others >= self.m - 1:
                return Action.C
            else:
                return Action.D
        elif threshold_met_last:
            self._in_punishment = False
            self._consec_threshold_fail = 0
            return Action.C
        else:
            self._consec_threshold_fail += 1
            if self._in_punishment:
                self._in_punishment = False
                return Action.C
            else:
                self._in_punishment = True
                if my_last_action:
                    return Action.D
                else:
                    self._in_punishment = False
                    return Action.C

class Strategy_COOPERATIVE_46(BaseStrategy):
    """
    Gradual Conditional Cooperation with Last-round Adjustment (GCC-LRA)

    - Start cooperating in round 1 to signal cooperative intent.
    - For intermediate rounds (2 to r-1):
        * If previous round met cooperation threshold m, cooperate and reset defect signal.
        * If previous round failed threshold and defect_signal is False, defect once as a signal.
        * Otherwise, cooperate to try to restore cooperation.
    - In last round (r), defect to maximize payoff.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.defect_signal = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        if history is None:
            self.defect_signal = False
            return Action.C
        t = history.round_number
        next_round = t + 1
        if next_round == r:
            return Action.D
        prev_coops = 0
        if history.my_actions[t - 1]:
            prev_coops += 1
        prev_coops += sum(history.opponent_actions[t - 1])
        if prev_coops >= m:
            self.defect_signal = False
            return Action.C
        elif not self.defect_signal:
            self.defect_signal = True
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_47(BaseStrategy):
    """
    Cooperative Strategy for the Collective Risk Dilemma:
    - Round 1: Cooperate to establish trust.
    - Subsequent rounds: Cooperate if the previous round had at least (m - 1) cooperators among others,
      indicating threshold met or nearly met, else punish by defecting one round.
    - Punishment lasts only one round, then revert to cooperation to allow recovery.
    - Last round: Cooperate if threshold met in the previous round; else defect since no future rounds to incentivize cooperation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self._punished_last_round = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        self_index = 0
        if history is None or history.round_number == 0:
            self._punished_last_round = False
            return Action.C
        current_round = history.round_number
        prev_round = current_round - 1
        my_last_action = history.my_actions[prev_round]
        opp_last_actions = history.opponent_actions[prev_round]
        coop_count_last = int(my_last_action) + int(opp_last_actions.sum())
        threshold_met_last = coop_count_last >= m
        other_coop_last = int(opp_last_actions.sum())
        if current_round == r:
            self._punished_last_round = False
            if threshold_met_last:
                return Action.C
            else:
                return Action.D
        if threshold_met_last:
            self._punished_last_round = False
            return Action.C
        if self._punished_last_round:
            self._punished_last_round = False
            return Action.C
        self._punished_last_round = True
        return Action.D

class Strategy_COOPERATIVE_48(BaseStrategy):
    """
    Cooperative strategy for the Collective Risk Dilemma.

    Starts by cooperating to build trust.
    Monitors cooperation levels each round.
    If defection detected (cooperators < m last round), punish by defecting exactly one round.
    Forgives after punishment and returns to cooperation.
    Cooperates in the final round if no ongoing punishment to maximize reward.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.m = game_description.m
        self.r = game_description.n_rounds
        self.punishment_counter = 0
        self.defection_detected = False
        self.threshold_ever_met = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punishment_counter = 0
            self.defection_detected = False
            self.threshold_ever_met = False
            return Action.C
        t = history.round_number
        coop_last_round = int(history.my_actions[t - 1]) + int(sum(history.opponent_actions[t - 1]))
        if coop_last_round >= self.m:
            self.threshold_ever_met = True
        self.defection_detected = coop_last_round < self.m
        current_round = t + 1
        final_round = self.r
        if self.punishment_counter > 0:
            action = Action.D
            self.punishment_counter -= 1
            return action
        if self.defection_detected:
            self.punishment_counter = 1
            return Action.D
        if current_round == final_round:
            return Action.C
        return Action.C

class Strategy_COOPERATIVE_49(BaseStrategy):
    """
    Conditional Reciprocity with Trust Calibration for Collective Risk Dilemma.

    Starts cooperating to build trust.
    Uses a sliding window average of past cooperation counts to decide cooperation in middle rounds.
    More tolerant in penultimate round (threshold lowered by 1).
    Always cooperates in first and last rounds.
    Detects persistent defectors to avoid exploitation by defecting in middle rounds.
    Attempts forgiveness if personal payoff was low last round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.g = game_description
        self.w = 2
        self.threshold = self.g.m
        self.coop_history = []

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        round_num = history.round_number + 1
        n = self.g.n_players
        r = self.g.n_rounds
        m = self.g.m
        w = self.w
        threshold = self.threshold
        last_round_idx = history.round_number - 1
        my_last_action = history.my_actions[last_round_idx]
        opponents_last_actions = history.opponent_actions[last_round_idx]
        coop_count_last = int(my_last_action) + opponents_last_actions.sum()
        if len(self.coop_history) < history.round_number:
            self.coop_history.append(coop_count_last)

        def avg_coop(coop_hist):
            if not coop_hist:
                return 0
            window_slice = coop_hist[-w:]
            return sum(window_slice) / len(window_slice)

        def detect_persistent_defectors(coop_hist):
            if len(coop_hist) < w:
                return False
            recent = coop_hist[-w:]
            limit = threshold - 1
            return all((c < limit for c in recent))
        personal_payoff_last = None
        if len(history.my_payoffs) > 0:
            personal_payoff_last = history.my_payoffs[-1]
        if round_num == r:
            return Action.C
        elif round_num == r - 1:
            avg = avg_coop(self.coop_history)
            if avg >= threshold - 1:
                return Action.C
            else:
                return Action.D
        else:
            avg = avg_coop(self.coop_history)
            persistent_defectors = detect_persistent_defectors(self.coop_history)
            forgiving = False
            if personal_payoff_last is not None and personal_payoff_last < 1.5:
                forgiving = True
            if forgiving:
                if avg >= threshold - 0.5:
                    return Action.C
                else:
                    return Action.D
            elif avg >= threshold:
                return Action.C
            elif persistent_defectors:
                return Action.D
            else:
                return Action.D

class Strategy_COOPERATIVE_50(BaseStrategy):
    """
    Conditional Gradual Cooperation strategy for the Collective Risk Dilemma.

    - Round 1: Cooperate to signal goodwill.
    - Rounds 2 to r-1:
        * If previous round had ≥ m cooperators:
            - If previously cooperated, keep cooperating.
            - If previously defected, return to cooperation.
            - Punishment mode off.
        * If previous round had < m cooperators:
            - If previously cooperated, punish by defecting and turn punishment mode on.
            - If previously defected, continue defecting (punishment mode on).
    - Last round (round r):
        * Defect regardless, to maximize payoff (no future rounds).
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.n = self.game.n_players
        self.r = self.game.n_rounds
        self.m = self.game.m
        self.punishing = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            self.punishing = False
            return Action.C
        t = history.round_number
        last_round_idx = t - 1
        my_last = history.my_actions[last_round_idx]
        opp_last_round = history.opponent_actions[last_round_idx]
        coop_count = int(my_last) + int(opp_last_round.sum())
        curr_round = t + 1
        if curr_round == self.r:
            self.punishing = False
            return Action.D
        if coop_count >= self.m:
            self.punishing = False
            if my_last:
                return Action.C
            else:
                return Action.C
        elif my_last:
            self.punishing = True
            return Action.D
        else:
            self.punishing = True
            return Action.D

class Strategy_COOPERATIVE_51(BaseStrategy):
    """
    Cooperative Strategy for Collective Risk Dilemma
    
    This strategy aims to establish and maintain cooperation by:
    - Cooperating in round 1 to signal intent.
    - In intermediate rounds (2 to r-1), cooperating if the threshold was met last round,
      otherwise defecting once as punishment then forgiving immediately.
    - In the final round, cooperating if cooperation was reached at any prior time, else defecting.
    
    It uses perfect recall of past rounds and own past actions to implement a single-round
    punishment–forgiveness cycle and sustain cooperation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n = self.n
        r = self.r
        m = self.m

        def count_cooperators(actions_row: '1D bool array'):
            return sum(actions_row)
        full_actions_all_rounds = []
        for round_idx in range(history.round_number):
            actions_round = [history.my_actions[round_idx]]
            for opp_idx in range(n - 1):
                actions_round.append(history.opponent_actions[round_idx, opp_idx])
            full_actions_all_rounds.append(actions_round)
        threshold_ever_met = False
        for round_actions in full_actions_all_rounds:
            if count_cooperators(round_actions) >= m:
                threshold_ever_met = True
                break
        if current_round == 1:
            return Action.C
        prev_round_actions = full_actions_all_rounds[-1]
        prev_cooperators = count_cooperators(prev_round_actions)
        threshold_met_prev = prev_cooperators >= m
        if current_round == r:
            if threshold_ever_met:
                return Action.C
            else:
                return Action.D
        if threshold_met_prev:
            return Action.C
        my_last_action = history.my_actions[-1]
        if my_last_action == False:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_52(BaseStrategy):
    """
    Conditional Reciprocity with Forgiving Coordination for Collective Risk Dilemma.
    Starts by cooperating, continues cooperation if cooperation threshold met.
    Forgives near-threshold lapses up to forgiveness_limit consecutive failures.
    Defects after persistent failure or on last round if cooperation history poor.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.trust_counter = 0
        self.forgiveness_limit = 2
        self.consecutive_failures = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        if history is None:
            self.trust_counter = 0
            self.consecutive_failures = 0
            return Action.C
        t = history.round_number + 1
        last_round_index = t - 2
        last_cooperators = 0
        if last_round_index >= 0:
            my_action_last = history.my_actions[last_round_index]
            opponents_last = history.opponent_actions[last_round_index]
            total_coops = int(my_action_last) + int(opponents_last.sum())
            last_cooperators = total_coops
        threshold_met_last_round = last_cooperators >= m
        if last_round_index >= 0:
            my_action_last = history.my_actions[last_round_index]
        else:
            my_action_last = True
        if t == 1:
            self.trust_counter = 0
            self.consecutive_failures = 0
            return Action.C
        elif 1 < t < r:
            if threshold_met_last_round:
                self.consecutive_failures = 0
                self.trust_counter += 1
                return Action.C
            else:
                self.consecutive_failures += 1
                near_threshold = last_cooperators >= m - 1
                if near_threshold and self.consecutive_failures <= self.forgiveness_limit:
                    return Action.C
                else:
                    return Action.D
        else:
            if self.trust_counter == 0:
                return Action.D
            if threshold_met_last_round:
                return Action.C
            elif self.consecutive_failures <= self.forgiveness_limit and last_cooperators >= m - 1:
                return Action.C
            else:
                return Action.D

class Strategy_COOPERATIVE_53(BaseStrategy):
    """
    Cooperative strategy for the Collective Risk Dilemma
    - Starts by cooperating to build trust.
    - Maintains cooperation when threshold (m) is met last round.
    - Punishes by defecting if threshold missed last round.
    - On last round defects to maximize individual payoff.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n = self.game.n_players
        r = self.game.n_rounds
        m = self.game.m
        last_round_idx = history.round_number - 1
        opponents_cooperated = history.opponent_actions[last_round_idx].sum()
        self_cooperated = history.my_actions[last_round_idx]
        cooperators_count = opponents_cooperated + (1 if self_cooperated else 0)
        if current_round == r:
            return Action.D
        if cooperators_count >= m:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_54(BaseStrategy):
    """
    Conditional Threshold Cooperation (CTC) Strategy for the Collective Risk Dilemma.
    
    Summary:
    - Cooperates unconditionally in the first round to signal willingness.
    - From round 2 to round r-1, cooperates if threshold m was met last round, else defects.
    - In the last round, cooperates if threshold met or just one short; defects otherwise.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        if history is None:
            return Action.C
        t = history.round_number + 1
        if history.round_number == 0:
            return Action.C
        last_round_index = history.round_number - 1
        opponent_cooperators = sum(history.opponent_actions[last_round_index])
        self_cooperated = history.my_actions[last_round_index]
        numC = opponent_cooperators + (1 if self_cooperated else 0)
        if t == 1:
            return Action.C
        if t == r:
            if numC >= m:
                return Action.C
            elif numC == m - 1:
                return Action.C
            else:
                return Action.D
        elif numC >= m:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_55(BaseStrategy):
    """
    Conditional cooperative strategy for the Collective Risk Dilemma.

    - Round 1: Cooperate to build trust.
    - From round 2 to (r-1):
        * If previous round had at least m cooperators, cooperate again.
        * Otherwise, defect once to punish and test.
    - Recovery:
        * If cooperation threshold was missed previously, remain defecting
          until threshold met again.
    - Last round (round r):
        * Defect if previous round met cooperation threshold (no future retaliation).
        * Otherwise cooperate to attempt last-round reward.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_number = history.round_number
        current_round = round_number + 1
        if round_number == 0:
            return Action.C
        else:
            prev_opponent_coop = history.opponent_actions[round_number - 1]
            prev_my_action = history.my_actions[round_number - 1]
            prev_cooperators = prev_opponent_coop.sum() + (1 if prev_my_action else 0)
        if current_round < self.r:
            if prev_cooperators >= self.m:
                return Action.C
            else:
                return Action.D
        elif prev_cooperators >= self.m:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_56(BaseStrategy):
    """
    Gradual Trust Builder for the Collective Risk Dilemma.
    
    Initiates cooperation, punishes defectors by defecting if threshold cooperation
    not met, forgives after a delay by attempting cooperation again,
    and defects in the last round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.forgiveness_delay = 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game.n_players
        r = self.game.n_rounds
        m = self.game.m
        t = 1 if history is None else history.round_number + 1
        if t == 1:
            return Action.C
        prev_round_idx = t - 2
        all_prev_actions = [history.my_actions[prev_round_idx]]
        if n > 1:
            all_prev_actions.extend(history.opponent_actions[prev_round_idx])
        prev_cooperators = sum(all_prev_actions)
        threshold_met = prev_cooperators >= m
        own_prev_action = history.my_actions[prev_round_idx]
        failed_rounds = 0
        start_check = max(0, prev_round_idx - self.forgiveness_delay + 1)
        for past_r in range(prev_round_idx, start_check - 1, -1):
            all_past_actions = [history.my_actions[past_r]]
            if n > 1:
                all_past_actions.extend(history.opponent_actions[past_r])
            if sum(all_past_actions) < m:
                failed_rounds += 1
        punished_phase = failed_rounds >= self.forgiveness_delay
        if t == r:
            return Action.D
        if threshold_met:
            return Action.C
        elif own_prev_action:
            return Action.D
        elif punished_phase:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_57(BaseStrategy):
    """
    Conditional Reciprocity with Forgiveness for the Collective Risk Dilemma.
    
    - Start cooperating in round 1.
    - If in the previous round at least m players cooperated, cooperate again.
    - If cooperation failed previously:
      * Punish once by defecting if cooperated last round.
      * Forgive and try cooperating if defected last round.
    - In last round:
      * Cooperate if previous threshold met.
      * Defect otherwise.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number
        m = self.m
        r = self.r
        last_round = t - 1
        my_last_action_bool = history.my_actions[last_round]
        opp_last_actions = history.opponent_actions[last_round]
        coop_count = int(my_last_action_bool) + int(opp_last_actions.sum())
        current_round = t + 1
        my_last_action = Action.C if my_last_action_bool else Action.D
        if current_round == 1:
            return Action.C
        if current_round == r:
            if coop_count >= m:
                return Action.C
            else:
                return Action.D
        if coop_count >= m:
            return Action.C
        elif my_last_action == Action.C:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_58(BaseStrategy):
    """
    Conditional Cooperation with Threshold Vigilance for Collective Risk Dilemma.
    
    Summary:
    - Start cooperating at round 1.
    - For rounds 2 to r-1:
        * If previous round had at least m cooperators (including self), cooperate.
        * Else defect to punish.
        * Exception: If previous round was defect due to insufficient cooperation but
          the round before that met cooperation threshold, try cooperating again to recover.
    - Defect in the last round (round r) to maximize payoff via backward induction.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number
        current_round = t + 1
        if current_round == self.r:
            return Action.D
        prev_round_idx = t - 1
        my_last_action = history.my_actions[prev_round_idx]
        opp_last_round_actions = history.opponent_actions[prev_round_idx]
        prev_cooperators = opp_last_round_actions.sum() + (1 if my_last_action else 0)
        if prev_cooperators >= self.m:
            return Action.C
        else:
            if current_round > 2:
                two_rounds_ago_idx = t - 2
                my_two_rounds_ago_action = history.my_actions[t - 2]
                opp_two_rounds_ago_actions = history.opponent_actions[t - 2]
                two_rounds_cooperators = opp_two_rounds_ago_actions.sum() + (1 if my_two_rounds_ago_action else 0)
                if two_rounds_cooperators >= self.m and my_last_action == False:
                    return Action.C
            return Action.D

class Strategy_COOPERATIVE_59(BaseStrategy):
    """
    Cooperative strategy for the Collective Risk Dilemma.
    - Start cooperating in round 1.
    - Reward cooperation when threshold met last round.
    - Forgive isolated failures and attempt to restore cooperation.
    - If threshold fails persistently (≥2 consecutive rounds), defect to punish.
    - Return to cooperation as soon as threshold met again.
    - In final round, defect unless threshold met last round and cooperation stable last 2 rounds.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game.n_players
        r = self.game.n_rounds
        m = self.game.m
        if history is None:
            return Action.C
        t = history.round_number
        if t == 0:
            return Action.C

        def coop_count_round(round_idx):
            self_coop = 1 if history.my_actions[round_idx] else 0
            opp_coop = sum(history.opponent_actions[round_idx])
            return self_coop + opp_coop
        failures = 0
        for past_round_i in range(t - 1, -1, -1):
            if coop_count_round(past_round_i) < m:
                failures += 1
            else:
                break
        last_round_idx = t - 1
        last_coop_count = coop_count_round(last_round_idx)
        self_cooperated_last = history.my_actions[last_round_idx]

        def cooperation_sufficient():
            if t < 2:
                return True
            return coop_count_round(t - 2) >= m and coop_count_round(t - 1) >= m
        current_round = t + 1
        if current_round == 1:
            return Action.C
        if current_round == r:
            threshold_met = last_coop_count >= m
            no_defectors = cooperation_sufficient()
            if threshold_met and no_defectors:
                return Action.C
            else:
                return Action.D
        if last_coop_count >= m:
            return Action.C
        if failures >= 2:
            return Action.D
        if self_cooperated_last:
            return Action.C
        return Action.D

class Strategy_COOPERATIVE_60(BaseStrategy):
    """
    Conditional Reciprocity with Early Signaling and Endgame Cooperation.

    - Round 1: Cooperate to signal trust.
    - Intermediate rounds (2..r-1):
      * If threshold met last round, cooperate.
      * Else, if cooperated last round, defect (retaliate).
      * Else, cooperate (forgive and attempt restore).
    - Final round: Cooperate unconditionally.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number + 1
        last_round_index = history.round_number - 1
        if t == self.r:
            return Action.C
        prev_opponent_actions = history.opponent_actions[last_round_index]
        prev_coop_opponents = 0
        for act in prev_opponent_actions:
            if act:
                prev_coop_opponents += 1
        my_last_action = history.my_actions[last_round_index]
        prev_cooperators = prev_coop_opponents + (1 if my_last_action else 0)
        if prev_cooperators >= self.m:
            return Action.C
        if my_last_action:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_61(BaseStrategy):
    """
    Gradual Trust Builder for Collective Risk Dilemma:
    - Starts cooperatively to signal intent.
    - Continues cooperation if threshold met or nearly met last round.
    - Forgives isolated lapses, defects only after persistent failures.
    - Defects in last round if threshold not met previously to avoid exploitation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.n = self.game.n_players
        self.r = self.game.n_rounds
        self.m = self.game.m
        self.k = self.game.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number
        current_round = t + 1
        last_round_idx = t - 1
        second_last_round_idx = t - 2 if t >= 2 else None
        prev_coops = 0
        if last_round_idx >= 0:
            own_last = history.my_actions[last_round_idx]
            opps_last = history.opponent_actions[last_round_idx]
            prev_coops = own_last.astype(int) + opps_last.astype(int).sum()
        prev2_coops = 0
        if second_last_round_idx is not None and second_last_round_idx >= 0:
            own_prev2 = history.my_actions[second_last_round_idx]
            opps_prev2 = history.opponent_actions[second_last_round_idx]
            prev2_coops = own_prev2.astype(int) + opps_prev2.astype(int).sum()

        def threshold_met(coop_count):
            return coop_count >= self.m
        fail_count = 0
        if last_round_idx >= 0 and (not threshold_met(prev_coops)):
            fail_count += 1
        if second_last_round_idx is not None and second_last_round_idx >= 0 and (not threshold_met(prev2_coops)):
            fail_count += 1
        if current_round == self.r:
            if threshold_met(prev_coops):
                return Action.C
            else:
                return Action.D
        if threshold_met(prev_coops):
            return Action.C
        elif prev_coops == self.m - 1:
            return Action.C
        elif fail_count >= 2:
            return Action.D
        else:
            fail_3rounds = 0
            for lookback_round in range(max(0, t - 3), t):
                own_look = history.my_actions[lookback_round]
                opps_look = history.opponent_actions[lookback_round]
                coop_count = own_look.astype(int) + opps_look.astype(int).sum()
                if coop_count < self.m:
                    fail_3rounds += 1
            if fail_3rounds >= 3:
                return Action.D
            if self.k > 3:
                return Action.C
            return Action.C

class Strategy_COOPERATIVE_62(BaseStrategy):
    """
    Threshold Reciprocity strategy for the Collective Risk Dilemma.

    Starts by cooperating to build trust. On each subsequent round (except last),
    cooperates if the previous round met or exceeded the cooperation threshold m,
    otherwise defects to punish defectors. Forgives quickly by returning to cooperation
    once threshold met again. On the final round, cooperates only if the majority of
    previous rounds were cooperative, else defects to avoid exploitation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number + 1
        prev_round_idx = history.round_number - 1
        my_last_action = history.my_actions[prev_round_idx]
        opp_last_actions = history.opponent_actions[prev_round_idx]
        num_C_prev = opp_last_actions.sum() + (1 if my_last_action else 0)
        if t < self.r:
            if num_C_prev >= self.m:
                return Action.C
            else:
                return Action.D
        else:
            cooperative_rounds = 0
            for round_idx in range(history.round_number):
                opp_actions = history.opponent_actions[round_idx]
                my_action = history.my_actions[round_idx]
                round_cooperators = opp_actions.sum() + (1 if my_action else 0)
                if round_cooperators >= self.m:
                    cooperative_rounds += 1
            if cooperative_rounds >= self.r / 2:
                return Action.C
            else:
                return Action.D

class Strategy_COOPERATIVE_63(BaseStrategy):
    """
    Conditional Reciprocity with Optimistic Start for the Collective Risk Dilemma.
    Starts cooperating to signal willingness, then conditionally cooperates or defects
    based on previous rounds' cooperation levels. Forgives occasional defections but
    punishes persistent ones. Applies endgame cautiousness by reducing cooperation in
    the last 20% of rounds and defects in the final round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self.current_cooperation_state = 'Cooperating'
        self.defections_seen = 0
        self.min_rounds_for_coop = max(1, int(self.r * 0.2))
        self.forgiveness_threshold = 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            self.current_cooperation_state = 'Cooperating'
            self.defections_seen = 0
            return Action.C
        round_num = history.round_number
        last_round_idx = round_num - 1
        coop_last_round = int(history.my_actions[last_round_idx]) + history.opponent_actions[last_round_idx].sum()
        next_round = round_num + 1
        if next_round > self.r - self.min_rounds_for_coop:
            if next_round == self.r:
                return Action.D
            elif coop_last_round >= self.m:
                return Action.C
            else:
                return Action.D
        if self.current_cooperation_state == 'Cooperating':
            if coop_last_round >= self.m:
                self.defections_seen = 0
                return Action.C
            else:
                self.defections_seen += 1
                if self.defections_seen > self.forgiveness_threshold:
                    self.current_cooperation_state = 'Punishing'
                    return Action.D
                else:
                    return Action.C
        else:
            start_check = round_num - self.forgiveness_threshold
            recent_coop_rounds = []
            for past_round in range(start_check, round_num):
                if past_round < 0:
                    break
                coop_in_past_round = int(history.my_actions[past_round]) + history.opponent_actions[past_round].sum()
                recent_coop_rounds.append(coop_in_past_round)
            if len(recent_coop_rounds) == self.forgiveness_threshold and all((c >= self.m for c in recent_coop_rounds)):
                self.current_cooperation_state = 'Cooperating'
                self.defections_seen = 0
                return Action.C
            else:
                return Action.D

class Strategy_COOPERATIVE_64(BaseStrategy):
    """
    Cooperative strategy for the Collective Risk Dilemma:
    - Start cooperating to signal willingness.
    - In rounds 2 to r-1:
      * If threshold met last round, cooperate.
      * If threshold failed and I cooperated last round, punish by defecting once.
      * If threshold failed and I defected last round, cooperate to restore cooperation.
    - Always cooperate in the last round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game.n_players
        r = self.game.n_rounds
        m = self.game.m
        if history is None:
            return Action.C
        t = history.round_number
        last_round = t - 1
        opp_cooperators_last_round = history.opponent_actions[last_round].sum()
        my_cooperated_last_round = history.my_actions[last_round]
        cooperators_last_round = opp_cooperators_last_round + (1 if my_cooperated_last_round else 0)
        if t == 1:
            return Action.C
        if 1 < t < r:
            if cooperators_last_round >= m:
                return Action.C
            elif my_cooperated_last_round:
                return Action.D
            else:
                return Action.C
        if t == r:
            return Action.C
        return Action.C

class Strategy_AGGRESSIVE_3(BaseStrategy):
    """
    Aggressive Exploitative Opportunist strategy for the Collective Risk Dilemma.
    
    Summary:
    - Round 1: Defect to test opponents and preserve endowment.
    - Intermediate rounds (2 to r-1):
        * If reward met last round:
            - Defect by default.
            - Cooperate only if threshold was just met (=m cooperators),
              I defected last round, to maintain threshold.
        * If reward missed last round:
            - If I cooperated last round, punish by defecting this round.
            - Otherwise, cooperate to recover threshold.
    - Last round: Always defect to maximize private payoff.
    
    Operates using only observable history of actions and payoffs.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.n = self.game.n_players
        self.r = self.game.n_rounds
        self.m = self.game.m
        self.k = self.game.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number
        if t == self.r:
            return Action.D
        last_actions_self = history.my_actions[t - 1 - 1]
        opp_actions_last = history.opponent_actions[t - 1 - 1]
        cooperators_last = opp_actions_last.sum() + (1 if last_actions_self else 0)
        reward_achieved = cooperators_last >= self.m
        if reward_achieved:
            if not last_actions_self and cooperators_last == self.m:
                return Action.C
            else:
                return Action.D
        elif last_actions_self:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_4(BaseStrategy):
    """
    Aggressive Strategy for Collective Risk Dilemma.

    This strategy aggressively maximizes own payoff by defecting whenever possible,
    cooperating only when it is pivotal to meet the cooperation threshold to unlock the reward.

    Summary:
    - Round 1: Defect outright.
    - Middle rounds (2..r-1): Cooperate only if defecting causes the total cooperators
      (including self) to drop below the threshold m, else defect to exploit cooperators.
    - Last round: Defect outright to maximize one-shot payoff without concern for future retaliation.
    - Uses previous round cooperation count to forecast current round cooperation.
    - If previous round failed the threshold, cooperate once if it can flip the outcome; otherwise defect.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.n = self.game.n_players
        self.r = self.game.n_rounds
        self.m = self.game.m
        self.k = self.game.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        n = self.n
        r = self.r
        m = self.m
        prev_round_idx = t - 2
        if prev_round_idx < 0:
            return Action.D
        prev_coop_myself = 1 if history.my_actions[prev_round_idx] else 0
        prev_coop_others = sum(history.opponent_actions[prev_round_idx])
        coop_count_prev = prev_coop_myself + prev_coop_others
        if t == 1:
            return Action.D
        if t == r:
            return Action.D
        if coop_count_prev >= m:
            expected_cooperation = coop_count_prev
            if expected_cooperation - 1 >= m:
                return Action.D
            else:
                return Action.C
        elif coop_count_prev + 1 >= m:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_5(BaseStrategy):
    """
    Aggressive Collective Risk Dilemma strategy:
    - Round 1: Defect.
    - Last round: Defect.
    - If previous round cooperators count ≥ m: defect (free-ride).
    - If previous round cooperators count = m - 1: cooperate to push cooperation over threshold.
    - Else defect.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        if history is None:
            return Action.D
        round_number = history.round_number
        current_round = round_number + 1
        if current_round == r:
            return Action.D
        prev_opponent_cooperators = history.opponent_actions[round_number - 1].sum()
        prev_self_action = history.my_actions[round_number - 1]
        prev_cooperators_count = prev_opponent_cooperators + (1 if prev_self_action else 0)
        if prev_cooperators_count >= m:
            return Action.D
        if prev_cooperators_count == m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_6(BaseStrategy):
    """
    Aggressive Strategy for Collective Risk Dilemma

    - First round: defect.
    - Subsequent rounds:
      - If previous round had ≥ m cooperators (including self), defect to free ride.
      - If previous round had exactly m-1 cooperators, cooperate to trigger threshold.
      - Else defect (threshold unlikely).
    - Last round: always defect regardless, to maximize payoff.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        m = self.game.m
        r = self.game.n_rounds
        if history is None:
            return Action.D
        t = history.round_number + 1
        prev_cooperators = 0
        if t > 1:
            self_last = history.my_actions[-1]
            opp_last = history.opponent_actions[-1]
            prev_cooperators = opp_last.sum() + (1 if self_last else 0)
        if t == 1:
            return Action.D
        elif 2 <= t < r:
            if prev_cooperators >= m:
                return Action.D
            elif prev_cooperators == m - 1:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_7(BaseStrategy):
    """
    Aggressive strategy for Collective Risk Dilemma.
    
    Starts defecting to exploit cooperators. Cooperates only to 
    restore/maintain the cooperation threshold to secure reward k. 
    Tracks consecutive threshold failures caused by own defection and 
    cooperates to prevent long-term loss. In the last round, cooperates 
    if needed to achieve threshold, else defects.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.consecutive_threshold_failures = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        k = self.game_description.k
        if history is None or history.round_number == 0:
            self.consecutive_threshold_failures = 0
            return Action.D
        t = history.round_number
        prev_round_idx = t - 1
        my_prev_action = history.my_actions[prev_round_idx]
        opp_prev_actions = history.opponent_actions[prev_round_idx]
        prev_coop = int(my_prev_action) + int(opp_prev_actions.sum())
        current_round = t + 1

        def prev_failure_due_to_own_defect():
            return prev_coop < m and (not my_prev_action)
        if prev_coop < m:
            if not my_prev_action:
                self.consecutive_threshold_failures += 1
            else:
                self.consecutive_threshold_failures = 0
        else:
            self.consecutive_threshold_failures = 0
        if current_round == r:
            if prev_coop < m:
                return Action.C
            else:
                return Action.D
        if prev_coop < m:
            return Action.C
        if prev_coop > m:
            return Action.D
        if self.consecutive_threshold_failures > 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_8(BaseStrategy):
    """
    Aggressive "Threshold Enforcer" strategy for Collective Risk Dilemma.

    Summary:
    - Round 1: Cooperate with 20% chance to probe for cooperation, else defect.
    - Intermediate rounds (2 to r-1):
        * If previous round met threshold (≥ m cooperators), defect to exploit.
        * If previous cooperators == m - 1, cooperate to try to reach threshold.
        * Else defect.
    - Last round (r): Always defect (greedy).
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C if random.random() < 0.2 else Action.D
        t = history.round_number + 1
        prev_round_idx = t - 2
        my_prev_c = False
        if prev_round_idx >= 0:
            my_prev_c = history.my_actions[prev_round_idx]
        if prev_round_idx >= 0:
            opp_prev_round = history.opponent_actions[prev_round_idx]
            countC_prev_round = opp_prev_round.sum() + (1 if my_prev_c else 0)
        else:
            countC_prev_round = 0
        if t == 1:
            return Action.C if random.random() < 0.2 else Action.D
        if t == self.r:
            return Action.D
        if countC_prev_round >= self.m:
            return Action.D
        if countC_prev_round == self.m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_9(BaseStrategy):
    """
    Aggressive Collective Risk Dilemma strategy: "Threshold Exploit and Punish (TEP)"

    Summary:
    - Round 1: Defect to probe opponents.
    - Rounds 2 to r-1:
      * If threshold met last round:
        - Defect always to exploit cooperating players.
      * If threshold not met last round:
        - Cooperate only if doing so this round is decisive to reach threshold,
          and if did not cooperate last round (minimize own cooperation).
        - Else defect to punish or avoid sucker payoffs.
    - Last round r: Defect unconditionally (endgame).
    The strategy exploits reward structure to free-ride while intimidating others
    through minimal cooperation and punishing insufficient cooperation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.n = self.game.n_players
        self.r = self.game.n_rounds
        self.m = self.game.m
        self.k = self.game.k

    def __call__(self, history: None | PlayerHistory):
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number
        round_num = t
        i_cooperated_last_round = history.my_actions[-1]
        last_round_opponent_coop = history.opponent_actions[t - 1].sum()
        coop_count_last = last_round_opponent_coop + (1 if i_cooperated_last_round else 0)
        estimated_coop_last = last_round_opponent_coop
        if round_num < self.r:
            if coop_count_last >= self.m:
                return Action.D
            elif not i_cooperated_last_round and estimated_coop_last + 1 >= self.m:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_10(BaseStrategy):
    """
    Aggressive strategy for Collective Risk Dilemma:
    - Always defect in first and last rounds.
    - In intermediate rounds, cooperate only if predicted cooperators are exactly m-1 (to secure reward k > 1).
    - Otherwise defect to free-ride on others' cooperation.
    - Prediction based on average past cooperation of opponents.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        n_opponents = self.n - 1
        if t == 1:
            return Action.D
        past_opponent_coop_counts = []
        for past_round in range(t - 1):
            coop_count = history.opponent_actions[past_round].sum(dtype=int)
            past_opponent_coop_counts.append(coop_count)
        if len(past_opponent_coop_counts) == 0:
            avg_coop = 0.0
        else:
            avg_coop = sum(past_opponent_coop_counts) / len(past_opponent_coop_counts)
        predicted_cooperators = avg_coop
        if predicted_cooperators >= self.m:
            return Action.D
        elif predicted_cooperators == self.m - 1 and self.k > 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_11(BaseStrategy):
    """
    Aggressive Exploiter Strategy for Collective Risk Dilemma.

    - Defects aggressively to exploit cooperators whenever safe.
    - Cooperates only when cooperation is strictly necessary to meet the threshold m.
    - If the group has ever failed to meet the threshold, permanently defects in retaliation.
    - Always defects on the last round for maximum individual gain.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.gd = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.gd.n_players
        r = self.gd.n_rounds
        m = self.gd.m
        if history is None:
            if m == 1:
                return Action.C
            else:
                return Action.D
        t = history.round_number
        current_round = t + 1
        if current_round == r:
            return Action.D
        opp_coops_per_round = history.opponent_actions.sum(axis=1) if t > 0 else 0
        my_coops = history.my_actions.astype(int) if t > 0 else []
        if t > 0:
            total_coops = opp_coops_per_round + my_coops
        else:
            total_coops = []
        if t > 0 and any((total_coop < m for total_coop in total_coops)):
            return Action.D
        if t > 0:
            avgC = sum(total_coops) / t
        else:
            avgC = 0.0
        if t > 0:
            prev_round_coops = total_coops[-1]
            i_defected_last_round = not history.my_actions[-1]
            if prev_round_coops == m - 1 and i_defected_last_round:
                return Action.C
        if avgC >= m:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_19(BaseStrategy):
    """
    Cooperative Minimal-Threshold Strategy for Collective Risk Dilemma.
    
    - Round 1: Always cooperate.
    - Rounds 2..r-1: Identify stable cooperators and select just enough 
      to reach threshold m. Cooperate if self is among first m cooperators 
      in sorted order; defect otherwise.
    - Last round r: Cooperate only if at least m-1 others cooperated in previous round,
      else defect to avoid exploitation.
    
    Maintains cooperator_set adapting to history:
    - Includes players who cooperated at least once,
    - Removes persistent defectors (never cooperated),
    - Forgives occasional lapses,
    - Always includes self.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.n = self.game.n_players
        self.r = self.game.n_rounds
        self.m = self.game.m
        self.k = self.game.k
        self.my_id = None
        self.cooperator_set = set()

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if self.my_id is None:
            first_my_action = history.my_actions[0]
            for candidate_id in range(self.n):
                combined_first_round = []
                for pid in range(self.n):
                    if pid == candidate_id:
                        combined_first_round.append(first_my_action)
                    elif pid < candidate_id:
                        combined_first_round.append(history.opponent_actions[0, pid])
                    else:
                        combined_first_round.append(history.opponent_actions[0, pid - 1])
                pass
            self.my_id = 0
            self.cooperator_set = set([self.my_id])
        current_round = history.round_number + 1
        completed_rounds = history.round_number
        n = self.n
        full_actions = []
        for rnd in range(completed_rounds):
            round_actions = []
            for pid in range(n):
                if pid == self.my_id:
                    round_actions.append(history.my_actions[rnd])
                elif pid < self.my_id:
                    round_actions.append(history.opponent_actions[rnd, pid])
                else:
                    round_actions.append(history.opponent_actions[rnd, pid - 1])
            full_actions.append(round_actions)
        coop_counts = [0] * n
        for pid in range(n):
            count = 0
            for rnd in range(completed_rounds):
                if full_actions[rnd][pid]:
                    count += 1
            coop_counts[pid] = count
        if current_round == 1:
            self.cooperator_set = set([self.my_id])
            return Action.C
        elif 1 < current_round < self.r:
            cooperator_candidates = set((pid for pid, c in enumerate(coop_counts) if c > 0))
            self.cooperator_set = self.cooperator_set & cooperator_candidates | set([self.my_id])
            if len(self.cooperator_set) < self.m:
                self.cooperator_set.add(self.my_id)
                return Action.C
            else:
                sorted_cooperators = sorted(self.cooperator_set)
                if self.my_id in sorted_cooperators[:self.m]:
                    return Action.C
                else:
                    return Action.D
        else:
            if completed_rounds == 0:
                return Action.D
            prev_round = completed_rounds - 1
            prev_actions = full_actions[prev_round]
            coop_others = sum((1 for pid in range(n) if pid != self.my_id and prev_actions[pid]))
            if coop_others >= self.m - 1:
                return Action.C
            else:
                return Action.D

class Strategy_AGGRESSIVE_12(BaseStrategy):
    """
    Aggressive Strategy for Collective Risk Dilemma.

    Defect by default to maximize personal payoff and exploit cooperators.
    Cooperate only when absolutely necessary to meet minimum cooperation threshold
    and secure the group reward, especially when exactly one cooperator short of threshold.
    On last round, defect unless cooperation is strictly needed to get reward.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        current_round = 1 if history is None else history.round_number + 1
        if history is None:
            return Action.D
        last_round_idx = current_round - 2
        coop_opponents = 0
        if last_round_idx >= 0:
            coop_opponents = history.opponent_actions[last_round_idx].sum()
        self_coop = 1 if history.my_actions[last_round_idx] else 0
        cooperators_last_round = coop_opponents + self_coop
        m = self.m
        r = self.r
        t = current_round
        if t < r:
            if cooperators_last_round >= m:
                return Action.D
            elif cooperators_last_round == m - 1:
                return Action.C
            else:
                return Action.D
        elif cooperators_last_round >= m:
            return Action.D
        elif cooperators_last_round == m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_13(BaseStrategy):
    """
    Aggressive "Threshold Snipe" strategy for the
    Collective Risk Dilemma repeated game.

    Summary:
    - Round 1: defect outright to maximize private payoff and observe others.
    - Rounds 2 to r-1: cooperate only if your cooperation is strictly necessary
      to reach the threshold (m). Otherwise defect to exploit cooperators.
    - Last round: always defect to maximize final payoff.
    - Use history to estimate if the threshold can be met without you.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory):
        if history is None or history.round_number == 0:
            return Action.D
        current_round = history.round_number + 1
        my_i = 0
        if current_round == self.r:
            return Action.D
        coop_counts = []
        total_rounds = history.round_number
        for rnd in range(total_rounds):
            opp_coops = sum(history.opponent_actions[rnd])
            self_coop = 1 if history.my_actions[rnd] else 0
            coop_counts.append(opp_coops + self_coop)
        if total_rounds == 0:
            return Action.D
        avg_coop = sum(coop_counts) / total_rounds
        last_self_coop = 1 if history.my_actions[-1] else 0
        est_without_self = avg_coop - last_self_coop
        if est_without_self >= self.m:
            return Action.D
        if est_without_self == self.m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_15(BaseStrategy):
    """
    Aggressive Opportunistic Exploiter for the Collective Risk Dilemma.
    
    Summary:
    - Defect always on first and last rounds.
    - After observing each round, if threshold m was met, defect and reset cooperation attempt.
    - If threshold missed, cooperate once to try push threshold, then defect if no success.
    - Keeps a simple state flag CoopAttempted to track if cooperation was tried after failure.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.CoopAttempted = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        if history is None:
            self.CoopAttempted = False
            return Action.D
        t = history.round_number
        current_round = t + 1
        if current_round == r:
            self.CoopAttempted = False
            return Action.D
        last_round_idx = t - 1
        if last_round_idx < 0:
            self.CoopAttempted = False
            return Action.D
        my_last = history.my_actions[last_round_idx]
        opp_last = history.opponent_actions[last_round_idx]
        coop_count_prev = int(my_last) + int(opp_last.sum())
        if coop_count_prev >= m:
            self.CoopAttempted = False
            return Action.D
        elif not self.CoopAttempted:
            self.CoopAttempted = True
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_16(BaseStrategy):
    """
    Aggressive Strategy for the Collective Risk Dilemma.

    Starts with a cooperative "probe" round to induce others to cooperate.
    Then exploits cooperation by defecting when threshold met.
    Cooperates to encourage cooperation if threshold not met,
    but switches to permanent defect after two consecutive failures to have threshold met following cooperation.
    Always defects in last round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.consecutive_failures = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        if history is None or history.round_number == 0:
            self.consecutive_failures = 0
            return Action.C
        t = history.round_number
        last_round_idx = t - 1
        my_last_action = history.my_actions[last_round_idx]
        opp_last_actions = history.opponent_actions[last_round_idx]
        opp_cooperators = opp_last_actions.sum()
        total_cooperators_last = opp_cooperators + (1 if my_last_action else 0)
        threshold_met_last = total_cooperators_last >= m
        if t == r:
            return Action.D
        if threshold_met_last:
            self.consecutive_failures = 0
            return Action.D
        if my_last_action:
            self.consecutive_failures += 1
        else:
            self.consecutive_failures = 0
        if self.consecutive_failures >= 2:
            return Action.D
        return Action.C


class Strategy_AGGRESSIVE_14(BaseStrategy):
    """
    Aggressive Strategy for the Collective Risk Dilemma.

    Summary:
    - Defect on first and last rounds always.
    - After first round, defect aggressively to maximize own payoff.
    - Exploit cooperators by defecting if threshold met last round.
    - Punish by defecting if threshold not met.
    - Never cooperate except sparsely to try to push cooperation over threshold
      when others are cooperating just below threshold.
    - Attempt minimal cooperation every ceil(r / 10) rounds if last round 
      cooperator count was exactly m-1 to try enabling threshold bonus.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.coop_interval = int(math.ceil(self.game_description.n_rounds / 10))

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        k = self.game_description.k
        C = True
        D = False
        if history is None:
            return Action.D
        t = history.round_number
        current_round = t + 1
        if current_round == r:
            return Action.D
        last_my_action = history.my_actions[-1]
        last_my_payoff = history.my_payoffs[-1]
        opp_actions_last_round = history.opponent_actions[-1]
        c_count = opp_actions_last_round.sum() + (1 if last_my_action else 0)
        threshold_met = c_count >= m
        action = D
        if current_round % self.coop_interval == 0:
            if c_count == m - 1:
                action = C
                return Action.C if action else Action.D
        if threshold_met:
            action = D
        elif last_my_action == C:
            action = D
        else:
            action = D
        return Action.C if action else Action.D

class Strategy_AGGRESSIVE_17(BaseStrategy):
    """
    Opportunistic Exploiter for Collective Risk Dilemma.

    Aggressively defects to maximize individual payoffs,
    only cooperating when strictly necessary to secure
    the collective threshold and thus avoid losing the large reward.

    Strategy:
    - Round 1: defect by default.
    - Intermediate rounds:
      * Estimate average cooperation from history.
      * Predict others' cooperation this round based on past average.
      * Cooperate if your cooperation is pivotal to reach threshold m.
      * Otherwise defect aggressively to exploit cooperators.
    - Last round: always defect.
    - If threshold was met previously without your cooperation, defect always.
    """

    def __init__(self, game_description):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history):
        if history is None:
            return Action.D
        t = history.round_number
        if t == self.r - 1:
            return Action.D
        self_coop = history.my_actions.astype(int)
        opp_coop = history.opponent_actions.astype(int).sum(axis=1)
        total_coop_per_round = self_coop + opp_coop
        threshold_met_without_me = any((total_coop_per_round[i] >= self.m and self_coop[i] == 0 for i in range(t)))
        if threshold_met_without_me:
            return Action.D
        avg_coop = total_coop_per_round.sum() / t
        your_prev_coops = self_coop.sum()
        avg_coop_others = avg_coop - your_prev_coops / t
        predicted_coop_others = avg_coop_others
        if predicted_coop_others + 1 < self.m:
            return Action.C
        elif predicted_coop_others + 1 == self.m:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_18(BaseStrategy):
    """
    Aggressive strategy for the Collective Risk Dilemma.

    Summary:
    - Defect by default to maximize personal payoff.
    - Cooperate only if strictly necessary to push total cooperators to threshold (m)
      to secure the reward k.
    - Never cooperate on last round.
    - Exploit cooperators if others already meet or exceed threshold.
    - Use past rounds to estimate expected number of cooperating opponents (moving average).
    - Be extra aggressive if m = n - 1 (coop only if strictly necessary).
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.gd = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        if t == self.r:
            return Action.D

        def coop_others_at(round_idx: int) -> int:
            return int(history.opponent_actions[round_idx].sum())

        def estimate_expected_others_coop() -> float:
            if history is None or history.round_number == 0:
                return 0.0
            total_others = 0
            for i in range(history.round_number):
                total_others += coop_others_at(i)
            return total_others / history.round_number
        expected_others = estimate_expected_others_coop()
        extra_aggressive = self.m == self.n - 1
        if expected_others >= self.m:
            return Action.D
        if expected_others == self.m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_19(BaseStrategy):
    """
    Aggressive Collective Risk Dilemma Strategy:
    - Defect in first and last rounds.
    - Between rounds, defect if threshold met last round, 
      else cooperate only if needed to rescue threshold (minimal cooperation).
    - Exploits cooperators by free-riding whenever threshold is met.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number + 1
        m = self.m
        r = self.r
        if t == r:
            return Action.D
        last_round_index = history.round_number - 1
        opp_coop_last = 0
        if last_round_index >= 0:
            opp_coop_last = history.opponent_actions[last_round_index].sum()
        self_coop_last = history.my_actions[last_round_index].item() if last_round_index >= 0 else False
        num_C_last = int(opp_coop_last) + (1 if self_coop_last else 0)
        if num_C_last >= m:
            return Action.D
        num_C_current = int(opp_coop_last)
        if num_C_current < m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_20(BaseStrategy):
    """
    Aggressive Collective Risk Dilemma strategy.

    - Round 1: defect (no info, exploit)
    - Intermediate rounds: 
      * If last round cooperation count >= m: defect (exploit cooperators)
      * Else cooperate only if last round cooperators == m-1 (pivotal),
        else defect (avoid waste)
    - Last round: always defect (maximize immediate payoff)
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        round_num = 1 if history is None else history.round_number + 1
        if round_num == 1:
            return Action.D
        last_round_idx = round_num - 2
        my_last_action = False
        if history is not None and history.round_number > 0:
            my_last_action = history.my_actions[-1]
        last_opponent_actions = history.opponent_actions[last_round_idx] if history is not None else []
        last_opp_cooperators = 0 if history is None else sum(last_opponent_actions)
        last_cooperators = last_opp_cooperators + (1 if my_last_action else 0)
        if round_num == self.r:
            predicted_cooperation = last_cooperators
            return Action.D
        if last_cooperators >= self.m:
            return Action.D
        elif last_cooperators == self.m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_21(BaseStrategy):
    """
    Aggressive Opportunistic Defector with Exploit & Punish for Collective Risk Dilemma.

    Strategy summary:
    - Round 1: Defect to exploit possible cooperators.
    - Rounds 2 to r-1:
       - If previous round met cooperation threshold, defect to exploit cooperators.
       - Else, cooperate only if your cooperation can tip the number of cooperators to threshold.
       - Otherwise, defect.
    - Last round: Defect unconditionally.
    
    Tracks previous round cooperators and threshold status via history.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        prev_round_idx = history.round_number - 1
        my_prev_action = history.my_actions[prev_round_idx]
        opp_prev_actions = history.opponent_actions[prev_round_idx]
        prev_cooperators = int(my_prev_action) + int(opp_prev_actions.sum())
        prev_round_threshold_met = prev_cooperators >= self.m
        if prev_round_threshold_met:
            return Action.D
        elif prev_cooperators == self.m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_22(BaseStrategy):
    """
    Aggressive strategy for the Collective Risk Dilemma:
    - Always defect by default.
    - Cooperate only if exactly one less than threshold cooperators existed last round to push 
      group to threshold and unlock rewards.
    - Defect on first round and last round aggressively.
    - Free-ride on cooperators whenever threshold already met.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self.threshold = self.m

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        round_num = history.round_number
        if round_num == self.r - 1:
            return Action.D
        last_round_idx = round_num - 1
        if last_round_idx < 0:
            return Action.D
        opp_coop_last = history.opponent_actions[last_round_idx].sum()
        my_coop_last = 1 if history.my_actions[last_round_idx] else 0
        total_coop_last = opp_coop_last + my_coop_last
        if total_coop_last >= self.threshold:
            return Action.D
        elif total_coop_last == self.threshold - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_23(BaseStrategy):
    """
    Aggressive Strategy for Collective Risk Dilemma (CRD).

    This strategy aggressively maximizes individual payoff by defecting whenever possible,
    only cooperating strategically to push the group over the cooperation threshold (m) 
    when it guarantees a bonus (k) with minimal personal cooperation cost.
    
    - Round 1: Always defect (test or seize immediate payoff).
    - Rounds 2 to r-1:
        * Defect if threshold met last round (free ride).
        * Cooperate if exactly m-1 cooperators last round to push threshold.
        * Defect otherwise.
    - Final round r:
        * Cooperate only if cooperation now can meet threshold.
        * Defect otherwise to avoid cost without future leverage.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        round_num = history.round_number + 1
        prev_round_idx = history.round_number - 1
        prev_C_count = history.my_actions[prev_round_idx].astype(int) + history.opponent_actions[prev_round_idx].astype(int).sum()
        if round_num < self.r:
            if prev_C_count >= self.m:
                return Action.D
            elif prev_C_count == self.m - 1:
                return Action.C
            else:
                return Action.D
        elif prev_C_count >= self.m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_24(BaseStrategy):
    """
    Aggressive Strategy for the Collective Risk Dilemma:
    - Round 1: Defect to exploit any naive cooperators.
    - Rounds 2 to r-1: 
        * If enough cooperators last round (≥ m), defect to maximize individual gain.
        * If not enough cooperators:
            - Cooperate only if by cooperating we reach threshold m (push for reward).
            - Else defect to punish or free ride.
        * If previously cooperated but reward missed, defect now to punish.
    - Last round (round r): Always defect for immediate max payoff.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.n = self.game.n_players
        self.r = self.game.n_rounds
        self.m = self.game.m
        self.k = self.game.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number
        last_round = t == self.r
        cooperators_prev = history.opponent_actions[t - 1 - 1].sum()
        my_prev_coop = history.my_actions[t - 1 - 1]
        if last_round:
            return Action.D
        if cooperators_prev >= self.m:
            return Action.D
        else:
            total_if_coop = cooperators_prev + 1
            if total_if_coop >= self.m:
                return Action.C
            elif my_prev_coop:
                return Action.D
            else:
                return Action.D

class Strategy_AGGRESSIVE_25(BaseStrategy):
    """
    Aggressive Opportunistic Free-rider strategy for the Collective Risk Dilemma.
    
    - Defects initially if threshold m ≤ n/2, else cooperates first round.
    - In middle rounds, defects whenever others cooperated enough to secure reward,
      cooperates minimally only when pivotal to just achieve threshold.
    - In final round, defects unless cooperation is strictly needed to meet threshold.
    - Uses randomized cooperation probability p_coop (default 0.2) when pivotal.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.p_coop = 0.2

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game.n_players
        r = self.game.n_rounds
        m = self.game.m
        if history is None or history.round_number == 0:
            if m <= n / 2:
                return Action.D
            else:
                return Action.C
        t = history.round_number
        t_current = t + 1
        my_idx = 0
        last_round = t - 1
        coop_others_last = history.opponent_actions[last_round].sum()
        my_last_action = history.my_actions[last_round]
        C_prev = coop_others_last + (1 if my_last_action else 0)
        if t_current == r:
            if C_prev >= m:
                return Action.D
            elif C_prev == m - 1:
                return Action.C
            else:
                return Action.D
        elif C_prev >= m:
            coop_count_needed = m - (C_prev - (1 if my_last_action else 0))
            if coop_count_needed <= 0:
                return Action.D
            elif coop_count_needed == 1:
                if random.random() < self.p_coop:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
        else:
            shortfall = m - C_prev
            if shortfall > 1:
                return Action.D
            else:
                return Action.C

class Strategy_AGGRESSIVE_26(BaseStrategy):
    """
    Dominant Defector with Opportunistic Exploitation.

    Aggressively defects to maximize private payoff unless cooperation is essential
    to secure the collective reward. Never initiates cooperation. Exploits others' cooperation
    and punishes borderline cooperation by defecting. Always defects in the final round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        last_round_idx = t - 2
        my_last_action = history.my_actions[last_round_idx]
        opp_last_actions = history.opponent_actions[last_round_idx]
        cooperators_last_round = int(my_last_action) + opp_last_actions.sum()
        if cooperators_last_round >= self.m:
            if not my_last_action:
                return Action.D
            elif cooperators_last_round - 1 >= self.m:
                return Action.D
            else:
                return Action.C
        elif cooperators_last_round + 1 >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_27(BaseStrategy):
    """
    Aggressive Strategy for Collective Risk Dilemma.

    Summary:
    - Always defect first round (no info).
    - Last round always defect (no future punishment/reward).
    - On intermediate rounds:
      * If previous round met threshold (≥ m cooperators), defect to freeride.
      * If previous round just missed threshold by one (coop_prev == m-1),
        cooperate if others are sufficiently reliable cooperators; else defect.
      * Otherwise defect.
    - Trust in cooperators is estimated by counting which opponents cooperated
      frequently in past rounds. If enough opponents appear consistently cooperative,
      cooperate minimally to push group over threshold.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number
        current_round = t + 1
        n = self.n
        m = self.m
        r = self.r
        if current_round == r:
            return Action.D
        prev_opponent_actions = history.opponent_actions[t - 1]
        coop_prev = prev_opponent_actions.sum()
        if coop_prev >= m:
            return Action.D
        if coop_prev == m - 1:
            if t == 0:
                return Action.D
            coop_counts = history.opponent_actions[:t].sum(axis=0)
            coop_fractions = coop_counts / t
            last_round_cooperators = set((i for i, val in enumerate(prev_opponent_actions) if val))
            reliable_coops = [i for i in last_round_cooperators if coop_fractions[i] >= 0.7]
            if len(reliable_coops) >= m - 1:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_28(BaseStrategy):
    """
    Aggressive Strategy for the Collective Risk Dilemma:
    - Defects by default.
    - Cooperates only reactively in rounds 2 to r-1 if exactly m-1 opponents cooperated last round
      (to push total cooperators to threshold m).
    - Defects first and last round outright.
    - Exploits cooperators by defecting whenever threshold was met last round without own cooperation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == r:
            return Action.D
        if history.round_number == 0:
            prev_coop_count = sum(history.opponent_actions[0])
        else:
            prev_coop_count = sum(history.opponent_actions[history.round_number - 1])
        if prev_coop_count >= m:
            return Action.D
        if prev_coop_count == m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_29(BaseStrategy):
    """
    Aggressive Strategy for Collective Risk Dilemma.

    - Defects initially to test and exploit cooperators.
    - Exploits once threshold met without own cooperation.
    - Cooperates minimally only to push group cooperation over threshold when one short.
    - Defects in final round(s) to maximize immediate payoff.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        round_t = history.round_number + 1
        if round_t > self.r:
            return Action.D
        last_round_idx = round_t - 2
        opponent_coop_bool = history.opponent_actions[last_round_idx]
        coop_opponents = opponent_coop_bool.sum()
        my_last_coop = history.my_actions[last_round_idx]
        C_count_prev = coop_opponents + (1 if my_last_coop else 0)
        if round_t == self.r:
            return Action.D
        if round_t == self.r - 1:
            if C_count_prev >= self.m:
                return Action.D
            elif C_count_prev == self.m - 1:
                return Action.C
            else:
                return Action.D
        if C_count_prev is None:
            return Action.D
        coop_excl_me = C_count_prev - (1 if my_last_coop else 0)
        if coop_excl_me >= self.m:
            return Action.D
        elif coop_excl_me == self.m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_30(BaseStrategy):
    """
    Aggressive 'Threshold Enforcer' strategy for the Collective Risk Dilemma.

    Summary:
    - Defects first round and last round to maximize immediate payoff.
    - Monitors the number of cooperators each round.
    - If the previous round failed to meet the threshold (m), defects persistently.
    - If threshold met last round, cooperates only if needed to push this round's
      cooperation count to at least m (i.e., if you are the marginal cooperator).
    - Otherwise defects to aggressively free-ride.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if self.m >= self.n:
            return Action.D
        if history is None:
            return Action.D
        t = history.round_number
        current_round = t + 1
        if t == 0:
            last_C = 0
        else:
            last_coop_opp = history.opponent_actions[t - 1].sum()
            last_self_coop = 1 if history.my_actions[t - 1] else 0
            last_C = last_coop_opp + last_self_coop
        if current_round > self.r:
            return Action.D
        if current_round == self.r:
            return Action.D
        if last_C < self.m:
            return Action.D
        last_others_coop = last_C - (1 if history.my_actions[t - 1] else 0)
        others_cooperate_estimate = min(last_others_coop, self.n - 1)
        if others_cooperate_estimate < self.m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_31(BaseStrategy):
    """
    Aggressive Collective Risk Dilemma strategy.
    
    - Round 1: Always defect.
    - Rounds 2 to r-1: Cooperate only if your cooperation guarantees crossing
      the threshold m (enabling the reward) based on previous round cooperators count.
    - Round r: Defect.
    
    This strategy exploits cooperators by freeriding but cooperates just enough
    to push the group over the threshold when it benefits own payoff.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number
        last_round_idx = t - 1
        if t == 0:
            return Action.D
        if last_round_idx < 0:
            return Action.D
        opponents_cooperators_last = history.opponent_actions[last_round_idx].sum()
        last_self_action = history.my_actions[last_round_idx]
        total_cooperators_last = opponents_cooperators_last + (1 if last_self_action else 0)
        current_round = t + 1
        c_last = total_cooperators_last
        if current_round == 1:
            return Action.D
        if current_round == self.r:
            return Action.D
        if c_last < self.m - 1:
            return Action.D
        if c_last == self.m - 1:
            return Action.C
        if c_last >= self.m:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_32(BaseStrategy):
    """
    Exploitative Aggressor for Collective Risk Dilemma:
    
    Aggressively defects whenever possible, relying on others' cooperation to reach threshold m.
    Defects first round, last round, and whenever possible in-between to maximize private payoff.
    Punishes wasted cooperation by defecting if threshold is not met.
    Does not repair cooperation once threshold fails.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        prev_idx = t - 2
        if prev_idx < 0:
            return Action.D
        my_c_prev = history.my_actions[prev_idx]
        opp_c_prev = history.opponent_actions[prev_idx].sum()
        count_C_prev = (1 if my_c_prev else 0) + opp_c_prev
        if t == 1:
            return Action.D
        if 2 <= t <= self.r - 1:
            if count_C_prev >= self.m:
                return Action.D
            else:
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_33(BaseStrategy):
    """
    Aggressive Exploiter for Collective Risk Dilemma.

    Strategy logic:
    - Round 1: always defect (probe).
    - Intermediate rounds:
        * If threshold was met last round (≥ m cooperators), defect to exploit cooperators.
        * If threshold not met:
            - Cooperate only if last round cooperators count == m - 1 (to push threshold).
            - Otherwise defect to avoid cost.
    - Final round: always defect to maximize endgame payoff.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number
        current_round = t + 1
        if current_round == self.r:
            return Action.D
        prev_round_idx = t - 1
        self_last_action = history.my_actions[prev_round_idx]
        opp_last_actions = history.opponent_actions[prev_round_idx]
        coop_opp = opp_last_actions.sum(dtype=int)
        coop_total = coop_opp + (1 if self_last_action else 0)
        if coop_total >= self.m:
            return Action.D
        elif coop_total == self.m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_34(BaseStrategy):
    """
    Aggressive Threshold Exploit & Punish strategy for the Collective Risk Dilemma.
    Always defects to maximize personal payoff by exploiting cooperators if threshold met,
    punishing cooperators if threshold not met, and never cooperating.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.n = self.game.n_players
        self.r = self.game.n_rounds
        self.m = self.game.m
        self.k = self.game.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number
        if t == self.r:
            return Action.D
        prev_opp_actions = history.opponent_actions[t - 1 - 1]
        prev_cooperators = prev_opp_actions.sum()
        own_action_prev = history.my_actions[t - 1 - 1]
        C_prev = prev_cooperators + (1 if own_action_prev else 0)
        threshold_met_prev = C_prev >= self.m
        return Action.D

class Strategy_AGGRESSIVE_35(BaseStrategy):
    """
    Aggressive strategy for Collective Risk Dilemma.

    Key points:
    - Always defect first round to exploit naive cooperators.
    - For middle rounds:
      * If last round reached threshold, defect to exploit cooperators.
      * If last round below threshold, cooperate only if threshold nearly reached (m-1) to push over threshold, else defect.
    - Last round:
      * Defect unless cooperation is needed to reach threshold.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number
        last_round = t - 1
        coop_count_last = history.opponent_actions[last_round].sum()
        if last_round >= 0 and last_round < len(history.my_actions):
            if history.my_actions[last_round]:
                coop_count_last += 1
        if t == self.r:
            if coop_count_last >= self.m:
                return Action.D
            if coop_count_last + 1 >= self.m:
                return Action.C
            return Action.D
        else:
            if coop_count_last >= self.m:
                return Action.D
            if coop_count_last == self.m - 1:
                return Action.C
            return Action.D

class Strategy_AGGRESSIVE_36(BaseStrategy):
    """
    Aggressive "Threshold Exploiter" strategy for the Collective Risk Dilemma.
    Defects by default to free-ride on others' cooperation.
    Cooperates only when cooperation is pivotal to reach the threshold reward.
    In final round, cooperates only if strictly necessary to meet threshold.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number
        last_round = t - 1
        opp_cooperators = history.opponent_actions[last_round].sum()
        my_last_action = history.my_actions[last_round]
        cooperators_last_round = opp_cooperators + (1 if my_last_action else 0)
        next_round = t + 1
        if next_round > self.r:
            return Action.D
        if next_round < self.r:
            if cooperators_last_round < self.m - 1:
                return Action.C
            else:
                return Action.D
        elif cooperators_last_round == self.m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_37(BaseStrategy):
    """
    Threshold Punisher (Aggressive Exploiter) for the Collective Risk Dilemma.

    Summary:
    - Always defect first round to observe/cooperate-free ride.
    - Defect last round to avoid exploitation.
    - For rounds 2 to r-1:
      * Predict cooperators if defecting (assume same as last round)
      * If threshold met without cooperating, defect (free ride).
      * If threshold can't be met even with cooperating, defect.
      * Only cooperate if your cooperation flips the round to meet threshold.
    - Punishes unconditional cooperators by never cooperating unless strictly beneficial.

    This maximizes personal payoff aggressively while ensuring cooperation threshold is met only
    when it benefits this player.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number
        current_round = t + 1
        if current_round == self.r:
            return Action.D
        if t == 0:
            return Action.D
        C_last_opponents = int(history.opponent_actions[t - 1].sum())
        my_last_action = history.my_actions[t - 1]
        C_last = C_last_opponents + (1 if my_last_action else 0)
        if C_last == 0:
            return Action.D
        C_expected = C_last_opponents
        if C_expected >= self.m:
            return Action.D
        if C_expected < self.m - 1:
            return Action.D
        if C_expected == self.m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_38(BaseStrategy):
    """
    Aggressive Exploiter strategy for Collective Risk Dilemma.
    
    - Defect first round unconditionally.
    - Defect last round unconditionally.
    - In middle rounds, cooperate only if exactly (m - 1) other cooperators observed previous round,
      to push cooperation over threshold and trigger reward.
    - Otherwise defect aggressively to maximize payoff.
    - Never trust or reward others' cooperation beyond what's minimally necessary.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.has_cooperated_to_push = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number
        r = self.game.n_rounds
        m = self.game.m
        if t == r:
            return Action.D
        if t == 0:
            return Action.D
        prev_coop_count = 0
        prev_opp_actions = history.opponent_actions[t - 1]
        prev_coop_count += prev_opp_actions.sum()
        self_prev_action = history.my_actions[t - 1]
        pred_coop_without_self = prev_coop_count + (1 if self_prev_action else 0) - (1 if self_prev_action else 0)
        cooperation_ever = history.my_actions.any() or history.opponent_actions.any()
        if not cooperation_ever:
            return Action.D
        coop_total_last = prev_coop_count + (1 if self_prev_action else 0)
        pred_coop_without_self = coop_total_last - (1 if self_prev_action else 0)
        if pred_coop_without_self >= m:
            return Action.D
        elif pred_coop_without_self == m - 1:
            if not self.has_cooperated_to_push:
                self.has_cooperated_to_push = True
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_39(BaseStrategy):
    """
    Aggressive strategy for the Collective Risk Dilemma.
    
    This strategy seeks to maximize individual payoff by free-riding on others'
    cooperation, cooperating minimally only to ensure the reward threshold is met,
    and defecting otherwise. It uses observed cooperation counts from previous rounds
    to decide actions, always defects in the last round, and cooperates cautiously in
    the first round only if the threshold seems plausibly reachable.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.n = self.game.n_players
        self.r = self.game.n_rounds
        self.m = self.game.m
        self.k = self.game.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            if self.m - 1 < self.n / 2:
                return Action.C
            else:
                return Action.D
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        prev_index = t - 2
        prev_cooperators = int(history.my_actions[prev_index]) + int(history.opponent_actions[prev_index, :].sum())
        if prev_cooperators >= self.m:
            return Action.D
        elif prev_cooperators == self.m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_40(BaseStrategy):
    """
    Aggressive Strategy for Collective Risk Dilemma.

    Starts by defecting to test others. Cooperates only to push total cooperators
    from (m-1) to m to secure the reward, otherwise defects to exploit cooperators or punish
    failures. Always defects in the last round. If threshold never met after initial rounds,
    punishes by continuous defection.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number
        if t == self.r:
            return Action.D
        last_round = t - 1
        opp_cooperators = history.opponent_actions[last_round].sum()
        if t > 1:
            self_cooperated_last = history.my_actions[last_round]
            self_coop_c = 1 if self_cooperated_last else 0
        else:
            self_coop_c = 0
        C_prev = opp_cooperators + self_coop_c
        threshold_met_last = C_prev >= self.m
        threshold_met_history = []
        for round_idx in range(t):
            opp_c = history.opponent_actions[round_idx].sum()
            self_c = history.my_actions[round_idx]
            total_c = opp_c + (1 if self_c else 0)
            threshold_met_history.append(total_c >= self.m)
        learning_window = max(2, self.r // 3)
        if t > learning_window:
            if not any(threshold_met_history):
                return Action.D
        if threshold_met_last:
            if C_prev - 1 >= self.m:
                return Action.D
            else:
                return Action.C
        if C_prev == self.m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_41(BaseStrategy):
    """
    Threshold Exploiter strategy for the Collective Risk Dilemma.

    This aggressive strategy aims to maximize own payoff by defecting whenever
    the cooperation threshold was previously met (to free-ride). It cooperates
    only when the threshold was not met to try to restore the reward payoff.
    In the first round, it cooperates only if nearly full cooperation is required,
    otherwise defects aggressively. In the last round it always defects to maximize payoff.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game.n_players
        r = self.game.n_rounds
        m = self.game.m
        k = self.game.k
        if history is None or history.round_number == 0:
            if m >= n - 1:
                return Action.C
            else:
                return Action.D
        round_idx = history.round_number
        current_round = round_idx + 1
        last_round_idx = round_idx - 1
        last_round_actions = [history.my_actions[last_round_idx]]
        last_round_actions.extend(history.opponent_actions[last_round_idx, :])
        count_coop_last_round = sum(last_round_actions)
        if current_round == r:
            return Action.D
        if current_round > 1 and current_round < r:
            if count_coop_last_round >= m:
                return Action.D
            else:
                return Action.C
        return Action.D

class Strategy_AGGRESSIVE_42(BaseStrategy):
    """
    Aggressive Strategy for Collective Risk Dilemma.

    This strategy aims to maximize individual payoff by defecting unless 
    cooperating strictly improves the player's payoff by pushing the 
    cooperators count to meet or exceed the threshold m.

    Key rules:
    - Defect in first round.
    - For rounds 2 to r-1: cooperate only if your cooperation alone would turn 
      a failed threshold (<m) into a met threshold (≥m), yielding a strictly 
      higher payoff than defecting.
    - Defect in last round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.n = self.game.n_players
        self.r = self.game.n_rounds
        self.m = self.game.m
        self.k = self.game.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        if t == 1:
            return Action.D
        last_round_idx = t - 2
        you_cooperated_last = bool(history.my_actions[last_round_idx])
        coop_opp_last = history.opponent_actions[last_round_idx].sum()
        last_coop = coop_opp_last + (1 if you_cooperated_last else 0)
        coop_count_if_cooperate = last_coop + 1
        coop_count_if_defect = last_coop
        cooper_threshold_met_if_coop = coop_count_if_cooperate >= self.m
        cooper_threshold_met_if_def = coop_count_if_defect >= self.m
        payoff_if_cooperate = 0 + (self.k if cooper_threshold_met_if_coop else 0)
        payoff_if_defect = 1 + (self.k if cooper_threshold_met_if_def else 0)
        if coop_count_if_defect < self.m and coop_count_if_cooperate >= self.m and (payoff_if_cooperate > payoff_if_defect):
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_43(BaseStrategy):
    """
    Threshold Raider strategy for the Collective Risk Dilemma.

    Aggressively defects whenever the threshold m of cooperators is met without needing own cooperation,
    cooperates only when the group is just one cooperator short of threshold (m-1) to push over the threshold,
    and defects otherwise. Always defects the first and last rounds because of lack of information or future payoff.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number
        if t == self.r:
            return Action.D
        rounds_so_far = t
        if rounds_so_far == 0:
            return Action.D
        coop_counts = history.opponent_actions[:rounds_so_far, :]
        coop_counts_sum = coop_counts.sum(axis=0)
        coop_rates = coop_counts_sum / rounds_so_far
        estimated_others_cooperators = int(round(coop_rates.sum()))
        if estimated_others_cooperators >= self.m:
            return Action.D
        elif estimated_others_cooperators == self.m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_44(BaseStrategy):
    """
    Aggressive Strategy for Collective Risk Dilemma.

    Starts by defecting to exploit naïve cooperators.
    Mid-game defects unless confident threshold of cooperators met,
    then cooperates only if enough others cooperated last round to secure reward.
    In last round, cooperates opportunistically if threshold likely met.
    Uses a sliding window of last w rounds (w=3) to estimate cooperation levels.
    Never initiates cooperation early; only exploits cooperators.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.w = 3

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        if history is None:
            return Action.D
        t = history.round_number + 1
        rounds_played = history.round_number
        cooperators_counts = []
        for i in range(rounds_played):
            count = 0
            if history.my_actions[i]:
                count += 1
            count += sum(history.opponent_actions[i])
            cooperators_counts.append(count)
        if len(cooperators_counts) >= self.w:
            window = cooperators_counts[-self.w:]
        else:
            window = cooperators_counts if cooperators_counts else []
        avg_cooperators = sum(window) / len(window) if window else 0
        if t == 1:
            return Action.D
        if t < r:
            if avg_cooperators >= m:
                last_round_cooperators = cooperators_counts[-1] if cooperators_counts else 0
                self_coop_last_round = history.my_actions[-1] if rounds_played >= 1 else False
                others_coop_last_round = last_round_cooperators - (1 if self_coop_last_round else 0)
                if others_coop_last_round >= m - 1:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
        elif avg_cooperators >= m:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_45(BaseStrategy):
    """
    Aggressive strategy for the Collective Risk Dilemma:
    Defects by default, only cooperates when absolutely necessary to keep 
    group cooperation at threshold m to secure the reward k.
    Always defects the last round.
    Exploits others' cooperation by minimally cooperating.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number
        if t == self.r - 1:
            return Action.D
        coop_prev_array = history.opponent_actions[t - 1] if t > 0 else None
        if t == 0:
            return Action.D
        prev_self_coop = history.my_actions[t - 1]
        coop_count_prev = (coop_prev_array.sum() if coop_prev_array is not None else 0) + (1 if prev_self_coop else 0)
        if coop_count_prev >= self.m:
            if coop_count_prev > self.m:
                return Action.D
            elif prev_self_coop:
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

class Strategy_AGGRESSIVE_46(BaseStrategy):
    """
    Aggressive "Threshold Defector with Opportunistic Cooperation" strategy for Collective Risk Dilemma.

    Summary:
    - Round 1: Defect unconditionally
    - Rounds 2..r-1:
      * If previous round had ≥ m cooperators: defect (exploit)
      * If previous round had exactly m-1 cooperators and defected last round: cooperate (push threshold)
      * If previous round had < m-1 cooperators: cooperate (avoid threshold failure)
      * Else defect
    - Round r (final): defect unconditionally
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        last_round_idx = history.round_number - 1
        my_last_coop = history.my_actions[last_round_idx]
        opp_last_actions = history.opponent_actions[last_round_idx]
        coop_prev = int(my_last_coop) + int(opp_last_actions.sum())
        my_last_action = Action.C if my_last_coop else Action.D
        if coop_prev >= self.m:
            return Action.D
        elif coop_prev == self.m - 1:
            if my_last_action == Action.D:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_47(BaseStrategy):
    """
    Aggressive strategy for Collective Risk Dilemma.
    Starts defecting to test others, exploits cooperative rounds by defecting,
    tries to rescue cooperation once if threshold nearly reached by others,
    gives up and defects permanently if rescue fails,
    and always defects in final round for endgame exploitation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.rescued = False
        self.give_up = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        if history is None:
            self.rescued = False
            self.give_up = False
            return Action.D
        t = history.round_number + 1
        if t == r:
            return Action.D
        prev_round_idx = t - 2
        self_last_action = history.my_actions[prev_round_idx]
        opponents_last_actions = history.opponent_actions[prev_round_idx]
        coop_opp_last = opponents_last_actions.sum(dtype=int)
        coop_total_last = coop_opp_last + (1 if self_last_action else 0)
        coop_wo_self_last = coop_opp_last
        if self.give_up:
            return Action.D
        if coop_total_last >= m:
            self.rescued = False
            return Action.D
        elif coop_wo_self_last >= m - 1 and (not self.rescued):
            self.rescued = True
            self.give_up = False
            return Action.C
        elif self.rescued:
            self.give_up = True
            return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_48(BaseStrategy):
    """
    Exploitative Punisher for Collective Risk Dilemma.

    Aggressively defects unless cooperation strictly guarantees the threshold 
    is met and yields a payoff at least as good as defecting.
    Exploits stable cooperators by defecting and free-riding on their contributions.
    Always defects on the first round and on the last round.
    Uses history to identify reliable cooperators (≥50% cooperation frequency).
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.n = self.game.n_players
        self.r = self.game.n_rounds
        self.m = self.game.m
        self.k = self.game.k
        self.freq_threshold = 0.5

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        rounds_played = t - 1
        opp_actions = history.opponent_actions[:rounds_played, :]
        coop_counts = opp_actions.sum(axis=0)
        freq_coop = coop_counts / rounds_played
        reliable_cooperators_mask = freq_coop >= self.freq_threshold
        num_reliable = reliable_cooperators_mask.sum()
        if num_reliable == 0:
            return Action.D
        if num_reliable >= self.m:
            return Action.D
        if num_reliable + 1 >= self.m:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_49(BaseStrategy):
    """
    Aggressive Strategy: Dominant Defect Leveraging Opportunistic Cooperation.

    Always defect first and last rounds.
    In intermediate rounds, defect regardless of previous rounds' cooperation.
    Exploits others by defecting even if threshold met, no cooperation unless guaranteed,
    which never happens given no communication and no trust.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t == 1:
            return Action.D
        if t == self.r:
            return Action.D
        last_round_index = t - 2
        my_last_action = history.my_actions[last_round_index]
        opp_last_actions = history.opponent_actions[last_round_index]
        num_cooperators_last = (1 if my_last_action else 0) + opp_last_actions.sum()
        return Action.D

class Strategy_AGGRESSIVE_50(BaseStrategy):
    """
    Aggressive "Calculated Exploit" strategy for Collective Risk Dilemma.

    Summary:
    - Round 1: defect (no information yet).
    - Middle rounds (2 to r-1):
      * If last round cooperators >= m: defect to free ride.
      * If last round cooperators == m - 1: cooperate to push threshold.
      * Else defect.
    - Last round: defect aggressively.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number + 1
        C_last_count = 0
        last_round_idx = history.round_number - 1
        C_opponents_last = history.opponent_actions[last_round_idx]
        C_last_count = C_opponents_last.sum()
        if t == self.r:
            return Action.D
        if C_last_count >= self.m:
            return Action.D
        if C_last_count == self.m - 1:
            last_my_action = history.my_actions[last_round_idx]
            if last_my_action == Action.D.value:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_51(BaseStrategy):
    """
    Aggressive Strategy for Collective Risk Dilemma.

    - Always defect on first round to test others.
    - On intermediate rounds (2..r-1), defect if threshold met without self.
    - Cooperate only if defecting would cause threshold failure but cooperation likely to push over threshold.
    - Always defect on last round for max payoff.
    - Uses history of opponents' cooperation to estimate likelihood of cooperation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        k = self.game_description.k
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number + 1
        if t == r:
            return Action.D
        last_round_idx = t - 2
        my_last_action = history.my_actions[last_round_idx]
        opponents_last_actions = history.opponent_actions[last_round_idx]
        coop_last_others = 0
        for a in opponents_last_actions:
            if a:
                coop_last_others += 1
        coop_last = coop_last_others
        if coop_last >= m:
            return Action.D
        if coop_last == m - 1:
            rounds_to_check = last_round_idx
            if rounds_to_check == 0:
                return Action.D
            coop_counts = []
            for round_i in range(rounds_to_check):
                ccount = 0
                opp_act = history.opponent_actions[round_i]
                for oa in opp_act:
                    if oa:
                        ccount += 1
                if history.my_actions[round_i]:
                    ccount += 1
                coop_counts.append(ccount)
            consistent_coop_rounds = 0
            for c in coop_counts:
                if c >= m - 1:
                    consistent_coop_rounds += 1
            if consistent_coop_rounds >= rounds_to_check / 2:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_52(BaseStrategy):
    """
    Aggressor strategy for Collective Risk Dilemma.
    
    - Round 1: Defect to test baseline.
    - Middle rounds (2 to r-1): 
      * If last round cooperation count ≥ m:
          Cooperate only if last round cooperators count == m-1 (pivotal cooperator).
          Otherwise defect.
      * If last round cooperation count < m:
          Defect (punish).
    - Last round (r): Always defect.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        if history is None:
            return Action.D
        t = history.round_number
        current_round = t + 1
        last_round_idx = t - 1
        if last_round_idx < 0:
            return Action.D
        my_last_action = history.my_actions[last_round_idx]
        opp_last_actions = history.opponent_actions[last_round_idx]
        coop_count_last = opp_last_actions.sum() + (1 if my_last_action else 0)
        if current_round == 1:
            return Action.D
        elif current_round == r:
            return Action.D
        elif coop_count_last >= m:
            others_coop_last = coop_count_last - (1 if my_last_action else 0)
            if others_coop_last == m - 1:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_53(BaseStrategy):
    """
    Aggressive Strategy for Collective Risk Dilemma.

    - Defects aggressively whenever the collective reward is secured.
    - Cooperates only when the reward was lost in the previous round to try to restore it.
    - Cooperates on first round only if threshold m is very high (m >= n-1).
    - Always defects on the last round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            if self.m >= self.n - 1:
                return Action.C
            else:
                return Action.D
        t = history.round_number
        last_round = t
        if last_round >= self.r:
            return Action.D
        my_last_action = history.my_actions[-1]
        opp_last_actions = history.opponent_actions[-1]
        last_cooperators = opp_last_actions.sum() + (1 if my_last_action else 0)
        reward_secured_last_round = last_cooperators >= self.m
        current_round = last_round + 1
        if current_round == self.r:
            return Action.D
        if reward_secured_last_round:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_54(BaseStrategy):
    """
    Aggressive strategy for the Collective Risk Dilemma repeated game.

    - Defects in the first round to probe others.
    - In middle rounds, defects unless others cooperated exactly m-1 last round,
      in which case it cooperates once to trigger the collective reward.
    - Always defects in the last round (no future incentive).
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        prev_round_index = t - 2
        prev_coop_count = int(history.opponent_actions[prev_round_index].sum())
        if prev_coop_count >= self.m:
            return Action.D
        elif prev_coop_count == self.m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_55(BaseStrategy):
    """
    Aggressive Strategy for Collective Risk Dilemma.

    Summary:
    - Round 1: Cooperate to signal willingness.
    - Rounds 2 to r-1: 
        * If previous coop count >= m, defect to exploit cooperators.
        * If previous coop count == m-1, cooperate to push threshold.
        * Otherwise defect.
    - Round r: Defect unconditionally to maximize final payoff.
    - If observing persistent zero cooperation by opponents (all defect), always defect.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t > 1:
            total_opponent_coop = history.opponent_actions.sum()
            if total_opponent_coop == 0:
                return Action.D
        if t == r:
            return Action.D
        prev_round_index = t - 2
        prev_opponent_coop = history.opponent_actions[prev_round_index].sum()
        prev_my_action = history.my_actions[prev_round_index]
        prev_cooperators = prev_opponent_coop + (1 if prev_my_action else 0)
        if prev_cooperators >= m:
            return Action.D
        elif prev_cooperators == m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_56(BaseStrategy):
    """
    Aggressive strategy for the Collective Risk Dilemma.

    Overview:
    - Round 1: Defect aggressively by default.
    - Intermediate rounds:
        * If threshold met last round:
            - If cooperated last round: continue cooperating only if threshold barely met (m or m+1).
            - Else defect.
        * If threshold failed last round:
            - Identify persistent defectors (never cooperated so far).
            - Cooperate only if we can meet threshold excluding persistent defectors (punish them by denying reward).
            - Else defect.
    - Last round: always defect to maximize immediate payoff.

    Rationale:
    Exploits cooperators to maximize payoff, uses tactical cooperation to punish persistent defectors by denying rewards,
    and avoids needless cooperation beyond minimal required.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.n = self.game.n_players
        self.r = self.game.n_rounds
        self.m = self.game.m
        self.k = self.game.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number
        your_index = None
        last_round_index = t - 1
        last_my_action = history.my_actions[last_round_index]
        last_opponent_actions_row = history.opponent_actions[last_round_index]
        last_actions = [last_my_action] + list(last_opponent_actions_row)
        num_cooperators_last_round = sum(last_actions)
        persistent_defectors = set(range(self.n))
        for round_i in range(t):
            round_my_action = history.my_actions[round_i]
            round_op_actions = history.opponent_actions[round_i]
            round_actions = [round_my_action] + list(round_op_actions)
            for i, act in enumerate(round_actions):
                if i in persistent_defectors and act:
                    persistent_defectors.remove(i)
        you_cooperated_last_round = last_my_action
        current_round = t
        current_round = t + 1
        if current_round == 1:
            return Action.D
        if current_round == self.r:
            return Action.D
        if num_cooperators_last_round >= self.m:
            if you_cooperated_last_round:
                if num_cooperators_last_round <= self.m + 1:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
        else:
            likely_cooperators = [i for i in range(self.n) if i not in persistent_defectors]
            if len(likely_cooperators) >= self.m:
                if 0 in likely_cooperators:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D

class Strategy_AGGRESSIVE_57(BaseStrategy):
    """
    Aggressive strategy for the Collective Risk Dilemma:
    - Defect whenever the threshold of cooperators (m) is met or unrecoverable.
    - Cooperate only when exactly m-1 cooperators were observed last round,
      to maintain the threshold and secure the reward.
    - Defect unconditionally in the last round.
    - Start with defect in the first round due to no information.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.n = self.game.n_players
        self.r = self.game.n_rounds
        self.m = self.game.m
        self.k = self.game.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number
        current_round = t + 1
        last_round_idx = t - 1
        if current_round == self.r:
            return Action.D
        my_last_action = history.my_actions[last_round_idx]
        opponents_last_actions = history.opponent_actions[last_round_idx]
        coop_count_last = int(my_last_action) + int(opponents_last_actions.sum())
        coop_count_two_rounds_ago = None
        if t >= 2:
            second_last_idx = t - 2
            my_action_2 = history.my_actions[second_last_idx]
            opp_actions_2 = history.opponent_actions[second_last_idx]
            coop_count_two_rounds_ago = int(my_action_2) + int(opp_actions_2.sum())
        if coop_count_two_rounds_ago is not None:
            if coop_count_two_rounds_ago < self.m and coop_count_last < coop_count_two_rounds_ago:
                return Action.D
        if coop_count_last >= self.m:
            return Action.D
        if coop_count_last == self.m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_58(BaseStrategy):
    """
    Aggressive strategy for Collective Risk Dilemma.
    - Always defect in first round.
    - In intermediate rounds:
      * If threshold failed last round, defect.
      * If threshold met last round:
         - Defect if threshold met without me.
         - Cooperate only if threshold depends on me and cooperation appears stable.
         - Otherwise defect.
    - In last round:
      * Defect if threshold met without me.
      * Cooperate only if my cooperation pushes cooperators to meet threshold.
      * Otherwise defect.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.stable_window = min(3, self.game.n_rounds)

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game.n_players
        r = self.game.n_rounds
        m = self.game.m
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number
        last_round_idx = t - 1
        my_prev_action = history.my_actions[last_round_idx]
        opponent_prev_actions = history.opponent_actions[last_round_idx]
        coop_prev_round = int(my_prev_action) + int(opponent_prev_actions.sum())
        coop_without_me = coop_prev_round - int(my_prev_action)

        def stable_cooperation(hist: PlayerHistory, threshold: int) -> bool:
            """
            Determine if cooperators show stable cooperation over recent rounds.
            Stability criterion:
              - For each recent round in the window, number of cooperators >= threshold
              - Additionally, own cooperation must be consistent in recent rounds
            """
            start = max(0, hist.round_number - self.stable_window)
            rounds_to_check = range(start, hist.round_number)
            for rnd in rounds_to_check:
                my_act = hist.my_actions[rnd]
                opp_acts = hist.opponent_actions[rnd]
                total_coop = int(my_act) + int(opp_acts.sum())
                if total_coop < threshold:
                    return False
            recent_self_coop = hist.my_actions[start:hist.round_number]
            if len(recent_self_coop) == 0:
                return False
            coop_ratio = recent_self_coop.sum() / len(recent_self_coop)
            return coop_ratio >= 0.66
        if t == r:
            if coop_without_me >= m:
                return Action.D
            elif coop_prev_round < m and coop_prev_round + 1 >= m:
                return Action.C
            else:
                return Action.D
        if coop_prev_round < m:
            return Action.D
        if coop_without_me >= m:
            return Action.D
        if my_prev_action:
            if stable_cooperation(history, threshold=m):
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_59(BaseStrategy):
    """
    Threshold Predator strategy for the Collective Risk Dilemma.

    Aggressive, selfish approach that defects by default,
    exploits cooperators when threshold met, and only cooperates
    to push group over threshold if cooperation narrowly missed previously.
    Always defects in first and last rounds.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_desc = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        cooperators_last_round = 0
        if current_round > 1:
            my_last = history.my_actions[-1]
            opp_last = history.opponent_actions[-1]
            total_cooperators = int(my_last) + int(opp_last.sum())
            cooperators_last_round = total_cooperators
        else:
            cooperators_last_round = 0
        if current_round == self.r:
            return Action.D
        if 1 < current_round < self.r:
            if cooperators_last_round >= self.m:
                return Action.D
            elif cooperators_last_round == self.m - 1:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_60(BaseStrategy):
    """
    Aggressive 'Threshold Exploiter' strategy for Collective Risk Dilemma.
    
    Defects by default to secure private payoff.
    Cooperates only when strictly needed to reach threshold and unlock reward.
    Exploits cooperators by defecting once threshold met without own cooperation.
    In last round, always defects to maximize personal gain.
    Punishes persistent failure to reach threshold by permanent defection.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self.punish = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number
        last_round_idx = t - 1
        if t == self.r:
            return Action.D
        if self.punish:
            return Action.D
        others_c = history.opponent_actions[last_round_idx].sum()
        threshold_met_rounds = []
        coop_rounds = []
        for round_i in range(t):
            opp_coop = history.opponent_actions[round_i].sum()
            my_coop = history.my_actions[round_i]
            total_coop = opp_coop + (1 if my_coop else 0)
            threshold_met = total_coop >= self.m
            threshold_met_rounds.append(threshold_met)
            coop_rounds.append(my_coop)
        failed_coop_rounds = [i for i in range(t) if coop_rounds[i] and (not threshold_met_rounds[i])]
        if len(failed_coop_rounds) >= 2:
            self.punish = True
            return Action.D
        if others_c >= self.m:
            return Action.D
        elif others_c == self.m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_61(BaseStrategy):
    """
    Aggressive strategy for Collective Risk Dilemma:
    - Defect first round to exploit cooperators.
    - Cooperate only when strictly necessary to keep total cooperators ≥ m (threshold).
    - Defect whenever threshold is assured by others to maximize personal payoff.
    - In last round, cooperate only if your cooperation is needed to reach threshold.
    - Use full history each round to decide based on previous round cooperation counts.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number
        current_round = t + 1
        my_last_action = history.my_actions[t - 1]
        opp_last_actions = history.opponent_actions[t - 1]
        C_prev = opp_last_actions.sum()
        if my_last_action:
            C_prev += 1
        if current_round < self.r:
            if C_prev >= self.m:
                return Action.D
            elif C_prev + 1 >= self.m:
                return Action.C
            else:
                return Action.D
        elif C_prev >= self.m:
            return Action.D
        elif C_prev + 1 >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_62(BaseStrategy):
    """
    Aggressive Conditional Exploiter for the Collective Risk Dilemma.

    Implements an aggressive strategy that defaults to defecting,
    cooperates minimally just to achieve the collective bonus k when
    profitable, exploits persistent cooperators by defecting,
    and defects in the last round unless cooperation is strictly needed
    to secure the bonus.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number
        current_round = t + 1
        if t == 0:
            observed_cooperators_last_round = 0
            self_cooperated_last_round = False
        else:
            prev_opponent_actions = history.opponent_actions[t - 1]
            observed_cooperators_last_round = prev_opponent_actions.sum()
            self_cooperated_last_round = history.my_actions[t - 1]
        est_cooperators = observed_cooperators_last_round - (1 if self_cooperated_last_round else 0)
        if current_round == self.r:
            if est_cooperators >= self.m:
                return Action.D
            elif est_cooperators + 1 >= self.m:
                return Action.C
            else:
                return Action.D
        if est_cooperators >= self.m:
            return Action.D
        if est_cooperators + 1 >= self.m:
            if self.k >= 1:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_63(BaseStrategy):
    """
    Aggressive strategy for the Collective Risk Dilemma.
    Implements defection on round 1 and last round unconditionally.
    Exploits others by defecting when threshold can be met without own cooperation.
    Cooperates only if payoff last round was below reward threshold and others nearly cooperate.
    Defects to punish failed cooperation groups.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        k = self.game_description.k
        if history is None:
            return Action.D
        t = history.round_number
        current_round = t + 1
        if current_round == r:
            return Action.D
        if t == 0:
            return Action.D
        last_opponent_actions = history.opponent_actions[t - 1]
        last_my_action = history.my_actions[t - 1]
        C_last = last_opponent_actions.sum() + (1 if last_my_action else 0)
        if C_last >= m:
            if C_last - 1 >= m:
                return Action.D
            else:
                c_i_last = 1 if last_my_action else 0
                payoff_last = 1 - c_i_last + k
                if payoff_last < 1 + k:
                    return Action.C
                else:
                    return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_64(BaseStrategy):
    """
    Aggressive Free-Rider Exploit with Dynamic Threshold Testing for Collective Risk Dilemma.
    
    Always defects except for the first round (where it defects to test environment).
    It exploits cooperators by free-riding when threshold met and punishes cooperation
    by defecting whenever threshold not met. On last round, defects to maximize immediate gain.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number
        current_round = t + 1
        last_round_cooperators = 0
        if t >= 1:
            opponent_coops = history.opponent_actions[t - 1].sum()
            my_last_action = history.my_actions[t - 1]
            last_round_cooperators = int(opponent_coops) + (1 if my_last_action else 0)
        if current_round == self.r:
            return Action.D
        return Action.D

class Strategy_COOPERATIVE_65(BaseStrategy):
    """
    Conditional Threshold Cooperation (CTC) strategy for the Collective Risk Dilemma.
    Starts cooperating to build trust and reach the threshold m.
    Monitors previous round cooperation to decide:
      - Punish by defecting temporarily if cooperation breaks down after I cooperated.
      - Forgive and resume cooperation once cooperation recovers.
      - Defect in final round if cooperation insufficient to avoid exploitation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punish_rounds_remaining = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        if history is None or history.round_number == 0:
            self.punish_rounds_remaining = 0
            return Action.C
        t = history.round_number
        current_round = t
        last_round = current_round - 1
        my_last_action = history.my_actions[last_round]
        opp_last_actions = history.opponent_actions[last_round]
        last_cooperation_count = opp_last_actions.sum() + (1 if my_last_action else 0)
        if self.punish_rounds_remaining > 0:
            self.punish_rounds_remaining -= 1
            return Action.D
        if last_cooperation_count < m and my_last_action and (last_cooperation_count > 0):
            remaining_rounds_after_this = r - (current_round + 1)
            self.punish_rounds_remaining = min(2, remaining_rounds_after_this)
            return Action.D
        if current_round + 1 == r:
            if last_cooperation_count >= m:
                return Action.C
            else:
                return Action.D
        if last_cooperation_count >= m:
            return Action.C
        return Action.D

class Strategy_COOPERATIVE_66(BaseStrategy):
    """
    Cooperative Strategy for Collective Risk Dilemma.

    This strategy starts by cooperating in round 1 to signal trust.
    From rounds 2 to r-1, it cooperates if at least (m-1) other players cooperated
    in the previous round, else defects to punish defection.
    In the final round r, it cooperates if the previous round reached the threshold m 
    or almost reached it (m-1), else defects to avoid exploitation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.gd = game_description
        self.n = self.gd.n_players
        self.r = self.gd.n_rounds
        self.m = self.gd.m

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number
        current_round = t + 1
        last_round_idx = t - 1
        if last_round_idx < 0:
            return Action.C
        last_opponent_actions = history.opponent_actions[last_round_idx]
        last_cooperators_opponents = last_opponent_actions.sum()
        self_cooperated_last = history.my_actions[last_round_idx]
        total_last_cooperators = last_cooperators_opponents + (1 if self_cooperated_last else 0)
        if current_round == 1:
            return Action.C
        elif 1 < current_round < self.r:
            if last_cooperators_opponents >= self.m - 1:
                return Action.C
            else:
                return Action.D
        elif current_round == self.r:
            if total_last_cooperators >= self.m:
                return Action.C
            elif total_last_cooperators == self.m - 1:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_67(BaseStrategy):
    """
    Cooperative strategy for the Collective Risk Dilemma.
    Starts cooperating; continues cooperating if last round's total cooperators reached threshold m;
    defects otherwise to punish, except when everyone defected last round (then tries to restart cooperation);
    cooperates in the last round to maximize payoff.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        round_num = history.round_number
        current_round = round_num + 1
        if current_round == self.r:
            return Action.C
        prev_round_idx = round_num - 1
        my_last_action = history.my_actions[prev_round_idx]
        opponents_last_actions = history.opponent_actions[prev_round_idx]
        prev_total_coop = opponents_last_actions.sum() + (1 if my_last_action else 0)
        if prev_total_coop >= self.m:
            return Action.C
        if prev_total_coop == 0:
            return Action.C
        return Action.D

class Strategy_COOPERATIVE_68(BaseStrategy):
    """
    Conditional Reciprocity with Forgiveness for Collective Risk Dilemma.

    - Cooperate first round to signal willingness.
    - Continue cooperating if previous round met cooperation threshold (≥ m).
    - If not met, punish exactly once by defecting, then forgive by cooperating.
    - In last round, cooperate only if previous round met threshold; else defect.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.defected_last_round = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        if history is None:
            self.defected_last_round = False
            return Action.C
        t = history.round_number + 1
        my_last_action = history.my_actions[-1]
        opponents_last_actions = history.opponent_actions[-1]
        previous_cooperator_count = opponents_last_actions.sum() + (1 if my_last_action else 0)
        last_round_cooperation_met = previous_cooperator_count >= m
        if t == 1:
            self.defected_last_round = False
            return Action.C
        if t == r:
            if last_round_cooperation_met:
                return Action.C
            else:
                return Action.D
        if last_round_cooperation_met:
            self.defected_last_round = False
            return Action.C
        elif self.defected_last_round:
            self.defected_last_round = False
            return Action.C
        else:
            self.defected_last_round = True
            return Action.D

class Strategy_COOPERATIVE_69(BaseStrategy):
    """
    Cooperative strategy for Collective Risk Dilemma.

    Starts by cooperating. In each subsequent round, cooperates if the previous round's
    total cooperators (including self) met or exceeded the threshold m. Defects as a
    calibrated punishment when threshold not met, but quickly forgives by returning to
    cooperation if cooperation is restored. This aims to sustain stable cooperation over
    repeated rounds with no permanent defection and tolerance near the threshold.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.m = game_description.m
        self.r = game_description.n_rounds
        self.n = game_description.n_players
        self._last_was_punishment = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            round_number = 1
        else:
            round_number = history.round_number + 1
        if round_number == 1:
            self._last_was_punishment = False
            return Action.C
        if history is None:
            self._last_was_punishment = False
            return Action.C
        last_round = round_number - 1
        if last_round - 1 < 0:
            self._last_was_punishment = False
            return Action.C
        prev_idx = last_round - 1
        my_last_action = history.my_actions[prev_idx]
        opponents_last_actions = history.opponent_actions[prev_idx]
        cooperator_count = int(my_last_action) + int(opponents_last_actions.sum())
        if cooperator_count >= self.m:
            self._last_was_punishment = False
            return Action.C
        elif not self._last_was_punishment:
            self._last_was_punishment = True
            return Action.D
        else:
            self._last_was_punishment = False
            return Action.C

class Strategy_COOPERATIVE_70(BaseStrategy):
    """
    Conditional Sustained Cooperation strategy for Collective Risk Dilemma.
    
    - Cooperates on first round.
    - Defects on last round.
    - In intermediate rounds:
      * If threshold (m) met previous round:
          - If self cooperated previous round, continue cooperating.
          - If self defected previous round, cooperate to rejoin.
      * If threshold not met previous round: defect as punishment.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        if history is None:
            return Action.C
        t = history.round_number
        if t == r - 1:
            return Action.D
        prev_round_idx = t - 1
        my_last_action = history.my_actions[prev_round_idx]
        opp_last_actions = history.opponent_actions[prev_round_idx]
        num_cooperators_prev = int(sum(opp_last_actions) + (1 if my_last_action else 0))
        if num_cooperators_prev >= m:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_71(BaseStrategy):
    """
    Conditional Gradual Cooperation (CGC) for Collective Risk Dilemma.

    - Round 1: Cooperate unconditionally to signal willingness.
    - Intermediate rounds (2 to r-1): Cooperate if previous round had at least m cooperators (including self),
      else defect to avoid exploitation.
    - Last round (r): Cooperate only if previous round had at least m cooperators and if self cooperated last round,
      otherwise defect.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number
        current_round = t + 1
        my_last_action = history.my_actions[t - 1]
        coop_opponents = sum(history.opponent_actions[t - 1])
        C_count_prev = coop_opponents + (1 if my_last_action else 0)
        if current_round == 1:
            return Action.C
        if 1 < current_round < self.r:
            if C_count_prev >= self.m:
                return Action.C
            else:
                return Action.D
        if current_round == self.r:
            if C_count_prev >= self.m and my_last_action:
                return Action.C
            else:
                return Action.D
        return Action.C

class Strategy_COOPERATIVE_72(BaseStrategy):
    """
    Threshold-Triggered Conditional Cooperation Strategy for Collective Risk Dilemma.

    - Cooperate first round to build trust.
    - In intermediate rounds:
      * Cooperate if previous round met cooperation threshold m.
      * Defect otherwise to punish failure.
      * Forgive and return to cooperation if you defected last round but threshold is now met.
    - Defect in last round to maximize personal payoff.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        r = self.game.n_rounds
        m = self.game.m
        if history is None:
            return Action.C
        last_round_idx = t - 2
        my_last_action = history.my_actions[last_round_idx]
        opp_last_actions = history.opponent_actions[last_round_idx]
        coop_count_last = int(my_last_action) + int(opp_last_actions.sum())
        if t == r:
            return Action.D
        if coop_count_last >= m:
            if not my_last_action:
                return Action.C
            else:
                return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_73(BaseStrategy):
    """
    Conditional Gradual Trust (CGT) Strategy for Collective Risk Dilemma.

    - Round 1: Cooperate to establish trust.
    - Rounds 2 to r-1: 
        * If previous round met threshold, cooperate.
        * If threshold not met and self cooperated last round, defect (punish).
        * If threshold not met and self defected last round, cooperate (forgive).
    - Last round:
        * Cooperate if previous round met threshold, else defect.
    - If cooperations fail threshold for 2 consecutive rounds **after cooperating**, permanently defect thereafter.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self._consecutive_failed_coop = 0
        self._permanently_defect = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            self._consecutive_failed_coop = 0
            self._permanently_defect = False
            return Action.C
        t = history.round_number
        current_round = t
        if self._permanently_defect:
            return Action.D
        prev_round_idx = t - 1
        i_played_C_prev = history.my_actions[prev_round_idx]
        coop_count_last = 0
        coop_count_last += history.opponent_actions[prev_round_idx].sum()
        coop_count_last += 1 if i_played_C_prev else 0
        threshold = self.m
        last_round = self.r
        if current_round == last_round:
            if coop_count_last >= threshold:
                return Action.C
            else:
                return Action.D
        if coop_count_last >= threshold:
            self._consecutive_failed_coop = 0
            return Action.C
        elif i_played_C_prev:
            self._consecutive_failed_coop += 1
            if self._consecutive_failed_coop >= 2:
                self._permanently_defect = True
                return Action.D
            return Action.D
        else:
            self._consecutive_failed_coop = 0
            return Action.C

class Strategy_COOPERATIVE_74(BaseStrategy):
    """
    Conditional Reciprocal Cooperation with Forgiveness (CRCF) for Collective Risk Dilemma.

    Starts cooperating to build trust and reach the cooperation threshold m.
    Cooperates as long as the cooperation threshold was met in the previous round.
    Forgives occasional round(s) of failed cooperation by continuing to cooperate.
    Defects once after multiple consecutive rounds missing the threshold to signal dissatisfaction.
    Then returns to cooperation to allow group recovery.
    In the last round, defects unless cooperation threshold is very likely (prev cooperators ≥ m-1).

    This balances maintaining collective cooperation and punishing persistent defection,
    with forgiveness to sustain cooperation over repeated rounds.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.cooperation_ratio_threshold = 0.7
        self.forgiveness_window = 2
        self.rounds_threshold_missed = 0
        self.last_action = Action.C

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.rounds_threshold_missed = 0
            self.last_action = Action.C
            return Action.C
        t = history.round_number + 1
        last_round_index = t - 2
        prev_cooperators_count = 0
        if last_round_index >= 0:
            my_last_action_bool = history.my_actions[last_round_index]
            opp_last_actions = history.opponent_actions[last_round_index]
            opp_cooperators = opp_last_actions.sum()
            prev_cooperators_count = opp_cooperators + (1 if my_last_action_bool else 0)
        else:
            prev_cooperators_count = 0
        if t == 1:
            action = Action.C
        elif 1 < t < self.r:
            if prev_cooperators_count >= self.m:
                self.rounds_threshold_missed = 0
                action = Action.C
            else:
                self.rounds_threshold_missed += 1
                if self.rounds_threshold_missed <= self.forgiveness_window:
                    action = Action.C
                elif self.last_action == Action.C:
                    action = Action.D
                else:
                    self.rounds_threshold_missed = 0
                    action = Action.C
        elif prev_cooperators_count >= self.m - 1:
            action = Action.C
        else:
            action = Action.D
        self.last_action = action
        return action

class Strategy_COOPERATIVE_75(BaseStrategy):
    """
    Conditional Reciprocity with Threshold Coordination (CRTC)
    
    Starts by cooperating to signal willingness.
    In subsequent rounds, cooperates only if in previous round at least m players cooperated.
    Defects otherwise.
    On the last round, cooperates if threshold met in previous round to maximize endgame payoff,
    else defects.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game.n_players
        r = self.game.n_rounds
        m = self.game.m
        if history is None:
            return Action.C
        t = history.round_number + 1
        last_round_index = t - 2
        if last_round_index < 0:
            return Action.C
        count_last_round = 0
        if history.my_actions[last_round_index]:
            count_last_round += 1
        count_last_round += history.opponent_actions[last_round_index].sum()
        if t < r:
            if count_last_round >= m:
                return Action.C
            else:
                return Action.D
        elif count_last_round >= m:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_76(BaseStrategy):
    """
    Conditional Threshold Cooperation (CTC) strategy for Collective Risk Dilemma:
    - Cooperate first round.
    - Cooperate in rounds 2 to r-1 if at least (m-1) other players cooperated last round and self cooperated last round.
    - Defect in rounds 2 to r-1 if self cooperated last round but fewer than (m-1) others cooperated.
    - If self defected last round (punishment), cooperate this round to forgive and retry cooperation.
    - Always defect in the last round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game.n_rounds
        m = self.game.m
        t = 1 if history is None else history.round_number + 1
        if t == 1:
            return Action.C
        if t == r:
            return Action.D
        last_round = t - 1 - 1
        my_last_action = history.my_actions[last_round]
        coop_others = sum(history.opponent_actions[last_round])
        if my_last_action:
            if coop_others >= m - 1:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_77(BaseStrategy):
    """
    Conditional Cooperative Assurance strategy for the Collective Risk Dilemma.
    
    - Cooperate first round to signal goodwill.
    - Continue cooperating if previous round met cooperation threshold (≥ m cooperators).
    - If cooperation broke down last round but was successful the round before, forgive once by cooperating.
    - Otherwise defect to avoid exploitation.
    - On the last round, cooperate only if prior round was cooperative, else defect.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game.n_players
        r = self.game.n_rounds
        m = self.game.m

        def safe_round(round_idx: int) -> bool:
            if round_idx < 0 or round_idx >= history.round_number:
                return False
            coop_count = int(history.opponent_actions[round_idx].sum())
            coop_count += 1 if history.my_actions[round_idx] else 0
            return coop_count >= m
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number + 1
        if t == r:
            if safe_round(r - 2):
                return Action.C
            else:
                return Action.D
        if safe_round(t - 2):
            return Action.C
        elif t > 2 and safe_round(t - 3):
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_78(BaseStrategy):
    """
    Cooperative Threshold Cooperation (CTC) strategy for the Collective Risk Dilemma.

    - Cooperate round 1 to signal willingness.
    - Monitor recent rounds to check if cooperation threshold m is met.
    - Cooperate if recent cooperation is stable (tolerance minus one or more rounds meet/cooperate).
    - Otherwise defect to avoid exploitation.
    - In final round, cooperate only if recent cooperation was stable to maintain group benefit,
      else defect to maximize private gain.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.tolerance = 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        if history is None or history.round_number == 0:
            return Action.C
        round_number = history.round_number
        current_round = round_number + 1
        countC = []
        for t in range(round_number):
            my_act = history.my_actions[t]
            opp_coop_count = sum(history.opponent_actions[t])
            total_coop = (1 if my_act else 0) + opp_coop_count
            countC.append(total_coop)
        check_from = max(0, len(countC) - self.tolerance)
        recent_window = countC[check_from:]
        recent_coop_rounds = sum((1 for c in recent_window if c >= m))
        cooperation_stable = recent_coop_rounds >= self.tolerance - 1
        if current_round == r:
            if cooperation_stable:
                return Action.C
            else:
                return Action.D
        if cooperation_stable:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_79(BaseStrategy):
    """
    Cooperative conditional strategy for the Collective Risk Dilemma:
    - Starts cooperating.
    - Attempts to maintain at least m cooperators each round, preferring a small buffer.
    - Punishes defection after rounds where cooperation threshold not met.
    - Allows re-entry to cooperation if defected but cooperation was close to threshold.
    - In last round, cooperates if previous round met threshold or self cooperated, else defects.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.n = self.game.n_players
        self.r = self.game.n_rounds
        self.m = self.game.m
        self.b = 1 if self.m + 1 <= self.n else 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        prev_idx = t - 2
        c_i_prev = history.my_actions[prev_idx]
        cooperators_opponents = history.opponent_actions[prev_idx].sum()
        cooperators_prev = cooperators_opponents + (1 if c_i_prev else 0)
        if t == 1:
            return Action.C
        elif t == self.r:
            if cooperators_prev >= self.m or c_i_prev:
                return Action.C
            else:
                return Action.D
        elif cooperators_prev >= self.m:
            if c_i_prev:
                return Action.C
            elif cooperators_prev >= self.m + self.b:
                return Action.D
            else:
                return Action.C
        elif c_i_prev:
            return Action.D
        elif cooperators_prev >= self.m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_80(BaseStrategy):
    """
    Conditional Reciprocity with Threshold Signaling for the Collective Risk Dilemma.

    Starts cooperating to establish good faith, rewards cooperation if
    threshold met in previous round, tolerates safe defection,
    tries to repair cooperation if threshold not met, and defects in last round
    if threshold was met previously to maximize private payoff.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        if history is None:
            return Action.C
        t = history.round_number
        next_round = t + 1
        last_round_idx = t - 1
        coop_counts_last = 0
        coop_counts_last = history.opponent_actions[last_round_idx].sum()
        if history.my_actions[last_round_idx]:
            coop_counts_last += 1
        if next_round == 1:
            return Action.C
        if next_round == r:
            if coop_counts_last >= m:
                return Action.D
            else:
                return Action.C
        if coop_counts_last >= m:
            my_last = history.my_actions[last_round_idx]
            if my_last:
                return Action.C
            else:
                coop_excl_me = coop_counts_last - 1
                if coop_excl_me >= m:
                    return Action.D
                else:
                    return Action.C
        else:
            return Action.C

class Strategy_COOPERATIVE_81(BaseStrategy):
    """
    Gradual Trust and Threshold Cooperation (GTTC) strategy for Collective Risk Dilemma.

    Starts cooperating to signal trust, then tracks trustworthiness of opponents by 
    incremental adjustments based on their cooperation or defection. Decides to cooperate 
    only if expected number of cooperators (including self) meets or exceeds the threshold m.
    Always cooperates in the first and final rounds. Punishes defections mildly and allows 
    trust recovery.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.gd = game_description
        self.n = self.gd.n_players
        self.r = self.gd.n_rounds
        self.m = self.gd.m
        self.DELTA_UP = 0.05
        self.DELTA_DOWN = 0.1
        self.trust = None
        self.self_index = None

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if self.self_index is None:
            self.trust = {i: 1.0 for i in range(self.n - 1)}
        t = history.round_number + 1
        if t == self.r:
            if t > 1:
                self._update_trust(history, self.trust, self.DELTA_UP, self.DELTA_DOWN)
            return Action.C
        if t == 1:
            return Action.C
        self._update_trust(history, self.trust, self.DELTA_UP, self.DELTA_DOWN)
        expected_cooperators = 1.0 + sum(self.trust.values())
        if expected_cooperators >= self.m:
            return Action.C
        else:
            return Action.D

    def _update_trust(self, history: PlayerHistory, trust: dict, delta_up: float, delta_down: float):
        last_round_idx = history.round_number - 1
        if last_round_idx < 0:
            return
        actions_last_round = history.opponent_actions[last_round_idx]
        for i in range(self.n - 1):
            if actions_last_round[i]:
                trust[i] = trust[i] + delta_up
                if trust[i] > 1.0:
                    trust[i] = 1.0
            else:
                trust[i] = trust[i] - delta_down
                if trust[i] < 0.0:
                    trust[i] = 0.0

class Strategy_COOPERATIVE_82(BaseStrategy):
    """
    Cooperative Strategy for the Collective Risk Dilemma
    
    Implements conditional cooperation based on the collective risk threshold.
    
    - Start cooperating in round 1.
    - In intermediate rounds, cooperate if at least m players cooperated last round; else defect.
    - In the final round, cooperate if last round's cooperation ≥ m; else defect.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        current_round = history.round_number
        last_round = current_round - 1
        opp_cooperators = history.opponent_actions[last_round].sum()
        my_last_action = history.my_actions[last_round]
        total_cooperators = opp_cooperators + (1 if my_last_action else 0)
        if current_round == self.r - 1:
            if total_cooperators >= self.m:
                return Action.C
            else:
                return Action.D
        if total_cooperators >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_83(BaseStrategy):
    """
    Conditional Trigger with Endgame Reciprocity for the Collective Risk Dilemma.

    - Cooperate first round to signal willingness.
    - For rounds 2 to r-1:
       * Cooperate if enough others cooperated last round (≥ m -1).
       * Defect otherwise to punish.
       * Forgive by cooperating again once cooperation recovers.
    - Defect in final round to avoid exploitation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        r = self.game.n_rounds
        m = self.game.m
        if t == 1:
            return Action.C
        if t == r:
            return Action.D
        prev_round_index = t - 2
        coop_others = history.opponent_actions[prev_round_index].sum()
        if coop_others >= m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_84(BaseStrategy):
    """
    Conditional Threshold Cooperation strategy for the Collective Risk Dilemma.

    Starts cooperatively to build trust. In subsequent rounds, aims to maintain cooperation 
    if threshold m is reached, otherwise punishes by defecting but allows one extra
    chance of cooperation after failure. Cooperates again to recover when possible.
    Pivotal players (those who can tip cooperation over the threshold) always cooperate.
    In the last round, defects if cooperation likely fails, else cooperates.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        t = 1 if history is None else history.round_number + 1
        if history is None:
            return Action.C
        prev_round_idx = t - 2
        prev_round_coops = 0
        if prev_round_idx >= 0:
            opp_coops = history.opponent_actions[prev_round_idx].sum()
            last_self_action = history.my_actions[prev_round_idx]
            last_self_C = last_self_action
            prev_round_coops = opp_coops + (1 if last_self_C else 0)
        else:
            last_self_C = True
            prev_round_coops = 0
        is_pivotal = prev_round_coops == m - 1
        if t == r:
            if prev_round_coops >= m:
                return Action.C
            else:
                return Action.D
        if prev_round_coops >= m:
            if last_self_C:
                return Action.C
            else:
                return Action.C
        elif last_self_C:
            two_rounds_ago_idx = t - 3
            if two_rounds_ago_idx >= 0:
                opp_coops_2ago = history.opponent_actions[two_rounds_ago_idx].sum()
                my_act_2ago = history.my_actions[two_rounds_ago_idx]
                coops_2ago = opp_coops_2ago + (1 if my_act_2ago else 0)
                if coops_2ago < m and prev_round_coops < m:
                    return Action.D
            return Action.C
        else:
            if is_pivotal:
                return Action.C
            return Action.D

class Strategy_COOPERATIVE_85(BaseStrategy):
    """
    Conditional Collective Cooperation (CCC) strategy for the Collective Risk Dilemma.

    Starts cooperatively. In intermediate rounds, if threshold cooperation was met last round:
      - continue cooperating if self cooperated last round,
      - else keep defecting (allow some tolerated free-riding).
    If threshold cooperation not met last round, defect to punish.
    In last round, always defect (no future to enforce cooperation).
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number
        total_rounds = self.game.n_rounds
        m = self.game.m
        last_round_idx = t - 1
        cooperators_last_round = 0
        if history.my_actions[last_round_idx]:
            cooperators_last_round += 1
        cooperators_last_round += history.opponent_actions[last_round_idx].sum()
        my_last_action = Action.C if history.my_actions[last_round_idx] else Action.D
        round_t = t + 1
        if round_t == 1:
            return Action.C
        if round_t == total_rounds:
            return Action.D
        if cooperators_last_round >= m:
            if my_last_action == Action.C:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COOPERATIVE_86(BaseStrategy):
    """
    Threshold-Triggered Reciprocity (TTR) strategy for Collective Risk Dilemma.

    - Cooperate in round 1 unconditionally.
    - For rounds 2 to r-1:
       * If last round had at least m cooperators, cooperate.
       * Else defect to punish.
       * After defecting due to insufficient cooperation, try to recover by cooperating once.
    - Defect in last round unconditionally.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self._just_defected_due_to_low_coop = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
        else:
            t = history.round_number + 1
        if t == 1:
            self._just_defected_due_to_low_coop = False
            return Action.C
        if t == self.r:
            self._just_defected_due_to_low_coop = False
            return Action.D
        prev_round = t - 1
        my_last_action = history.my_actions[prev_round - 1]
        opp_last_actions = history.opponent_actions[prev_round - 1]
        coop_count_last_round = int(my_last_action) + int(opp_last_actions.sum())
        can_recover = False
        if t > 2:
            two_rounds_ago = t - 2
            my_action_two_rounds_ago = history.my_actions[two_rounds_ago - 1]
            opp_actions_two_rounds_ago = history.opponent_actions[two_rounds_ago - 1]
            coop_count_two_rounds_ago = int(my_action_two_rounds_ago) + int(opp_actions_two_rounds_ago.sum())
            if my_last_action == 0 and coop_count_two_rounds_ago < self.m and self._just_defected_due_to_low_coop:
                self._just_defected_due_to_low_coop = False
                return Action.C
        if coop_count_last_round >= self.m:
            self._just_defected_due_to_low_coop = False
            return Action.C
        else:
            self._just_defected_due_to_low_coop = True
            return Action.D

class Strategy_COOPERATIVE_87(BaseStrategy):
    """
    Conditional Reciprocity with Forgiveness (CRF) for the Collective Risk Dilemma.
    
    Maintains a trust level T ∈ [0,1], updated each round based on group cooperation and 
    defections, with forgiveness to allow recovery. Starts cooperating unconditionally.
    Adjusts cooperation according to trust, previous round outcomes, and criticality
    of own cooperation to reach the threshold m. Always cooperates in the last round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.n = self.game.n_players
        self.r = self.game.n_rounds
        self.m = self.game.m
        self.k = self.game.k
        self.T = 1.0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.T = 1.0
            return Action.C
        t = history.round_number
        if t == self.r - 1:
            return Action.C
        prev_round = t - 1
        if prev_round >= 0:
            opp_coop = history.opponent_actions[prev_round].sum()
            my_prev_coop = history.my_actions[prev_round]
            C_count = opp_coop + (1 if my_prev_coop else 0)
            threshold_met = C_count >= self.m
            if threshold_met and my_prev_coop:
                self.T = min(1.0, self.T + 0.1)
            elif not threshold_met and my_prev_coop:
                self.T = max(0.0, self.T - 0.3)
            elif threshold_met and (not my_prev_coop):
                pass
            elif not threshold_met and (not my_prev_coop):
                self.T = max(0.0, self.T - 0.1)
            if not threshold_met:
                defectors = 0
                for opp_i in range(self.n - 1):
                    if not history.opponent_actions[prev_round, opp_i]:
                        defectors += 1
                self.T = max(0.0, self.T - 0.05 * defectors)
            if threshold_met and my_prev_coop:
                self.T = min(1.0, self.T + 0.05)
        if prev_round >= 0:
            opp_coop = history.opponent_actions[prev_round].sum()
            my_prev_coop = history.my_actions[prev_round]
            C_count = opp_coop + (1 if my_prev_coop else 0)
        else:
            return Action.C
        cooperation_critical = C_count == self.m and my_prev_coop
        if cooperation_critical:
            return Action.C
        if self.T > 0.7 and C_count >= self.m:
            return Action.C
        if self.T <= 0.4:
            if C_count >= self.m + 1:
                return Action.D
            else:
                return Action.C
        if 0.4 < self.T <= 0.7:
            if random.random() < self.T:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_COOPERATIVE_88(BaseStrategy):
    """
    Gradual Reciprocity with Threshold Stability (GRTS) strategy for the Collective Risk Dilemma.
    Cooperates initially, then selectively cooperates with players who reliably cooperate enough (>= alpha fraction).
    Tries to maintain a stable cooperation core of size at least m to secure the collective reward k.
    Uses probabilistic cooperation near the threshold to foster cooperation clusters.
    Adopts cautious optimism in the final round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.alpha = 0.5
        self.beta = 0.5

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game.n_players
        m = self.game.m
        r = self.game.n_rounds
        if history is None:
            return Action.C
        t = history.round_number
        next_round = t + 1
        coop_counts = history.opponent_actions.sum(axis=0)
        freq = coop_counts / t
        RC_opponents = [j for j, f in enumerate(freq) if f >= self.alpha]
        size_core = len(RC_opponents) + 1
        if next_round == 1:
            return Action.C
        elif next_round < r:
            if size_core >= m:
                return Action.C
            elif size_core == m - 1:
                p = (next_round - 1) / r
                if random.random() < p:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
        elif size_core >= m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_89(BaseStrategy):
    """
    Cooperative Strategy for the Collective Risk Dilemma.

    This strategy aims to maintain cooperation so that the collective threshold 'm' of cooperators
    is met each round and all players receive the reward 'k'.
    It uses a three-state machine:
    - Cooperating: cooperate if last round met threshold; else punish defecting by defecting once.
    - Punishing: defect one round after failure, then attempt to rebuild cooperation by cooperating.
    - AttemptRebuild: after one round of defection (punishment), cooperate to try restoring cooperation.
    On last round: cooperate if group cooperated successfully in at least half previous rounds,
    else defect to avoid exploitation since no future rounds remain.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.state = 'Cooperating'

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game.n_players
        r = self.game.n_rounds
        m = self.game.m
        if history is None or history.round_number == 0:
            self.state = 'Cooperating'
            return Action.C
        t = history.round_number
        coop_counts = []
        for round_idx in range(t):
            my_c = 1 if history.my_actions[round_idx] else 0
            opp_c = sum(history.opponent_actions[round_idx])
            coop_counts.append(my_c + opp_c)
        current_round = t + 1
        if current_round == r:
            successes = sum((1 for c in coop_counts if c >= m))
            if successes * 2 >= len(coop_counts):
                self.state = None
                return Action.C
            else:
                self.state = None
                return Action.D
        last_coop_count = coop_counts[-1] if coop_counts else 0
        if self.state == 'Cooperating':
            if last_coop_count >= m:
                action = Action.C
                next_state = 'Cooperating'
            else:
                action = Action.D
                next_state = 'AttemptRebuild'
        elif self.state == 'AttemptRebuild':
            action = Action.C
            next_state = 'Cooperating'
        else:
            action = Action.C
            next_state = 'Cooperating'
        self.state = next_state
        return action

class Strategy_COOPERATIVE_90(BaseStrategy):
    """
    Conditional Reciprocal Cooperation with Threshold Assurance for Collective Risk Dilemma.
    
    Starts cooperating to build trust.  
    In last round always defects to avoid exploitation.  
    Otherwise conditions on previous round's number of cooperators and own last action:
    - If threshold met previously (C_prev >= m), cooperate.
    - If threshold failed and I cooperated, retaliate by defecting.
    - If threshold failed and I defected, forgive by cooperating.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number
        next_round = t + 1
        rounds_left = self.r - next_round + 1
        if next_round == 1:
            return Action.C
        if rounds_left == 1:
            return Action.D
        last_round_opponent_coop = history.opponent_actions[t - 1]
        my_last_action = history.my_actions[t - 1]
        cooperators_prev = int(my_last_action) + int(last_round_opponent_coop.sum())
        if cooperators_prev >= self.m:
            return Action.C
        elif my_last_action == True:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_91(BaseStrategy):
    """
    Conditional Conditional Cooperation with Forgiveness (3C-F) for Collective Risk Dilemma.

    Starts cooperating to build trust. Continues cooperating if cooperation threshold m
    was met in previous round. If threshold not met, defects if previously cooperating 
    (punishment), but forgives by cooperating if previously defecting.
    Always defects in last round to avoid exploitation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        prev_round = t - 1
        opp_coop_count = history.opponent_actions[prev_round - 1].sum()
        my_prev_coop = history.my_actions[prev_round - 1]
        coop_prev = opp_coop_count + (1 if my_prev_coop else 0)
        if coop_prev >= self.m:
            return Action.C
        elif not my_prev_coop:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_92(BaseStrategy):
    """
    Cooperative strategy for the Collective Risk Dilemma.
    
    - Start cooperating.
    - Track group cooperation each round.
    - If cooperation threshold met >= 80% of previous rounds, keep cooperating.
    - If exploited last round (cooperated but no reward), defect to prevent loss.
    - If cooperation unstable, use recent rounds (window=3) minimum cooperators:
      if stable (>=m), cooperate, else defect.
    - Always defect on final round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        rounds_played = history.round_number
        coop_counts = []
        for rnd in range(rounds_played):
            self_c = 1 if history.my_actions[rnd] else 0
            opp_c = sum(history.opponent_actions[rnd])
            coop_counts.append(self_c + opp_c)
        coop_counts_array = coop_counts
        coop_threshold_met_rounds = sum((1 for c in coop_counts_array if c >= self.m))
        coop_threshold_met_ratio = coop_threshold_met_rounds / rounds_played if rounds_played > 0 else 0.0
        self_last_action = history.my_actions[-1]
        last_round_cooperators = coop_counts_array[-1]
        exploited = self_last_action and last_round_cooperators < self.m
        if exploited:
            return Action.D
        if coop_threshold_met_ratio >= 0.8:
            return Action.C
        window = min(3, rounds_played)
        recent_min_coop = min(coop_counts_array[-window:])
        if recent_min_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_93(BaseStrategy):
    """
    Threshold-Trigger Cooperation strategy for Collective Risk Dilemma.

    Starts cooperating to signal trust. In intermediate rounds, if the group met the cooperation threshold,
    cooperators continue to cooperate, defectors who had defected previously defect again if the group reward 
    was still obtained, else switch to cooperate to help restore cooperation.
    If threshold failed, defect to punish free-riders and avoid exploitation.
    In final round, cooperate only if threshold was met in previous round; else defect.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game.n_players
        r = self.game.n_rounds
        m = self.game.m
        k = self.game.k
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number
        last_round_idx = t - 1
        my_last_action = history.my_actions[last_round_idx]
        opp_last_actions = history.opponent_actions[last_round_idx]
        all_last_actions = [my_last_action] + list(opp_last_actions)
        numC = sum(all_last_actions)
        all_last_payoffs = [history.my_payoffs[last_round_idx]] + list(history.opponent_payoffs[last_round_idx])
        if t < r:
            if numC >= m:
                if my_last_action:
                    return Action.C
                else:
                    group_reward_received = any((p >= 1 + k for p in all_last_payoffs))
                    if group_reward_received:
                        return Action.D
                    else:
                        return Action.C
            else:
                return Action.D
        elif numC >= m:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_94(BaseStrategy):
    """
    Conditional Trigger Cooperate with Forgiveness (CTCF) strategy for the Collective Risk Dilemma.

    - Cooperates initially.
    - Continues cooperating so long as the cooperation threshold was met in the previous round.
    - Punishes by defecting in rounds immediately following rounds where threshold was not met.
    - Forgives by returning to cooperation if threshold met.
    - Always cooperates in the last round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punishment_active = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        if history is None:
            self.punishment_active = False
            return Action.C
        t = history.round_number + 1
        if t == r:
            self.punishment_active = False
            return Action.C
        prev_round = t - 2
        opponent_coop_prev = sum(history.opponent_actions[prev_round])
        my_coop_prev = history.my_actions[prev_round]
        cooperators_prev = opponent_coop_prev + (1 if my_coop_prev else 0)
        if cooperators_prev >= m:
            self.punishment_active = False
            return Action.C
        else:
            self.punishment_active = True
            return Action.D

class Strategy_COOPERATIVE_95(BaseStrategy):
    """
    Generous Conditional Cooperator with Forgiveness for the Collective Risk Dilemma.

    - Round 1: Cooperate.
    - Rounds 2 to r-1:
      - If last round's cooperation count >= m, cooperate.
      - If < m and not currently punishing, defect (start punishment).
      - If punishing and < m last round, forgive by cooperating (end punishment).
      - If punishing and last round had >= m cooperators, cooperate (end punishment).
    - Final round: Defect.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punishment = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        if history is None or history.round_number == 0:
            self.punishment = False
            return Action.C
        t = history.round_number
        current_round = t + 1
        if current_round == r:
            return Action.D
        prev_round_idx = t - 1
        my_prev = history.my_actions[prev_round_idx]
        opponents_prev = history.opponent_actions[prev_round_idx]
        coop_count_last = sum(opponents_prev) + (1 if my_prev else 0)
        if not self.punishment:
            if coop_count_last >= m:
                return Action.C
            else:
                self.punishment = True
                return Action.D
        elif coop_count_last >= m:
            self.punishment = False
            return Action.C
        else:
            self.punishment = False
            return Action.C

class Strategy_COOPERATIVE_96(BaseStrategy):
    """
    Conditional Reciprocity with Graduated Punishment for the Collective Risk Dilemma.

    Starts with cooperation to attempt reaching the threshold.
    Maintains cooperation if group succeeded in cooperating last round.
    Uses conditional defection as proportional punishment to deter free-riding.
    Attempts quick recovery of cooperation after failures.
    Defects in the last round to maximize individual payoff.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number
        n = self.n
        r = self.r
        m = self.m
        prev_idx = t - 1
        prev_actions_opponents = history.opponent_actions[prev_idx]
        prev_my_action = history.my_actions[prev_idx]
        n_coop_prev = int(prev_my_action) + prev_actions_opponents.sum()
        if t > 1:
            prev2_idx = t - 2
            prev2_actions_opponents = history.opponent_actions[prev2_idx]
            prev2_my_action = history.my_actions[prev2_idx]
            n_coop_prev2 = int(prev2_my_action) + prev2_actions_opponents.sum()
        else:
            n_coop_prev2 = None
        if t == r:
            return Action.D
        if n_coop_prev >= m:
            if prev_my_action is True:
                return Action.C
            else:
                return Action.C
        if n_coop_prev2 is not None and n_coop_prev2 >= m:
            return Action.C
        if prev_my_action is True:
            return Action.D
        else:
            return Action.D

class Strategy_COOPERATIVE_97(BaseStrategy):
    """
    Reciprocal Threshold Cooperation for Collective Risk Dilemma.

    - First round: Cooperate.
    - From round 2 to r-1: Cooperate if total cooperators last round ≥ m,
      else punish defectors once by defecting if self cooperated last round,
      otherwise try to restore cooperation by cooperating.
    - Last round: Cooperate only if last round had ≥ m cooperators, else defect.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.g = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.g.n_players
        r = self.g.n_rounds
        m = self.g.m
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number
        last_round = t - 1
        opponent_cooperators = history.opponent_actions[last_round].sum()
        self_cooperated_last = history.my_actions[last_round]
        total_cooperators = opponent_cooperators + (1 if self_cooperated_last else 0)
        if t < r:
            if total_cooperators >= m:
                return Action.C
            elif self_cooperated_last:
                return Action.D
            else:
                return Action.C
        elif total_cooperators >= m:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_98(BaseStrategy):
    """
    Cooperative strategy for the Collective Risk Dilemma.
    - Always cooperate in first round to signal trust.
    - From round 2 to round r-1, cooperate only if previous round had at least m cooperators total (including self).
    - Defect otherwise to signal punishment and encourage cooperation.
    - Always cooperate in final round to maximize group payoff with no future retaliation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number + 1
        if t == r:
            return Action.C
        prev_round_idx = t - 2
        self_last_action = history.my_actions[prev_round_idx]
        self_cooperated = 1 if self_last_action else 0
        opp_coop_count = history.opponent_actions[prev_round_idx].sum()
        coop_count = self_cooperated + opp_coop_count
        if coop_count >= m:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_99(BaseStrategy):
    """
    Conditional Trust and Reinforcement Cooperation (CTRC) strategy for the
    Collective Risk Dilemma.
    
    Summary:
    - Round 1: cooperate to signal willingness.
    - Intermediate rounds: cooperate if prior round had ≥ m-1 cooperators; 
      else defect as punishment, with forgiveness after consecutive defects.
    - Last round: cooperate only if prior round cooperation ≥ m-1, else defect
      to avoid costly exploitation.
    - Permanently defect if threshold not met for 2+ consecutive rounds.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self.consecutive_defect_count = 0
        self.consecutive_threshold_fail = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.consecutive_defect_count = 0
            self.consecutive_threshold_fail = 0
            return Action.C
        t = history.round_number + 1
        last_round_idx = t - 2
        if last_round_idx < 0:
            self.consecutive_defect_count = 0
            self.consecutive_threshold_fail = 0
            return Action.C
        last_opponent_actions = history.opponent_actions[last_round_idx]
        n_opp_coop = sum(last_opponent_actions)
        my_last_action = history.my_actions[last_round_idx]
        n_cooperators_last = n_opp_coop + (1 if my_last_action else 0)
        if n_cooperators_last < self.m:
            self.consecutive_threshold_fail += 1
        else:
            self.consecutive_threshold_fail = 0
        if my_last_action == False:
            self.consecutive_defect_count += 1
        else:
            self.consecutive_defect_count = 0
        if self.consecutive_threshold_fail >= 2:
            return Action.D
        if t == 1:
            self.consecutive_defect_count = 0
            return Action.C
        if t == self.r:
            if n_cooperators_last >= self.m - 1:
                return Action.C
            else:
                return Action.D
        if n_cooperators_last >= self.m:
            self.consecutive_defect_count = 0
            return Action.C
        if n_cooperators_last == self.m - 1:
            self.consecutive_defect_count = 0
            return Action.C
        if self.consecutive_defect_count >= 2:
            self.consecutive_defect_count = 0
            return Action.C
        self.consecutive_defect_count += 1
        return Action.D

class Strategy_COOPERATIVE_100(BaseStrategy):
    """
    Cooperative Strategy: Conditional Reciprocity with Forgiveness for Collective Risk Dilemma.
    
    - Round 1: Cooperate
    - Rounds 2..r-1: Cooperate if previous round cooperation count ≥ m,
      else defect to punish defectors, but if self defected last round and cooperation restored,
      forgive by cooperating.
    - Last round: Always cooperate.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.C
        last_round = history.round_number - 1
        prev_cooperators = history.my_actions[last_round] + sum(history.opponent_actions[last_round])
        cooperation_sufficient = prev_cooperators >= self.m
        self_defected_last_round = not history.my_actions[last_round]
        if current_round == 1:
            return Action.C
        if cooperation_sufficient:
            return Action.C
        elif self_defected_last_round:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_101(BaseStrategy):
    """
    Conditional Cooperative Reciprocity (CCR) strategy for the
    repeated Collective Risk Dilemma game.

    - Start cooperating in round 1.
    - Track opponents' cooperation counts each round.
    - Punish by defecting for punish_rounds if cooperation threshold not met.
    - Forgive slight shortfalls by cooperating if cooperators >= m - 1.
    - Cooperate unconditionally in the last endgame rounds to maximize payoff.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self.forgiveness_margin = 1
        self.punish_rounds = 2
        self.endgame_rounds = max(1, self.r // 5)
        self.endgame_start = self.r - self.endgame_rounds + 1
        self.punishment_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punishment_counter = 0
            return Action.C
        t = history.round_number
        current_round = t + 1
        if current_round >= self.endgame_start:
            self.punishment_counter = 0
            return Action.C
        if self.punishment_counter > 0:
            self.punishment_counter -= 1
            return Action.D
        last_round_idx = t - 1
        if last_round_idx < 0:
            return Action.C
        my_coop_last_round = history.my_actions[last_round_idx]
        opp_coop_count_last_round = sum(history.opponent_actions[last_round_idx])
        total_coop_last_round = opp_coop_count_last_round + (1 if my_coop_last_round else 0)
        if total_coop_last_round >= self.m:
            return Action.C
        if total_coop_last_round >= self.m - self.forgiveness_margin:
            return Action.C
        self.punishment_counter = self.punish_rounds
        self.punishment_counter -= 1
        return Action.D

class Strategy_COOPERATIVE_102(BaseStrategy):
    """
    Cooperative Strategy: Conditional Reciprocity with Threshold Support
    
    This strategy promotes cooperation in the Collective Risk Dilemma by:
    - Cooperating on the first round to establish goodwill.
    - Monitoring the number of cooperators last round.
    - Cooperating if threshold (m) met or nearly met (m-1) last round.
    - Defecting otherwise to punish defection and signal seriousness.
    - Defecting on the last round to avoid exploitation without future punishment.
    - Forgiving past defections if group cooperation recovers.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        if history is None:
            return Action.C
        t = history.round_number
        next_round = t + 1
        if next_round == 1:
            return Action.C
        if next_round == r:
            return Action.D
        last_round_opponent_coop = history.opponent_actions[t - 1].sum()
        last_round_own_coop = 1 if history.my_actions[t - 1] else 0
        last_round_cooperators = last_round_own_coop + last_round_opponent_coop
        if last_round_cooperators >= m:
            return Action.C
        if last_round_cooperators == m - 1:
            return Action.C
        return Action.D

class Strategy_COOPERATIVE_103(BaseStrategy):
    """
    Conditional Reciprocity with Threshold Monitoring for the Collective Risk Dilemma.
    
    Starts cooperating to signal intent, then conditions cooperation on past rounds'
    cooperation levels and own past actions. Punishes low cooperation phases by defecting,
    but forgives occasional setbacks. In final round, defects unless confident that
    cooperation threshold is historically met overall.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.defect_tolerance = 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game.n_players
        r = self.game.n_rounds
        m = self.game.m
        k = self.game.k
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number
        coop_counts = []
        for round_idx in range(t):
            self_coop = history.my_actions[round_idx]
            opp_coops = history.opponent_actions[round_idx].sum()
            coop_counts.append(int(self_coop) + int(opp_coops))
        prev_coop = coop_counts[-1] if coop_counts else 0
        my_prev_action = history.my_actions[-1] if t >= 1 else True
        avg_coop = sum(coop_counts) / t if t > 0 else 0.0
        recent_coop_history = coop_counts[-self.defect_tolerance:] if t >= self.defect_tolerance else coop_counts
        incentive_high = k > 2.0
        incentive_low = k <= 1.1
        threshold_near_all = m >= n - 1
        if t == r:
            coop_req = m + 0.5 if threshold_near_all else m
            if avg_coop >= coop_req:
                return Action.C
            else:
                return Action.D
        if prev_coop >= m:
            if my_prev_action == Action.C or my_prev_action is True:
                return Action.C
            else:
                return Action.C
        elif prev_coop >= m - 1:
            return Action.C
        elif any((coop < m for coop in recent_coop_history)):
            if incentive_high and prev_coop < m - 2:
                if len(coop_counts) >= 2 and coop_counts[-2] >= m and (prev_coop < m - 1):
                    return Action.C
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_104(BaseStrategy):
    """
    Conditional Cooperative Trust strategy for the Collective Risk Dilemma.
    
    This strategy:
    - Starts cooperating to signal willingness.
    - Sustains cooperation if the cooperation threshold was met last round.
    - If cooperation failed last round (< m cooperators), punishes with one round of defection.
    - After punishing once, immediately forgives and returns to cooperation.
    - Always cooperates in the first and last rounds.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punishment_flag = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        if history is None:
            self.punishment_flag = False
            return Action.C
        current_round = history.round_number + 1
        if current_round == r:
            self.punishment_flag = False
            return Action.C
        last_round_idx = history.round_number - 1
        last_round_cooperators = int(history.my_actions[last_round_idx]) + int(history.opponent_actions[last_round_idx].sum())
        if self.punishment_flag:
            self.punishment_flag = False
            return Action.D
        if last_round_cooperators >= m:
            return Action.C
        else:
            self.punishment_flag = True
            return Action.C

class Strategy_COOPERATIVE_105(BaseStrategy):
    """
    Minimal Threshold Cooperate-and-Punish (MTCP) Strategy for Collective Risk Dilemma.

    Summary:
    - Cooperate on first round to signal willingness.
    - For rounds 2 to r-1:
        * If last round the number of cooperators (including self) >= m, cooperate.
        * Else defect to punish undercooperation.
    - In last round r, defect to maximize payoff with no future incentives.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        if current_round == 1:
            return Action.C
        last_round_idx = current_round - 2
        my_last_action = history.my_actions[last_round_idx]
        opp_last_actions = history.opponent_actions[last_round_idx]
        coop_count = opp_last_actions.sum() + (1 if my_last_action else 0)
        if coop_count >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_106(BaseStrategy):
    """
    Conditional Collective Cooperation:
    - Cooperate initially to build trust.
    - Continue cooperating if group cooperation meets or nearly meets threshold.
    - Defect to punish free-riders when cooperation is insufficient.
    - Forgive by returning to cooperation if group recovers after punishment.
    - Defect on last round to maximize individual payoff.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self.punishment = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.n
        r = self.r
        m = self.m
        if history is None:
            self.punishment = False
            return Action.C
        current_round = history.round_number + 1
        if current_round == r:
            self.punishment = False
            return Action.D
        past_rounds_count = current_round - 1
        C_count = []
        for t in range(past_rounds_count):
            coop_in_round = int(history.my_actions[t]) + int(history.opponent_actions[t].sum())
            C_count.append(coop_in_round)
        last_round_cooperators = C_count[-1] if C_count else 0
        avg_cooperators = sum(C_count) / past_rounds_count if past_rounds_count > 0 else 0.0
        my_prev_action = history.my_actions[-1]
        cooperate_threshold = m
        near_threshold = m - 1
        if m >= n - 1:
            near_threshold = m
        if last_round_cooperators >= cooperate_threshold and avg_cooperators >= near_threshold:
            if self.punishment:
                self.punishment = False
                return Action.C
            else:
                return Action.C
        else:
            self.punishment = True
            return Action.D

class Strategy_COOPERATIVE_107(BaseStrategy):
    """
    Threshold-Triggered Cooperative Reciprocity for Collective Risk Dilemma.

    - Round 1: Cooperate to establish cooperation.
    - Intermediate rounds: Cooperate if previous round's total cooperation count >= m, else defect.
    - Last round: Cooperate if previous round's cooperation count >= m, else defect.

    Uses only immediate previous round's cooperation count (including self) to decide.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number + 1
        prev_round_idx = t - 2
        my_prev_action = history.my_actions[prev_round_idx]
        opponents_prev_actions = history.opponent_actions[prev_round_idx]
        coop_count_prev = (1 if my_prev_action else 0) + opponents_prev_actions.sum()
        if t == self.r:
            if coop_count_prev >= self.m:
                return Action.C
            else:
                return Action.D
        if coop_count_prev >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_108(BaseStrategy):
    """
    Conditional Cooperation with Forgiveness and Endgame Adjustment for the Collective Risk Dilemma.

    - Round 1: Cooperate to signal willingness.
    - Rounds 2 to r-1: Cooperate if last round's total cooperation (including self) ≥ m.
      Otherwise defect one round as punishment.
      Forgive and resume cooperation if cooperation recovers.
    - Round r: Defect unconditionally (endgame defection).
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_num = history.round_number
        current_round = round_num + 1
        if current_round == self.r:
            return Action.D
        my_last_action = history.my_actions[-1]
        coop_opp_last = sum(history.opponent_actions[-1])
        total_coop_last = (1 if my_last_action else 0) + coop_opp_last
        if total_coop_last >= self.m:
            return Action.C
        if round_num >= 2:
            coop_opp_two_ago = sum(history.opponent_actions[-2])
            my_two_ago = history.my_actions[-2]
            total_coop_two_ago = (1 if my_two_ago else 0) + coop_opp_two_ago
            if total_coop_two_ago < self.m and total_coop_last >= self.m:
                return Action.C
            if total_coop_two_ago < self.m and total_coop_last < self.m:
                return Action.D
        return Action.D

class Strategy_COOPERATIVE_109(BaseStrategy):
    """
    Responsive Threshold Cooperation (RTC) for Collective Risk Dilemma.

    Starts cooperating to build trust. Tracks others' cooperation last round.
    Cooperates if threshold m met otherwise defects as brief punishment.
    Forgives quickly to avoid retaliation cycles.
    In last round, defects if previous cooperation below threshold to avoid loss,
    otherwise cooperates to maintain mutual payoff.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.m = self.game.m
        self.n = self.game.n_players
        self.r = self.game.n_rounds
        self.punishment_active = False
        self.punishment_rounds_left = 0
        self.consecutive_below_threshold = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punishment_active = False
            self.punishment_rounds_left = 0
            self.consecutive_below_threshold = 0
            return Action.C
        t = history.round_number + 1
        if t == 1:
            return Action.C
        prev_round_idx = t - 2
        opp_coop_last = 0
        if prev_round_idx >= 0:
            opp_coop_last = history.opponent_actions[prev_round_idx].sum()
        own_coop_last = False
        if prev_round_idx >= 0 and prev_round_idx < len(history.my_actions):
            own_coop_last = history.my_actions[prev_round_idx]
        total_coop_last = opp_coop_last + (1 if own_coop_last else 0)
        if t == self.r:
            if total_coop_last < self.m:
                return Action.D
            else:
                return Action.C
        threshold_broken = total_coop_last < self.m
        if self.punishment_active:
            action = Action.D
            self.punishment_rounds_left -= 1
            if self.punishment_rounds_left == 0:
                self.punishment_active = False
            return action
        if threshold_broken:
            self.consecutive_below_threshold += 1
            if self.consecutive_below_threshold >= 3:
                return Action.D
            self.punishment_active = True
            self.punishment_rounds_left = 1
            return Action.D
        else:
            self.consecutive_below_threshold = 0
            return Action.C

class Strategy_COOPERATIVE_110(BaseStrategy):
    """
    Conditional Trust and Threshold Cooperation (CTTC) for Collective Risk Dilemma.

    - Start cooperating to build trust.
    - Track opponents' cooperation frequency to maintain a trust score.
    - Cooperate only if expecting at least m cooperators (including self).
    - Punish defectors by defecting against them (exclude low trust players).
    - In final round, cooperate only if threshold likely reached.
    """
    TOLERANCE = 0.8

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.n = self.game.n_players
        self.r = self.game.n_rounds
        self.m = self.game.m
        self.k = self.game.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number
        if t == 0:
            return Action.C
        coop_counts = history.opponent_actions[:t].sum(axis=0)
        rounds_played = t
        TrustScore = coop_counts / rounds_played
        CooperatorSet = set((i for i, score in enumerate(TrustScore) if score >= self.TOLERANCE))
        EstimatedCooperators = len(CooperatorSet) + 1
        if t < self.r:
            if EstimatedCooperators >= self.m:
                return Action.C
            else:
                return Action.D
        elif EstimatedCooperators >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_111(BaseStrategy):
    """
    Cooperative strategy for Collective Risk Dilemma.
    - Starts cooperating to build trust.
    - Punishes persistent defection by defecting for 1 round if cooperation threshold not met while cooperating.
    - Forgives and returns to cooperation if cooperation threshold recovers.
    - In final round, cooperates only if last round had enough cooperators to expect reward.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self._punish_rounds = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        if history is None:
            self._punish_rounds = 0
            return Action.C
        t = history.round_number + 1
        last_round_idx = t - 2
        if t == 1:
            return Action.C
        coop_self_prev = history.my_actions[last_round_idx]
        coop_opp_prev = history.opponent_actions[last_round_idx].sum()
        coop_count_prev = coop_opp_prev + (1 if coop_self_prev else 0)
        if self._punish_rounds > 0:
            self._punish_rounds -= 1
            return Action.D
        if t == r:
            if coop_count_prev >= m:
                return Action.C
            else:
                return Action.D
        if coop_count_prev >= m:
            return Action.C
        if coop_self_prev:
            self._punish_rounds = 1
            return Action.D
        else:
            return Action.D

class Strategy_COOPERATIVE_112(BaseStrategy):
    """
    Conditional Coordinated Cooperation (CCC) strategy for the Collective Risk Dilemma.

    This strategy starts by cooperating to signal goodwill. For rounds 2 to r-1, it uses the previous 
    round's cooperation count to decide: if threshold m was met, cooperate; if not, punish by defecting once,
    then forgive by cooperating next round after defecting. Always cooperates in the last round to maintain trust.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        if history is None:
            return Action.C
        t = history.round_number
        current_round = t + 1
        if current_round == r:
            return Action.C
        prev_round_idx = t - 1
        if prev_round_idx >= 0:
            prev_coop_count = int(history.my_actions[prev_round_idx]) + int(history.opponent_actions[prev_round_idx].sum())
        else:
            prev_coop_count = 0
        self_defected_last_round = prev_round_idx >= 0 and (not history.my_actions[prev_round_idx])
        if prev_coop_count >= m:
            return Action.C
        elif self_defected_last_round:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_113(BaseStrategy):
    """
    Conditional Reciprocity with Threshold Coordination strategy for Collective Risk Dilemma.

    Begins with cooperation to build trust, and adapts based on previous round cooperation levels.
    Strives to maintain minimal cooperation threshold (m) each round.
    Exploits free-riding opportunity if threshold exceeded.
    Defects in final round to avoid exploitation due to lack of future incentives.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number + 1
        prev_round_idx = history.round_number - 1
        my_prev = history.my_actions[prev_round_idx]
        opp_prev = history.opponent_actions[prev_round_idx]
        num_cooperators = int(opp_prev.sum() + (1 if my_prev else 0))
        if t == self.r:
            return Action.D
        if t == self.r - 1:
            if num_cooperators >= self.m:
                return Action.C
            else:
                return Action.D
        prev_cooperator = my_prev
        k_val = self.k
        if num_cooperators == 0:
            return Action.D
        if num_cooperators >= self.m and prev_cooperator:
            if num_cooperators == self.m:
                return Action.C
            else:
                return Action.D
        elif num_cooperators == self.m - 1:
            return Action.C
        elif num_cooperators < self.m - 1:
            if k_val > 1.5:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_114(BaseStrategy):
    """
    Conditional Reciprocity with Risk Thresholding for Collective Risk Dilemma.
    
    Starts cooperating to signal willingness. On subsequent rounds (except last),
    it cooperates if the count of cooperators last round met or exceeded threshold m.
    If threshold not met, punishes by defecting once, then tries cooperating again.
    In the last round, defects to avoid exploitation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punishmentFlag = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        n_rounds = self.game_description.n_rounds
        m = self.game_description.m
        if history is None:
            self.punishmentFlag = False
            return Action.C
        t = history.round_number
        current_round = t + 1
        if current_round == 1:
            self.punishmentFlag = False
            return Action.C
        if current_round == n_rounds:
            self.punishmentFlag = False
            return Action.D
        last_round_idx = t - 1
        my_last_action = history.my_actions[last_round_idx]
        opp_last_round = history.opponent_actions[last_round_idx]
        count_cooperators_last = opp_last_round.sum() + (1 if my_last_action else 0)
        if self.punishmentFlag:
            self.punishmentFlag = False
            return Action.C
        if count_cooperators_last >= m:
            return Action.C
        self.punishmentFlag = True
        return Action.D

class Strategy_COOPERATIVE_115(BaseStrategy):
    """
    Conditional Threshold Reciprocity strategy for the Collective Risk Dilemma.

    Summary:
    - Round 1: Cooperate to seed trust.
    - Intermediate rounds (2 to r-1):
       * Compute cooperation ratios for all players.
       * Identify trusted cooperators with ratio ≥ theta (0.7).
       * If enough trusted cooperators (≥ m):
           - Defect if own ratio ≥ theta (free ride).
           - Else cooperate (maintain trustworthiness).
       * Else cooperate to help meet threshold and punish defectors.
    - Last round r: Defect (endgame, no incentive to cooperate).
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self.theta = 0.7

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number
        current_round = t + 1
        if current_round == self.r:
            return Action.D
        coopCounts = [0] * self.n
        coopCounts_self = history.my_actions.sum()
        coopCounts_self = int(coopCounts_self)
        self_index = 0
        coopCounts[self_index] = coopCounts_self
        for opp_j in range(self.n - 1):
            coopCounts[opp_j + 1] = int(history.opponent_actions[:, opp_j].sum())
        if t == 0:
            coopRatios = [0.0] * self.n
        else:
            coopRatios = [count / t for count in coopCounts]
        trusted = [j for j, ratio in enumerate(coopRatios) if ratio >= self.theta]
        m_trusted = len(trusted)
        last_round_self_action = history.my_actions[-1]
        last_round_coops = int(last_round_self_action) + int(history.opponent_actions[-1, :].sum())
        self_ratio = coopRatios[self_index]
        if m_trusted >= self.m:
            if self_ratio < self.theta:
                return Action.C
            else:
                return Action.D
        if m_trusted == 0:
            return Action.C
        return Action.C

class Strategy_COOPERATIVE_116(BaseStrategy):
    """
    Cooperative Strategy for Collective Risk Dilemma.

    Starts cooperative to signal trust.
    Sustains cooperation if threshold met last round.
    Punishes by defecting if threshold not met and was cooperating (or defecting).
    Forgives if cooperation returns in recent rounds.
    Last round defects unless confident threshold met without own cooperation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self._cooperative_mode = True

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        if history is None:
            self._cooperative_mode = True
            return Action.C
        t = history.round_number
        C_count = []
        for round_idx in range(t):
            coop_opponents = history.opponent_actions[round_idx].sum()
            my_coop = 1 if history.my_actions[round_idx] else 0
            C_count.append(coop_opponents + my_coop)
        current_round = t + 1
        last_C_count = C_count[-1] if C_count else 0
        if current_round == 1:
            self._cooperative_mode = True
            return Action.C
        if current_round == r:
            if last_C_count >= m:
                action = Action.D
            else:
                action = Action.D
            return action
        if last_C_count >= m:
            action = Action.C
            self._cooperative_mode = True
        else:
            my_last_action = history.my_actions[-1]
            if self._cooperative_mode:
                action = Action.D
                self._cooperative_mode = False
            else:
                start_check = max(0, t - 3)
                recent_C_counts = C_count[start_check:]
                threshold_met_recently = any((cc >= m for cc in recent_C_counts))
                if threshold_met_recently:
                    action = Action.C
                    self._cooperative_mode = True
                else:
                    action = Action.D
        return action

class Strategy_COOPERATIVE_117(BaseStrategy):
    """
    Conditional Threshold Cooperation with Forgiveness (CTCF) for Collective Risk Dilemma.

    Starts cooperating in round 1. In intermediate rounds (2 to r-1), cooperates if the number
    of cooperators last round met the threshold (m), else forgives one failure by cooperating once.
    Defects on consecutive failures to sustain cooperation discipline. Always defects in the last round
    to maximize individual payoff.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        if t == 1:
            return Action.C
        if t == self.r:
            return Action.D
        prev_round_idx = t - 2
        prev2_round_idx = t - 3
        if prev_round_idx < 0:
            prev_count = 0
        else:
            self_coop_prev = bool(history.my_actions[prev_round_idx])
            opp_coop_prev = history.opponent_actions[prev_round_idx, :]
            prev_count = int(self_coop_prev) + int(opp_coop_prev.sum())
        if prev_count >= self.m:
            return Action.C
        if t == 2:
            return Action.C
        if prev2_round_idx < 0:
            prev2_count = 0
        else:
            self_coop_prev2 = bool(history.my_actions[prev2_round_idx])
            opp_coop_prev2 = history.opponent_actions[prev2_round_idx, :]
            prev2_count = int(self_coop_prev2) + int(opp_coop_prev2.sum())
        if prev2_count >= self.m:
            return Action.C
        return Action.D

class Strategy_COOPERATIVE_118(BaseStrategy):
    """
    Cooperative Strategy for the Collective Risk Dilemma:
    - Cooperate on round 1 to set cooperative norm.
    - Maintain cooperation if threshold met.
    - Defect to exploit if threshold met with slack but played D last round.
    - If threshold failed, cooperate if cooperation trend increasing/steady, else defect.
    - In last round defect if threshold met with surplus cooperators, else cooperate if cooperation likely.
    - If cooperation fails multiple rounds consecutively, switch to persistent defection.
    - If almost no cooperation first two rounds, switch early to defection.
    - If threshold close to all players (m = n-1), be more cautious defecting, maintain cooperation longer.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.persistent_defect = False
        self.failed_threshold_streak = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game.n_players
        r = self.game.n_rounds
        m = self.game.m
        if history is None:
            self.persistent_defect = False
            self.failed_threshold_streak = 0
            return Action.C
        t = history.round_number
        if t == 0:
            prev_cooperators = sum(history.opponent_actions[0]) + (history.my_actions[0].item() == True)
            prev_round_success = prev_cooperators >= m
            prev_my_action = history.my_actions[0]
        else:
            prev_cooperators = sum(history.opponent_actions[t - 1]) + (history.my_actions[t - 1].item() == True)
            prev_round_success = prev_cooperators >= m
            prev_my_action = history.my_actions[t - 1]
        consecutive_fail = 0
        max_lookback = min(t, 4)
        for i in range(1, max_lookback + 1):
            round_cooperators = sum(history.opponent_actions[t - i]) + (history.my_actions[t - i].item() == True)
            if round_cooperators < m:
                consecutive_fail += 1
            else:
                break
        if consecutive_fail >= 2:
            self.persistent_defect = True
        if t >= 1:
            first_round_coop = sum(history.opponent_actions[0]) + (history.my_actions[0].item() == True)
            second_round_coop = sum(history.opponent_actions[1]) + (history.my_actions[1].item() == True) if t >= 2 else None
            if first_round_coop <= 1 and (second_round_coop is None or second_round_coop <= 1):
                self.persistent_defect = True
        if self.persistent_defect:
            return Action.D
        threshold_is_strict = m >= n - 1
        if t == r - 1:
            if prev_round_success and prev_cooperators > m:
                return Action.D
            else:
                projected_cooperators = self._estimate_next_cooperators(history, m, n)
                if projected_cooperators >= m:
                    return Action.C
                else:
                    return Action.D
        if t >= 1 and t < r - 1:
            if prev_round_success:
                if prev_my_action:
                    return Action.C
                elif prev_cooperators > m:
                    return Action.D if not threshold_is_strict else Action.C
                else:
                    return Action.C
            else:
                recent_trend = self._assess_cooperation_trend(history, m)
                if recent_trend in ('increasing', 'steady'):
                    if prev_my_action and prev_cooperators < m:
                        if recent_trend == 'increasing':
                            return Action.C
                        else:
                            return Action.D
                    else:
                        return Action.C
                else:
                    return Action.D
        return Action.C

    def _assess_cooperation_trend(self, history: PlayerHistory, m: int) -> str:
        """
        Assess recent cooperation trend over last up to 3 rounds.
        Return:
            - "increasing" if cooperators count strictly increases each round
            - "steady" if cooperators count roughly constant (±0)
            - "decreasing" if cooperators count decreases
        """
        t = history.round_number
        if t < 2:
            return 'steady'
        coop_counts = []
        for i in range(max(0, t - 3), t):
            coop = sum(history.opponent_actions[i]) + (history.my_actions[i].item() == True)
            coop_counts.append(coop)
        if len(coop_counts) < 2:
            return 'steady'
        diffs = [coop_counts[i + 1] - coop_counts[i] for i in range(len(coop_counts) - 1)]
        positive = all((d > 0 for d in diffs))
        negative = all((d < 0 for d in diffs))
        if positive:
            return 'increasing'
        elif negative:
            return 'decreasing'
        else:
            max_c = max(coop_counts)
            min_c = min(coop_counts)
            if max_c - min_c <= 1:
                return 'steady'
            return 'decreasing'

    def _estimate_next_cooperators(self, history: PlayerHistory, m: int, n: int) -> int:
        """
        Heuristic estimate of cooperators next round.
        Use last two rounds cooperation average.
        If no history, guess m (threshold).
        """
        t = history.round_number
        if t == 0:
            return m
        coop_last = sum(history.opponent_actions[t - 1]) + (history.my_actions[t - 1].item() == True)
        if t >= 2:
            coop_prev = sum(history.opponent_actions[t - 2]) + (history.my_actions[t - 2].item() == True)
            est = int(round((coop_last + coop_prev) / 2))
            if est < 0:
                est = 0
            if est > n:
                est = n
            return est
        else:
            return coop_last

class Strategy_COOPERATIVE_119(BaseStrategy):
    """
    Threshold-Triggered Conditional Cooperation for the Collective Risk Dilemma.

    - Start cooperating to signal intent.
    - Continue cooperating if at least m cooperators last round.
    - If cooperation threshold failed last round:
       * Defect once as punishment if not punished in previous round.
       * Else revert to cooperation immediately.
    - On last round:
       * Cooperate if threshold met last round.
       * Otherwise defect to maximize payoff exploiting finite horizon.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number
        last_round_idx = t - 1
        coop_prev = 0
        coop_in_opponents_last_round = history.opponent_actions[last_round_idx].sum()
        my_last_action = history.my_actions[last_round_idx]
        coop_prev = coop_in_opponents_last_round + (1 if my_last_action else 0)
        if t < self.r - 1:
            if coop_prev >= self.m:
                return Action.C
            elif my_last_action == False:
                return Action.C
            else:
                return Action.D
        elif coop_prev >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_120(BaseStrategy):
    """
    Conditional Cooperative Reciprocity (CCR) strategy for the Collective Risk Dilemma.
    
    - Round 1: Cooperate to signal cooperative intent.
    - Rounds 2 to r-2: Cooperate if previous round cooperators ≥ m;
      cooperate if cooperators == m-1 and self cooperated last round (forgiveness);
      else defect to punish.
    - Penultimate round (r-1): Defect if previous round cooperation low (< m) to anticipate endgame defection.
    - Last round (r): Cooperate only if last round cooperators ≥ m, else defect.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number
        current_round = t + 1
        if current_round > self.r:
            return Action.D
        if t == 0:
            last_cooperators = 0
            self_cooperated_last = False
        else:
            last_opponent_actions = history.opponent_actions[t - 1]
            last_cooperators = int(sum(last_opponent_actions))
            self_cooperated_last = bool(history.my_actions[t - 1])
            last_cooperators += 1 if self_cooperated_last else 0
        cooperation_history = []
        for past_round in range(t):
            opp_actions = history.opponent_actions[past_round]
            c_count = int(sum(opp_actions)) + (1 if history.my_actions[past_round] else 0)
            cooperation_history.append(c_count)
        r = self.r
        m = self.m
        if current_round < r:
            prior_c = cooperation_history[-2] if len(cooperation_history) >= 2 else None
            just_failed_after_success = prior_c is not None and prior_c >= m and (last_cooperators < m)
            if last_cooperators >= m:
                return Action.C
            elif last_cooperators >= m - 1:
                if self_cooperated_last:
                    return Action.C
                else:
                    return Action.D
            elif current_round == r - 1:
                return Action.D
            else:
                return Action.D
        elif last_cooperators >= m:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_121(BaseStrategy):
    """
    Cooperative strategy for the Collective Risk Dilemma.
    - Start cooperating.
    - Maintain cooperation if others did, else punish defectors by defecting one round.
    - Forgive immediately after punishment.
    - Last round always defect to maximize immediate payoff.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self.forgiveness_rounds = 1
        self.punish_until = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number
        current_round = t + 1
        last_round_idx = t - 1
        last_round_actions = [history.my_actions[last_round_idx]]
        last_round_actions.extend(history.opponent_actions[last_round_idx, :].tolist())
        cooperators_last = sum(last_round_actions)
        defection_occurred = any((not a for a in last_round_actions))
        my_last_action = history.my_actions[last_round_idx]
        threshold_met = cooperators_last >= self.m
        if current_round == self.r:
            return Action.D
        if defection_occurred and threshold_met and my_last_action:
            if self.punish_until < current_round:
                self.punish_until = current_round + self.forgiveness_rounds - 1
        if current_round <= self.punish_until:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_122(BaseStrategy):
    """
    Conditional Reciprocity with Coordinated Cooperation for Collective Risk Dilemma.

    Starts cooperating to signal intent. In rounds 2 to R-1:
      - Continue cooperating if threshold met or nearly met last round.
      - Defect if threshold substantially missed unless forgiving return after recent improvement.
    In final round always cooperate.
    Balances optimism, conditional cooperation, and prudence to foster stable cooperation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.defected_due_to_low_coop = False
        self.cooperation_trend = []

    def __call__(self, history: None | PlayerHistory) -> Action:
        R = self.game_description.n_rounds
        m = self.game_description.m
        n = self.game_description.n_players
        if history is None:
            self.defected_due_to_low_coop = False
            self.cooperation_trend.clear()
            return Action.C
        t = history.round_number
        current_round = t + 1
        prev_round_index = t - 1
        self_c_last = history.my_actions[prev_round_index]
        opp_coop_last = history.opponent_actions[prev_round_index].sum()
        C_prev = opp_coop_last + (1 if self_c_last else 0)
        if t >= 2:
            prev2_round_index = t - 2
            self_c_prev2 = history.my_actions[prev2_round_index]
            opp_coop_prev2 = history.opponent_actions[prev2_round_index].sum()
            C_prev2 = opp_coop_prev2 + (1 if self_c_prev2 else 0)
            diff = C_prev - C_prev2
            if diff > 0:
                self.cooperation_trend.append('improve')
            elif diff < 0:
                self.cooperation_trend.append('decline')
            else:
                self.cooperation_trend.append('steady')
            if len(self.cooperation_trend) > 4:
                self.cooperation_trend.pop(0)
        else:
            pass
        if current_round == R:
            self.defected_due_to_low_coop = False
            return Action.C
        if C_prev >= m:
            self.defected_due_to_low_coop = False
            return Action.C
        elif C_prev >= m - 2:
            self.defected_due_to_low_coop = False
            return Action.C
        elif self.defected_due_to_low_coop:
            lo = self.cooperation_trend[-2:] if len(self.cooperation_trend) >= 2 else []
            if lo == ['improve', 'improve']:
                self.defected_due_to_low_coop = False
                return Action.C
            return Action.D
        else:
            self.defected_due_to_low_coop = True
            return Action.D

class Strategy_COOPERATIVE_123(BaseStrategy):
    """
    Threshold-Responsive Conditional Cooperation for Collective Risk Dilemma.
    - Cooperate on first round to signal cooperation.
    - For rounds 2 to r-1, cooperate if previous round had >= m cooperators, else defect.
    - Defect on last round to maximize last-round payoff.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        current_round = history.round_number + 1
        last_round_idx = history.round_number - 1
        if current_round == self.r:
            return Action.D
        own_last_action = history.my_actions[last_round_idx]
        opponents_last_actions = history.opponent_actions[last_round_idx]
        c_prev = opponents_last_actions.sum() + (1 if own_last_action else 0)
        if c_prev >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_124(BaseStrategy):
    """
    Cooperative strategy for the Collective Risk Dilemma implementing 
    Conditional Conditional Cooperation with Forgiveness as specified.

    Summary:
    - Round 1: cooperate unconditionally to signal cooperative intent.
    - Rounds 2 to r-1: cooperate if previous round met cooperation threshold m,
      or if forgiveness clause applies (threshold met two rounds ago).
    - Round r (last round): always defect.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        if history is None:
            return Action.C
        t = history.round_number
        current_round = t + 1
        if current_round == r:
            return Action.D
        last_round_index = t - 1
        if last_round_index < 0:
            return Action.C
        self_last_action = history.my_actions[last_round_index]
        opp_actions_last = history.opponent_actions[last_round_index]
        last_round_cooperators = int(self_last_action) + opp_actions_last.sum()
        if last_round_cooperators >= m:
            return Action.C
        if current_round >= 3:
            prev_prev_round_index = t - 2
            if prev_prev_round_index >= 0:
                self_prev_prev_action = history.my_actions[prev_prev_round_index]
                opp_actions_prev_prev = history.opponent_actions[prev_prev_round_index]
                prev_prev_cooperators = int(self_prev_prev_action) + opp_actions_prev_prev.sum()
                if prev_prev_cooperators >= m:
                    return Action.C
        return Action.D

class Strategy_COOPERATIVE_125(BaseStrategy):
    """
    Conditional Tit-for-Threshold (CTfT) strategy for the Collective Risk Dilemma.
    - Round 1: Cooperate.
    - Rounds 2 to r-1: Cooperate if at least m players cooperated last round, else defect.
    - Round r: Cooperate if threshold met last round, else defect.
    Forgiving strategy that conditions cooperation solely on whether the group met the cooperation threshold 
    in the previous round. 
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = self.game_description.n_players
        self.r = self.game_description.n_rounds
        self.m = self.game_description.m

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        round_idx = history.round_number
        current_round = round_idx + 1
        last_cooperators_opponents = history.opponent_actions[round_idx - 1].sum()
        my_last_action = history.my_actions[round_idx - 1]
        my_last_cooperator = 1 if my_last_action else 0
        num_cooperators_prev = last_cooperators_opponents + my_last_cooperator
        if current_round < self.r:
            if num_cooperators_prev >= self.m:
                return Action.C
            else:
                return Action.D
        if num_cooperators_prev >= self.m:
            return Action.C
        return Action.D

class Strategy_COOPERATIVE_126(BaseStrategy):
    """
    Conditional Reciprocity with Forgiveness and Endgame Cooperation for the
    Collective Risk Dilemma game.

    Starts by cooperating to signal willingness.
    Monitors the number of cooperators each round.
    Continues cooperating if threshold (m) is met or nearly met (with margin theta=1).
    Defects temporarily to punish when cooperation drops below threshold.
    Forgives after ForgivenessRounds=2 rounds of punishment to re-establish cooperation.
    Always cooperates on the final round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.theta = 1
        self.forgiveness_rounds = 2
        self.failure_count = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        if history is None or history.round_number == 0:
            self.failure_count = 0
            return Action.C
        t = history.round_number
        next_round = t + 1
        if next_round == r:
            self.failure_count = 0
            return Action.C
        prev_round_idx = t - 1
        prev_cooperators_opp = history.opponent_actions[prev_round_idx].sum()
        prev_self_coop = 1 if history.my_actions[prev_round_idx] else 0
        prev_cooperators = prev_cooperators_opp + prev_self_coop
        threshold = m - self.theta
        if prev_cooperators >= threshold:
            self.failure_count = 0
            return Action.C
        else:
            self.failure_count += 1
            if self.failure_count > self.forgiveness_rounds:
                self.failure_count = 0
                return Action.C
            else:
                return Action.D

class Strategy_COOPERATIVE_127(BaseStrategy):
    """
    Conditional Gradual Cooperation (CGC) strategy for the Collective Risk Dilemma.

    - Cooperates on round 1 to signal cooperation.
    - On rounds 2 to r-1:
      * Cooperates if the total number of cooperators last round (including self) is at least threshold m.
      * If cooperation dropped below threshold, forgives once and cooperates again.
      * If still below threshold after forgiveness, defects to punish.
    - Always cooperates on the last round to maximize collective payoff.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self.forgiveness_window = 1
        self.forgiveness_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.forgiveness_counter = 0
            return Action.C
        t = history.round_number + 1
        if t == self.r:
            self.forgiveness_counter = 0
            return Action.C
        last_round_idx = t - 2
        my_last_action = history.my_actions[last_round_idx]
        opp_last_actions = history.opponent_actions[last_round_idx]
        coop_others = opp_last_actions.sum()
        total_cooperators = coop_others + (1 if my_last_action else 0)
        if total_cooperators >= self.m:
            self.forgiveness_counter = 0
            return Action.C
        elif self.forgiveness_counter < self.forgiveness_window:
            self.forgiveness_counter += 1
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_128(BaseStrategy):
    """
    Conditional Cooperative Partner (CCP):
    - Start cooperating to signal goodwill.
    - From round 2 to r-1, cooperate if previous round's cooperators ≥ m, else defect.
    - In final round, cooperate if average recent cooperation (last 3 rounds or fewer) ≥ m, else defect.
    - Defect persistently if (a) all defect round 1 or (b) cooperation below m for 3 consecutive rounds.
    - Smooth decision in case cooperation oscillates around threshold by majority vote over last 2 rounds (or fewer).
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self.perm_defect = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            self.perm_defect = False
            return Action.C
        round_num = history.round_number + 1
        total_rounds_played = history.round_number
        coop_counts = []
        for past_round in range(total_rounds_played):
            my_a = history.my_actions[past_round]
            opp_a = history.opponent_actions[past_round]
            n_coop = int(my_a) + int(opp_a.sum())
            coop_counts.append(n_coop)
        if total_rounds_played >= 1 and coop_counts[0] == 0:
            self.perm_defect = True
        if total_rounds_played >= 3:
            last_3_low = all((c < self.m for c in coop_counts[-3:]))
            if last_3_low:
                self.perm_defect = True
        if self.perm_defect:
            return Action.D
        if round_num == 1:
            return Action.C
        if round_num == self.r:
            lookback = min(3, total_rounds_played)
            recent_coop_counts = coop_counts[-lookback:]
            avg_coop = sum(recent_coop_counts) / lookback if lookback > 0 else 0
            if avg_coop >= self.m:
                return Action.C
            else:
                return Action.D
        lookback = min(2, total_rounds_played)
        if lookback == 0:
            return Action.C
        recent_coop_counts = coop_counts[-lookback:]
        votes = []
        for c in recent_coop_counts:
            votes.append(c >= self.m)
        cooperate_next = sum(votes) >= lookback / 2
        return Action.C if cooperate_next else Action.D

class Strategy_AGGRESSIVE_65(BaseStrategy):
    """
    Aggressive Threshold Enforcer (ATE) for the Collective Risk Dilemma.
    
    Strategy aggressively seeks to maximize own payoffs by:
    - Cooperating on first round to signal and test cooperation viability.
    - Exploiting cooperators by defecting if threshold was met previously.
    - Cooperating only if exactly one cooperator short of threshold in previous round, to push group over threshold.
    - Defecting otherwise to avoid wasted cooperation.
    - Always defecting in the last round to maximize private payoff.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        t = 1 if history is None else history.round_number + 1
        if t == 1:
            return Action.C
        if t == r:
            return Action.D
        last_round_idx = t - 2
        opp_actions_prev = history.opponent_actions[last_round_idx]
        opp_coops = opp_actions_prev.sum()
        my_prev_action = history.my_actions[last_round_idx]
        my_prev_coop = 1 if my_prev_action else 0
        C_t_minus_1 = opp_coops + my_prev_coop
        if C_t_minus_1 >= m:
            return Action.D
        if C_t_minus_1 == m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_66(BaseStrategy):
    """
    Aggressive Strategy for Collective Risk Dilemma
    
    In round 1: always defect to probe others.
    In rounds 2 to r-1: cooperate only if in previous round there were at least (m - 1)
    cooperators among others, i.e., threshold would be met if self cooperates.
    Otherwise defect to exploit cooperators.
    In the last round: always defect to maximize private payoff.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        prev_round_idx = history.round_number - 1
        prev_cooperators = 0
        if prev_round_idx >= 0:
            prev_cooperators = history.opponent_actions[prev_round_idx].sum()
        else:
            return Action.D
        if prev_cooperators >= self.m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_67(BaseStrategy):
    """
    Dominant Defector with Strategic Cooperation for Collective Risk Dilemma.

    Aggressively defects to maximize private payoff except when cooperating is pivotal 
    to ensuring the public good reward is obtained, thereby exploiting others' cooperation. 
    Uses first round to test opponents by defecting.
    Defects on last round to exploit others' cooperation without reciprocation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        if t > 1:
            last_round_idx = history.round_number - 1
            last_opponent_acts = history.opponent_actions[last_round_idx] if self.n > 1 else []
            my_last_action = history.my_actions[last_round_idx]
            coop_count = int(my_last_action) + sum(last_opponent_acts)
            threshold_met = coop_count >= self.m
        else:
            coop_count = 0
            threshold_met = False
        rounds_played = history.round_number
        coop_freq = []
        if self.n > 1 and rounds_played > 0:
            opp_actions = history.opponent_actions[:rounds_played]
            coop_counts_per_opponent = opp_actions.sum(axis=0)
            coop_freq = coop_counts_per_opponent / rounds_played
        else:
            coop_freq = [0.0] * (self.n - 1)
        my_coop_count = history.my_actions[:rounds_played].sum() if rounds_played > 0 else 0
        if threshold_met:
            return Action.D
        if coop_count >= self.m - 2 and coop_count < self.m:
            return Action.C
        coop_threshold = 0.5
        for freq in coop_freq:
            if freq > coop_threshold:
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_68(BaseStrategy):
    """
    Aggressive "Dominant Defector with Opportunistic Punishment" strategy for Collective Risk Dilemma.

    - Always defects in first and last rounds.
    - Exploits cooperators by defecting when threshold met and self defected last round.
    - If threshold missed last round, tries cooperating to push threshold reached.
    - If self cooperated and threshold met last round, defects next round to exploit.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        k = self.game_description.k
        if history is None:
            return Action.D
        t = history.round_number
        current_round = t + 1
        if current_round == r:
            return Action.D
        prev_round_idx = t - 1
        prev_coop_count = 0
        self_last_action = history.my_actions[prev_round_idx]
        oppo_coop_count = history.opponent_actions[prev_round_idx].sum()
        prev_coop_count = oppo_coop_count + (1 if self_last_action else 0)
        if prev_coop_count >= m and self_last_action == False:
            return Action.D
        if prev_coop_count < m:
            return Action.C
        if prev_coop_count >= m and self_last_action == True:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_69(BaseStrategy):
    """
    Conditional Exploitative Defector for Collective Risk Dilemma.
    
    Aggressively defects to maximize private payoff. Cooperates only minimally
    to nudge others to meet the cooperation threshold m and secure the collective
    reward k. Uses prior round cooperation counts to decide current action.
    
    Decision logic:
    - Round 1: Defect to gather info.
    - Rounds 2 to r-1:
        * if prev round cooperators ≥ m: defect (free-ride)
        * if prev round cooperators = m - 1: cooperate (push threshold)
        * else: defect (punish)
    - Last round r: always defect for maximal private gain.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n, m, r = (self.game.n_players, self.game.m, self.game.n_rounds)
        if history is None:
            return Action.D
        t = history.round_number
        current_round = t + 1
        if current_round == r:
            return Action.D
        prev_round_index = t - 1
        prev_my_action = history.my_actions[prev_round_index]
        prev_opponent_actions = history.opponent_actions[prev_round_index]
        n_cooperators = int(prev_my_action) + int(prev_opponent_actions.sum())
        if n_cooperators >= m:
            return Action.D
        elif n_cooperators == m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_70(BaseStrategy):
    """
    Conditional Exploiter for Collective Risk Dilemma:
    - Round 1: Defect to test opponents.
    - Rounds 2 to r-1: Cooperate only if exactly (m-1) opponents cooperated last round and threshold was met.
      Otherwise defect.
    - Last round r: Defect aggressively.
    - Goal: Free-ride on others' cooperation; cooperate minimally only when pivotal to meet threshold.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number
        current_round = t + 1
        if current_round == 1:
            return Action.D
        if current_round == self.r:
            return Action.D
        prev_round_idx = t - 1
        my_prev_action = history.my_actions[prev_round_idx]
        opp_prev_actions = history.opponent_actions[prev_round_idx]
        total_prev_cooperators = (1 if my_prev_action else 0) + opp_prev_actions.sum()
        threshold_met_prev = total_prev_cooperators >= self.m
        prev_cooperator_count = int(opp_prev_actions.sum())
        if threshold_met_prev and prev_cooperator_count == self.m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_71(BaseStrategy):
    """
    Threshold Exploiter strategy for the Collective Risk Dilemma.

    Aggressive individual maximizing payoff by cooperating just enough to 
    secure the threshold reward and defecting otherwise. Always defects first round,
    defects last round, and exploits cooperating opponents in between by defecting
    when threshold is safe.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.n = self.game.n_players
        self.m = self.game.m
        self.r = self.game.n_rounds
        self.threshold_fail_streak = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == 1:
            return Action.D
        elif current_round > self.r:
            return Action.D
        prev_round_index = current_round - 2
        prev_cooperators = 0
        if prev_round_index >= 0:
            prev_cooperators = history.opponent_actions[prev_round_index].sum()
        my_prev_action = False
        if prev_round_index >= 0 and len(history.my_actions) > prev_round_index:
            my_prev_action = history.my_actions[prev_round_index]
        total_cooperators_last = prev_cooperators + (1 if my_prev_action else 0)
        if total_cooperators_last >= self.m:
            self.threshold_fail_streak = 0
        else:
            self.threshold_fail_streak += 1
        if self.threshold_fail_streak >= 2:
            return Action.D
        if current_round == self.r:
            return Action.D
        if total_cooperators_last == self.m:
            if prev_cooperators >= self.m - 1:
                return Action.C
        if prev_cooperators >= self.m:
            return Action.D
        if prev_cooperators == self.m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_72(BaseStrategy):
    """
    "Conditional Exploit" strategy for Collective Risk Dilemma.

    Aggressively defects whenever the threshold m of cooperators was met in the previous round,
    to maximize own payoff by free-riding on others. Cooperates only when first round,
    when the threshold was missed last round (to try to reach it),
    in the penultimate round (to secure reward), and defects on last round.

    Summary:
    - Round 1: Cooperate (C)
    - Rounds 2 to r-2: Defect if last round met threshold, else cooperate
    - Round r-1: Cooperate
    - Round r: Defect
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number
        next_round = t + 1
        if next_round > self.r:
            return Action.D
        if t == 0:
            return Action.C
        coop_opponents = history.opponent_actions[t - 1].sum()
        my_last_action = history.my_actions[t - 1]
        coop_total_last = coop_opponents + (1 if my_last_action else 0)
        if next_round == 1:
            return Action.C
        if next_round == 1:
            return Action.C
        if 2 <= next_round <= self.r - 2:
            if coop_total_last >= self.m:
                return Action.D
            else:
                return Action.C
        if next_round == self.r - 1:
            return Action.C
        if next_round == self.r:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_73(BaseStrategy):
    """
    Aggressive "Exploit & Punish Threshold Cooperation" strategy for Collective Risk Dilemma.

    Defects by default.
    Cooperates only when confident the cooperation threshold is met or nearly met,
    and this player has cooperated previously to ensure the reward.
    Always defects in first and last rounds.
    Exploits partial cooperation by defecting.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        curr_round = history.round_number
        decision_round = curr_round + 1
        if decision_round == self.r:
            return Action.D
        prev_round_idx = curr_round - 1
        my_action_prev = Action.C if history.my_actions[prev_round_idx] else Action.D
        opponents_actions_prev = history.opponent_actions[prev_round_idx]
        num_cooperators_prev = int(my_action_prev == Action.C) + opponents_actions_prev.sum()
        coop_others_prev = num_cooperators_prev - (1 if my_action_prev == Action.C else 0)
        if num_cooperators_prev >= self.m:
            if my_action_prev == Action.C:
                return Action.C
            else:
                return Action.D
        if coop_others_prev >= self.m - 1:
            if my_action_prev == Action.C:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_74(BaseStrategy):
    """
    Aggressive Strategy for Collective Risk Dilemma.

    Defects by default to maximize private payoff and only cooperates when absolutely
    necessary to secure the collective reward threshold. Punishes failed cooperation
    rounds by defecting except when minimal cooperation is needed to save the reward.
    Always defects in the first and last round. Exploits others' cooperation by free-riding
    when threshold can be met without self cooperating.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game.n_players
        m = self.game.m
        r = self.game.n_rounds
        if history is None or history.round_number == 0:
            return Action.D
        round_num = history.round_number + 1
        if round_num == r:
            return Action.D
        last_round_idx = history.round_number - 1
        opponents_coop = sum(history.opponent_actions[last_round_idx])
        self_coop_last = history.my_actions[last_round_idx]
        C_count = opponents_coop + (1 if self_coop_last else 0)
        threshold_met = C_count >= m
        others_cooperating = opponents_coop
        if threshold_met:
            if others_cooperating >= m:
                return Action.D
            else:
                return Action.C
        elif others_cooperating >= m:
            return Action.D
        else:
            cooperate_needed = others_cooperating + 1 >= m
            if cooperate_needed:
                return Action.C
            else:
                return Action.D

class Strategy_AGGRESSIVE_75(BaseStrategy):
    """
    Aggressive strategy for the Collective Risk Dilemma.

    - Defects as much as possible to maximize private payoffs.
    - Cooperates only when pivotal to reaching the threshold m.
    - Exploits cooperators by defecting when threshold is still met without self.
    - Tracks consistent cooperators (2+ rounds consecutively cooperating) to punish by defecting.
    - Adjusts cooperation frequency dynamically based on observed cooperation levels.
    - Defects unconditionally on the last round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.consistent_cooperators = set()
        self.coop_streak = [0] * self.game_description.n_players

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        k = self.game_description.k

        def bool_to_action(b: bool) -> Action:
            return Action.C if b else Action.D
        if history is None:
            if m - 1 <= 1:
                return Action.C
            else:
                return Action.D
        round_num = history.round_number
        current_round = round_num + 1
        if current_round == r:
            return Action.D
        last_round_index = round_num - 1
        last_round_opponent_actions = history.opponent_actions[last_round_index]
        last_action_self = history.my_actions[last_round_index]
        coop_count_last_round = last_round_opponent_actions.sum() + (1 if last_action_self else 0)
        for i in range(n - 1):
            if last_round_opponent_actions[i]:
                self.coop_streak[i] += 1
            else:
                self.coop_streak[i] = 0
        new_consistent_cooperators = set()
        for i, streak in enumerate(self.coop_streak):
            if streak >= 2:
                new_consistent_cooperators.add(i)
        self.consistent_cooperators = new_consistent_cooperators
        coop_others_last_round = coop_count_last_round - (1 if last_action_self else 0)
        needed = m - coop_others_last_round
        lookback = min(3, round_num)
        if lookback > 0:
            recent_opponent_actions = history.opponent_actions[round_num - lookback:round_num]
            cooperation_sums = recent_opponent_actions.sum(axis=0)
            opponents_cooperate_freq = cooperation_sums
        else:
            opponents_cooperate_freq = [0] * (n - 1)
        avg_coop_rate = opponents_cooperate_freq.sum() / ((n - 1) * lookback) if lookback > 0 else 0
        if coop_count_last_round >= m:
            if coop_others_last_round >= m:
                return Action.D
            else:
                return Action.C
        elif needed <= 1:
            return Action.C
        else:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_76(BaseStrategy):
    """
    Aggressive 'Threshold Exploiter' strategy for the Collective Risk Dilemma.

    - Defects aggressively whenever threshold m is met without own cooperation.
    - Cooperates only when previous round's cooperation count is exactly m-1,
      to sustain threshold and secure the collective reward.
    - In the first round, defects if threshold m < n/2, else cooperates to
      ensure threshold met.
    - Always defects in the last round to maximize personal payoff since no
      future retaliation is possible.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game.n_players
        r = self.game.n_rounds
        m = self.game.m
        if history is None:
            if m < n / 2:
                return Action.D
            else:
                return Action.C
        round_num = history.round_number
        if round_num == r - 1:
            return Action.D
        prev_idx = round_num - 1
        if prev_idx < 0:
            if m < n / 2:
                return Action.D
            else:
                return Action.C
        prev_opp_coop = history.opponent_actions[prev_idx].sum(dtype=int)
        prev_my_coop = 1 if history.my_actions[prev_idx] else 0
        prev_coop_total = prev_opp_coop + prev_my_coop
        if prev_coop_total >= m:
            return Action.D
        elif prev_coop_total == m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_77(BaseStrategy):
    """
    Aggressive Opportunist strategy for Collective Risk Dilemma.

    Starts defecting to test opponents. In middle rounds, exploits cooperators
    when reward threshold was met previously, else cooperates only to tip the 
    group over the threshold if needed. Final round defects always, free-riding
    if reward likely secured.

    Key points:
    - Never cooperate blindly; cooperation only when it can secure the reward.
    - Exploit cooperators by defecting when threshold met last round.
    - Cooperate only if your cooperation can push group over threshold after a failure.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.m = game_description.m
        self.r = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        round_num = 1 if history is None else history.round_number + 1
        if round_num == 1:
            return Action.D
        prev_idx = round_num - 2
        own_last = history.my_actions[prev_idx]
        opp_last = history.opponent_actions[prev_idx]
        prev_c = (own_last + opp_last.sum()).item()
        if round_num == self.r:
            return Action.D
        if prev_c >= self.m:
            return Action.D
        if prev_c + 1 >= self.m:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_78(BaseStrategy):
    """
    Opportunistic Free-Rider Strategy for the Collective Risk Dilemma.

    This aggressive strategy maximizes individual payoff by:
    - Starting with defection to test others.
    - Cooperating only when that cooperation secures the minimal cooperation threshold.
    - Defecting otherwise to free-ride on others' cooperation.
    - If others rarely cooperate, defect consistently.
    - If others regularly cooperate, exploit by defecting whenever threshold can still be met.
    - Always defect on the last round to maximize private payoff without risk.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number
        if t == self.r - 1:
            return Action.D
        prev_round_idx = t - 1
        opponent_coop_last = history.opponent_actions[prev_round_idx].sum()
        self_coop_last = 1 if history.my_actions[prev_round_idx] else 0
        count_C_prev = opponent_coop_last + self_coop_last
        expected_others_C = count_C_prev - self_coop_last
        last_rounds_to_check = 2
        rounds_available = min(t, last_rounds_to_check)
        recent_counts = []
        for i in range(t - rounds_available, t):
            o_coop = history.opponent_actions[i].sum()
            s_coop = 1 if history.my_actions[i] else 0
            recent_counts.append(o_coop + s_coop)
        avg_recent_C = sum(recent_counts) / rounds_available if rounds_available > 0 else 0
        if avg_recent_C < self.m:
            return Action.D
        if expected_others_C + 1 >= self.m:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_79(BaseStrategy):
    """
    Aggressive Strategy for Collective Risk Dilemma repeated game.
    
    Key points:
    - Defect on the first round to test others.
    - On rounds 2 to r-1, if the previous round met cooperation threshold, defect to exploit.
      Otherwise, cooperate every 3rd round as a minimal cooperation signal, else defect.
    - Always defect on the last round to maximize payoff without risk.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game.n_players
        r = self.game.n_rounds
        m = self.game.m
        k = self.game.k
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number
        current_round = t + 1
        if current_round == r:
            return Action.D
        prev_round_idx = t - 1
        prev_cooperators = int(history.my_actions[prev_round_idx]) + int(sum(history.opponent_actions[prev_round_idx]))
        if prev_cooperators >= m:
            return Action.D
        if current_round % 3 == 0:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_80(BaseStrategy):
    """
    Threshold Enforcer with Exploitative Defection for the Collective Risk Dilemma.

    This strategy aggressively defects when threshold cooperation is met by others,
    cooperates to enforce the threshold after failures, and tries to exploit early
    rounds while securing reward in final rounds.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        last_round_idx = t - 2
        last_round_cooperators = sum(history.opponent_actions[last_round_idx]) + history.my_actions[last_round_idx]
        threshold_met_last = last_round_cooperators >= self.m
        consecutive_failures = 0
        for i in range(last_round_idx, -1, -1):
            coop_count = sum(history.opponent_actions[i]) + history.my_actions[i]
            if coop_count < self.m:
                consecutive_failures += 1
            else:
                break
        if t == self.r:
            if threshold_met_last:
                return Action.D
            else:
                return Action.C
        if consecutive_failures >= 2:
            return Action.C
        if threshold_met_last:
            if history.my_actions[last_round_idx]:
                return Action.D
            else:
                return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_81(BaseStrategy):
    """
    Aggressive Strategy for Collective Risk Dilemma.

    - Always defects first round to probe.
    - On intermediate rounds, estimates expected cooperators excluding self from past rounds.
    - If threshold m can be met without cooperating, defect (free-ride).
    - At round 2, cooperate once to test feasibility of threshold.
    - Always defects last round to maximize payoff.
    - Otherwise defects aggressively to punish cooperators and avoid cooperation cost.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number
        current_round = t + 1
        if current_round == self.r:
            return Action.D
        coop_counts = []
        for past_round_idx in range(t):
            opp_coop_count = history.opponent_actions[past_round_idx].sum()
            if history.my_actions[past_round_idx]:
                opp_coop_count -= 1
            coop_counts.append(opp_coop_count)
        if coop_counts:
            E_t = sum(coop_counts) / len(coop_counts)
        else:
            E_t = 0.0
        if E_t + 1 >= self.m:
            return Action.D
        if current_round == 2:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_82(BaseStrategy):
    """
    Threshold Exploiter strategy for the repeated Collective Risk Dilemma.

    Aggressively defects except minimally cooperates only when the threshold was
    missed by exactly one cooperator last round and this player defected last round,
    trying to push the group over the threshold to gain the reward.  
    Always defects on first and last rounds.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game.n_players
        r = self.game.n_rounds
        m = self.game.m
        if history is None:
            return Action.D
        round_number = history.round_number + 1
        last_round_idx = history.round_number - 1
        my_last_action = history.my_actions[last_round_idx]
        coop_opp_last = history.opponent_actions[last_round_idx].sum()
        c_prev = coop_opp_last + (1 if my_last_action else 0)
        if round_number == 1:
            return Action.D
        if round_number == r:
            return Action.D
        if c_prev >= m:
            return Action.D
        elif c_prev == m - 1:
            if not my_last_action:
                return Action.C
            else:
                return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_83(BaseStrategy):
    """
    Opportunistic Defector for Collective Risk Dilemma.

    This aggressive strategy cooperates only when confident the cooperation threshold 
    will be met to secure the reward and maintain some advantage, otherwise defects 
    to maximize individual payoff. It uses history to identify stable cooperators 
    and free-rides on them, defects persistently on the last round, and cuts losses 
    when threshold is not met.

    Summary of behavior:
    - Round 1: Cooperate only if m ≤ n-1, else defect.
    - Middle rounds (2 to r-1):
       - If threshold met last round and cooperated last round, keep cooperating.
       - If threshold met and defected last round, keep defecting to free-ride.
       - If threshold missed and cooperated last round, defect now to cut losses.
       - If threshold missed and defected last round, stay defecting.
       - Additional logic: if coop_count < m-1 and player defected, defect aggressively.
    - Last round: Always defect.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            if self.m <= self.n - 1:
                return Action.C
            else:
                return Action.D
        t = history.round_number
        current_round = t + 1
        if current_round == self.r:
            return Action.D
        prev_round_idx = t - 1
        coop_opp_last = history.opponent_actions[prev_round_idx].sum()
        i_action_prev = history.my_actions[prev_round_idx]
        coop_count_prev = coop_opp_last + (1 if i_action_prev else 0)
        if coop_count_prev < self.m - 1 and (not i_action_prev):
            return Action.D
        if coop_count_prev < self.m:
            if i_action_prev:
                return Action.D
            else:
                return Action.D
        elif i_action_prev:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_84(BaseStrategy):
    """
    Aggressive strategy for the Collective Risk Dilemma.

    Tries to defect as much as possible exploiting others' cooperation while ensuring
    the threshold m is met each round to secure reward k, cooperating only when needed
    to maintain the collective threshold and thus the reward.

    Strategy logic:
    - Round 1: Cooperate if threshold m > 1; else defect.
    - Rounds 2..r-1: 
        * If predicted cooperators (based on last round opponents) >= m, defect.
        * If predicted cooperators == m-1, cooperate to reach threshold.
        * If predicted cooperators < m-1, cooperate only if defecting would cause losing reward this round.
          Else defect.
    - Final round r: defect if safe; else cooperate to secure reward.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.n = self.game.n_players
        self.r = self.game.n_rounds
        self.m = self.game.m
        self.k = self.game.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            if self.m > 1:
                return Action.C
            else:
                return Action.D
        t = history.round_number + 1
        last_round_idx = history.round_number - 1
        C_prev = history.opponent_actions[last_round_idx].sum() if last_round_idx >= 0 else 0
        predicted_cooperators = C_prev

        def decide_mid_round():
            if predicted_cooperators >= self.m:
                return Action.D
            elif predicted_cooperators == self.m - 1:
                return Action.C
            elif predicted_cooperators + 1 >= self.m:
                return Action.C
            else:
                return Action.D
        if t == 1:
            return Action.C if self.m > 1 else Action.D
        elif 2 <= t < self.r:
            return decide_mid_round()
        else:
            action = decide_mid_round()
            if action == Action.D and predicted_cooperators < self.m:
                return Action.C
            else:
                return action

class Strategy_AGGRESSIVE_85(BaseStrategy):
    """
    Threshold Hijacker strategy for the Collective Risk Dilemma.
    Aggressively defects first round, free-rides when enough cooperators,
    cooperates minimally to recover threshold if it failed last round,
    and on last round cooperates only if threshold was ever missed before.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game.n_players
        r = self.game.n_rounds
        m = self.game.m
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number
        cooperators_per_round = []
        for round_idx in range(t):
            my_c = int(history.my_actions[round_idx])
            opp_c = history.opponent_actions[round_idx].sum()
            cooperators_per_round.append(my_c + opp_c)
        current_round = t + 1
        if current_round == r:
            for ct in cooperators_per_round:
                if ct < m:
                    return Action.C
            return Action.D
        else:
            c_last = cooperators_per_round[-1]
            if c_last >= m:
                return Action.D
            else:
                return Action.C

class Strategy_AGGRESSIVE_86(BaseStrategy):
    """
    Aggressive Strategy for Collective Risk Dilemma.

    - Defects first round to observe.
    - Defects if threshold met without self (free-rides).
    - Cooperates only if pivotal to meet threshold.
    - On last round, same logic applies: cooperate only if absolutely needed.
    - Tracks previous round cooperation count among all players excluding self.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        round_num = history.round_number + 1
        prev_round_idx = round_num - 2
        if prev_round_idx < 0:
            return Action.D
        prev_opp_actions = history.opponent_actions[prev_round_idx]
        prev_cooperators_count = np.sum(prev_opp_actions)
        est_coop_without_me = prev_cooperators_count
        if round_num == self.r:
            if est_coop_without_me >= self.m:
                return Action.D
            elif est_coop_without_me == self.m - 1:
                return Action.C
            else:
                return Action.D
        elif 1 < round_num < self.r:
            if est_coop_without_me >= self.m:
                return Action.D
            elif est_coop_without_me == self.m - 1:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_87(BaseStrategy):
    """
    Threshold Opportunist Exploiter for the Collective Risk Dilemma.

    Aggressively defects unless absolutely necessary to cooperate to reach 
    the cooperation threshold m. Exploits cooperators by free-riding when 
    threshold is met without own contribution. Always defects in the last round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        r = self.game.n_rounds
        m = self.game.m
        if t == 1:
            return Action.D
        if t == r:
            return Action.D
        last_round_idx = t - 2
        coop_others = sum(history.opponent_actions[last_round_idx])
        if coop_others >= m:
            return Action.D
        if coop_others == m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_88(BaseStrategy):
    """
    Aggressive Strategy for the Collective Risk Dilemma.

    Summary:
    - Round 1: Cooperate once to trigger cooperation.
    - Subsequent rounds except last:
      * Defect if threshold m reached last round.
      * Cooperate if last round had (m-1) cooperators and self cooperated last round (pivot).
      * Otherwise defect.
    - Last round: same logic as intermediate rounds.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number
        prev_round_idx = t - 1
        cooperators_prev = history.opponent_actions[prev_round_idx].sum() + (1 if history.my_actions[prev_round_idx] else 0)
        cooperated_prev = history.my_actions[prev_round_idx]
        is_last_round = t == self.r
        if is_last_round:
            if cooperators_prev >= self.m:
                return Action.D
            elif cooperators_prev == self.m - 1 and cooperated_prev:
                return Action.C
            else:
                return Action.D
        elif cooperators_prev >= self.m:
            return Action.D
        elif cooperators_prev == self.m - 1 and cooperated_prev:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_89(BaseStrategy):
    """
    Aggressive Strategy for Collective Risk Dilemma.

    Summary:
    - Round 1: Defect to exploit naive cooperators.
    - Intermediate rounds:
       * Defect if others met/exceeded threshold m.
       * Cooperate only if one short (m-1) to push over threshold.
       * Defect otherwise.
    - Final round: Always defect (no future punishment).
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        k = self.game_description.k
        if history is None:
            return Action.D
        t = history.round_number
        current_round = t + 1
        C_minus_i_prev = 0
        if t > 0:
            last_round_idx = t - 1
            last_round_opponents = history.opponent_actions[last_round_idx]
            C_minus_i_prev = last_round_opponents.sum()
        else:
            C_minus_i_prev = 0
        if current_round == 1:
            return Action.D
        if current_round == r:
            return Action.D
        if C_minus_i_prev >= m:
            return Action.D
        elif C_minus_i_prev == m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_90(BaseStrategy):
    """
    Aggressive Strategy for the Collective Risk Dilemma.
    
    Starts by defecting aggressively, exploits cooperators when the
    threshold reward is delivered, cooperates only conditionally to
    maintain or fix the reward threshold, and always defects in the last round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.n = self.game.n_players
        self.r = self.game.n_rounds
        self.m = self.game.m
        self.k = self.game.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        if t == 1:
            return Action.D
        if t == self.r:
            return Action.D
        last_round_index = t - 2
        my_action_prev = history.my_actions[last_round_index]
        opp_actions_prev = history.opponent_actions[last_round_index]
        coop_count = int(my_action_prev) + int(sum(opp_actions_prev))
        reward_delivered = coop_count >= self.m
        my_payoff_prev = history.my_payoffs[last_round_index]
        defectors_payoffs = []
        cooperators_payoffs = []
        if my_action_prev:
            cooperators_payoffs.append(my_payoff_prev)
        else:
            defectors_payoffs.append(my_payoff_prev)
        opp_payoffs_prev = history.opponent_payoffs[last_round_index]
        for action, payoff in zip(opp_actions_prev, opp_payoffs_prev):
            if action:
                cooperators_payoffs.append(payoff)
            else:
                defectors_payoffs.append(payoff)
        max_def_payoff = max(defectors_payoffs) if defectors_payoffs else float('-inf')
        max_coop_payoff = max(cooperators_payoffs) if cooperators_payoffs else float('-inf')
        if reward_delivered:
            if max_def_payoff > max_coop_payoff:
                return Action.D
            elif coop_count == self.m or coop_count == self.m + 1:
                return Action.C
            else:
                return Action.D
        else:
            any_reward_ever = False
            for round_idx in range(history.round_number):
                opp_act_round = history.opponent_actions[round_idx]
                my_act_round = history.my_actions[round_idx]
                ccount = int(my_act_round) + int(sum(opp_act_round))
                if ccount >= self.m:
                    any_reward_ever = True
                    break
            if coop_count == self.m - 1:
                return Action.C
            else:
                return Action.D

class Strategy_AGGRESSIVE_91(BaseStrategy):
    """
    Aggressive Strategy for the Collective Risk Dilemma.

    This strategy defects by default to exploit cooperators,
    cooperating only when strictly necessary to maintain the
    threshold of cooperators to secure the group reward.

    In the last round, it cooperates only if it strictly benefits
    (i.e., when the group is just one cooperator short of threshold),
    otherwise defects.

    It uses previous round's cooperation counts (excluding self) as
    a predictor of others' behavior, assuming they repeat actions.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number
        current_round = t + 1
        if t == 0:
            return Action.D
        prev_opponent_actions = history.opponent_actions[t - 1]
        others_C = prev_opponent_actions.sum()
        threshold = self.m
        prev_reward_met = False
        self_last_action = history.my_actions[t - 1]
        total_coop_prev = others_C + (1 if self_last_action else 0)
        if total_coop_prev >= threshold:
            prev_reward_met = True
        if current_round == self.r:
            if others_C == threshold - 1:
                return Action.C
            else:
                return Action.D
        if not prev_reward_met:
            return Action.D
        if others_C >= threshold:
            return Action.D
        elif others_C == threshold - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_92(BaseStrategy):
    """
    Aggressive Strategy for Collective Risk Dilemma.

    Summary:
    - Round 1: Defect outright to signal aggressiveness.
    - Intermediate rounds:
      - If last round threshold met:
        -- Defect always to free-ride / exploit cooperators.
      - Else (threshold not met):
        -- Cooperate only if by cooperating alone can push cooperators count to threshold,
           otherwise defect.
    - Last round: Defect to maximize final payoff.
    - Never reward cooperation long-term; always aggressively exploit or punish.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number
        next_round = t + 1
        prev_round_idx = t - 1
        opp_last_actions = history.opponent_actions[prev_round_idx]
        self_coop_last = history.my_actions[prev_round_idx]
        opp_coops = opp_last_actions.sum()
        coop_count = opp_coops + (1 if self_coop_last else 0)
        threshold_met = coop_count >= self.m
        if next_round == 1:
            return Action.D
        if next_round > self.r:
            return Action.D
        if next_round == self.r:
            return Action.D
        if threshold_met:
            return Action.D
        else:
            coop_without_me = coop_count - (1 if self_coop_last else 0)
            if coop_without_me + 1 >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_AGGRESSIVE_93(BaseStrategy):
    """
    Aggressive Collective Risk Dilemma Strategy:
    - First round: always defect.
    - Last round: always defect.
    - Intermediate rounds:
      * If threshold met last round, defect if others can reach threshold without me, else cooperate.
      * If threshold NOT met last round, cooperate only if my cooperation alone flips threshold; else defect.
    This aggressively exploits cooperators and only cooperates when strictly necessary to achieve threshold.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory):
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number + 1
        if t == r:
            return Action.D
        last_round_idx = history.round_number - 1
        my_last_action = history.my_actions[last_round_idx]
        opp_last_actions = history.opponent_actions[last_round_idx]
        c_last = int(my_last_action) + opp_last_actions.sum()
        c_last_excl_me = c_last - (1 if my_last_action else 0)
        threshold_met_last = c_last >= m
        if threshold_met_last:
            if c_last_excl_me >= m:
                return Action.D
            else:
                return Action.C
        elif c_last_excl_me + 1 >= m:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_94(BaseStrategy):
    """
    Aggressive Strategy for Collective Risk Dilemma.
    
    Defect by default to maximize personal payoff.
    Cooperate only if cooperating is strictly needed to reach the cooperation threshold (m)
    and secure the reward k.
    Exploit identified cooperators by defecting whenever possible.
    Always defect on first and last rounds to avoid exploitation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.n = self.game.n_players
        self.r = self.game.n_rounds
        self.m = self.game.m
        self.k = self.game.k
        self.C_obs = None
        self.self_index = None
        self.f_threshold = 0.5

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.self_index = 0
            self.C_obs = [0] * self.n
            return Action.D
        t = history.round_number
        if self.self_index is None:
            self.self_index = 0
            self.C_obs = [0] * self.n
        opponent_indices = []
        for idx in range(self.n):
            if idx != self.self_index:
                opponent_indices.append(idx)
        last_round = t - 1
        if last_round > 0:
            for i in range(self.n):
                self.C_obs[i] = 0
            for round_idx in range(last_round):
                opp_actions_round = history.opponent_actions[round_idx]
                for opp_pos, pidx in enumerate(opponent_indices):
                    if opp_actions_round[opp_pos]:
                        self.C_obs[pidx] += 1
        if t == self.r:
            return Action.D
        if t == 1:
            return Action.D
        if t > 1:
            coop_freq = [0.0] * self.n
            denom = t - 1
            for i in range(self.n):
                if i != self.self_index:
                    coop_freq[i] = self.C_obs[i] / denom
                else:
                    coop_freq[i] = 0.0
            likely_cooperators = [i for i in range(self.n) if i != self.self_index and coop_freq[i] >= self.f_threshold]
            E_coop = len(likely_cooperators)
            if E_coop >= self.m:
                return Action.D
            elif E_coop == self.m - 1:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_95(BaseStrategy):
    """
    Aggressive strategy for Collective Risk Dilemma.

    Always defects first and last round.
    From round 2 to r-1:
      - Defects if previous round had ≥ m cooperators (exploit reward)
      - Cooperates if previous round had exactly m-1 cooperators to push threshold
      - Otherwise defects
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game.n_players
        r = self.game.n_rounds
        m = self.game.m
        if history is None:
            return Action.D
        round_t = history.round_number
        curr_round = round_t + 1
        if curr_round == r:
            return Action.D
        if round_t == 0:
            return Action.D
        prev_round_idx = round_t - 1
        prev_opponent_coop = history.opponent_actions[prev_round_idx]
        prev_opponent_C = prev_opponent_coop.sum()
        own_last_action = history.my_actions[prev_round_idx]
        prev_C = prev_opponent_C + (1 if own_last_action else 0)
        if prev_C >= m:
            return Action.D
        if prev_C == m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_96(BaseStrategy):
    """
    Threshold Punisher for the Collective Risk Dilemma.

    Aggressively defects initially and exploits cooperators by free-riding if the cooperation threshold m is achieved without own cooperation.
    Cooperates only if pivotal to push cooperators count to threshold m (i.e. exactly m-1 others cooperated last round and self defected).
    Punishes opponents who defect repeatedly when cooperation is expected by permanent defection.
    Always defects in the last round to maximize private payoff.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self.defect_streaks = None
        self.permanent_defectors = None

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.defect_streaks = [0] * (self.n - 1)
            self.permanent_defectors = [False] * (self.n - 1)
            return Action.D
        t = history.round_number
        if t == 0:
            return Action.D
        if t == self.r:
            return Action.D
        prev_round_idx = t - 1
        my_prev_cooperated = history.my_actions[prev_round_idx]
        opp_prev_actions = history.opponent_actions[prev_round_idx]
        opp_c_count = opp_prev_actions.sum()
        if t >= 2:
            cooperation_profitable_last_round = opp_c_count >= self.m or opp_c_count == self.m - 1
            for i in range(self.n - 1):
                if self.permanent_defectors[i]:
                    continue
                opp_defected_last_round = not opp_prev_actions[i]
                if cooperation_profitable_last_round and opp_defected_last_round:
                    self.defect_streaks[i] += 1
                    if self.defect_streaks[i] >= 2:
                        self.permanent_defectors[i] = True
                else:
                    self.defect_streaks[i] = 0
        if opp_c_count == self.m - 1 and (not my_prev_cooperated):
            return Action.C
        if opp_c_count >= self.m and (not my_prev_cooperated):
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_97(BaseStrategy):
    """
    Aggressive "Exploit & Intimidate" strategy for Collective Risk Dilemma.
    - Always defects first round.
    - From rounds 2 to r-1, cooperates only if cooperation is pivotal to unlock reward (threshold).
    - Otherwise defects to exploit cooperators or avoid wasted cooperation cost.
    - Always defects last round to maximize own payoff.
    - Uses past rounds opponent cooperation counts to estimate expected cooperators.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number
        current_round = t + 1
        if current_round == self.r:
            return Action.D
        coop_counts = []
        for past_round in range(t):
            coop_counts.append(sum(history.opponent_actions[past_round]))
        if len(coop_counts) == 0:
            expected_cooperators = 0.0
        else:
            expected_cooperators = sum(coop_counts) / len(coop_counts)
        if expected_cooperators + 1 < self.m:
            return Action.D
        elif expected_cooperators >= self.m:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_98(BaseStrategy):
    """
    Aggressive 'Exploitative Opportunist' strategy for the Collective Risk Dilemma.
    - Round 1: Defect to test cooperators.
    - Intermediate rounds: 
       * If last round's cooperation threshold met, defect to freeride.
       * Otherwise, cooperate only if needed to barely reach threshold.
    - Last round: Always defect to maximize personal gain.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game.n_players
        r = self.game.n_rounds
        m = self.game.m
        if history is None:
            return Action.D
        t = history.round_number
        current_round = t + 1
        if current_round == r:
            return Action.D
        last_round_idx = t - 1
        if last_round_idx < 0:
            last_cooperators = 0
        else:
            last_opponent_actions = history.opponent_actions[last_round_idx]
            last_cooperators = sum(last_opponent_actions)
            if history.my_actions[last_round_idx]:
                last_cooperators += 1
        if last_cooperators >= m:
            return Action.D
        if last_cooperators < m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_99(BaseStrategy):
    """
    Aggressive Conditional Exploiter with Threat Enforcement for Collective Risk Dilemma.

    Strategy aggressively defects to maximize private payoff and exploits cooperators who meet
    the collective threshold. It only cooperates minimally and conditionally to maintain the
    reward when it directly benefits the player, otherwise defects to punish and extract maximum gain.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.n = self.game.n_players
        self.r = self.game.n_rounds
        self.m = self.game.m
        self.k = self.game.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number
        if t == self.r:
            return Action.D
        prev_round_idx = t - 1
        prev_opponent_coop = history.opponent_actions[prev_round_idx]
        prev_opponent_coop_count = prev_opponent_coop.sum()
        my_last_action = history.my_actions[prev_round_idx]
        c_prev = my_last_action + prev_opponent_coop_count
        if c_prev >= self.m:
            return Action.D
        elif c_prev == self.m - 1 and my_last_action == False:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_100(BaseStrategy):
    """
    Aggressive strategy for the Collective Risk Dilemma repeated game.
    - Cooperate sparingly, only to help reach threshold early if worthwhile.
    - Exploit others by defecting once threshold met.
    - Defect last round unconditionally.
    - Adjust based on recent cooperation to push group near threshold.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            if self.m < self.n / 2:
                return Action.C
            else:
                return Action.D
        t = history.round_number
        if t == self.r:
            return Action.D
        last_round_idx = t - 1
        last_round_cooperators = 0
        own_last_action_coop = history.my_actions[last_round_idx]
        opponents_last_actions = history.opponent_actions[last_round_idx]
        last_round_cooperators = int(own_last_action_coop) + int(opponents_last_actions.sum())
        threshold_met_last_round = last_round_cooperators >= self.m
        if threshold_met_last_round and (not own_last_action_coop):
            return Action.D
        elif threshold_met_last_round and own_last_action_coop:
            return Action.D
        elif last_round_cooperators >= self.m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_101(BaseStrategy):
    """
    Aggressive "Threshold Exploiter" strategy for the Collective Risk Dilemma.

    Summary:
    - Round 1: Defect.
    - Rounds 2 to r-1:
        * If last round total cooperators < m - 1: Defect.
        * If last round total cooperators == m - 1: Cooperate.
        * If last round total cooperators >= m: Defect.
    - Round r: Defect.

    This strategy cooperates minimally to just achieve the reward threshold,
    exploits over-cooperators by defecting, and always defects in the final round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t == r:
            return Action.D
        last_actions_opponents = history.opponent_actions[t - 2] if t > 1 else []
        n_coop_opponents = 0 if t == 1 else sum(last_actions_opponents)
        my_last_coop = history.my_actions[t - 2] if t > 1 else False
        last_round_cooperators = n_coop_opponents + (1 if my_last_coop else 0)
        if last_round_cooperators < m - 1:
            return Action.D
        if last_round_cooperators == m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_102(BaseStrategy):
    """
    Opportunistic Exploiter for the Collective Risk Dilemma.
    Aggressively defects to maximize payoff, free-rides when possible,
    cooperates only when strictly necessary to meet the cooperation threshold m,
    and exploits cooperation patterns of opponents.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game.n_players
        r = self.game.n_rounds
        m = self.game.m
        k = self.game.k
        if history is None:
            return Action.D
        t = history.round_number
        current_round = t + 1
        last_round_idx = t - 1
        opp_coop_last = 0
        if last_round_idx >= 0:
            opp_coop_last = history.opponent_actions[last_round_idx].sum()
        self_coop_last = 1 if history.my_actions[last_round_idx] else 0
        coop_last = opp_coop_last + self_coop_last
        expected_others_coop = opp_coop_last
        if current_round == r:
            if expected_others_coop >= m:
                return Action.D
            elif expected_others_coop == m - 1:
                return Action.C
            else:
                return Action.D
        if expected_others_coop >= m:
            return Action.D
        elif expected_others_coop == m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_103(BaseStrategy):
    """
    Aggressive strategy for Collective Risk Dilemma:
    - First round: defect to exploit any cooperators.
    - Intermediate rounds: defect unless exactly m-1 others likely cooperate, then cooperate to
      tip the threshold and capture reward.
    - Last round: defect unconditionally.
    This strategy exploits cooperators by defecting when threshold is met without self,
    cooperates only if cooperation is essential to reach the threshold,
    minimizing own cooperation costs.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game.n_players
        r = self.game.n_rounds
        m = self.game.m
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number
        current_round = t + 1
        if current_round == r:
            return Action.D
        if t == 0:
            return Action.D
        opponent_coop_counts = history.opponent_actions.sum(axis=0)
        cooperation_freq = opponent_coop_counts / t
        expected_cooperators_excl_self = cooperation_freq.sum()
        eps = 1e-09
        if expected_cooperators_excl_self + eps >= m:
            return Action.D
        elif abs(expected_cooperators_excl_self - (m - 1)) < eps:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_104(BaseStrategy):
    """
    Aggressive Collective Risk Dilemma strategy:
    - Defect first round (no history).
    - Defect last round always (no future enforcement).
    - On intermediate rounds:
      * Compute how many cooperators (excluding self) cooperated last round.
      * Calculate needed cooperators to reach threshold m.
      * Defect unless exactly one cooperation needed and cooperating yields greater immediate payoff.
    This maximizes private payoffs by leeching off others' cooperation while cooperating only when strictly decisive.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        k = self.game_description.k
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == r:
            return Action.D
        last_round_idx = current_round - 2
        opponents_coop_last_round = history.opponent_actions[last_round_idx]
        prev_coop_count = opponents_coop_last_round.sum(dtype=int)
        needed = m - prev_coop_count
        if needed <= 0:
            return Action.D
        elif needed == 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_105(BaseStrategy):
    """
    Aggressive Strategy for Collective Risk Dilemma.
    
    This player prioritizes maximizing personal payoff by defecting as much as possible,
    exploiting cooperative players. It defects in the first round and the last round,
    and in intermediate rounds it only cooperates reluctantly when pivotal to just meet
    the cooperative threshold, based on observed last round cooperation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        last_round_index = history.round_number - 1
        if last_round_index < 0:
            return Action.D
        opp_cooperators_last_round = history.opponent_actions[last_round_index].sum()
        last_round_cooperators_excl_self = int(opp_cooperators_last_round)
        cooperators_if_defect = last_round_cooperators_excl_self
        cooperators_if_cooperate = last_round_cooperators_excl_self + 1
        if cooperators_if_defect >= self.m:
            return Action.D
        if cooperators_if_defect == self.m - 1:
            self_cooperated_last_round = history.my_actions[last_round_index]
            total_cooperators_last_round = last_round_cooperators_excl_self + (1 if self_cooperated_last_round else 0)
            if total_cooperators_last_round < self.m:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_106(BaseStrategy):
    """
    Aggressive Opportunist for the Collective Risk Dilemma.

    - Round 1: defect aggressively.
    - Rounds 2 to r-1: defect if threshold consistently met or 
      consistently not met; cooperate only if threshold borderline 
      (m-1 cooperators last round) to push over threshold.
    - Last round: always defect.

    This exploits cooperators by free-riding on their cooperation 
    when threshold is met, and only cooperates minimally when 
    pivotal. Never trusts sustained cooperation and defects last round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t == 1:
            return Action.D
        if t == self.r:
            return Action.D
        last_round_idx = t - 2
        last_coop = sum(history.opponent_actions[last_round_idx]) + (1 if history.my_actions[last_round_idx] else 0)
        if t > 2:
            second_last_idx = t - 3
            second_last_coop = sum(history.opponent_actions[second_last_idx]) + (1 if history.my_actions[second_last_idx] else 0)
            last_two = [second_last_coop, last_coop]
        else:
            last_two = [0, last_coop]
        if all((c >= self.m for c in last_two)):
            return Action.D
        if all((c < self.m for c in last_two)):
            return Action.D
        if last_coop == self.m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_107(BaseStrategy):
    """
    Aggressive Strategy for Collective Risk Dilemma.

    Always defects except uses history to detect if threshold was met last round by others alone.
    If threshold met without own cooperation, free-rides by defecting.
    If threshold depended on own cooperation or not met, defects to avoid exploitation.
    First and last rounds defect unconditionally.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        last_round = t == self.r
        if history.round_number == 0:
            return Action.D
        last_round_index = t - 2
        last_round_opponent_actions = history.opponent_actions[last_round_index]
        coop_others = int(last_round_opponent_actions.sum())
        my_last_action = history.my_actions[last_round_index]
        total_cooperators = coop_others + (1 if my_last_action else 0)
        threshold_met_last_round = total_cooperators >= self.m
        if last_round:
            return Action.D
        if threshold_met_last_round:
            if coop_others >= self.m:
                return Action.D
            else:
                return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_108(BaseStrategy):
    """
    Aggressive strategy for the Collective Risk Dilemma.

    Summary:
    - Defect first round to gain private payoff and test others.
    - Between rounds 2 and r-1, defect if previous round had enough cooperators (≥ m),
      else cooperate only if your cooperation is pivotal to reach threshold m.
    - Defect always in the last round to maximize immediate payoff since no future rounds remain.
    - Uses opponent cooperation counts from previous round to decide.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_now = history.round_number + 1
        last_round_index = history.round_number - 1
        if round_now == self.r:
            return Action.D
        if last_round_index < 0:
            return Action.D
        opp_coops_last = history.opponent_actions[last_round_index].sum()
        self_coop_last = 1 if history.my_actions[last_round_index] else 0
        coop_count_last = opp_coops_last + self_coop_last
        if coop_count_last >= self.m:
            return Action.D
        if coop_count_last + 1 >= self.m:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_109(BaseStrategy):
    """
    Aggressive strategy for the Collective Risk Dilemma.
    Defects in first and last rounds.
    In intermediate rounds, defects if previous round had >= m cooperators to exploit cooperators.
    Cooperates only if previous cooperators == m - 1 to push group over threshold.
    Otherwise defects.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        if history is None:
            return Action.D
        round_num = history.round_number
        current_round = round_num + 1
        if current_round == r:
            return Action.D
        prev_round_idx = round_num - 1
        if prev_round_idx < 0:
            return Action.D
        prev_my_coop = history.my_actions[prev_round_idx]
        prev_opp_coops = history.opponent_actions[prev_round_idx]
        coop_count_last_round = (1 if prev_my_coop else 0) + sum(prev_opp_coops)
        if coop_count_last_round >= m:
            return Action.D
        elif coop_count_last_round == m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_110(BaseStrategy):
    """
    Aggressive strategy for the Collective Risk Dilemma.
    - Round 1: defect (no info, avoid cost).
    - Rounds 2 to r-1: if previous round met threshold, defect to exploit cooperators,
      else cooperate only if your cooperation can push threshold to be met,
      otherwise defect.
    - Last round: defect to maximize immediate payoff.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.n = self.game.n_players
        self.r = self.game.n_rounds
        self.m = self.game.m
        self.k = self.game.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        round_idx = history.round_number
        current_round = round_idx + 1
        if current_round == self.r:
            return Action.D
        last_round_idx = round_idx - 1
        opp_coop = history.opponent_actions[last_round_idx].sum()
        self_cooperated_last = history.my_actions[last_round_idx]
        coop_counts_last = opp_coop + (1 if self_cooperated_last else 0)
        coop_others_last = coop_counts_last - (1 if self_cooperated_last else 0)
        if coop_counts_last >= self.m:
            return Action.D
        if coop_others_last >= self.m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_111(BaseStrategy):
    """
    Aggressive "Exploit & Pressure" strategy for the Collective Risk Dilemma.
    
    Starts by defecting to gather info.
    In middle rounds, defects if threshold met last round, else cooperates to push threshold.
    On last round always defects.
    If cooperated last round but got defected upon by opponents, switch to persistent defection (punishment).
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self._punish = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        if history is None:
            self._punish = False
            return Action.D
        t = history.round_number + 1
        if self._punish:
            return Action.D
        if t == 1:
            self._punish = False
            return Action.D
        last_round_idx = t - 2
        last_coop_count = 0
        if last_round_idx >= 0:
            opp_coop_count = history.opponent_actions[last_round_idx].sum()
            my_coop_last = history.my_actions[last_round_idx]
            last_coop_count = opp_coop_count + (1 if my_coop_last else 0)
        else:
            last_coop_count = 0
            my_coop_last = False
        if t > 1:
            if my_coop_last:
                opp_defected = (~history.opponent_actions[last_round_idx]).any()
                if opp_defected:
                    self._punish = True
                    return Action.D
        if t < r:
            if last_coop_count >= m:
                return Action.D
            else:
                return Action.C
        return Action.D

class Strategy_AGGRESSIVE_112(BaseStrategy):
    """
    Aggressive strategy for the Collective Risk Dilemma:
    - Round 1: Cooperate if threshold m ≥ n/2, else defect.
    - Intermediate rounds (2..r-1):
      * Defect if threshold was met last round (free-ride).
      * Cooperate if threshold missed last round to restore cooperation,
        continuing cooperation if self cooperated last round,
        or switching from defection to cooperation otherwise.
    - Final round (r): always defect to maximize last round payoff.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            if self.m >= self.n / 2:
                return Action.C
            else:
                return Action.D
        t = history.round_number
        current_round = t + 1
        coop_count_last = int(history.opponent_actions[t - 1].sum()) + (1 if history.my_actions[t - 1] else 0)
        if current_round == self.r:
            return Action.D
        if coop_count_last >= self.m:
            return Action.D
        else:
            my_last_action = history.my_actions[t - 1]
            return Action.C

class Strategy_AGGRESSIVE_113(BaseStrategy):
    """
    Aggressive Exploiter with Minimal Cooperation for Collective Risk Dilemma.

    - Always defects first round.
    - Tracks number of cooperators in last round to decide action.
    - Cooperates only when threshold is narrowly missed and might tip threshold.
    - Otherwise defects to maximize private payoff and free-ride on cooperators.
    - Last round exploits observed cooperation by defecting when threshold likely met,
      or cooperating only if threshold was narrowly missed last round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m

    def __call__(self, history: None | PlayerHistory) -> Action:
        C = Action.C
        D = Action.D
        if history is None or history.round_number == 0:
            return D
        t = history.round_number
        last_idx = t - 1
        last_round_cooperators = int(history.my_actions[last_idx])
        last_round_cooperators += history.opponent_actions[last_idx].sum()
        my_last_action_coop = bool(history.my_actions[last_idx])
        narrowly_missed = last_round_cooperators == self.m - 1
        threshold_met = last_round_cooperators >= self.m
        if t == self.r:
            if threshold_met:
                return D
            elif narrowly_missed:
                return C
            else:
                return D
        if threshold_met:
            return D
        elif narrowly_missed:
            if not my_last_action_coop:
                return C
            else:
                return D
        else:
            return D

class Strategy_AGGRESSIVE_114(BaseStrategy):
    """
    Aggressive strategy for the Collective Risk Dilemma.

    Summary:
    - Round 1: Defect to exploit presumed cooperators.
    - Intermediate rounds (2..r-1): Cooperate only if your cooperation is pivotal to maintaining
      the threshold of cooperators; defect otherwise.
    - Final round (r): Defect to maximize single-round private payoff.
    - Uses last round's cooperation count (including own previous action) to decide.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        k = self.game_description.k
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t == r:
            return Action.D
        prev_round = t - 2
        opponents_last_round = history.opponent_actions[prev_round]
        own_last_action = history.my_actions[prev_round]
        coop_count_last = int(own_last_action) + int(opponents_last_round.sum())
        if coop_count_last >= m:
            if coop_count_last == m:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_115(BaseStrategy):
    """
    Aggressive Strategy for the Collective Risk Dilemma.

    Summary:
    - Always defect in first and last rounds.
    - In intermediate rounds, defect unless exactly one cooperator is needed to
      reach the threshold based on last round's cooperation; then cooperate to push
      cooperation over the threshold and gain reward.
    - Exploits cooperators by free-riding on their contributions.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number
        if t == self.r:
            return Action.D
        last_round_index = t - 1
        if last_round_index == 0:
            coop_last = sum(history.opponent_actions[0]) + (1 if history.my_actions[0] else 0)
        else:
            coop_last = sum(history.opponent_actions[last_round_index]) + (1 if history.my_actions[last_round_index] else 0)
        if coop_last >= self.m:
            return Action.D
        if coop_last == self.m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_116(BaseStrategy):
    """
    Aggressive strategy for Collective Risk Dilemma:
    - Defect first round and last round.
    - Cooperate only if in previous round the number of cooperators among all players 
      (including self) was exactly m-1, so that this player's cooperation is pivotal 
      to reach threshold and trigger reward.
    - Otherwise, defect to freeride or avoid losing.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t == 1:
            return Action.D
        if t == self.r:
            return Action.D
        prev_round_idx = t - 2
        opp_coop_last = history.opponent_actions[prev_round_idx].sum()
        self_coop_last = 1 if history.my_actions[prev_round_idx] else 0
        total_coops_last = opp_coop_last + self_coop_last
        if total_coops_last >= self.m:
            return Action.D
        elif total_coops_last == self.m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_117(BaseStrategy):
    """
    Aggressive Strategy for Collective Risk Dilemma:
    - Defect first round to test others.
    - Defect last round unconditionally.
    - In intermediate rounds:
       * If threshold met last round (including self if cooperated last round), defect (exploit).
       * If threshold missed last round, cooperate only if others cooperated exactly m-1 or m-2 times (near threshold),
         else defect.
    This strategy minimizes own cooperation costs while exploiting others' cooperation, cooperating only
    reluctantly to push threshold over near misses, maximizing individual payoff.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        if history is None:
            return Action.D
        round_num = history.round_number
        if round_num == r - 1:
            return Action.D
        prev_round_idx = round_num - 1
        prev_opponent_cooperators = history.opponent_actions[prev_round_idx].sum() if prev_round_idx >= 0 else 0
        self_cooperated_last = history.my_actions[prev_round_idx] if prev_round_idx >= 0 else False
        prev_total_cooperators = prev_opponent_cooperators + (1 if self_cooperated_last else 0)
        current_round = round_num + 1
        if current_round == 1:
            return Action.D
        if current_round < r:
            if prev_total_cooperators >= m:
                return Action.D
            elif prev_opponent_cooperators in {m - 1, m - 2}:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_118(BaseStrategy):
    """
    Threshold Exploiter Strategy for Collective Risk Dilemma.

    - Start by defecting first round (no info).
    - For intermediate rounds:
      * Defect if others cooperated enough last round (≥ m).
      * Cooperate only if others cooperated exactly m-1 times last round, 
        to push count to threshold and secure reward.
      * Otherwise defect.
    - In last round, defect unless cooperation strictly needed (but per spec, always defect).
    - Aggressively exploit cooperators without initiating cooperation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number
        if t >= self.r:
            return Action.D
        last_round_idx = t - 1
        coop_opponents = history.opponent_actions[last_round_idx].sum()
        coop_self_last = 1 if history.my_actions[last_round_idx] else 0
        total_coop_last = coop_opponents + coop_self_last
        current_round = t + 1
        if current_round == self.r:
            return Action.D
        others_coop_last = total_coop_last - coop_self_last
        if others_coop_last >= self.m:
            return Action.D
        elif others_coop_last == self.m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_119(BaseStrategy):
    """
    Aggressive strategy for the Collective Risk Dilemma:
    - Always defect on first round to test others.
    - From round 2 to r-1, cooperate only if your cooperation flips the 
      cooperation count from below to at least threshold m, allowing 
      reward k to be gained.
    - Defect otherwise.
    - On last round, same logic but no incentive to build trust.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        k = self.game_description.k
        if history is None:
            return Action.D
        round_num = history.round_number
        current_round = round_num + 1
        if round_num == 0:
            num_coop_others_prev = 0
        else:
            last_round_actions = history.opponent_actions[round_num - 1]
            num_coop_others_prev = int(last_round_actions.sum())
        if num_coop_others_prev >= m:
            return Action.D
        if num_coop_others_prev == m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_120(BaseStrategy):
    """
    Calculated Exploiter strategy for the Collective Risk Dilemma.
    
    Aggressively defects except when pivotal to reach the cooperation threshold (m).
    In the first round defects to test others.
    In intermediate rounds cooperates only if cooperation is decisive for reward.
    Defects in the last round unconditionally to maximize immediate gain.
    Exploits patterns of cooperation by others by free-riding whenever threshold 
    is met without your contribution.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.gd = game_description
        self.n = self.gd.n_players
        self.r = self.gd.n_rounds
        self.m = self.gd.m
        self.k = self.gd.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number
        if t == self.r:
            return Action.D
        prev_coop_opponents = 0
        if t > 0:
            prev_coop_opponents = history.opponent_actions[t - 1].sum()
        if prev_coop_opponents == 0:
            return Action.D
        if prev_coop_opponents < self.m - 1:
            return Action.D
        if prev_coop_opponents == self.m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_121(BaseStrategy):
    """
    Aggressive Strategy for the Collective Risk Dilemma.
    Prioritizes individual payoff by freely defecting except when minimal cooperation is needed 
    to push last round's cooperation count to meet threshold m (to get reward k).
    First and last rounds always defect aggressively.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        last_round_index = t - 2
        if last_round_index < 0:
            return Action.D
        my_last = history.my_actions[last_round_index]
        opp_last = history.opponent_actions[last_round_index]
        cooperators_last = (1 if my_last else 0) + opp_last.sum()
        if cooperators_last >= self.m:
            return Action.D
        if cooperators_last == self.m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_122(BaseStrategy):
    """
    Aggressive Strategy for the Collective Risk Dilemma.

    Summary:
    - Round 1: Always defect.
    - Intermediate rounds (2 to r-1):
      * If last round cooperation count (including self) ≥ m: defect (exploit).
      * If last round cooperation count = m-1: cooperate (minimally push threshold).
      * Else defect.
    - Last round (r):
      * If last round cooperation count ≥ m: defect (exploit).
      * If last round cooperation count = m-1: cooperate if k ≥ 1 else defect.
      * Else defect.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        k = self.game_description.k
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number
        current_round = t + 1
        last_round_cooperators = int(history.my_actions[t - 1]) + int(sum(history.opponent_actions[t - 1]))
        if current_round < r:
            if last_round_cooperators >= m:
                return Action.D
            elif last_round_cooperators == m - 1:
                return Action.C
            else:
                return Action.D
        elif last_round_cooperators >= m:
            return Action.D
        elif last_round_cooperators == m - 1:
            return Action.C if k >= 1 else Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_123(BaseStrategy):
    """
    Aggressive strategy for Collective Risk Dilemma.
    
    - Round 1: Defect to avoid first-mover cost.
    - Last round: Defect to maximize payoff without concern for retaliation.
    - Intermediate rounds:
        * If threshold was met last round: defect to free-ride.
        * If cooperators last round == m-1: cooperate to push threshold.
        * Otherwise defect.
    This approach exploits cooperators while avoiding sucker payoffs.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = history.round_number + 1 if history is not None else 1
        r = self.game.n_rounds
        m = self.game.m
        if t == 1:
            return Action.D
        if t == r:
            return Action.D
        last_round = t - 2
        coop_opp_last_round = history.opponent_actions[last_round].sum()
        coop_self_last_round = 1 if history.my_actions[last_round] else 0
        cooperators_last_round = coop_opp_last_round + coop_self_last_round
        if cooperators_last_round >= m:
            return Action.D
        if cooperators_last_round == m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_124(BaseStrategy):
    """
    Aggressive Strategy for Collective Risk Dilemma.
    
    Implements a payoff-maximizing aggressive approach:
    - Always defect first round (no info).
    - Cooperate only to push threshold if close (one cooperation away).
    - Exploit cooperating opponents by defecting when threshold met.
    - Defect last round unless almost sure cooperation push is needed.
    - Handles edge cases by favoring defection to minimize cost.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.n = self.game.n_players
        self.r = self.game.n_rounds
        self.m = self.game.m
        self.k = self.game.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        last_round_idx = t - 2
        if last_round_idx < 0:
            return Action.D
        last_opponent_actions = history.opponent_actions[last_round_idx]
        my_last_action_coop = history.my_actions[last_round_idx]
        C_count = last_opponent_actions.sum() + (1 if my_last_action_coop else 0)
        if self.m >= self.n - 1:
            return Action.D
        if t == self.r:
            if C_count >= self.m - 1:
                return Action.D
            else:
                return Action.D
        if C_count < self.m:
            if C_count + 1 >= self.m:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_125(BaseStrategy):
    """
    Aggressive Conditional Exploiter strategy for the Collective Risk Dilemma.

    - Defects on the first round.
    - Tracks cooperation frequencies of opponents.
    - Cooperates only if defecting would drop total cooperators below the threshold m.
    - Otherwise defects to exploit cooperators.
    - On the last round always defects to maximize personal gain.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.coop_threshold = 0.5

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number
        last_round_idx = t - 1
        n = self.n
        m = self.m
        r = self.r
        opp_actions = history.opponent_actions
        coop_freq = opp_actions[:t, :].sum(axis=0) / t
        likely_cooperators = [i for i, freq in enumerate(coop_freq) if freq >= self.coop_threshold]
        count_likely_cooperators = len(likely_cooperators)
        total_cooperators_without_me = count_likely_cooperators
        if t == r:
            return Action.D
        if total_cooperators_without_me >= m:
            return Action.D
        elif total_cooperators_without_me == m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_126(BaseStrategy):
    """
    Aggressive strategy for the Collective Risk Dilemma.
    
    - Round 1: Defect to secure guaranteed payoff.
    - Intermediate rounds (2 to r-1):
      - If previous round had at least m cooperators: defect to free-ride.
      - If previous round had exactly m-1 cooperators: cooperate to trigger reward.
      - Else defect to avoid cost.
    - Last round (r): always defect to maximize final payoff.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game.n_rounds
        m = self.game.m
        if history is None:
            return Action.D
        round_t = history.round_number
        if round_t == r:
            return Action.D
        prev_round_idx = round_t - 1
        prev_opponent_coops = history.opponent_actions[prev_round_idx].sum()
        my_prev_action = history.my_actions[prev_round_idx]
        prev_coop_count = prev_opponent_coops + (1 if my_prev_action else 0)
        if prev_coop_count >= m:
            return Action.D
        elif prev_coop_count == m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_127(BaseStrategy):
    """
    Aggressive Strategy for the Collective Risk Dilemma.

    This strategy seeks to maximize individual payoff by defecting whenever possible,
    cooperating only when strictly necessary to reach the cooperation threshold `m` and
    secure the collective reward `k`. It uses observed history to estimate cooperation
    levels and decides accordingly, punishing cooperators by defecting if threshold
    failures persist. It applies specific logic on the first and last rounds.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.threshold_failed_after_coop = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game.n_players
        m = self.game.m
        r = self.game.n_rounds
        k = self.game.k
        if history is None:
            return Action.D
        t = history.round_number
        last_cooperators = 0
        if t > 0:
            coop_self = history.my_actions[t - 1]
            coop_opponents = history.opponent_actions[t - 1]
            last_cooperators = coop_opponents.sum() + (1 if coop_self else 0)
        threshold_met_last_round = last_cooperators >= m
        any_coop_last_round = last_cooperators > 0
        threshold_failed_with_coop = any_coop_last_round and (not threshold_met_last_round)
        if threshold_failed_with_coop:
            self.threshold_failed_after_coop = True
        current_round = t + 1
        if self.threshold_failed_after_coop:
            if current_round == r:
                prev_coop_opponents = history.opponent_actions[t - 1].sum() if t > 0 else 0
                if prev_coop_opponents + 1 >= m:
                    return Action.C
                else:
                    return Action.D
            return Action.D
        E_c = 0
        if t > 0:
            E_c = history.opponent_actions[t - 1].sum()
        else:
            E_c = 0
        if current_round < r:
            if E_c >= m:
                return Action.D
            elif E_c + 1 >= m:
                return Action.C
            else:
                return Action.D
        elif current_round == r:
            if E_c >= m:
                return Action.D
            elif E_c + 1 >= m:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_128(BaseStrategy):
    """
    Aggressive "Calculative Exploiter" strategy for Collective Risk Dilemma.

    - Defects initially.
    - Only cooperates if my cooperation pushes last round's cooperation count to threshold m.
    - Defects when threshold met without me to free-ride on others' cooperation.
    - On last round, cooperates only if cooperation will secure threshold reward.
    - Never cooperates otherwise, punishing free-riders and maximizing individual payoff.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number
        last_idx = t - 1
        last_coop_count = history.opponent_actions[last_idx].sum()
        current_round = t + 1
        if current_round == 1:
            return Action.D
        if current_round < self.r:
            if last_coop_count >= self.m:
                return Action.D
            elif last_coop_count == self.m - 1:
                return Action.C
            else:
                return Action.D
        if current_round == self.r:
            if last_coop_count == self.m - 1:
                return Action.C
            else:
                return Action.D
        return Action.D