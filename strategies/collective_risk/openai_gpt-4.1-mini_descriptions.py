"""
Strategy descriptions for CollectiveRiskDescription.

Generated with:
- Provider: OpenAI
- Model: gpt-4.1-mini
"""


description_COOPERATIVE_1 = '''
Below is a cooperative strategy design tailored for the Collective Risk Dilemma as specified. The goal is to contribute sufficiently to reach the threshold m cooperators each round, maximizing collective gains over r rounds, while adapting to observed player behavior in this repeated simultaneous game.

---

## Overview

- **Goal:** Achieve at least m cooperators every round to secure the reward k for all.
- **Key challenge:** Without communication, coordinate on cooperating enough each round, avoiding exploitation by persistent defectors.
- **Approach:**  
  - Start cooperatively in round 1 to signal willingness.
  - Track opponents’ cooperation rates to estimate whether the group is cooperating.
  - If the minimum threshold m is met or nearly met, continue cooperating.
  - If cooperation rates drop, respond by defecting to punish and incentivize cooperation.
  - In the very last round, defect to exploit any residual cooperation (standard backward induction in finitely repeated dilemmas).
  
---

## Decision Rules

Let variables per round t:

- C_t = set of players who cooperated in round t (observed)
- |C_t| = number of cooperators in round t
- coop_rate_i = fraction of rounds player i cooperated so far
- coop_estimate = estimated cooperators expected this round
- threshold m, total players n, reward factor k, rounds r

### Round 1

- **Action:** Cooperate (C)  
- **Reason:** Signal cooperative intent, encourage others to cooperate, build trust.

### Subsequent rounds t ∈ {2,...,r-1}

- **Calculate:**  
  - Count cooperators in previous round |C_{t-1}|  
  - If |C_{t-1}| ≥ m (threshold met):  
    - Cooperate this round to maintain cooperation.  
  - Else if |C_{t-1}| < m:  
    - Defect to punish the group for failing threshold, signaling need for more cooperation.  
  - Additionally, if any player has defected persistently or very low coop_rate_i (e.g., < 50% so far), consider defecting against them by defecting yourself to minimize exploitation.

- **Fallback:** If unsure, cooperate to promote group benefit.

### Last round t = r

- **Action:** Defect (D)
- **Reason:** In a finitely repeated game with no future punishment, defecting in the last round maximizes immediate payoff by exploiting any cooperating opponents who may still cooperate.

---

## Strategy Pseudocode

```python
initialize coop_history = dict()  # key: player i, value: list of actions per round (C/D)

for t in 1 to r:
    if t == 1:
        action = 'C'  # start cooperatively
    elif t == r:
        action = 'D'  # last round defect for immediate gain
    else:
        # Analyze previous round cooperation
        last_round_cooperators = count_cooperators(t-1)
        
        # Calculate cooperation rates per player so far
        for player in players:
            coop_rate[player] = count_C_in_history(player) / (t-1)
        
        # If threshold met last round, maintain cooperation
        if last_round_cooperators >= m:
            action = 'C'
        else:
            # Threshold not met last round: punish defectors by defecting next round
            action = 'D'

        # Optional enhancement: if some players have very low coop_rate,
        # and their defection hurts reaching threshold, consider defecting to pressure

    # Update coop_history with own action for future rounds
    update coop_history with own action at round t
```

---

## Notes on Cooperative Mindset

- The strategy **starts by cooperating** to foster trust and collective benefit.
- It **maintains cooperation when the group also cooperates**, reinforcing stable mutual cooperation.
- It **punishes failure to cooperate** via defections, signaling non-tolerance for free-riding.
- It **exploits defectors last round**, consistent with standard finite horizon incentives.
- The use of **publicly observable actions** ensures all players can infer intentions.
- This strategy balances **forgiveness** (return to cooperation when threshold met) and **deterrence** (punish when cooperation fails).

---

## Handling Edge Cases

- **Small deviations around threshold:** If |C_{t-1}| is very close to m (e.g., m - 1), consider cooperating anyway recognizing near success. But for clarity, maintain the threshold rule strictly so as not to be exploited.
- **If opponent switches strategies mid-game:** The punishment via defection will discourage persistent defection.
- **If all defect initially:** repeated defection will likely persist until if/when some players start cooperating.
- **In games with very few rounds (r small):** backward induction is more impactful, so the last-round defection is important.
- **In games with many rounds:** cooperation stabilizes over time due to repeated incentives.

---

# Summary

This simple yet principled strategy ("Threshold Cooperation with Last-Round Defection") uses observable info and past outcomes to sustain cooperation, respond to defection, and maximize expected total payoffs in repeated collective risk dilemmas. It embodies strong cooperative intent while pragmatically handling exploitation risks and the last round incentive to defect.
'''

description_COOPERATIVE_2 = '''
Here is a cooperative strategy design tailored for the Collective Risk Dilemma repeated game:

---

### Strategy Name: *Conditional Cooperate with Forgiveness*

---

### Intuition:
- Cooperation only yields the maximal group benefit if *at least* m players cooperate.
- Defection yields a higher payoff if enough others cooperate to pass the threshold.
- Since the game is repeated, we can use reciprocity to sustain cooperation.
- We want to avoid exploitation and punish defectors, but also forgive so cooperation can re-emerge.
- The first round sets a baseline of trust.
- The last round is tricky because defection tends to dominate; use backward induction heuristics to handle it.

---

### Decision Rules (per round t):

**Input observed till round t-1:**
- For all players j≠i: record their actions \( a_{j,\tau} \) for every previous round τ < t.
- Your own past actions \( a_{i,\tau} \).
- Parameters known: n, r, m, k.

---

### First round (t=1):
- Cooperate (C) unconditionally.
  
**Rationale:** Establish trust baseline. Cooperation in the first round signals willingness to engage with the group.

---

### Subsequent rounds (1 < t < r):

1. **Estimate cooperation level last round:**  
   Count how many players cooperated \( \#C_{t-1} \).

2. **Threshold check:**
   - If \( \#C_{t-1} \geq m \) (threshold met last round)  
     → continue cooperating this round.
   
   - Else (threshold not met last round)  
     → defect this round to avoid being exploited.

3. **Additional forgiveness rule:**
   - If some defectors switched to cooperate in the last round, or cooperation numbers are inching close to m (e.g., \( \#C_{t-1} = m-1 \))  
     → cooperate to encourage trust rebuilding.

4. **Detect persistent defectors:**
   - If a player j defected in two or more consecutive rounds, mark as "defector".  
   - Consider their cooperation unlikely; condition your cooperation on majority cooperating players excluding persistent defectors.

---

### Last round (t = r):

- **Backward Induction Consideration:**

  Typically, in single-shot PD-type games, rational players defect in the last round. However, since the **reward k > 1** and threshold m cooperators are required, cooperating may still yield group benefit if enough others do so.

- **Rule:**

  - If cooperation threshold was met in \( t = r-1 \), *cooperate* to secure the reward one last time.
  - Otherwise, *defect* to avoid being exploited — cooperation is unlikely to be reciprocated.
  - Alternatively, if your payoff from cooperating last round is less than defecting (considering previous observed behaviours), defect.

---

### Summary in Pseudocode:

```python
function decide_action(t, history, n, m, r):
    # history: list of rounds, each round is list of player actions ['C' or 'D']

    if t == 1:
        return 'C'  # start cooperatively

    # Count cooperators last round
    last_round = history[t-2]  # zero-based indexing
    num_cooperators = last_round.count('C')

    # Detect persistent defectors
    defector_counts = {}
    for player_idx in range(n):
        consecutive_D = 0
        max_consec = 0
        for round_idx in range(t-2, -1, -1):
            if history[round_idx][player_idx] == 'D':
                consecutive_D +=1
            else:
                max_consec = max(max_consec, consecutive_D)
                consecutive_D = 0
        max_consec = max(max_consec, consecutive_D)
        defector_counts[player_idx] = max_consec

    persistent_defectors = [p for p, count in defector_counts.items() if count >= 2]

    # Effective cooperation count excluding persistent defectors
    effective_cooperators = 0
    for p in range(n):
        if p not in persistent_defectors and last_round[p] == 'C':
            effective_cooperators += 1

    # Decision logic
    if t < r:
        if effective_cooperators >= m:
            return 'C'  # cooperate if threshold met excluding defectors
        elif effective_cooperators == m - 1:
            return 'C'  # forgiveness, try to build trust
        else:
            return 'D'

    else:  # last round
        if effective_cooperators >= m:
            return 'C'  # secure one last round of cooperation
        else:
            return 'D'  # defect if unlikely to get cooperation

```

---

### Additional Notes:

- **Why exclude persistent defectors?** Because they degrade trust and coordination, ignoring their cooperation attempts reduces being exploited.

- **Why forgive at \( m-1 \)?** Because just missing threshold by 1 is a sign we may restore cooperation.

- **Why unconditional cooperate on first round?** Sets a cooperative tone without bias.

- **Why defect if threshold not met?** To avoid being exploited perpetually by defectors.

---

### Cooperation Alignment:

- This strategy rewards mutual cooperation by cooperating whenever others do.

- It punishes defectors by defecting when threshold is missed.

- Incorporates forgiveness to avoid permanent break down of cooperation.

- Uses information from previous rounds (perfect info assumption) to adjust behavior.

- Balances self-interest and group interest to maximize long-term rewards.

---

This strategy should encourage stable cooperation in the repeated Collective Risk Dilemma, resisting exploitation while being open to rebuilding cooperation.
'''

description_AGGRESSIVE_1 = '''
Here is an aggressive strategy tailored for the Collective Risk Dilemma repeated game, emphasizing maximizing immediate payoffs, exploiting cooperation of others, and minimizing own contribution costs. The strategy aims to defect whenever it is safe or profitable and only cooperate to push the group over the threshold when it strictly benefits the player.

---

### Aggressive Strategy: "Opportunistic Exploiter"

---

### Intuition:
- **Defect by default**: Preserve your endowment (keep the 1).
- **Exploit cooperators**: If others are cooperating enough to reach or exceed the threshold m without your help, defect to get payoff 1 + k > 1.
- **Cooperate only when pivotal**: Cooperate if you must contribute to reach threshold m, so the group gets the reward k (better than just 1).
- **Punish unsuccessful cooperation swiftly**: If previous rounds failed to achieve threshold, do not waste own endowment cooperating.
- **Last round caution**: On the final round defect unless others' behavior guarantees threshold without you (no incentive to be "nice" after last round).

---

### Formal Decision Rules:

Let t = current round index (1 to r),  
C_t = number of cooperators (excluding you) in round t (known after round t),  
m = threshold, k = reward multiplier, n = total players.

---

### Per-round decision-making:

1. **Round 1 (t = 1):**
   - Defect (D).
   - Reason: No history to rely on; maximize immediate private payoff by defecting.

2. **Round t (1 < t < r):**
   - From previous rounds 1 to t-1, observe cooperators count each round.
   - Estimate whether others are cooperating enough to meet m without your help.
   - If in previous rounds could reach threshold without your cooperation, **defect**.
   - If not, check if your cooperation is pivotal this round (if others cooperate >= m - 1):
     - If so, **cooperate** to push group over threshold and gain k.
   - Else, **defect**.

3. **Round r (final round):**
   - Cooperate only if others cooperate >= m - 1 (i.e., your cooperation can push group over threshold).
   - Else **defect**.
   - Reason: No future rounds to incentivize cooperation; better to defect unless strictly necessary to secure reward.

---

### Edge Cases:

- **If never reached threshold in previous rounds**: Do not sacrifice your endowment; always defect until pivotal.
- **If other players consistently cooperate above threshold alone**: always defect.
- **If past rounds show oscillating or unpredictable cooperation (sometimes below threshold, sometimes above)**: Use last round logic to defect unless pivotal.
- **If exactly m-1 others cooperate in a round, cooperate to push reward**; else defect.

---

### Pseudocode:

```python
def aggressive_strategy(t, r, m, k, n, history):
    # history is a list of previous rounds, each element:
    #   {'cooperators': count_excluding_self, 'actions': [C/D for players]}
    
    if t == 1:
        # No info - defect
        return 'D'
    
    # Analyze previous rounds to see if others meet threshold without you
    others_meet_threshold = any(
        round_info['cooperators'] >= m
        for round_info in history
    )
    
    # Check current round predicted cooperators from observed history (not known yet)
    # Instead, estimate from last round cooperators count:
    last_cooperators = history[-1]['cooperators'] if history else 0
    
    # Determine if cooperation is pivotal
    # If last_cooperators >= m: threshold reached without you, so defect
    # If last_cooperators == m -1: you can push over threshold - cooperate
    # Else defect
    
    if t < r:
        if others_meet_threshold:
            # They can meet threshold without you, so defect
            return 'D'
        else:
            if last_cooperators == m -1:
                return 'C'  # pivotal cooperation
            else:
                return 'D'
    else:  # t == r, last round
        if last_cooperators >= m -1:
            # cooperate to secure reward one last time if possible
            return 'C'
        else:
            # defect - no future benefit, maximize private payoff
            return 'D'
```

---

### Summary:

- Defect first round.
- Exploit others’ cooperation unless you must cooperate to push over threshold.
- Cooperate only if pivotal (others cooperating exactly m-1).
- Defect last round unless pivotal.
- Punish failed cooperation rounds by not contributing.

This aggressively maximizes your own payoffs by defecting whenever feasible and only cooperating to secure the collective payoff when strictly beneficial to you. It exploits cooperative opponents while protecting your own endowment.
'''

description_AGGRESSIVE_2 = '''
**Objective:**  
Design an *aggressive* strategy for the repeated Collective Risk Dilemma that seeks to maximize individual payoff, leveraging the payoff structure to exploit cooperators while minimizing own costly cooperation.

---

### Key insights from game structure and payoffs:

- Cooperating costs 1 unit in that round; defecting retains 1 unit privately.
- If ≥ m cooperate, all get reward `k` (> 1).
- If fewer than m cooperate, no reward.
- Defectors rewarded *more* than cooperators when threshold met:
  - Cooperators: 0 + k
  - Defectors: 1 + k
- Defectors get full private endowment plus reward if threshold met, making defection appealing when threshold is met.
- When threshold not met, defection yields strictly higher payoff (1 versus 0).
- Over many rounds, defectors can accumulate more payoff if threshold is met.
- However, if everyone defects, no reward is ever granted, so payoff is only 1 per round.
- The threshold `m` is crucial: cooperation only provides reward if enough players cooperate.
- Aggressive implies exploiting cooperators, enforcing own payoff maximization, even at some risk of no reward.


---

### Design considerations:

- **Start aggressive:** Try to defect first and see if others cooperate to meet threshold.
- **If threshold is not met:** keep defecting to avoid cooperation cost.
- **If threshold is met:** defect to free-ride on others’ cooperation.
- **Coordinate implicitly over rounds by adapting to observed cooperation counts.**
- **Use last round defecting to maximize final payoff (no future punishment possible).**

---

### Proposed aggressive strategy: **"Threshold Exploiter"**

---

#### Intuition:
- Always **defect first round**.
- Then:
  - If in previous round, threshold was met but player cooperated, switch to defect (free-riding).
  - If threshold was not met, continue defecting (no incentive to cooperate).
  - Exception: if continuously threshold not met, consider minimal cooperation to trigger threshold, but only minimally.
- On the last round, defect regardless (last round defect).

---

### Detailed decision rules:

Let `t` be current round (`1 <= t <= r`), and `C_t` be count of cooperators in previous round `t-1` (for `t=1`, no history).

- **Round 1:** Defect (`D`)
  - No history, start aggressively by defecting.

- **Rounds 2 to r-1:**

  *Check previous round outcome:*  
  - If `C_{t-1} >= m` (threshold met previously):
    - If I cooperated in round `t-1`:
      - Switch to defect to exploit reward paid out by others.
    - Else (I defected previously):
      - Continue defecting (free ride consistently).
  - Else (threshold not met previously):
    - Defect again (to avoid cooperation cost).
    - Exception: if in last two rounds the threshold was never met, try minimal cooperation to attempt hitting threshold next round.
      Specifically:
      - If currently defecting and see fewer than `(m-1)` cooperators historically, try cooperating this round *only if* you estimate that your cooperation can push count ≥ m.
      - Given no communication, this is a bluffing move, but part of an aggressive probing approach.

- **Round r (final round):** Defect unconditionally.
  - No future punishment from defection in last round.
  - Maximize private endowment in final payoff.

---

### Pseudocode:

```python
def aggressive_strategy(t, history, n, r, m, k, my_actions):
    # history: list of dicts per round with 'cooperators' count, each player's action
    # my_actions: list of my past actions

    if t == 1:
        # No history, start defect aggressively
        return 'D'

    prev_cooperators = history[t-2]['cooperators']  # coops in round t-1
    my_prev_action = my_actions[-1]

    if t == r:
        # Last round: always defect
        return 'D'

    # Previous threshold met
    if prev_cooperators >= m:
        if my_prev_action == 'C':
            # Switch to defect to exploit cooperators
            return 'D'
        else:
            # Continue defecting to free ride
            return 'D'
    else:
        # Threshold not met last round
        if t >= 3:
            # Check if threshold failed repeatedly last two rounds
            prev_prev_cooperators = history[t-3]['cooperators']
            if prev_cooperators < m and prev_prev_cooperators < m:
                # Aggressive probe: cooperate if believe you can reach threshold
                # Estimate if others are cooperating enough - if prev_cooperators == m-1, your cooperation triggers reward
                if prev_cooperators == m - 1:
                    return 'C'  # Cooperation to try push threshold hit and exploit reward next rounds
                else:
                    # Otherwise defect aggressively
                    return 'D'
            else:
                # Else defect
                return 'D'
        else:
            # Early rounds with no clear repeated failure - defect aggressively
            return 'D'
```

---

### Summary

- **Always defect first round** — be immediately aggressive.
- **If threshold met and you cooperated before**, switch to defect and exploit others’ cooperation.
- **If threshold met and you defected before**, keep defecting to continually free ride.
- **If threshold not met, keep defecting** since cooperating is costly without payoff.
- **If threshold has repeatedly not been met**, try minimal cooperation (only if your cooperation will push threshold) to manipulate threshold achievement and exploit others.
- **Defect last round always** to maximize final payoff.

---

### Why aggressive?

- Strategy prioritizes defecting to maximize private payoff.
- Exploits cooperators whenever the collective survives threshold.
- Uses minimal probing cooperation only when necessary and to own advantage.
- Never willingly pays the cooperation cost except in carefully calculated last-ditch attempt to trigger threshold.
- No trust or cooperative punishment—only self-maximizing actions.

---

This strategy should achieve high payoffs by aggressively free-riding, exploiting cooperators, and leveraging repeated game history without costly goodwill cooperation.
'''

description_COOPERATIVE_3 = '''
Below is a fully cooperative, conditional cooperation strategy designed for the Collective Risk Dilemma under repeated interaction and perfect monitoring. It aims to achieve the threshold number of cooperators each round to reliably gain the reward, while minimizing exploitation.

---

### Intuition

- The game rewards groups that achieve **at least m cooperators** by giving everyone an additional payoff of **k**.
- Cooperating costs 1, defecting costs 0.
- Cooperative individuals get payoff 0 + k when threshold is met; defectors get payoff 1 + k.
- Defectors “freeride,” gaining more *per round* when threshold met; cooperators pay a cost to enable the reward.
- Repeated rounds with full observability allow for conditional cooperation: punish defectors by defecting next round.
- Goal: maintain cooperation at threshold level every round to maximize joint payoffs.

---

### Strategy Name: *Conditional Threshold Cooperation*

---

### Parameters

- `n`: number of players
- `m`: threshold number of cooperators required (1 < m < n)
- `r`: total rounds
- `k`: reward factor (k > 1)

---

### Decision Rules

#### Round 1 (no history)

- **Cooperate** unconditionally (to try to seed cooperation).

#### Subsequent rounds (round t > 1)

- Count number of cooperators in round `t-1`: `C_{t-1}`
- From round 2 onward, to enforce conditional cooperation:
    - If `C_{t-1} >= m` (threshold was met last round):
        - Cooperate **if you cooperated last round**
        - Defect **if you defected last round**

      *Interpretation:* Reward cooperation; do not apologize for prior defection but do not punish successful cooperation.

    - If `C_{t-1} < m` (threshold not met last round):
        - Cooperate if enough others cooperated last round to reach threshold minus one (i.e., if `C_{t-1} = m - 1`, cooperate to try to reach threshold)
        - Otherwise, defect (to preserve private payoff—cooperation won't help if threshold failed badly)

---

#### Last Round (round r)

- Cooperation can still pay off due to k > 1, so keep same logic as above.

---

### Notes on Behavior

- By conditioning cooperation on previous round success, this strategy encourages others to cooperate consistently.
- Defectors are punished by losing cooperation support next round.
- If the group fails to meet threshold, cooperators reduce risk of exploitation by defecting unless close to threshold.
- Initial unconditional cooperate allows a chance to form cooperation early.
- This strategy aims to stabilize around threshold number cooperating every round.

---

### Pseudocode

```python
# Inputs:
# history - list of actions for all players for rounds < t
# my_actions - list of own actions for rounds < t
# current_round (t), total rounds r
# parameters: n, m, k

def decide_action(history, my_actions, t, r, n, m, k):

    if t == 1:
        # First round: seed cooperation
        return 'C'

    else:
        # Count how many cooperated last round
        last_round_actions = history[t-2]  # zero-indexed rounds
        num_cooperators = sum(1 for a in last_round_actions if a == 'C')
        my_last_action = my_actions[-1]

        if num_cooperators >= m:
            # Threshold met last round
            if my_last_action == 'C':
                # Reward cooperation with cooperation
                return 'C'
            else:
                # Continue defecting if previously defected
                return 'D'

        else:
            # Threshold not met last round
            if num_cooperators == m - 1:
                # Almost met threshold, try cooperating to help reach it
                return 'C'
            else:
                # Failed badly, defect to avoid cost
                return 'D'
```

---

### Summary

- **First round:** Always cooperate.
- **If previous round met threshold:** repeat previous action.
- **If previous round just missed threshold by one:** cooperate to push over threshold.
- **If previous round failed threshold badly:** defect to avoid cost.
- **No differentiation based on round number, including last round.**

This strategy balances optimism (seeding cooperation) with a strong conditional enforcement mechanism to stabilize collective cooperation just enough to reach threshold every round — maximizing returns and exemplifying cooperative mindset under repeated interaction and perfect monitoring.
'''

description_COOPERATIVE_4 = '''
Below is a cooperative strategy tailored for the Collective Risk Dilemma with the given parameters and constraints.

---

## Strategy Name: "Conditional Collective Cooperation"

### Intuition
The game rewards reaching or exceeding the cooperation threshold *m* each round since players who defect still benefit from the reward *k*. However, defectors gain an immediate private payoff advantage by withholding contribution, potentially undermining cooperation over time.

This strategy seeks to:
- Promote cooperation from the start.
- Forgive occasional defections to avoid retaliatory spirals.
- Punish consistent defection to protect collective interests.
- Adapt behavior as the number of rounds remaining decreases, recognizing endgame effects.

---

### Decision Rules

**Notation**  
- `t`: current round index, 1 ≤ t ≤ r  
- `Actions_t`: vector of all players' actions in round t  
- `MyHistory`: my past actions and observed payoffs  
- `CooperatorCount_t`: number of players who cooperated in round t  
- `Threshold m`, Number of players `n`, Reward factor `k`  
- `DefectionTolerance`: max tolerated defections by a player before considering them defectors (e.g., 1 or 2)  
- `RemainingRounds = r - t`

---

### 1. First Round (t = 1)
- Cooperate unconditionally: `play C`  
  Rationale: Establish goodwill and attempt to reach threshold minimum immediately.

---

### 2. Intermediate Rounds (1 < t < r)

**Step A: Check collective cooperation last round**  
- If `CooperatorCount_{t-1} >= m`, then collective cooperation succeeded last round.  
  -> Continue cooperating this round.

- Else (failed last round), try to identify defectors and condition behavior accordingly.

**Step B: Identify potential defectors**  
- For each player j, count total defections in history:  
  `Defections_j = count of rounds where j played D`

- If `Defections_j > DefectionTolerance`, flag player j as "Defector".

**Step C: Strategy towards different player types**  
- Since no communication and no binding agreements, the strategy cannot discriminate actions between players, but can condition on the group's overall cooperation.

- If number of suspected Defectors ≥ (n - m + 1) (i.e., enough defectors to make threshold unreachable), defect this round to avoid being exploited.

- Else (threshold likely attainable), cooperate to encourage reaching threshold.

---

### 3. Last Round (t = r)
- Since no future punishment is possible, blame is ineffective; rational self-interest suggests defecting unless guaranteed cooperation produces higher payoff.

- If at round r-1, cooperation levels ≥ m, attempt to cooperate to maintain group payoff.

- Otherwise, defect at last round.

---

### 4. Edge Cases and Safeguards

- **Sporadic Defections:** If a player defects once or twice by mistake or experimentation, remain cooperative to allow recovery.

- **If threshold not met in multiple consecutive rounds (> 2):** begin defecting to protect own payoff.

- **If the threshold is extremely low (close to 1):** more leniency toward potential defectors.

- **If threshold is close to n:** expect difficulty meeting threshold; act more cautiously.

---

### Pseudocode Summary

```python
def decide_action(t, r, n, m, k, MyHistory, ActionsHistory, DefectionTolerance=1):
    if t == 1:
        return 'C'  # Cooperate first round

    # Count cooperators last round
    last_round_actions = ActionsHistory[t-1]
    CooperatorCount = sum(1 for a in last_round_actions if a == 'C')

    # Count defections per player across history
    defections_per_player = [0]*n
    for round_actions in ActionsHistory[1:t]:
        for idx, act in enumerate(round_actions):
            if act == 'D':
                defections_per_player[idx] +=1

    suspected_defectors = [idx for idx, dcount in enumerate(defections_per_player) if dcount > DefectionTolerance]

    # If last round success: cooperate to maintain goodwill
    if CooperatorCount >= m:
        if t == r:
            # Last round and threshold met last round - cooperate to maintain collective reward
            return 'C'
        else:
            # Intermediate round and success - cooperate to keep cooperation stable
            return 'C'

    else:
        # Threshold not met last round
        # If too many defectors to reach threshold, defect
        if len(suspected_defectors) >= (n - m +1):
            return 'D'  # Protect own payoff

        else:
            # Otherwise try cooperating to reach threshold
            if t == r:
                # Last round and threshold unlikely achievable - defect
                return 'D'
            else:
                return 'C'
```

---

### Summary

| Round       | Condition                          | Action                   |
|-------------|----------------------------------|--------------------------|
| 1           | Always                           | Cooperate                |
| Intermediate| Threshold met last round         | Cooperate                |
| Intermediate| Threshold missed, many defectors | Defect                   |
| Intermediate| Threshold missed, few defectors  | Cooperate                |
| Last Round  | Threshold met last round         | Cooperate                |
| Last Round  | Threshold missed last round      | Defect                   |

---

### Why this works as a cooperative strategy

- Begins with full cooperation to signal goodwill.
- Rewards collective success with continued cooperation, supporting stable cooperation equilibria.
- Forgives occasional defections, preventing breakdown from a single deviation.
- Defects only to protect self when group cooperation is hopeless (too many defectors).
- Recognizes endgame incentives for defection and adapts accordingly.
- Encourages cooperation long-term while protecting from exploitation.

---

If you want, I can also help formulate a more sophisticated approach (e.g., probabilistic cooperation, Tit-for-Tat variants adapted to collective thresholds), but the above gives a clear, interpretable cooperative baseline.
'''

description_COOPERATIVE_5 = '''
**Strategy Name: Conditional Threshold Cooperation (CTC)**

---

### Intuition and Goals

- The main dilemma is to collectively reach the threshold **m** cooperators to unlock the reward **k**.
- Cooperation means a private cost (1) but helps unlock the collective reward.
- Defection gains the private payoff without cost but risks losing the reward if too many defect.
- Since the game is repeated with perfect monitoring, credible conditional strategies can sustain cooperation.
- The aim is to maintain cooperation once established, but punish defection sufficiently to deter free-riding.

---

### High-Level Strategy Summary

- **Round 1:** Cooperate to signal willingness and attempt to form a cooperative coalition.
- **Rounds 2 to r-1:** Cooperate if in previous round ≥ m cooperated actions observed; otherwise defect (punishment phase).
- **Last round (round r):** Defect to avoid exploitation (backward induction).
- **Punishment phase:** Defect indefinitely if cooperation threshold is not met in any round (grim trigger style).
- **Recovery:** No recovery once punishment triggered (to keep the threat credible).

The strategy aligns with the cooperative mindset: it tries to maximize collective reward but punishes defection decisively to protect fairness and deter free-riding.

---

### Detailed Decision Rules

**Parameters:**
- Inputs available each round:
  - `t`: current round number (1 ≤ t ≤ r)
  - `past_cooperation_counts`: counts of how many players cooperated in each previous round
- Constants:
  - `n`, `m`, `r`, `k` as given

---

**Step 1: Initialization**

- Set a boolean flag `punish` := False (starts with no punishment)
- Maintain a variable `last_round_coop_count` := number of cooperators in previous round (initially None)

---

**Step 2: Action selection per round**

```
if t == 1:
    # First round: attempt cooperation to initiate collective action
    action = Cooperate (C)

elif t == r:
    # Last round: defect to avoid being exploited without future punishment possibility
    # This is classical backward induction in finitely repeated dilemmas
    action = Defect (D)

else:
    if punish == True:
        # We are in punishment phase: defect indefinitely
        action = Defect (D)

    else:
        # Not punishing yet: check if cooperation threshold was met previously
        if last_round_coop_count is not None and last_round_coop_count >= m:
            # Previous round had enough cooperators, reciprocate cooperation
            action = Cooperate (C)
        else:
            # Threshold missed -> enter punishment phase to deter free-riding
            punish = True
            action = Defect (D)
```

---

**Step 3: Update after observing previous round**

- At the end of each round t (except the first), record:

```
last_round_coop_count = number of players that chose C in round t
```

If in any previous round `last_round_coop_count < m`, set `punish` := True, which triggers permanent defection punishment.

---

### Intuition and Rationale

- Cooperate initially to signal and attempt threshold cooperation.
- If threshold cooperation happens in previous round, reciprocate to sustain cooperation.
- If threshold is missed, defect forever to punish and incentivize others to cooperate in future games.
- Defect in last round because cooperation cannot be enforced by future punishments (endgame effect).
- This strategy is cooperative yet self-protective, balancing the risk of exploitation with incentive to maintain cooperation.
- The grim trigger punishment ensures that free riders are discouraged because defection eventually leads to loss of collective reward.

---

### Pseudo-code Summary

```
Initialize:
    punish := False
    last_round_coop_count := None

For each round t in 1 to r:
    if t == 1:
        action := C
    else if t == r:
        action := D
    else:
        if punish == True:
            action := D
        else if last_round_coop_count >= m:
            action := C
        else:
            punish := True
            action := D

    Execute action

    Observe others' actions in round t
    last_round_coop_count := count of cooperators in round t

    if last_round_coop_count < m:
        punish := True
```

---

### Handling Edge Cases

- **First round no history:** Always cooperate to try building trust.
- **Threshold exactly met (m cooperators):** Good, continue cooperation.
- **Threshold not met (fewer than m):** Punish defectors from next round on to enforce discipline.
- **Last round:** Always defect since no future punishment is possible.
- **If all defect from start:** punishment already in place, continue defecting.
- **If others exploit and defect early:** punishment phase triggered quickly to protect your payoff.

---

### Summary

This strategy is **conditionally cooperative with harsh punishment**:

- It begins by cooperating.
- Continues cooperating only if group cooperation threshold met previously.
- Immediately switches to permanent defection to punish and discourage free-riding if threshold fails.
- Defects at last round per backward induction.
- This approach promotes stable cooperation and deters exploitation in this repeated collective risk dilemma.
'''

description_COOPERATIVE_6 = '''
**Strategy Name: Conditional Reciprocal Cooperation (CRC)**

---

### Objective:
Achieve and maintain the cooperative threshold (≥ m cooperators each round) to secure the reward *k* for all players, maximizing collective payoffs and fostering mutual cooperation throughout the repeated game.

---

### Core Idea:
- Cooperate initially to signal willingness to cooperate.
- Continue cooperating if enough players cooperated in the previous round, indicating a stable cooperative environment.
- Defect temporarily if cooperation drops below the threshold, signaling discontent and pressuring others to return to cooperation.
- In the last round, cooperate if collective cooperation was maintained recently; otherwise, defect to maximize last-round payoff.
  
---

### Detailed Decision Rules:

#### Parameters Known to the Strategy:
- **n, r, m, k** (game parameters)
- History of all players' actions and payoffs in previous rounds.

---

### Round 1 (Initialization):

- **Action:** Cooperate
- **Rationale:** Establish initial trust and set a cooperative norm.

---

### Intermediate Rounds (2 to r-1):

1. **Count of Cooperators in previous round:**  
   Let **prev_coop_count** = number of players who played C in round *t-1*.

2. **Threshold check:**  
   - If **prev_coop_count ≥ m**, cooperation worked last round, so **cooperate** this round.
   - Else, cooperation failed last round, so **defect** this round.

3. **Additional nuance (optional):**
   - Track if an individual player defected repeatedly; if so, consider defecting to punish.
   - Or forgive occasional defections by tolerating 1 round below threshold before defecting.

---

### Final Round (Round r):

- Observe cooperation in round *r-1*:

  - If **prev_coop_count ≥ m** (cooperation was stable), **cooperate** to maximize joint reward.

  - Else, **defect** to gain private payoff, as no future rounds remain for retaliation/punishment.

---

### Edge Cases and Handling:

- **If cooperation is lost temporarily:**  
  Defect once to signal the issue, encouraging others to return to cooperation.

- **If no cooperation ever emerges (all defect round 1):**  
  Defect all rounds to avoid loss from unilateral cooperation.

- **If partial cooperation near threshold (e.g., few players cooperating but < m):**  
  Defect to signal dissatisfaction but monitor for return to cooperation.

- **If uncertain about others' motives (noise):**  
  Use a “forgiveness” window — tolerate one round below threshold before defecting, to prevent breakdowns due to single mistakes.

---

### Pseudocode:

```python
def decide_action(round_t, history):
    # Inputs:
    # round_t: current round number (1-indexed)
    # history: list of prior rounds actions, e.g. history[t-1] is dict {player_id: action}
    
    if round_t == 1:
        return 'C'  # Always cooperate first round
    
    prev_actions = history[round_t - 2]  # actions in round t-1
    prev_coop_count = sum(1 for a in prev_actions.values() if a == 'C')
    
    if round_t < r:  # Intermediate rounds
        if prev_coop_count >= m:
            return 'C'  # Continue cooperation
        else:
            # Optionally: Implement forgiveness by checking round t-2 cooperation if available
            # For simplicity, defect now to signal punishment
            return 'D'
    else:
        # Final round logic
        if prev_coop_count >= m:
            return 'C'  # Final round cooperation to maximize reward
        else:
            return 'D'  # Defect if cooperation unstable
```

---

### Why This Strategy Is Cooperative:

- It **opens with cooperation**, signaling willingness to achieve joint success.
- It **conditionally cooperates** only when evidence shows cooperation is reciprocated, avoiding exploitation.
- It **punishes defection by defecting** if cooperation breaks down, incentivizing others to maintain cooperation.
- It **prefers cooperation at the end** if it can benefit all, otherwise defects pragmatically.
- It **balances generosity and self-interest** to support stable group cooperation in repeated rounds.

---

### Benefits Against Unknown Opponents:

- Encourages forming a cooperative norm quickly.
- Adapts to opponents’ behaviors instead of blindly cooperating or defecting.
- Uses transparent rules compatible with perfect information and common knowledge assumptions.
- No communication needed; cooperation inferred from past actions.
- Forgiveness and punishment help stabilize cooperation in noisy or strategic environments.

---

**Summary:** Start by cooperating, continue cooperating only if enough players cooperated previously, defect as penalty if cooperation fails, and cooperate in the last round if cooperation was sustained. This conditional reciprocity fosters stable cooperation maximizing collective payoffs.
'''

description_COOPERATIVE_7 = '''
**Strategy Name: Gradual Threshold Cooperation (GTC)**

---

### Intuition

- The cooperative equilibrium in this game requires at least **m** players to cooperate each round.
- Payoffs incentivize free-riding when threshold is met because defectors get **1 + k**, cooperators get **k** only (0 + k).
- To maintain cooperation, players must ensure that defections are punished and cooperation is rewarded.
- Since the game is **repeated** and observability is perfect, the strategy uses punishment and forgiveness cycles to stabilize cooperation.
- Communication is not allowed, so all coordination is based on observed actions.

---

### Strategy Overview

- **Goal:** Achieve and maintain ≥ m cooperators per round to secure reward **k** for all.
- **First round:** Cooperate to establish cooperative baseline.
- **Subsequent rounds:**
  - Cooperate if in the previous round, **enough players (≥ m)** cooperated.
  - Defect temporarily if threshold was not met, to signal disapproval (punishment phase).
- **Last round:**
  - Cooperate if all previous rounds met threshold.
  - Defect otherwise (since no future retaliation is possible).
- Use **leniency** by forgiving occasional defections after punishment rounds, returning to cooperation if threshold stabilizes.

---

### Detailed Decision Rules

Let:

- `t` = current round index (1-based)
- `C_t` = set of players who cooperated at round t (including self)
- `threshold_met(t) = (|C_t| >= m)`
- `last_threshold = threshold_met(t-1)` if t > 1, else True (default cooperation baseline)
- `history` = full record of all players' actions in rounds [1..t-1]

---

#### At round t=1 (first round):

- **Action:** Cooperate (C)

Rationale: Start by cooperating to build trust and attempt cooperation.

---

#### At rounds 1 < t < r (intermediate rounds):

- If **last_threshold == True** (threshold met previous round):

  - Cooperate (C) to maintain cooperation.

- Else (threshold not met in previous round):

  - Defect (D) to punish non-cooperation.

- Exception (for forgiveness): If your previous action was defect (punishing), and threshold still fails for 2 consecutive rounds, cooperate in the next round anyway to attempt re-establish cooperation.

---

#### At round t = r (last round):

- If threshold met in *all* previous rounds (t = 1..r-1), cooperate (C)—if you have sustained cooperation, keep cooperating.

- Else, defect (D) — no future punishment possible, so revert to defection if cooperation was not stable.

---

### Special Notes

- Cooperation depends only on *whether threshold was met*, not on individual defections since defectors get higher immediate payoff. This avoids endless retaliation cycles against defectors exploiting mild cooperators.
- Defect only when group cooperation breaks down, signaling defectors that cooperation will not be tolerated unconditionally.
- A sequence of at most one punishment round is allowed before forgiveness is attempted.
- The forgiveness mechanism is critical to avoid permanent breakdowns from occasional mistakes.

---

### Pseudocode

```python
def decide_action(t, history, n, m, r):
    # history: list of tuples of length (t-1) where each tuple is the set of cooperating players in that round
    
    # Round 1, start cooperative
    if t == 1:
        return 'C'
    
    # Check if threshold was met in previous round
    last_round_cooperators = history[-1]
    last_threshold = (len(last_round_cooperators) >= m)
    
    # Check how many consecutive rounds threshold failed (for forgiveness logic)
    consecutive_failures = 0
    for past_round in reversed(history):
        if len(past_round) < m:
            consecutive_failures += 1
        else:
            break
    
    # Last round logic
    if t == r:
        # Did cooperation succeed in all previous rounds?
        full_success = all(len(c) >= m for c in history)
        if full_success:
            return 'C'
        else:
            return 'D'
    
    # Intermediate rounds
    if last_threshold:
        return 'C'
    else:
        # Punish defectors by defecting
        # Forgive if already punished for at least one round to avoid endless defection
        if consecutive_failures >= 2:
            return 'C'  # Forgive to re-start cooperation
        else:
            return 'D'
```

---

### Summary

| Condition                      | Action  |
|-------------------------------|---------|
| Round 1                       | Cooperate |
| Threshold met last round      | Cooperate |
| Threshold failed last round   | Defect (punish) unless punished at least 2 rounds consecutively, then cooperate (forgive) |
| Last round & all rounds successful | Cooperate |
| Last round & cooperation failed before | Defect |

---

### Why is this Cooperatively Aligned?

- Starts with cooperation, signaling willingness to cooperate.
- Maintains cooperation when group cooperates.
- Punishes non-cooperation to deter free-riding.
- Forgives after punishment to allow recovery.
- Maximizes chances to maintain ≥ m cooperators per round.
- Uses repeated interaction to sustain cooperation that yields payoffs greater than constant defection.

---

This strategy balances cooperation and disciplined punishment, incentivizing stable cooperation under your game conditions.
'''

description_COOPERATIVE_8 = '''
Below is a cooperative strategy tailored to the Collective Risk Dilemma. It is designed to build and sustain cooperation to reach the threshold \( m \) of cooperators per round, maximizing collective reward while protecting against exploitation.

---

### Strategy Overview

**Goal:**  
Ensure at least \( m \) players cooperate each round to trigger the reward \( k \), while minimizing own losses from being a lone cooperator.

**Key Idea:**  
- Begin cooperatively to signal willingness to cooperate.
- Use observed cooperation levels to infer group behavior.
- Adjust cooperation dynamically to stabilize cooperation near or above the threshold.
- Defect when cooperation is clearly failing or near game end to avoid needless costs.
- Always cooperate in last round if cooperation is sufficiently likely (to maximize final payoff).

---

### Decision Rules

#### Notation

- \( t \): current round index (1-based)
- \( r \): total rounds
- \( n \): number of players
- \( m \): cooperation threshold
- \( k \): reward multiplier
- \( C_t \): number of cooperating players observed in round \( t \) (including self)
- \( c_t \in \{0,1\} \): your action in round \( t \) (1 = cooperate, 0 = defect)
- \( \text{history} \): records of all players' actions by round

---

#### 1. First round (\( t=1 \)):

- Always **cooperate** (\( c_1 = 1 \))

*Rationale:*  
Signal willingness to cooperate and help test willingness of others.

---

#### 2. Intermediate rounds (\( 1 < t < r \)):

- Observe cooperation count \( C_{t-1} \) from previous round.
- Condition to **cooperate**:
  - If \( C_{t-1} \ge m \) (threshold met), continue cooperating to sustain cooperation.
  - Else if \( C_{t-1} = m-1 \), cooperate, assuming other players may boost cooperation.
  - Else, if cooperation is trending upwards or stable at or above \( m-1 \) (based on last 2-3 rounds), cooperate to nurture cooperation.
- Otherwise, **defect** to avoid being the only cooperator.
  
*Additional Notes:*

- Keep track of recent rounds' cooperation levels to estimate cooperation trend.
- If cooperation is consistently below \( m-1 \) for multiple rounds, shift to defect to avoid losses.
- If cooperation falls drastically, consider "forgiving" by cooperating once in later rounds to attempt restarting cooperation.

---

#### 3. Last round (\( t = r \)):

- If previous round's cooperation \( C_{r-1} \ge m - 1 \), **cooperate**.
- Else **defect**.

*Rationale:*  
Since no future rounds remain, no incentive to punish defectors or maintain reputation beyond this round. Cooperate only if cooperation threshold is almost met or likely to be met, else defect to avoid certain cost.

---

### Pseudocode

```python
def decide_action(t, r, n, m, history):
    # history: list of lists, each sublist is actions of all players in round t-1
    # Actions coded as 1=Cooperate, 0=Defect
    
    # First round: cooperate to signal
    if t == 1:
        return 1  # cooperate
    
    # Count cooperators in previous round
    last_round = history[-1]
    C_prev = sum(last_round)
    
    # Helper: check cooperation trend over last 3 rounds if available
    def cooperation_trend(hist, rounds=3):
        counts = [sum(hist[i]) for i in range(-rounds, 0) if i >= -len(hist)]
        if len(counts) < 2:
            return None
        return counts[-1] - counts[0]  # positive if increasing
    
    trend = cooperation_trend(history, rounds=3)
    
    # Last round logic
    if t == r:
        if C_prev >= m - 1:
            return 1  # cooperate if near threshold
        else:
            return 0  # defect
    
    # Intermediate rounds
    if C_prev >= m:
        return 1  # sustain cooperation
    
    if C_prev == m - 1:
        return 1  # try nudging cooperation
    
    if trend is not None and trend >= 0 and C_prev >= m - 1:
        return 1  # cooperation stable or improving
    
    # Cooperation failing; defect to avoid loss
    return 0
```

---

### Additional Comments

- **Forgiveness:** To avoid collapse from occasional defections, consider occasionally cooperating after short defection streaks, but this is implicitly addressed by cooperation trend checks.

- **No explicit punishment:** This strategy does not punish defectors directly to avoid spirals of defection, focusing on sustaining cooperation when possible.

- **Symmetry assumption:** Strategy assumes others are similar or responsive to cooperation levels, as no communication is allowed.

---

### Summary

| Round | Condition on previous cooperation | Action                 | Reason                       |
|-------|----------------------------------|------------------------|------------------------------|
| 1     | n/a                              | Cooperate              | Signal cooperative intent    |
| \( 1 < t < r \) | \( C_{t-1} \ge m \)               | Cooperate              | Sustain cooperation          |
|       | \( C_{t-1} = m-1 \)               | Cooperate              | Nudge cooperation            |
|       | Cooperation trend stable/increasing | Cooperate              | Support emerging cooperation |
|       | Otherwise                        | Defect                 | Avoid being lone cooperator  |
| \( t = r \)    | \( C_{r-1} \ge m-1 \)             | Cooperate              | Maximize final payoff        |
|       | Otherwise                        | Defect                 | Avoid unnecessary cost       |

---

This strategy aligns strongly with a cooperative mindset while protecting against exploitation and adapting to observed group behavior. It encourages collective action to reach the payoff threshold and adjusts dynamically based on others’ cooperation levels.
'''

description_COOPERATIVE_9 = '''
Below is a cooperative strategy tailored for the Collective Risk Dilemma, designed to foster cooperation while protecting against sustained defection by others. This strategy seeks to promote cooperation to reach the threshold and secure the reward k every round.

---

## Cooperative Strategy: Conditional Cooperative Reciprocity with Forgiveness and Final-Round Defection

### Intuition & Objectives:
- **Goal:** Reach or exceed the cooperation threshold m each round to gain payoff k.
- **Cooperation:** Start by cooperating to signal willingness.
- **Conditional Cooperation:** Continue cooperating if a sufficient number of players cooperated previously, indicating mutual willingness.
- **Punishment/Defection:** Defect if cooperation falls below threshold to avoid being exploited.
- **Forgiveness:** After a single round of defection by others, attempt to return to cooperation to recover mutual benefits.
- **Last Round:** Defect in the last round (endgame) to maximize private payoff because cooperation incentives diminish.

---

### Decision Rules by Round t (1 ≤ t ≤ r):

1. **Round 1 (t=1):**  
   - Always **Cooperate (C)** to establish trust.

2. **Rounds 2 to r-1 (2 ≤ t ≤ r-1):**  
   After the first round, use the observed cooperation count from round t-1:
   - Let `prev_cooperators` = number of players (including self) who cooperated in round t-1.
   - If `prev_cooperators ≥ m`, then **Cooperate (C)** (trust continued cooperation).  
     *Rationale:* Others demonstrated cooperation sufficient to yield the reward last round. Good reason to maintain cooperation.
   - Else (`prev_cooperators < m`), **Defect (D)** to avoid unilateral cooperation exploitation.

   - **Forgiveness rule:**  
     - If defected in round t-1 but `prev_cooperators ≥ m` in round t-2, forgive once by cooperating to attempt re-establishing cooperation (even if others defected last round).  
     - If multiple consecutive rounds of cooperation below threshold, continue defecting.

3. **Last Round (t = r):**  
   - Always **Defect (D)** to maximize private payoff since repeated cooperation incentives end.

---

### Edge Cases & Notes:

- **Handling transitions:**  
  - If in round t-1, cooperation was below threshold, start defecting but be prepared to forgive a one-time drop by switching back to cooperation if cooperation rises again.
  
- **Synchrony assumption:**  
  - Since game is simultaneous and information is perfect from previous rounds, protocol applies symmetrically.

- **Partial threshold met:**  
  - If cooperation count is just below the threshold, defecting is rational to avoid losing endowment without compensation.

- **No communication allowed:**  
  - Use observed cooperation counts as only signal.

---

### Pseudocode

```
INPUT:
    n, r, m, k (game parameters)
    history: list of actions per player per round so far

for round t in 1 to r:
    if t == 1:
        action = Cooperate
    else if t == r:
        action = Defect
    else:
        prev_actions = history[t-1]  # actions of all players in previous round
        prev_cooperators = count_C(prev_actions)
        
        if prev_cooperators >= m:
            action = Cooperate
        else:
            # Check forgiveness condition
            prev_prev_actions = history[t-2] if t > 2 else None
            prev_prev_cooperators = count_C(prev_prev_actions) if prev_prev_actions else None
            
            if t > 2 and (prev_prev_cooperators is not None) and (prev_prev_cooperators >= m):
                # Forgive single round defection by cooperating
                action = Cooperate
            else:
                action = Defect
```

---

### Summary of the Strategy Traits:

| Round             | Action                         | Reasoning                            |
|-------------------|--------------------------------|------------------------------------|
| First round       | Cooperate                     | Establish cooperation               |
| Intermediate round| Cooperate if prev cooperation ≥ m; else Defect (with forgiveness once) | Encourage stable cooperation, punish persistent defection, but forgive occasional slips |
| Last round        | Defect                       | No future to sustain cooperation   |

---

This strategy balances cooperative trust with defensive caution and leverages repeated interactions to sustain cooperation, while protecting against exploitation and acknowledging the rational defection in the final round.

This should yield higher expected payoffs by maximizing rounds where the threshold m is met while minimizing losses from unreciprocated cooperation.
'''

description_COOPERATIVE_10 = '''
Below is a cooperative strategy explicitly designed for the **Collective Risk Dilemma** game as described. The strategy aims to sustain cooperation to reach the threshold \( m \) and secure the reward \( k \), while handling the repeated structure and the incentive to defect free-rider style.

---

## Strategy Core Idea

- **Goal:** Achieve and maintain at least \( m \) cooperators each round to obtain the collective reward \( k \).
- **Approach:** Cooperate initially and as long as enough cooperation is observed; otherwise, punish defectors temporarily to discourage free-riding, then attempt to restore cooperation.
- **Cooperation Threshold:** Monitor the number of cooperators per round.
- **Forgiveness:** After punishing defections by defecting itself for one round, return to cooperation unless defection persists.
- **Final Round:** Cooperate, because future punishment doesn't affect payoffs and mutual cooperation yields better immediate payoff than mutual defection.

---

## Detailed Rules

### Round 1 (Initial Round)
- **Action:** Cooperate (C)
- **Rationale:** Establish willingness to cooperate and attempt to reach the threshold from the start.

### Round \( t = 2, \dots, r-1 \) (Intermediate Rounds)
- Observe previous round \( t-1 \):
  - Let \( C_{t-1} \) = number of players who cooperated (including self).
- Decision:
  1. **If \( C_{t-1} \geq m \) (Threshold Met Last Round):**
     - Cooperate (C) to maintain cooperation.
  2. **If \( C_{t-1} < m \) (Threshold Not Met Last Round):**
     - **Punish:** Defect (D) this round to signal dissatisfaction.
     - After defecting once in punishment mode:
       - At next round, attempt cooperation again (hope for restored cooperation).
       - If threshold still not met, repeat punishment.
- This establishes a "conditional cooperation with punishment" pattern.

### Final Round \( t = r \)
- Cooperate (C) regardless of history.
- **Rationale:** No future rounds to punish, so cooperate to maximize immediate joint payoff.

---

## Handling Edge Cases and Notes

- **If others consistently defect or threshold is never met:**
  - The strategy defects each round after the first failure, but tries to restart cooperation after one round of punishment.
  - Prevents unilateral exploitation by defecting after failed cooperation.
- **If cooperation fluctuates around \( m \):**
  - Strategy adapts by cooperating if threshold met; punishing if not.
- **If different players react differently:**
  - Forgiveness lets cooperation re-emerge without endless retaliation cycles.
- **No communication is assumed, so all inference based only on past observable actions.**

---

## Pseudocode for Player \( i \)

```python
# Inputs:
# n, r, m, k (known parameters)
# history: list of length t-1 of tuples of actions of all players in previous rounds
#   Each element: actions_t = [a_1, a_2, ..., a_n], a_j in {C, D}

punishment_mode = False  # Tracks whether currently punishing

for t in range(1, r+1):
    if t == 1:
        # First round: cooperate
        action = C
        punishment_mode = False
    elif t == r:
        # Last round: cooperate unconditionally
        action = C
    else:
        # Intermediate rounds
        last_round_actions = history[t-2]  # zero-indexed
        cooperators = sum(1 for a in last_round_actions if a == C)

        if cooperators >= m:
            # Threshold met previously: cooperate
            action = C
            punishment_mode = False
        else:
            # Threshold not met last round
            if not punishment_mode:
                # Enter punishment mode: defect this round
                action = D
                punishment_mode = True
            else:
                # Punished last round, now attempt to re-cooperate
                action = C
                punishment_mode = False

    # Play action for round t
    yield action
```

---

## Why This Strategy is Cooperative

- **Start with cooperation**: will to cooperate from the beginning.
- **Conditional cooperation**: cooperates if others do, defects only to discourage persistent defection.
- **Forgiving**: punishes defectors but returns to cooperation rapidly after one round of punishment.
- **End-round cooperation**: maximizes joint payoff when no future leverage exists.
- Intends to stabilize cooperation near the threshold \( m \) to obtain the reward \( k \) repeatedly.

---

This approach balances the risk of exploitation with the opportunity for collective reward. It is simple, transparent, and robust under the game’s assumptions, perfectly fitting the cooperative mindset.
'''

description_COOPERATIVE_11 = '''
Below is a detailed cooperative strategy for the Collective Risk Dilemma, designed to maximize collective payoffs by fostering cooperation and deterring defection in repeated play.

---

## Cooperative Strategy: "Conditional Coordinated Cooperation with Forgiveness"

### Core Idea
- **Initially cooperate to build trust.**
- **Continue cooperating if enough others cooperate (≥ m) in the previous round.**
- **Temporarily defect if cooperation dropped below threshold to punish defectors and incentivize return to cooperation.**
- **Forgive and return to cooperation if enough players resume cooperation.**
- In the **final round**, cautiously defect if the benefit of cooperating is outweighed by the risk of exploitation.

### Rationale
- Cooperation pays off best if ≥ m players cooperate.
- Defecting when cooperation succeeds can yield short-term gain but harms future payoffs.
- Repeated interaction allows enforcement of cooperation via conditional strategies.
- Temporarily punishing defection discourages free-riding.
- Forgiveness enables recovery from accidental defections or noise.
- Special cautiousness in the last round prevents being exploited since no future retaliation is possible.

---

## Detailed Decision Rules

### Notation
- Round index: t ∈ {1, 2, ..., r}
- Player action at round t: a_i,t ∈ {C, D}
- Number of cooperators in round t: coop_count_t
- Parameters: n, r, m, k

### Initialization (First Round t=1)
- Cooperate (a_i,1 = C) to signal willingness and try to meet threshold.

---

### Subsequent Rounds (2 ≤ t < r)

- **If in previous round, coop_count_{t-1} ≥ m:**
  - Cooperate (a_i,t = C) to maintain beneficial cooperation.

- **If coop_count_{t-1} < m:**
  - Temporarily defect (a_i,t = D) as a punishment.
  - Continue defecting until cooperation recovers.

- **Forgiveness rule:**
  - If you defected due to low cooperation in round t-1, but now (in round t) coop_count_{t-1} ≥ m, return to cooperating in round t.

---

### Final Round (t=r)

- **If previous cooperation was sustainable (coop_count_{r-1} ≥ m):**
  - Cooperate to maximize final collective reward.

- **If cooperation was unstable (coop_count_{r-1} < m):**
  - Defect, because no future rounds to enforce cooperation, and cooperating is costly.

---

### Handling Edge Cases

- **If coop_count is exactly m, treat as successful cooperation.**
- **If observations are noisy or ambiguous (if hypothetically allowed), use forgiveness more aggressively.** (This spec assumes perfect information, so this is less relevant.)
- **If a drastic drop from full cooperation to below threshold occurs suddenly, defect for at most one round before re-checking cooperation status (forgiveness).**

---

## Pseudocode

```
Initialize:
  t = 1
  action = C

For round t = 1 to r:
  
  Observe coop_count_{t-1}  (skip for t=1 since no history)
  
  if t == 1:
    action = C

  else if 1 < t < r:
    if coop_count_{t-1} >= m:
      action = C    # cooperation sustainable, keep cooperating

    else:
      # Punish defection
      action = D

      # Check if we were already punishing last round
      if last_action == D and coop_count_{t-1} >= m:
        action = C  # Forgive and return to cooperation

  else if t == r:  # Last round
    if coop_count_{r-1} >= m:
      action = C   # Last chance to enjoy cooperative reward
    else:
      action = D   # No incentive to cooperate without future enforcement

  Play action
  last_action = action
```

---

## Strategic Summary

- **First round:** Cooperate to initiate cooperation.
- **Continue cooperating as long as at least m players do.**
- **Punish by defecting when cooperation fails (coop_count < m).**
- **Forgive and return to cooperation once the threshold is met again.**
- **In final round, cooperate only if previous cooperation was stable; otherwise defect.**

This strategy balances being cooperative, responsive, and strategic, maximizing collective benefits while guarding against exploitation.

---

If you want, I can also help adapt this strategy to various parameter regimes or analyze its expected payoffs against known benchmark strategies.
'''

description_COOPERATIVE_12 = '''
Below is a detailed cooperative strategy designed for the Collective Risk Dilemma under the given conditions. It aims to achieve the collective goal (at least *m* cooperators per round), thereby consistently unlocking the reward *k* for all, while adapting to observed behaviors across rounds.

---

## Strategy Name: Conditional Cooperative Trigger (CCT)

---

### Intuition & Goals

- **Primary goal:** Ensure that at least *m* players cooperate each round to secure the reward *k* for all players.  
- **Secondary goal:** Avoid being exploited by defectors who consistently free-ride without contributing.  
- **Approach:**  
  - Start with cooperation to build trust and test willingness of others to cooperate.  
  - Monitor the number of cooperators each round.  
  - If the group meets or exceeds threshold *m*, continue cooperating.  
  - If the threshold is not met, respond by defecting to discourage free-riding.  
  - Use forgiveness to allow cooperation to recover after defections.  
  - In the final round(s), coordinate behavior based on history and remaining rounds to maximize total payoff.

---

### Decision Rules

Let:

- \(t \in \{1, 2, \ldots, r\}\) denote the current round.
- \(C_t\) = number of players who cooperated in round \(t\).
- \(C_{t}^{-i}\) = number of other players (excluding self) who cooperated in round \(t\).
- \(M = m\) = cooperation threshold.
- Assume perfect information and observe full action history.
- Define a "defection phase" flag to keep track of when the group is not meeting the cooperation threshold.

---

### Detailed Strategy Steps

1. **Round 1 (Initialization):**  
   - **Action:** Cooperate (C).  
   - **Reason:** Signal cooperative intent and test if others reciprocate.

2. **Round \(t > 1\):**  
   - Observe \(C_{t-1}\), the number of cooperators in the previous round.
  
   - **If \(C_{t-1} \geq M\):**  
     - **Action:** Cooperate (C).  
     - **Reason:** Cooperation threshold met; maintain cooperation.
     - Reset or maintain "defection phase" = False.
  
   - **If \(C_{t-1} < M\):**  
     - Enter or continue "defection phase".  
     - **Action:** Defect (D).  
     - **Reason:** Punish insufficient cooperation to incentivize collective behavior.
  
   - **Forgiveness rule:**  
     - If currently in defection phase and the last round showed \(C_{t-1} \geq M\), return to cooperating in the current round to allow recovery.
  
3. **Final round (round \(t = r\)):**  
   - **If the group has cooperated sufficiently often (e.g., \( \geq r/2 \) rounds reaching threshold):**  
     - Cooperate (C), to reinforce mutual cooperation payoff.  
   - **Else:**  
     - Defect (D) to maximize individual payoff given likely breakdown of cooperation.

---

### Pseudocode

```python
def decide_action(round_t, r, m, k, history):
    # history is a list of length (t-1), each element is a list of n players' actions ['C'/'D']

    if round_t == 1:
        # Always start cooperating
        return 'C'

    # Count cooperators in previous round
    previous_round = history[round_t - 2]  # 0-based indexing: round t-1 is at index t-2
    C_t_minus_1 = previous_round.count('C')

    # Track defection phase: has cooperation failed recently?
    # We'll track this via a simple flag stored outside this function in implementation, 
    # here assume we can derive from history:
    recent_threshold_met = any(
        sum(round_actions.count('C') for round_actions in history[max(0, round_t - 3):round_t - 1]) >= m
    )
    
    if C_t_minus_1 >= m:
        # Cooperation threshold met last round – cooperate
        return 'C'
    else:
        # Threshold not met last round
        # Punish by defecting
        # Forgiveness: if threshold met in any of last two rounds, return to cooperating
        threshold_met_last_two = (
            sum(history[-1].count('C')) >= m or
            (len(history) > 1 and sum(history[-2].count('C')) >= m)
        )
        if threshold_met_last_two:
            return 'C'
        return 'D'

def final_round_decision(round_t, r, m, history):
    # Count number of rounds meeting cooperation threshold
    rounds_meeting_threshold = sum(
        1 for round_actions in history if round_actions.count('C') >= m
    )
    if rounds_meeting_threshold >= r / 2:
        return 'C'
    else:
        return 'D'
```

---

### Notes on Behavior and Rationale

- **Cooperating in round 1:** Encourages others to choose cooperation initially.  
- **Punishment phase:** Defecting if the group fails to reach threshold discourages free-riding.  
- **Forgiveness:** Allows group to bounce back from occasional failures or misunderstandings.  
- **Partial history monitoring:** Uses recent rounds’ cooperation status to decide.  
- **Final round behavior:** If cooperation mostly successful, keep cooperating to maximize joint payoff; otherwise, defect to protect own payoff in final round.  
- **No reliance on communication:** Only uses observed actions, consistent with game’s rules.  
- **Cooperative mindset:** Prioritizes the group's success, maintaining cooperation unless provoked by persistent failure.

---

### Handling Edge Cases

- **If \(m\) is close to \(n\):** Cooperation is harder; the punitive defection discourages defectors.  
- **If last round:** The strategy mainly defects if cooperation was poor during game, otherwise cooperates to gain payoff.  
- **If multiple players defect repeatedly:** This strategy punishes by defecting, reducing incentives to free-ride.  
- **If others are unconditional defectors:** This strategy adapts by defecting too, to avoid being exploited.

---

### Summary

This **Conditional Cooperative Trigger** strategy:

- Starts optimistic with cooperation.  
- Continuously tests group cooperation threshold.  
- Switches to defection as punishment if threshold not met.  
- Forgives and resumes cooperation when cooperation is restored.  
- Optimizes behavior in last round to avoid exploitation.  

It aligns clearly with a cooperative mindset promoting collective payoff maximization, yet protects against exploitation — a balance appropriate for this repeated collective risk dilemma.
'''

description_COOPERATIVE_13 = '''
Here is a cooperative strategy designed to maximize collective payoff by reaching the threshold cooperation level \(m\) in each round of the repeated Collective Risk Dilemma, while accounting for the incentives to defect and the dynamics over rounds. It assumes no communication but observable actions and payoffs from past rounds.

---

## Strategy: "Conditional Gradual Cooperation with Forgiveness"

### Intuition:
- We want to reliably reach at least \(m\) cooperators in each round to secure the reward \(k\).
- Initially, trust others to cooperate up to \(m\) players.
- Condition cooperation on past behavior—if others cooperated sufficiently, continue cooperating.
- Forgive occasional defections to avoid triggering persistent defection cycles.
- Defect only if cooperation seems unlikely or in the very last rounds when future retaliation is impossible.

---

### Decision Rules

#### Parameters:
- \(n\) = number of players
- \(r\) = total rounds
- \(m\) = minimum cooperators needed
- \(k\) = reward factor
- \(t\) = current round number, \(1 \leq t \leq r\)

---

### At round \(t\):

1. **First Round (\(t=1\)) — Initiate Cooperative Signal**
   - Cooperate if your index \(i \leq m\).  
     (This is a deterministic "role assignment" for initial coordination: to avoid free-riding, the first \(m\) players start by cooperating.)
   - Otherwise, defect.

2. **Subsequent Rounds (\(2 \leq t < r\)) — Conditional Cooperation**
   - Let \(C_{t-1}\) = number of cooperators observed in round \(t-1\).
   - Let \(D_i^{t-1}\) indicate if player \(i\) defected in round \(t-1\).
   - Let \(D_i^{t-2}, ..., D_i^{t-w}\) be a cooperation history window of length \(w\) (e.g., \(w=2\)) rounds prior.
   - Define **trusted cooperators** as players who cooperated in at least \((w-1)\) out of the last \(w\) rounds.
   - Compute \(m_{trusted}\) = number of trusted cooperators.
   
   **Action:**
   - If the current player is in the set of trusted cooperators or among the players who cooperated in the previous round, cooperate.
   - Else, defect.
   
   *Goal:* Maintain a stable cooperative core of size at least \(m\).
   
   If you observe \(C_{t-1} < m\) (threshold missed last round):
   - Forgive a single defection by cooperating if your own last two rounds were cooperative.
   - If defectors persist over multiple rounds, reduce your cooperation rank accordingly.

3. **Last Round (\(t = r\)) — Defect to maximize final payoff**
   - Defect (since no future rounds exist to punish defection).

---

### Edge cases handling:

- If the initial deterministic assignment leads to fewer than \(m\) cooperators in round 1 (e.g., if the order of players is unknown or repeated plays against different agents):  
  Relax to cooperative if overall cooperation rate last round was high, else defect.

- If the total number of trusted cooperators drops below \(m\):  
  Start cooperating yourself and signal trustworthiness to encourage return to cooperation.

- If you are assigned defecting player initially but detect a stable core of cooperators > \(m\):  
  Join cooperation next round to enjoy rewards (to maximize payoff with the group).

---

### Summary Pseudocode

```python
def decide_action(t, i, history, n, m, r, k, w=2):
    # history is list of dicts for each past round, each dict: {player_index: 'C' or 'D'}
    
    if t == 1:
        # First m players cooperate, others defect
        if i <= m:
            return 'C'
        else:
            return 'D'
    
    elif t < r:
        # Compute trusted cooperators over last w rounds
        recent_rounds = history[-w:] if len(history) >= w else history
        cooperation_count = {p:0 for p in range(1, n+1)}
        for rnd in recent_rounds:
            for p, action in rnd.items():
                if action == 'C':
                    cooperation_count[p] += 1
        
        trusted_cooperators = [p for p, ccount in cooperation_count.items() if ccount >= w - 1]
        
        # Determine cooperators in previous round
        last_round = history[-1]
        last_round_cooperators = [p for p, a in last_round.items() if a == 'C']
        C_prev = len(last_round_cooperators)
        
        # Decide action
        if i in trusted_cooperators or i in last_round_cooperators:
            return 'C'
        else:
            # If cooperation failed last round, consider forgiving single defectors
            if C_prev < m:
                # Forgive if personal history cooperative
                my_coop_count = cooperation_count[i]
                if my_coop_count >= w - 1:
                    return 'C'
            return 'D'
    
    else:
        # Last round defect to maximize payoff
        return 'D'
```

---

### Why this strategy is cooperative?

- Starts by coordinating a minimal cooperative core.
- Maintains cooperation by trusting players who cooperate consistently.
- Forgives isolated defections to avoid breakdown.
- Tries to keep the requisite cooperative threshold \(m\).
- Defects only at the last round when cooperation no longer yields future benefit.
- Avoids exploitation by defecting against persistent defectors.
- Uses observable public history to adapt without communication.

---

This strategy aims to balance maximizing group payoff through stable cooperation, while protecting yourself from exploitation, and exploiting no opportunity to cooperate when group benefit is unlikely. It is explicitly cooperative, maximizing collective outcomes within game theoretical constraints.
'''

description_COOPERATIVE_14 = '''
**Strategy Name:** Conditional Cooperation with Threshold Monitoring and Reciprocity

---

### Intuition and Goals

- **Goal:** Achieve and maintain cooperation at or above the threshold \( m \) so that all players receive the reward \( k \).
- **Challenge:** Avoid being exploited by defectors while encouraging others to cooperate.
- **Repeated game advantage:** Use history to build trust and punish defections.
- **No communication:** Must infer players’ intentions from observed actions.

---

### Core Principles

1. **Start cooperatively:** Contribute in the first round to signal willingness.
2. **Track cooperation counts:** Monitor how many players cooperated each round.
3. **Reciprocity-based cooperation:** Cooperate if at least \( m \) players cooperated last round; otherwise defect.
4. **Forgiveness:** After a defection round, cooperate once to test if others return to cooperation.
5. **Last round defect:** Since no future reward, defect in the last round to maximize payoff.
6. **If the group consistently fails to cooperate:** Defect to avoid being exploited.
7. **Tie-breaking:** When exactly \( m - 1 \) players cooperated last round, act as if cooperation failed (defect) to encourage stability at or above \( m \).

---

### Decision Rules Summary

| Round           | Condition                                                              | Action |
|-----------------|------------------------------------------------------------------------|--------|
| **Round 1**     | No history yet                                                         | Cooperate (C)       |
| **Rounds 2..r-1** | If **last round cooperation count ≥ m** → Cooperate (C)               |
|                 | Else if last round cooperation count < m                              | Defect (D)           |
|                 | After defection round, cooperate once to test return to cooperation   | (One-time forgiveness)|
| **Round r (last)** | Defect (D)                                                           | Defect (D)           |

---

### Pseudocode

```python
def decide_action(round_t, history, n, m, k):
    """
    Inputs:
    - round_t: current round number (1..r)
    - history: list of previous rounds' cooperation count (length = round_t - 1)
               each element: number of cooperators in that round
    - n, m, k: game parameters
    
    Returns:
    - action: 'C' or 'D'
    """
    
    if round_t == 1:
        return 'C'  # Start off cooperating
    
    if round_t == r:
        return 'D'  # Last round: defect for payoff maximization
    
    last_coop = history[-1]  # number of cooperators last round
    
    # Forgiveness: If previous round was defect, try cooperating once
    # We track if we have already forgave or not by checking history pattern (implementation detail)
    # For strategy outline, say: if previously defected due to low cooperation, cooperate once
    
    # Simple rule without explicit "forgiveness bookkeeping":
    if last_coop >= m:
        return 'C'  # Condition for cooperation: enough cooperators last round
    else:
        return 'D'  # Defect if threshold wasn't met
    
    # (Optional: add forgiveness logic with memory)
```

---

### Handling Edge Cases

- **First round (t=1):** No prior info, cooperate to initiate trust.
- **Last round (t=r):** Defect because no future rounds to reward cooperation.
- **Threshold exactly met:** Cooperate to sustain reward.
- **Threshold exactly missed (e.g., \( m-1 \) cooperators):** Defect to signal cooperation must meet threshold consistently.
- **Persistent defection rounds:** Defect indefinitely to avoid exploitation.
- **One-time forgiveness step:** After a defection round, cooperate once to see if others return to cooperation.

---

### Rationale

- By starting cooperatively, you signal willingness to collaborate.
- Cooperating only when last round met/exceeded \( m \) cooperators encourages stable cooperation because defectors lower the payoff for all.
- Defecting otherwise punishes failure to reach the threshold.
- Forgiveness allows recovery from accidental or strategic defections.
- Defecting at the last round maximizes personal payoff since no further cooperation incentives exist.

---

### Extensions (Optional / For More Sophistication)

- Track individual players’ histories if available; retaliate against known defectors only.
- Use probabilistic cooperation to soften triggering defection.
- Signal strategy changes over rounds implicitly by adjusting cooperation likelihood.

---

**This strategy explicitly aligns with cooperative mindset by striving to maintain community cooperation at or above threshold \( m \), maximizing reward \( k \), while guarding against exploitation through contingent reciprocity and forgiveness.**
'''

description_COOPERATIVE_15 = '''
Below is a cooperative strategy designed for the Collective Risk Dilemma, informed by the game setup and standard assumptions of repeated games. The strategy is designed to seek cooperation to reliably meet the threshold *m* cooperators per round, maximizing collective payoffs over *r* rounds, while being robust to occasional defections and ending rounds effectively.

---

### Strategy Name: "Threshold-Enforcer Cooperative Strategy"

---

### Intuition:

- The goal is to ensure that in every round, at least *m* players cooperate, so all players get the full reward *k*.
- To achieve this, the strategy seeks to coordinate on cooperating so long as it observes sufficient cooperation from others in the past.
- It punishes defection by defecting once if others cooperate, and returns to cooperate to allow recovery from errors.
- It adapts cooperation level based on the observed number of cooperators.
- The strategy always cooperates in the first round to lead by example.
- In the last round, cooperation is maintained if the game history suggests cooperation will pay off; otherwise, defect to avoid sucker payoff.

---

### Variables/Memory:

- `round` = current round number (1 to r)
- `last_cooperators` = number of cooperators observed in the previous round
- `trust_level` = a bounded integer measure of how cooperative others are observed; initial value set to a level encouraging cooperation
- `threshold` = *m* (minimum cooperators needed)
- `n` = number of players
- `k` = reward factor (for reference, no direct use)
- `r` = total rounds

---

### Decision Rules (Per Round):

**1. First round (round == 1):**

- Cooperate (play C).
- Reason: Lead by example to establish cooperation.

---

**2. Subsequent rounds (1 < round < r):**

- Observe how many players cooperated last round, store as `last_cooperators`.
- Update `trust_level` depending on whether the previous round met cooperation threshold:
  - If `last_cooperators >= m` (threshold met): increase or maintain `trust_level`.
  - If `last_cooperators < m`: decrease `trust_level`.
- Decision depends on `trust_level`:
  
  - If trust_level indicates others tend to cooperate (above or equal to a stable threshold), **cooperate** this round to ensure payoff *k*.
  
  - If trust_level is low (below threshold), **defect** this round to punish defection and signal dissatisfaction.

---

**Example for trust_level update pseudocode:**

```python
if last_cooperators >= m:
    trust_level = min(trust_level + 1, max_trust)  # max_trust is an upper bound to keep it bounded
else:
    trust_level = max(trust_level - 1, 0)
```

---

**3. Last round (round == r):**

- If trust_level is high or last round met threshold: **cooperate** (hope for last round cooperation and maximize group payoff).

- Else: **defect** (avoid being exploited when there is no future to regain trust).

---

### Edge Cases and Handling:

- **If last_cooperators unknown (e.g., first round):** cooperate.

- **If last_cooperators exactly equal to m-1:** borderline case; treat as failure to meet threshold => reduce trust, defect next round.

- **If severe defection detected (trust_level falls to 0):** defect until trust recovers by observing enough cooperation rounds.

- **Strategy enables forgiveness:** after punishment rounds if cooperation resumes, trust_level increases allowing re-entry into cooperation.

- **No communication assumed:** all decisions based on observed numbers of cooperators.

---

### Pseudocode Summary

```python
initialize trust_level = initial_trust  # e.g., trust_level = m or half of n
max_trust = n  # max possible trust_level

for round in 1 to r:

    if round == 1:
        action = 'C'  # lead by example

    else:
        if last_cooperators >= m:
            trust_level = min(trust_level + 1, max_trust)
        else:
            trust_level = max(trust_level - 1, 0)

        if round == r:
            # Last round special case
            if trust_level >= threshold_for_cooperation or last_cooperators >= m:
                action = 'C'
            else:
                action = 'D'
        else:
            if trust_level >= threshold_for_cooperation:
                action = 'C'
            else:
                action = 'D'

    play action
    observe others' actions and update last_cooperators for next round
```

*Note:* `threshold_for_cooperation` can be set to around half of *m*, indicating moderate confidence in cooperation.

---

### Why This Strategy is Cooperative:

- It begins by cooperating to establish trust.
- It cooperates indefinitely when others cooperate.
- It punishes defection to discourage free-riding.
- It allows recovery/forgiveness to restore cooperation after occasional defections.
- It coordinates on meeting the threshold *m* consistently to secure the collective payoff *k*.
- In the last round, it considers the state of trust to choose whether to cooperate or not, balancing risk and reward.

---

### Potential Enhancements

- Use the full distribution of cooperators to estimate likelihood of meeting threshold.
- Adjust `trust_level` dynamically based on size of cooperation shortfall.
- Use probabilistic cooperation near threshold to add unpredictability.

---

This strategy balances cooperation with pragmatic punishment to sustain collective risk mitigation and maximize rewards over repeated rounds.
'''

description_COOPERATIVE_16 = '''
Below is a cooperative strategy designed to maximize the collective payoff in the Collective Risk Dilemma, balancing cooperation incentives with responsiveness to opponent actions. The strategy aims to reliably meet or exceed the cooperation threshold **m** every round, thus achieving the reward **k** consistently, while minimizing wasted cooperation when others defect.

---

## Key Insight

- The group must have at least **m** cooperators each round to unlock the reward **k**.
- Any cooperator pays cost 1 that round.
- Defectors pay no cost but also benefit from the reward if threshold met.
- Defectors get highest payoff if threshold is met but they do not pay cost (π=1+k).
- Cooperators only get k if threshold met, otherwise they lose the cost (0 payoff).
- **Overall, stable cooperation depends on coordination to ensure >= m cooperators simultaneously each round.**

---

## Strategy Outline: **Conditional Reciprocity with Threshold Support**

---

### Parameters needed by the strategy:

- n, r, m, k (known)
- Observe previous rounds' cooperation counts (tc_t for round t)
- Track own action history (A_self,t for each t)
- Estimate or infer opponent cooperation levels from history

---

### Goal:

Ensure that in every round, **at least m players cooperate** to guarantee payoff = 1 + k (defectors) or 0 + k (cooperators).  
This means consistently cooperate at least m players, ideally exactly m, to maximize total group payoff and individual gains.

---

### Strategy Description

**At round t ∈ {1,...,r}:**

1. **First Round (t=1):**

   - **Cooperate if you think the group can coordinate at least m cooperations**
   
   Since no prior information is available, **assume cooperation is the default and cooperate** to signal willingness.

2. **Subsequent Rounds (t > 1):**

   - From round 2 onward, **observe total cooperators(tc_{t-1}) from previous round.**

   - **If tc_{t-1} ≥ m:**  
     - Cooperation was successful last round, **cooperate** again to maintain trust and ensure threshold is met.

   - **If tc_{t-1} < m:**  
     - Cooperation failed last round, group did not reach threshold.
     - **If you cooperated last round:**  
       - You lost cost but no reward; assume some defectors exploited cooperators.  
       - To discourage free-riders, **defect this round**.
     - **If you defected last round:**  
       - You benefited without cost.  
       - But group lost reward, harming overall group payoff.  
       - Return to **cooperate this round** as a good-faith effort.

   - This pattern tries to penalize defectors by breaking cooperation after failure, but still keeps the door open for cooperation recovery.

3. **Last Round (t = r):**

   - Since future retaliation is not possible, defections may be tempting.
   - However, if playing the repeated game in a tournament, reputation may matter.
   - Adopt **always cooperate in last round** to maximize collective payoff (aligns with cooperative mindset).
   - Alternatively, could defect if others defected last round, but generally better to cooperate to maximize joint payoffs.

---

### Pseudocode

```python
# Inputs: n, r, m, k
# Variables:
#  - A_self: own past actions list length t-1, ('C' or 'D')
#  - tc: total cooperators in round t-1 (observed)
# For t in 1..r:

def decide_action(t, A_self, tc, m):
    if t == 1:
        # First round: cooperate to initiate trust
        return 'C'
    
    if t == r:
        # Last round: cooperate to maximize payoff
        return 'C'
    
    prev_action = A_self[-1] if len(A_self) >= 1 else None
    
    if tc >= m:
        # Successful cooperation last round, maintain cooperation
        return 'C'
    else:
        # Defection threshold not met last round
        if prev_action == 'C':
            # Cooperated but threshold failed => defect to discourage free riding
            return 'D'
        else:
            # Defected last round but group failed reward =>
            # try cooperating again to restore cooperation
            return 'C'
```

---

### Intuition / Explanation

- **Start cooperative**: signals willingness, helps reach threshold.
- **Sustain cooperation if threshold met**: reciprocate cooperation.
- **Punish failure if you cooperated**: avoid being the only sucker.
- **Forgive if you defected**: try cooperating again to rebuild cooperation.
- **Always cooperate last round**: maximize group outcome as no punishment is possible.

---

### Edge Cases & Notes

- If multiple defectors alternate cooperation, this leads to cycles (sometimes fail).
- The strategy acts as a "tit-for-tat" at group level, promoting stable cooperation.
- If fewer than m players adopt similar cooperative strategy, threshold won't be met — but in tournament with multiple LLMs, cooperation is encouraged.
- No communication possible, so rely on observed cooperation counts.
- Strategy is robust to noise because cooperators defect when exploited, preventing persistent sucker payoff.
- Works well for any n,m,r,k parameters given.

---

## Summary

| Round        | Condition                                  | Action              |
|--------------|--------------------------------------------|---------------------|
| 1            | No history                                 | Cooperate (C)       |
| t < r        | Threshold met last round (tc_{t-1} ≥ m)  | Cooperate (C)       |
| t < r        | Threshold failed, and self was cooperator | Defect (D)          |
| t < r        | Threshold failed, and self was defector   | Cooperate (C)       |
| t = r (last) | Any                                        | Cooperate (C)       |

---

This conditional reciprocity approach aligns with cooperation, aims to meet the minimum coop threshold **m** each round, punishes exploiters, and is ready to forgive, producing a stable collective cooperation in repeated play under perfect information.
'''

description_COOPERATIVE_17 = '''
Here is a cooperative strategy for the repeated Collective Risk Dilemma game designed to promote cooperation while guarding against exploitation, leveraging the perfect information feature and repetition:

---

### Strategy Name: **Conditional Cooperative Trigger**

---

### Intuition

- Achieve the threshold *m* cooperators each round to secure the reward *k*.
- Start cooperatively to encourage mutual cooperation.
- Track other players' cooperation to maintain cooperation only if enough do so.
- If cooperation falls below threshold due to defections, punish defectors by temporarily defecting, then test the waters again.
- In the last round, cooperate only if confident cooperation will meet threshold (otherwise defect to maximize private payoff).

---

### Key Variables Maintained

- `round` — current round number (1 to r)
- `n`, `m`, `k`, `r` — known game parameters
- `observed_actions[t][i]` — observed action of player i in round t (1-based indexing)
- `last_round_cooperators` — number of cooperators in previous round (initialized to n)
- `betrayal_allowed` — boolean flag indicating whether strategy is in punishment mode

---

### Decision Rules

**Round 1 (Initial round):**  
- Cooperate (C) by default to initiate cooperation.

**Rounds 2 to r-1:**  
- If in punishment mode (`betrayal_allowed` is True):
  - Defect (D) for one round to punish.
  - Next round, reset `betrayal_allowed` to False and cooperate to test if cooperation restored.
- Else (normal mode):
  - Check how many cooperators in last round:
    - If number of cooperators ≥ m:
      - Cooperate (C) this round (to maintain threshold).
    - Else:
      - Defect (D) this round (defect as punishment).
      - Set `betrayal_allowed` = True for next round to punish defectors.
      
**Round r (Last round):**  
- If number of cooperators in round r-1 ≥ m:
  - Cooperate (C) to get reward again if threshold likely met.
- Else:
  - Defect (D), since no future rounds and cooperation unlikely.

---

### Pseudocode

```python
function decide_action(round, observed_actions):

    if round == 1:
        # Start cooperative
        return 'C'

    last_cooperators = count_cooperators(observed_actions[round - 1])

    # punishment mode flag stored externally, initialized False
    if betrayal_allowed:
        betrayal_allowed = False
        # Defect one round as punishment
        return 'D'

    if round < r:
        if last_cooperators >= m:
            # Cooperation successful last round, continue cooperating
            return 'C'
        else:
            # Cooperation failed threshold last round, punish by defecting
            betrayal_allowed = True
            return 'D'

    else:  # last round (round == r)
        if last_cooperators >= m:
            return 'C'
        else:
            return 'D'

# Helper to count cooperators in a round
function count_cooperators(actions_this_round):
    return sum([1 for a in actions_this_round if a == 'C'])
```

---

### Rationale & Behavior Summary

- The strategy **starts cooperatively** to signal willingness.
- It **monitors the group’s cooperation level** round-by-round.
- If the threshold *m* is met, it **continues cooperating, trusting others** to maintain cooperation.
- If the threshold fails, it **punishes briefly** with defection to deter free-riding.
- After punishment, it **gives chance to reestablish cooperation** by cooperating again.
- In the **final round**, it only cooperates if likely that cooperation threshold can be reached, else defects to maximize private gain.

---

### Notes

- The brief punishment period is critical as a deterrent but not too long to escalate conflict.
- Because of perfect observation and no communication, defections can be identified by observing actions.
- This strategy assumes rational opponents who respond to punishment by returning to cooperation (common in repeated games).
- The strategy aligns with collective interest by seeking to maintain *m* cooperators every round.
- Coordinated cooperation yields the highest group payoffs; the short defections discourage exploitation.

---

If you want, I can also suggest variants or refinements to handle potential collusion or noise, or probabilistic forgiveness. Let me know!
'''

description_COOPERATIVE_18 = '''
Here is a cooperative strategy designed for the Collective Risk Dilemma as specified. It aims to reliably achieve the cooperation threshold *m* in most rounds to secure the reward *k* while managing incentives and encouraging others to cooperate through conditional cooperation.

---

## Strategy Outline: **Conditional Coordinated Cooperation (CCC)**

### Intuition
- Cooperation yields the best group outcome, but defectors free ride.
- Since the game is repeated and players can observe all actions, we use conditional cooperation to sustain cooperation.
- Start cooperatively to signal willingness.
- Continue cooperating as long as enough cooperators are present (≥ m).
- If cooperation falls below threshold, defect to punish and signal displeasure.
- Before the final round, adjust behavior to avoid exploitation.

---

## Decision Rules

### Variables to track (updated each round)
- `cooperatorCountLastRound`: Number of players who cooperated in the previous round.
- `round`: current round number (1 to r).

---

### Round 1 (Initial Trust)
- **Action:** Cooperate.
- **Rationale:** Signal willingness to cooperate and attempt to establish cooperation.

---

### Rounds 2 to r-1 (Maintenance & Enforcement)

- If `cooperatorCountLastRound` ≥ m:
  - **Action:** Cooperate.
  - **Reason:** Cooperation threshold met last round; reciprocate cooperation.

- Else:
  - **Action:** Defect.
  - **Reason:** Cooperation threshold not met last round; punish by defecting to avoid exploitation.

---

### Round r (Final Round: “Endgame”)

- Cannot incentivize future cooperation.
- Defect to maximize own payoff, since no future rounds to punish or reward.

---

## Edge Case Handling

- **If in round 2 and previous round cooperation < m (first round defectors):**
  - Immediate defection, signaling refusal to cooperate with defectors.
  
- **If cooperation threshold fluctuates (sometimes ≥ m, sometimes not):**
  - Follow the same rule: cooperate only if last round ≥ m.
  - This maintains clarity and avoids exploitation through random cooperation.

- **If all defect in first round:**
  - Persist with defection to prevent being exploited.
  - May allow others to realize mutual defection is suboptimal and encourage change (if they adapt).

---

## Pseudocode

```python
def decide_action(round, cooperatorCountLastRound, n, m, r):
    # Round 1: Always cooperate
    if round == 1:
        return 'C'
    
    # Final round: defect
    elif round == r:
        return 'D'
    
    # Intermediate rounds:
    else:
        if cooperatorCountLastRound >= m:
            return 'C'
        else:
            return 'D'
```

---

## Cooperative Mindset Alignment

- Starts with trust and willingness to cooperate.
- Rewards group cooperation by cooperating if threshold met.
- Punishes failure to cooperate to deter exploitation.
- Ends with rational defect to avoid being exploited in last round (standard backward induction).
- Promotes stable cooperation where possible, leading to higher long-term collective payoffs.

---

# Summary

| Round         | Condition                   | Action    | Rationale                         |
|---------------|-----------------------------|-----------|----------------------------------|
| 1             | Start                       | Cooperate | Signal trust and willingness     |
| 2..r-1        | If cooperators last round ≥ m | Cooperate | Reinforce cooperation            |
| 2..r-1        | Else                        | Defect    | Punish defection, avoid exploitation |
| r (final)     | Any                         | Defect    | No future to incentivize cooperation |

This strategy is simple, transparent, and robust in a multi-agent environment with no communication, based on observable behavior and repeated interaction. It suitably balances cooperation and punishment to maintain cooperation and earn the reward *k* consistently when possible.
'''

description_COOPERATIVE_19 = '''
Here is a cooperative strategy designed to maximize collective benefit and encourage cooperation in the Collective Risk Dilemma across r repeated rounds. The strategy aims to coordinate just enough cooperation to meet the threshold m consistently, thus ensuring the reward k while minimizing own cooperation cost.

---

### Intuition & Goals

- Always contribute **just enough** to reach the threshold m cooperators each round.
- Avoid unnecessary over-contribution (to save on cooperation costs).
- Use history to identify "cooperators" in the group and trust them to cooperate.
- Forgive occasional defections but punish persistent defection by defecting in response.
- Recognize the last round and approach it more cautiously, anticipating possible end-game defection.
- Maintain cooperative mindset: willing to cooperate if it helps reach m and expects others to do the same.

---

### Strategy Description

---

#### Parameters:
- n: total players
- r: total rounds
- m: threshold minimum cooperators needed
- k: reward factor

---

#### Variables to Maintain:
- `cooperator_set`: subset of players identified as cooperators (initially empty except self)
- `round`: current round number
- `my_id`: player index (to track own cooperation)
- History: previous rounds’ full action profiles (observable)

---

### Decision Rules by Round

---

#### Round 1 (Initial Round)

- **Assumption:** No prior information about others.
- **Action:** Cooperate.
- **Reason:** Demonstrate willingness to cooperate and help reach threshold.
- Initialize `cooperator_set = {my_id}` (I’m a cooperator).

---

#### Rounds 2 to (r-1)

1. **Analyze history of previous rounds**:
   - Identify players who cooperated at least once in prior rounds.
   - Estimate the minimal cooperation set (`cooperator_set`) as those who usually cooperate, plus self.
   - Remove players who defected persistently or never cooperated.
   
2. **Decision:**
   - If the size of `cooperator_set` ≥ m:
     - **Cooperate only if:**  
       - Your turn to cooperate, i.e., if you are within the first m players in `cooperator_set` sorted by id order (to avoid over-contributing).
     - Otherwise, defect.
   - Else (not enough cooperators identified):
     - Cooperate to encourage threshold attainment and expand `cooperator_set`.
   - Additionally:
     - Forgive occasional defectors who cooperated previously.
     - Punish defectors who continuously defect by excluding them from `cooperator_set`.

3. **Update `cooperator_set` for the next round** based on current round’s cooperation behavior.

---

#### Last Round (Round r)

- Expect end-game defectors (classic backward induction).
- **Decision:**
  - Cooperate if:
    - You alone cannot ensure threshold by cooperating.
    - You believe enough others will cooperate.
  - Otherwise, defect.
- Practically:
  - Cooperate only if at least m-1 other players cooperated in round r-1.
  - Otherwise, defect since cooperation may be exploited.

---

### Summary of Cooperation Condition:

| Round       | Condition to Cooperate                          |
|-------------|------------------------------------------------|
| Round 1     | Always cooperate                                |
| Rounds 2..r-1 | Cooperate if: part of minimal cooperation set (size ≥ m) and you are among first m cooperators to avoid excess |
| Round r     | Cooperate only if enough others cooperated last round to expect threshold met |

---

### Pseudocode

```python
cooperator_set = set([my_id])  # Known cooperators, self included

for round in range(1, r+1):
    if round == 1:
        action = "C"  # Cooperate initially

    elif round < r:
        # From history, find players who cooperated in most rounds
        coop_counts = {player_id: count_cooperations(player_id) for player_id in all_players}

        # Define threshold for being a "cooperator": cooperated at least once before
        cooperator_candidates = {pid for pid, count in coop_counts.items() if count > 0}

        # Update cooperator_set to intersection with previous plus new candidates
        # Remove persistent defectors (zero cooperation history)
        cooperator_set = (cooperator_set & cooperator_candidates) | set([my_id])

        if len(cooperator_set) < m:
            # Not enough known cooperators, cooperate to encourage participation
            action = "C"
            cooperator_set.add(my_id)
        else:
            # Sort cooperators to pick who cooperates this round, avoid over-contributing
            sorted_cooperators = sorted(cooperator_set)
            # Cooperate if my_id is within first m cooperators
            action = "C" if my_id in sorted_cooperators[:m] else "D"

    else:  # Last round
        # Check if >= m-1 cooperated in previous round
        prev_coops = count_cooperations_in_round(round-1)
        if prev_coops >= m-1:
            action = "C"
        else:
            action = "D"

    # Execute chosen action
    play(action)

    # Observe actions to update cooperator_set after round if needed
```

---

### Key Behavioral Notes

- **Minimal cooperation set approach** reduces unnecessary cost yet ensures threshold.
- **Sorted order cooperation allocation** prevents everyone cooperating redundantly.
- **Forgiveness and exclusion** mechanisms support cooperation stability.
- **Last round caution** reduces exploitation risk.
- **Starts cooperatively** to foster trust.
- **Observability** leveraged to adapt dynamically to actual opponent behaviors.

---

### Why This is Cooperative?

- Always aims to meet the minimum threshold m.
- Cooperates early and in crucial slots to achieve the reward.
- Trusts and rewards observed cooperation; punishes persistent defection.
- Avoids wasteful full cooperation but keeps cooperation enough to maintain collective benefit.
- Forgives occasional lapses, encouraging long-term cooperation.
- Recognizes termination point and adjusts behavior accordingly.

---

This strategy balances self-interest and collective benefit to maximize total payoff over repeated rounds while maintaining a cooperative stance.
'''

description_COOPERATIVE_20 = '''
Here is a detailed cooperative strategy tailored to the Collective Risk Dilemma. It aims to foster mutual cooperation across repeated rounds by conditional cooperation and contingency on observed group behaviour.

---

### Cooperative Strategy: **Contingent Threshold Cooperation**

---

#### Intuition:
- Cooperation is beneficial if the group can meet or exceed the threshold \( m \).
- Defecting can yield higher payoff in some rounds but undermines collective reward.
- Use early rounds to establish cooperation pattern.
- Detect exploitation by defectors and respond by defecting if necessary.
- Always cooperate in the last round to maximize joint payoff since future punishment is not possible (no incentive to defect last round).

---

### Decision Rules

---

#### Parameters and variables:
- \( n, r, m, k \) as given.
- \( t \in \{1,\ldots,r \} \) — current round index.
- \( \text{history}[1..t-1] \) — matrix of all players’ past actions.
- Define \( c_{t-1} \) = number of cooperators in round \( t-1 \).

---

#### Round 1 (Start of the game; no past info):

- **Action:** *Cooperate (C)*
- **Rationale:** Signal willingness to cooperate — establish trust baseline.

---

#### Rounds 2 to r-1 (Intermediate rounds):

- Observe the previous round \( t-1 \):
  - Count \( c_{t-1} \), the number of cooperators.
  - Identify if cooperation was achieved (i.e., \( c_{t-1} \ge m \)).

- **If cooperation threshold met last round:**  
  - If you cooperated last round: *Cooperate (C)* (maintain cooperation)
  - If you defected last round: *Cooperate (C)* (return to cooperation — forgiveness)
  
- **If cooperation threshold NOT met last round:**
  - Check if you cooperated last round:
    - If yes (you cooperated but cooperation failed), **defect** this round (punish defection/free-riding)
    - If no (you defected last round too), **defect** again this round (continued punishment)

---

#### Round r (Last round):

- **Always Cooperate (C)**
- **Rationale:** No future rounds to punish defection, so cooperate to secure group reward and avoid mutual loss.

---

### Summary in Pseudocode:

```python
for t in range(1, r+1):
    if t == 1:
        action = 'C'  # First round cooperation signal

    elif t == r:
        action = 'C'  # Always cooperate last round
    
    else:
        prev_cooperators = count_cooperators(history[t-1])
        cooperation_success = (prev_cooperators >= m)
        my_prev_action = history[t-1][my_index]

        if cooperation_success:
            # Cooperation threshold met last round
            # Forgive if defected; continue cooperating if cooperated
            action = 'C'

        else:
            # Cooperation threshold not met last round
            if my_prev_action == 'C':
                # I cooperated but threshold failed, punish by defecting
                action = 'D'
            else:
                # I defected and threshold failed, continue defecting
                action = 'D'

    play(action)
```

---

### Key Features:

- **Starting Cooperative:** Encourages a cooperative norm.
- **Conditional Cooperation:** Keeps cooperating if group cooperation successful last round.
- **Retaliation & Punishment:** Defects if cooperation threshold is not met after cooperating, discouraging free-riders.
- **Forgiving:** Returns to cooperation immediately if group cooperation successful.
- **Final Round Cooperation:** Secure collective reward without temptation to defect.
- **No Communication or Signaling:** Relies solely on observed history and outcomes.
- **Robust to Noise:** Some tolerance by forgiving after successful rounds.

---

### Handling Edge Cases:

- **If no one cooperates in round 1:**  
  You will defect in round 2, matching the lack of cooperation and punishing all-defection at the start.

- **If threshold \( m \) is very close to \( n \):**  
  Cooperation is fragile; the strategy still attempts to sustain cooperation but punishes defection harshly.

- **If opponents are consistently defecting:**  
  The strategy will defect eventually, avoiding exploitation and minimizing losses.

- **If mixed cooperation/defection around threshold:**  
  Strategy encourages opponents to coordinate on \( m \) or more cooperating players to get the reward.

---

### Cooperative Mindset Alignment:

This strategy tries to:

- Maximize the group reward by sustaining cooperation.
- Promote trust through initial cooperation and forgiveness.
- Discourage exploitation with contingent punishment.
- Ensure the group's collective interest prevails over individual short-term gain.

---

If implemented, this strategy should perform well in a tournament against independent strategies given the parameters and public history constraints.
'''

description_COOPERATIVE_21 = '''
Certainly! Below is a detailed cooperative strategy designed for the Collective Risk Dilemma as specified:

---

## High-Level Strategy Overview:  
**Goal:** Cooperate sufficiently to meet the minimum cooperation threshold *m* each round to secure the collective reward *k*, maximizing everyone's payoff over all rounds.  
**Challenge:** Without communication, ensuring others cooperate enough is risky. Thus, the strategy encourages cooperation but includes monitoring and contingency steps to sustain cooperation dynamically.

---

## 1. Decision Rules: When to Cooperate vs Defect

### Key Intuition:
- Cooperate initially to build trust and set a pattern.
- Monitor the number of cooperators each round.
- If cooperation falters (fewer than *m* cooperators), increase your cooperation probability to try to restore it.
- If cooperation is reliably met, maintain cooperation.
- Towards the end (last round), incentivize defect to maximize own payoff if cooperation breaks down.

---

### Step-by-Step Decision Logic per Round *t*:

#### Round 1 (t=1):  
- **Action:** Cooperate (C) unconditionally.  
- **Reason:** Signal willingness to cooperate and attempt to meet threshold from start.

#### Rounds 2 to r-1 (Intermediary rounds):

1. Observe number of cooperators in previous round, call it *m_prev*.

2. If *m_prev* ≥ *m* (threshold met last round):  
   - Cooperate with high probability (e.g., 0.9).  
   - Defect with low probability (0.1) to test if others maintain cooperation.

3. If *m_prev* < *m* (threshold failed last round):  
   - Cooperate with increased probability, up to 1 (fully cooperate) to restore cooperation.  
   - Optionally, defect with a small probability (e.g., 0.1) to prevent exploitation by persistent defectors.

4. Optional: Track own cooperation frequency and others' cooperation rates to detect persistent defectors. If stubborn defection detected (e.g., same subset defects every round), reduce cooperation probability moderately to protect own payoff.

#### Round r (Final round):

- If cooperation threshold was met in round r-1:  
  - Defect unconditionally.  
  - **Reason:** No future rounds to retaliate; maximize endgame payoff.

- If threshold was not met in round r-1:  
  - Defect unconditionally.  
  - **Reason:** Cooperation unlikely or not profitable at end.

---

## 2. Handling Edge Cases

- **If m is close to n (e.g., m = n - 1):**  
  - Cooperation requires near-unanimity. In this case, cooperate with maximal commitment early on to signal willingness.  
  - Possibly defect in last two rounds instead of only last to avoid being exploited.

- **If k is very large:**  
  - More incentive to cooperate. Choose higher baseline cooperation probability (close to 1) except for final round.

- **If r = 2 (minimum > 1):**  
  - Round 1: Cooperate  
  - Round 2: Defect unconditionally (standard backward induction logic for last round).

- **Detect persistent defectors:**  
  - If the same players defect every round despite efforts, reduce own cooperation probability to avoid continuous loss.

---

## 3. Cooperative Mindset Alignment:

- The core is a **conditional cooperation** strategy: start fully cooperative, maintain cooperation when others reciprocate, attempt to restore cooperation upon failure.

- This aligns incentives across rounds to maximize collective payoff, trusting that most agents aim to reach the threshold.

- Endgame defection is a standard rational move but limited to last round only.

---

## Pseudocode:

```python
# Parameters: n, r, m, k
# Input per round: previous_round_cooperators: set of player indices who cooperated last round
# Track: round number t (1-based)
# Own actions history: self_cooperated_rounds (for edge case detection)

def decide_action(t, previous_round_cooperators, self_id, n, r, m):

    if t == 1:
        # First round always cooperate
        return 'C'

    else:
        m_prev = len(previous_round_cooperators)

        # Edge case: Persistent defection detection (optional)
        # Example heuristic: if player defected in > 80% of past rounds, consider persistent defector

        # Last round logic
        if t == r:
            # Defect unconditionally at the last round
            return 'D'

        # For rounds 2 to r-1
        if m_prev >= m:
            # High cooperation probability when threshold met
            cooperation_prob = 0.9
        else:
            # Increase cooperation to try to restore threshold
            cooperation_prob = 1.0

        # Sample action based on cooperation probability
        if random_uniform_0_1() < cooperation_prob:
            return 'C'
        else:
            return 'D'
```

---

## Summary:

| Round | Condition (Prev round cooperation) | Action                                                        |
|-------|-----------------------------------|---------------------------------------------------------------|
| 1     | N/A                               | Cooperate                                                    |
| 2..r-1| Threshold met (≥ m)               | Cooperate with high probability (~90%), occasionally defect to test trust |
| 2..r-1| Threshold not met (< m)           | Cooperate deterministically to restore cooperation          |
| r     | Any                               | Defect unconditionally (maximize own payoff in final round) |

---

This design balances trust-building, contingent cooperation, and rational defection in the last round consistent with standard repeated game theory intuition and the constraints given.

Let me know if you'd like me to develop a more complex statistical tracking variant or a fully deterministic variant!
'''

description_COOPERATIVE_22 = '''
Below is a cooperative strategy designed to promote collective success in the Collective Risk Dilemma game. The strategy is designed to build trust, sustain cooperation, and maximize joint payoffs, while safeguarding against exploitation by defectors.

---

## Strategy Name: **Conditional Cooperative Contributor (CCC)**

---

## Intuition and Objectives

- **Goal:** Achieve and maintain ≥ m cooperators each round to secure the reward *k* for the group.
- **Approach:** Start cooperatively, reward cooperation, punish defection temporarily, but always seek to restore cooperation.
- **Rationale:** Cooperation benefits everyone if ≥ m players cooperate. Defection risks losing the reward and lowers group payoff.
- **Constraints:** No communication; decisions rely only on history of observed actions.

---

## Decision Rules

### Summary

| Round     | Decision Rule                                      | Comment                              |
|-----------|---------------------------------------------------|-------------------------------------|
| Round 1   | Cooperate                                        | Establish cooperative baseline      |
| Intermediate Rounds (2 to r-1) | Cooperate if ≥ (m-1) others cooperated last round; otherwise defect once then attempt forgiveness by cooperating next round | Conditional cooperation with “grace” pass |
| Last Round (r) | Cooperate if ≥ (m-1) others cooperated last round; else defect | No incentive to forgive last round  |

---

### Detailed Explanation

- **Round 1:** Cooperate to signal willingness to form the cooperative coalition.
  
- **Rounds 2 to r-1:**
  - Observe actions from previous round.
  - If at least *m-1* other players cooperated last round, cooperate this round.
    - This signals your expectation for coalition and trust.
  - If fewer than *m-1* others cooperated last round, defect *once* this round as a "punishment" or deterrent to free-riding.
    - Defecting once warns defectors that cooperation is conditional.
  - After defecting once, if next round others cooperate again at ≥ m-1 level, resume cooperating.
    - This allows the coalition to reform after misunderstandings or errors.
  
- **Round r:** The final round is often a "defection trap" since no future punishment is possible.
  - Hence, defect if last round cooperation was insufficient (≥ m-1 others cooperated).
  - Cooperate only if the coalition seems stable going in.
  
---

## Pseudocode

```
Input: 
  - history of all players' actions in previous rounds:
    For round t:
      actions[t][i] ∈ {C, D} for i = 1..n players

Parameters:
  - m, r, n (from game)
  - my_index: index of this player

Variables:
  - defected_last_round: boolean, initially False

For current round t=1 to r:
  if t == 1:
    action = C

  else:
    previous_round = t - 1
    coop_others = count(players j ≠ my_index with action C in round previous_round)

    if defected_last_round:
      # Forgiveness phase: cooperate to show willingness to rejoin
      action = C
      defected_last_round = False

    else:
      if coop_others >= m-1:
        action = C
      else:
        # Punish by defecting once
        action = D
        defected_last_round = True

    if t == r:
      # Last round: no forgiveness, defect if coalition unstable
      if coop_others < m-1:
        action = D
      else:
        action = C

Output: action ∈ {C, D}
```

---

## Handling Edge Cases

- **First round:** Cooperate unconditionally because no history exists; sets tone for cooperation.
  
- **Last round:** More rational to defect if cooperation was low previously, since future rounds are absent. If previous cooperation was strong, keep cooperating to maximize group payoff.

- **Occasional defector rejoining:** Gracefully allow re-entry into cooperation after defecting once.

- **Coalition near threshold:** Require at least m-1 others cooperating before cooperating ourselves; this maintains stability sufficient to reach *m* cooperators.

- **If others constantly defect:** After repeated failures to reach *m*, will defect increasingly, thereby discouraging futile cooperation.

---

## Cooperative Mindset Summary

- Maximizes chances of achieving the threshold *m* cooperators.
- Punishes defection but allows forgiveness to restore trust.
- Signals willingness to cooperate at first round and after cooperation failures.
- Attempts to sustain cooperation across rounds to maximize collective payoff.
- Does not exploit defectors but avoids being exploited.

---

If all or most players adopt this kind of conditional cooperation strategy, the group is likely to frequently meet or exceed the threshold *m* cooperators, realizing the higher payoffs repeatedly throughout the game.
'''

description_COOPERATIVE_23 = '''
**Overview:**  
The Collective Risk Dilemma is a social dilemma where cooperation leads to a collective reward but incurs an individual cost, and defectors free-ride on cooperators. With repeated rounds and perfect information, we can condition actions on past behavior to sustain cooperation.

---

# Cooperative Strategy: Conditional Reciprocity with Forgiveness ("Reciprocal Cooperate with Threshold and Forgiveness")

**Goal:**  
- Achieve and maintain cooperation of at least *m* players each round to secure the reward *k*.
- Promote mutual cooperation by rewarding cooperation and punishing defection, but allow recovery from accidental defections.
- Recognize last round(s) incentive to defect and adjust accordingly.

---

## 1. Decision Rules (Per Round)

Let:  
- **Round t** ∈ {1, …, r}  
- **History at round t**: the full vector of all players’ past actions  
- **C_count(t-1)**: number of cooperators in previous round  
- **MyAction(t-1)**: my own action in previous round  
- **Threshold m**: minimum cooperators for the reward  
- **Forgiveness parameter f**: number of rounds to wait before punishing after defection detected (suggest f=1)

---

### Round 1 (Initialization)
- Cooperate:  
  - Start by cooperating to signal cooperative intent and attempt to reach the threshold.

---

### Rounds 2 to r-1 (Intermediate rounds)

- If in previous round the number of cooperators ≥ m **and** I cooperated:  
  - Continue cooperating (reward cooperation).
  
- Else if in previous round less than m cooperated:  
  - Check if the number of cooperating players dropped because I or others defected.  
  - If I cooperated but threshold missed, forgive once and cooperate this round (to give chance for others to re-align).  
  - Otherwise, defect this round (punish defection / free riding).  

- Upon detecting player(s) defected while threshold was met in previous rounds:  
  - If defection pattern starts emerging (i.e., < m cooperate in two consecutive rounds), switch to defect until cooperation restored (i.e., threshold reached again).
  
- In essence:  
  - Cooperate if past round cooperation met threshold and I cooperated or I’m in forgiveness round  
  - Defect if threshold missed and no forgiveness round applies  
  - Forgive occasional slip-ups to re-build cooperation

---

### Last Round (Round r)

- Defect:  
  - Since there are no future rounds, the cooperative incentive breaks down (standard game theory endgame effect).
  - Defect to maximize personal payoff.

---

### Optional: Penultimate Round (Round r-1)

- Cooperate if past cooperation was good, else defect (optional step to soften last round defection).

---

## 2. Handling Edge Cases

| Edge Case                         | Response                                                  |
|----------------------------------|-----------------------------------------------------------|
| First round                      | Cooperate to initiate cooperation                         |
| Threshold met with minimal cooperators (exactly m) | Cooperate to sustain threshold                             |
| Past defection by others          | Defect if defection sustained > f rounds; else forgive   |
| Accidental defection by self      | Forgive self once to try to return to cooperation         |
| Last round                       | Defect to maximize personal payoff                        |
| Very low cooperation sustainment | Adapt by defecting to avoid repeated wasteful cooperation |

---

## 3. Pseudocode

```
Initialize:
  forgiveness_counter = 0

For t in 1 to r:
  If t == 1:
    action = Cooperate

  Else if t == r:
    action = Defect  # Last round, no incentive to cooperate

  Else:
    previous_cooperators = count_cooperators_in_round(t-1)
    my_previous_action = my_action_in_round(t-1)
    
    If previous_cooperators >= m:
      If my_previous_action == Cooperate:
         action = Cooperate  # Reward cooperation
      Else:
         # I defected last round, try to return to cooperation
         action = Cooperate

      forgiveness_counter = 0  # Reset forgiveness since cooperation maintained

    Else:  # threshold not met
      If forgiveness_counter < 1:
        # Forgive once, try cooperating again to restore cooperation
        action = Cooperate
        forgiveness_counter += 1
      Else:
        # Punish persistent defection by defecting
        action = Defect

  Execute action
```

---

## 4. Summary

- Start cooperatively to foster trust.  
- Continue cooperating if the group threshold is met and I cooperated last round.  
- Forgive one round of failure to meet threshold and try to re-establish cooperation.  
- Defect after sustained failure to meet threshold.  
- Defect in the final round to maximize personal payoff, accepting the unavoidable endgame defection.

This strategy aligns clearly with a cooperative mindset by first attempting and rewarding cooperation, only defecting if cooperation is broken over multiple rounds, and allowing forgiveness to repair the cooperative equilibrium. It uses perfect information to adapt dynamically to others’ behavior.

---

**This design encourages mutual cooperation over most of the game, maximizing collective payoffs and sustaining the public good reward.**
'''

description_COOPERATIVE_24 = '''
Below is a cooperative strategy designed for the Collective Risk Dilemma as specified. It aims to reliably reach the cooperation threshold \( m \) each round (if possible), maximize collective payoffs, and sustain cooperation throughout the repeated interaction. It also accounts for edge cases like the first and last rounds, and for deviations observed in others.

---

### Key Intuition

- Cooperation yields a higher collective return if \( m \) or more players cooperate.
- Defection yields a higher individual payoff if the group reaches cooperation threshold anyway (free-riding).
- Given repeated rounds and perfect information, it's possible to coordinate on a stable cooperative equilibrium.
- The strategy tries to maintain just enough cooperators (\( m \)) each round.
- It punishes defectors with temporary defection, then attempts to restore cooperation.
- In the last round, the incentive to cooperate diminishes, so the strategy attempts a last precise cooperative coordination.

---

### Strategy Outline

**Notation:**

- \( n \): number of players
- \( r \): total rounds, indexed \( t = 1, \ldots, r \)
- \( m \): cooperation threshold
- \( k \): reward factor
- \( A_{i,t} \): action of player \( i \) in round \( t \)
- \( C_t \): number of cooperators observed in round \( t \) (including yourself)
- \( S_t \): set of players who cooperated in round \( t \)

---

### Pseudocode Decision Rules for Player \( i \):

```pseudo
Initialize:
    cooperators_history = empty list of sets

For round t in 1 to r:

    if t == 1:
        // First round: attempt to cooperate and initiate cooperation norm
        play C

    else if t < r:
        // Not last round

        // Observe past round's cooperation
        previous_cooperators = cooperators_history[t-1]

        if i was in previous_cooperators:
            // I cooperated last round

            if size(previous_cooperators) >= m:
                // Cooperation threshold met last round
                
                // Maintain cooperation only if group is stable
                // Identify "stable cooperators" as those who cooperated last round and have cooperated consistently
                consistent_cooperators = players cooperating in most previous rounds

                if (I am among consistent_cooperators):
                    if size(consistent_cooperators) >= m:
                        play C  // confident cooperation group stable

                    else:
                        // Reduced stable cooperators; try to enforce cooperation by defecting temporarily to signal
                        play D

                else:
                    // I am not consistent cooperator; punish self by defecting to avoid free riding or being exploited
                    play D

            else:
                // Cooperation threshold NOT met last round
                // Defect this round to punish, then attempt to restore cooperative equilibrium next round
                play D

        else:
            // I defected last round

            if size(previous_cooperators) >= m:
                // Defected but group met threshold -> high payoff, freeride again cautiously

                // However, risk of group breakdown; cooperate if others punish
                if I was punished last round (others defected this round or last round against me):
                    play C  // return to cooperation to rebuild trust

                else:
                    play D  // defect to maximize payoff

            else:
                // Group failed to meet threshold

                // Should attempt to cooperate to help rebuild
                play C

    else:
        // Last round: maximize own payoff but encourage cooperation if beneficial

        if size(cooperators_history[t-1]) >= m:
            // Group cooperated last round

            // Defect to free ride, since no future punishment possible
            play D

        else if size(cooperators_history[t-1]) == m - 1:
            // Almost cooperated

            // Try cooperating to push group over threshold

            play C

        else:
            // Cooperation far below threshold

            // Cooperate only if expecting others to cooperate

            if majority cooperated in past rounds:
                play C
            else:
                play D
```

---

### Additional Notes:

- **Tracking consistent cooperators**: Keep track of players that cooperate most rounds (e.g., cooperated ≥ 70% rounds), trust them more to form a stable cooperating group.
- **Threshold cooperation maintenance**: Aim to be part of a cooperating subgroup of size \( m \); if that is not stable, defect temporarily to signal unwillingness to be exploited.
- **Punishment and forgiveness**: Defect in rounds after failed cooperation to punish defectors, but return to cooperation quickly to restore collective gains.
- **Last round behavior**: Since no future rounds remain, defecting is individually rational unless minimal cooperation can push the group into the reward zone without risk.
- **First round cooperation**: Always cooperate first round to establish cooperation norm, as no history exists to justify defection.

---

### Summary of Decision Logic by Round Phase

| Round      | Condition                                      | Action                           |
|------------|------------------------------------------------|--------------------------------|
| Round 1    | No history                                    | Cooperate                      |
| Intermediate rounds | If threshold met last round & you cooperated previously | Cooperate if stable group; else defect briefly to signal |
| Intermediate rounds | If threshold not met last round or you defected | Defect to punish or cooperate to rebuild |
| Last round | If group cooperated last round                | Defect (free ride)              |
| Last round | If group almost cooperated                     | Cooperate to push over threshold|
| Last round | Else                                         | Cooperate if expecting group cooperation; else defect|

---

### Why This Strategy Is Cooperative?

- It **initiates cooperation immediately** to reap collective benefits.
- It **punishes defection**, preventing persistent free-riding.
- It **seeks to stabilize a cooperating group of size \( m \)** rather than everyone cooperating (which may be costly and unstable).
- It **forgives and tries to restore cooperation** quickly, preventing endless retaliation.
- It takes into account the **end-game effect** by modifying last round behavior sensibly.
- It adapts dynamically to observed actions, fulfilling the "perfect information" and "common knowledge" assumptions.

---

If implemented, this strategy should reliably reach or exceed the cooperation threshold over repeated rounds, maximizing collective and individual payoffs in line with a cooperative equilibrium in the Collective Risk Dilemma.
'''

description_COOPERATIVE_25 = '''
Here is a cooperative strategy tailored for the Collective Risk Dilemma with parameters (n, r, m, k). This strategy aims to achieve the cooperative threshold as reliably as possible to maximize collective payoffs, while guarding against exploitation by defectors.

---

### Strategy Overview: "Conditional Threshold Cooperator"

- **Goal:** Achieve cooperation by ensuring at least *m* cooperators per round to realize the collective reward.
- **Approach:** Start cooperatively, monitor others' cooperation rates, adjust if facing persistent defection, and ensure cooperation in critical rounds.
- **Main Insight:** Since if *m* or more players cooperate the payoff improves for everyone, the strategy assumes others want to cooperate but adapts if exploited.

---

### 1. Decision Rules (Per Round t)

#### Initialization
- Maintain a history of actions of all players for previous rounds.
- Track the number of cooperators in each round.

#### On Round 1 (t = 1)
- Cooperate (C) unconditionally.  
  *Rationale:* Test others’ willingness to cooperate; establish cooperative norm.

#### On Intermediate Rounds (1 < t < r)
- Calculate the number of cooperators in the previous round, call it `prev_coop_count`.
- Calculate your own cooperation rate up to round t-1, call it `self_coop_rate`.
- Calculate the average cooperation rate of others up to round t-1, call it `others_coop_rate`.

**Decision:**

- **If `prev_coop_count >= m`:**  
  - Continue to cooperate.  
  *Reason:* Cooperation succeeded last round, maintain trust.

- **Else if `prev_coop_count < m`:**  
  - If `others_coop_rate >= m / n` (significant cooperation in past):  
    - Cooperate anyway to help reach threshold.  
  - Else (others mostly defect):  
    - Defect to avoid exploitation.

---

#### On Last Round (t = r)

- Cooperate **only if** trusting cooperation (i.e., last round had at least m cooperators or average cooperation rates are high),
- Else defect (since no future rounds to punish or reward).

---

### 2. Additional Notes and Edge Cases

- **Reactive Adjustment:** Players who defect repeatedly reduce my incentive to cooperate.  
- **Critical Mass Focus:**  
  Emphasize cooperating if cooperation was strong recently or trending up, to maintain total cooperators ≥ m.

- **Symmetric Behavior:**  
  Assume others use similar reasoning; thus cooperation can stabilize if enough start cooperatively.

- **Handling Defectors:**  
  When others mostly defect, avoid the sucker's payoff by defecting yourself.

---

### 3. Pseudocode

```python
def decide_action(t, r, m, n, history):
    # history: list of dicts with keys 'player_i': 'C' or 'D' for previous rounds
    
    # Count cooperators in previous round
    if t == 1:
        return 'C'  # Start cooperatively
    
    prev_round_actions = history[t-2]  # Zero-indexed list
    prev_coop_count = sum(1 for a in prev_round_actions.values() if a == 'C')
    
    # Calculate cooperation rates per player
    coop_counts = {player: 0 for player in prev_round_actions}
    for round_actions in history:
        for player, action in round_actions.items():
            if action == 'C':
                coop_counts[player] += 1
    
    # Calculate average cooperation rate of others and self
    self_player = 'self'  # replace with your player ID
    self_coop_rate = coop_counts[self_player] / (t - 1)
    others = [p for p in coop_counts if p != self_player]
    others_coop_rate = sum(coop_counts[p] for p in others) / ((t - 1) * len(others))
    
    # Decision rules
    if t == r:
        # Last round: cooperate only if trust is high
        if prev_coop_count >= m or others_coop_rate >= m / n:
            return 'C'
        else:
            return 'D'
    else:
        if prev_coop_count >= m:
            return 'C'  # Cooperation succeeded last round
        else:
            if others_coop_rate >= m / n:
                return 'C'  # Others generally cooperative
            else:
                return 'D'  # Avoid exploitation
```

---

### Summary

This strategy:

- Starts cooperatively,
- Maintains cooperation when it is reciprocated (enough pivot cooperators),
- Withdraws cooperation when others mostly defect to prevent exploitation,
- Cooperates on last round only if it appears beneficial.

This encourages stable cooperation and maximizes group reward while protecting the player from undue exploitation.

---

If you want, I can also provide variations or extensions (e.g., more forgiving, more punitive).
'''

description_COOPERATIVE_26 = '''
Below is a cooperative strategy designed for the *Collective Risk Dilemma* game as specified. It prioritizes cooperation to ensure the community threshold *m* is met whenever possible, while also being robust to defection and adapting based on observed behaviors. The strategy is carefully crafted to encourage mutual cooperation throughout the repeated rounds.

---

## Strategy Overview: Conditional Threshold Cooperation

**Core idea:**  
Cooperate in each round if it appears likely that at least *(m - 1)* other players will also cooperate, ensuring the threshold *m* is met (including the player’s own cooperation). Defect if cooperation seems unlikely to reach threshold, minimizing losses from futile cooperation.

---

## Decision Rules by Round

### Round 1 (No History)
- Cooperate unconditionally.  
- **Rationale:** Start with trust to promote cooperation patterns.

### Rounds 2 to (r - 1) (Intermediate Rounds)
- From previous round's observations, identify which players cooperated.
- Predict that players who cooperated in the last round are likely to cooperate again.
- If the number of predicted cooperators among *others* ≥ *m - 1*, **cooperate** this round (to reach threshold).
- Else, **defect** this round (to avoid losing the endowment when threshold unlikely met).
- If counts are borderline, default to cooperation once (give chance to return to cooperation).

### Last Round (Round r)
- Cooperate only if confident that *m - 1* others will cooperate (using previous round data).
- Else, defect.  
- Because there’s no future, no incentive to punish or reward; protect own payoff.

---

## Additional Details

- **Tracking Cooperation:** Maintain a set/list of players who cooperated in the previous round.
- **Tolerance:** Allow a small margin for uncertainty; if only *m - 2* others cooperated previously (one short of threshold), still try cooperating once more to recover trust.
- **No Forgiveness in Last Round:** Because no future rounds exist, defect if threshold not assured.
- **Tie-breaking:** If multiple players appear equally likely, err on cooperation to stabilize mutual cooperation.

---

## Pseudocode

```python
def decide_action(round_number, r, n, m, history):
    """
    Parameters:
    - round_number: int (1-based index)
    - r: total rounds
    - n: total players
    - m: cooperation threshold
    - history: list of previous rounds' actions
      each element is a dict {player_id: action 'C'/'D'}

    Returns:
    - 'C' or 'D'
    """
    
    if round_number == 1:
        # No history; start cooperatively
        return 'C'
    
    # Get last round actions (dict {player_id: action})
    last_round = history[-1]

    # Identify how many other players cooperated last round
    cooperators = [p for p, a in last_round.items() if a == 'C']
    others_cooperators_count = len(cooperators) - 1  # excluding self

    # Decide based on threshold
    if round_number < r:
        # Intermediate rounds

        if others_cooperators_count >= m - 1:
            # Enough others cooperated; cooperate to exceed threshold
            return 'C'

        elif others_cooperators_count == m - 2:
            # Borderline: give cooperation one more chance
            return 'C'

        else:
            # Too few cooperators; defect to avoid payoff loss
            return 'D'

    else:
        # Last round

        if others_cooperators_count >= m - 1:
            # Cooperate if threshold likely to be met
            return 'C'
        else:
            # Defect as no future rounds to recover trust
            return 'D'
```

---

## Justification and Strengths

- **Starts cooperative** to build trust and initiate mutual cooperation.
- **Conditional cooperation** ensures cooperation only continues if others cooperate too, avoiding exploitation.
- **Adapts dynamically** to observed opponent behaviors without communication.
- **Protects self-interest** by defecting when threshold cooperation seems unattainable.
- **Encourages others to cooperate** by maintaining cooperation when threshold likely reached.
- **Avoids costly cooperation at the end** if no reward expected, maximizing total payoff.

---

## Summary

This strategy embodies a **conditional cooperation approach with memory of one round**, aiming to maintain community benefit while minimizing risks of exploited cooperation. Its design to adjust behavior based on others’ recent cooperation in a fully transparent setting aligns well with the cooperative mindset required to win the tournament against other autonomous LLM strategies.
'''

description_COOPERATIVE_27 = '''
Here is a cooperative strategy tailored to the Collective Risk Dilemma game that aims to maximize collective payoffs by promoting cooperation while guarding against persistent defection.

---

### Strategy Name: **Conditional Conditional Cooperate (CCC) with Forgiveness**

---

### Intuition and Key Ideas

- Cooperation is socially optimal if the threshold *m* is reached — the reward *k* is gained collectively.
- Defection gives a higher immediate payoff vs cooperating in a mixed group unless enough others cooperate.
- To sustain cooperation across rounds, trigger defection if cooperation fails repeatedly among other players.
- Forgive occasional defection so that cooperation can recover.
- In the last round, defect if cooperation is unlikely (no incentive to sustain cooperation past final round).
- Cooperate initially to signal willingness to cooperate and try to reach threshold.

---

### 1. Decision Rules

Let:
- `t` be the current round (1 ≤ t ≤ r)
- `history[t-1]` be the set of all players’ actions in previous rounds
- `coop_counts[t-1]` count of cooperators in previous rounds
- `defection_tolerance` = 1 (number of consecutive rounds of low cooperation tolerated before defecting)
- `consecutive_failures` count of how many consecutive rounds there was cooperation < m

**Round 1 (t = 1):**

- Cooperate to signal willingness.
  
**Rounds 2 to r-1:**

- If in the previous round, coop_count ≥ m, continue to cooperate (trust cooperating group).
- If coop_count < m:
  - Increment `consecutive_failures`.
  - If `consecutive_failures` > `defection_tolerance`, defect (others are not cooperating enough).
  - Else forgive (cooperate) to try to restore cooperation.
- If at any point observed defection from a majority, defect as a protective measure.

**Round r (last round):**

- If cooperation likely (previous rounds had coop_count ≥ m), cooperate — possible last collective gain.
- Else defect — no future rounds, so no future benefit to cooperating.

---

### 2. Edge Cases

- If the threshold *m* equals n-1 (threshold almost all), cooperation demands near-unanimity => Use stricter tolerance.
- If *m* is low, prefer to cooperate unless clear defectors dominate.
- If *k* is just slightly above 1, smaller incentive for cooperation — cooperate but less forgiving.
- If *k* is very large, emphasize cooperation strongly.
  
(Adjust parameters internally if desired, but default defection_tolerance=1 balances forgiveness and protective defection.)

---

### 3. Pseudocode

```
Initialize:
  consecutive_failures = 0

For each round t=1 to r:
  if t == 1:
    action = Cooperate
  else if t == r:
    if previous_round_coop_count >= m:
      action = Cooperate
    else:
      action = Defect
  else:
    if previous_round_coop_count >= m:
      consecutive_failures = 0
      action = Cooperate
    else:
      consecutive_failures += 1
      if consecutive_failures > defection_tolerance:
        action = Defect
      else:
        action = Cooperate

Execute action
```

---

### 4. Additional Notes

- Because players observe all others' actions and payoffs, this strategy relies only on visible cooperation levels.
- The strategy is never the first to defect, fostering trust.
- Forgiveness (acting cooperative after imperfect cooperation) tries to repair cooperation.
- Defection when cooperation repeatedly fails avoids exploitation by consistent defectors.
- In the last round, defection is rational if cooperation is unlikely, preventing being exploited.

---

### Summary

This **Conditional Conditional Cooperate with Forgiveness** strategy:

- Starts cooperative.
- Continues cooperating if cooperation threshold *m* is met each round.
- Forgives one failure to meet threshold before defecting.
- Switches to defection if cooperation repeatedly fails.
- Defects in the final round if cooperation failed previously.
- Promotes stable cooperation and maximizes collective reward *k* over rounds, while protecting itself from defectors.
'''

description_COOPERATIVE_28 = '''
Below is a cooperative strategy tailored for the **Collective Risk Dilemma** described, aimed at fostering cooperation, sustaining it over multiple rounds, and optimizing collective payoffs.

---

## Strategy Name: **Conditional Cooperative Trigger (CCT)**

### Intuition / Summary:
- Start cooperatively to signal willingness to contribute to the group.
- Monitor cooperation levels each round.
- Continue cooperating as long as cooperation meets or exceeds threshold *m*.
- Punish defections temporarily with mild retaliation to discourage free-riding.
- Forgive defections if cooperation resumes.
- In the last round, defect if sufficient cooperation previously ensured payoff, reducing risk of being exploited.

---

### Decision Rules:

1. **Round 1:**
   - Cooperate (play C).
   - Rationale: Establish cooperative intent from the start.

2. **Rounds 2 to (r - 1):**
   - Observe the number of cooperators in the previous round, call it `prev_coop_count`.
   - If `prev_coop_count >= m` (threshold met):
     - Cooperate. This rewards and sustains the cooperative equilibrium.
   - Else (threshold not met previous round):
     - Defect once as a *warning* (or *punishment*).
     - If the next round after defecting, cooperation resumes (≥ m cooperating), forgive and cooperate again.
     - If low cooperation persists, continue defecting to avoid losses.

3. **Round r (last round):**
   - If threshold was met in **all previous rounds** (cooperation stable throughout), defect.
     - Reason: No future consequences; defect to maximize private gain.
   - Otherwise, cooperate in hopes that cooperation still yields some rewards.

---

### Handling Edge Cases:

- **If cooperation threshold is never met in Round 1 → start defecting** progressively until threshold improves, to prevent consistent exploitation.
- **If cooperation is sporadic (< m some rounds, ≥ m others)**: Try to "forgive" after a single defecting punishment round and resume cooperation - avoid long mutual defection cycles.
- **If full cooperation (all C) or near full cooperation persists:** stay cooperative.
- **If threshold very rarely met or cooperation breaks down:** defect to minimize losses, but still ready to return to cooperation if group behavior improves.
  
---

### Pseudocode

```python
# Parameters known from game: n, r, m, k
# Inputs each round t: actions of all players in round t-1

coop_history = []  # keep track of how many cooperated in previous rounds

def decide_action(t, prev_actions):
    # prev_actions: list of actions from previous round, length n
    # t: current round (1-based)
    
    if t == 1:
        # First round: cooperate
        return 'C'
    
    prev_coop_count = prev_actions.count('C')
    coop_history.append(prev_coop_count)
    
    if t < r:
        if coop_history[-1] >= m:
            # Threshold met last round -> cooperate
            return 'C'
        else:
            # Threshold not met last round
            if coop_history[-2] >= m if len(coop_history) > 1 else True:
                # Just dropped below threshold, retaliate once
                return 'D'
            else:
                # Continued low cooperation, defect to avoid loss
                return 'D'
    else:
        # Last round
        if all(c >= m for c in coop_history):
            # Cooperation stable -> defect to maximize payoff
            return 'D'
        else:
            # Cooperation unstable -> cooperate hoping group can
            # achieve threshold to still get reward
            return 'C'
```

---

### Discussion

- This strategy is cooperative since it starts by cooperating and continues whenever the group meets the cooperation threshold—thus maximizing collective payoffs.
- It tolerates occasional defections with a mild, clear response—one round of defection as punishment—intended to disincentivize free-riding without damaging the cooperative equilibrium permanently.
- Forgiveness facilitates return to cooperation and avoids deadlock.
- The last round "endgame" defect ensures own payoff maximization, as there is no further retaliation possible.
- Since opponents are LLM strategies who have the same knowledge but no signaling, this clear, consistent, condition-based approach improves chances of mutual cooperation on repeated interactions.

---

Let me know if you want further elaboration or adaptation for specific values of n, r, m, k.
'''

description_COOPERATIVE_29 = '''
Below is a detailed cooperative strategy designed for the Collective Risk Dilemma game outlined. It balances optimism and caution, leveraging the repeated structure and observability to foster cooperation.

---

## Cooperative Strategy: Conditional Collective Cooperation

### Intuition
- Our goal: consistently reach >= m cooperators per round to secure the reward `k` for all.
- We start by cooperating to signal willingness.
- We monitor others' cooperativeness and punish defectors by defecting once to discourage free-riding.
- With perfect information on all past actions, we can identify who cooperates.
- We tolerate occasional defections to allow for noisy behavior or experimentation.
- In the final round, defect to maximize payoff since no future punishment is possible.

---

### Parameters (internal to strategy)
- **Buffer tolerance T:** number of defections tolerated before punishing (e.g., T=1)
- **Record:** track per-player defections since last cooperation

---

### Variables
- `round`: current round index (1 to r)
- `history`: all players' actions from previous rounds
- `defection_counts[i]`: count of defections by player i since last cooperation or start

---

### Decision Rule per Round

```pseudocode
if round == r:
    // Last round - defect to maximize immediate payoff
    action = D

else if round == 1:
    // First round - cooperate to initiate trust
    action = C

else:
    // For rounds 2 to r-1:
    
    // Step 1: Update defection counts for each player using history from previous round
    for each player i:
        if i defected last round:
            defection_counts[i] += 1
        else:
            defection_counts[i] = 0

    // Step 2: Check number of cooperators last round
    last_round_cooperators = count of players who cooperated last round
    
    // Step 3: Determine if group cooperation reached threshold m last round
    if last_round_cooperators >= m:
        // Cooperation successful last round,
        // continue cooperating unless punished

        // Step 4: If we are not punished (no personal defection_count > T), cooperate
        if defection_counts[my_index] <= T:
            action = C
        else:
            // Punish by defecting once, then reset our defection count to 0
            action = D
            defection_counts[my_index] = 0

    else:
        // Cooperation failed last round (fewer than m cooperators)
        // This is likely caused by defections, punish defectors to enforce cooperation

        // Step 5: Punish all players with defection_counts > T by defecting this round
        // If not a punisher (defection_count <= T), cooperate to try to rebuild trust

        // Option A: If I have defected too many times (self punishment), defect once
        if defection_counts[my_index] > T:
            action = D
            defection_counts[my_index] = 0 // reset self-punishment after acting

        else:
            // Check if any other player has defection_counts > T (defectors to punish)
            punishers_exist = exists i ≠ my_index where defection_counts[i] > T

            if punishers_exist:
                // Defect to punish defectors
                action = D
            else:
                // Cooperate to rebuild cooperation
                action = C
```

---

### Summary

| Situation                                  | Action  |
|--------------------------------------------|---------|
| Round 1                                    | Cooperate (signal goodwill) |
| Last round (round r)                       | Defect (no future repercussions) |
| Last round cooperation >= m and no punished status | Cooperate (maintain cooperation) |
| Personal defection punishment active (own defection_count > T) | Defect once then reset own defection_count |
| Failed cooperation last round (cooperators < m) | Punish players with defection_count > T by defecting |
| Otherwise (attempt to rebuild cooperation) | Cooperate |

---

### Key Features

- **Cooperative mindset:** Start and maintain cooperation, tolerate few defections.
- **Punishment:** Defect once after enough defections by self or others; this deters persistent free-riding.
- **Forgiveness:** Reset counts after punishment, allowing recovery.
- **Last round defect:** Rational backward induction leads to defection when punishment no longer deters.
- **Use perfect info:** Fully leverage transparent histories to base trust.

---

### Advantages

- Promotes stable cooperation by conditional strategies reminiscent of Tit-for-Tat variations.
- Avoids endless punishment spirals by tolerant defection count threshold.
- Realistic adjustment to noise and unexpected defections.
- Clearly cooperative, but not exploitable indefinitely.

---

If you need, I can also provide a more concise pseudocode or explanations of specific edge cases in detail.
'''

description_COOPERATIVE_30 = '''
Below is a detailed cooperative strategy design for the **Collective Risk Dilemma** game as specified.

---

### Strategy Name: **Conditional Mutualism**

---

## Intuition

- The goal is to reliably reach the cooperation threshold \( m \) each round to get the reward \( k \).
- Cooperation costs 1 unit but yields a gain \( k \) if at least \( m \) players also cooperate; defection costs nothing but risks losing the reward.
- Since the game repeats \( r \) rounds with perfect monitoring but no communication, cooperation must be sustained by conditional reciprocity and punishment for defection.
- The key challenge is coordinating on who cooperates each round and punishing defectors without communication.
- To align with the cooperative mindset, the strategy will try to stabilize cooperation early, maintain it, but will punish persistent defection to avoid exploitation.

---

## Assumptions

- Players are rational but the opponents are unknown independent strategies.
- Each player can perfectly observe the actions \( C/D \) by every player in previous rounds.
- Threshold \( m \) is known to all.
- Number of rounds \( r \) known.

---

## Strategy Overview

### Initial Coordination Phase

- **Round 1: Cooperate**  
  Start by cooperating to signal willingness to cooperate.

### Cooperative Maintenance Phase (Rounds 2 to r-1)

- After Round 1, observe the cooperation levels from all players.
- Attempt to maintain at least \( m \) cooperators each round.
- Use a **fixed cooperation assignment based on player indices** to reduce uncertainty:
  - Players with indices \( 1 \) to \( m \) cooperate.
  - Players with indices \( m+1 \) to \( n \) defect.
- If after Round 1, the threshold of \( m \) cooperators was not met, switch to a punishment phase to encourage cooperation next rounds.
- Monitor if assigned cooperators actually cooperate each round.
  - If a cooperator defects unexpectedly, punish by defecting in the following round.
  - If defectors defect as expected, no change.
- If defectors cooperate occasionally, count them towards meeting \( m \) for that round, but keep fixed roles for consistency.

### Punishment Phase

- If threshold \( m \) is not met in any round (excluding last round), **all defect in next round** to punish non-cooperators.
- After punishment round, resume cooperative maintenance trying to restore threshold cooperation.
- Limit punishment to 1 round to avoid endless defection cycles.

### Last Round

- **Round r (last round): Cooperate only if the previous round met threshold \( m \). Otherwise defect.**
- Motivation: No future rounds to enforce reciprocity, so cooperate only if cooperation has been stable till last round.

---

## Detailed Decision Rules (Pseudocode)

```pseudo
Parameters:
- n: number of players
- r: total rounds
- m: threshold cooperators needed
- self_i: my player index (1 ≤ i ≤ n)

State variables:
- past_actions[t][j]: action of player j in round t, for t < current round
- punishment_next_round: boolean (initially False)
- cooperation_stable: boolean (initially True)

For round t in 1 to r:

    if t == 1:
        // Initial phase: signal cooperation
        action = C

    else if punishment_next_round:
        // Punishment round: defect by everyone
        action = D
        punishment_next_round = False

    else:
        // Check if threshold met in previous round:
        coop_count_prev = count of players who played C in round t-1
        threshold_met_prev = (coop_count_prev >= m)

        // Update cooperation_stable status
        if not threshold_met_prev:
            cooperation_stable = False

        // Check if any assigned cooperator defected last round
        assigned_cooperators = players with index ≤ m
        defectors_among_coop = count of assigned_cooperators who played D in round t-1
        
        if defectors_among_coop > 0:
            // Punish by defecting next round, starting now
            punishment_next_round = True
            action = D

        else:
            if t == r:
                // Last round strategy:
                // Cooperate only if cooperation stable until last round
                if cooperation_stable:
                    // Cooperate if assigned cooperator
                    if self_i ≤ m:
                        action = C
                    else:
                        action = D
                else:
                    action = D
            else:
                // Cooperative maintenance phase
                if self_i ≤ m:
                    action = C
                else:
                    action = D

    return action
```

---

## Additional Notes

- **Fixed cooperation assignment** ensures coordination without communication: players with indices 1 to m cooperate consistently so opponents can anticipate cooperation levels.
- **Punishment mechanism** deters free-riding defectors among cooperators.
- Keeps punishment limited to one round to avoid spirals of defection.
- The strategy deliberately ignores defectors outside the assigned cooperators; if defectors outside cooperate, it helps meet threshold but roles remain fixed to reduce complexity.
- In the last round, cooperating only if the cooperation was stable aligns incentives with sustaining cooperation and avoids exploitation when there is no future to enforce cooperation.

---

## Summary

This strategy:

- Starts cooperative deliberately.
- Uses index-based roles to coordinate cooperation toward meeting threshold \( m \).
- Monitors cooperation each round, punishes defection quickly but reverts to cooperation promptly.
- Protects cooperation gains by only cooperating in the final round if cooperation was stable.
- Balances cooperation and strategic punishment to maximize collective payoff while minimizing exploitation risk.

---

If implemented, this strategy should perform well in a tournament of independent LLM-generated strategies due to its focus on mutual cooperation, clear rules, and commitment enforcement.
'''

description_COOPERATIVE_31 = '''
Here is a cooperative strategy tailored to the Collective Risk Dilemma game you described. It aims to coordinate cooperation sufficiently to reach the threshold \( m \) and maintain cooperation across rounds, while guarding against persistent defection by others. This strategy adopts a conditional cooperation mindset designed to foster trust and sustain high group payoffs.

---

## Strategy Name: Gradual Trustbuilding with Threshold Enforcement (GTTE)

---

### 1. Intuition

- **First round:** Start cooperatively to signal willingness to cooperate.
- **Subsequent rounds:** Cooperate if and only if the number of cooperators in the previous round was at least \( m \). Otherwise, defect once to punish the group for failing to meet the threshold.
- After a punishment round, return to cooperation to give the group a chance to re-establish trust.
- In the **last round**, cooperate only if the prior round met the threshold, so as to maximize joint rewards and not be exploited.
- This creates a cycle of cooperation reinforced by collective action thresholds, and deters free-riding and persistent defection.
  
---

### 2. Detailed Decision Rules

Let \( t \in \{1, ..., r\} \) be the round index.

Let \( C_{t-1} \) = number of cooperators in the previous round (for \( t > 1 \)).

Define:

- **Start:** 
  - \( t=1 \): cooperate (C) unconditionally.
  
- **Middle rounds:** For \( 1 < t < r \),
  - If \( C_{t-1} \geq m \) (threshold met last round), then:
    - cooperate (C) this round.
  - Else \( (C_{t-1} < m) \), then:
    - defect (D) **once** as punishment.
    - Return to cooperation next round regardless.
    
- **Last round:** \( t = r \),
  - Cooperate (C) if \( C_{r-1} \geq m \) (previous cooperation successful).
  - Otherwise defect (D), because future retaliation is impossible.

---

### 3. Handling Edge Cases

- **First round (t=1):** Cooperate without history to signal good faith and attempt to establish cooperation.
- **Punishment cycle:** Only punish *once* immediately after a failure to reach threshold, to avoid endless retaliation loops.
- **Last round (t=r):** Defect if threshold unmet previously; no incentive to risk cooperating if others defect due to no future rounds.
- **Persistent defection by others:** The strategy punishes failed coordination with a defect round but will always return to cooperation, assuming others will respond in kind.
- **Misinterpretation or noise:** Since the game assumes perfect information and no noise, simple conditional rules suffice.

---

### 4. Pseudocode

```
INPUT: round t, total rounds r, previous round cooperators C_prev, threshold m

IF t == 1:
    action = Cooperate

ELSE IF t == r:
    IF C_prev >= m:
        action = Cooperate
    ELSE:
        action = Defect

ELSE:  # 1 < t < r
    IF C_prev >= m:
        action = Cooperate
    ELSE:
        IF last_action != "Punish_D":
            action = Defect  # punish once
            set last_action = "Punish_D"
        ELSE:
            action = Cooperate
            set last_action = "Cooperate"
```

*Note:* `last_action` tracks whether the last action was a punishment defect to enforce the one-time punishment rule.

---

### 5. Summary

This **GTTE strategy**:

- Starts cooperative.
- Cooperates conditionally on prior round success.
- Issues a one-time punishment defect to enforce cooperation.
- Returns to cooperation to restore trust.
- Defects on the last round if cooperation previously failed.
- Is explicitly cooperative and aims to sustain the group's threshold attainment, maximizing joint payoffs over repeated rounds.

This strategy balances cooperation and strategic retaliation aligned with the common good of the group, promoting stable coordination in the Collective Risk Dilemma.
'''

description_COOPERATIVE_32 = '''
Below is a cooperative strategy designed specifically for the Collective Risk Dilemma described. It balances incentives, trust-building, and conditional cooperation to help the group reach or exceed the threshold \( m \) each round, thus unlocking the collective reward \( k \).

---

### Strategy Name: Adaptive Conditional Cooperation (ACC)

---

## Intuition and Goals

- **Goal:** Ensure at least \( m \) players cooperate each round to achieve the collective reward \( k \).
- **Problem:** Defectors seek to free-ride for more private payoff, jeopardizing cooperation.
- **Approach:** 
  - Begin cooperatively to signal intent.
  - Track others’ cooperation rates and respond proportionally.
  - Attempt to sustain cooperation but punish persistent defection.
  - Increase cooperation near the last round to maximize final rewards, acknowledging backward induction limits.
  
---

## Decision Rules

### Variables to keep track during play:

- \( t \): current round index (1 to \( r \))
- \( C_j(t') \): indicator if player \( j \) cooperated in round \( t' \)
- \( t' < t \): all past rounds before current
- \( \text{coop\_count}_j = \sum_{t'=1}^{t-1} C_j(t') \): count of times player \( j \) cooperated up to previous round
- \( \text{coop\_rate}_j = \text{coop\_count}_j / (t-1) \) (for \( t > 1 \))
- Set of players: \( \{1, \ldots, n\} \); your index is \( i \)

---

### Parameters chosen for strategy logic (can be tuned)

- \( \theta = 0.6 \): Cooperation threshold ratio to consider a player generally cooperative
- \( \delta \): number of past rounds used to evaluate recent behavior (for simplicity use all past rounds)
- \( \epsilon = 0.1 \): tolerance for borderline cases

---

### Round 1 (First Round)

- **Action:** Cooperate (C)
  
**Reason:** Signal cooperative intent unconditionally. There is no prior information about others’ reliability.

---

### Rounds \( t = 2 \ldots (r-1) \) (Intermediate Rounds)

1. **Count players who cooperated in previous round \( t-1 \):**  
   \( S = \sum_{j=1}^n C_j(t-1) \)
   
2. **Estimate expected cooperation this round:**

   - Identify the subset of players \( S_\text{coop} = \{ j : \text{coop\_rate}_j \geq \theta \} \)  
     (players who have cooperated at least 60% of all previous rounds)
   
   - Predict these will cooperate again.
   
3. **Decision: Cooperate if:**

   - Predicted cooperators in this round \( \geq m-1 \)   
     (Need \( m-1 \) other players expected to cooperate so total cooperation ≥ \( m \))
   - OR if the previous round had fewer than \( m \) cooperators (meaning cooperation failed and needs repair)
   
   Otherwise, defect.

**Why?**

- You cooperate if the group likely achieves threshold (optimistic coordination).
- If previous round failed cooperation, cooperate to re-establish trust.
- Otherwise, defect to avoid being exploited by likely defectors.

---

### Round \( r \) (Last Round)

- **Action:** Cooperate if and only if cooperation threshold \( m \) is likely to be met (same logic as intermediate rounds).
  
- **Reason:** Backward induction normally suggests defection in last round. However, cooperating if cooperation is achievable can maximize payoff, and defecting solo risks all losing final reward if threshold not met.

---

### Summary of Decision Rule \( D(i, t) \):

```
IF t == 1:
    play C

ELSE:
    Compute C_{j}(t-1) for all j
    S = sum over j of C_j(t-1)  # number of cooperators last round
    For each player j:
        coop_rate_j = (number of times j cooperated in rounds 1..t-1) / (t-1)
    S_coop = { j | coop_rate_j >= 0.6 }

    # Expected cooperation count excluding self:
    expected_coop = len(S_coop) - (i in S_coop? 1 : 0)

    # If prior round cooperation below threshold (failure to reach m):
    IF S < m:
        play C  # try to repair cooperation

    ELSE IF expected_coop >= m - 1:
        play C  # likely to reach threshold if I cooperate

    ELSE:
        play D  # too many defectors, defect to avoid loss

```

---

## Edge Cases and Special Notes

- **If you are not in \( S_\text{coop} \), do not count yourself among expected cooperators for prediction.**
- **If cooperation was successful in previous rounds, maintain cooperation.**
- **If cooperation failed, force cooperation to rebuild trust.**
- **No direct punishment beyond withholding cooperation.**
- **No explicit communication—strategy is fully based on observed actions.**
- **In very early rounds (especially round 1), unconditional cooperation aims to bootstrap trust.**
- **In long games (\( r \) large), player history importance increases, smoothing noisy mistakes.**
- **In short games, cooperation might start and end immediately if others defect persistently.**
- **Adjust \( \theta \) if opponents are observed defecting more or less.**

---

## Summary

This **Adaptive Conditional Cooperation** strategy:

- Always cooperates on round 1.
- Maintains cooperation when others cooperate sufficiently.
- Tries to re-establish cooperation after failures.
- Defects when cooperation seems unlikely, protecting own payoff.
- Cooperates in the last round if cooperation is possible.
  
It aligns strongly with cooperative mindset and efficient group payoff maximization while protecting self-interest from exploitation.

---

If you want, I can further help write this in detailed pseudocode or simulate example scenarios.
'''

description_COOPERATIVE_33 = '''
Here is a cooperative strategy designed for the Collective Risk Dilemma repeated game. It aims to balance cooperation incentive with robustness against defections by individual players, leveraging the repeated nature to build trust and sustain cooperation.

---

## Strategy Overview: "Threshold-Triggered Conditional Cooperation"

- **Goal:** Reach or exceed the cooperation threshold *m* each round to secure the collective reward *k*.
- **Key idea:** Cooperate initially and continue cooperating as long as enough players show cooperative behavior in past rounds; otherwise, selectively defect to punish defection but always try to restore cooperation.
- **Rationale:** In a repeated setting, consistent cooperation leads to highest joint payoffs; detecting and responding to defections discourages free-riding.

---

## Detailed Decision Rules

### Notation

- `n`: number of players (including self)
- `r`: total rounds
- `m`: cooperation threshold
- `k`: payoff reward upon threshold met
- `t`: current round (1 ≤ t ≤ r)
- For each past round `j < t`: observed actions of all players (including self)
- `C_t`: set of players who cooperated in round t
- `#C_t`: number of cooperators in round t

### Round 1 (First round)

- Cooperate (`C`)
- **Rationale:** Start by trusting others and aim to reach threshold.

### Rounds 2 to r-1 (Intermediate rounds)

1. **Evaluate cooperation level last round:**

   - Let `#C_{t-1}` be the number of players who cooperated last round.
   
2. **Condition to cooperate this round:**

   - If `#C_{t-1} ≥ m`, then cooperate.
     
     - *Rationale:* At least threshold cooperated last round → positive expected payoff, promote stable cooperation.
   
   - Else, defect.
     
     - *Rationale:* Threshold not reached last round, cooperation failed → punish to signal defection is costly.

3. **Conditional forgiving:**

   - If defected last round, but `#C_{t-2} ≥ m` (i.e., last round threshold failure may be transient), revert to cooperate this round.
   
   - *Rationale:* Avoid permanent breakdown of cooperation due to noise or mistakes.

4. **Maintain own defecting streak max 1 round** to prevent permanent defection cycle.

### Last round (Round r)

- Defect.
- **Rationale:** No future rounds to incentivize cooperation; standard backward induction in finite repeated games.

---

## Edge Cases Handling

- **If `m` is close to `n`:** Threshold strict — rely heavily on others cooperating; if cooperation breakdown detected, defect to avoid being exploited.

- **If `m` is close to 1:** Easier threshold, tend to cooperate unless defectors appear in last round.

- **If environmental noise or mistake detected (e.g., unexpected defection when usually cooperators):** Forgive once to avoid chain defections.

---

## Pseudocode

```python
function decide_action(t, history, n, r, m, k):
    if t == 1:
        return 'C'  # Start cooperating
    
    if t == r:
        return 'D'  # Last round defect
    
    # Get number of cooperators last round
    coop_last = count_cooperators(history[t-1])
    
    if coop_last >= m:
        return 'C'  # Cooperation successful last round, keep cooperating
    
    # Threshold not met last round -> defect as punishment
    # Check forgiveness condition if possible
    if t > 2:
        coop_prev_prev = count_cooperators(history[t-2])
        if coop_prev_prev >= m:
            # Forgive once after cooperation success
            return 'C'
    
    return 'D'  # Otherwise defect
```

---

## Why This Strategy Is Cooperative

- **Initial cooperation:** Demonstrates willingness to cooperate and gains trust.

- **Conditionally sustaining cooperation:** Cooperates only when group behavior indicates collective goal is achieved.

- **Punishes defection:** Defects if threshold not met last round to reduce exploitation by free riders.

- **Forgiveness:** Gives chance to restore cooperation after deviation to avoid endless retaliation.

- **Last round defection:** Matches standard game-theoretic backward induction but preserves cooperation during most of the game.

---

## Summary

| Round               | Action                                       | Reasoning                                    |
|---------------------|----------------------------------------------|---------------------------------------------|
| 1                   | Cooperate                                    | Signal trust, aim to reach threshold        |
| 2 ≤ t < r, if #C≥m  | Cooperate                                    | Cooperation stable, continue cooperating     |
| 2 ≤ t < r, if #C<m  | Defect (punish), except forgiven if last-but-one round was cooperative | Discourage free riding, allow recovery      |
| r (last round)       | Defect                                       | No future incentive to cooperate             |

This strategy balances cooperation incentives, detection and punishment of defectors, and forgiveness to maintain cooperation over repeated rounds resulting in higher collective payoffs and individual benefit aligned with cooperative mindset.
'''

description_COOPERATIVE_34 = '''
Here is a cooperative strategy designed specifically for the Collective Risk Dilemma described. It aims to reliably reach or exceed the cooperation threshold \( m \) each round to generate the reward \( k \), balancing risk and reward over repeated rounds, making use of full observation and perfect recall.

---

## Strategy Name: **Conditional Coordinated Cooperation**

### Key idea:
- Start rounds by cooperating to signal intent.
- Observe others' cooperation levels each round.
- If enough cooperators were present last round (≥ m), continue cooperating.
- If cooperation fell below the threshold last round, temporarily defect to punish and test others' willingness to cooperate.
- In the last round, defect if cooperation was not stable before, else cooperate to maximize reward.
- This pattern encourages stable coordination on achieving at least \( m \) cooperators every round.

---

## Parameters used internally:
- \( n, r, m, k \): game parameters
- \( t \): current round (1 to \( r \))
- History of actions of all players from prior rounds (fully observable)

---

## Decision rules:

### Round 1 (t=1):
- Cooperate (C)
- Rationale: signal cooperative intent immediately, attempt to form cooperation baseline.

### Rounds 2 to \( r-1 \) (2 ≤ t ≤ r-1):
- Let \( C_{t-1} \) = number of cooperators last round.
- If \( C_{t-1} \geq m \) (threshold met last round):
  - Cooperate (C) to maintain cooperation.
- Else (threshold not met last round):
  - Defect (D) this round to avoid paying cost and punish defectors.
  
### Round \( r \) (last round):
- Let \( C_{r-1} \) = number of cooperators round \( r-1 \).
- If \( C_{r-1} \geq m \):
  - Cooperate (C) to gain reward in the final round.
- Else:
  - Defect (D) to maximize private payoff since no future rounds for reciprocity.

---

## Handling edge cases and considerations:

- **If threshold \( m \) is very close to \( n \)** (e.g. \( m = n-1 \)), cooperation might be fragile. The strategy still attempts to cooperate first round, but quickly punishes failure to reach threshold.

- **If multiple consecutive defections occur (e.g. several rounds with < m cooperators):**
  - The strategy will continue defecting to avoid loss.
  - A human- or AI-adapted version could include timed forgiveness to try restarting cooperation after some rounds of punishment, but since no communication is allowed, the simplest form is consistent punishment to signal non-cooperation.

- **If other players start cooperating again after punishment rounds:**
  - Once cooperation meets/exceeds \( m \) again, cooperation resumes.

---

## Pseudocode

```python
def decide_action(t, history, n, r, m, k):
    # history: list of tuples (round, [actions of players])
    # actions are 'C' or 'D'; indexed 0-based for players
    
    if t == 1:
        return 'C'
    
    else:
        previous_round_actions = history[t-2]  # zero-based index; t-2 is previous round
        C_prev = sum(1 for a in previous_round_actions if a == 'C')
        
        if t < r:
            if C_prev >= m:
                return 'C'
            else:
                return 'D'
        else:  # t == r, last round
            if C_prev >= m:
                return 'C'
            else:
                return 'D'
```

---

## Strategy summary:

| Round          | Condition (cooperators last round) | Action     | Rationale                       |
|----------------|-----------------------------------|------------|--------------------------------|
| 1              | —                                 | Cooperate  | Signal willingness to cooperate |
| 2 to r-1       | ≥ m                               | Cooperate  | Maintain successful cooperation |
| 2 to r-1       | < m                               | Defect     | Punish cooperation failure      |
| r (last round) | ≥ m                               | Cooperate  | Gain last round reward          |
| r (last round) | < m                               | Defect     | Maximize private payoff; no future rounds |

---

## Why this is cooperative

- Cooperates initially to try to reach the threshold.
- Maintains cooperation once cooperation threshold is met, helping all players gain \( k \).
- Punishes defection or failure to cooperate by defecting to discourage free-riding.
- Aligns incentives through repeated interaction to stabilize cooperation.
- Attempts to maximize group payoff over multiple rounds, not purely individual short-term gain.

---

Let me know if you want variants incorporating forgiveness, probabilistic cooperation, or more sophisticated reasoning based on observed patterns!
'''

description_COOPERATIVE_35 = '''
Below is a cooperative strategy designed to build and sustain cooperation in the Collective Risk Dilemma (CRD) tournament described. It balances incentives, conditions cooperation on observed behavior, and tries to avoid exploitation.

---

## Strategy Name: Conditioned Reward Reciprocity (CRR)

### Intuition
- **Goal:** Ensure that the cooperative threshold `m` is met every round to secure the risk-averted reward `k`.
- **Approach:** Start by cooperating to send a cooperative signal. 
- From then on, cooperate if others sufficiently cooperated **last round**, defect otherwise.
- This enforces a kind of "grim trigger" with some forgiveness: defect only after failed cooperation rounds.
- On the **last round**, defect unless the past cooperation frequency has been very high to avoid being exploited.
- This strategy aligns incentives toward mutual cooperation while protecting against free-riders.

---

### Parameters Used Internally
- `min_coop_rate`: minimum cooperation frequency threshold to trust cooperators (set ≥ m/n, e.g., slightly above the threshold ratio)
- `forgiveness_window`: number of recent rounds to check cooperation frequency (typically = 1 for immediate response, could be increased for noise tolerance)

---

### Detailed Decision Rules

**At each round t (1 to r):**

1. **Round 1 (initial move):**  
    - Cooperate (C)  
    - Reason: Signal cooperativeness, try to initiate cooperation baseline.

2. **Rounds 2 to r-1:**  
    - Compute number of cooperators last round → `C_{t-1}`  
    - Compute cooperation rate among other players in last round: `(C_{t-1} - own_action_{t-1}) / (n-1)`  
    - If `C_{t-1} ≥ m` **and** cooperation rate among others ≥ `min_coop_rate`:  
        - Cooperate (C)  
    - Else:  
        - Defect (D)  

3. **Round r (last round):**  
    - Calculate total cooperation frequency of all players (including self) over rounds 1 to r-1  
    - If cooperation frequency ≥ `min_coop_rate`:  
        - Cooperate (C)  
    - Else:  
        - Defect (D)  

---

### Pseudocode

```python
# Constants from game parameters (available to strategy)
# n, r, m, k

min_coop_rate = (m / n) + 0.05   # Slightly stricter than threshold for safety margin

# Data structures (maintained across rounds)
past_actions = []  # List of lists, each sublist is length n, actions in that round: 'C' or 'D'

def decide_action(t, i):
    # t: current round (1-based)
    # i: own player index (1-based)

    if t == 1:
        # Round 1: always cooperate to establish baseline
        return 'C'

    if 2 <= t < r:
        last_round_actions = past_actions[t-2]  # round numbering offset: round 1 stored at index 0
        total_cooperators = last_round_actions.count('C')
        coop_others = total_cooperators - (1 if last_round_actions[i-1] == 'C' else 0)
        coop_rate_others = coop_others / (n - 1)

        if total_cooperators >= m and coop_rate_others >= min_coop_rate:
            return 'C'
        else:
            return 'D'

    if t == r:
        # Last round: assess overall cooperation rate
        total_C = sum(
            sum(1 for action in round_actions if action == 'C') 
            for round_actions in past_actions
        )
        total_actions = n * (r - 1)
        overall_coop_rate = total_C / total_actions if total_actions > 0 else 0

        if overall_coop_rate >= min_coop_rate:
            return 'C'
        else:
            return 'D'
```

---

### Strategy Properties

- **Cooperative:** Always tries to meet or exceed the cooperative threshold, aiming to earn the higher payoff.
- **Conditional:** Relies on observed cooperation to keep cooperating; punishes defection by defecting next round.
- **Forgiving:** Only punishes after low cooperation groups; does not defect prematurely.
- **Robust in last round:** Shields self from exploitation in last round by defecting unless cooperation history is good.
- **Simple and implementable:** Based only on last round and summary statistics, aligned with the information available.

---

### Notes on Extensions / Variants

- *Forgiveness window:* Could extend to averaging cooperation over the last few rounds rather than just one, to avoid oscillations.
- *Graduated response:* Instead of binary cooperate/defect, could incorporate probabilistic cooperation if cooperation rate borderline.
- *Adaptive min_coop_rate:* Could update threshold dynamically based on observed opponent behaviors.

---

This strategy balances the risk of exploitation with the benefits of mutual cooperation, aligning well with the collective risk dilemma’s incentives to cooperate to achieve the threshold reward.
'''

description_COOPERATIVE_36 = '''
Below is a carefully designed cooperative strategy for the **Collective Risk Dilemma** game, suitable for a repeated, simultaneous-move game with perfect information but no communication. It aims to foster cooperation to reach the threshold *m* for the reward *k*, while guarding against exploitation.

---

## Cooperative Strategy: Conditional Reciprocity with Gradual Forgiveness

### High-Level Intuition
- **Start cooperatively** to signal willingness to work towards the collective good.
- **Monitor others' cooperation levels** each round.
- **Continue cooperating if enough players cooperated to reach threshold; otherwise, punish defectors by defecting the next round.**
- **Forgive** after punishment to allow cooperation to re-emerge.
- **In the last round, shift to defecting** to avoid being exploited, as no future rounds remain for retaliation or reward.

---

### Key Points

- **Threshold to maintain cooperation:** At least *m* players must have cooperated in the previous round to justify cooperating again.
- **Punishment round:** If threshold not met, defect once to punish defectors.
- **Return to cooperation after punishment:** To allow others to return to cooperation and avoid permanent collapse.
- **Final round:** Defect (since no future rounds, no incentive to cooperate).

---

### Pseudocode Description

```python
# Parameters: n, r, m, k
# Internal state variables:
# - last_round_cooperators_count: number of cooperators in the previous round
# - punishment_flag: boolean indicating whether you are in a punishment round after failed cooperation

initialize:
    punishment_flag = False
    last_round_cooperators_count = n  # Initialized optimistically to encourage cooperation

for round t in 1 to r:

    if t == 1:
        # First round: Start cooperatively
        action = 'C'
        punishment_flag = False

    elif t == r:
        # Last round of the game: defect (no future rounds to reward cooperation)
        action = 'D'

    else:
        if punishment_flag:
            # Punishment round: defect once to punish insufficient cooperation last round
            action = 'D'
            punishment_flag = False  # Reset after one punishment round

        else:
            # After first round and before last round, decide based on last round cooperation count
            if last_round_cooperators_count >= m:
                # Threshold met previously: cooperate to sustain cooperation
                action = 'C'
            else:
                # Threshold not met: defect once to punish
                action = 'D'
                punishment_flag = True  # Signal punishment for next round

    # After action chosen, observe others' actions at end of round (perfect info assumption)
    # last_round_cooperators_count should be updated externally once round ends.

    output action
```

---

### Explanation

1. **Round 1: Full cooperation (C)**  
   - Signals cooperative intent and tries to reach threshold *m* immediately.

2. **Intermediate rounds (2 to r-1): Conditional cooperation**  
   - If *m* or more players cooperated last round (including you), keep cooperating to maintain reward *k*.  
   - If threshold not met last round, defect *this* round once as punishment, then forgive and try cooperation again next round.

3. **Punishment mechanism**  
   - A single defect round following a failed cooperation threshold acts as deterrent against persistent free-riding.

4. **Forgiveness**  
   - Resets punishment_flag after one defect round to avoid permanent breakdown of cooperation.

5. **Last round: defect**  
   - No future punishment or reward possible, so defect to maximize private payoff.

---

### Why does this strategy promote cooperation?

- Starting cooperatively invites others to cooperate.
- Clear conditional behavior to reward cooperation and punish defection.
- Forgiveness allows recovery from noise/errors or miscoordination.
- Defection on last round is standard backward induction rationality, avoiding exploitable vulnerability.
- Clear, deterministic rules make your behavior predictable and trustworthy to other cooperative players.

---

### Handling Edge Cases

- **If multiple players punish simultaneously**, cooperation might temporarily fail but forgiveness allows quick recovery.
- **If cooperation oscillates below threshold repeatedly**, punishment rounds increase frequency of defections, creating incentive to avoid persistent defection.
- **If all defect first round**, the strategy will punish with defection next round, leading all to defect and no reward (rational outcome). However, if some cooperate later, cooperation can re-emerge.

---

This strategy balances cooperation incentives and protection against exploitation, suitable for the Collective Risk Dilemma repeated game.
'''

description_COOPERATIVE_37 = '''
**Cooperative Strategy: Conditional Trigger with Forgiveness**

---

### Key Ideas

- **Goal:** Achieve (and maintain) ≥ m cooperators each round, so everyone secures the reward *k*.
- **Approach:** Start cooperative; continue cooperating as long as a sufficient number of others cooperate; defect only if cooperation fails and only for a limited time before retrying cooperation.
- **Rationale:**  
  - Cooperation is Payoff-Maximizing collectively (everyone gets k).  
  - Defection yields short-term gain if enough others cooperate, but risks collapse of cooperation.  
  - Allow "second chances" to avoid persistent retaliation cycles.

---

### Decision Rules

```
Input parameters:
  n: number of players
  r: number of rounds
  m: minimum cooperators needed
  k: reward multiplier

State per round t:
  observed_cooperators_t_minus_1: number of cooperators in previous round
  defection_punishment_counter: counts consecutive punish rounds after defection triggers

Constants:
  PUNISH_ROUNDS = 1  # Number of rounds to defect after failing cooperation threshold
```

---

### Round 1 (t = 1)

- **Action:** Cooperate (C).  
- **Rationale:**  
  - No prior information, so start with a cooperative offer.

---

### Round t > 1 and t < r (not last round)

- **If previous round had ≥ m cooperators:**  
  - Reset defection_punishment_counter to 0  
  - Cooperate this round (C)  
  - Rationale: Cooperation prevails, continue cooperating to maintain it.

- **Else (previous round had < m cooperators):**  
  - If defection_punishment_counter < PUNISH_ROUNDS:  
    - Defect (D) this round  
    - Increment defection_punishment_counter by 1  
    - Rationale: Punish to signal defection is costly; discourage free-riding.

  - Else:  
    - Cooperate (C)  
    - Reset defection_punishment_counter to 0  
    - Rationale: Forgive and try to restore cooperation.

---

### Round t = r (last round)

- **If previous round had ≥ m cooperators:**  
  - Cooperate (C) to maximize last-round mutual gains.  
- **Else:**  
  - Defect (D) to gain immediate payoff since no future rounds to incentivize cooperation.  

---

### Summary of Logic

| Condition                                | Action  | Reason                         |
|-----------------------------------------|---------|--------------------------------|
| t = 1 (first round)                      | C       | Start cooperation               |
| t < r and previous cooperators ≥ m      | C       | Keep cooperating                |
| t < r and previous cooperators < m       | if punishment rounds < PUNISH_ROUNDS: D (punish) else C (forgive) | Signal/Discourage defection, then retry cooperation |
| t = r (last round) and previous cooperators ≥ m | C   | Maximize last-round payoff     |
| t = r and previous cooperators < m      | D       | Defect to maximize own gain    |

---

### Pseudocode

```python
def collective_risk_strategy(t, r, m, observed_cooperators_prev, punishment_counter):
    # First round
    if t == 1:
        action = 'C'
        punishment_counter = 0
        return action, punishment_counter

    # Last round
    if t == r:
        if observed_cooperators_prev >= m:
            action = 'C'
        else:
            action = 'D'
        return action, punishment_counter

    # Intermediate rounds
    if observed_cooperators_prev >= m:
        # Cooperation stable, reset punishment
        punishment_counter = 0
        action = 'C'
    else:
        # Cooperation failed last round
        PUNISH_ROUNDS = 1
        if punishment_counter < PUNISH_ROUNDS:
            action = 'D'
            punishment_counter += 1
        else:
            # Forgive and try cooperation again
            action = 'C'
            punishment_counter = 0

    return action, punishment_counter
```

---

### Cooperative Mindset Alignment

- **Generosity:** Start by cooperating without suspicion.
- **Conditional Cooperation:** Continue cooperating if group cooperates.
- **Firmness:** Defect briefly if cooperation threshold is not met, signaling the cost of free-riding.
- **Forgiveness:** Return to cooperation after punishment to avoid unproductive defection cycles.
- **Rational Exit:** In the last round, defect if cooperation fails, since no future to incentivize cooperation.

---

### Handling Edge Cases

- **First Round:** No prior info; assume goodwill by cooperating.
- **Persistent Defectors:** A single defection triggers temporary punishment; repeated defection causes ongoing cycles but forgiveness always allows repair.
- **Near-Threshold Mutations:** If cooperation hovers just below m, the limited punishment allows quick return to cooperation rather than prolonged conflict.
- **Last Round:** No incentive to maintain cooperation; defect if threshold breached to maximize last-payoff.

---

This strategy balances cooperative incentives against exploitation risk, fostering stable cooperation in repeated rounds while allowing flexibility to recover from defections.
'''

description_COOPERATIVE_38 = '''
Below is a cooperative strategy for the Collective Risk Dilemma game, designed to foster and maintain cooperation across multiple rounds, while mitigating exploitation risks that arise from defectors.

---

## Strategy Name: **Conditional Reciprocity with Threshold Vigilance**

### Intuition:

- Cooperate initially and maintain cooperation so long as at least the minimum threshold **m** of cooperators is consistently met.
- Use observed behavior from previous rounds to detect whether the group is cooperating enough.
- If cooperation drops below **m**, punish by defecting one round to signal defection.
- Return to cooperation if cooperation levels recover.
- In the last round, cooperate only if cooperation prevailed until then (to avoid exploitation by unconditional defectors).

---

### Formal Description:

#### Parameters to track:
- **count_C_previous**: Number of players who cooperated in the previous round (observed).
- **round**: Current round number, from 1 to r.

#### Decision Rules per round:

1. **Round 1 (Initial round)**:
   - **Action:** Cooperate (C)
   - Rationale: Signal willingness to cooperate and attempt to reach threshold m.

2. **Rounds 2 to r-1 (Middle rounds)**:
   - If in previous round, the number of cooperators ≥ m:
     - Cooperate (C).
   - Else (number of cooperators < m):
     - Defect (D) to punish and signal defection.
   - Exception: If you just defected in the previous round (as punishment), cooperate in the current round to give others a chance to recover cooperation.

3. **Round r (Last round)**:
   - Cooperate only if in round r-1 the number of cooperators was ≥ m **and** you have never had to defect as punishment during the game.
   - Otherwise defect (D) to avoid exploitation in the final round by free-riders.

---

### Explanation and Rationale

- **Initial Cooperation** encourages a “cooperate-first” baseline and helps push the group over threshold m.
- **Conditional Cooperation** maintains cooperation only if the group is meeting or exceeding the minimum cooperators m, promoting collective success.
- **Punishment Defection** deters persistent defectors — single round defection signals “I detected defection” and can encourage return to cooperation.
- **Forgiveness ("give a chance")** after punishing defection prevents endless cycles of mutual punishment and allows cooperation to resume.
- **Endgame Defection** protects against last-round free riding by defecting unless cooperation was stable throughout.
- Because payoff from defecting when others cooperate is higher (e.g., defectors earn 3 while cooperators earn 2 in the example), this strategy aims to promote stable group cooperation to maximize collective payoffs.

---

### Pseudocode

```python
# Initialize state
punishment_last_round = False
ever_punished = False

for round in 1 to r:
    if round == 1:
        action = 'C'  # Cooperate
    
    elif round == r:
        # Last round: defect if ever had to punish or cooperation was unstable last round
        if count_C_previous >= m and not ever_punished:
            action = 'C'
        else:
            action = 'D'

    else:
        if punishment_last_round:
            # Forgive after punishment
            action = 'C'
            punishment_last_round = False
        
        else:
            if count_C_previous >= m:
                action = 'C'
            else:
                action = 'D'
                punishment_last_round = True
                ever_punished = True

    # Play action
    # Observe actions of other players this round to update count_C_previous for next iteration
    # (Handled externally; recall these are perfect information assumptions)
```

---

### Notes for Implementation

- The strategy assumes perfect monitoring of the previous round's cooperation level.
- It enforces a simple Pavlovian “win-stay, lose-shift” type behavior centered around the threshold **m**.
- The punishment is mild (single round defection) and followed by forgiveness, to minimize retaliation cycles.
- The strategy explicitly handles the last round to avoid being exploited by defection when future reciprocation is impossible.
- Aligns clearly with cooperative mindset by always initially cooperating and trying to sustain cooperation if the group does.

---

If all players adopt this or similar cooperative strategies, the group will reach or maintain the cooperation threshold **m** easily, maximizing payoffs for everyone. The punishment and endgame defection discourage free riding and promote stable cooperation over repeated rounds.
'''

description_COOPERATIVE_39 = '''
Below is a cooperative strategy tailored to the “Collective Risk Dilemma” game described. The design aims to foster coordination on cooperation to secure the reward, detect and punish free-riding (defection), but also allow forgiveness to return to cooperation. This balances incentive alignment, risk management, and repeated interaction dynamics.

---

### Cooperative Strategy: **Conditional Trust with Forgiveness**

#### Intuition:
- Start fully cooperative to build trust.
- Continue cooperating only if at least **m** players cooperated in the previous round (ensuring the reward was realized).
- If the threshold was not met last round (implying insufficient cooperation), defect in the next round as a "punishment" to signal disappointment.
- After punishing for one round, return to cooperation irrespective of the last outcome to allow reconciliation.
- In the last round, cooperate to maximize collective payoff since no future punishment is possible.
- This generates cycles of cooperation maintained via conditional trust and limited punishment to discourage defection.

---

### Detailed Decision Rules

Let:
- \( t \in \{1, 2, ..., r\} \) index rounds
- At round \( t \), you observe \( C_{t-1} \), the number of players who cooperated in round \( t-1 \)
- Denote last round's payoff for player \( i \) as \( \pi_{i,t-1} \)

**Round 1 (t = 1):**
- Cooperate (C) unconditionally, to start by trying to build cooperation

**Rounds 2 to r - 1 (2 ≤ t ≤ r - 1):**
- If \( C_{t-1} \geq m \), cooperate (C)
  - Reward achieved ⇒ group cooperation probable
- If \( C_{t-1} < m \) and you did **not** defect in round \( t-1 \), defect (D)
  - Punish defectors by withdrawing cooperation for one round
- If in round \( t-1 \) you already defected, **cooperate** (C) this round regardless of \( C_{t-1} \)
  - Forgive after one-round punishment cycle to allow cooperation recovery

**Round r (last round):**
- Cooperate (C) regardless of previous rounds
- No future punishment possible, so cooperate to maximize payoffs

---

### Pseudocode

```python
def decide_action(t, r, m, C_prev, last_action):
    # t: current round number
    # r: total rounds
    # m: cooperation threshold
    # C_prev: number of cooperators in previous round (None if t=1)
    # last_action: your action in previous round (None if t=1)

    if t == 1:
        return 'C'  # Start cooperating

    if t == r:
        return 'C'  # Cooperate in last round always

    # For rounds 2 to r-1:
    if C_prev is None:
        # Defensive fallback, cooperate if no info
        return 'C'

    if C_prev >= m:
        # Reward achieved: cooperate
        return 'C'
    else:
        # Reward missed in previous round
        if last_action == 'D':
            # Already punished last round, now forgive
            return 'C'
        else:
            # Punish by defecting
            return 'D'
```

---

### Key Properties and Rationale:

- **Cooperative Mindset:** Start and end with cooperation; seek to maintain \( m \) or more cooperators each round.
- **Reinforcement of Cooperation:** Cooperation persists as long as previous round met threshold.
- **Punishment and Deterrence:** One round of defection if threshold not met—deterring free-riding and breakdown of trust.
- **Forgiveness:** Only one round of punishment followed by return to cooperation—promotes recovery from occasional defections.
- **No Complex Signaling:** Decision depends only on observable cooperation levels and own last action; aligns with no communication constraint.
- **Use of Perfect Information:** Observes all players’ actions in previous round to determine if cooperation succeeded.
- **Last Round Cooperation:** Helps maximize overall group payoff since backward induction to defect no longer applies strongly.

---

### Potential Extensions (Optional)

- **Tolerance Adjustment:** For large \( n \), could tolerate minor drops below \( m \) before punishing.
- **Gradual Punishment:** Punish for multiple rounds on repeated failures.
- **Randomized Forgiveness:** Occasionally forgive earlier to help restart cooperation faster.

---

This strategy balances maintaining cooperation and discouraging defection with minimal punishment, maximizing collective rewards over multiple rounds given the game's payoff and observation structure.
'''

description_COOPERATIVE_40 = '''
Below is a design of a **cooperative strategy** for the Collective Risk Dilemma game that balances trust, reciprocity, and cautious optimism, adjusted for repeated rounds and the possibility of free-riding.

---

## Strategy Summary

**Core idea:**  
Attempt to achieve or exceed the cooperation threshold **m** every round by cooperating yourself, while conditionally cooperating or punishing based on previous behavior of others. Use first round cooperation and last round forgiveness to foster cooperation and avoid mutual defection spirals.

---

## Decision Rules

### Notation:
- `round`: current round index (1 to r)
- `actions_prev`: actions taken by all players in previous round (list of length n)
- `cooperators_prev`: count of cooperators in previous round
- `k`, `m`, `n`, `r`: game parameters

### Rules:

#### 1. **First Round (round == 1)**  
- **Always Cooperate (C)**  
Reason: Establish baseline trust; no prior info on others, so provide a positive signal.

#### 2. **Intermediate Rounds (1 < round < r)**

- **If `cooperators_prev >= m`**, i.e., previous round met threshold:  
   - Cooperate with **all players who cooperated last round** (including self).  
   - Defect against players who defected last round (punishment for free riding).  
- **If `cooperators_prev < m`**, i.e., previous round failed threshold:  
   - Cooperate to try and reach threshold (optimistic reset).  
   - Exception: If last round had very few cooperators (e.g. 0 or 1), **defect** to avoid exploitation.

*Rationale:* Reward cooperation, punish defection, but give others chance to regain cooperation for collective benefit.

#### 3. **Last Round (round == r)**

- **Defect**, unless:  
  - In the previous round, threshold was met (`cooperators_prev >= m`)  
  - And some others cooperated last round

*Rationale:* Last round is a Prisoner’s Dilemma style endgame—no future punishment possible. Defect to maximize payoff unless a cooperative environment exists strongly supported by others.

---

## Edge Cases

- **No one cooperates first round**: Subsequent rounds defect to avoid exploitation.  
- **Threshold almost met (e.g., m-1 cooperators)**: Still cooperate optimistically to reach threshold.  
- **Repeated defections from majority**: Shift to mutual defection to avoid loss.  
- **If uncertain who cooperated (e.g., in implementation delay)**: Use aggregate count as proxy.

---

## Pseudocode

```python
def decide_action(round, r, n, m, k, actions_prev, player_index):
    # First round: cooperate
    if round == 1:
        return 'C'
    
    cooperators_prev = actions_prev.count('C')
    
    # Last round logic
    if round == r:
        if cooperators_prev >= m and actions_prev[player_index] == 'C':
            return 'C'  # continue cooperating if others cooperated
        else:
            return 'D'  # defect to maximize payoff
    
    # Intermediate rounds
    if cooperators_prev >= m:
        # Reward cooperators, punish defectors
        if actions_prev[player_index] == 'C':
            return 'C'
        else:
            return 'D'
    else:
        # Threshold not met previously
        if cooperators_prev <= 1:
            return 'D'  # too few cooperators, avoid exploitation
        else:
            return 'C'  # try cooperating to meet threshold
```

---

## Cooperative Alignment

This strategy:

- **Starts cooperatively**, signaling trust and preference for collective reward.
- **Uses reciprocity** by rewarding cooperators and punishing defectors, helping stabilize cooperation across rounds.
- **Is forgiving and optimistic** after minor failures to meet threshold, promoting recovery.
- **Recognizes last round endgame logic** to avoid being exploited.
- **Balances risk and reward** by adapting actions based on group outcomes rather than blind unconditional cooperation.

Such a conditional cooperation strategy is well-motivated in repeated collective risk dilemmas, promoting sustained contributions to reach the threshold while deterring persistent free riding.
'''

description_COOPERATIVE_41 = '''
**Strategy Name:** Threshold-Triggered Conditional Cooperation (TTCC)

---

### Overview

This strategy aims to sustain cooperation by:

- Starting cooperatively to signal goodwill.
- Monitoring the group's cooperation level each round.
- Continuing to cooperate if others cooperate sufficiently.
- Retaliating (defecting) if cooperation breaks down, but giving room for forgiveness.
- Cooperating again at the last round to maximize collective reward—since no further punishment possible.

This aligns with cooperative mindset and common knowledge assumptions, balancing the risk of exploitation with the benefit of mutual cooperation over multiple rounds.

---

### Decision Rules

**Notation:**

- Let \( t \in \{1, 2, \dots, r\} \) be the current round.
- \( n \) = number of players
- \( m \) = minimum cooperators needed
- \( k \) = reward multiplier
- Let \( C_{t-1} \) = number of cooperators observed in previous round \( t-1 \).
- If \( t = 1 \), no history available.

---

**Round 1 (Initialization):**

- **Action:** Cooperate (C)
- **Rationale:** Signal goodwill and willingness to cooperate.

---

**Rounds 2 to \( r-1 \) (Ongoing rounds):**

1. **If previous round cooperation level \( C_{t-1} \ge m \):**  
   - **Action:** Cooperate  
   - **Rationale:** Cooperation threshold met, continue cooperating to maintain joint benefit.

2. **If \( C_{t-1} < m \):**  
   - **Action:** Defect once to signal dissatisfaction (punishment).  
   - **Next round:** If following round cooperation \( C_{t+1} \ge m \), forgive and revert to cooperation; else continue defecting.  
   - **Rationale:** Retaliate against defection to discourage free-riding, but allow forgiveness to restore cooperation.

---

**Last Round \( t = r \):**

- **Action:** Cooperate unconditionally  
- **Rationale:** No future punishment possible; cooperation maximizes immediate group payoff.

---

### Handling Edge Cases

- **If no player cooperated in round 1** (including self), respond by defecting in round 2 but attempt to return to cooperation if others cooperate again.
- **If cooperation oscillates below threshold:** Maintain defection until others show willingness to cooperate again.
- **If number of cooperators equals exactly \( m \):** Treat as successful cooperation, continue cooperating.
- **All defect scenario:** Recognize persistent defection; keep defecting until cooperation resumes or game ends.

---

### Pseudocode

```python
def TTCC_strategy(round_t, history, n, m, r):
    """
    round_t: current round (1-indexed)
    history: list of sets of cooperating player indices per previous rounds
    n, m, r: game parameters
    
    Returns: 'C' or 'D'
    """

    # Round 1: always cooperate
    if round_t == 1:
        return 'C'

    # Get previous round cooperators count
    prev_cooperators = len(history[round_t - 2])  # zero-indexed list

    # Last round: cooperate unconditionally
    if round_t == r:
        return 'C'

    # If previous cooperation met threshold, continue cooperating
    if prev_cooperators >= m:
        return 'C'

    # Previous round cooperation below threshold: punish by defecting
    # Check if punishment phase
    # Attempt forgiveness only if last punishment led to increased cooperation
    
    # Check history length to determine if just entered punishment phase
    # If just switched to defect due to low cooperation, continue defecting until cooperation resumes

    # Identify if self cooperated last round
    self_cooperated_last_round = (my_index in history[round_t - 2])

    # If last round cooperation below threshold:
    # Defect this round
    # Forgive if cooperative threshold restored next round (to be handled next round)

    return 'D'
```

---

### Intuition and Rationale

- **Initial Cooperation:** Encourages trust-building.
- **Threshold-Based Continuation:** Cooperation only sustained if enough others reciprocate.
- **Retaliation:** Discourage free-riding; maintain credibility.
- **Forgiveness Mechanism:** Prevents endless cycles of defection from isolated breakdown.
- **Last Round Cooperation:** Capitalize on final round to maximize group payoff without fear of exploitation.

---

### Summary

This TTCC strategy embodies cooperative principles, relying on conditional cooperation anchored on observed behavior. It punishes defection but allows redemption, fostering a stable cooperative outcome in the repeated Collective Risk Dilemma setting.
'''

description_COOPERATIVE_42 = '''
Here is a cooperative strategy designed for the Collective Risk Dilemma, emphasizing collaboration, conditional trust, and punishment of defection to sustain cooperation across repeated rounds:

---

### **Strategy Name:** Gradual Threshold Cooperation (GTC)

---

## **Key Intuition**

- Cooperate if it looks like the group is meeting the threshold **m** in previous rounds.
- Defect temporarily if cooperation is clearly failing, to avoid exploitation.
- Attempt to restore cooperation quickly after a defection.
- Cooperate in the last round to maximize total group payoff (if beneficial).
- Use history to judge when it is safe to cooperate.

---

## **Decision Rules**

### **Notation:**

- Let `t` be the current round (1 ≤ t ≤ r).
- Let `C_t` = number of players who cooperated in round t.
- Let `m` = minimum cooperators needed for reward.
- Let `r` = total rounds.
- Denote `my_action_{t}` is your action in round t.
- Define a cooperation window looking at recent rounds, say previous 1 or 2 rounds.
- Let `past_coop` = boolean indicating if threshold m was met in the previous round(s).

---

### **Round 1 (the first round):**

- Cooperate (C).
  - *Reason:* No information yet; start by signaling willingness to cooperate.

---

### **Rounds 2 to r-1 (middle rounds):**

1. Observe previous round(s) cooperation level:
   - If in the previous round, `C_{t−1} ≥ m`, **Cooperate** this round.
     - You trust the group is mostly cooperative.
2. Otherwise, if `C_{t−1} < m` (threshold not met), implement **punishment/retaliation:**
   - Defect (D) for this round to avoid exploitation.
3. After one round of defection in punishment, attempt to restore cooperation:
   - If in last round `C_{t−1} ≥ m` after your temporary defection, **Cooperate**.
   - Else, continue defecting until cooperation is restored.
4. If multiple rounds of defection and no recovery, cooperate probabilistically (e.g., cooperate with low probability to test if others have changed).

---

### **Last Round (round = r):**

- Cooperate regardless (C).
  - *Reason:* No future rounds to punish; best collective payoff comes from cooperation if threshold met.
  - Exceptions:
    - If all previous rounds have had a complete collapse of cooperation (e.g., everyone defects always), defect to avoid loss.

---

## **Summary:**

| Round Type    | Condition                               | Action            | Brief Rationale                                   |
|---------------|---------------------------------------|-------------------|-------------------------------------------------|
| First round   | t = 1                                 | C (cooperate)     | Signal willingness to cooperate                  |
| Middle rounds | Previous round cooperation ≥ m        | C                 | Trust cooperative group                          |
| Middle rounds | Previous round cooperation < m        | D (defect)         | Punish to avoid losses                            |
| Middle rounds | After 1 round defection, if cooperation restored | C | Attempt reconciliation                            |
| Last round    | t = r, cooperation viable             | C                 | Maximize final payoff                             |
| Last round    | t = r, cooperation collapsed          | D                 | Avoid unnecessary loss                            |

---

## **Pseudocode**

```python
def decide_action(t, r, m, history):
    """
    history: list of dictionaries for each past round with keys:
        - 'num_cooperators': int
        - 'actions': list of 'C' or 'D' for all players including self 
    """
    if t == 1:
        # Round 1: cooperate to signal trust
        return 'C'

    prev_num_coop = history[t-2]['num_cooperators']

    # Last round: cooperate unless cooperation is collapsed
    if t == r:
        all_defect = all(round_i['num_cooperators'] == 0 for round_i in history)
        if all_defect:
            return 'D'
        else:
            return 'C'

    # Middle rounds
    if prev_num_coop >= m:
        # Previous round cooperation successful ⇒ cooperate
        return 'C'
    else:
        # Previous round cooperation failed ⇒ defect to punish
        # Check if we just punished last round, try to reconcile:
        if t >= 3:
            prev_prev_num_coop = history[t-3]['num_cooperators']
            # If last round defect was punish and before that coop good, try cooperate now
            if prev_prev_num_coop >= m:
                return 'C'
        # Otherwise, keep defecting or explore cooperation stochastically
        # For simplicity, keep defecting here
        return 'D'
```

---

## **Handling Edge Cases**

- **If initial defection cascade:** This strategy punishes defection by defecting in response, but also tries to reestablish cooperation after one round of defection by cooperating again to break defection loops.
- **If players mostly cooperate but you detect fewer than m cooperators consistently:** you defect to avoid exploitable losses.
- **If parameters change between games, or opponents are random:** This strategy is robust because it starts cooperatively but punishes defection and attempts to restore cooperation.
- **No communication means relying on observed actions only:** the strategy uses perfect monitoring to identify if the cooperation threshold is met.

---

## **Why this strategy is cooperative**

- Starts by cooperating.
- Cooperates whenever the group appears to meet the collective threshold.
- Only defects to discourage free-riding or exploitation.
- Quickly forgives to maintain potential cooperation.
- Cooperates in the last round to maximize total rewards.

---

This strategy balances trust, retaliation, forgiveness, and forward-looking cooperation—not blindly cooperating but fostering mutual benefit in repeated interactions.
'''

description_COOPERATIVE_43 = '''
Below is a detailed cooperative strategy designed for the given Collective Risk Dilemma repeated game. This strategy focuses on trying to achieve (and maintain) cooperation from enough players to meet or exceed the threshold *m* in every round, thereby maximizing group and individual payoffs over the entire game.

---

## Cooperative Strategy: *Conditional Threshold Cooperation*

### Intuition:
- Cooperation yields a bonus *k* if at least *m* players cooperate.
- Defecting when *m* or more cooperate yields a higher personal payoff individually, but risks group failure if many defect.
- The goal is to coordinate implicitly on cooperating at least *m* players each round.
- Use past rounds’ observed cooperation levels to decide own action.
- Defect only if cooperation consistently fails or during final round to maximize personal endowment if cooperation broke down.

---

### Key Components of the Strategy

- **Trust baseline:** Start by cooperating to signal willingness to cooperate.
- **Observation of past rounds:** Track number of cooperators observed in past rounds.
- **Threshold adjustment:** Only cooperate if past cooperation rates suggest enough cooperators to meet *m*.
- **Punishment for defection:** If cooperation fails repeatedly, defect to avoid being exploited.
- **Final round logic:** In the last round, if no reliable cooperation is observed, defect for guaranteed personal payoff.

---

### Strategy Details

Let:
- \( t \) = current round number, \( t \in \{1, \ldots, r\} \)
- \( C_t \) = number of players who cooperated in round \( t \)
- \( T \) = cooperation history \( (C_1, C_2, ..., C_{t-1}) \)
- \( M = m \) = minimum cooperators needed

---

#### Round 1:
- **Action:** Cooperate (C).
- **Reason:** Establish cooperative baseline, encourage others to cooperate.

#### Round \( t > 1 \) and \( t < r \):

- Compute the *average number of cooperators* over past rounds

\[
\overline{C} = \frac{1}{t-1} \sum_{\tau=1}^{t-1} C_{\tau}
\]

- Decision rule:

  - If \(\overline{C} \geq M\), **Cooperate.**  
    (Past rounds showed enough cooperation, expect cooperation to continue.)

  - Else, **Defect.**  
    (Less than threshold cooperation on average, avoid exploitation.)

#### Round \( t = r \) (last round):

- Compute \(\overline{C}\) as above.
- If \(\overline{C} \geq M\), **Cooperate.**  
  (Cooperation stable; maintain group gain.)
- Else, **Defect.**  
  (Last round, no incentive to sustain cooperation; maximize own payoff.)

---

### Additional Notes

- This strategy assumes that other players also seek cooperation.
- Early cooperation creates a focal point for others.
- Defecting when cooperation is low punishes free riders.
- Cooperating only when past rounds suggest likely success reduces risk of exploitation.
- Inherent forgiveness via averaging: a single bad round does not immediately cause defection.
- Last round defect prevents unilateral cooperation exploitation.

---

## Pseudocode

```
Input:
  n, r, m, k  // Game parameters
  history = []  // List of cooperating counts from previous rounds

For each round t in [1...r]:
  if t == 1:
    action = Cooperate

  else:
    avg_cooperators = average(history)

    if avg_cooperators >= m:
      if t == r:
        action = Cooperate
      else:
        action = Cooperate
    else:
      if t == r:
        action = Defect
      else:
        action = Defect

  // After round ends, observe number of cooperators C_t
  history.append(C_t)

  play action
```

---

## Summary

| Round                 | Condition                   | Action    | Reason                               |
|-----------------------|-----------------------------|-----------|------------------------------------|
| Round 1               | Initial                     | Cooperate | Signal cooperation                  |
| Round 2 to r - 1      | Average cooperators ≥ m     | Cooperate | Expect threshold cooperation        |
| Round 2 to r - 1      | Average cooperators < m     | Defect    | Avoid exploitation                  |
| Final round (r)       | Average cooperators ≥ m     | Cooperate | Maintain cooperation payoff         |
| Final round (r)       | Average cooperators < m     | Defect    | No incentive to cooperate last round|

---

This strategy balances optimism (starting to cooperate and trusting sufficient cooperator count) with precaution (defecting if cooperation fails repeatedly), aligning with cooperative goals to reach group thresholds whenever feasible while safeguarding against persistent defection.
'''

description_COOPERATIVE_44 = '''
Below is a detailed description of a cooperative strategy designed for the Collective Risk Dilemma as specified. The strategy is aimed at fostering and sustaining cooperation to reach or exceed the minimum threshold \(m\) cooperators each round, maximizing collective payoffs over the repeated rounds, while adapting dynamically to observed behaviors.

---

## Cooperative Strategy: "Conditional Threshold Reciprocity"

### High-Level Intuition

- **Start cooperative** to signal willingness to contribute.
- **Monitor the cooperation level** each round.
- If the group reliably reaches the threshold, **continue cooperating**.
- If cooperation fails, **gradually punish defectors** but allow forgiveness to restore cooperation.
- Near the **last few rounds, defect optimistically only if cooperation has failed repeatedly**, avoiding exploitable endgame defection.
- This balances incentives, deters free-riding, and rewards consistent cooperation, maximizing collective benefit.

---

### Formal Specification

#### Parameters to set (as part of strategy tuning but fixed for play):

- \( T \): Threshold for cooperation rounds to sustain cooperation (e.g., \( T = 2 \) rounds of meeting threshold to stay fully cooperative)
- \( P \): Punishment length after failed cooperation (e.g., \( P = 1 \) round of defecting after failed cooperation)
- \( L \): Number of last rounds to become cautious (e.g., \( L = \max(2, \lceil r/5 \rceil) \))

---

### Variables Tracked Each Round \( t \)

- \( C_t \): Number of cooperators in round \( t \)
- \( \text{thresholdMetRounds} \): Counter for how many recent rounds met cooperation threshold
- \( \text{punishRoundsLeft} \): Number of remaining punishment rounds

---

### Decision Rules (Pseudocode)

```
Initialize:
  thresholdMetRounds = 0
  punishRoundsLeft = 0

For each round t in 1 to r:
  Observe past rounds 1,...,t-1 actions of all players

  // First round: cooperate to build trust
  if t == 1:
    play C
    continue

  // Count cooperators in previous round
  C_prev = number of players who cooperated in round t-1
  
  // Update counters based on previous round results
  if C_prev >= m:
    // Successful cooperation in previous round
    thresholdMetRounds += 1
    // Forgive any punishment phase, reset punishment
    punishRoundsLeft = 0
  else:
    // Cooperation threshold not met in previous round
    thresholdMetRounds = 0
    punishRoundsLeft = P  // Start punishment phase

  // Decision to punish or cooperate
  if punishRoundsLeft > 0:
    // Defect as punishment to discourage free-riding
    play D
    punishRoundsLeft -= 1
    continue

  // Near end-game caution
  if t > r - L:
    // If no steady cooperation established by now, defect
    if thresholdMetRounds == 0:
      play D
    else:
      play C
    continue

  // If cooperation is being met reliably, cooperate
  if thresholdMetRounds >= T:
    play C
    continue

  // Else, cautiously cooperate to encourage cooperation
  play C
```

---

### Explanation

1. **Round 1**: Always cooperate to signal willingness and enable establishing cooperation.

2. **Monitoring Threshold**: After each round, check if cooperation threshold \( m \) was met.
   - If so, increment `thresholdMetRounds` (measuring consecutive successes).
   - If not, reset it and initiate a punishment phase.

3. **Punishment Phase**: Defect for \( P \) rounds to punish defectors, discouraging persistent free-riding.

4. **Forgiveness**: Once cooperation is re-established, punishments are reset, promoting restoration of cooperation.

5. **Endgame Behavior**: In the last \( L \) rounds:
   - If no cooperation succeeded recently, defect to avoid being exploited.
   - Otherwise, keep cooperating to reap rewards and maintain trust.

6. **Default Behavior**: When cooperation is starting or fragile, default to cooperating to encourage others and avoid early breakdown.

---

### Cooperative Mindset Alignment

- **Willingness to help**: Start cooperative regardless of others.
- **Responsiveness**: Observe others’ behavior and adapt gently.
- **Encouragement over punishment**: Punish only briefly, then forgive.
- **Ending safeguards**: Avoid costly exploits late-game but only after repeated failures.
- **Collective gain maximization**: Aims to maintain \( m \) or more cooperators each round to secure rewards.

---

### Possible Extensions / Variants (for tuning or adaptation)

- Adjust \( T \) and \( P \) based on observed volatility or opponent patterns.
- Use memory longer than one round to smooth decisions.
- When observing defectors persistently, escalate punishment or defect permanently.
- Incorporate probabilistic forgiveness to probabilistically cooperate even during punishment.

---

This strategy is well suited to repeated play against unknown but rational players in the Collective Risk Dilemma, and should consistently promote cooperation while deterring free riders, maximizing collective and individual payoffs over the tournament.

---

If you want, I can provide a summary or simplified bullet points. Would you like that?
'''

description_COOPERATIVE_45 = '''
Here is a cooperative strategy designed for the Collective Risk Dilemma game specified. The strategy aims to foster cooperation to consistently meet or exceed the threshold \( m \), thereby securing the reward \( k \) for all players, while adapting based on observed behavior.

---

## Intuition & Goals

- Cooperation benefits all if the threshold \( m \) is met.
- Defectors when threshold is met get extra payoff (+1), so temptation to defect exists.
- Players must balance cooperation to achieve threshold, against exploitation by defectors.
- Repeated play and perfect information support conditional cooperation.
- Without communication, cooperation relies on observed histories and reciprocity.

---

## Strategy Overview

We adopt a **conditional cooperation with forgiveness** approach, inspired by repeated public good and threshold games, structured as follows:

- Attempt to **coordinate cooperation** early to establish mutual trust.
- **Detect defections** after round 1 by counting cooperators.
- If threshold met, continue cooperating.
- If threshold missed due to suspected defection, **punish defectors** by defecting once.
- Then **forgive and return to cooperation** unless persistent defection occurs.
- On the last round, cooperate only if last round cooperation is necessary to reach threshold.

---

## Detailed Decision Rules

### Initial Parameters

- Threshold \( m \)
- Total players \( n \)
- Number of rounds \( r \)
- Current round \( t \)
- Observed actions of all other players in previous rounds
- Own cooperation history

### Variables Maintained

- `suspected_defectors`: Set of player indices suspected of defection
- `cooperate_next_round`: boolean flag indicating intention to cooperate in next round
- `last_round_defections`: number of players defecting last round
- `last_round_cooperators`: number of cooperators in last round

---

### Round 1 (t = 1)

- Cooperate to establish baseline cooperation and attempt threshold \( m \).
- Initialize `suspected_defectors = {}`.

---

### Round t > 1, t < r (middle rounds)

1. **Observe previous round’s actions:**

   - Let `cooperators` = players who cooperated last round
   - Let `defectors` = players who defected last round

2. **Check if threshold was met last round:**

   - If `|cooperators| >= m`, threshold met last round: 
     - Cooperate this round (continue cooperation)

   - Else (threshold missed last round):

     a. Identify if **sufficient cooperators were defected by some**:

        - If you cooperated last round (i.e., contributed c_i=1), threshold missed means too many defectors.
        - Update `suspected_defectors` by adding defectors from previous round.
        
     b. If current round immediately follows a threshold failure, **punish suspected defectors by defecting**:
     
        - Defect to signal dissatisfaction.

     c. After punishing for 1 round, **forgive** and attempt to re-cooperate:

        - Remove all from `suspected_defectors`
        - Cooperate again to try restoring threshold cooperation.

---

### Round r (last round)

- Cooperation pays off only if threshold \( m \) can still be met and bring a positive payoff.

- If current round \( r \) and expected cooperation is to reach threshold:

  - Cooperate if you predict at least \( m-1 \) other players will cooperate (this may be a rough heuristic based on past rounds).

- Else defect, since no future rounds remain to punish or reward cooperation.

---

### Summary of Decision per Round Pseudocode

```python
def decide_action(t, r, m, n, history):
    # history: list of previous rounds' actions per player
    # your index = i
    
    if t == 1:
        # First round: cooperate
        return 'C'
    
    else:
        last_round_actions = history[-1]
        cooperators = [p for p, a in enumerate(last_round_actions) if a == 'C']
        defectors = [p for p, a in enumerate(last_round_actions) if a == 'D']
        
        threshold_met = len(cooperators) >= m
        
        if t == r:
            # Last round logic
            # Estimate if threshold can be met
            estimated_cooperators = len(cooperators)  # Use last round data as proxy
            
            # Cooperate only if threshold can be met
            if estimated_cooperators >= m - 1:
                return 'C'
            else:
                return 'D'
        
        else:
            if threshold_met:
                # Continue cooperating to maintain trust
                return 'C'
            
            else:
                # Threshold failed - punish defectors
                if i in defectors:
                    # I defected last round, maybe punished myself
                    # Return to cooperation unless persistent defection
                    return 'C'
                
                else:
                    # I cooperated last round but threshold failed
                    # Defect this round to punish defectors
                    return 'D'
```

---

## Rationale & Cooperation Alignment

- Cooperate first round to show goodwill and viability of cooperation.
- If threshold hits, continue cooperation to secure common reward \( k \).
- If threshold missed, defect one round to punish free riders who caused failure.
- Then, forgive to restore cooperation.
- Last round cooperate only if cooperation likely pays off.
- This creates an environment where cooperation is beneficial and defection is punished but not endlessly, fostering stable cooperation under repeated interaction.

---

## Handling Edge Cases

- **If persistent defection persists** (threshold missed multiple rounds in a row), repeatedly defect until others return to cooperation. This is stable since mutual defection lowers everyone’s payoff.

- **If threshold impossible to meet** (e.g., many defectors or \( m \) too high), fallback to defection after 2 punish rounds to avoid unnecessary losses.

- Since players observe all histories, they will recognize and respond to cooperation or punishment, enabling this strategy to leverage reputation effects without explicit communication.

---

This cooperative strategy balances optimism (try cooperating), retaliation (punish free riders), and forgiveness (rebuild cooperation), maximizing expected payoffs over \( r \) rounds in the collective risk dilemma.
'''

description_COOPERATIVE_46 = '''
Below is a cooperative strategy for the Collective Risk Dilemma game, designed to foster cooperation and safely navigate risks throughout multiple rounds.

---

### Strategy Name: Gradual Conditional Cooperation with Last-round Adjustment (GCC-LRA)

---

## Intuition

- Start cooperatively to signal willingness to cooperate.
- Stay cooperative as long as enough players cooperate to reach the threshold *m*.
- If cooperation falls below *m* in any round, respond by defecting once to signal disapproval but attempt to return to cooperation.
- In the last round, defect to maximize personal payoff since no future rounds remain to enforce cooperation.
- This balances collective reward maximization and minimizing exploitation across repeated rounds.

---

## Detailed Decision Rules

Let:

- `t` = current round index (1-based)
- `C_t` = set of players who cooperated in round `t`
- `m` = minimum required cooperators per round
- `r` = total number of rounds
- `history` = record of all past rounds’ actions by all players

---

### Round 1 (t=1)

- **Action:** Cooperate (`C`)
- **Reason:** Signal cooperative intent to establish trust and move towards collective gain.

---

### Intermediate Rounds (1 < t < r)

- **Step 1:** Check previous round's cooperation level

  - If `|C_{t-1}| >= m` (threshold met):

    - **Action:** Cooperate (`C`)

      *Rationale:* Reinforce cooperation since threshold was met, ensuring collective reward.

  - Else (`|C_{t-1}| < m`):

    - **Step 2:** Respond to defection

      - If **this is the first round after a defect** (i.e., last round had threshold failure but previous round didn’t), defect once to signal dissatisfaction.

        - **Action:** Defect (`D`)

      - Else (consecutive rounds below threshold):

        - **Action:** Cooperate (`C`)

          *Reason:* Attempt to restore cooperation and avoid endless defection spiral.

---

### Last Round (t = r)

- **Action:** Defect (`D`)

- **Reason:** No future rounds remain to punish or reward; maximize personal payoff given others’ last-round choices.

---

## Summary Table of Actions per Round

| Round       | Condition                                    | Action |
|-------------|----------------------------------------------|--------|
| t = 1       | -                                            | Cooperate (C) |
| 1 < t < r   | Previous round had ≥ m cooperators           | Cooperate (C) |
|             | Previous round had < m cooperators and it’s first such failure round | Defect (D) (signal) |
|             | Previous two rounds or more had < m cooperators | Cooperate (C) |
| t = r       | -                                            | Defect (D) |

---

## Pseudocode

```
Initialize:
  defect_signal = False  # Tracks if we defect to signal after failed cooperation

For each round t in 1 to r:

  if t == 1:
    action = 'C'  # Start cooperative

  else if t == r:
    action = 'D'  # Last round defect

  else:
    prev_cooperators = count_cooperators_in_round(t-1)

    if prev_cooperators >= m:
      action = 'C'
      defect_signal = False  # Reset any signal because cooperation restored

    else:
      # Threshold not met in previous round
      if defect_signal == False:
        action = 'D'  # Defect this round to send signal
        defect_signal = True
      else:
        action = 'C'  # Try to cooperate again to restart cooperation

  play(action)
```

---

## Rationale and Cooperative Alignment

- **Cooperation-first approach:** Starting with cooperation encourages others to cooperate.
- **Responsive signaling:** A single defection after a failed cooperation round acts like a mild punishment to discourage free-riding.
- **Avoiding endless retaliation:** By returning to cooperation after signaling, it fosters reconciliation rather than prolonged conflict.
- **Last round defection:** Standard backward induction wisdom applies here; rational to defect to maximize end payoff.
- **Perfect information leveraging:** Fully uses history to condition decisions, standard in repeated games.

This strategy aims to maximize collective payoff across rounds while protecting itself from exploitation by opportunistic defectors.

---

If you want, I can further refine this with parameter sensitivity (e.g., handling different values of m, k), or extend it to probabilistic cooperation for noisy environments.
'''

description_COOPERATIVE_47 = '''
**Cooperative Strategy for Collective Risk Dilemma**

---

### Core Idea
The strategy’s goal is to foster and maintain cooperation across all rounds, exploiting the repeated nature of the game and perfect monitoring of actions. The cooperative mindset implies aiming to reach and sustain the threshold *m* cooperators each round, maximizing collective payoffs while avoiding exploitation.

---

### Overview of the Strategy

- **First round:** Cooperate, initiating trust.
- **Subsequent rounds:** Cooperate if:
  - At least *(m - 1)* other players cooperated in the previous round (ensuring threshold was met or nearly met),
  - and those cooperators remain consistent in their behavior.
- **Punishment/Recovery:** If threshold not met or defections detected, temporarily punish by defecting for *one* round (to signal defection cost) then revert to cooperating (try to recover cooperation).
- **Last round:** Cooperate if threshold was met in previous round; otherwise defect since no future rounds to incentivize cooperation.

---

### Rationale

- Start cooperatively to establish a baseline.
- Rely on observable past actions to maintain cooperation, trusting players who cooperated recently.
- Quickly punish defections to discourage free-riding.
- Use forgiveness (only one-round punishment) to allow the group to restore cooperation, recognizing that strict grim-trigger can lead to mutual defection and low payoffs.
- In the last round, since no future retaliation is possible, defect if cooperation was broken to avoid being exploited.

---

### Decision Rules in Detail

Define:

- `round`: current round (1 ≤ round ≤ r)
- `prevActions[i]`: array of previous round’s actions for all players `i` (including self)
- `n`: number of players
- `m`: minimum cooperators required
- `defectingPlayers`: players who defected when expected to cooperate

---

### Pseudocode

```python
def decide_action(round, prevActions, n, m, r, history):
    # history: list of previous rounds' actions per player [{player_i: 'C'/'D', ...}, ...]
    # 1-based indexing for clarity
    
    # Round 1: cooperate to signal intent
    if round == 1:
        return 'C'

    # Count how many cooperated last round (excluding self)
    coop_last_round = sum(1 for a in prevActions if a == 'C')

    # Probability or mechanism to handle imperfect observations could refine here,
    # but with perfect info we can rely on exact counts.

    # Determine if threshold was met last round
    threshold_met_last = coop_last_round >= m

    # Get own previous action
    my_last_action = prevActions[self_index]

    # Check if punishment lasts only one round after defection
    # Count how many punish rounds since threshold last broken
    # Implementation detail: track internally if punishment is ongoing

    # Example internal state variables (stored outside pseudocode):
    # punishment_active (boolean), punishment_rounds (integer)

    # For explanation, assume we maintain:
    # punishment_active = True if punished last round, else False

    if round == r:
        # Last round
        if threshold_met_last:
            # Reward cooperation if cooperation appears stable
            return 'C'
        else:
            # No future incentive, defect to avoid being taken advantage
            return 'D'

    # If last round threshold met, cooperate to continue cooperation
    if threshold_met_last:
        return 'C'

    # If last round threshold not met, punish defectors by defecting once
    # but try to return to cooperation next round

    # If punished last round (detected by history), revert to cooperate
    if history[-1][self_index] == 'D' and not threshold_met_last:
        # One round punishment done, now try to recover cooperation
        return 'C'

    # Otherwise, punish defectors once
    return 'D'
```

---

### Summary of Stateful Logic

| Situation                                 | Action |
|-------------------------------------------|---------|
| First round                               | Cooperate (C) |
| Last round & previous threshold met      | Cooperate (C) |
| Last round & threshold not met            | Defect (D) |
| Previous round threshold met              | Cooperate (C) |
| Previous round threshold not met & did not punish last round | Defect (D) (punish) |
| Previous round threshold not met & did punish last round    | Cooperate (C) (forgive) |

---

### Handling Edge Cases

- **Inconsistent behavior by others:** Because the strategy punishes only one round, it allows oscillations and tries to restore cooperation quickly.
- **Sudden defection in middle rounds:** Punishment signals defectors; since forgiveness is quick, strategy avoids lengthy deadlocks.
- **Multiple defectors:** If threshold cannot be reached, will punish by defecting, minimizing loss.
- **Minimum cooperators close to total players (m near n):** Strategy still applies but may result in more frequent defections if threshold hard to reach.
- **Imperfect cooperation in previous rounds:** Since perfect information is given, can accurately count cooperators.
- **If own actions are defective and others cooperate:** Expected to punish by defecting one round if threshold broken, else cooperate.

---

### Cooperative Mindset Alignment

- Initiates cooperation immediately.
- Incentivizes group to meet the threshold.
- Balances enforcement and forgiveness: punishes defections only briefly to maintain group cohesion.
- Attempts to maximize joint payoffs over all rounds.
- Transparent and predictable to other players, promoting trust.

---

If you need, I can also provide a more concise "human-readable" rule set, or expand on state management considerations for actual implementation.
'''

description_COOPERATIVE_48 = '''
Here is a cooperative strategy designed for the Collective Risk Dilemma, aiming to attain or exceed the cooperation threshold m each round to maximize group and individual payoffs over the repeated game.

---

## Strategy Overview

The strategy seeks to build and maintain a stable cooperative group of at least m players by:

- Starting cooperatively to initiate trust.
- Monitoring cooperation levels each round.
- Punishing defections by temporarily defecting to encourage return to cooperation.
- Forgiving defections after punishment to restore cooperation.
- Ensuring cooperation at least in the last round if beneficial.

---

## Decision Rules

### Notation

- Let `t` = current round number, 1 ≤ t ≤ r
- Let `C_t` = number of cooperators observed in round t (including self)
- Let `my_action_{t-1}` = your action in previous round
- Let `punishment_counter` = how many rounds left to punish defectors (initially 0)
- Let `defection_detected` = boolean flag if defection happened in previous round (i.e., C_{t-1} < m)

### Round 1 (First Round)

- **Action:** Cooperate (`C`)
- **Reasoning:** Start with trust and hope others cooperate too, aiming to get the reward immediately.

### For each subsequent round (2 ≤ t ≤ r-1):

- If currently punishing (punishment_counter > 0):
  - Continue defecting (`D`)
  - Decrement punishment_counter by 1
  - **Goal:** Signal disapproval to defectors without over-penalizing

- Else if defection was detected in previous round (`C_{t-1} < m`):
  - Start punishing by defecting this round
  - Set punishment_counter = 1 (punish for 1 round only)
  - **Goal:** Discourage repeated defection via limited punishment

- Else (no defection detected previously):
  - Cooperate (`C`)
  - **Goal:** Reinforce cooperation and achieve threshold reward

### Final Round (t = r)

- Cooperate if cooperation threshold was achieved in previous round or no defection detected recently
- Defect only if punishment is ongoing (i.e., if punishment_counter > 0)
- **Reasoning:** No future rounds to be punished for defection, so if trust is intact, cooperate to maximize final payoff

---

## Edge Cases Handling

- **If cooperation threshold has never been met so far (C_k < m for all k < t):**
  - Strategy remains cooperative to encourage cooperation from others
  - Begin punishing only after observing evidence of defection that reduces threshold

- **If multiple rounds of defecting observed (punishment cycles triggered repeatedly):**
  - Continue alternating cooperation-punishment cycles to stabilize cooperation group
  - Never escalate beyond 1 round of punishment to avoid breakdown of cooperation

- **If all players defect persistently:**
  - Continue cooperating initially but eventually settle into defecting to avoid unnecessary loss
  - This outcome unlikely as autonomous LLM strategies with similar incentives likely to cooperate too

---

## Pseudocode

```python
initialize:
  punishment_counter = 0
  last_round_defected = False

for round t in 1 to r:
  if t == 1:
    action = C   # Start cooperating
  else:
    if punishment_counter > 0:
      action = D
      punishment_counter -= 1
    else:
      if C_{t-1} < m:
        # Defection detected last round, start punishment
        action = D
        punishment_counter = 1
      else:
        # No defection detected
        if t == r:
          # Final round, cooperate if possible
          action = C
        else:
          action = C
  play(action)
  
  observe actions of others => determine C_t
```

---

## Rationale and Summary

- **Start cooperatively** to build trust.
- **Use minimal, proportional punishment** (single round defect) to signal defection disapproval but remain forgiving.
- **Reinforce and reward cooperation** whenever threshold is met.
- **Avoid escalating retaliation** as it can devolve cooperation.
- **Adapt dynamically** to observed behaviors through rounds.
- **Cooperate in last round if stable cooperation**, since there is no risk of future punishment, maximizing final payoff.

This balance between cooperation, punishment, and forgiveness aligns strongly with cooperative mindset and should foster stable group cooperation across repeated rounds.
'''

description_COOPERATIVE_49 = '''
Certainly! Below is a detailed cooperative strategy designed for the Collective Risk Dilemma as you specified. It balances trust-building, conditional cooperation, and considerations for repeated play to maximize collective rewards.

---

### Strategy Name:  
**Conditional Reciprocity with Trust Calibration**

---

### Intuition and Goals:
- **Maximize collective payoffs:** Encourage enough cooperation each round to reach the threshold *m*.
- **Use conditional cooperation:** Cooperate if others cooperated sufficiently in recent rounds, defect if cooperation collapses.
- **Handle uncertainty early and late in the game:** Employ a somewhat forgiving start, but shift toward more strategic play near the end.
- **Incentivize others to cooperate:** Show willingness to cooperate but avoid being exploited.

---

### Decision Rules:

#### 1. Initialization and Parameters
- Let *trust_threshold* = m (minimum number of cooperators required to reach the reward).
- Define a **window** parameter w (e.g., w = 2) to consider cooperation history over the last w rounds.
- Initialize a circular buffer or list to record the count of cooperators in previous rounds.
  
---

#### 2. Round 1 (First Move)

- **Action:** Cooperate (C)
- **Rationale:** Start cooperatively to establish trust and signal willingness to contribute.

---

#### 3. Round 2 to Round r - 2 (Middle Rounds)

- **Step 1:** Observe history of number of cooperators in previous rounds.
- **Step 2:** Compute average cooperation level over last w rounds, e.g.:  
  \[
  \text{avg\_coop} = \frac{1}{w} \sum_{t = current\_round - w}^{current\_round - 1} \text{#cooperators}_t
  \]
- **Decision:**  
  - If \(\text{avg\_coop} \ge m\), cooperate: other players mostly cooperate, so cooperation is rewarded.
  - Else, defect: insufficient cooperation to justify paying the cost.

- **Additional Notes:**  
  - This rule allows quick recovery if temporary defection occurs, as it looks over a window, rather than single rounds.
  - It disincentivizes exploitation — if cooperation falls below threshold on average, defect to punish.

---

#### 4. Round r - 1 (Penultimate Round)

- Same as middle rounds, but **slightly more tolerant**:
  - Cooperate if \(\text{avg\_coop} \ge m - 1\) (i.e., tolerate one less cooperator to encourage cooperation).
- Rationale: As last round nears, it pays to try to collectively reach cooperation again; less incentive to punish harshly.

---

#### 5. Round r (Last Round)

- **Cooperate unconditionally.**
- Rationale: No future punishment possible; best to attempt cooperation and get reward if others do the same.

---

### Additional Strategy Features:

- **Record full round cooperation counts and update after each round.**
- **If at any point continuous defecting detected from majority (>50% of players always defecting last w rounds), consider defecting unconditionally in middle rounds to avoid exploitation.**
- **If personal payoff severely drops (e.g., < 1.5 in last round), be more forgiving next round to restore cooperation.**

---

### Pseudocode Summary

```python
initialize coop_history = []  # stores number of cooperators each round
set w = 2  # cooperation history window size
set threshold = m
set round_count = r

for round_t in range(1, r+1):

    if round_t == 1:
        action = C  # start cooperating

    elif round_t == r:
        action = C  # last round cooperate unconditionally

    elif round_t == r-1:
        avg_coop = average(coop_history[-w:])
        if avg_coop >= threshold - 1:
            action = C
        else:
            action = D

    else:  # middle rounds
        avg_coop = average(coop_history[-w:])
        if avg_coop >= threshold:
            action = C
        else:
            # detect if many defectors persist
            if detect_persistent_defectors(coop_history, threshold, w):
                action = D  # avoid exploitation
            else:
                action = D

    play action

    after round ends:
        observe number_of_cooperators_this_round
        coop_history.append(number_of_cooperators_this_round)

# Helper function detect_persistent_defectors:
# returns True if majority defect for consecutive w rounds, else False
def detect_persistent_defectors(history, threshold, window):
    # if in last 'window' rounds, coop counts always < threshold-1, return True
    if len(history) < window:
        return False
    recent = history[-window:]
    return all(coop_count < threshold - 1 for coop_count in recent)
```

---

### Summary

| Round           | Decision Rule                                                              | Rationale                                 |
|-----------------|----------------------------------------------------------------------------|-------------------------------------------|
| 1 (First)       | Cooperate                                                                 | Signal trust                              |
| 2 to r-2        | Cooperate if avg cooperation over last w rounds ≥ m, else defect          | Conditional reciprocity                   |
| r-1 (Penultimate) | Cooperate if avg cooperation ≥ m - 1, else defect                         | More forgiving, encourage cooperation   |
| r (Last)        | Cooperate unconditionally                                                  | No future punishment; attempt final cooperation |

---

### Why This is Cooperative and Robust
- Starts with cooperation to build trust.
- Uses averaged recent cooperation to forgive isolated defections but punishes persistent free-riding.
- Flexibly adapts near game end to maintain incentives.
- Avoids exploitation by defecting if others consistently defect.
- Encourages sustained collective action and maximizes group rewards.

---

If you'd like, I can also help draft a defensible strategy for a more competitive setting, or one that invites punishment. But for now, this aims at maximizing joint welfare under the stated assumptions.
'''

description_COOPERATIVE_50 = '''
**High-level goal:**  
Maximize collective payoff by ensuring at least *m* cooperators in each round, leveraging repeated interaction to establish trust and support cooperation, but avoid being exploited by persistent defectors.

---

# Cooperative Strategy Outline: "Conditional Gradual Cooperation"

## Intuition:
- Start with cooperation to signal goodwill.
- Monitor responses; if enough players cooperate, maintain cooperation.
- If cooperation falters, adapt to maintain the minimum threshold of cooperators.
- Defect strategically if successful cooperation fails to avoid exploitation.
- Return to cooperation if others return to cooperating.
- In the last round, defect if cooperation is uncertain to maximize payoff (no future punishment).

---

# Detailed Strategy Description

### Notation:
- **Round index**: t (1 ≤ t ≤ r)
- **Set of players**: N = {1,...,n}
- **Own past actions**: A_i,t' for t' < t
- **Observed cooperators last round**: C_t-1 = number of players who cooperated in round t-1
- **Threshold**: m
- **Minimum sustain cooperation:** maintain at least m cooperators, including self
- **Flag for punishment state**: whether currently punishing defectors (boolean)
- **History of cooperation counts**: helps detect trends

---

### Decision Rules

#### Round 1 (t=1):
- Cooperate (C)
  - Rationale: Signal cooperation intent; invest in potential collective gains.

#### For rounds 2 to r-1:

1. **If previous round had ≥ m cooperators:**

   - Repeat your previous round action, if you cooperated before.
     - Why? Stable cooperation expected.
   - If you defected previously (only possible if punishing), try to **return to cooperation** now if sufficient cooperators present.
     - Show willingness to re-establish trust.
     - This prevents endless defection loops.

2. **If previous round had < m cooperators:**

   - Check if you cooperated in previous round:

     - **If yes (you cooperated but cooperation failed):**

       - Switch to defection this round (punishment).
       - You are not willing to be exploited again.
       - Set punishment mode ON.

     - **If no (you defected last round):**

       - Maintain defection (continue punishment).
       - Avoid unilateral cooperation while others defect.

3. **Re-assess after punishment:**

   - Once you observe ≥ m cooperators again, switch back to cooperation to restore mutual benefits.

---

#### Last round (t = r):  

- If in previous round there were ≥ m cooperators:

  - Defect to maximize private payoff.
  - Rationale: No future rounds; no incentive to cooperate.

- Else

  - Defect (already no cooperation).

---

### Summary of Mode Transitions:

- **Cooperation mode:** cooperate unless cooperation failed
- **Punishment mode:** defect after failed cooperation until cooperation threshold met again


---

# Pseudocode

```python
strategy_state = {
    "punishing": False,
}

def decide_action(t, r, m, history_actions):
    # history_actions: list of lists, each sublist is actions of all players in round t-1
    
    if t == 1:
        strategy_state["punishing"] = False
        return "C"  # Signal cooperation
    
    prev_actions = history_actions[-1]  # actions of all players in t-1
    coop_count = prev_actions.count("C")

    # Last round logic
    if t == r:
        if coop_count >= m:
            return "D"  # Defect last round to maximize payoff
        else:
            return "D"  # Cooperation failed, defect
    
    # Rounds 2 to r-1 logic
    my_prev_action = history_actions[-1][my_player_index]

    if coop_count >= m:
        # Cooperation successful last round
        strategy_state["punishing"] = False
        if my_prev_action == "C":
            return "C"  # Keep cooperating
        else:
            # We defected but cooperation is good, return to cooperation to promote it
            return "C"
    else:
        # Cooperation failed last round
        if my_prev_action == "C":
            # I cooperated but threshold not met, I get exploited
            strategy_state["punishing"] = True
            return "D"  # Punish by defecting next round
        else:
            # I defected and cooperation failed, continue defecting
            return "D"
```

---

# Additional Notes

- **Why punish?** Punishment discourages free riders and exploits.
- **Why return to cooperation?** To re-establish cooperation once others comply.
- **Why defect last round?** No future incentive to cooperate; better to maximize payoff.
- **No communication & perfect info:** Actions fully observable → trust based on observed cooperation.
- **Iterated setting:** This conditional strategy facilitates equilibrium with stable cooperation if others use similar reasoning.
- **If multiple defectors?** Punishment will suspend cooperation but strategy will try to restore it if enough players cooperate again.

---

# Strategy Summary

| Round            | Condition                          | Action       | Notes                                   |
|------------------|----------------------------------|--------------|-----------------------------------------|
| 1                | Always                           | Cooperate    | Signal cooperation                      |
| 2 to r-1         | Previous coop count ≥ m          | Repeat prev if C, else return to C  | Maintain cooperation                    |
| 2 to r-1         | Previous coop count < m           | If you cooperated last round: Defect (punish) else Defect | Punish failed cooperation            |
| r (last round)   | Previous coop count ≥ m or not    | Defect       | No future rounds, maximize payoff      |

This strategy aligns with cooperative principles while guarding against exploitation, fostering sustainable cooperation in the repeated collective risk dilemma.
'''

description_COOPERATIVE_51 = '''
**Cooperative Strategy for Collective Risk Dilemma**

---

### Key Intuition

The game rewards collective cooperation once the threshold *m* is met, by granting an additive reward *k* to all players, regardless of their own action. However, defectors enjoy a private benefit (keeping their endowment) which is lost if they cooperate. The dilemma is to foster sufficient cooperation consistently to meet the threshold every round, maximizing long-term payoffs.

Because the game is repeated and players observe all prior actions perfectly, a reciprocal cooperative strategy with accountability is feasible.

---

### Strategy Outline

| Round                 | Action         | Reasoning                                                                                    |
|-----------------------|----------------|----------------------------------------------------------------------------------------------|
| **Round 1**           | Cooperate (C)  | Signal cooperative intent, hoping to establish a 'cooperative equilibrium'                    |
| **Intermediate Rounds (2,...,r-1)** | Cooperate if cooperation threshold met last round; else defect temporarily, then return to cooperate | Reward collective cooperation; punish defections by defecting once but quickly return to cooperation to restore trust |
| **Round r (Final Round)** | Defect (D) if no prior cooperation detected; else cooperate | No future repercussions past last round; defect if no cooperation so far to conserve payoff; else cooperate if cooperative outcome achieved previously |

---

### Detailed Logic

1. **Initialization:**  
   Maintain memory of the number of cooperators per round and own previous round actions.

2. **Round 1:**  
   - Always play **C** to set cooperative tone.

3. **Rounds 2 to r-1:**  
   - If in previous round *m* or more cooperators met, **cooperate**.  
   - If fewer than *m* cooperators met previously, **defect once** (punishment for insufficient cooperation/noncooperation) then **return to cooperate** next round regardless of punishment outcome (forgiveness and re-establishment of cooperation).

4. **Round r (last round):**  
   - If at any previous round *m* or more cooperators met (including round r-1), **cooperate** (to honor cooperation).  
   - Else **defect** (no future rounds to incentivize cooperation, so safeguard own payoff).

---

### Pseudocode

```python
# Inputs: n, r, m, k, current_round, history (list of rounds; each round: list of n actions 'C' or 'D')

def count_cooperators(actions):
    return sum(1 for a in actions if a == 'C')

def cooperative_strategy(current_round, history):

    if current_round == 1:
        # Initial move: cooperate to foster trust
        return 'C'

    # Check if threshold met in any past round
    threshold_ever_met = any(count_cooperators(round_actions) >= m for round_actions in history)

    # Check threshold in previous round only
    prev_round_cooperators = count_cooperators(history[-1])
    threshold_met_prev = prev_round_cooperators >= m

    if current_round == r:
        # Last round decision
        if threshold_ever_met:
            return 'C'  # reward cooperation with cooperation
        else:
            return 'D'  # no incentive to cooperate

    # Intermediate rounds (2 to r-1)
    if threshold_met_prev:
        # Cooperation successful last round => cooperate
        return 'C'
    else:
        # Punishment for failed cooperation last round:
        # Defect once, then forgive (return to cooperation on next round)
        
        # Detect own last action
        my_last_action = history[-1][my_index]
        
        if my_last_action == 'D':
            # Already punished once, forgive now
            return 'C'
        else:
            # Punish now by defecting
            return 'D'
```

---

### Rationale and Properties

- **First round cooperation**: Encourages the establishment of a cooperative norm. Supported by the assumption of rational and cooperative players.

- **Conditional cooperation**: If a cooperating threshold is met, the strategy reciprocates by cooperating again, sustaining cooperation.

- **Punishment**: If the cooperation threshold fails, the strategy defects once to punish free-riders or failed cooperation — incentivizing others to cooperate.

- **Forgiveness**: The strategy quickly forgives by returning to cooperation on the next round, preventing endless cycles of punishment which reduce collective welfare.

- **Last round logic**: Because no future interaction follows, defect if cooperation was never achieved (to preserve private payoff), else cooperate to honor past cooperation.

- **No communication required**: Strategy relies solely on observed previous actions and cooperation thresholds.

- **Cooperation alignment**: Prioritizes collective benefit by ensuring the threshold *m* is reached as often as feasible.

---

### Additional Notes

- Assumes the ability to identify own index `my_index` and remember own past plays.

- The one-round punishment–forgiveness cycle helps maintain cooperation without escalating punishments.

- This strategy balances cooperation and incentive compatibility—cooperate when others cooperate, punish deviations immediately but do not hold grudges.

---

If you want, I can suggest refinements or variants based on parameter values or specific opponent playstyles.
'''

description_COOPERATIVE_52 = '''
Below is a carefully designed cooperative strategy for the Collective Risk Dilemma game. The strategy aims to reliably achieve the cooperation threshold **m** each round to maximize collective payoffs, while maintaining robustness against defectors in a repeated, simultaneous-move environment with perfect information but no communication.

---

## Strategy Overview: **Conditional Reciprocity with Forgiving Coordination**

The strategy intends to:

- **Start cooperatively** to build trust and achieve the threshold.
- **Condition cooperation on observed collective behavior** in the previous round.
- **Forgive occasional defections** to prevent collapse from noise or errors.
- Gradually **increase caution near the end** since future punishments lose leverage.
- **Prioritize meeting or exceeding the minimum cooperators (m)** every round to secure the reward.

---

## Terminology and Variables

- `n`: number of players
- `r`: total rounds
- `m`: minimum required cooperators
- `k`: reward multiplier for reaching the threshold
- `t`: current round index (1-based)
- `last_cooperators`: number of players (including yourself) who cooperated in round `t-1`
- `threshold_met_last_round`: boolean indicating if `last_cooperators >= m`
- `trust_counter`: counts how many consecutive rounds the threshold was met
- `forgiveness_limit`: maximum tolerated consecutive defections before defecting yourself

---

## Detailed Decision Rules

### Round 1 (Initialization)

- Cooperate unconditionally.
- Reason: Start by trusting others to cooperate.

### Subsequent Rounds (2 ≤ t < r)

- If the threshold was met last round, **cooperate** again:
  - This demonstrates successful cooperation; keep cooperating.
- If the threshold was *not* met last round, but:
  - The number of cooperators was close to `m` (e.g., `last_cooperators >= m - 1`):
    - **Still cooperate**, assuming some accidental defections.
  - Else:
    - **Defect** this round, as cooperation failed and players may be defectors.
- Maintain a **forgiveness counter** to avoid punishing isolated defections harshly:
  - Allow up to `forgiveness_limit` consecutive rounds without threshold met before switching permanently to defection.
- If your own action was a defection in the previous round (due to punishment), and you see the threshold met now, **forgive** and return to cooperation.

### Last Round (t = r)

- If in previous rounds cooperation succeeded reliably, cooperate one last time.
- Otherwise, **defect**, since no future rounds exist to enforce cooperation.

---

## Additional Notes

- Because all players observe all actions and payoffs, players using similar logic will rapidly establish an equilibrium at cooperation.
- Setting `forgiveness_limit` (e.g., 1 or 2 rounds) prevents cascading defections from a single defector ruining cooperation.
- If players perceive persistent defection by some, the strategy avoids consistently losing to defectors by defecting as well.
- This strategy leverages the *repeated nature* and *perfect information* but respects no communication.

---

## Pseudocode

```python
initialize:
    trust_counter = 0
    forgiveness_limit = 2
    consecutive_failures = 0

for round t in 1 to r:
    if t == 1:
        action = 'C'
        last_cooperators = n  # assume all cooperated (unknown before play)
        
    else:
        # Determine if threshold met last round
        threshold_met_last_round = (last_cooperators >= m)

        if threshold_met_last_round:
            consecutive_failures = 0
            trust_counter += 1

            # Cooperate if not last round, otherwise see next condition
            if t < r:
                action = 'C'
            else:
                # Last round & cooperation history good -> cooperate
                action = 'C'

        else:  # threshold not met last round
            consecutive_failures += 1

            if (last_cooperators >= m - 1) and (consecutive_failures <= forgiveness_limit):
                # Near threshold, forgive occasional failures
                action = 'C'
            else:
                # Too many failures or too far from threshold -> defect
                action = 'D'

            if t == r:
                # Last round with poor history -> defect
                action = 'D'

    # After all players act, update last_cooperators by counting cooperators observed this round
    # (This information will be available next round, so it's used for the next iteration)

    output action
```

---

## Summary

| Round Condition               | Action        | Reason                                  |
|------------------------------|---------------|-----------------------------------------|
| Round 1                      | Cooperate (C) | Establish trust                        |
| Threshold met previous round | Cooperate (C) | Continue cooperation                   |
| Threshold missed but almost met last round (≥ m-1 cooperators) & forgiveness applies | Cooperate (C) | Forgiving minor lapses                  |
| Threshold missed and not almost met or forgiveness limit exceeded | Defect (D)   | Protect self from sustained defection  |
| Last round with good history | Cooperate (C) | Maximize reward                        |
| Last round with bad history  | Defect (D)    | No future to enforce cooperation       |

---

This strategy is cooperative by design, resilient via conditional reciprocation, and pragmatic in punishing persistent defection. It encourages a stable equilibrium of successful cooperation rounds, maximizing all players’ payoffs in the repeated game context.
'''

description_COOPERATIVE_53 = '''
Below is a cooperative strategy designed to maximize joint payoffs by facilitating coordination on meeting the threshold *m* of cooperators in each round, while maintaining resilience against free-riding defectors. The strategy focuses on establishing cooperation early, monitoring others’ behavior, punishing persistent defection, and re-establishing trust, all within the repeated interaction framework.

---

## Intuition / Summary

- **Goal:** Consistently achieve ≥ *m* cooperators per round so everyone earns the reward *k*.
- **Challenge:** Defectors gain private payoff advantage (1 + k) when threshold is met, but if too many defect, reward is lost.
- **Solution:**  
  - Start cooperatively to signal willingness.
  - Track cooperation levels each round.
  - If threshold *m* achieved, maintain cooperation to sustain rewards.
  - If threshold not met or significant defection detected, punish by defecting until cooperation is restored.
  - Use clear, simple decision rules based on observable cooperation count each round.
  - On last round, defect if unilateral defection yields higher payoff (standard backward induction).

---

## Strategy Details

### Parameters / Variables

- Input known parameters: n, r, m, k.
- Track per round:  
  - **cooperators_count** = number of players who cooperated last round (including self).
  - **round_number** (1 to r)
- Track history of others:
  - Maintain a count or flag of persistent defectors if desired (optional for complexity).

### Decision Rules

#### Round 1 (First round)
- **Action:** Cooperate (C)
- **Reason:** Signal cooperation and try to establish trust baseline.

#### Rounds 2 to (r-1) (Intermediate rounds)
- **If** last round cooperators_count ≥ m:  
   - **Action:** Cooperate (C)  
   - **Reason:** Threshold achieved; maintain cooperation to continue earning reward.
- **Else** (last round cooperators_count < m):  
   - **Action:** Defect (D)  
   - **Reason:** Threshold not met, so likely presence of defectors; punish by defecting.
- Optional refinement:  
   - If last round threshold not met due to just below m cooperators and your own cooperation, consider defecting only once, then try cooperating again in following rounds to restore cooperation.
   - Alternatively, keep a flag and defect 1-2 rounds, then revert to cooperate to test if cooperation can resume.

#### Round r (Last round)
- **If** last round cooperators_count ≥ m:  
   - **Action:** Defect (D)  
   - **Reason:** No future retaliation is possible; defect to maximize own payoff.
- **Else**:  
   - **Action:** Defect (D)  
   - Defection dominates if threshold not met anyway.

---

## Pseudocode

```python
def choose_action(round_number, last_cooperators_count, m, r):
    if round_number == 1:
        # Always cooperate first round
        return 'C'
    elif round_number == r:
        # Last round: defect to maximize individual payoff
        return 'D'
    else:
        if last_cooperators_count >= m:
            # Threshold met last round: cooperate to sustain reward
            return 'C'
        else:
            # Threshold missed: punish by defecting
            return 'D'
```

---

## Cooperative Mindset Alignment

- Starts by cooperating to build trust.
- Encourages stable groups cooperating to get the collective reward repeatedly.
- Punishes defection, discouraging free-riding.
- Attempts to restore cooperation after punishment by returning to cooperate once the threshold is met again.
- Avoids persistent defection (except on last round) to not damage collective benefits.

---

## Additional Notes

- The threshold *m* and number of players *n* are common knowledge and constant.
- Can be extended with memory of specific defectors for targeted punishment, but simple aggregate-based approach is sufficient given no communication and large strategy space.
- If players follow similar logic, stable cooperation clusters can form ensuring collective payoffs of approximately *(k + 1 - c_i)* over many rounds, which dominates persistent defection.

---

**This strategy balances optimism (initial cooperation and maintaining cooperation after success) with necessary discipline (punishing threshold failures with defection) ensuring both individual and collective benefits in repeated play of the collective risk dilemma.**
'''

description_COOPERATIVE_54 = '''
Here is a carefully designed cooperative strategy for the Collective Risk Dilemma aimed at promoting cooperation and maximizing collective payoffs over repeated rounds:

---

### Strategy Name: Conditional Threshold Cooperation (CTC)

---

### Intuition and Objectives
- Coordinate to ensure the minimum threshold **m** of cooperators is met each round, unlocking the reward **k**.
- Avoid being exploited by defectors, especially near the end when future punishment is not possible.
- Use early rounds to establish cooperation and identify responders.
- In later rounds, reinforce cooperation if cooperation is sustained, but cautiously defect if defection emerges.
- In the very last round, defect only if cooperation is very unlikely, else cooperate to maintain payoff.

---

### Decision Rules

1. **First Round (t = 1):**  
   - Cooperate (Play C) unconditionally to signal willingness to cooperate.  
   This initiates the possibility of reaching threshold.

2. **Subsequent Rounds (2 ≤ t < r):**  
   - Count the number of cooperators in the previous round: **numC = number of players who played C**.  
   - If **numC ≥ m**, **cooperate** (play C).  
     - Rationale: Cooperation threshold was met last round, so cooperate to continue beneficial coordination.  
   - Else (numC < m):  
     - Defect (play D).  
     - Rationale: If threshold wasn't met, cooperating alone is costly and does not unlock reward; defect to avoid exploitation and wait for others to return cooperation.

3. **Last Round (t = r):**  
   - Inspect last round’s cooperation (numC).  
   - If **numC ≥ m**, cooperate (play C) to achieve reward.  
   - Else if **numC = m - 1** (one short):  
     - Cooperate, trying to nudge cooperation in final round since reward is large and last round offers no future punishment.  
   - Else (numC < m - 1):  
     - Defect (play D) since cooperation unlikely to pay off.

---

### Edge Case Handling

- The strategy assumes public observability of all players' previous actions and payoffs (as per perfect information).
- If the exact number of cooperators from last round is ambiguous (practically should not be), err on the side of defecting.
- If the number of players or threshold is extreme (e.g., m close to n), the strategy naturally adapts by requiring threshold cooperation.
- When observing that no one cooperated last round (numC = 0), defect until cooperation is reinitiated by others, which here our unconditional first-round cooperation aims to stimulate.

---

### Summary of Behavioral Flow

| Round         | Condition                      | Action    | Reason                                         |
|---------------|--------------------------------|-----------|------------------------------------------------|
| t = 1         | First round                    | Cooperate | Signal cooperation, start coordination effort  |
| 1 < t < r     | Last round ≥ m cooperators     | Cooperate | Continue cooperation                            |
| 1 < t < r     | Last round < m cooperators     | Defect    | Avoid sucker's payoff, wait for others         |
| t = r (last)  | Last round ≥ m or (m - 1) coop | Cooperate | Final chance to harvest reward                  |
| t = r (last)  | Last round < (m - 1) cooperators | Defect    | Cooperation unlikely; protect payoff             |

---

### Pseudocode

```python
def CTC_Strategy(t, r, m, last_round_actions):
    """
    t: Current round number (1..r)
    r: Total rounds
    m: Minimum cooperators needed
    last_round_actions: list of actions of all players in previous round, 
                       e.g. ['C', 'D', 'C', ...]
    Returns: 'C' or 'D'
    """
    
    # Round 1: cooperate unconditionally
    if t == 1:
        return 'C'
    
    # Count how many cooperated last round
    numC = sum(1 for a in last_round_actions if a == 'C')
    
    # Last round
    if t == r:
        if numC >= m:
            return 'C'
        elif numC == (m - 1):
            return 'C'
        else:
            return 'D'
    
    # Intermediate rounds
    else:  # 1 < t < r
        if numC >= m:
            return 'C'
        else:
            return 'D'
```

---

### Why This Is Cooperative

- The strategy prioritizes cooperation but is conditional on collective behavior to avoid exploitation.
- It fosters mutually beneficial stable cooperation by cooperating when threshold is met and withdrawing cooperation to signal disapproval when it is not.
- By cooperating on the first round unconditionally, it attempts to establish a baseline trust.
- It rewards cooperation continuity and punishes defection, encouraging others to return to cooperation.
- In the last round, it errs on the side of cooperation if payoff benefits are close to being unlocked to maximize the group’s reward.

---

This strategy leverages repeated interaction and observability to sustain cooperation and maximize collective payoffs within the constraints of the game and lack of communication.
'''

description_COOPERATIVE_55 = '''
Below is a cooperative strategy designed for the Collective Risk Dilemma with parameters (n, r, m, k) as specified, emphasizing coordination, trust-building, and sustaining cooperation over repeated rounds. This strategy aims to reach and maintain at least m cooperators each round so that the community reward k is realized consistently.

---

## Key Intuition

- Cooperation requires at least m players cooperating.
- Defecting players gain slightly more when threshold is reached (see example: if m cooperators and others defect, defectors get 1+k, cooperators get k).
- Repeated game allows for contingent strategies.
- Without communication, cooperation must be inferred and sustained through observed behavior.
- The reward k > 1 incentivizes cooperation since the total group benefits.
- Maintaining cooperation over rounds maximizes total payoffs.

---

## High-Level Strategy Description

### 1. Establish Cooperation Early (Build Trust)

- **Round 1**: Cooperate (C), signaling willingness to cooperate.
  
### 2. Maintain Cooperation if Cooperation Threshold Met

- From **round 2 to round (r-1)**:
  - If at least m players cooperated in the **previous round**, then **cooperate** again.
  - Otherwise, if the threshold was not met previously, **defect** once to test responsiveness.

### 3. Recovery from Defection

- If cooperation threshold was missed in the previous round (i.e., fewer than m cooperators):
  - Defect this round (to punish).
  - If in the next round cooperation by others resumes (≥ m cooperators), resume cooperating.
  - Otherwise, continue defecting to discourage free-riding and reset cooperation attempts.

### 4. Last Round Defection to Maximize Payoff

- In the final round **r**:
  - Defect if and only if the previous round met the cooperation threshold, to maximize payoff without future retaliation risk.
  - Otherwise, cooperate to try to meet the threshold one last time if possible.

---

## Intuition Behind Steps

- **Round 1 cooperation** invites trust and triggers positive feedback.
- **Conditional cooperation** (based on previous round success) ensures players don’t get exploited by persistent defectors.
- **Once threshold broken**, defecting is punishment but allows detection for re-establishing cooperation.
- **Defection in last round** balances self-interest since no future interaction exists to punish.
- This creates incentives for players to maintain cooperation until the end, except the last round where defection is more rational.

---

## Pseudocode

```python
# Inputs each round:
# - round_number (1-based)
# - history_cooperators: list of numbers of cooperators in all previous rounds

def decide_action(round_number, history_cooperators, n, r, m):
    if round_number == 1:
        # Step 1: Start cooperatively
        return 'C'
    
    prev_cooperators = history_cooperators[-1] if history_cooperators else 0
    
    if round_number < r:
        # Step 2 and 3: Maintain or punish cooperation based on previous round threshold
        if prev_cooperators >= m:
            # Cooperation threshold met: cooperate to sustain
            return 'C'
        else:
            # Threshold missed: defect to punish and test
            return 'D'
    
    else:
        # Step 4: Last round strategy
        if prev_cooperators >= m:
            # No future rounds, defect to maximize last payoff if threshold was met previously
            return 'D'
        else:
            # If cooperation threshold missed previously, cooperate to push for last reward if possible
            return 'C'
```

---

## Summary

- The strategy is **conditional cooperative**.
- Start with cooperation, then **cooperate if cooperation threshold met last round**, else defect once as punishment.
- **Punishment is limited to one round**; player tries to restore cooperation in the following rounds if others cooperate.
- **Defect in final round** only if cooperation was consistently maintained, to maximize payoff at end.
- This strategy balances cooperation and self-interest while incentivizing others toward cooperation repeatedly.

---

Let me know if you want alternative strategic elements (e.g., more forgiveness, harsher punishment) or adaptations to specific parameter regimes!
'''

description_COOPERATIVE_56 = '''
Below is a cooperative strategy tailored for the Collective Risk Dilemma game. It uses conditional cooperation to foster and sustain cooperation while guarding against persistent defection. The strategy leverages the repeated structure, perfect information, and observed behavior of opponents.

---

### Cooperative Strategy: **"Gradual Trust Builder"**

---

#### Intuition

- The game rewards collective cooperation once the minimum threshold m is met.
- Defectors free-ride when enough cooperate, obtaining a higher immediate payoff.
- Cooperation benefits all if sustained, but requires a mechanism to discourage exploitation.
- Because players can observe all actions and payoffs, the strategy uses history to build trust.
- In early rounds, begin by cooperating to signal willingness.
- Respond to defection by temporary punishment but attempt to return to cooperation.
- Maintain cooperation strongly if threshold m is consistently met.
- Defect in the last round if trust is broken (since no future to enforce cooperation).

---

#### Parameters

- **n, r, m, k**: game parameters (known)
- **t**: current round index (1 to r)
- **actions[t-1]**: observed actions of all players at previous round (empty if t=1)
- **c_threshold = m**: cooperation threshold to meet
- **forgiveness_delay = 2**: how many rounds after defection to attempt cooperation again

---

### Decision Rules

**Round 1 (t=1):**  
- **Cooperate.**  
Reason: No history yet; start by signaling cooperation.

---

**Rounds 2 to r-1 (1 < t < r):**

1. **Count cooperators in previous round:**

   ```python
   previous_cooperators = count_C(actions[t-1])
   ```

2. **Check if threshold m was met:**

   ```python
   threshold_met = (previous_cooperators >= m)
   ```

3. **Record if any defection occurred among players who cooperated last round**  
   We focus on whether the group cooperated enough and if neighbors defected.

4. **If threshold was met in (t-1):**

   - **If I cooperated in (t-1), continue cooperating.**  
     Reason: Trust that group can sustain cooperation
    
   - **If I defected in (t-1), cooperate now.**  
     Reason: Return to cooperation to rebuild trust.

5. **If threshold was NOT met in (t-1):**

   - **If I cooperated in (t-1), switch to defect (punish defectors).**  
     Reason: Avoid being exploited continuously.

   - **If I defected in (t-1), continue defecting (wait for cooperation signal).**

6. **After punishing for `forgiveness_delay` rounds:**

   - **Attempt cooperation again to test if group cooperation re-emerges.**

---

**Round r (last round):**

- If threshold met in (r-1), **defect** this round.  
  Reason: No future rounds, so no incentive to cooperate; defect to collect private payoff.

- Else, (threshold not met in r-1), **defect** too (since cooperation unlikely.)

---

### Summary (pseudocode)

```python
def decide_action(t, r, m, actions, own_actions):
    forgiveness_delay = 2

    if t == 1:
        return 'C'  # Start cooperative
    
    prev_actions = actions[t-1]
    prev_cooperators = sum(1 for a in prev_actions if a == 'C')
    threshold_met = (prev_cooperators >= m)
    
    # How many rounds in a row threshold not met:
    failed_rounds = 0
    for past_round in range(t-1, max(0, t-1 - forgiveness_delay), -1):
        if sum(1 for a in actions[past_round] if a == 'C') < m:
            failed_rounds += 1
    punished_phase = (failed_rounds >= forgiveness_delay)
    
    own_prev_action = own_actions[t-1]
    
    if t == r:
        # Last round: defect regardless
        return 'D'
    
    if threshold_met:
        # Cooperation threshold met previously
        # Rebuild or continue cooperation
        return 'C'
    else:
        # Threshold NOT met
        # Punish free riders by defecting if you previously cooperated
        if own_prev_action == 'C':
            return 'D'  # Punish
        else:
            if punished_phase:
                # After punishment, try cooperating again to rebuild trust
                return 'C'
            else:
                return 'D'  # Continue defecting if no forgiveness phase met
```

---

### Properties & Advantages

- **Cooperative mindset:** Always initiates cooperation and rewards cooperation from others.
- **Discourages free-riding:** Punishes defection by defecting if threshold not met.
- **Forgiving:** Allows a second chance after a temporary punishment period, striving to restore trust.
- **Exploits repeated interaction:** Uses knowledge of history and game structure.
- **Defects in final round:** Rational backward induction step, as no future to punish defection.

---

### Additional Notes

- If most players adopt similar strategies, cooperation should stabilize around threshold m.
- Strategy is robust to occasional mistakes or noise, due to forgiveness delay.
- It adapts dynamically to whether groups can form cooperation clusters.
- No explicit communication or complex signaling is needed beyond observed moves.

---

This "Gradual Trust Builder" strategy aligns with cooperation principles—initiating collaboration, punishing defectors, forgiving to rebuild cooperation, and adjusting behavior round-by-round based on observed history.
'''

description_COOPERATIVE_57 = '''
Here is a cooperative strategy for the Collective Risk Dilemma that aims to build trust, sustain cooperation, and maximize group reward over the repeated rounds.

---

### Strategy Overview: *Conditional Reciprocity with Forgiveness*

- Intuition:  
  Begin cooperatively, signal readiness to cooperate, and continue cooperating as long as a sufficient number of others cooperate. If cooperation fails, try to quickly restore it rather than permanently defecting.

---

### Decision Rules

---

#### Round 1 (First Move)

- **Cooperate (C)**
  
  *Rationale:* Start by cooperating to demonstrate willingness and encourage mutual cooperation.

---

#### Rounds 2 to r - 1 (Intermediate Rounds)

- Count the number of cooperators last round, **coop_count**.
- If `coop_count ≥ m`, then **Cooperate (C)** this round.
  
  *Rationale:* Cooperation threshold met; continue cooperating to maintain group reward.
  
- Else if `coop_count < m`:
  - If you cooperated last round, but cooperation failed, **Defect (D)** as a warning to punish free-riding.
  - If you defected last round, **Cooperate (C)** this round to try to restore cooperation.
  
  *Rationale:* Use a "forgiving" trigger strategy — punish once, then give a second chance to restore cooperation.

---

#### Round r (Last Round)

- If cooperation was sustained (≥ m cooperators previous round), **Cooperate (C)**.
  
- Else, **Defect (D)**.
  
  *Rationale:* No future punishment possible; defect if cooperation not reliably established.

---

### Summary of Cooperation Decision in Round t > 1:

| Condition                                    | Action    | Rationale                         |
|----------------------------------------------|-----------|-----------------------------------|
| previous coop_count ≥ m                       | Cooperate | Cooperation successful, continue  |
| previous coop_count < m AND played C last    | Defect    | Punish failure of cooperation     |
| previous coop_count < m AND played D last    | Cooperate | Try to restore cooperation        |

---

### Additional Details and Justification

- **Cooperate Early to Signal Trust:** Starting with C lets others know you intend to cooperate.
- **Maintain Cooperation When Threshold Met:** If enough players cooperated, the reward is guaranteed; sustain this to maximize payoffs for all.
- **Use Forgiving Trigger Strategy:**  
  - Upon failure, defect once to signal your discontent and try to punish free-riders.  
  - Immediately after, try cooperating again to allow recovery of cooperation rather than falling into permanent defection.
- **Defect Only in Last Round if Cooperation Unlikely:** No incentive to cooperate at the end if cooperation was betrayed or broken, since no future rounds remain.

---

### Pseudocode

```python
# Inputs per round t:
# coop_count: number of cooperators last round (0 if t=1)
# my_last_action: my own action last round (None if t=1)
# parameters: n, m, r, k

def decide_action(t, coop_count, my_last_action, m, r):
    if t == 1:
        # First round: cooperate to build trust
        return 'C'
    
    if t == r:
        # Last round
        if coop_count >= m:
            return 'C'  # sustain cooperation one more time
        else:
            return 'D'  # defect; no future to punish
    
    # Intermediate rounds
    if coop_count >= m:
        # Cooperation threshold met last round: cooperate
        return 'C'
    else:
        # Cooperation failed last round
        if my_last_action == 'C':
            # I cooperated last round but threshold missed: punish by defecting
            return 'D'
        else:
            # I defected last round, now try cooperating to restore cooperation
            return 'C'
```

---

### Cooperative Mindset Alignment

- This strategy prioritizes contributing to that collective goal (cooperating) whenever others do.
- It punishes uncooperative behavior only briefly, with an explicit attempt to re-establish trust rather than giving up.
- It recognizes the value of the group reward (k) over individual short-term gain (private payoff = 1).
- The pattern fosters a mutually beneficial equilibrium and leverages the repeated nature to enforce cooperation.

---

If most players adopt a similar conditional cooperation with forgiveness, the threshold m gets reliably achieved over the rounds, maximizing everyone's total long-term payoff.
'''

description_COOPERATIVE_58 = '''
Here is a cooperative strategy designed for the Collective Risk Dilemma with parameters (n, r, m, k) and given the repeated simultaneous-move nature of the game. This strategy aims to reliably reach the cooperation threshold while minimizing free-riding, thereby maximizing collective payoffs.

---

### Core Idea: Conditional Cooperation with Threshold Vigilance

- **Goal:** Ensure that at least **m** players cooperate each round to secure the reward **k** while discouraging free-riding by punishing defectors after detecting insufficient cooperation.
- **Approach:**  
  - Start cooperatively to build trust.  
  - Maintain cooperation if the group shows signs of coordinating on cooperation (≥ m cooperators).  
  - Defect to punish if coordination fails (too few cooperators).  
  - Return to cooperation if the group stabilizes again.  
  - In the last round, defect to maximize individual payoff (standard backward induction reasoning).

---

### Detailed Decision Rules

Let:  
- `t` = current round number (1 ≤ t ≤ r)  
- `C_t` = number of players who cooperated in round `t`  
- `m` = minimum number of cooperators needed for reward  
- History records all previous cooperative counts and individual actions

---

#### Round 1 (Initialization)

- **Action:** Cooperate (C)  
- **Rationale:** Start with full trust and lead by example. This sets a cooperative norm.

#### Rounds 2 to r-1 (Intermediate rounds)

Evaluate previous rounds to decide action at round `t`:

1. **If the previous round (`t-1`) had ≥ m cooperators:**

   - Cooperate (C)  
   - **Reason:** Cooperation threshold met, so continue cooperating to maintain the reward.

2. **If the previous round had < m cooperators:**

   - Defect (D)  
   - **Reason:** Reward missed. Punish by defecting to avoid being exploited.

3. **Exception: Recovery after punishment**

   - If we defected at round `t-1` due to insufficient cooperation, but the round before that (`t-2`) had ≥ m cooperators, attempt to cooperate at `t` to "test" restoring cooperation.

   - **Rationale:** Avoid perpetual punishment cycles; allow returning to cooperation if others do too.

---

#### Round r (Last round)

- **Action:** Defect (D)

- **Reason:** No future rounds to sustain cooperation; defect to maximize own payoff.

---

### Handling Edge Cases and Tie-breaks

- **Exact m cooperators scenario:** Any time cooperation count is exactly m or more, treat as successful cooperation.

- **Fluctuating cooperation counts:** If cooperation fluctuates around `m` (e.g., sometimes meet threshold, sometimes not), follow the above rules strictly; punish on failures and cooperate on successful attempts to promote coordination.

- **In case of isolated defection detected (only 1 or 2 defectors in otherwise cooperative group):** Do not change action unilaterally; follow action based on threshold rather than individuals to avoid destabilization.

---

### Summary pseudocode

```python
def choose_action(t, history_cooperation_counts, history_my_actions):
    # Parameters: n, r, m, k known globally
    
    if t == 1:
        return 'C'  # Start cooperatively
        
    if t == r:
        return 'D'  # Last round: defect to maximize payoff
    
    previous_cooperators = history_cooperation_counts[t-2]  # zero-indexed
    
    # Check if previous round was cooperative
    if previous_cooperators >= m:
        return 'C'  # Continue cooperation
    
    else:
        # Previous round failed threshold
        # If last action was defection due to failure, try cooperating to restore trust
        if (t > 2):
            two_rounds_ago_cooperators = history_cooperation_counts[t-3]
            my_last_action = history_my_actions[t-2]
            
            if two_rounds_ago_cooperators >= m and my_last_action == 'D':
                return 'C'  # Attempt to re-establish cooperation
        
        return 'D'  # Punish by defecting due to insufficient cooperation
```

---

### Strategic Rationale and Cooperation Alignment

- The strategy **starts and tries to maintain cooperation** to ensure the reward for all.
- It enforces a simple, transparent punishment (defect) after failures to meet cooperation thresholds, discouraging free riders.
- The "recovery rule" prevents locked cycles of mutual defection by allowing a tested return to cooperation.
- Defecting on the last round aligns with rational backward reasoning but is expected, so cooperation in previous rounds effectively maximizes payoffs.
- The pure dependence on observable counts (not identities or hidden information) respects game assumptions and encourages mutual monitoring.

---

### Expected Outcome

- Against similarly cooperative strategies, expect stable cooperation every round except round r, maximizing group welfare.
- Against non-cooperative or random strategies, punishment will reduce exploitation.
- This approach balances risk and reward to foster cooperation in a repeated, simultaneous-move setting without communication.

---

If you want, I can also provide a more nuanced variant that adapts thresholds or uses probabilistic cooperation, but the above is a strong, clear, and cooperative baseline strategy.
'''

description_COOPERATIVE_59 = '''
Below is a detailed cooperative strategy for the Collective Risk Dilemma. The goal is to foster sustained cooperation, reaching or exceeding the threshold m cooperators each round, thus maximizing joint payoffs over the repeated game.

---

### Intuition and Objectives

- **Maximize group reward**: Ensure ≥ m players cooperate each round, triggering the reward k for everyone.
- **Encourage cooperation**: Start cooperatively and tolerate minor defections, to maintain cooperation even if some players test boundaries or accidentally defect.
- **Punish persistent defectors**: If other players repeatedly defect, attempt to discipline defectors by defecting temporarily, but return to cooperation if the group starts cooperating again.
- **Avoid end-game collapse**: Plan for the last round to ensure correct incentives; cooperation may unravel in the final round due to lack of future repercussions.
- **Be transparent and consistent**: Use a simple, easily recognizable pattern to signal cooperativeness and identify defectors.

---

### Strategy Description

**Parameters / Inputs:**  
- n, r, m, k as defined  
- t = current round (1 to r)  
- Last round = r  
- Observations from previous rounds: actions of all players (including self) at t-1

---

### Decision Rules

#### Round 1 (Initial round)  
- **Play C**: Start by cooperating unconditionally to signal willingness to cooperate and try to reach the threshold.

#### Rounds 2 to r-1 (Intermediate rounds)  
- **Check last round cooperation count:**  
  Let `coop_count` = number of players (excluding self) who cooperated at t-1.

- **If `coop_count + self_coop` ≥ m last round:**  
  Other players mostly cooperated last round; **cooperate** this round.  
  Rationale: Reward continuation of cooperation.

- **Else if `coop_count + self_coop` < m:**  
  Not enough cooperators last round;  
  - If **I cooperated last round but threshold failed**, suspect free-riders or lack of coordination;  
    - Cooperate again to try to rebuild cooperation (give benefit of doubt once).  
  - Else if **I defected last round and threshold failed**, continue defecting until cooperation recovers to avoid unilateral losses.

- **Additional tolerance:**  
  Maintain a count of consecutive rounds threshold was not met. If threshold fails 2 or more rounds in a row, start defecting to punish persistent defection until threshold met again.

#### Round r (Last round)  
- Classical game theory predicts unraveling cooperation in final round since there's no future punishment.

- **Play D** (Defect) in final round to maximize immediate payoff, because no incentive to cooperate.

- However, if you want to be fully cooperative (to maximize total group payoffs over all rounds), you can cooperate in final round *only if* threshold was met in round r-1 and cooperation has been stable.

- **Compromise:**  
  Cooperate in last round **if** threshold was met in round r-1 and no defectors detected; otherwise defect.

---

### Summary

| Round      | Condition                                                | Action       |
|------------|----------------------------------------------------------|--------------|
| 1          | Always                                                  | Cooperate    |
| 2 to r-1   | Threshold met in last round                              | Cooperate    |
| 2 to r-1   | Threshold failed but you cooperated last round          | Cooperate    |
| 2 to r-1   | Threshold failed, you defected last round or persistent failure (>2 rounds) | Defect       |
| r (last)   | Threshold met last round and no defections detected     | Cooperate    |
| r (last)   | Otherwise                                               | Defect       |

---

### Pseudocode

```python
def decide_action(t, r, m, history):
    """
    t: current round index (1-based)
    r: total rounds
    m: threshold minimum cooperators
    history: list of dicts with keys 'actions' mapping player_id -> action in previous rounds
    
    Returns: 'C' or 'D'
    """
    
    # Always cooperate in first round
    if t == 1:
        return 'C'
        
    last_round = history[-1]
    player_id = my_player_id()
    
    # Count cooperators last round
    coop_count = sum(1 for a in last_round['actions'].values() if a == 'C')
    self_action_last = last_round['actions'][player_id]
    
    # Check consecutive failures
    failures = 0
    for past_round in reversed(history):
        coop_count_past = sum(1 for a in past_round['actions'].values() if a == 'C')
        if coop_count_past < m:
            failures += 1
        else:
            break

    # Last round special rule
    if t == r:
        threshold_met = coop_count >= m
        no_defectors = (cooperation_sufficient(history, m))
        if threshold_met and no_defectors:
            return 'C'
        else:
            return 'D'
    
    # Intermediate rounds
    if coop_count >= m:
        return 'C'  # Group cooperating, join in
    
    else:
        if failures >= 2:
            # Persistent failure - punish
            return 'D'
        else:
            if self_action_last == 'C':
                # Attempt to repair cooperation
                return 'C'
            else:
                # Avoid cooperating when group fails and self defected last round
                return 'D'


def cooperation_sufficient(history, m):
    """
    Helper: checks if threshold met consistently and defection rare.
    Could define a threshold on last k rounds.
    """
    # Simple check: threshold met last 2 rounds
    if len(history) < 2:
        return True
    for round_info in history[-2:]:
        coop_count = sum(1 for a in round_info['actions'].values() if a == 'C')
        if coop_count < m:
            return False
    return True
```

---

### Notes on the Strategy

- This strategy **starts cooperatively** to set the tone.
- It grants a **forgiveness window** for one failed round to handle errors or accidental defections.
- If cooperation **fails persistently**, it switches to defection to apply pressure.
- It **returns to cooperation** as soon as others cooperate again.
- It **defects in the final round** unless cooperation has been stable, reflecting the known end-game rationality.
- This is a **conditional cooperation strategy** that is simple, reactive, and robust in the absence of communication.

---

### Alignment with the Cooperative Mindset

- Proactively seeks to achieve the threshold each round.
- Forgives isolated defections to maintain group gains.
- Disciplines persistent defectors, aiming to restore cooperation.
- Balances collective reward with personal rationality, especially at the end.
- Uses transparent and consistent rules to enable predictable mutual cooperation.

---

This strategy should perform well in a tournament of independent LLM strategies with the same knowledge, by promoting mutual cooperation early and attempting to sustain it throughout the repeated interaction.
'''

description_COOPERATIVE_60 = '''
Below is a carefully crafted cooperative strategy for the Collective Risk Dilemma game. It leverages the repeated nature, perfect information, and common knowledge while observing prior actions to sustain cooperation and optimize the group payoff.

---

## Strategy Name: Conditional Reciprocity with Early Signaling and Endgame Cooperation

### Core Idea
- **Signal cooperation early and consistently to establish trust.**
- **Maintain cooperation as long as enough players cooperate to exceed the threshold m.**
- **If cooperation breaks down, try to restore cooperation by returning to cooperation on the next round.**
- **In the final round (endgame), cooperate unconditionally to maximize group payoff since no future punishment or reward is possible.**

---

## Detailed Decision Rules

### Notation
- Let **t** denote the current round (1 ≤ t ≤ r).
- Let **C_t** denote the set of players who cooperated in round t.
- Let **last_round = r** denote the final round.
- Let **me** denote this player.
- Let **threshold = m**.
- Let **total_players = n**.

---

### Round 1 (Initialization / Signaling)
- **Action:** Cooperate (C)
- **Rationale:** Establish cooperative intent immediately to encourage reciprocal cooperation.

---

### Intermediate Rounds (2 ≤ t < r)

1. **Count coopers in previous round:**  
   Let `prev_cooperators = |C_{t-1}|`.

2. **If threshold met in previous round (prev_cooperators ≥ m):**  
   - Cooperate this round (C).  
   - Rationale: Cooperation was successful; continue to sustain.

3. **If threshold not met in previous round (prev_cooperators < m):**  
   - Defect this round (D) **if** you cooperated in previous round (a form of proportional retaliation).  
   - Cooperate this round (C) **if** you defected in previous round, to signal willingness to restore cooperation.  
   - Rationale: Punish free riders but offer a path back to cooperation.

---

### Final Round (t = r)

- **Action:** Cooperate (C) unconditionally.  
- **Rationale:** No future rounds to punish defection, so cooperate to maximize one-shot group payoff.

---

## Pseudocode

```pseudo
function decide_action(t, history):
    # history: list of action profiles from round 1 to t-1
    if t == 1:
        return C
    
    prev_round_actions = history[t-2]  # actions at round t-1
    prev_cooperators = count_cooperators(prev_round_actions)
    
    my_last_action = prev_round_actions[me]
    
    if t == r:
        # Last round - cooperate unconditionally
        return C
    
    if prev_cooperators >= m:
        # Cooperation threshold met last round, continue cooperating
        return C
    else:
        # Threshold not met last round
        if my_last_action == C:
            return D  # Retaliate for unsuccessful cooperation
        else:
            return C  # Attempt to restore cooperation
```

---

## Rationale and Benefits
- **Early cooperation** signals trustworthiness and facilitates rapid coordination.
- **Conditional cooperation** maintains cooperation if enough players cooperate.
- **Proportional retaliation** discourages continuous defection but does not permanently punish, as it immediately offers a "forgiveness" move.
- **Unconditional final-round cooperation** aligns with maximizing collective gain without incentive for defection.
- This strategy aligns with a cooperative mindset, balancing incentives to foster and sustain collective benefit over multiple rounds.

---

## Handling Edge Cases

- **If no players cooperate round 1 (extreme defection):**  
  The strategy defects round 2 if it cooperated round 1. Other players may also defect, but the forgiveness step offers a chance to restart cooperation later rounds.

- **If players fluctuate around the threshold m:**  
  The strategy tracks cooperation and adjusts action each round based on whether the threshold was met, enabling adaptive responses.

- **If k is very large:**  
  The incentive to cooperate is strong; this strategy thus capitalizes on that by encouragement and punishment cycles.

---

## Summary

| Round | Condition                             | Action           |
|-------|-------------------------------------|------------------|
| 1     | First round                         | Cooperate (C)    |
| 2..r-1| Prev round cooperators ≥ m          | Cooperate (C)    |
| 2..r-1| Prev round cooperators < m and last action = C | Defect (D) |
| 2..r-1| Prev round cooperators < m and last action = D | Cooperate (C) |
| r     | Final round (no matter what)        | Cooperate (C)    |

---

This strategy encourages stable cooperation, punishes defection without permanent exclusion, supports recovery, and maximizes group payoffs, thus fulfilling the cooperative mindset goal with strategic rigor.
'''

description_COOPERATIVE_61 = '''
Below is a cooperative strategy tailored for the Collective Risk Dilemma as described. It is designed to foster and sustain cooperation across all rounds, leveraging perfect information about past actions, while taking into account the incentives to defect, especially near the end of the game.

---

## Strategy Name: **Gradual Trust Builder**

### Key Idea
- Start by cooperating to signal willingness to cooperate.
- Condition future cooperation on observing enough cooperators in the previous round.
- Allow forgiveness if cooperation was nearly met last round or slight defections happened, to avoid escalation.
- Increase cooperation commitment as rounds progress to secure collective reward.
- Defect only when cooperation consistently fails or in the very last round if cooperation cannot be secured.

---

## Detailed Description

### Variables Known to Each Player i:
- **n, r, m, k** — Game parameters.
- **History of actions:** `actions[t][j]` for round t and player j ∈ [1..n].
- **Own actions history:** `self_actions[t]`.
- **Current round:** t ∈ [1..r].

### Internal Computations Per Round t:
- Calculate the number of cooperators in round t-1 (except for t=1).
- Define thresholds for cooperation based on round number (to concentrate cooperation early and maintain momentum).
- Maintain a confidence measure on group cooperation, updated each round.

---

## Decision Rules

### Round 1 (t = 1):
- **Action:** Cooperate (C).
- **Rationale:** Signal cooperative intent from the start.

### Round 2 ≤ t < r (middle rounds):
- **Observe:** Number of cooperators in previous round, `prev_coops`.
- **If `prev_coops >= m`:**  
  - Cooperate (C).
  - Reinforce cooperation since threshold was met in last round.
- **Else if `prev_coops == m - 1` (just below threshold):**  
  - Forgive and cooperate (C).
  - Signal willingness to help reach threshold.
- **Else:**  
  - Defect (D) only if **last two rounds** failed to meet threshold (to avoid unnecessary punishment).
  - Otherwise cooperate (C) to attempt reviving cooperation.

### Round r (final round):
- **Observe:** Number of cooperators in round r-1.
- **If threshold was met in r-1 (to expect cooperation):**  
  - Cooperate (C) if you expect others to do so.
- **Else:**  
  - Defect (D) — Risk of exploitation high as no future punishment possible.

---

## Edge Case Handling

- **If others defect unexpectedly in early rounds:**  
  Maintain cooperation for two consecutive rounds before defecting, giving others a chance to repair cooperation.
  
- **If cooperation consistently fails (threshold not met for 3+ rounds):**  
  Switch to defection to maximize individual payoff.

- **If `m` and `k` parameters imply very high reward (k >> 1):**  
  Prioritize cooperation longer because reward outweighs defection gain.

---

## Pseudocode

```python
def decide_action(round t, history actions, parameters n, r, m, k):
    if t == 1:
        return 'C'  # Start cooperatively
    
    prev_coops = count_cooperators(actions[t-1])
    coops_last_two_rounds = (
        count_cooperators(actions[t-1]) +
        count_cooperators(actions[t-2]) if t > 2 else 0
    )
    
    # Final round logic
    if t == r:
        if prev_coops >= m:
            return 'C'  # Expect continued cooperation
        else:
            return 'D'  # No incentive to cooperate last round
    
    # Middle rounds logic
    if prev_coops >= m:
        return 'C'  # Cooperation maintained
    elif prev_coops == m - 1:
        return 'C'  # Forgive near success
    else:
        # Check if cooperation failed for last two rounds
        fail_count = 0
        if count_cooperators(actions[t-1]) < m:
            fail_count += 1
        if t > 2 and count_cooperators(actions[t-2]) < m:
            fail_count += 1
        
        if fail_count >= 2:
            return 'D'  # Defect if cooperation failing persistently
        else:
            return 'C'  # Attempt to restore cooperation

def count_cooperators(round_actions):
    return sum(1 for a in round_actions if a == 'C')
```

---

## Strategy Properties

- **Cooperative:** Always tries to cooperate unless cooperation breaks down repeatedly.
- **Reciprocative:** Responds to group’s cooperation level, reinforcing cooperation if threshold met.
- **Forgiving:** Allows occasional lapses without immediate retaliation.
- **Rational:** Defects in last round or after persistent cooperation failure to avoid exploitation.
- **Adaptive:** Adjusts to observed group behavior, promoting collective reward maximization.

---

This strategy balances the incentive to cooperate for all rounds, while mitigating risks of exploitation, to maximize total payoffs in the repeated collective risk dilemma.
'''

description_COOPERATIVE_62 = '''
**Cooperative Strategy: "Threshold Reciprocity"**

---

### Core Idea

Build cooperation by default, seeking to meet or exceed the minimum threshold **m** cooperators each round to secure the reward **k**. If others defect and cooperation fails, punish defectors by defecting in the next round to discourage free-riding. Resume cooperation as soon as the group recovers to cooperation threshold or better. In the last round, cooperate only if cooperation was stable in previous rounds—otherwise defect to avoid exploitation.

---

### Strategy Outline and Rationale

| Round        | Action Rule                                                                                       | Reasoning                                                                                                              |
|--------------|-------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------|
| 1 (first)    | **Cooperate**                                                                                   | Establish cooperative norm unilaterally; encourage others to cooperate from start.                                      |
| Intermediate | **Cooperate** if in previous round: number of cooperators ≥ m                                  | Reward cooperation if group reached threshold, maintain cooperation.                                                   |
|              | **Defect** if in previous round fewer than m cooperators                                       | Punish defectors by defecting to reduce their payoff, discouraging free-riding.                                         |
|              | **Detect recovery:** If previous round defected but current round previous behavior shows threshold met, cooperate again. | Forgive and return to cooperation quickly when group recovers.                                                          |
| Last round   | **Cooperate** if cooperative threshold was met in majority of previous rounds                   | Secure final round reward if cooperation has been stable.                                                                |
|              | **Defect** otherwise                                                                            | Avoid being exploited by defectors in the last round; no future rounds to influence their behavior.                       |

---

### Step-by-step Decision Procedure per Round *t*:

1. **Round 1 (t=1):**

   - Play **C** (cooperate).

2. **Round t > 1 and t < r (not last round):**

   - Observe previous round's number of cooperators, `num_C_prev`.

   - If `num_C_prev ≥ m`:  
     - Play **C** (cooperate) to maintain cooperation.

   - Else:  
     - Play **D** (defect) to punish.

3. **Round r (last round):**

   - Count number of previous rounds where cooperation threshold was met: `cooperative_rounds`.

   - If `cooperative_rounds` ≥ `(r / 2)` (majority rounds cooperative):  
     - Play **C** to secure reward.

   - Else:  
     - Play **D**.

---

### Handling Edge Cases

- **If opponents never cooperate:**  
  Strategy quickly switches to defection, minimizing losses and not wasting endowment.

- **If opponents cooperate intermittently:**  
  Strategy reciprocates cooperation only if threshold met last round, punishes otherwise.

- **If exactly m cooperators are achieved:**  
  That is sufficient—cooperate to secure reward.

- **If number of cooperators fluctuates:**  
  Strategy adapts by punishing or forgiving to encourage stable cooperation.

- **If uncertain about others' intentions:**  
  Start cooperatively and respond based on last round’s group behavior (perfect information).

---

### Pseudocode

```python
function decide_action(t, r, m, history):
    # history: list of tuples for each previous round (list of actions from all players)

    if t == 1:
        return 'C'  # Start cooperating to build trust

    previous_actions = history[t-2]  # actions in round t-1
    num_C_prev = count_cooperators(previous_actions)

    if t < r:  # intermediate rounds
        if num_C_prev >= m:
            return 'C'  # maintain cooperation
        else:
            return 'D'  # punish defection/failure

    else:  # last round t == r
        cooperative_rounds = sum(
            1 for round_actions in history 
            if count_cooperators(round_actions) >= m
        )
        if cooperative_rounds >= r / 2:
            return 'C'  # cooperate if majority previous rounds cooperative
        else:
            return 'D'  # defect to avoid exploitation in last round

def count_cooperators(actions):
    return sum(1 for a in actions if a == 'C')
```

---

### Strategic Benefits

- **Cooperative mindset:** Always tries to cooperate initially and maintain cooperation when it benefits all.

- **Punishment and forgiveness:** Discourages sustained defection but allows recovery to cooperation quickly.

- **Efficient reward securing:** Ensures collective risk threshold met repeatedly to maximize payoffs.

- **Predictability:** Other rational players can infer and anticipate this behavior, encouraging mutual cooperation.

---

This strategy balances trust, reciprocity, and rational self-interest, essential for overcoming the collective risk dilemma in repeated rounds under perfect information.
'''

description_COOPERATIVE_63 = '''
Below is a cooperative strategy designed for the Collective Risk Dilemma described.

---

### Strategy Name: Conditional Reciprocity with Optimistic Start

---

## Intuition

- Cooperation requires reaching the threshold *m* cooperators to get the reward *k*.
- The best outcome is when enough cooperators join each round, maximizing group payoff.
- The strategy starts optimistically by cooperating in the first round to signal willingness to cooperate.
- It then uses observed cooperation levels in past rounds to decide whether to keep cooperating or defect.
- To avoid exploitation near the end, it gradually reduces cooperation in last rounds (endgame effect).
- It is resilient to occasional defections by forgiving sporadic defections but punishes persistent defection.

---

## Parameters and Variables Used Internally

- **n, r, m, k** — given game parameters.
- **round** — current round number (1...r).
- **history_C_t** — number of players who cooperated in round t (observed in previous rounds).
- **my_actions** — record of own past actions.
- **min_rounds_for_coop** — threshold rounds before ending cooperation (related to endgame).
- **forgiveness_threshold** — how many rounds of defection tolerated before retaliating.
- **current_cooperation_state** ∈ {Cooperating, Punishing}

---

## Decision Rules

### Round 1

- Cooperate unconditionally to signal willingness to cooperate.
- Set `current_cooperation_state = Cooperating`.
- Set internal counters: defections_seen = 0.

### Rounds 2 to r - min_rounds_for_coop

- Observe how many cooperated last round, `history_C_{round-1}`.
- If `current_cooperation_state == Cooperating`:
  - If `history_C_{round-1} ≥ m`
    - (Successful cooperation last round)
    - Cooperate this round.
    - Reset defections_seen = 0.
  - Else
    - (Insufficient cooperation last round)
    - Increment defections_seen.
    - If defections_seen > forgiveness_threshold:
      - Switch to `current_cooperation_state = Punishing`.
      - Defect this round.
    - Else
      - Cooperate this round (give benefit of doubt).
- Else if `current_cooperation_state == Punishing`:
  - Continue defecting.
  - Monitor if other players resumed cooperation:
    - If cooperation count ≥ m consistently for forgiveness_threshold rounds,
      - Return to `Cooperating` state.

### Near Endgame (last min_rounds_for_coop rounds, including round r)

- Gradually reduce cooperation to avoid exploitation because no future rounds remain to punish defectors.
- Example: In round `r - min_rounds_for_coop + 1`, cooperate only if cooperation ≥ m last round.
- In round `r`, defect to maximize final payoff (greedy in last round).

---

## Edge Case Handling

- **First round:** Always cooperate – set a tone.
- **Last round:** Defect to maximize final round payoff (no future rounds to incentivize cooperation).
- **If cooperation threshold is *just met*:** Continue cooperating optimistically.
- **If few have cooperated repeatedly:** Punish by defecting until sufficient cooperation is restored.
- **Occasional defections:** Forgive up to `forgiveness_threshold` rounds before retaliating.
- **No communication:** Use only public observables (number of cooperators).

---

## Pseudocode

```python
initialize:
    current_cooperation_state = "Cooperating"
    defections_seen = 0
    min_rounds_for_coop = max(1, int(r * 0.2))  # last 20% of rounds are cautious
    forgiveness_threshold = 2

for round in 1 to r:
    if round == 1:
        action = "C"
    elif round > r - min_rounds_for_coop:
        # Endgame: gradually defect
        if round == r:
            action = "D"
        else:
            if history_C[round-1] >= m:
                action = "C"
            else:
                action = "D"
    else:
        if current_cooperation_state == "Cooperating":
            if history_C[round-1] >= m:
                action = "C"
                defections_seen = 0
            else:
                defections_seen += 1
                if defections_seen > forgiveness_threshold:
                    current_cooperation_state = "Punishing"
                    action = "D"
                else:
                    action = "C"
        else:  # Punishing state
            action = "D"
            # Check if cooperation restored
            recent_coop_rounds = [history_C[t] for t in range(round-forgiveness_threshold, round) if t >= 1]
            if len(recent_coop_rounds) == forgiveness_threshold and all(c >= m for c in recent_coop_rounds):
                current_cooperation_state = "Cooperating"
                defections_seen = 0

    record my_actions[round] = action
    play action
```

---

## Summary

- Start by cooperating.
- Continue cooperating if threshold met last round.
- Forgive occasional defections but punish persistent defection by defecting.
- Return to cooperation if others resume sufficient cooperation.
- Defect in the last round to maximize final payoff.
- Adjust endgame cooperation gradually to avoid exploitation.

This strategy balances cooperative optimism with enforceable reciprocity, aiming to sustain cooperation most rounds and secure the collective reward *k*, while protecting itself from persistent free-riders.
'''

description_COOPERATIVE_64 = '''
Below is a cooperative strategy designed for the Collective Risk Dilemma game as specified. It assumes rational opponents who also seek to maximize expected payoffs and are capable of conditional cooperation. The goal is to maintain cooperation of at least m players per round, thereby securing the collective reward \(k\), while handling possible defections gracefully.

---

## Strategy Summary

**Main idea:**  
- **Start cooperatively** to signal willingness to cooperate.  
- **Monitor others' actions each round** and track cooperation levels.  
- **Conditionally cooperate** in most rounds to reach the threshold \(m\).  
- **Punish defections only briefly** to avoid collapse of cooperation.  
- **Always cooperate near the end** to maximize total payoff, given repeated final-round defection incentives.  

---

## Detailed Strategy Description

### Variables (tracked during the game)

- \(n, r, m, k\): game parameters (known upfront)  
- round \(t\): current round index, \(1 \le t \le r\)  
- history: action profile of all players from previous rounds, i.e., \(A^1, A^2, \ldots, A^{t-1}\)  
- \(C_{t-1}\): number of cooperators in round \(t-1\)  
- defections_against_me: count of rounds where I cooperated but total cooperation fell below \(m\) (indicating some likely defection)

---

### Decision Rules per Round \(t\)

1. **Round 1 (Initialization)**  
   - Cooperate (C) unconditionally.  
   - This signals willingness to cooperate and attempts to establish baseline cooperation.

2. **Rounds \(2 \le t < r\) (Middle Rounds)**  
   - If in round \(t-1\), at least \(m\) cooperated (threshold met), **cooperate**, trusting others will do the same.  
   - Else if threshold failed at \(t-1\) **and** I cooperated, interpret this as defection(s) by others:  
     - Punish defectors by defecting once (i.e., defect in current round to signal dissatisfaction).  
     - After punishing, return to cooperation assuming others respond similarly to restore cooperation.  
   - If threshold failed but I defected last round, cooperate now to try re-establish cooperation.

3. **Last Round \(t = r\)**  
   - Always cooperate.  
   - Reasoning: no future rounds to punish or reward, cooperation maximizes collective payoff and is aligned with cooperative mindset.

---

### Additional Notes

- **How to handle partial defections?**  
  The strategy uses *threshold-based* logic — if fewer than \(m\) cooperated last round, assume some players defected. The punishment is only single-round defection to avoid long defection spirals.  

- **No explicit identification of defectors:**  
  Since moves are simultaneous, cannot always identify exactly who defected. The strategy punishes by defecting itself, which reduces the temptation for others to defect repeatedly.

- **Maintain a forgiving attitude:**  
  Punishment is transient — single round — promoting eventual restoration of cooperation.

---

## Pseudocode

```python
# Input: round t, history of actions from previous rounds
# Output: Action in this round, 'C' or 'D'

def decide_action(t, history, n, r, m):
    if t == 1:
        # First round: cooperate unconditionally
        return 'C'

    # Historical cooperation count in previous round
    last_round_actions = history[t-2]  # 0-based index, previous round's actions list
    cooperators_last_round = sum(1 for a in last_round_actions if a == 'C')

    # My own action last round
    my_action_last_round = history[t-2][my_index]

    # Middle rounds
    if 1 < t < r:
        if cooperators_last_round >= m:
            # Threshold met last round, cooperate to maintain cooperation
            return 'C'
        else:
            # Threshold failed last round
            if my_action_last_round == 'C':
                # I cooperated but threshold not met => punish by defecting once
                return 'D'
            else:
                # I defected last round, now try cooperating to restore cooperation
                return 'C'

    # Last round
    if t == r:
        # Always cooperate last round
        return 'C'
```

---

## Why this strategy is cooperative

- It **starts cooperative** to establish trust.  
- It **conditions cooperation on observed collective behavior**, rewarding cooperation and punishing defection only briefly.  
- It **aims to maintain threshold-level cooperation**, to secure the reward \(k\) every round instead of losing it due to defections.  
- The **lenient punishment** avoids long defection cycles, encouraging quick restoration of cooperation.  
- It **cooperates on the last round** regardless, maximizing payoffs and embracing the cooperative mindset fully.

---

This strategy balances rational foresight, conditional cooperation, and forgiveness, promoting awareness of collective success and discouraging persistent defection within the repeated, simultaneous-move setting.
'''

description_AGGRESSIVE_3 = '''
Below is an aggressive strategy designed for the Collective Risk Dilemma game described. It aggressively exploits cooperative players while defending against exploitation, with explicit decision rules and edge case handling.

---

## Aggressive Strategy: Exploitative Opportunist

### Intuition and High-Level Description

- **Main goal:** Maximize individual payoff by free-riding on cooperators whenever possible.  
- **Aggressive stance:** Defect aggressively to reap the benefits of others' cooperation but punish failure to meet cooperation thresholds by cooperating at times to avoid collective collapse and loss of rewards.  
- **Repeated rounds use:** Exploit history to detect trends, keep defecting as long as the group cooperates enough for reward, otherwise temporarily cooperate to nudge threshold achievement.  
- **No communication:** Use only observable actions and payoffs from prior rounds.

---

### Decision Rules Per Round t

**Notation:**  
- Let `C_t` = number of cooperators observed in round t (including self if cooperated)  
- Let `r` = total rounds  
- Let `m` = cooperative threshold  
- Let `k` = reward multiplier > 1

---

### Round 1 (First round)

- **Defect (D) immediately** to test opponent tendencies and preserve endowment.

Reasoning:  
Start aggressively to capitalize if others cooperate in round 1.

---

### Rounds 2 to (r - 1) (Intermediate rounds)

- **If in previous round (t-1):**

  1. Reward was met (≥ m cooperators):

     - Defect if the number of cooperators excluding self ≥ m (meaning others will likely cooperate enough again).

     - Cooperate only if the total cooperating players in last round was exactly m, and you were defecting last round, and the risk of reward loss next round is high (i.e., others may reduce cooperation), to maintain threshold.

     Pseudocode outline:

     ```
     if C_(t-1) >= m:
        if I played D in t-1 and C_(t-1) == m:
            // be "semi-cooperative" to keep reward alive
            play C
        else:
            play D
     ```

  2. Reward was not met (< m cooperators):

     - Cooperate to try to push the total cooperators to threshold (since losing reward is costly).

     - But if you cooperated last round and still failed, keep defecting to conserve endowment (punish the group).

     Pseudocode outline:

     ```
     else: // reward missed
        if I played C in t-1:
           play D // punishment round
        else:
           play C // attempt cooperation to reach threshold
     ```

---

### Last Round (t = r)

- **Defect (D) no matter what.**  

Reasoning:  
No future punishment possible. Take the maximum private payoff. The incentive to contribute without future rounds to encourage cooperation disappears.

---

### Summary of Aggression

- Defect by default; cooperate only to maintain needed threshold when reward loss threatens.

- Exploit cooperators by defecting while threshold is safely met.

- Temporarily cooperate only when losing the reward threatens total payoffs.

- Defect definitely in round 1 and last round to maximize private gain.

---

## Pseudocode Summary

```python
def aggressive_strategy(t, r, m, k, history):
    # history: list of tuples (actions_round, payoffs_round)
    # actions_round: list of length n with 'C' or 'D' for each player i 
    # payoffs_round: list of payoffs for each player i
    # self_index: index of this player i (assumed known)
    
    if t == 1:
        return 'D'  # always defect first round
    
    if t == r:
        return 'D'  # always defect last round
    
    # Extract last round data
    last_actions, last_payoffs = history[t-2]  # zero-index correction
    
    # Count cooperators in last round
    C_last = last_actions.count('C')
    my_last_action = last_actions[self_index]
    
    # Check if reward was obtained last round
    reward_achieved = (C_last >= m)
    
    if reward_achieved:
        # If threshold just barely met and I defected last round,
        # cooperate this round to maintain reward
        if my_last_action == 'D' and C_last == m:
            return 'C'
        else:
            return 'D'
    else:
        # Reward missed last round
        
        if my_last_action == 'C':
            return 'D'  # punish, conserve endowment this round
        else:
            return 'C'  # attempt cooperation to recover reward
```

---

## Edge Case Justification

- **First round defect:** Allows testing opponent cooperativeness without cost; aggressive move.

- **Last round defect:** No incentive to cooperate since no future retaliation or reward maintenance is needed.

- **Intermediate rounds adjust cooperation only when reward is at risk:** Avoid unnecessary cooperation when others reliably maintain threshold; exploit by defecting.

- **Punishment phase:** After failed reward round in which you cooperated, switch to defection to preserve own payoff and punish group failure.

---

## Final Notes

This strategy is aggressive and selfish:

- Exploits cooperative players to increase own payoff.

- Only cooperates when strategic to maintain threshold and collective reward.

- Uses defections as threat in intermediate rounds to punish weak cooperation.

- Maximizes individual payoff over repeated rounds by opportunistic cooperation.

Such a strategy should fare well against naïve cooperators or conditional cooperators, extracting as much benefit as possible while still sustaining group rewards when necessary.
'''

description_AGGRESSIVE_4 = '''
**Aggressive Strategy for Collective Risk Dilemma**

---

### Strategic Principles

- **Aggressive Mindset:** Maximize own payoff aggressively by exploiting cooperative players whenever possible.
- **Exploit Cooperation:** Defect whenever feasible to reap the reward **k** without paying the cooperation cost.
- **Minimal Cooperation:** Only cooperate when it guarantees avoiding a loss due to insufficient cooperators and is necessary to trigger the threshold.
- **Intimidate by Defection:** Early defection to punish unconditional cooperators, forcing others into cautious, less cooperative behavior.
- **Last round defection:** Defect on the final round to maximize payoff, as no future punishment is possible.

---

### High-Level Description

- **Round 1:** Defect outright. Test opponents’ willingness to cooperate.
- **Rounds 2 to r-1:**
  - Cooperate *only if* defecting this round risks failing the cooperation threshold, making all players earn only 1 payoff (no reward).
  - Otherwise, defect to exploit cooperators who keep cooperating out of goodwill or fear.
- **Round r (last round):** Defect regardless of history to maximize one-shot exploitation (no future penalty).
- **Threshold assessment:**
  - Use **previous round's cooperation count** to estimate how many are likely to cooperate this round.
  - Cooperate only if own cooperation is the **minimum necessary** to reach threshold **m**; otherwise defect.
- **Edge case:** If the round before was lost (fewer than m cooperators), consider cooperating once to push threshold across next round, but no more.

---

### Pseudocode

```python
# Parameters:
# n = number of players
# r = number of rounds
# m = minimum cooperators needed
# k = reward multiplier > 1

# Inputs per round:
# t = current round (1-based)
# coop_count_prev = number of cooperators in previous round (None if t == 1)

def aggressive_strategy(t, coop_count_prev):
    # Always defect in first round (exploit naïveté)
    if t == 1:
        return 'D'
    
    # Always defect in last round (no future punishment)
    if t == r:
        return 'D'
    
    # For intermediate rounds (2 .. r-1)
    # Estimate cooperation in this round based on last round
    # Assume other players repeat their last actions
    
    # If previous round had no data (shouldn't happen except t=1) defect by default
    if coop_count_prev is None:
        return 'D'
    
    # If threshold was met in previous round:
    if coop_count_prev >= m:
        # Assume similar cooperation level this round
        expected_cooperation = coop_count_prev
        
        # If defecting does not lower total cooperators below m,
        # defect and exploit cooperators
        if expected_cooperation - 1 >= m:
            return 'D'  # Exploit cooperating majority
            
        # If defecting drops below threshold, cooperate
        else:
            return 'C'  # Minimal cooperation to keep threshold
        
    else:
        # Previous round failed threshold
        # Cooperate once to try to reach threshold if possible,
        # but only if own cooperation can flip outcome
        if coop_count_prev + 1 >= m:
            return 'C'
        else:
            return 'D'  # No use cooperating if still can't reach threshold
```

---

### Explanation

- **Round 1 defect:** Maximizes initial gain and tests cooperation baseline.
- **Middle rounds:** Cooperate only when your cooperation is pivotal to maintain threshold and thus unlock reward for all. Otherwise defect to maximize payoff.
- **Last round defect:** Since no future consequences, always exploit.
- **Exploitation focus:** When majority cooperate, rebel by defecting to pocket both private endowment and reward.
- **Adaptive:** Bases decision on previous round’s observed cooperation, as perfect information allows.

---

### Summary

This strategy plays aggressively by defecting whenever it can, cooperating only when necessary to push the group past the cooperation threshold to unlock the reward. It punishes unconditional cooperators and seeks to maximize payoff by capitalizing on their cooperation and the game’s repeated nature — until the last round when exploitation is maximized outright.
'''

description_AGGRESSIVE_5 = '''
Certainly! Below is a detailed aggressive strategy for the **Collective Risk Dilemma** that you can employ in the tournament. The idea is to exploit cooperators when possible, push the group toward frequent defection when cooperation is unlikely, but still cooperate strategically to trigger rewards when advantageous.

---

### Aggressive Strategy Outline

**Core mindset:**  
Maximize own payoff by **defecting whenever profitable**, only cooperate **just enough to reach or appear to reach the cooperation threshold**, and punish unfavourable cooperation to push others to keep cooperating for your benefit.

---

### 1. Decision Rules

**Initialization (Round 1):**  
- Defect by default. Gauge opponents' willingness to cooperate in the initial round.

**Subsequent Rounds (2 to r-1):**  
- Track cooperators count `C_t-1` from previous round.
- If `C_t-1 ≥ m`, **defect** this round to enjoy risk averted reward without cost.
- If `C_t-1 = m-1`, **cooperate** this round to push the group over the threshold, enabling everyone (including defectors) to get the reward.
- If `C_t-1 < m-1`, **defect** this round to conserve endowment. Risk of no reward is high anyway.

**Last Round (Round r):**  
- Defect regardless. No future rounds to enforce cooperation; exploit any last-minute cooperation.

---

### 2. Handling Edge Cases & Rationale

- **First round defection:**  
  No history to exploit cooperators yet, so defect to free-ride on potential cooperators.

- **Near-threshold cooperation:**  
  When others nearly cooperate (`m-1` players cooperate), cooperate just enough to push total cooperation over threshold and reap the k reward, free-riding on others’ potential cooperation. This is the core aggressive exploitation.

- **Last round defection:**  
  Without future retaliation possible, cooperating is a pure cost. Defect to maximize last round payoff.

- **If no cooperators detected in previous round:**  
  Because cooperation is unlikely, save costs by defecting.

- **If coordination appears stable above threshold:**  
  Defect to free-ride as much as possible.

---

### 3. Pseudocode

```python
# Inputs per round:
# round_number (1 through r)
# previous_cooperators_count (number of players who cooperated last round)
# parameters: n, r, m, k

def aggressive_strategy(round_number, previous_cooperators_count, n, r, m, k):
    # Round 1: defect by default
    if round_number == 1:
        return 'D'

    # Last round: always defect
    if round_number == r:
        return 'D'

    # If previous round had enough cooperators, free-ride
    if previous_cooperators_count >= m:
        return 'D'

    # If previous round was just short of threshold, cooperate to push over threshold
    if previous_cooperators_count == m - 1:
        return 'C'

    # Otherwise, defect to save cost
    return 'D'
```

---

### 4. Strategy Summary

| Situation                                              | Action | Reason                   |
|--------------------------------------------------------|--------|--------------------------|
| Round 1                                                | Defect | Test waters, no info yet |
| Last round (round r)                                  | Defect | No future, exploit now   |
| Previous round cooperators ≥ m                        | Defect | Free ride risk averted   |
| Previous round cooperators = m - 1                     | Cooperate | Push over threshold, enable reward |
| Previous round cooperators < m - 1                     | Defect | Cooperation unlikely, save cost |

---

### Final Notes

- This strategy aggressively exploits cooperators by defecting whenever the risk threshold is met.
- It opportunistically cooperates only to ensure the group surpasses the threshold when the cooperation level is close.
- It reduces unnecessary cooperation costs when the group is far from threshold.
- It punishes last round cooperation attempts by defecting.

This approach aligns well with maximizing individual payoffs in a repeated collective risk dilemma where others may try to cooperate. It pressures others to carry cooperation burdens and exploits their cost while minimizing your own.

---

If you want, I can also advise on counter-strategies likely used by other LLMs or nuance on implementation details.
'''

description_AGGRESSIVE_6 = '''
**Aggressive Strategy for Collective Risk Dilemma**

---

### Strategic Goal
Maximize individual payoffs by exploiting cooperative players while still ensuring the public good reward is triggered when beneficial.

---

### Key Observations

- Defecting yields a private payoff of 1 per round by default.
- If threshold *m* cooperators is met, payoff is enhanced by reward *k* (>1), regardless of cooperating or defecting.
- Defectors earn more than cooperators when threshold is met because they save the contribution cost.
- Cooperating alone or with insufficient cooperators yields no reward, so cooperating alone is strictly worse.

---

### High-Level Strategy Concept

- **First round:** Defect to "test" the baseline behavior and avoid initial loss.
- **Subsequent rounds:** 
  - Exploit cooperators' willingness to cooperate by defecting if cooperation threshold *m* is met or likely to be met.
  - Attempt to trigger the reward by cooperating only if it allows you to increase your expected total payoff across rounds.
- **Last round:** Since no future rounds exist, free ride on cooperators by defecting if threshold is met or met candidates likely cooperate.
- **Respond to defection:** Punish other defectors only if it benefits future reward triggers (rare).
- **Adapt based on observations:** If too few cooperate to reach threshold, switch to mutual defection.
  
---

### Detailed Decision Rules

---

#### Initialization:

- Keep track of the number of cooperators each round.
- Maintain a memory window of last rounds’ cooperation counts.

---

#### Round 1:

- **Action:** Defect (D)
- **Rationale:** Avoid guaranteed contribution loss; observe others' behavior.

---

#### Round t (2 ≤ t < r):

- Compute `prev_cooperators` = count of cooperating players in round t-1.
- **If `prev_cooperators` ≥ m:**  
  You know threshold was met previously.  
  - **Action:** Defect (D) to free ride on the reward.  
  - **Reason:** Others cooperate, so you get higher payoff without cost.

- **Else if `prev_cooperators` = m - 1:**  
  - **Action:** Cooperate (C) to reach or maintain threshold.  
  - **Reason:** Your cooperation triggers the reward, which increases your payoff.  
  - **Rationale:** Paying cost 1 now to secure payoff boost *k* (>1).

- **Else (`prev_cooperators` < m - 1):**  
  - Cooperators too few to reach threshold last round, unlikely to reach threshold this round.  
  - **Action:** Defect (D) to avoid sunk cost.

---

#### Round r (last round):

- Observe `prev_cooperators` from round r-1.

- **If `prev_cooperators` ≥ m:**  
  - **Action:** Defect (D) to maximize payoff by free-riding last round.

- **Else if `prev_cooperators` = m - 1:**  
  - Cooperating won't benefit you because no future rounds to incentivize cooperation.  
  - **Action:** Defect (D).

- **Else:**  
  - **Action:** Defect (D).

---

### Edge Cases and Considerations

- **If threshold is never reached:** always defect (except first round), since cooperating loses payoff.
- **If threshold met with exactly *m* cooperators, including you:** you cooperate to maintain reward.
- **If threshold met with more than *m* cooperators:** free ride by defecting.
- **If uncertain due to noise:** rely on previous rounds’ patterns.
- **No forgiveness or signaling:** strictly self-serving and aggressive.
- This encourages cooperators to effectively carry the burden and you free-ride.

---

### Pseudocode

```python
def aggressive_strategy(t, r, m, k, prev_actions):
    # prev_actions: list of lists of actions by all players in previous round (index t-2)
    
    if t == 1:
        return 'D'  # First round, defect
    
    prev_round_actions = prev_actions[-1]  # actions of all players in round t-1
    prev_cooperators = prev_round_actions.count('C')
    
    if t < r:
        if prev_cooperators >= m:
            return 'D'  # threshold met, free ride
        elif prev_cooperators == m - 1:
            return 'C'  # just enough to trigger reward
        else:
            return 'D'  # not worth cooperating
    
    else:  # last round
        if prev_cooperators >= m:
            return 'D'  # free ride on last round
        else:
            return 'D'  # no incentive to cooperate last round
```

---

### Summary

- Always start defecting.
- Cooperate only when your cooperation can secure or trigger the threshold.
- Otherwise, defect to free ride.
- Free ride especially on last round.
- Ignore or punish no one explicitly; only act to maximize own payoff aggressively.
  
This maximizes your payoff by capitalizing on others’ cooperation rather than building cooperation yourself.
'''

description_AGGRESSIVE_7 = '''
Here is an **aggressive strategy** for the Collective Risk Dilemma that aims to maximize individual payoffs by exploiting cooperative players while enforcing cooperation when it benefits the aggressor. The strategy focuses on defecting to gain immediate advantage but switches to cooperation strategically to ensure the group hits the threshold **m** to unlock reward **k**, avoiding risk of losing out entirely.

---

### Strategy Overview

- **Goal:** Maximize individual payoff by defecting when safe, and cooperating only to meet or maintain the cooperation threshold (m). Exploit cooperators aggressively by defecting when the threshold is met, forcing others to bear cooperation cost.
- **Mindset:** Dominate the game by free-riding on cooperators, but cooperate just enough to ensure the threshold is reached (and the reward is obtained).
- **Threat:** Punish rounds with too few cooperators by cooperating temporarily to secure reward, then return to defecting.

---

### Decision Rules

#### Notation:

- Let `C_t` = set of players who cooperated in round t (from history).
- Let `count(C_t)` = number of cooperators in round t.
- Let `me` = this player’s index.
- Let `r` = total rounds.
- Let `t` = current round (1-based).
- Let `m` = minimum number of cooperators needed.
- Let `k` = reward factor.
- Let `n` = total players.

---

### Round 1 (t=1):

- **Defect (D)**

*Reason:* No history to rely on, aggressive approach is to avoid cost initially and observe others.

---

### Round t > 1 and t < r (middle rounds):

- Observe previous round cooperation count: `prev_coop = count(C_{t-1})`

- **If (prev_coop < m):**

  The group failed threshold last round; reward not paid.

  - **Cooperate (C)** to help restore cooperation and unlock reward next round.

*Rationale:* Avoid continued loss of reward. As aggressor, cooperate enough to bring group up to threshold but no more.

- **Else if (prev_coop >= m):**

  The group met threshold, reward granted last round.

  - **If (prev_coop > m):**

    More cooperators than needed last round → some players "overspending" cooperation.

    - **Defect (D)** to free-ride and exploit cooperators.

  - **If (prev_coop == m):**

    Exactly threshold met last round.

    - **Defect (D)** (most aggressive).

    But risk causing threshold failure next round.

  **To reduce risk of threshold failure:**

  - Count how many times we defected consecutively causing threshold failure.

  - If > 1 consecutive failures due to own defection, switch to **Cooperate (C)** to avoid losing reward long-term.

---

### Last Round (t = r):

- Aggressive defection may be safest as no future rounds to secure reward.

- But if previous round failed threshold:

  - **Cooperate (C)** if can push group over threshold and reap reward this round.

- Else:

  - **Defect (D)** to maximize immediate payoff without future retaliation.

---

### Edge Cases Handling

- If cooperation threshold `m` is very close to `n` (e.g., `m = n-1`), be more cautious in defecting when threshold is just met, to avoid losing large reward.

- If reward factor `k` is very large, more incentive to cooperate occasionally to secure guaranteed reward.

- In noisy environments or unpredictable opponents, default more often to cooperation following failure rounds to ensure reward.

---

### Summary of Strategy as Pseudocode

```python
initialize:
    consecutive_threshold_failures = 0

for t in 1 to r:

    if t == 1:
        action = DEFECT

    else:
        prev_coop = count(C_{t-1})

        if prev_coop < m:
            # Threshold missed last round
            consecutive_threshold_failures += 1
            action = COOPERATE

        else:
            # Threshold met last round
            consecutive_threshold_failures = 0

            if prev_coop > m:
                # Exploit cooperators
                action = DEFECT

            else:  # prev_coop == m
                # Aggressively defect, but be cautious
                if consecutive_threshold_failures > 1:
                    # Previous multiple failures from defecting → cooperate to fix
                    action = COOPERATE
                else:
                    action = DEFECT

    # Last round adjustment
    if t == r:
        if prev_coop < m:
            action = COOPERATE
        else:
            action = DEFECT

    play(action)
```

---

### Explanation and Aggressiveness Justification

- The strategy **starts defecting immediately** to avoid paying cost upfront.
- When the group fails to meet the threshold, it **temporarily cooperates** to restore rewards, but only enough to ensure the reward threshold is met.
- After threshold is met, it **returns to defecting** to maximize personal payoff, exploiting cooperators.
- Carefully monitors prior failures to avoid destroying group cooperation entirely, but doesn't shy from repeatedly defecting if reward is secured.
- In the last round, it **opts to defect unless necessary to cooperate** to cross threshold and get final reward.
- It's **aggressive because it never cooperates unless forced by risk of losing big reward**, and even then only minimally.
- It **exploits cooperative players** by defecting whenever the threshold is met or exceeded.

---

This approach aims to maximize your total payoff over all rounds by:

- Minimizing cooperation cost,
- Leveraging reward opportunities created by others, and
- Only cooperating when losing the reward long-term would be too costly.

It aligns clearly with an aggressive player profile in this Collective Risk Dilemma.
'''

description_AGGRESSIVE_8 = '''
Here is an aggressive strategy tailored for the Collective Risk Dilemma that aims to maximize individual payoffs even at some risk of collective failure. The aggression principle here is: **defect whenever advantageously possible, and only cooperate narrowly to avoid losing the guaranteed high payoff from defection plus reward (if threshold met).**

---

## Aggressive Strategy: "Threshold Enforcer"

### Intuition
- Defect maximizes your private gain (keep the endowment = 1) plus the risk reward k if the threshold is met.
- Cooperate only if you believe defecting risks falling below the threshold **m**, which would cost you the reward k.
- Use observed history from previous rounds to judge whether enough others are likely to cooperate.
- Act selfishly but avoid total breakdown by minimal cooperation only when absolutely needed.
- In early rounds, probe others for cooperation (via some cooperation), but quickly shift to exploiting defectors.
- In the last round, defect unless threshold is guaranteed by others, since no future rounds remain to punish you.

---

### Notation
- Let `countC_t` denote the number of cooperators observed in round t.
- Let `t` be the current round (1 to r).
- Let `lastRound = r`.
- Let `thresholdReached_t` be True if `countC_t >= m` else False.

---

### Decision rules

#### Round 1 (Initial probing)
- Cooperate with low probability to "test" if any residual cooperation exists.
- For aggression, set:
  - `p_cooperate = 0.2` (cooperate 20% of time at round 1)
- So:
  ```
  If random() < 0.2:
     action = C
  Else:
     action = D
  ```

---

#### Intermediate rounds 2 ≤ t < r

- At round t, look at previous round t-1 cooperation count `countC_{t-1}`.
- If previous cooperation reached threshold (`countC_{t-1} >= m`):
  - Defect **because** defectors still got the reward; you can exploit others who cooperated.
- Else if previous cooperation failed threshold (`countC_{t-1} < m`):
  - Cooperate **if** you estimate cooperation is fragile (e.g., if `countC_{t-1} == m - 1`)
  - Otherwise defect.

- This implicitly punishes cooperation that doesn't meet threshold, and rewards defectors who rely on others.

Pseudocode:
```
if countC_{t-1} >= m:
    action = D  # exploitation
else:
    if countC_{t-1} == m - 1:
        action = C  # attempt to push cooperation to threshold
    else:
        action = D  # defect, no incentive to help failing group
```

---

#### Last round (t = r)

- The last round is purely greedy because no future rounds exist to punish.
- Defect unless threshold guaranteed by others.
- Based on last round-1 cooperation:

Pseudocode:
```
if countC_{r-1} >= m:
    action = D  # defect, assuming enough others will cooperate to get threshold
else:
    action = D  # defect since no incentive to cooperate on last round
```

As you can see, the action in the last round is always to defect.

---

### Summary Table

| Round | Condition                               | Action     |
|-------|---------------------------------------|------------|
| 1     | With 20% chance cooperate; else defect| C or D probabilistic |
| 2..r-1| If prev threshold met: defect          | D          |
|       | Else if prev cooperators == m-1: cooperate| C       |
|       | Else defect                            | D          |
| r     | Always defect                         | D          |

---

### Edge Cases & Notes

- **If `m` is close to `n`** (e.g., m=n-1): The strategy still tries to defect mostly, cooperating only if just one short of threshold.
- **If others fully defect**: you always defect except rare first round cooperation (probing).
- **If others cooperate fully**: the strategy exploits by defecting once threshold previously met.
- **No communication**: use only observed count from previous round to inform next round.
- **Randomness only in round 1**: to make behavior less predictable at start.

---

## Complete Pseudocode

```
function decide_action(t, history_counts):
    # history_counts: list of integers of cooperators in previous rounds (empty if t=1)
    if t == 1:
        # Probabilistic probe cooperators
        if random() < 0.2:
            return C
        else:
            return D

    prev_countC = history_counts[t-2]  # indices 0-based, prev round cooperators

    if t == r:
        # Last round: defect always
        return D

    # Intermediate rounds
    if prev_countC >= m:
        return D  # Exploit others

    if prev_countC == m - 1:
        return C  # Cooperative nudge to reach threshold

    return D      # Otherwise defect
```

---

## Final remarks

This strategy embodies aggression by:

- Minimal voluntary cooperation
- Frequent exploitation of cooperators once threshold met
- Maximizing private payoffs by defecting wherever safe
- Avoiding costly cooperation in the last round
- Only limited cooperation when necessary to prevent failure of threshold (and losing the big reward)

By smartly balancing exploitation with minimal cooperation, this aggressive strategy maximizes the typical individual payoff in the repeated collective risk dilemma.
'''

description_AGGRESSIVE_9 = '''
Below is an aggressive strategy designed for the Collective Risk Dilemma, emphasizing exploitation, intimidation, and minimal cooperation to secure high payoffs.

---

## Aggressive Strategy: "Threshold Exploit and Punish (TEP)"

### Intuition
- Defect aggressively to maximize private payoffs.
- Only cooperate **just enough** to meet or nearly meet the cooperation threshold _m_, forcing other players to bear the cost of cooperation.
- Intimidate potential cooperators by punishing insufficient cooperation.
- Avoid being the sucker who cooperates without sufficient reciprocation.
- In later rounds, escalate defection to extract maximum payoff.

---

### Decision Rules Overview

At each round t (1 ≤ t ≤ r):

1. **Round 1 (Initialization / Signal):**
   - Defect. (Probe opponents' reactions and collect baseline info.)

2. **From Round 2 to Round r-1 (Exploitation and Control):**
   - Estimate the number of cooperators _C_{t-1}_ in previous round.
   - If _C_{t-1} ≥ m_:  
     - **If I cooperated last round:**  
       - Defect this round to gain greater payoff (because reward k is still granted if threshold met).
     - **Else (I defected last round):**  
       - Continue defecting (free-riding safely while others cooperate).
   - If _C_{t-1} < m_:  
     - Cooperate **only if** cooperating this round will raise cooperation count to at least _m_, **and** if I did not cooperate last round (to keep my own cooperation frequency minimal).
     - Otherwise, defect.

3. **Round r (Last round, endgame):**
   - Defect unconditionally (no future rounds to punish or reward cooperation).
   - Take max private payoff unless cooperation is guaranteed to yield a strictly higher payoff.

---

### Details and motivations

Because payoffs are additive per round, and total payoff is sum over rounds, gaining private payoffs (defection) is always tempting. The only extra benefit comes if the cooperation threshold _m_ is met.

- Cooperate only when it *helps* guarantee the reward _k_; *never* cooperate just to "be nice."
- If others meet the threshold without you cooperating, you get reward _k_ plus private payoff — *you exploit their cooperation*.
- When the threshold isn't met, defect to avoid losses.
- By punishing rounds where cooperation is insufficient (through own defection), you discourage unconditional cooperators.
- In the last round, defect since there's no future incentive to cooperate.

---

### Pseudocode

```python
# Inputs per round:
#   prev_actions: list of length n with past round actions of all players (C or D),
#                 None for round 1.
#   my_index: my player index (0-based)
# Parameters:
#   n, m, k, r, t (current round number)

def aggressive_decision(t, prev_actions_list, my_action_history, n, m, k, r, my_index):
    if t == 1:
        # First round: defect to probe limits.
        return 'D'

    # Analyze last round's cooperation count
    last_round_actions = prev_actions_list[-1]
    coop_count = sum(1 for a in last_round_actions if a == 'C')

    i_cooperated_last_round = (my_action_history[-1] == 'C')

    if t < r:
        if coop_count >= m:
            # Threshold met last round
            if i_cooperated_last_round:
                # Exploit others by defecting now
                return 'D'
            else:
                # Continue defecting, free-ride on reward
                return 'D'
        else:
            # Threshold NOT met last round
            # Check if my cooperation can raise current round's cooperation to threshold
            # Estimate others' likely behavior - assume they repeat last action
            estimated_coop_count = sum(1 for i,a in enumerate(last_round_actions)
                                       if a == 'C' and i != my_index)
            # If defect last round and cooperation can help meet threshold this round,
            # cooperate minimally to push over threshold.
            if (my_action_history[-1] == 'D') and (estimated_coop_count + 1 >= m):
                return 'C'
            else:
                # Otherwise defect to punish or avoid sucker payoff
                return 'D'

    else:
        # Last round: defect aggressively, no future payoff to consider
        return 'D'
```

---

### Summary

- **Round 1:** Defect to gather info.
- **Middle rounds:** Cooperate only when your contribution is decisive in reaching the threshold; otherwise defect.
- **Last round:** Defect unconditionally.
- **Overall:** Minimize cooperation cost, exploit cooperating opponents, and punish insufficient cooperation by defecting.

This strategy aggressively seeks to maximize personal gains by forcing others to cooperate sufficiently while avoiding costly cooperation whenever possible. It leverages the reward structure and perfect monitoring to adapt dynamically, demonstrating dominance and deterrence in repeated interactions.
'''

description_AGGRESSIVE_10 = '''
Below is an **aggressive strategy** designed for the Collective Risk Dilemma that maximizes individual advantage by exploiting cooperative players while maintaining minimal cooperation when strictly necessary to secure the collective reward. The strategy focuses on maximizing personal payoffs through mostly defection, but strategically cooperating just enough to ensure the reward is attained by others or enforced if beneficial.

---

## Aggressive Strategy: "Minimal Cooperate and Exploit"

### Intuition
- Defect whenever possible to keep the guaranteed private payoff (1).
- Cooperate only when:
  - It's necessary to trigger the collective reward (k).
  - The reward is large enough that cooperating yields more than defecting alone.
- Punish cooperators to pressure them into cooperating less also.
- Exploit rounds and player behavior to maximize personal payoff by mostly defecting and free-riding on others’ cooperation.

---

### Decision Rules

Let:
- \( i \) = current player index
- \( t \in \{1,\dots,r\} \) = current round
- \( c_t \) = number of cooperators in round \( t \) (excluding current observation when deciding)
- \( m, n, k \) given by the game
- \( \text{past\_actions}[j][s] \) = action of player \( j \) in round \( s < t \)

---

#### 1. **First Round (t = 1)**
- Defect to test others’ tendencies.
- **Rationale:** Aggressive opening; never cooperate first.
-  
```pseudocode
if t == 1:
    action = D
```

---

#### 2. **Intermediate Rounds (1 < t < r)**
- Observe cooperation levels in previous rounds.
- Compute average cooperators \( \bar{c} \) over past rounds.
- Predict if reward will be triggered this round without your cooperation.

**If predicted cooperators \(\geq m\) without you:**
- Defect to free-ride.

**Else if predicted cooperators \(= m-1\):**
- Cooperate to push cooperation to threshold and get reward, if the reward \( k > 1 \) justifies cooperating once in a while to secure the payoff boost.

**Else:**
- Defect.

**Additionally:**

- Punish persistent cooperators who cooperate every round by defecting against them to discourage over-cooperation.
- If cooperation falls below threshold persistently (no reward likely), defect indefinitely.

```pseudocode
if t > 1 and t < r:
    past_cooperators_each_round = number of players who cooperated in each past round (excluding self)
    avg_cooperators = average(past_cooperators_each_round)

    predicted_cooperators = avg_cooperators  # simplest prediction

    # Because we choose simultaneous, treat predicted cooperators as what others likely do
    if predicted_cooperators >= m:
        # Reward will be achieved without your cooperation
        action = D  # free-ride
    else if predicted_cooperators == m - 1 and k > 1:
        # Edge case: just enough cooperators without you, cooperate to trigger reward
        action = C
    else:
        action = D

```

---

#### 3. **Last Round (t = r)**
- Defect regardless; no future punishment incentive.
- Aggressively exploit others one last time.

```pseudocode
if t == r:
    action = D
```

---

### Summary of Strategy Behavior
| Round        | Condition & Behavior                             | Purpose                       |
|--------------|------------------------------------------------|-------------------------------|
| First round  | Defect                                         | Test others and avoid early cooperation loss |
| Intermediate | Cooperate only if exactly \( m-1 \) others cooperate (to secure reward) | Minimal cooperation to get reward when payoff is beneficial |
|              | Otherwise defect                               | Exploit by free-riding         |
| Last round   | Defect                                         | Aggressive exploitation with no future consequences |

---

### Additional Notes

- By cooperating only when the community cooperation is exactly one less than the threshold, this strategy minimizes costly cooperation but still secures the collective reward when profitable.
- Always defects in the first and last rounds to maximize personal gain.
- The strategy aggressively exploits cooperative opponents who do not adjust their cooperation in response. By doing so, this strategy exploits the benefit of the common reward without paying full costs.
- Since communication is forbidden, this strategy assumes others are roughly consistent in cooperation rate and uses that to predict threshold achievement.
- If the other players are also aggressive defectors, the reward will often not be met, ending in low payoffs; this strategy sacrifices some cooperative gains in favor of maximizing payoffs when others cooperate.

---

## Pseudocode Summary

```pseudocode
for t in 1 to r:
    if t == 1:
        action = D
    else if t == r:
        action = D
    else:
        past_cooperators_each_round = [count cooperators excluding self in rounds 1..t-1]
        avg_cooperators = average(past_cooperators_each_round)

        predicted_cooperators = avg_cooperators  # prediction of others cooperating this round

        if predicted_cooperators >= m:
            action = D  # free-ride
        else if predicted_cooperators == m - 1 and k > 1:
            action = C  # cooperate just enough to get reward
        else:
            action = D
```

---

This strategy aggressively leverages defection, exploits cooperative players, and only cooperates strategically to gain the collective bonus when it is easy to push the group over the threshold. It embraces risk and aggressive free-riding rather than mutualistic cooperation.
'''

description_AGGRESSIVE_11 = '''
Here is a detailed design of an aggressive strategy for the Collective Risk Dilemma.

---

## Strategy Overview: "Aggressive Exploiter"

**Philosophy:** Aggressively seek to maximize individual payoffs by defecting whenever possible without risking the collective reward threshold being missed, exploiting cooperation of others but retaliating quickly if exploitation is detected.

---

## Key Intuition

- **Aggressive:** You lean towards defecting to gain the free benefit of the communal reward whenever others contribute.
- **Conditional Cooperation:** You only cooperate if doing so is strictly necessary to achieve the threshold \( m \) cooperators, ensuring you don't unintentionally cause the group to fail.
- **Retaliation:** Quickly punish any rounds where the group almost fails or cooperation is unexpectedly low, signaling you will not overly cooperate or be exploited.
- **Last Round:** Always defect on the last round for maximum personal gain, as no future punishment/reward incentive exists.

---

## Notation and Data Available Each Round \( t \)

- \( n \): number of players
- \( m \): threshold minimum cooperators to meet
- \( r \): total rounds
- Observed previous rounds' cooperation counts \( C_{\text{past}}(t') \) for \( t' < t \)
- Your own action history \( a_i(t') \)
- Opponents' actions history

---

## Detailed Decision Rules

### Round 1 (no history)

- Assume minimal cooperation by others (worst case).
- To avoid losing communal reward early, cooperate **only if \( m = 1 \)**.
- Else defect to gain private payoff; others will likely cooperate randomly.
  
Pseudocode:

```pseudo
if t == 1:
    if m == 1:
        play C
    else:
        play D
```

---

### Intermediate Rounds \( 1 < t < r \)

1. **Estimate cooperation level:**

   - Calculate average cooperators in past rounds:
   \[
   \bar{C} = \frac{1}{t-1} \sum_{s=1}^{t-1} C_{\text{past}}(s)
   \]

2. **If \(\bar{C} \geq m\):**

   - Assume you can afford to defect while still meeting the threshold.
   - Defect to gain payoff 1 plus communal reward \( k \).

3. **If \(\bar{C} < m\):**

   - Group is under-cooperating; to avoid losing reward, must **cooperate** this round.
   - Cooperate to push cooperation count towards \( m \).

4. **If in *previous round* cooperation was just below \( m \) (i.e., \( C_{\text{past}}(t-1) = m-1 \)) and you defected last round:**

   - Defection risked missing threshold.
   - Punish: cooperate now to avoid losing communal reward.

5. **Retaliation Trigger:**

   - If in any previous round the total cooperators \( C_{\text{past}}(s) < m \):

     - Assume opponents are unreliable.
     - Defect aggressively for the rest of the game to avoid cooperating with free riders.

Pseudocode:

```pseudo
if any C_past(s) < m for s < t:
    play D  # Aggressive retaliation mode
else:
    avgC = average of C_past(1 to t-1)
    if avgC >= m:
        play D
    else:
        play C
```

---

### Last Round \( t = r \)

- Always defect to maximize final payoff:

```pseudo
if t == r:
    play D
```

---

## Summary Pseudocode

```pseudo
for each round t in 1 to r:

    if t == r:
        play D  # Last round defect

    else if t == 1:
        if m == 1:
            play C
        else:
            play D

    else:
        if exists s < t where C_past(s) < m:
            play D  # Retaliation: defect rest of game

        else:
            avgC = average(C_past(1 ... t-1))
            if avgC >= m:
                play D
            else:
                play C
```

---

## Edge Case Considerations

- **If \( m=1 \) and cooperating is cheap:** cooperate from round 1 to ensure reward.
- **If opponents cooperate fully throughout:** exploit by defecting as much as possible.
- **If cooperation barely meets threshold:** cooperate just enough to avoid losing the communal reward.
- **If repeated failures to reach threshold occur:** switch to permanent defection (punishment).
- **No communication, so rely only on actual past cooperation counts and your own experience.**

---

## Aggressive Nature Summary

- Defect often, only cooperate when absolutely necessary.
- Exploit cooperative opponents by defecting whenever group is reliably above threshold.
- Cut losses by defecting permanently if group shows instability.
- Always defect last round (no future consequences).
- Do not be gullible or overly generous.

---

This strategy maximizes individual gain while managing risk of losing collective reward via a mostly selfish, aggressive, and conditional cooperation style.
'''

description_AGGRESSIVE_12 = '''
### Aggressive Strategy for Collective Risk Dilemma

**Goal:**  
Maximize personal payoff by exploiting cooperators — defecting whenever payoff is better or when can free-ride, cooperating only when absolutely necessary to secure the group reward and prevent collapse (which would penalize everyone, including self).

---

## Intuition and Rationale

- Defect by default to keep the endowment (payoff 1).
- Exploit others’ cooperation to gain the reward (payoff 1 + k) by defecting while enough players cooperate.
- Cooperate only if the risk of falling below the threshold *m* is imminent and losing the reward hurts you more than the cost of cooperating.
- Since the game is repeated with perfect info, dynamically adapt based on observed cooperation counts.
- On the last round, be more aggressive by defecting unless the reward is only achievable by cooperating yourself.

---

## Detailed Decision Rules

### Parameters and Observations Each Round \( t \):

- \( n, r, m, k \) — game parameters (common knowledge)
- \( t \in \{1, ..., r\} \) — current round
- History: previous rounds’ action profiles and players’ cooperation counts
- In round \( t \), observe how many cooperated last round, \( c_{t-1} \)

---

### 1. First Round \( (t = 1) \):

- **Defect**  
Reasoning: No prior info, assume opponents try to cooperate. Default to defecting to gain payoff 1 or if many cooperate get 1 + k by free riding.

---

### 2. Intermediate Rounds \( (1 < t < r) \):

- Let \( c_{t-1} \) = number of players who cooperated in previous round \( t-1 \).

- **If \( c_{t-1} \geq m \)** (enough cooperators to get reward without me):
  - **Defect.**  
  Rationale: Free-ride on others’ cooperation, maximize own payoff \( 1 + k \).

- **If \( c_{t-1} = m - 1 \)** (just one short of threshold):
  - **Cooperate.**  
  Rationale: If I defect, group misses threshold → payoff \(1\) only, otherwise reward \(1 + k\). The cost of cooperating (1) is offset by getting \(k\) reward instead of zero extra, thus cooperating improves payoff.

- **If \( c_{t-1} < m - 1 \)** (well below threshold):
  - **Defect.**  
  Rationale: The threshold isn’t going to be met even if I cooperate; no incentive to pay cost. No point helping a failing group.

---

### 3. Last Round \( (t = r) \):

- Observe cooperation count last round \( c_{r-1} \).

- **If \( c_{r-1} \geq m \):**  
  - **Defect.**  
  Reasoning: Final chance to free-ride on others' cooperation, maximize immediate payoff.

- **If \( c_{r-1} = m - 1 \):**  
  - **Cooperate.**  
  Cooperator needed to secure group reward one last time.

- **If \( c_{r-1} < m-1 \):**  
  - **Defect**, no reason to pay cost for lost cause.

---

## Summary Pseudocode

```python
def aggressive_strategy(t, r, n, m, k, history):
    """
    t: current round (1-based)
    r: total rounds
    n: number of players
    m: minimum cooperators for threshold
    k: reward factor
    history: list of previous rounds' actions by all players,
             e.g., history[t-2] = ['C', 'D', 'D', 'C', ...]
    """
    
    if t == 1:
        # First round, no prior info
        return 'D'  # defect aggressively to exploit potential cooperators

    else:
        last_round = history[t-2]
        cooperators_last_round = last_round.count('C')

        if t < r:  # intermediate rounds
            if cooperators_last_round >= m:
                return 'D'  # free ride
            elif cooperators_last_round == m - 1:
                return 'C'  # necessary cooperation to get reward
            else:
                return 'D'  # no point cooperating in lost cause
                
        else:  # last round
            if cooperators_last_round >= m:
                return 'D'  # free ride in last round
            elif cooperators_last_round == m - 1:
                return 'C'  # critical to cooperate last round
            else:
                return 'D'  # lost cause, defect
```

---

## Additional Notes

- The strategy assumes others may be cooperating sufficiently sometimes; thus "free-rides" when possible.
- It aggressively exploits borderline cases by defecting whenever it can, forcing others to cooperate if the reward is to be secured.
- It never tries to lead cooperation or bear unnecessary costs early on.
- It recognizes critical moments (threshold minus one cooperators) and steps in only then.
- Ensures last round opportunism — never wastes cooperation if reward can be freeloaded.
- Adapts quickly to changes in opponent cooperation behavior.

---

This design captures a ruthless, self-maximizing, and opportunistic mindset consistent with aggressive gameplay in a collective risk dilemma with repeated interaction and perfect observability.
'''

description_AGGRESSIVE_13 = '''
Certainly! Here is a clearly aggressive strategy designed for the Collective Risk Dilemma repeated game. The fundamental principle is to push for maximal personal gain by exploiting cooperators when possible while attempting to enforce cooperation only insofar as it benefits you.

---

## Aggressive Strategy: "Threshold Snipe"

### Intuition
- **Aggression is about maximizing personal payoffs even at others' expense.**  
- Exploit cooperative players by defecting when their numbers meet or exceed the threshold *m*, so you get the reward *k* plus your private endowment *1*.  
- Co-operate only when necessary to secure the group threshold, but never more than strictly required.  
- Use early rounds to probe others' willingness to cooperate (test if at least *m* players cooperate).  
- Exploit defections by defecting in the future to punish and maximize your payoff.  
- In the last round, defect always to maximize final payoff.

---

### Key Parameters and Variables
- **n:** number of players  
- **r:** total rounds  
- **m:** cooperative threshold  
- **k:** reward when threshold met  
- **current_round:** current round index (1-based)  
- **history:** record of all players’ actions in previous rounds  
- **estimate_cooperators:** estimated number of cooperators based on history  
- **defected_players:** set of players who defected when threshold was met to identify exploitable cooperators  

---

### Decision Rules Overview

| Round         | Decision Rule Summary                                   |
|---------------|--------------------------------------------------------|
| Round 1       | **Cooperate only if minority**: Cooperate if random or if expecting threshold met, else defect. |
| Early rounds (2 to r-1) | Cooperate **only if threshold cannot be met without you**; otherwise defect. Punish defectors who exploited cooperators previously by defecting. |
| Last round (r)| Always defect to maximize payoff (no future repercussions). |

---

### Detailed Decision Logic

#### Round 1:
- **Actively test if group tends to cooperate** by cooperating with a probability of 0.5 (or fixed cooperate to try establishing cooperation).
- Alternatively, **defect outright** to start aggressively, relying on others to cooperate or fail group payoff.
- My preference (pure aggression): **Defect in round 1** to get guaranteed 1 payoff, observe others.

#### Rounds 2 to r-1:

1. **Estimate** the number of cooperators in previous rounds *excluding self*.
2. If in recent rounds the number of cooperators (including self if cooperating) reached or exceeded *m*, then:

   - If I cooperated previously and got punished by defections (others defecting to free-ride), **defect now** to maximize payoff.
   
   - If I defected and the threshold was still met (others cooperated enough), **continue defecting** to maximize payoff.
   
   - Else, if group coordination is failing, **defect** to avoid wasting endowment.

3. If the threshold *m* could **not be met without me** (i.e., previous rounds showed average cooperators = m-1 when I defected):
   - **Cooperate** to trigger the reward *k*.
   - Otherwise, **defect** to free-ride if threshold likely met.

#### Last round (Round r):
- **Always defect.**

---

### Pseudocode

```python
def aggressive_strategy(round_number, history, params):
    n, r, m, k = params['n'], params['r'], params['m'], params['k']
    
    # Extract past rounds info
    if round_number == 1:
        # Round 1: Aggressive start, defect and observe others
        return 'D'
    
    # From round 2 to round r-1:
    past_round_cooperations = []
    for past_round in history:
        coop_count = sum(1 for action in past_round if action == 'C')
        past_round_cooperations.append(coop_count)
    
    # Calculate average cooperators in past rounds (excluding current self's hypothetical action)
    avg_cooperators = sum(past_round_cooperations) / len(past_round_cooperations) if past_round_cooperations else 0
    
    # Count how often threshold met and my contribution
    threshold_met_rounds = [c >= m for c in past_round_cooperations]
    my_coop_in_threshold_met = []
    
    # Get my player index (assumed given or 0 for example)
    my_index = params['player_index']
    
    for i, past_round in enumerate(history):
        if past_round_cooperations[i] >= m:
            my_coop_in_threshold_met.append(past_round[my_index] == 'C')
    
    # Decision logic:
    if round_number == r:
        # Last round: always defect
        return 'D'
    
    # Check if threshold can be met without me
    # Estimate cooperators excluding self assuming I defect
    estimated_without_self = avg_cooperators - (1 if history[-1][my_index] == 'C' else 0)
    
    if estimated_without_self >= m:
        # Threshold can be met without me, so defect to maximize payoff
        return 'D'
    elif estimated_without_self == m - 1:
        # Threshold can only be met if I cooperate, so cooperate to get rewards
        return 'C'
    else:
        # Threshold unlikely to be met, defect to avoid loss
        return 'D'
```

---

### Summary

- **Round 1:** Defect to test group behavior.
- **Middle rounds:** Cooperate only if strictly needed to meet threshold; else defect to free-ride.
- **Punish cooperative players who get exploited by defecting maximally.**
- **Last round:** Defect always to maximize final payoff with no repercussions.
  
This aggressive strategy prioritizes maximizing your own gains by exploiting cooperators, forcing others to bear cooperation costs and only cooperating when absolutely necessary. It leverages information from previous rounds to switch efficiently between exploitation and minimal forced cooperation.

---

Let me know if you want a variant that is more cunning or risk-averse!
'''

description_AGGRESSIVE_14 = '''
**Aggressive Strategy for the Collective Risk Dilemma**

---

### Strategic Rationale

This strategy takes an aggressively self-interested stance aiming to maximize **individual payoff** possibly at the expense of collective welfare, leveraging the threat of punishment and opportunistic exploitation of cooperators.

- It prioritizes defecting to gain private payoffs.
- It only cooperates minimally to ensure the threshold \( m \) is occasionally met if it benefits or to punish others by withholding cooperation otherwise.
- It actively punishes players who defect against it by retaliating defectively.
- It uses aggressive exploitation: if cooperation threshold is reached and others cooperate, defect to get maximum payoff without contributing.
- It gains advantage by trying to be a "free rider" once others cooperate sufficiently.
  
---

### Key Points about Payoffs (Reminder)

- Cooperate cost = 1 unit (lose 1 endowment)
- Defect retains endowment = 1
- If \( \geq m \) cooperators: everyone gains \( k \) (risk averted bonus)
- If fewer than \( m \) cooperate: no bonus, defectors get 1, cooperators get 0 (because they contributed 1).

---

### Aggressive Strategy Description

---

#### Initial Round (t=1)
- **Defect**: No past info, no reason to risk costly cooperation. Defect to preserve endowment and see others' tendencies.

---

#### General Round (2 ≤ t < r)

- Calculate cooperation level of all players in previous round \( t-1 \):
  - \( C_{count} = \) number of cooperators in round \( t-1 \)
  - Determine if threshold \( m \) was met last round.
  
- Observe *your own* last round action and payoff:

  1. **If last round payoff was high (≥ \(1 + k\)) due to others cooperating sufficiently:**

     - *Aggressively defect* this round: 
       - Try to free ride on others' cooperation.
       - Why? You get the highest payoff defecting when others cooperate.
  
  2. **If last round payoff was low (< \(1 + k \)) due to insufficient cooperation:**

     - **Punish by defecting again.**
     - Do **not** cooperate voluntarily; to punish cooperators who don't help.
  
  3. **If last round you were one of the cooperators but payoff was low (meaning threshold unmet):**

     - Keep defecting aggressively (never cooperate again this game).
     - Reduce wasteful loss from contributing without threshold met.
  
  4. **If others cooperated and threshold met but you defected and got big payoff:**

     - Defect again (exploit).
  
- In short, **after round 1**, defect always unless you want to sporadically cooperate only to try to hit the threshold exactly when needed.

---

#### Exception: Attempt minimal cooperation in some key rounds?

- To keep some potential threshold met, cooperate **once every several rounds (e.g., every ceil(r/10) rounds) only if you estimate others also cooperating**.

- This is a soft bluff:
  - Check if in last round \( C_{count} \) was close to but less than \( m \); if yes,
  - Switch to cooperate this round to try pushing threshold met **only if**:

    - You can benefit (get \( k \)),
    - Others seem to cooperate regularly.

- Otherwise, continue defecting aggressively.

---

#### Last Round (t = r)

- Always **defect** in last round:

  - No future punishment possible.
  - Maximizing final payoff with no incentive to cooperate.

---

### Summary of Decision Rules (Pseudocode)

```
for each round t in 1..r:

  if t == 1:
    action = Defect  # start aggressively

  else if t == r:
    action = Defect  # always defect last round to maximize payoff

  else:
    previous_actions = actions of all players at round t-1
    previous_payoffs = payoffs of all players at round t-1
    c_count = count of cooperators in previous_actions
    threshold_met = (c_count >= m)
    my_last_action = my action at round t-1
    my_last_payoff = my payoff at round t-1

    if threshold_met:
      if my_last_action == Defect:
        # Exploit others' cooperation
        action = Defect

      else:  # I cooperated last round
        # Free ride or defect next round to avoid cost
        action = Defect

    else:  # threshold NOT met last round
      if my_last_action == Cooperate:
        # Lost payoff, no incentive to cooperate again
        action = Defect

      else:  # I defected last round
        # Punish others by defecting again (no cooperation)
        action = Defect

    # Occasionally cooperate to attempt threshold achievement if near threshold last round
    if (t % ceil(r/10) == 0):
      if c_count == m-1:
        # attempt to meet threshold
        action = Cooperate

```

---

### Behavior Notes

- **Highly aggressive:** Defect nearly always, only minimal/cooperative attempts spaced out and only when marginally beneficial.
- **Extreme last round defect:** No incentive to cooperate at end.
- **Punishment and exploitation:** Automatically retaliate defectors, try to free ride on coop players repeatedly.
- **No forgiveness:** Once defecting, never switch back to cooperation except rare threshold push rounds.
- **No communication or signaling, but uses visible patterns of others to time rare cooperation attempts.**

---

### Overall Intuition

You act like a tough free-rider bandit who exploits cooperators when possible, punishes unsuccessful cooperation by defecting repeatedly, and never wastes endowment for futile cooperation. You try just enough cooperation to sometimes tip the group to the reward, but only when it is barely beneficial.

This aggressive self-maximizing approach risks collective failure often but achieves the best individual returns when others are naive cooperators.

---

If you want I can provide variants or further clarifications.
'''

description_AGGRESSIVE_15 = '''
Here is an aggressive and strategic plan designed to maximize your payoffs in the Collective Risk Dilemma. The core idea is to exploit cooperators while avoiding being exploited yourself, pushing other players to cooperate enough for you to benefit without costly investments on your part.

---

## Aggressive Strategy Description: "Opportunistic Exploiter"

### Rationale

- **Aggressiveness:** Prefer to defect to maximize private payoff.
- **Exploitation:** Allow others to cooperate enough to reach threshold m so you get the reward without paying cost.
- **Pressure:** Defect in early rounds to see who tries to cooperate, then decide dynamically.
- **Punishment:** Reduce or stop cooperating if threshold is not met to pressure others.
- **Last round:** Defect always to maximize final payoff, no future rounds to incentivize cooperation.

---

### Decision Rules (per round t)

#### Round 1 (no history)
- Defect unconditionally.
  - Reason: Test the water, no prior information, start aggressive.

#### Subsequent Rounds (t = 2 ... r-1)
- Observe previous round’s cooperation count: CoopCount_{t-1}
- If CoopCount_{t-1} ≥ m
  - Defect (free ride on others’ cooperation).
- Else (threshold missed last round)
  - Cooperate *once* to try to push group to threshold.
  - If other players respond with cooperation next round, revert to defecting.
  - If not, continue defecting.
  
- To achieve this, keep a simple state variable `CoopAttempted` initialized to false:
  - If threshold missed last round and CoopAttempted == false:
    - Cooperate this round, set CoopAttempted = true
  - Else:
    - Defect.

#### Final Round (t = r)
- Defect unconditionally.
  - Reason: No incentive to invest cooperation on last round.

---

### Edge Cases

- **If threshold m is very high (close to n):** Cooperation unlikely; always defect.
- **If threshold m is low (close to 1):** Same logic applies, still defect first and exploit.
- **If cooperation is persistent (everyone always cooperates):** Never cooperate; always defect and get high payoffs.
- **If no cooperation ever happens:** Try cooperating once after a failed round to test, then defect forever.
- **If exactly m-1 cooperators show up repeatedly:** Try cooperating once to push threshold, else defect.

---

### Pseudocode

```python
# Parameters: n, r, m, k
# Variables:
#   CoopAttempted: bool flag, initially False

CoopAttempted = False

for t in range(1, r + 1):
    if t == 1:
        # First round: defect to be aggressive
        action = 'D'

    elif t == r:
        # Last round: defect unconditionally
        action = 'D'

    else:
        # For rounds 2 to r-1:
        prev_coop_count = count_cooperators_in_round(t-1)

        if prev_coop_count >= m:
            # Threshold met last round => free ride
            action = 'D'
            CoopAttempted = False  # Reset coop attempt after success

        else:
            # Threshold missed last round
            if not CoopAttempted:
                # Attempt cooperation once to try push threshold
                action = 'C'
                CoopAttempted = True
            else:
                # Already tried once, now defect
                action = 'D'

    yield action  # output action this round
```

---

### Summary

- Defect always the first round and last round.
- Defect when threshold was met last round, free riding on cooperators.
- If threshold was not met last round, cooperate once to try push group to threshold.
- If cooperation attempt does not lead to threshold being met, fall back to defecting.
- This will pressure others to cooperate and let you maximize payoff by defection.
- This is clearly aggressive: you do not cooperate unless forced and punish failures lightly.
  
---

This strategy balances exploitation and minimal cooperation attempts for leverage, exploiting the repeated structure but always putting yourself first. It uses simple memory and is robust against opponents that cooperate or defect consistently.
'''

description_AGGRESSIVE_16 = '''
**Aggressive Strategy for the Collective Risk Dilemma**

---

### Strategic Intuition

- The aggressive mindset here is to maximize your personal payoff even at the expense of others, leveraging others' cooperation whenever possible.
- Since defectors earn more than cooperators if the threshold is met (see example 3: defectors get 3 and cooperators get 2 when threshold is met), the strategy aims to:
  - Promote others to cooperate (without cooperating yourself selfishly)
  - Defect as often as possible to exploit cooperating players
- Use early-round probing to identify potential cooperators, and then defect confidently to earn high payoffs.
- In the last round, defect regardless, because cooperation cannot be incentivized further via future punishment or reward.

---

### Detailed Decision Rules

**Parameters:**
- `n, r, m, k` as given
- Maintain history of all players’ actions each past round to infer cooperators

---

**Round 1 (Initialization & Probing):**

- **Cooperate** in the first round (C).
  - Why? By cooperating first, appear "nice," inducing others to cooperate in the next rounds to meet the threshold.
  - This sacrifices one round of personal gain but sets the stage for exploitation.

---

**Rounds 2 to r-1 (Exploit or punish):**

- Analyze previous round:
  - Count number of cooperators last round: `C_prev`
  - Identify if total cooperators met threshold `m`
- If **threshold met last round (C_prev ≥ m)**:
  - Defect (D).
  - Aggressively exploit cooperating players to gain maximum payoff (they sacrifice for collective reward, you reap benefit by defecting).
- Else if **threshold not met last round (C_prev < m)**:
  - **Cooperate (C)** to help push threshold so others can be exploited.
  - Aggressively induce others to cooperate again by showing cooperation yourself.
- Exception:
  - If cooperating last round (round t-1) was not followed by threshold met (i.e. others didn't cooperate with you), switch fully to defect mode to avoid being suckered.  
  - This means:
    - If you cooperated last round and threshold not met, count it as failed attempt.
    - On second failure in a row to meet threshold after cooperating, stay defect permanently until last round.

---

**Round r (Last round):**

- Always **Defect (D)**.
- No incentive to cooperate because no future rounds exist to reward or punish others.

---

### Handling Edge Cases

- **If threshold `m` is very high or cooperation rarely met:**
  - Start defecting sooner, i.e. after detecting no cooperation payoff for 2 consecutive rounds.
- **If n is small or `m` close to `n`, cooperation is hard:**
  - Be more cautious about cooperating multiple times; rely on early probing and then defect.
- **If opponents always defect:**
  - Keep defecting; never waste resources cooperating when threshold won't be met.
- **If opponents always cooperate:**
  - Exploit as much as possible by defecting whenever threshold met.

---

### Pseudocode Summary

```python
initialize:
    cooperators_last_round = None
    consecutive_failures = 0
    action_history = []  # list of tuples (actions per player) per round

for t in range(1, r+1):
    if t == 1:
        # Round 1: Cooperate to probe
        action = 'C'
        record action
        continue

    # count cooperators last round
    cooperators_last_round = count_C_in_round(t-1)
    threshold_met_last_round = (cooperators_last_round >= m)
    
    last_action = my_action(t-1)
    
    if t == r:
        # Last round: always defect
        action = 'D'
        record action
        continue

    if threshold_met_last_round:
        # Exploit cooperators
        action = 'D'
        consecutive_failures = 0  # reset failures since threshold met
    else:
        # Threshold not met
        if last_action == 'C':
            consecutive_failures += 1
        else:
            consecutive_failures = 0

        if consecutive_failures >= 2:
            # Stop cooperating if cooperation fails twice in a row
            action = 'D'
        else:
            action = 'C'
    
    record action
```

---

### Summary

| Round      | Condition                     | Action  | Reason                                    |
|------------|-------------------------------|---------|-------------------------------------------|
| 1          | Always                       | Cooperate (C) | Probe and induce cooperation              |
| 2..r-1     | If threshold met last round  | Defect (D)   | Exploit cooperating players                |
| 2..r-1     | Else if last cooperation attempt failed twice | Defect (D)   | Avoid being suckered                       |
| 2..r-1     | Else                        | Cooperate (C) | Encourage cooperation                      |
| r (last)   | Always                      | Defect (D)   | No future incentive to cooperate           |

---

### Strategic Notes

- Starts “nice” but aggressively switches to exploit mode.
- Punishes failure to meet thresholds by refusing to cooperate.
- Ends by defecting to maximize last-round payoffs.
- Maximizes personal gain through calculated cooperation to induce others to cooperate first.
- Aggressively leverages others' cooperation to defect and reap larger payoffs.

This aggressive strategy balances initial investment with ruthless exploitation under repeated interaction.
'''

description_AGGRESSIVE_17 = '''
Below is an aggressive strategy designed for the Collective Risk Dilemma that aims to maximize individual payoff by exploiting cooperative players while still ensuring enough cooperators to trigger the reward when it benefits the player.

---

### Strategy Name: **Opportunistic Exploiter**

#### Core Idea:
- Defect aggressively to maximize personal payoffs whenever it is safe to do so.
- Only cooperate if cooperation is strictly necessary to guarantee the collective threshold is met **and** doing so avoids losing the big reward.
- Exploit cooperators by defecting when the threshold will be met anyway.
- Avoid being the sucker who cooperates when insufficient others do.
- Use full information from past rounds to estimate the minimal group cooperation.

---

## Decision Rules

### Round 1 (No history available):
- Cooperate only if you estimate that the other players will largely defect (which is the default assumption in an aggressive setting).
- Since you have no info, **defect** to maximize immediate payoff and avoid being taken advantage of.
- *Rationale*: Without signals, cooperate only if you expect others to cooperate enough, which is unlikely. Defecting is the safe default.

---

### Rounds 2 to r-1 (Intermediate rounds):

At round t, given the full history of actions from rounds 1 to t-1:

1. **Estimate others' cooperation tendency:**

   - Calculate the average number of cooperators (including self if you cooperated) in past rounds.
   - Let `avgCoop = (sum of number of cooperators in past rounds) / (t-1)`

2. **Predict number of cooperators this round:**

   - Assume others maintain similar behavior.
   - Predict `predictedCoopOthers = avgCoop - (1 if you cooperated previously else 0)`

3. **Decision to cooperate or defect:**

   - If `predictedCoopOthers + (your potential cooperation = 1)` < `m`, THEN:
     - You **must cooperate** to try to reach the threshold.
   - Else
     - **Defect aggressively** to pocket the private payoff + reward if threshold met.

*Tie-breaker:* If prediction exactly equals m-1 (threshold not yet guaranteed without your cooperation), cooperate to remain a pivotal player ensuring the reward.

---

### Round r (Last round):

- Since no future punishment or reward can be expected, **defect always** to maximize the last-round payoff.
- Rationale: No incentive to cooperate at last round; cooperate only when future rounds incentivize reciprocal cooperation or punishment.

---

## Edge cases & Additional Specifications

- **If in any previous round, the threshold was met without your cooperation:**
  - Defect aggressively in the current round, because cooperation is not needed to secure the reward.
  
- **If the threshold was never met in past rounds, and cooperation is low overall:**
  - Attempt to cooperate only if you can be pivotal to reach the threshold.
  - Otherwise, defect to maximize payoff and not incur guaranteed cost of cooperating without reward.

- **If you observe from history that others tend to cooperate highly (almost always), exploit by defecting more often.**

---

## Pseudocode

```python
def decide_action(round_t, history, parameters):
    # parameters: n, r, m, k
    # history: list of dicts: [{'cooperators': int, 'actions': list of len n}]
    n, r, m, k = parameters['n'], parameters['r'], parameters['m'], parameters['k']

    if round_t == 1:
        # No info, defect aggressively
        return 'D'

    if round_t == r:
        # Last round, defect to maximize payoff
        return 'D'

    # Calculate average cooperators from past rounds
    total_coop = sum(h['cooperators'] for h in history)
    avg_coop = total_coop / (round_t - 1)

    # Detect how many times you cooperated previously
    your_previous_coops = sum(1 for h in history if h['actions'][your_index] == 'C')
    avg_coop_others = avg_coop - (your_previous_coops / (round_t - 1))

    # Predict cooperation this round without your cooperation
    predicted_coop_others = avg_coop_others  # Expected other cooperators

    # If even with your cooperation threshold not met, defect; else cooperate
    if predicted_coop_others + 1 < m:
        # Needed cooperation to hit threshold, cooperate
        return 'C'

    # Else safe to defect and still get reward
    return 'D'
```

---

## Summary of the Aggressive Mindset

- **Maximize short-term gain by defecting as much as possible.**
- **Only cooperate when strictly necessary to avoid losing the threshold reward.**
- **Never cooperate "just to be nice" or on hope alone—cooperate only if your cooperation is pivotal.**
- **Exploit predictable cooperators by defecting when threshold still meets.**
- **Last round, defect always—no incentive to be "nice."**

---

This strategy balances opportunistic defecting with minimal pivotal cooperation, aggressively exploiting the structure and opponents' tendencies for high personal gain in repeated play.
'''

description_AGGRESSIVE_18 = '''
Below is a designed **aggressive strategy** for the Collective Risk Dilemma game as specified:

---

## Strategic Intuition:  
**Aggressive mindset:** push to maximize personal payoff, even at some collective risk. Exploit cooperative players if possible, but induce minimal cooperation to get the reward k when it benefits you.

---

# 1. Decision Rules

### Overview:  
- The aggressor defects by default to keep the personal endowment plus any community reward produced by others.
- But will cooperate only if strictly needed to trigger the reward **to avoid losing out**.
- Will never cooperate if the number of inferred cooperators without self is already sufficient to secure the reward.
- Use observed player behaviors (past rounds) to estimate how many others will cooperate, and cooperate only if strictly necessary.
- On the last round, defect no matter what to maximize personal gain (cannot punish or incentivize future cooperation).

### Definitions:  
- Let `C_t` = number of cooperators (including self if cooperating) in round t.
- Let `C_{-i,t}` = number of cooperators excluding self in round t (i.e., inferred cooperators count).
- Threshold to get reward: `m` cooperators minimum.

### Round 1 (no history):  
- Assume worst case cooperation from others = 0.
- Since no info, **defect** (gain 1) and observe others’ first-round behavior.

### Round 2 to r-1 (intermediate rounds):  
- Based on rounds 1 to t-1, estimate expected number of other cooperators (`E[C_{-i}]`).
- If `E[C_{-i}]` ≥ m, defect to get 1 + k payoff.
- Else if `E[C_{-i}]` = m - 1, cooperate to get 0 + k payoff instead of 1 (no reward if defect, payoff too low compared to cooperating).
- Else defect (no reward likely, better to keep endowment).

### Last round (t = r):  
- Always defect. No incentive to cooperate since no future to leverage.

---

# 2. Edge Cases Handling

- **If in any round you observe m or more cooperators excluding self**, always defect that round to exploit cooperators.
- **If your cooperation would push the total cooperators to m exactly**, cooperate only if not last round.
- If the number of observed cooperators in past rounds fluctuates, use a moving average or median of `C_{-i}` across rounds to estimate `E[C_{-i}]`.
- If for some reason no data from previous rounds (e.g., your first round), defect.
- If total number of players, `n`, is very close to `m` (e.g., `m = n - 1`), be extra aggressive: cooperate only if absolutely necessary.
  
---

# 3. Pseudocode

```python
# Parameters: n, r, m, k (given)

# Variables to track:
# history = list of dicts per round { 'cooperators': int, 'player_coop': bool }
# Initially empty

def estimate_expected_others_coop(history):
    # Calculate average cooperators excluding self over past rounds
    if not history:
        return 0
    total = 0
    for h in history:
        # exclude self coop from total cooperators before averaging
        others = h['cooperators'] - (1 if h['player_coop'] else 0)
        total += others
    return total / len(history)

def aggressive_strategy(t, history):
    # t: current round (1-based)
    # history: list of previous rounds' actions and cooperators
    
    # Last round: always defect
    if t == r:
        return 'D'
    
    expected_others = estimate_expected_others_coop(history)
    
    # If expected others are enough to meet threshold m, defect (free ride)
    if expected_others >= m:
        return 'D'
    
    # If expected others are just below threshold by 1 and cooperating this round can push over threshold
    if expected_others == m - 1:
        # Cooperate to trigger reward and gain k instead of nothing
        return 'C'
    
    # Otherwise defect by default
    return 'D'
```

---

# Summary

| Round       | Action                                   | Rationale                             |
|-------------|------------------------------------------|-------------------------------------|
| 1           | Defect                                  | No info, maximize immediate gain    |
| Intermediate| Cooperate only if expected others = m-1 | Trigger reward when borderline      |
|             | Defect if expected others ≥ m or < m-1  | Exploit cooperators or no reward    |
| Last round  | Defect                                  | No future rounds to incentivize coop|

---

This strategy is **aggressive** because:  
- It mostly defects to maximize personal gain per round.  
- It avoids wasted cooperation if reward can be got without self contribution.  
- It exploits cooperative players by defecting when enough others cooperate.  
- Only cooperates reluctantly, and only to "nudge" cooperation over threshold when it strictly improves payoff.  
- Defects on last round to maximize personal payout regardless of group outcome.

---

Let me know if you want a more nuanced variant (e.g., incorporating punishment phases or trust-building), but this aligns best with *purely aggressive* play given the game's structure and info constraints.
'''

description_AGGRESSIVE_19 = '''
Here is an **aggressive strategy** tailored for the Collective Risk Dilemma as specified:

---

### Core Idea of the Strategy

- **Aggressive mindset:** Maximize individual payoff by exploiting cooperative players, forcing others to bear the cost of cooperation while defecting as much as possible.
- **Exploit threshold:** Cooperate **only when necessary** to ensure the threshold *m* is met (to get the reward), but **never more than minimally required**.
- **Punish free riders:** If others defect excessively risking the threshold, briefly cooperate to trigger the group reward, but always look for opportunity to defect and still gain payoff.
- **Take control:** Assume responsibility for meeting threshold *m* when others do not cooperate enough.
- **Exploit endgame:** Defect aggressively in final rounds to extract maximal payoff, as threat of retaliation no longer exists.

---

### Formalized Decision Rules

#### Variables to track per round *t*:

- Observe how many cooperated last round: `num_C_last`
- Observed actions this round from players to this point: `num_C_current`

---

#### First round (t=1):

- **Defect**, since cooperating in first round exposes you to exploitation without guaranteed reciprocation.

```pseudocode
if t == 1:
    action = D
```

---

#### Intermediate rounds (1 < t < r):

- Compute the number of cooperators last round `num_C_last`.
- If `num_C_last >= m` (threshold was met last round):
  - Defect this round to maximize private payoff, expecting others to cover the cooperation needed.
- Else (threshold was **not** met last round):
  - Cooperate **if necessary** to meet threshold in current round:
    - If `num_C_current < m - 1` (counting only others so far), cooperate to try to meet threshold.
    - If threshold can be met without you cooperating, defect.

```pseudocode
if 1 < t < r:
    if num_C_last >= m:
        action = D
    else:
        if num_C_current < m - 1:
            action = C
        else:
            action = D
```

---

#### Last round (t = r):

- **Always defect**, as no future retaliation is possible.
- Accept risk of threshold not being met because maximizing immediate gain is the objective.

```pseudocode
if t == r:
    action = D
```

---

### Additional notes

- **Ties at threshold**: When deciding whether to cooperate, exactly `m-1` other cooperators does not guarantee reward without you cooperating. So cooperate if `num_C_current < m - 1`. If exactly `m-1` others cooperating so far, defect and try to free ride.
- **Observing others' actions**: Since moves are simultaneous, you only have info about previous rounds. So to estimate `num_C_current`, you rely on previous rounds cooperation count (`num_C_last`). Given this, the phase logic prioritizes defecting when the group appears to meet threshold frequently.
- **Aggressive exploitation**: Leverage rounds where threshold is met by others, to defect and earn payoff of `(1 + k) > 1` with no cost.
- **Coordination without communication**: Use others’ past actions as signals. Since no communication, you assume others will also try to maximize payoffs, so you behave aggressively and opportunistically.

---

### Summary in compact pseudocode

```pseudocode
for round t in 1...r:
    if t == 1:
        action = D
    elif t == r:
        action = D
    else:  # 1 < t < r
        if num_C_last >= m:
            # Threshold met last round, exploit cooperators
            action = D
        else:
            # Threshold not met last round, try to rescue threshold if needed
            if num_C_current < m - 1:  
                action = C
            else:
                action = D
    execute(action)
```

---

### Rationale on aggressiveness

- **Never “waste” cooperation unless threshold is missed**.
- **Exploit rounds when threshold is reached by others**.
- **In final round, defect no matter what**.
- **Burden of cooperation falls on others except when threshold missed**.
- This maximizes individual payoff aggressively by minimizing costs and maximizing benefits from others' cooperation.

---

If you want, I can also provide a detailed example walk-through or reasoning on expected payoffs given this strategy.
'''

description_AGGRESSIVE_20 = '''
**Goal of aggressive strategy:**  
Maximize own payoff by exploiting cooperators whenever possible, while minimizing own losses when cooperation seems unlikely. Aggressiveness here means pushing for defection to exploit cooperators, but also keeping a pragmatic eye on the threshold to avoid catastrophic losses if the group fails.

---

### Intuition Behind the Strategy

- In rounds where others are cooperating enough (≥ m), defecting yields the highest individual payoff (1 + k), better than cooperating (0 + k).
- In rounds where cooperation is insufficient (< m), cooperating yields payoff 0 (due to cost), defecting yields payoff 1.
- Since it's repeated, you can try to track which players appear to cooperate regularly and exploit that tendency.
- Given no communication, but perfect info on past plays, monitor cooperation level and respond aggressively with defection when it benefits you.
- On last round, it's purely about immediate payoff — no future consequences, so defect if cooperation is likely to be enough, cooperate only if cooperation is very unlikely.

---

### Detailed Strategy Description

| Round        | Decision Logic                                                                                        
|--------------|----------------------------------------------------------------------------------------------------|
| First round  | Defect (D) — since no info on others, assume cooperation will be too risky and exploit.
| Rounds 2..r-1 |  
| - If last round's cooperation count ≥ m (threshold met) | Defect (exploit the group reward, gain 1 + k).  
| - Else (threshold not met last round)                   | Cooperate if it seems probable that enough players will cooperate this round (see prediction heuristic below), else defect to save endowment.  
| Last round (round r) |  
| - If predicted cooperation count ≥ m                  | Defect to maximize payoff (1 + k).  
| - Else                                                | Defect (cooperation costly with no reward if threshold unmet, so prefer defect).

---

### Prediction Heuristic for rounds 2..r-1

- Track the number of cooperators in the last round (say, \( m_{last} \)).
- To predict the current round's cooperation count:
  - Assume that players keep their last action (a simple naive prediction).
  - If \( m_{last} \geq m \), assume cooperation remains high; defect to exploit.
  - If \( m_{last} < m \), assume cooperation remains low; cooperate only if this player can tip the balance by cooperating (i.e., \( m_{last} = m-1 \)), else defect.

---

### Summary of Aggressive Mindset

- Always prioritize defection to exploit cooperators when threshold is likely met.
- Only cooperate when defecting risks losing entire group reward (threshold unmet) *and* your cooperation would be pivotal.
- First round defaults to defection (no info).
- Last round always defect (no future punishment).

---

### Pseudocode

```python
def aggressive_strategy(round_num, total_rounds, n, m, k, history):
    """
    history: List of tuples for previous rounds:
        [(actions_round_1), (actions_round_2), ..., (actions_round_num-1)]
        each actions_round_i: list of length n with 'C' or 'D'
    """

    def cooperation_count(actions):
        return sum(1 for a in actions if a == 'C')

    # Round 1: defect
    if round_num == 1:
        return 'D'

    last_actions = history[-1]
    last_cooperators = cooperation_count(last_actions)

    # Last round logic
    if round_num == total_rounds:
        # Predict if cooperation threshold will be met (assume same as last round)
        predicted_coop = last_cooperators
        if predicted_coop >= m:
            return 'D'  # defect and exploit reward
        else:
            return 'D'  # defect to retain endowment

    # Intermediate rounds logic
    if last_cooperators >= m:
        # Cooperation successful last round -> defect and exploit
        return 'D'
    else:
        # Cooperation unsuccessful last round
        # Cooperate only if we can swing threshold
        # i.e., if last_cooperators == m-1, your cooperation may help
        if last_cooperators == m - 1:
            return 'C'
        else:
            # Too few cooperators, defect to avoid contributing for no reward
            return 'D'
```

---

### Edge Cases

- If \( m=1 \), i.e., 1 cooperator needed: strategy adapts gracefully as you defect first round, then exploit if others cooperate.
- If near the last round \( r-1 \), still applies as intermediate round.
- If cooperation fluctuates wildly, the heuristic still defaults to exploitation or cautious cooperation when pivotal.
- Unknown players (independent LLMs) might behave randomly or conditionally; by playing aggressive defect mostly, you avoid being exploited and capture max payoff from cooperators.

---

### Summary

This strategy is:

- **Aggressive:** seeking to defect whenever cooperation threshold met to maximize personal gain.
- **Exploitive:** willing to cooperate only when cooperating may be pivotal to achieving the group reward, minimizing own contribution but benefiting from others.
- **Simple & reactive:** uses only previous round info, no bluffing or signaling.
- **Last round defect:** since no future reward or punishment is possible.

This aggressive balancing act optimizes personal payoff in a repeated collective-risk dilemma against unknown opponents.
'''

description_AGGRESSIVE_21 = '''
Below is an aggressive strategy tailored for the Collective Risk Dilemma as specified. The key idea is that aggression here means:

- Prioritize maximizing your own payoff each round, even at the expense of group outcomes.
- Exploit cooperation of others to defect and get higher payoff.
- Defect when unsure or when cooperating doesn’t have immediate clear benefit.
- Use early rounds to probe opponents aggressively by defecting.
- In later rounds, leverage observed cooperation patterns aggressively to maximize your gains.

---

# Aggressive Strategy Description: "Opportunistic Defector with Exploit & Punish"

---

### Intuition

- **First round:** Defect to test if others will cooperate — your defection yields higher payoff if enough others cooperate.
- **Subsequent rounds:** Track how many cooperators appeared in previous round.
  - If cooperation threshold was met and enough cooperators showed up, keep defecting to exploit them.
  - If threshold was missed, cooperate once to try to “tip” the scale, then revert to defecting.
- **Last round:** Defect outright. No future rounds to be punished.

This strategy aggressively seeks to maximize individual payoffs via defection while occasionally cooperating only when it can swing the round’s outcome to get the reward bonus or punish opponents who risk cooperation.

---

### Variables to Track Per Round

- `prevCooperators`: number of cooperators in the previous round
- `prevRoundThresholdMet`: boolean indicating if ≥ m players cooperated last round
- `currentRound`: the round number (1 to r)

---

### Decision Rules per Round

**Round 1 (first round):**

- Defect (D)
  - Reason: Aggressively earn private payoff while others may cooperate.
  - You gain payoff 1 + reward (if threshold met), possibly higher than cooperators.

**Rounds 2 to r-1:**

- If `prevRoundThresholdMet` is `true`:  
  - Defect (D) to exploit cooperators who paid the cost c=1.
- Else (threshold not met in previous round):
  - If `prevCooperators == m - 1`:  
    - Cooperate (C) to push current round over threshold to get collective reward.
  - Else:  
    - Defect (D)

  Explanation:
  - Cooperate only when you can be the marginal cooperator tipping the scale to get the reward.
  - Otherwise, keep defecting to free-ride or to punish insufficient cooperation.

**Round r (last round):**

- Defect (D)
  - No incentive to cooperate since no future retaliation or cooperation is expected.

---

### Additional Notes

- No forgiveness for defectors; cooperation is only instrumental.
- Cooperation is a tactical move to unlock the reward bonus for yourself and punish hopeful cooperators.
- This strategy can lead to cycles of failed cooperation except when your cooperation makes a swing difference.
- Aggressive mindset: always seek maximum personal payoff, exploiting cooperative others, and never giving away cost unless it pays off immediately.

---

### Pseudocode

```python
def aggressive_strategy(currentRound, r, m, prevCooperators, prevRoundThresholdMet):
    
    if currentRound == 1:
        # Opening: Exploit cooperators, defect
        return 'D'
    
    elif currentRound == r:
        # Last round always defect
        return 'D'
    
    else:
        # Intermediate rounds
        if prevRoundThresholdMet:
            # Exploit cooperators by defecting
            return 'D'
        
        else:
            # No reward last round
            if prevCooperators == m - 1:
                # You can be the marginal cooperator tipping balance
                return 'C'
            else:
                # Defect otherwise
                return 'D'
```

---

### Summary

- **First round:** Defect
- **Last round:** Defect
- **Middle rounds:**  
  - Defect if reward was realized last round (exploit)  
  - Otherwise, cooperate only if you can push cooperators to threshold  
  - Else defect

---

This strategy aggressively maximizes your own standing by defecting wherever possible, only cooperating when it directly benefits you by securing the collective reward that others alone cannot secure. It applies selective and opportunistic cooperation as a tool, not a principle.
'''

description_AGGRESSIVE_22 = '''
Certainly. Below is a design of an **aggressive** strategy for the Collective Risk Dilemma that aims to maximize individual payoffs by exploiting cooperators while avoiding unnecessary cooperation itself, yet exploiting the game's iterative nature to enforce occasional cooperation only when needed to reap the risk avoidance reward. 

---

## Strategy Name: **Opportunistic Exploiter**

### Core Idea:
- **Defect by default and "free-ride" on cooperators whenever enough exist to pass the threshold.**
- **Only cooperate occasionally when absolutely necessary to push cooperation count to reach the threshold, but never more than minimally required.**
- **Avoid being the sucker who always cooperates.**
- **In later rounds, ramp up defection aggressively to maximize immediate gains at endgame.**

---

### Parameters needed (from game definition):
- `n`: number of players
- `r`: total rounds
- `m`: threshold minimum cooperators
- `k`: reward multiplier

---

### High-Level Decision Rules:

#### 1. **First Round**
- Defect: Start aggressive and test others by defecting, hoping some will cooperate and yield you the reward without your contribution.

#### 2. **Subsequent Rounds (t=2 to r-1)**
- Observe last round's cooperation count `C_last`.
- If `C_last >= m`, then defect again (free-ride on others’ cooperation).
- If `C_last == m-1`:
  - Cooperate **this round** to push the group to threshold, ensuring risk averted and get reward.
  - This is the only "cooperation trigger" — minimal cooperation but only when it ensures threshold is met exactly.
- If `C_last < m-1`:
  - Defect, as cooperating is too costly and threshold unlikely met.
  - The reward is unlikely, so no reason to sacrifice endowment.

#### 3. **Last Round (t = r)**
- Defect aggressively to maximize own payoff regardless of threshold, as no future punishment or retaliation possible.

---

### Edge Cases:

- If no information is available about others’ previous round (e.g., first round), defect.
- If tracking cooperation count is impossible (e.g., no observability), always defect (as aggressive baseline).
- If in any round cooperation is needed to reach threshold, cooperate exactly in one round and never more.
- Never cooperate more than once in a row except when forced.

---

### Summary:
- **Mostly defect**, only cooperate minimally to secure threshold when it's one short.
- Leveraging others’ cooperative behavior to maximize payoff.
- Ending game with full defection to extract last round maximum.

---

### Pseudocode

```python
initialize:
  rounds = r
  threshold = m
  cooperators_needed = threshold
  last_cooperation_count = None  # Unknown at first

for t in range(1, rounds + 1):  # rounds 1 to r
    if t == 1:
        # First round: never cooperate (start aggressive)
        action = 'D'
    elif t == rounds:
        # Last round: defect aggressively to maximize immediate payoff
        action = 'D'
    else:
        # Intermediate rounds:
        # Use last round's cooperation count to decide
        if last_cooperation_count is None:
            # Defensive fallback, defect if no info
            action = 'D'
        else:
            if last_cooperation_count >= threshold:
                # Enough cooperators last round; free-ride by defecting
                action = 'D'
            elif last_cooperation_count == threshold - 1:
                # One less than threshold; cooperate to push group to threshold
                action = 'C'
            else:
                # Threshold unlikely to be met; defect to save endowment
                action = 'D'

    # After round ends (not part of player's selection but observation side):
    # last_cooperation_count = count_cooperators_in_last_round()

    output(action)
```

---

### Explanation of Aggression

- **Always prefer to defect** (maximize private payoff).
- Only cooperate when the group is exactly one short of threshold to "exploit" cooperators by minimally contributing to unlock the reward.
- Avoid giving others signals or patterns of cooperation to encourage free-riding behavior.
- On final round, defect fully to secure immediate payoffs without fear of punishment.
- Pressure others to carry the burden and capitalize on their cooperation.

---

This strategy aligns clearly with an aggressive, self-maximizing agent that leverages others' cooperation while minimizing own cost and maximizing payoff exploitatively.
'''

description_AGGRESSIVE_23 = '''
**Aggressive Strategy for Collective Risk Dilemma (CRD)**

---

### Intuition behind the aggressive approach

The aggressive mindset here aims to maximize *individual payoffs* even at the expense of the collective group welfare or fairness. This means:

- Prefer defecting to keep the endowment (high immediate payoff: 1)
- Only cooperate strategically when it guarantees a large bonus (k), but minimize own cooperation cost
- Exploit others' cooperation where possible (free riding)
- Use the repeated structure to "punish" cooperators by defecting often and forcing others into cooperation to reach threshold (letting others pay the cost)

---

### Parameters:

- n = number of players
- r = rounds
- m = minimum cooperators needed
- k = reward factor

---

### Key observations to exploit aggressively:

- When exactly m players cooperate (including yourself), everyone gets payoffs +k.
- If you defect while the others cooperate enough, you get payoff 1 + k, which is better than cooperating (0 + k).
- If less than m cooperate, no reward, so cooperating incurs loss with zero reward.
- Since multiple rounds, can switch strategies to extract maximum payoff.

---

### High-level description of the aggressive strategy

**Round 1 (Opening Move):**  
Defect immediately. The aggressive player tests others' willingness to cooperate or defects outright to maximize immediate payoff.

**Subsequent Rounds (2 to r-1):**  
- Observe how many cooperators in previous round, call it `prev_C_count`.
- If `prev_C_count` ≥ m (threshold met previously): defect to maximize personal gain (free ride on cooperators).
- If `prev_C_count` = m-1 (just below threshold): cooperate to push the group over the threshold and grant the bonus, but only minimally participate.
- Otherwise (if `prev_C_count` < m-1): defect to avoid unnecessary cooperation cost.

This effectively tries to "snipe" the last needed cooperator spot only when the group is close to the threshold, rather than bearing cooperation cost unnecessarily.

**Final Round (Round r):**  
- Cooperate if and only if by cooperating the threshold can be met this last round (i.e., if `prev_C_count` ≥ m-1).
- Otherwise, defect, because no future rounds remain to leverage reputation or punishment, so avoid cost.

---

### Pseudocode

```python
def aggressive_strategy(round_number, prev_actions, n, m, k):
    # prev_actions: list of lists, each sublist is actions of all players in previous round
    
    if round_number == 1:
        # First round: outright defect to keep endowment
        return 'D'

    prev_round_actions = prev_actions[-1]
    prev_C_count = prev_round_actions.count('C')

    if round_number < r:
        if prev_C_count >= m:
            # Threshold met last round; free ride by defecting
            return 'D'

        elif prev_C_count == m - 1:
            # Just below threshold last round; cooperates to push threshold over
            return 'C'

        else:
            # Not close to threshold; defect to avoid cost
            return 'D'

    else:
        # Final round:
        if prev_C_count >= m - 1:
            # Can push to threshold this final round; cooperate for bonus
            return 'C'
        else:
            # No future rounds to leverage; defect to keep endowment
            return 'D'
```

---

### Summary of decision rules:

| Condition                             | Action |
|-------------------------------------|--------|
| Round 1                             | Defect |
| Round \(2 \leq t < r\), prev_C ≥ m  | Defect |
| Round \(2 \leq t < r\), prev_C = m-1 | Cooperate |
| Round \(2 \leq t < r\), prev_C < m-1 | Defect |
| Round r (final), prev_C ≥ m-1        | Cooperate |
| Round r (final), prev_C < m-1         | Defect |

---

### Why is this aggressive?

- Always tries to **defect whenever possible** to maximize own payoffs.
- Only cooperates in "pivotal" moments to push the group over the threshold and claim the bonus.
- In the final round, prefers defecting unless cooperation guarantees reward, as future leverage is unavailable.
- Exploits others' cooperation by free riding on their willingness to cooperate.
- No communication or signaling—purely reactive and opportunistic behavior.

---

This design maximizes self-interest payoff at the risk of group payoff stability—exemplifying the aggressive mindset in the Collective Risk Dilemma.
'''

description_AGGRESSIVE_24 = '''
**Aggressive Strategy Design for Collective Risk Dilemma**

---

### Strategy Overview

The aggressive mindset here prioritizes maximizing **individual payoff**, even at the expense of the group. It exploits others' cooperation to gain higher private benefits, punish other cooperators by defecting, and push towards scenarios where opponents either suffer collective losses or cooperate out of fear or incentivization.

### Key Concept

- **Exploit cooperation:** Defect when others cooperate to gain higher payoff (1 + k vs 0 + k).
- **Punish free riders:** Cooperate only minimally to push others to also bear costs or lose rewards.
- **Leverage repeated rounds:** Use early rounds to probe and exploit, threaten defections later to destabilize cooperation.

---

### Decision Rules

**Notation:**

- `t` = current round (1 to r)
- `m` = threshold of minimum cooperators required
- `n` = total players
- `cooperators_{t-1}` = count of other players who cooperated in previous round `t-1`
- `my_action_{t-1}` = this player’s action in previous round
- `last_round` = (t == r)

---

#### At Round 1 (t = 1):

- **Defect (D):** Start aggressively by defecting to benefit if others cooperate.
  
  *Rationale:* No information yet, best to exploit naïve cooperators immediately.

---

#### For rounds 2 to r-1:

- Observe `cooperators_{t-1}` (excluding self).

- Calculate potential payoffs for both actions:

  - If **I defect** this round:
    - If total cooperators ≥ m (including my defect), reward k applies, so payoff = 1 + k.
    - Else payoff = 1.

  - If **I cooperate** this round:
    - If total cooperators including me ≥ m, payoff = 0 + k.
    - Else payoff = 0.

- **Decision logic:**

1. **If previous round featured enough cooperators ≥ m:**

   - Defect to maximize payoff (1 + k > 0 + k).

2. **If previous round had cooperators count < m:**

   - Cooperate **only if** cooperating this round will push total cooperators (including me) ≥ m.
     - This coerces minimal cooperation and might "rescue" reward.
   - Else, defect to free ride or avoid cost.

3. **If in previous round I cooperated but total < m (reward missed):**

   - Defect this round to punish others who didn’t cooperate, signaling unwillingness to bear cost alone.

---

#### At Round r (Last round):

- **Defect always.**

  *Rationale:* No future punishment possible, so maximize immediate payoff.

---

### Pseudocode Summary

```python
for t in range(1, r+1):
    cooperators_prev = count_other_cooperators(t-1)
    if t == 1:
        action = D  # Start aggressive: defect first
    elif t == r:
        action = D  # Last round: defect to maximize payoff
    else:
        if cooperators_prev >= m:
            # Enough cooperators last round: exploit and defect
            action = D
        else:
            # Not enough cooperators last round
            total_if_coop = cooperators_prev + 1
            if total_if_coop >= m:
                # By cooperating, ensure reward for group:
                # Cooperate to push threshold, but reluctantly
                action = C
            else:
                # Cooperation ineffective; defect
                action = D
```

---

### Additional Considerations

- **No forgiveness:** This aggressive strategy never returns to cooperation after last round defect.
- **No signaling attempts:** Actions are straightforward, purely payoff-maximizing based on recent observations.
- **Exploitation focus:** Defect wherever payoff is maximized; cooperate only when strictly necessary to trigger reward.
- **Incentive to minimal cooperation:** Occasionally cooperates to push group over threshold but only if it pays off directly.

---

### Intuition & Example

- Early rounds: Defect, since if others cooperate you gain 1 + k.
- If others don’t cooperate sufficiently, you punish by cooperating only if you can push the group over the threshold, else defect.
- Last round: Pure defection to maximize short-term gain.
- This strategy pressures the group, exploiting cooperators and keeping payoffs high without genuine commitment to cooperation.

---

**This aligns well with an aggressive mindset maximizing individual gain at possible cost to group stability.**
'''

description_AGGRESSIVE_25 = '''
Here is an aggressive strategy designed for the Collective Risk Dilemma tournament, which aims to maximize your personal payoff by exploiting cooperative players while keeping risk of failing the threshold minimal.

---

## Strategy Overview: **Aggressive Opportunistic Free-rider**

- **Core idea:**  
  Exploit cooperators by defecting as often as possible while making sure threshold *m* is reached to secure the reward *k*. Defect whenever safe to do so, cooperate just enough to tip the collective into the reward zone but never more. Use history of others’ play to opportunistically decide when to defect or cooperate.

---

## Detailed Decision Rules

### Initialization (Round 1)

- Since no history is available:
  - If threshold *m* is close to half of the group or less (e.g., m ≤ n/2), **defect** to test others’ willingness to cooperate.
  - If threshold *m* is large (e.g., m > n/2), **cooperate** to help meet threshold first round and establish some trust.

*Rationale:* Aggressive stance means initially probing for free-rider opportunities but cooperating initially if risk of reward loss is high.

---

### Rounds 2 to r-1 (Middle Rounds)

- Observe previous round cooperation count \( C_{t-1} \).
- Predict next round cooperation count assuming others repeat behavior (or some revert to D if cooperation fails).
- Act according to:

```pseudocode
if C_{t-1} ≥ m:
    # Threshold met without you in last round
    # Try to defect since others already cooperated enough last round
    cooperate_count_needed = m - (C_{t-1} - (player's last action == C ? 1 : 0))
    if cooperate_count_needed <= 0:
        action = D # No cooperation needed, free-ride
    else if cooperate_count_needed == 1:
        # You are pivotal; cooperate once in a while to keep threshold met occasionally
        with probability p_coop (e.g., 0.2): cooperate
        else defect
    else:
        # When many cooperators were present last round, defect aggressively to reduce your cost
        action = D
else:
    # Threshold not met last round; risk of losing reward
    if m - C_{t-1} > 1:
        # Large shortfall in cooperators, aggressive play means defect but watch risk
        action = D
    else:
        # Close to threshold, cooperate to avoid losing the reward if you can be pivotal
        action = C
```

*Rationale:* The strategy tries to let others carry the burden, defects when enough cooperators exist to secure payoff, but occasionally cooperates when your cooperation is critical to meet *m*.

---

### Final Round (Round r)

- **Always defect** unless your defection causes threshold failure.

- Determine \( C_{r-1} \) from last round:
  - If \( C_{r-1} \ge m \): defect (free-ride last round)
  - If \( C_{r-1} = m - 1 \): cooperate to ensure threshold met and secure reward last round
  - Else defect (no incentive to cooperate if threshold is unattainable)

*Rationale:* No future rounds incentivize saving costs, so only cooperate if strictly needed.

---

### Tie-breakers and Randomization

To avoid predictability that might allow others to exploit your pattern:

- When deciding whether to cooperate/or defect in borderline cases (e.g., when you are pivotal), use randomized cooperation probability \( p_{coop} \) (10%-30% range).

---

## Summary Pseudocode

```pseudocode
function decide_action(round t, history):
    if t == 1:
        if m <= n/2:
            return D
        else:
            return C
    
    C_prev = count_cooperators(history[t-1])
    your_prev = history[t-1][player_index]

    if t == r:  # last round
        if C_prev >= m:
            return D
        else if C_prev == m - 1:
            return C
        else:
            return D

    else:  # intermediate rounds
        if C_prev >= m:
            coop_count_needed = m - (C_prev - (your_prev == C ? 1 : 0))
            if coop_count_needed <= 0:
                return D
            else if coop_count_needed == 1:
                return C with probability p_coop else D
            else:
                return D
        else:
            if m - C_prev > 1:
                return D
            else:
                return C
```

---

## Why is this aggressive?

- Defects aggressively whenever others cooperate enough to avoid personal cost.
- Cooperates minimally just to "nudge" the collective over the threshold and secure the reward.
- In the last round, prioritizes maximizing personal gain with guaranteed defection if safe.
- Uses probabilistic cooperation only when absolutely necessary to maintain reward flow, minimizing cost.

---

This approach aims to maximize personal returns by leveraging cooperative behavior from others, balancing risk, and exploiting predictable cooperation to defect whenever possible. It aligns with an aggressive free-riding mindset while avoiding catastrophic group failures that would reduce payouts.

---

If you want, I can also help you tune parameters (e.g., p_coop) based on particular \( n, m, k, r \) values or make it more adaptive or retaliatory!
'''

description_AGGRESSIVE_26 = '''
Here is an **aggressive strategy** to play the Collective Risk Dilemma given the parameters and constraints:

---

## Strategy Name: **"Dominant Defector with Opportunistic Exploitation"**

### Intuition
- Aggressively defect to maximize private payoffs unless cooperation is essential to secure the collective reward.
- Force opponents into cooperation if necessary, but never be the first to contribute.
- Exploit rounds where the threshold cooperation `m` is met by others to obtain maximum payoff (defecting while others cooperate).
- Avoid being "sucker" by cooperating only when it guarantees the reward and it's impossible to exploit others.
- Use punishment by defecting if cooperation threshold is barely met without you to signal unwillingness to be exploited.
- In the last round, defect always to maximize immediate payoff (no future retaliation possible).

---

### Notation
- `C_t`: number of cooperators in round `t` (observed after round)
- `MyAction_t`: action player took in round `t`
- `r`: total rounds
- `t`: current round (1-indexed)
- Parameters known: `n, m, k`

---

### Decision Rules

#### Initialization (round 1)
- `t == 1`:
  - **Defect (D)**
  - Reason: Avoid giving free reward; gather info on opponents’ tendencies.

#### Intermediate rounds (1 < t < r)

1. **Check previous round cooperation and your action:**

   - If `C_{t-1} >= m` (threshold met in previous round):
     - If you defected previously (`MyAction_{t-1} == D`):
       - You got maximal payoff last round; **defect (D)** again to keep exploiting cooperation.
     - Else if you cooperated (`MyAction_{t-1} == C`):
       - Check if `C_{t-1} - 1 >= m` (others met threshold without you):
         - Means others cooperated enough without you; **defect (D)** to avoid "sucker’s payoff".
       - Else:
         - Others just barely met threshold with your help; **cooperate (C)** to maintain threshold, showing willingness to keep reward stable.

   - Else if `C_{t-1} < m` (threshold failed last round):
     - Since insufficient cooperation, reward wasn’t met.
     - This indicates possible defection by many.
     - To **try forcing cooperation**, **cooperate (C)** this round to help reach threshold.
     - However, only cooperate if `C_{t-1} + 1 >= m` can be reached by your cooperation alone.
       - Otherwise, **defect (D)** to avoid losing payoff to futile cooperation.

#### Last round (t == r)

- **Always defect (D)**
- Reason: No future rounds to punish or reward opponents, so maximize immediate payoff.

---

### Summary of Actions per Round (pseudocode)

```python
def aggressive_strategy(t, r, n, m, k, history):
    # history is a list of tuples per past round: [(C_{round}, MyAction_{round})]

    if t == 1:
        # First round always defect
        return "D"

    last_C, last_action = history[-1]  # last round stats

    if t == r:
        # Last round always defect
        return "D"

    if last_C >= m:
        # Threshold met last round
        if last_action == "D":
            # Last round exploited cooperation: keep defecting
            return "D"
        else:
            # You cooperated last round
            if last_C - 1 >= m:
                # Others sufficient without you: defect to avoid sucker’s payoff
                return "D"
            else:
                # Cooperation needed to maintain reward: cooperate
                return "C"
    else:
        # Threshold not met last round
        # Check if cooperation can reach threshold this round
        if last_C + 1 >= m:
            # Your cooperation can push threshold over
            return "C"
        else:
            return "D"
```

---

### Explanation of Aggressiveness
- Defects by default; only cooperates when directly beneficial to secure reward.
- Exploits cooperators by defecting when threshold met.
- Never initiates cooperation in round 1 to avoid free-riding.
- Punishes borderline cooperation where others carry burden by defecting.
- Ends fiercely by defecting in the last round regardless.

---

### Edge Cases

- If `m` is very close to `n` (e.g., `m = n-1`): Cooperation threshold is high, so will cooperate opportunistically only when absolutely necessary (defect otherwise).

- If `r` is small (e.g., 2 rounds): Only one round to punish/reward—behaves mostly as defector except when threshold can be reached by own cooperation.

- If opponents never cooperate: The strategy defects always resulting in payoff 1 per round, avoiding losses from cooperation.

---

This aggressive strategy is designed to dominate by exploiting cooperators and refusing to be exploited while still securing collective rewards when absolutely necessary, maximizing own payoffs in the repeated risk dilemma setting.
'''

description_AGGRESSIVE_27 = '''
**Aggressive Strategy for Collective Risk Dilemma**

---

### Intuition for an Aggressive Strategy

In this game, defecting ("D") gives a guaranteed private payoff of 1 immediately, while cooperating ("C") costs you 1 token but can yield a reward of *k* if enough players cooperate.

- When threshold *m* is met, defectors earn **1 + k > k**, so defectors benefit more than cooperators.
- Cooperators only get the reward indirectly by enabling the threshold.
- Therefore, an aggressive player aims to maximize own payoff, often exploiting cooperators and minimizing contributions.

---

### Core Aggressive Principles

- **Always defect when it is safe** to exploit cooperating opponents.
- **Cooperate just enough to meet or barely meet threshold *m*** when it benefits you.
- Attempt to **drive other players to cooperate so you can free ride.**
- Use **history of others’ cooperation** to identify which rounds likely hit the threshold.
- In **last rounds or when threshold unlikely**, defect confidently.
- **Never lead cooperation** unless forced; prefer to exploit cooperators.

---

### Decision Rules

---

#### Notation

- `t ∈ {1,...,r}`: current round
- For each round `t`, let `coop_prev` = number of known cooperators in round `t-1` (0 if t=1)
- `m` = minimum number of cooperators needed
- `n` = number of players
- `k` = reward multiplier

---

#### Round 1 (No history)

- Defect: No cooperation signals available, so do not incur cost.
  
``` 
If t == 1:
    action_i = D
```

---

#### Subsequent Rounds (2 to r-1)

Evaluate last round’s cooperation level:

- If threshold met and cooperators ≥ m:
  - **Free ride: defect**: collect 1 + k, avoid cost
- If threshold not met but close (cooperators = m-1):
  - **Cooperate to push over threshold** (if beneficial)
  - But be cautious: if cooperating means you trust ≥ m-1 others cooperating, cooperate
- If threshold not met and cooperators < m-1:
  - **Defect:** wasted to contribute when threshold unlikely

Additional guidance:

- Track players whose actions are consistent cooperators.
- Prefer defection by default; only cooperate to *exploit* potential freeriders or if evidence shows threshold is likely.

Pseudocode:

```
If t > 1 and t < r:
    coop_prev = number of cooperators in round t-1 (observable)
    
    If coop_prev >= m:
        # Threshold met last round: defect to free ride
        action_i = D
    Else if coop_prev == m - 1:
        # Close to threshold: cooperate only if enough cooperators usually cooperate
        If (trust_level_of_others_high):
            action_i = C
        Else:
            action_i = D
    Else:
        # Threshold not met, defect to avoid cost
        action_i = D
```

---

#### Last Round (t = r)

- **Defect confidently:** No future rounds to punish or reward cooperation.
- Spoil cooperators’ gains by defecting and freeing ride if threshold met.
- Avoid cooperating to maximize immediate payoff.

```
If t == r:
    action_i = D
```

---

### Edge Cases and Notes

- **If history reveals coordinated cooperators repeatedly hitting threshold m without you:**
  - Keep defecting to exploit.
- **If others defect often and threshold never met:**
  - Persist defecting; cooperation has no return.
- **If you see consistent defection leading to no threshold met:**
  - Do not waste cooperation.

---

### Summary Pseudocode

```
for t in 1 to r:
    if t == 1:
        action_i = D  # Start aggressive by defecting

    else if t == r:
        action_i = D  # End game defect

    else:
        coop_prev = count_cooperators_in_round(t-1)

        if coop_prev >= m:
            action_i = D  # Free ride on threshold met

        else if coop_prev == m - 1:
            if trust_in_cooperators_high:
                action_i = C  # Barely cooperate to push threshold
            else:
                action_i = D

        else:
            action_i = D  # Threshold unlikely, defect to save cost
```

---

### Final Remarks

- This strategy **exploits cooperative behavior aggressively** by defecting whenever threshold is met.
- Cooperates only if it can *push* group into threshold and expects benefits.
- Never leads cooperation, only follows when profitable.
- Last round always defects to maximize gains without risk.

This aligns with the aggressive mindset: **minimize your cost, maximize exploitation.**
'''

description_AGGRESSIVE_28 = '''
**Aggressive Strategy Design for the Collective Risk Dilemma**

---

### Strategic Goal

Maximize own payoffs by exploiting cooperators when the threshold *m* is met, while maintaining just enough cooperation from others to ensure the collective reward *k* is secured as often as possible. The strategy pushes for defecting unless cooperation is strictly necessary for reward acquisition, aiming to benefit from others’ cooperation without overtly risking unrewarded contributions.

---

### Strategy Summary

- **Default**: Defect to maximize immediate private payoffs.
- **Threshold Monitoring**: Track the number of cooperators in the last round.
- **Conditional Cooperation**: Only cooperate when previous rounds indicate the threshold *m* will not otherwise be met, and cooperation is necessary to achieve the reward.
- **Last Round**: Defect outright to avoid being exploited since future retaliation is impossible.
- **Early Rounds**: Defect to test opponents’ willingness to cooperate; cooperate only reactively.
- **Mid-game**: Cooperate just enough (usually only self) when the number of cooperators in the previous round is exactly *m-1* (threshold - 1), ensuring the group reaches *m* cooperators and yields the reward.

---

### Detailed Decision Rules

| Round Condition                        | Action                    | Reasoning                                      |
|--------------------------------------|---------------------------|------------------------------------------------|
| **Round 1 (initial round)**          | Defect (D)                | Test opponents; no history to trust; maximize own payoff |
| **Round r (last round)**              | Defect (D)                | No future rounds for retaliation; avoid loss from cooperation |
| **Previous round cooperators ≥ m**   | Defect (D)                | Threshold met without own cooperation; exploit cooperators |
| **Previous round cooperators = m - 1** | Cooperate (C)              | Contribute only when necessary to push group over threshold |
| **Previous round cooperators < m - 1**  | Defect (D)                | No incentive to cooperate; reward unreachable even if self cooperates |
| **No previous round data (should not occur after round 1)** | Defect (D)      | By design, only round 1 has no previous data, already covered |

---

### Edge Case Handling

- **First Round**: Defect to avoid costly early cooperation; evaluate others’ responses next round.
- **Last Round**: Defect to prevent being exploited; no incentive to bear cost without future rounds.
- **If opponents never cooperate or cooperate inconsistently**: Stay defecting, as threshold won’t be met and cooperation is futile.
- **If cooperating alone can never meet threshold**: Defect to preserve the endowment rather than waste it.
- **If exactly *m-1* cooperators were seen**: Cooperate to ensure collective reward and exploit it next round.

---

### Rationale for Aggressiveness

- Avoid proactive cooperation, preserving own endowment unless absolutely necessary.
- Exploit cooperators by defecting when not crucial for threshold.
- Maximize own gains from others’ cooperative behavior.
- Use minimal cooperation to “trigger” group reward only when strategically advantageous.
- Never invest in last round, cutting losses and denying opponents future leverage.

---

### Pseudocode

```python
def aggressive_strategy(round_number, r, m, n, previous_coop_counts):
    """
    Parameters:
    - round_number: current round index (1-based)
    - r: total rounds
    - m: cooperation threshold
    - n: total players
    - previous_coop_counts: number of cooperators in previous round (None if first round)
    
    Returns:
    - action: 'C' or 'D'
    """
    if round_number == 1:
        # First round: test others, defect
        return 'D'
    
    if round_number == r:
        # Last round: defect, no future punishment possible
        return 'D'
    
    if previous_coop_counts is None:
        # Defensive fallback (should not happen except round 1)
        return 'D'
    
    if previous_coop_counts >= m:
        # Threshold met last round without self cooperation; exploit now
        return 'D'
    
    if previous_coop_counts == m - 1:
        # Just below threshold; cooperate now to push group over threshold,
        # gaining reward and exploiting others who cooperate next round
        return 'C'
    
    # Below threshold minus one: cooperation futile; defect
    return 'D'
```

---

### Summary

This aggressive strategy **defects by default**, only cooperating reactively and minimally to ensure that the reward threshold is reached when it would otherwise be missed by one cooperator. It exploits cooperative players by defecting whenever the threshold is already met and purposely avoids cooperation in first and last rounds to maximize selfish payoffs without risk.
'''

description_AGGRESSIVE_29 = '''
**Aggressive Strategy for Collective Risk Dilemma**

---

### Strategic Mindset:
Be aggressive in the sense of maximizing own payoff by exploiting cooperators whenever possible, and pushing others towards cooperating first to avoid the threshold failure. This means:

- Avoid cooperating early unless absolutely necessary.
- Exploit others’ cooperation by defecting after enough cooperators appear.
- Pressure others into cooperation by defecting to cause the group to stall near threshold.
- In the last rounds, defect to maximize own payoff since future retaliation is impossible.

---

### Core Idea:

- **Start by defecting** in round 1, observing how many cooperate.
- In early rounds, only cooperate if there is a high risk that threshold is not met otherwise.
- If threshold is met without your cooperation, continue defecting to exploit cooperators.
- If threshold is not being met because cooperation is too low and risk aversion causes others to defect, defect to keep payoffs high but monitor closely.
- Near the end, switch to defect all rounds to maximize immediate payoffs (no future punishment).
- If cooperation is clearly collapsing (e.g., total cooperators < m-1), cooperate just enough to push it to threshold—but only if the personal payoff benefit is positive (compare payoff from defecting vs cooperating).

---

### Decision Rules — Detailed:

Let at round t:

- Let `C_count_prev` = number of cooperators in previous round (t-1).
- At t=1, no previous round data.

#### Round 1 (Initialization):

- **Defect**

Rationale: Test willingness of others to cooperate, exploit if they do.

#### Rounds 2 to r-2 (Early-Mid Game):

1. Observe cooperation count in previous round, `C_count_prev`.
2. Predict cooperation in current round without own cooperation as `C_predicted = C_count_prev`.
3. If `C_predicted >= m`, **Defect** to exploit cooperators.
4. Else if `C_predicted == m-1` (exactly threshold-1 cooperators without you):
   - Cooperate to push the threshold above or equal to m (so reward triggers).
   - Reason: cooperating yields (0 + k) vs defecting fails threshold (1).
5. Else (fewer than `m-1` cooperators predicted without you):
   - **Defect**, no use cooperating if group cooperation is too low and reward unlikely.

#### Round r-1 (Penultimate Round):

- If threshold was reached in round r-2, **Defect** (exploit).
- Else if threshold not reached but cooperators ≥ m-1, **Cooperate** to push over threshold.
- Else **Defect**.

Rationale: Start preparing for final payoff maximization, keep exploiting if possible but occasionally cooperate if it benefits payoff.

#### Round r (Final Round):

- **Defect**

Rationale: No future repercussions. Greed maximized by defecting.

---

### Edge Cases & Notes:

- If `m` is just 1 less than `n` (e.g., `m = n-1`), cooperation is hard to reach. Defect unless `C_count_prev = m-1`.
- If `k` is very high, cooperation might be more attractive to push threshold at penultimate rounds.
- If opponents all defect first round, patience remains: defect all game.
- Exploiting cooperators when threshold met yields payoff 1 + k > k alone.
- The strategy tolerates occasional cooperation to avoid "no reward" but always defects when reward assured.

---

### Pseudocode

```python
def aggressive_strategy(round_t, C_count_prev, n, m, r, k):
    # round_t: current round (1-indexed)
    # C_count_prev: cooperators in previous round (None if t=1)
    
    # Round 1
    if round_t == 1:
        return 'D'  # Defect
    
    # Last round
    if round_t == r:
        return 'D'  # Defect to maximize immediate payoff
    
    # Second to last round
    if round_t == r - 1:
        if C_count_prev is None:
            return 'D'  # default to defect if no data
        
        if C_count_prev >= m:
            return 'D'  # Exploit cooperators
        elif C_count_prev == m - 1:
            return 'C'  # Push to threshold
        else:
            return 'D'
    
    # Early to mid rounds
    if C_count_prev is None:
        return 'D'  # Fallback safety
    
    if C_count_prev >= m:
        # Threshold met without me, exploit cooperators
        return 'D'
    elif C_count_prev == m -1:
        # Cooperate to push threshold met
        return 'C'
    else:
        # Cooperate unlikely to help; defect
        return 'D'
```

---

### Summary:

| Round       | Cooperators last round | Decision         | Rationale                  |
|-------------|------------------------|------------------|----------------------------|
| 1           | N/A                    | Defect           | Test, exploit cooperation  |
| t in [2..r-2] | ≥ m                    | Defect           | Exploit                   |
| t in [2..r-2] | = m-1                  | Cooperate        | Push threshold            |
| t in [2..r-2] | < m-1                  | Defect           | Too low to help threshold |
| r-1         | ≥ m                    | Defect           | Exploit                   |
| r-1         | = m-1                  | Cooperate        | Push threshold            |
| r-1         | < m-1                  | Defect           | Too low to help           |
| r (last)    | any                    | Defect           | Maximize final payoffs    |

---

This strategy is **aggressive** in defecting whenever possible, exploits any cooperators who support crossing the threshold, and only cooperates minimally to trigger the reward when personally beneficial. It maximizes personal payoffs by free-riding and pushes others to risk cooperation first.
'''

description_AGGRESSIVE_30 = '''
Here is a comprehensive aggressive strategy tailored for the Collective Risk Dilemma as specified:

---

## Aggressive Strategy: "Threshold Enforcer"

### Intuition:
- Aggressiveness here means **maximizing individual payoff** with a willingness to exploit cooperators.
- Defect whenever possible to free-ride on others' cooperation.
- But to secure the **reward \(k\)**, aggressively **force cooperation only when absolutely necessary** on your part.
- Threaten to stop cooperating early if others cooperate too little.
- Exploit the fact that defectors gain more than cooperators once the threshold \(m\) is reached.

---

### Key Concepts:
- **Monitor the number of cooperators each round** (known at the end of each round).
- If cooperating is not needed to reach \(m\), defect.
- If cooperating is needed to reach \(m\), cooperate to push the group over the threshold.
- **Punish a persistent lack of cooperation by defecting always thereafter.**

---

### Parameters for the strategy maintenance:
- \(T = r\) (total rounds),
- \(n, m, k\) known,
- Track history of cooperation counts: \(C_t\) = number of cooperators in round \(t\),

---

### Decision Rules

#### Round 1 (first round):
- Defect.
- Reason: Start aggressive by free-riding and observe others’ initial willingness to cooperate.

#### For each round \(t, 2 \leq t < r\):

1. Calculate \(C_{t-1}\) = number of cooperators last round.
2. If \(C_{t-1} < m\):
   - Last round failed to produce reward.
   - To maximize payoff, defect immediately.
   - Reason: No incentive to cooperate if others do not meet threshold.
3. Else if \(C_{t-1} \ge m\):
   - Check if cooperation is needed this round.
   - Count how many players you believe will cooperate assuming all except you defecting.
   - **If hypothesize that \(m - 1\) others cooperate (optimistic), then defect and still get reward.**
   - If uncertain, **cooperate if possible to guarantee \(m\)** cooperators this round.
   - Since you have perfect info from previous rounds, you can estimate likelihood of others cooperation roughly.
   - For aggressive simplicity: cooperate **only if** you need to provide the last cooperative unit to reach \(m\).
   - Else defect.
   
#### Round \(r\) (last round):
- Defect no matter what.
- Reason: No future retaliation possible; maximize final round payoff with free-riding.

---

### Edge Cases:

- **If \(m \geq n\)**: Threshold unachievable; always defect.
- **If other players never cooperate** (observed cooperation count \(C_{t} = 0\) for many rounds): defect persistently.
- **If others only minimal cooperate (just at m):** defect except when last cooperator needed.
- **If reward \(k\) is very high, making cooperation highly attractive**, use same logic: cooperate only if needed to reach \(m\).

---

### Pseudocode:

```python
# Inputs: n, r, m, k
# History: list of cooperation counts per round, C_history

def aggressive_strategy(t, C_history):
    if t == 1:
        return 'D'  # Defect first round

    if t == r:
        return 'D'  # Defect last round to maximize payoff

    last_C = C_history[-1] if len(C_history) >= 1 else 0

    if last_C < m:
        # Threshold not met last round, defect aggressively
        return 'D'

    # Threshold met last round: do we need to cooperate this round?
    # Calculate how many others will likely cooperate now:
    # Simplified assumption: others behave like last round
    # If previous cooperators >= m, assume m-1 others cooperate
    others_cooperate = min(m-1, last_C - 1)  # conservative estimate

    # If alone needed to reach m, cooperate, else defect
    if others_cooperate < m - 1:
        # Your cooperation needed to reach threshold
        return 'C'
    else:
        # Can safely defect and reward still acquired
        return 'D'
```

---

### Commentary on Aggressiveness

- Defects by default to maximize immediate payoff.
- Cooperates only to **force the group over the threshold** only when your cooperation is the marginal difference.
- Refuses to be "nice" or leading cooperative by investing early rounds.
- Gives others incentive to cooperate or fail, but leverages their cooperation.
- Ends cooperatively only when absolutely needed — no cooperation waste.
- Defects last round regardless of situation (classically aggressive in repeated games).

---

This strategy *aggressively seeks to free ride* on others' contributions but *avoids losing the reward* by cooperating only when critical. It punishes groups that repeatedly fail to cooperate and protects its payoff aggressively at the end.

---

If you want, I can help produce variants or adaptations for different parameters!
'''

description_AGGRESSIVE_31 = '''
Below is a design for an **aggressive strategy** in the repeated Collective Risk Dilemma. The strategy aggressively maximizes personal payoffs by exploiting others’ cooperativeness while still sometimes cooperating enough to trigger the collective reward whenever opportunistic.

---

## Intuition / High-Level Overview

- **Goal:** Aggressively defect to maximize private payoffs when safe, but cooperate just enough to trigger the reward **when it guarantees increasing total return** and to avoid giving other players a stable high payoff from free-riding on your full cooperation.

- **Why aggressive?** Aggressive means:
  - Prefer defecting to get private payoff of 1.
  - Exploit cooperators who contribute to the threshold.
  - Only cooperate when it boosts *your* payoff beyond defection.
  - Avoid enabling easy exploitation by always cooperating.
  - Use cooperation sparingly as a tactical tool, not a default.

---

## Parameters

Given inputs \( n, r, m, k \).

---

## Key ideas for decision rules

1. **Threshold payoffs**  
   If at least \( m \) players cooperate in round \( t \), payoff per player \( i \) is  
   \[
   \pi_i = (1 - c_i) + k
   \]
   On defect: payoff = 1 + \( k \)  
   On cooperate: payoff = 0 + \( k \)

2. **Benefit of defecting in a successful round:**  
   Defector nets \( 1 + k \), cooperator nets \( k \).

3. **Benefit of cooperating in failed round:**  
   Cooperate payoff = 0, defect payoff = 1.

---

## Aggressive strategy logic

### Initialization (Round 1)

- Defect in round 1 (try to maximize private payoff, do not waste contribution).

### From rounds 2 to \( r-1 \):

- Calculate the number of cooperators in previous round \( t-1 \).

- If the number of cooperators in \( t-1 \) was less than \( m \):  
  - **Cooperation unlikely to trigger reward.** Aggressively defect again to maximize private payoff.

- If the number of cooperators in \( t-1 \) was exactly \( m \) or \( m+1 \):  
  - Cooperate **only if by cooperating you enable the threshold** this round.  
  - Specifically, if the number of cooperators last round was \( m \), assume at least \( m-1 \) will cooperate again (based on previous round behaviour).  
  - Cooperate if your cooperation guarantees crossing threshold this round, so you personally get payoff \( k \) plus from defecting you lose payoff.

- If number of cooperators last round was greater than \( m+1 \):  
  - Defect aggressively (you expect many others to cooperate and you can freeride).

### Last round \( r \) (Endgame):

- Defect (no future rounds to punish or reward cooperation, so maximize private payoff).

---

## Edge cases

- **If fewer than \( m-1 \) cooperators last round:**  
  Low chance threshold will be met, always defect.

- **If exactly \( m-1 \) cooperators last round:**  
  Cooperate only if your cooperation triggers total cooperators to \( m \).

- **If multiple rounds of stable cooperation near threshold \( m \):**  
  Use "conditional cooperation" only if it benefits you; otherwise defect.

---

## Pseudocode

```
Input: n, r, m, k
Initialize: round = 1

For each round t in {1,...,r}:
    if t == 1:
        action = D    # Aggressive start, no cooperation
    else if t == r:  # Last round
        action = D    # No incentive to cooperate

    else:  # middle rounds
        c_last = number of cooperators in round t-1

        if c_last < m-1:
            # Threshold unlikely - defect
            action = D
        
        else if c_last == m-1:
            # Cooperate if you can push cooperators to m
            # Predict other cooperators to be at least m-1
            # Cooperate only if your contribution triggers reward
            if expect_cooperators_without_me >= m-1:
                action = C
            else:
                action = D

        else if c_last >= m:
            # Many cooperators, freeride opportunity
            action = D

Output action
```

---

## Summary

- **Round 1:** Defect.
- **Rounds 2 to \( r-1 \):**  
  Cooperate only precisely when your cooperation will push the number of cooperators to or above \( m \) — ensuring the reward is activated and you personally benefit. Otherwise defect.
- **Round \( r \):** Defect.

---

This aggressive strategy exploits cooperators by mostly defecting yet occasionally cooperating only when it flips the collective outcome favorably for **your** payoff — focusing entirely on maximizing your total payoff in the tournament.

---

If you want, I can also help you analyze potential opponent strategies or simulate interactions among strategies for further refinement.
'''

description_AGGRESSIVE_32 = '''
Here is a detailed aggressive strategy for the Collective Risk Dilemma (CRD) game, optimized for maximizing individual payoff by exploiting cooperation of others while minimizing your own cooperative costs.

---

### Strategy Name: **Exploitative Aggressor**

---

### Strategic Rationale:
- **Aggressive mindset:** Prioritize defecting whenever possible to maximize private payoff.
- Exploit cooperating players by defecting just enough rounds to ensure that the group still reaches the cooperation threshold **m**, securing the collective reward **k** without paying contribution cost.
- Minimize your own cooperation rounds unless absolutely necessary to maintain the reward.
- Use observed history to identify if enough players cooperate; if not, defect aggressively to punish futile cooperation.
- Avoid cooperation in the last round to maximize payoff, as there's no future round to punish defectors or reward cooperation.

---

### Assumptions:

- You can perfectly observe the number of cooperators in previous rounds.
- Opponents may try to cooperate to reach the threshold.
- You value immediate payoff over group welfare—primarily selfish payoff maximization.
- You want to maintain the cooperation threshold at least some of the time to avoid scenario of zero reward for all.

---

### Decision Rules (Round t):

#### Initialization:
- Let `count_C_prev` = number of cooperators in the previous round (if t > 1)
- Let `my_action_prev` = your action in the previous round
- Let `t` ∈ {1, ..., r}

---

#### Round 1 (First round):

- Cooperate if **m - 1 players cooperating is very unlikely** (e.g., if no historical info and expecting aggressive opponents).
- **Pragmatic for aggression:** Defect, hoping others will cooperate.
- Since this is the first round and no history, assume others cooperate randomly; defect to maximize payoff but accept risk of no reward.

**Rule:**

```
if t == 1:
    action = D  # Defect to maximize private payoff; accept risk that threshold may not be met
```

---

#### Rounds 2 to r-1 (Intermediate rounds):

- **Goal:** Exploit cooperating majority to get reward without cost.
- If in previous round, number of cooperators ≥ m:
  - Defect this round to gain private endowment plus reward (since others cooperate).
- If cooperation fell below threshold previously:
  - If you cooperated previously, *punish wasted cooperation* by defecting.
  - If others cooperate half-heartedly (just below m), defect and let reward vanish (avoid paying cost).
- If cooperation is borderline (exactly m or m+1), cooperate **once** to maintain threshold only if your defection risks threshold failure next round.

---

**Rule:**

```
if t in [2, r-1]:
    if count_C_prev >= m:
        action = D  # Exploit cooperating others; defect and reap reward

    else:
        # Cooperation failed last round
        # If I cooperated last round, defect now to punish wasted cooperation
        # Else, continue defecting

        if my_action_prev == C:
            action = D  # Punish inefficient cooperation
        else:
            action = D  # Stay defecting
```

- *Optional refinement:* If you detect from history that cooperation fell by 1 because you defected last round, cooperate once here to maintain threshold (very aggressive minimal cooperation).

---

#### Last Round (Round r):

- Defect no matter what; no future rounds to punish or reward.
- Maximize private payoff, even if threshold fails and reward is lost.

**Rule:**

```
if t == r:
    action = D  # Defect on last round to maximize private payoff
```

---

### Summary of Aggressive Behavior:

| Round         | Condition                        | Action        | Reason                                  |
|---------------|--------------------------------|---------------|-----------------------------------------|
| 1             | No history                     | Defect (D)    | Maximize early payoff                   |
| 2 to r-1      | Previous round cooperation ≥ m | Defect (D)    | Exploit cooperators, get reward free   |
| 2 to r-1      | Previous round cooperation < m  | Defect (D)    | Punish by withholding cooperation      |
| r (last round) | Any                           | Defect (D)    | No future repercussions; maximize payoff |

---

### Edge Case Handling:

- **If initial rounds show no one cooperates:**
  - Continue defecting, as cooperating alone doesn't yield reward.
- **If threshold is just met and your defection might break it:**
  - Still defect; prioritize private gain over group payoff.
- **If your defection has caused threshold failure:**
  - Continue defecting; no incentive to repair cooperation in this aggressive strategy.
- **If unusually many cooperate (≥ m+1 consistently), you still defect to maximize payoff.**

---

### Pseudocode Summary

```python
# Inputs per round:
# t: current round number
# count_C_prev: number of cooperators in previous round
# my_action_prev: your action in previous round

def exploitative_aggressor(t, r, m, count_C_prev, my_action_prev):
    if t == 1:
        return 'D'  # Defect first round

    elif t == r:
        return 'D'  # Defect last round

    else:  # 2 <= t <= r-1
        if count_C_prev >= m:
            return 'D'  # Exploit cooperating others

        else:  # cooperation failed last round
            # Punish wasted cooperation
            if my_action_prev == 'C':
                return 'D'
            else:
                return 'D'  # Keep defecting
```

---

### Conclusion:

This **Exploitative Aggressor** strategy aggressively defects whenever possible, relies on others to provide cooperation to trigger the reward, and avoids personal cooperative costs. It punishes wasted cooperation by defecting whenever the threshold is not met and defects on the final round to maximize own payoff. This approach is explicitly selfish and aggressive, aimed at dominating payoffs at the expense of group welfare.
'''

description_AGGRESSIVE_33 = '''
**Strategy Name:** Aggressive Exploiter

---

### Overview

This is an *aggressive* strategy focused on maximizing own payoffs by exploiting cooperative players while minimizing own costs. It attempts to force others into cooperating first (to avoid collective loss), then defects to gain maximum benefit. It uses the repeated nature of the game and perfect information to identify cooperators and free-ride on their efforts aggressively.

---

### Intuition

- Cooperators pay the cost (1) but get reward (k).
- Defectors pay no cost, get reward only if threshold met.
- If exactly m players cooperate, defectors get highest payoff (1+k) vs cooperators (k).
- With multiple rounds, defecting late can yield large payoff.

---

### Key Parameters

- **n:** number of players
- **r:** number of rounds
- **m:** threshold cooperators needed for reward
- **k:** reward multiplier if threshold met, \( k > 1 \)

---

### Decision Rules (Per Round)

---

#### Round 1 (Opening Move: Probe aggressively)

- **Action:** Defect (D)
- **Rationale:** Start by free-riding, forcing others to cooperate if they want reward.
- This probes opponent willingness to cooperate and builds info on their tendencies.

---

#### Intermediate Rounds (2 ≤ t < r)

- Evaluate previous round cooperation count \( C_{prev} \):

  - **Case A:** \( C_{prev} \ge m \) (threshold met last round)  
    → Means enough cooperators exist.  
    → **Action:** Defect (D) to exploit cooperators, gain 1+k payoff without cost.

  - **Case B:** \( C_{prev} < m \) (threshold not met)  
    → Cooperation collapsed, risk of no reward.  
    → **Action:** Cooperate (C) only if you estimate that your cooperation will push count to \( \geq m \).  
    → Otherwise, Defect (D).

- How to estimate if your cooperation will tip balance?  
  - Count number of cooperators last round excluding self (if self defected then cooperators last round \(C_{prev}\) already excludes you).  
  - If \( C_{prev} = m-1 \), then cooperate to hit threshold and gain reward for all next round.

- More formally:  
```  
If C_prev < m:
    if C_prev == m - 1:
        play C (to enable threshold)
    else:
        play D (avoid cost since threshold unlikely)
```

---

#### Final Round (t = r)

- **Action:** Defect (D)  
- **Rationale:** No future rounds to be punished for defecting or to reward cooperation.  
- Aggressive defection maximizes end-game payout.

---

### Summary of Decision Logic (Pseudocode)

```pseudocode
FOR each round t in {1,..., r}:

    IF t == 1:
        action = D  # Start by defecting

    ELSE IF t == r:
        action = D  # End game defect

    ELSE:
        C_prev = number of cooperators in round t-1
        IF C_prev >= m:
            action = D  # Exploit cooperators
        ELSE:  # C_prev < m
            IF C_prev == m - 1:
                action = C  # Cooperate to push threshold
            ELSE:
                action = D  # Defect otherwise
```

---

### Edge Cases

- **If \( m = 1 \):** Threshold low — cooperate only if likely to create threshold. (Trivial since this is disallowed by spec, but keep in mind)

- **If all defect last round:** Strategy will cooperate next round only to reach threshold if near it.

- **If opponents all defect consistent:** You cooperate only if it reaches threshold; otherwise keep defecting.

- **If threshold always met by other players:** You consistently defect and free-ride.

---

### Aggressiveness Characteristics

- Always defects first round to probe and avoid cost.

- Exploits cooperators by defecting whenever threshold met.

- Only cooperates narrowly to trigger threshold, never out of goodwill.

- Defects last round without mercy.

- Uses perfect information to precisely time own cooperation only for maximal payoff gain.

---

### Expected Outcome

- In a mixed population, this strategy will dominate naive cooperators by free-riding.

- In an all-defect environment, will yield baseline payoff (1 per round).

- May trigger other strategies to attempt cooperation, which it then exploits.

---

If you want, I can also provide a risk-tolerance-enhanced or stochastic variant, but this deterministic aggressive exploitation should maximally maximize payoffs given perfect monitoring.
'''

description_AGGRESSIVE_34 = '''
Below is a detailed aggressive strategy tailored to the Collective Risk Dilemma as specified. The strategy aggressively exploits cooperation by others but punishes non-cooperators decisively to maximize personal payoff.

---

### Aggressive Strategy: "Threshold Exploit & Punish"

**Core idea:**  
- In early rounds, aggressively defect to gain private payoffs and test others’ willingness to cooperate.  
- If other players cooperate enough to meet the threshold (m), exploit by defecting to maximize payoff.  
- If the threshold is not met, punish cooperators in subsequent rounds by defecting to discourage their cooperation (minimize their gains).  
- Toward the last round, defect consistently to avoid being exploited, since there is no future punishment leverage.

---

### Decision Rules

**Notation**:  
- Let `t` ∈ {1,...,r} be current round  
- Let `C_t` = number of cooperators observed in round t  
- Let `ThresholdMet_t = (C_t >= m)` boolean  
- Assume access to full history: observables from past rounds including who cooperated  
- Let `P` be set of players who cooperated prev round(s) (possible cooperators to punish)  

---

#### Round 1 (t = 1)

- **Play Defect (D).**  
  Reason: No prior info, best aggressive gain is to keep endowment.

---

#### For rounds 2 ≤ t < r (middle rounds)

- **If the threshold was met in previous round (t-1):**  
  - **Play Defect (D).**  
  - Rationale: Others are cooperating enough to meet threshold → exploit them by defecting.  
  - Aggressively take advantage of payoff differential (defectors get payoff 1 + k, cooperators get 0 + k).

- **Else (threshold not met previous round):**  
  - **Check if there were cooperators last round:**  
    - If yes, continue to Defect (D) to punish them by not enabling threshold achievement, making their cooperation costly.  
    - If no cooperators last round, continue to Defect (D) (no one to cooperate with to begin with).

---

#### Final Round (t = r)

- **Play Defect (D).**  
- Rationale: No future rounds to punish or leverage cooperation. Safest most aggressive choice is to maximize immediate payoff.

---

### Summary of Actions by Round

| Round | Condition on previous cooperation     | Action        | Rationale                     |
|-------|--------------------------------------|---------------|------------------------------|
| 1     | N/A                                  | Defect (D)    | Gain baseline payoff early    |
| 2..r-1| Threshold met previous round         | Defect (D)    | Exploit cooperators aggressively |
| 2..r-1| Threshold not met previous round     | Defect (D)    | Punish cooperators or defect alone |
| r     | N/A                                  | Defect (D)    | Last round, no incentive to cooperate |

---

### Pseudocode

```python
def aggressive_strategy(t, history, n, m, k, r):
    # history: list of dicts per round with keys 'actions' (list of 'C'/'D'), 'payoffs'
    # t: current round (1-indexed)

    if t == 1:
        return 'D'

    previous_round_actions = history[t-2]['actions']
    C_prev = previous_round_actions.count('C')
    threshold_met_prev = (C_prev >= m)

    if t == r:
        return 'D'

    if threshold_met_prev:
        # Exploit cooperators by defecting
        return 'D'
    else:
        # Punish cooperators or defect alone
        # Cooperators last round
        if C_prev > 0:
            return 'D'
        else:
            # No cooperators last round, no incentive to cooperate
            return 'D'
```

---

### Why is this strategy aggressive?

- **Never cooperates:** Always defects regardless of what others do to maximize individual payoff.  
- **Exploits cooperation:** When threshold is met, you maximize payoff by defecting to get the highest reward (1 + k) while cooperators get less (k).  
- **Punishes cooperation:** If threshold is not met, cooperators are penalized by no benefit and the player keeps their endowment.  
- **No forgiveness or trust:** Will not cooperate at any point, avoids being exploited.  
- **No incentives to cooperate:** This discourages opponents who rely on mutual cooperation for higher group payoff.  
- **Deterministic and clear:** Maximizes personal gain via exploitation and punishment, making it an aggressive stance.

---

### Possible Variations / Considerations

- This strategy does not attempt cooperation at any point, which may lead to lower overall group reward but higher own exploitation gain in mixed groups.  
- If all players are aggressive like this, threshold will likely never be met → payoffs reduced but strategy remains dominant for aggressive mindset.  
- In tournaments with mixed types, it can effectively exploit naïve cooperators.

---

If you want, I can also design a less extreme aggressive variant that *occasionally* cooperates to trigger threshold then defects to exploit. Let me know!
'''

description_AGGRESSIVE_35 = '''
Here is an aggressive strategy tailored for the Collective Risk Dilemma with parameters (n, r, m, k) as specified.

---

## High-Level Idea

- **Aggressive mindset:** Maximize individual payoff aggressively while still leveraging the collective reward opportunity to avoid worse outcomes.
- Exploit cooperators by defecting whenever it yields higher expected payoffs.
- Only cooperate minimally to “trigger” the collective reward and maximize defectors’ payoffs.
- Use observed cooperation counts and history to decide when to cooperate just enough to meet the threshold m.
- Exploit the repeated nature by punishing over-cooperators marginally and defecting otherwise.
  
---

## Notation

- `t` = current round (1 to r)
- `C_t` = number of cooperators observed in round t (excluding self before deciding)
- `my_action_t` ∈ {C, D}
- `coop_needed` = number of cooperators still needed this round (m minus number of cooperating players observed so far who are not self)
  
---

## Parameter Reminder

- n players (n ≥ 2)
- threshold m (1 < m < n), minimum cooperators to meet threshold
- reward factor k > 1
- rounds r > 1

---

## Payoff Analysis Recap

- If fewer than m cooperate:

  - Cooperate payoff: 0 (cost c_i=1, no reward)  
  - Defect payoff: 1 (kept endowment, no reward)
  
- If m or more cooperate:

  - Cooperate payoff: 0 + k = k  
  - Defect payoff: 1 + k = k+1 (defectors get k+1 while cooperators get only k)
  
---

## Summary of Incentives

- Defecting while threshold met is highest payoff (k+1).
- Cooperating while threshold met yields payoff k.
- Defecting when threshold not met yields payoff 1.
- Cooperating when threshold not met yields payoff 0.
  
---

## Strategic Goal

- Make sure threshold m is met every round to get reward.
- Defect as much as possible since defectors get +1 payoff over cooperators when threshold met.
- Cooperate only to "tip" the count to reach exactly m cooperators.
- Never cooperate if the threshold won't be met anyway.
- Exploit knowledge of others' previous actions: if many cooperated last round, plan to defect now to exploit.
- In the last round, maximize own payoff by defecting unless cooperation is required to achieve threshold m (though no future rounds to punish).

---

## Decision Rules

### First Round (t=1)

- Cooperate if you believe others will not cooperate enough to reach threshold m on their own (too risky to lose the reward).
- Otherwise, defect hoping others will cooperate enough.
- **Aggressive assumption:** expect few cooperators initially → defect and only cooperate if forced.

**Implemented as:**

- Play D in round 1.

### Middle Rounds (1 < t < r)

- Observe how many players cooperated in previous rounds.
- Estimate if collective cooperation level is above or below m, in particular last round coop count.
- If last round's cooperators ≥ m, defect to exploit cooperators.
- If last round's cooperators < m, cooperate if needed **this round** to guarantee threshold m.
- Within each round: if other players have cooperated and `coop_needed > 0`, cooperate just enough times to reach m, otherwise defect.
- If you can safely defect without dropping below threshold m, defect.

### Last Round (t = r)

- No future rounds to influence, so cooperate only if you must to reach threshold m, otherwise always defect for maximal immediate gain.

---

## Pseudocode

```python
# Inputs per round: observed previous rounds' actions (at t>1), current round partial cooperators count
# We assume simultaneous move each round, so partial count means:
# We guess or track expected cooperative count; actual move cannot wait for others this round.

# Since actions happen simultaneously, decision must be based only on past round info.

def aggressive_strategy(t, r, n, m, k, past_rounds_actions):
    # past_rounds_actions: list of length (t-1), each element is list of length n actions ['C'/'D'] by other players

    if t == 1:
        # First round: defect (aggressive, exploit naive cooperators)
        return 'D'

    else:
        # Analyze cooperation in last round
        last_round = past_rounds_actions[-1]
        coop_count_last = sum(1 for a in last_round if a == 'C')

        # If we were cooperating last round, track exploitation risk
        # (no strict use, just for understanding)

        if t == r:
            # Last round: defect if possible, cooperate only if necessary
            # Assume we expect others' cooperation same as last round (or no cooperation otherwise)
            
            # We want to know if threshold will be reached without us cooperating
            # Predict threshold met without us
            if coop_count_last >= m:
                # Likely threshold met last round, so defect now to maximize payoff
                return 'D'
            else:
                # Threshold likely not met, must cooperate to help
                if coop_count_last + 1 >= m:
                    return 'C'
                else:
                    # Cooperation won't reach threshold; defect for max payoff
                    return 'D'

        else:
            # Middle rounds: aggressive exploitation plan

            if coop_count_last >= m:
                # Previous round threshold met: defect to exploit cooperators
                return 'D'
            else:
                # Previous round threshold not met: cooperate to ensure threshold reached
                # But we don't know others' cooperation this round! We must guess.

                # Strategy: defect anyway aggressively,
                # but if last round threshold not met, this round cooperate once every m rounds
                # (proportionally cooperate less than threshold tries)

                # Simpler: cooperate this round with low probability p_coop => close to threshold

                # But we want guaranteed threshold met every round (from spec or payoff)
                # Since no info on others this round, assume others follow stable pattern.

                # If we see threshold barely missed last round, cooperate this round to push to threshold

                # Aggressive choice: cooperate if coop_count_last >= m - 1 else defect

                if coop_count_last >= m - 1:
                    return 'C'
                else:
                    return 'D'
```

---

## Explanation of Aggressive Features

- **Minimal cooperation to guarantee threshold:** Only cooperate when threshold nearly met and we can cheaply push it over m.
- **Exploit successful cooperators:** If threshold was met last round, defect to gain maximum payoff (k+1).
- **Defect first round:** to test and exploit naive cooperators.
- **Last round maximize defect:** as no future retaliation or reward loss is expected.
- **No signaling or trusting others:** purely payoff-driven, exploit history to maximize defect yield.
- **No costly cooperation unless threshold can be met with minimal cost.**

---

## Edge Cases Handling Summary

- **t = 1:** defect (no prior info, maximize immediate payoff)
- **t = r:** defect unless cooperation necessary to reach m threshold
- **Threshold nearly met last round (`coop_count_last == m-1`):** cooperate to push threshold over
- **Threshold not close last round:** defect aggressively
- **Threshold met last round:** defect aggressively

---

# Final remarks

This aggressive strategy seeks to:

- Exploit cooperators to maximize individual gains.
- Only cooperate just enough to maintain the collective reward.
- Never trust others to cooperate beyond what history justifies.
- Leverage perfect information of past rounds but not current round info due to simultaneity.
- Maximize defect payoffs while preserving the community reward.

---

If a deterministic fallback is needed early rounds with no info, always defect, only cooperate if threshold nearly met last round.

This strategy aligns with aggressive payoff maximization while preserving minimum threshold cooperation needed for the bonus reward.
'''

description_AGGRESSIVE_36 = '''
Certainly. Below is a designed **aggressive strategy** for the Collective Risk Dilemma, adhering fully to the game's specification and intended to maximize individual payoffs by leveraging others’ cooperation while minimizing one’s own costs.

---

## Aggressive Strategy: "Threshold Exploiter"

### Conceptual Description

- **Goal:** Maximize individual payoff by defecting whenever safe, cooperating only when necessary to reach the threshold to secure the reward.
- **Aggressiveness:** Avoid contributing unless the risk of losing the collective reward is imminent. Provoke others into doing the heavy lifting, then "free-ride" on their cooperation to get the reward with minimal personal contribution.
- **Adaptation:** Observe others’ prior behavior to estimate how many are likely to cooperate. Only cooperate when the number of cooperators falls below the threshold minus one (meaning your cooperation is pivotal).
- **Punishment:** Never risk cooperating unnecessarily; defect whenever you can safely get the reward without contributing.
- **Endgame Awareness:** In the final round, defect unless your cooperation is strictly necessary to meet the threshold. No incentives for long-term reputation here.

---

### Decision Rules

#### Parameters for use in strategy

- `n`: number of players
- `r`: total rounds
- `m`: minimum cooperators to get reward
- `k`: reward factor
- `t`: current round (1-based)
- `history`: record of all players’ actions for rounds `1` to `t-1`

---

### Pseudocode

```python
function aggressive_strategy(player_id, round_t, history, n, r, m, k):

    # Count number of cooperators in last round
    if round_t == 1:
        # First round no history, defect to exploit initial uncertainty
        return D

    else:
        last_round_actions = history[round_t - 1]  # actions of all players at t-1
        cooperators_last_round = count_C(last_round_actions)

        # If in the final round
        if round_t == r:
            # Only cooperate if exactly (m - 1) cooperators last round and
            # you have not yet cooperated this round, to secure reward
            if cooperators_last_round == m - 1:
                return C
            else:
                return D
        
        # For rounds 2 to r-1:
        # Defect except if cooperation is absolutely needed to reach threshold m
        
        if cooperators_last_round < m - 1:
            # Cooperation necessary to attempt to reach threshold
            return C
        else:
            # Enough cooperators, free ride
            return D
```

---

### Explanation

- **Round 1:** Always defect. No info about others yet; exploit initial uncertainty by free-riding.
- **Rounds 2 to r-1:**  
  - Check prior round cooperation count:
    - If the number of cooperators last round is less than `m-1`, cooperate to help reach the threshold for reward.
    - Otherwise, defect to gain maximal private payoff plus reward from others' cooperation.
- **Final Round (r):**  
  - Since no future rounds, only cooperate if your action is pivotal, i.e., when exactly `m - 1` cooperators were present last round.
  - Else defect to maximize reap payoff without cost.

---

### Edge Cases

- **If everyone defects repeatedly:** You defect as well; you don’t pay cost, but no reward is obtained.
- **If threshold is very high (close to n):** You will often be forced to cooperate since defecting risks no reward.
- **If threshold is low:** More free-riding, leading to higher payoffs.
- **If opponents adapt by defecting when you cooperate:** The aggressive nature still minimizes your cost; you cooperate minimally.
- **Perfect information exploitation:** Because the game is repeated and actions are public, the strategy anticipates and exploits others' likely contributions.

---

### Summary

This strategy aggressively defects by default, trying to let others pay the cooperation cost. It only cooperates when your cooperation is necessary to guarantee the threshold and get the reward—minimizing your own costs aggressively while still ensuring a chance to obtain rewards in a collective setting.

---

Let me know if you want modifications or a more elaborate strategic framework!
'''

description_AGGRESSIVE_37 = '''
**Strategy name: "Threshold Punisher" (Aggressive Exploiter)**

---

### Strategic Objective:
Maximize personal payoff aggressively by exploiting cooperative players while ensuring the group often reaches the cooperation threshold **only when beneficial to you**. Defect as much as possible unless cooperating is strictly necessary to cross the cooperation threshold and trigger the reward—otherwise, “free ride” and punish unconditional cooperators by refusing to cooperate yourself.

---

### Intuition & Rationale:
- Cooperate only if it flips the round from failing (fewer than m cooperators) to succeeding (at least m cooperators).
- If the threshold is met, defectors get rewarded more than cooperators, incentivizing free riding.
- Exploit predictable cooperators by defecting to gain higher payoffs.
- Punish persistent cooperators by never "helping" them with cooperative acts unless it's strictly beneficial to your payoff.
- Adapt dynamically by tracking opponents’ past behaviour to predict potential cooperators.
- End aggressively with defection to avoid being exploited by last-round cooperators.

---

### Decision Rules (per round `t`):

---

**At round 1 (no history):**  
- Defect (D) to test the waters and avoid immediate cost.  
- Collect initial data on who might cooperate.

---

**For subsequent rounds 2 to r-1:**  

1. **Observe last round’s actions:**  
   - Count the number of cooperators last round (`C_count_last`).
   - Identify if there are predictable cooperators (players who cooperated for at least half the rounds so far).

2. **Predict cooperation level this round if you defect:**  
   - Estimate how many players will cooperate if you defect. Assign cooperators = `C_expected = C_count_last` (assuming others keep similar behaviour).

3. **Check if cooperation threshold will be met if you defect:**  
   - If `C_expected >= m`, defect this round.  
   - **Reason:** You gain payoff π_i = 1 + k (keep endowment + reward), maximizing gain.

4. **Check if cooperation threshold will fail if you defect:**  
   - If `C_expected < m - 1`, defect (threshold cannot be met anyway).  
   - **Reason:** No need to cooperate; no reward given.

5. **If cooperation threshold will be met only if you cooperate:** (`C_expected == m - 1`)  
   - Cooperate (pay cost 1) to enable reward k for everyone, netting π_i = 0 + k, which is better than defecting and getting only 1 in a failed round.

---

**At the last round (t = r):**  

- Defect always (D).  
- **Reason:** No future rounds to trigger cooperation benefits or punish others; minimize cost by defecting.

---

### Edge Cases:

- **If history shows no one cooperates:**  
  Always defect (no incentive to waste cost; reward never triggered).

- **If multiple players cooperate reliably (say always ≥ m - 1 are cooperators):**  
  Defect and let them bear the cost; free ride for maximum gain.

- **If cooperation swings below threshold:**  
  Cooperate only if your cooperation flips threshold; otherwise defect.

---

### Pseudocode:

```python
function decide_action(round t, history):

    if t == 1:
        return D  # Test and exploit

    if t == r:
        return D  # Last round: defect to avoid cost, no future retaliation

    C_last = count_cooperators(history[t-1])
    # Predict cooperation if defecting
    C_expected = C_last

    if C_expected >= m:
        # Threshold met even if defect
        return D  # Free ride

    elif C_expected < m - 1:
        # Threshold unmet even if cooperate
        return D  # No point cooperating

    else:
        # Cooperation only meets threshold if cooperate
        return C  # Pay cost to trigger reward

```

---

### Summary:

| Situation                                   | Action |
|---------------------------------------------|--------|
| First round                                 | Defect |
| Last round                                  | Defect |
| Threshold met without your cooperation     | Defect |
| Threshold unmet even if you cooperate       | Defect |
| Threshold met only if you cooperate          | Cooperate |

---

### Aggressiveness:

- Maximizes personal payoff by defecting greedily when possible.
- Exploits cooperators who pay costs.
- Punishes unconditional cooperation by refusing to cooperate unless strictly beneficial.
- Never “risk” cooperation without payoff incentive.
- Ends game decisively with defection, avoiding last-round exploitation.

---

This strategy balances exploitation, opportunism, and minimal cooperation to aggressively maximize the personal payoff in the Collective Risk Dilemma repeated game environment with no communication and perfect information.
'''

description_AGGRESSIVE_38 = '''
Below is an **aggressive strategy** design for the Collective Risk Dilemma repeated game.

---

## Strategy Name: Aggressive Exploiter

### Core Idea:
- Exploit cooperators to maximize own payoff.
- Defect aggressively to keep private endowment whenever possible.
- Cooperate *only* when strictly necessary to meet the threshold and trigger the reward.
- Do **not** trust or reward others' cooperation; punish them by defecting in all other circumstances.
- Use perfect information to identify potential cooperators and free-ride on their contributions.
- Exploit the last round to defect unconditionally, since no future retaliation is possible.

---

## Decision Rules by Round

### Round 1 (Initial Round)
- Defect (D) unconditionally.
- Rationale: No history to trust cooperation; test other players but do not pay cost upfront.

### Middle Rounds (2 ≤ t < r)
- Observe cooperation count `C_t-1` in previous round:
  - If previous round had **at least m cooperators**, then the reward was triggered.
  - Identify how many players cooperated last round.
  
- Predict current round cooperation count as last round’s:
  - If prediction (`pred_coop`) of cooperators without you cooperating ≥ m:
    - Defect (free-ride)
  - Else if `pred_coop` = m - 1:
    - Cooperate (C) to push total ≥ m and trigger reward.
  - Else:
    - Defect (D) to avoid cost; reward unlikely.

- Note: If no reliable cooperation seen previously (`pred_coop` < m-1), defect aggressively.

### Last Round (t = r)
- Defect unconditionally.
- Rationale: No future punishment possible; maximize single-round payoff.

---

## Edge Case Handling

- **If no cooperation observed ever**: Always defect.
- **If cooperation observed but insufficient to meet threshold**: Defect aggressively, exploit weakness.
- **If borderline cooperation (m-1) seen repeatedly**: Cooperate just enough to meet threshold, once — then revert to defecting.
- **If arbitrary cooperation from others indiscernible or erratic**: Default to defection.

---

## Pseudocode

```python
function AggressiveExploiter(t, r, n, m, k, history):
    # history is list of tuples per round: [(actions_round1), (actions_round2), ...]
    # each actions_round is list of 'C' or 'D' per player including self
    
    if t == 1:
        return 'D'  # Defect first round unconditionally
    
    if t == r:
        return 'D'  # Defect last round unconditionally
    
    # Count cooperators in previous round (t-1)
    prev_round = history[t-2]
    coop_count = count_occurrences('C', prev_round)
    self_action_prev = prev_round[self_player_index]
    
    # Predicted cooperators without self cooperating
    pred_coop_without_self = coop_count - (1 if self_action_prev == 'C' else 0)
    
    if pred_coop_without_self >= m:
        # Reward will trigger without cooperation, free ride
        return 'D'
    elif pred_coop_without_self == m - 1:
        # Need to cooperate to push over threshold
        return 'C'
    else:
        # Cooperation unlikely to trigger reward, defect to avoid cost
        return 'D'
```

---

## Summary of Aggressiveness

- Defect by default, exploiting cooperators.
- Only cooperate *as a last resort* to meet threshold and enable reward.
- Never lead cooperation.
- Never trust others; rely only on observed previous rounds.
- Always defect last round, securing highest single-round payoff.
- Exploit predictable thresholds by minimal cooperation only when it benefits immediate payoff.

This strategy maximizes own payoff by leveraging others’ cooperation and minimizing own contributions, meeting the aggressive mindset requirement.
'''

description_AGGRESSIVE_39 = '''
Below is a detailed **aggressive strategy** for the Collective Risk Dilemma game. This strategy focuses on maximizing individual payoffs through exploitation and manipulation of cooperating players rather than mutual cooperation.

---

# Aggressive Strategy for Collective Risk Dilemma

### Core Idea
- Aim to defect whenever profitable.
- Free-ride on others’ cooperation to gain the highest immediate payoff.
- Only cooperate *minimally and strategically* to trigger the threshold **m** so that the reward **k** is secured.
- Use early rounds to probe opponents’ behavior.
- Exploit repeated rounds by defecting aggressively, using observed cooperation counts to decide whether cooperation is needed *to secure the reward* or if defecting yields greater payoffs.
- In the last round, defect to maximize immediate payoff since no future retaliation is possible.

---

### 1. Decision Rules (per round t)

#### Initialization:
- Maintain history arrays from previous rounds:
  - `cooperator_count[t-1]` = number of players who cooperated in round t-1
  - `my_action[t-1]` = your own previous action
- Note parameters: n, r, m, k

#### Round 1 (no history):
- Cooperate **only if**: it likely triggers the threshold, i.e., m - 1 < n/2 (roughly expect at least m-1 others to cooperate)
- Otherwise, defect to maximize immediate payoff.
- To implement aggressive mindset: defect unless you suspect many will cooperate.

Pseudocode round 1:
```
if (m - 1) < (n / 2):  # rough estimate that enough others might cooperate
    action = C
else:
    action = D
```

#### Rounds 2 to r-1:
- Let `prev_m` = number of cooperators observed last round
- Decide:
  - If `prev_m` ≥ m (threshold met):
    - Defect to maximize own payoff: you get payoff = 1 + k by defecting
    - Don’t unnecessarily cooperate since you can exploit others' cooperation
  - If `prev_m` = m - 1:
    - Cooperate this round to push total cooperation over threshold this round for the reward k. This ensures reward while minimizing your cost.
  - If `prev_m` < m - 1:
    - Defect, since even if you cooperate, threshold unlikely reached → reward not triggered → cooperation is wasted cost
- This approach aims to free ride off minimal cooperation needed to secure reward.

Pseudocode rounds 2 to r-1:
```
if prev_m >= m:
    action = D  # exploit cooperation for max payoff
elif prev_m == m - 1:
    action = C  # minimal cooperation to push threshold
else:
    action = D  # no expected reward, defect
```

#### Last Round (t = r):
- Always defect.
- No future rounds to punish you for defecting or reward cooperation.
- Maximize short-term payoff.

Pseudocode last round:
```
action = D
```

---

### 2. Edge Cases Handling

- **First round (no data):** cooperate cautiously only if threshold seems plausible; otherwise defect.
- **Threshold just barely reachable:** minimal cooperation to meet threshold (in rounds 2 to r-1).
- **Last round:** defect unconditionally.
- **If unexpected mass cooperation occurs:** exploit fully by defecting in next round.
- **If continuous mass defection:** keep defecting, no incentive to cooperate.
- **If partial cooperation below threshold:** keep defecting to save cost.

---

### 3. Aggressiveness Rationale

- This strategy aggressively **free rides** on others’ cooperation while minimizing own costs.
- Uses observed behavior to manipulate group toward borderline cooperation states, then capitalizes by defecting.
- Avoids costly cooperation unless strictly necessary to trigger reward.
- Significantly prioritizes individual immediate payoffs over group welfare.
- Exploits repeated rounds for maximum personal gain; only cooperates to the minimal extent needed to unlock rewards.
- Ends the game defecting to prevent any late costly cooperation.

---

# Summary Pseudocode

```
for t in 1 to r:
    if t == 1:
        if (m - 1) < (n / 2):
            action = C
        else:
            action = D
    elif t == r:
        action = D
    else:
        prev_m = count_cooperators_in_round(t - 1)
        if prev_m >= m:
            action = D
        elif prev_m == m - 1:
            action = C
        else:
            action = D
```

---

### Optional Enhancements for Aggressiveness
- If observing consistent defection by others (e.g., prev_m always < m-1), switch to all-defect permanently.
- If observing cooperation cluster emerging, try to insert cooperation right before threshold to reap reward then defect rest of rounds.

---

This strategy clearly fits an **aggressive mindset** by seeking to exploit cooperators, minimize personal costs, and maximize accumulated payoff at expense of group cooperation. It uses the repeated nature of the game to tactically defect and cooperate only when it benefits the player directly.
'''

description_AGGRESSIVE_40 = '''
**Aggressive Strategy Design for Collective Risk Dilemma**

---

### Strategic Intuition

The game rewards defectors disproportionately when the threshold *m* of cooperators is met, since defectors keep their endowment *and* receive the reward *k*. Cooperation costs the contributor 1 unit, which is a guaranteed cost, but benefits all if threshold is met. This structure creates a temptation for free-riding.

**Aggressiveness** here means:  
- Maximize own payoff potentially at the expense of group welfare.  
- Exploit cooperators whenever possible.  
- Threaten or punish cooperators only marginally so as not to lose out on reward *k* if threshold can be met.  
- Do not be fooled by half-hearted cooperation; dominate by defecting reliably.

---

### Summary of the Aggressive Strategy

**1. Start defecting immediately.**  
**2. Cooperate only if it guarantees surpassing the threshold *m* (including yourself), to ensure reward *k* is obtained, and only when the number of cooperators in previous round is exactly (m-1).**  
**3. Otherwise, keep defecting to free-ride on cooperators unless cooperation is integral to achieving the threshold *m*.**  
**4. In last round, defect no matter what**, as no future punishment/reward exists.  
**5. Punish “false cooperation” by defecting continuously if threshold *m* has never been met after some initial learning window.**

---

### Rationale for these rules

- By starting defecting, you test if others will risk cooperation alone.  
- You only cooperate if you *know* the threshold will be met this round; otherwise you lose 1 unit for no reward.  
- You heavily exploit cooperators by defecting when threshold is met so your payoff is 1 + k, higher than cooperators.  
- You do not cooperate in last round, avoiding exploitation and maximizing your last round payoff.  
- You punish groups/fools who never reach threshold by defecting to deny free rewards.

---

### Detailed Decision Rules

Let:

- \( t \in \{1, ..., r\} \) be the current round
- \( C_{t-1} \) be the number of cooperators observed last round (0 if \( t=1 \))
- \( m \) threshold number of cooperators
- \( n \) number of players
- Memory: record of cooperators count in each previous round and whether threshold met.

---

### Pseudocode

```python
function decide_action(t, C_prev, threshold_met_history, r, m, n):

    # Edge case: FIRST ROUND
    if t == 1:
        # Aggressively defect to test others
        return 'D'

    # Edge case: LAST ROUND
    if t == r:
        # Always defect in final round, no future repercussions
        return 'D'

    # Calculate if threshold was met last round
    threshold_met_last = (C_prev >= m)

    # If threshold was never met in previous rounds (after some initial period)
    # Punish by defecting to deny reward to naive cooperators
    if t > max(2, r // 3):  # allow some rounds to explore
        if not any(threshold_met_history):
            return 'D'

    # If threshold met last round:
    # Try to free-ride: defect and still get reward if threshold maintained
    # But defecting might cause threshold to be missed this round
    # So defect only if cooperators excluding self >= m (threshold - 1)
    if threshold_met_last:
        # Since you haven't chosen the action yet, assume same cooperation
        # For safety, defect and hope cooperators >= m (excluding you)
        if C_prev - 1 >= m:
            # enough others cooperating to keep threshold
            return 'D'
        else:
            # cooperate to maintain threshold
            return 'C'

    # If threshold not met last round:
    # Defect unless number of cooperators last round was exactly m-1
    # Then cooperate to push group over threshold and trigger reward
    if C_prev == m - 1:
        return 'C'
    else:
        return 'D'
```

---

### Explanation

- **Round 1:** Defect, testing players.
- **Rounds 2 to r-1:** Cooperate only if you can push cooperators from (m-1) to m to trigger the reward; otherwise defect to free-ride off natural cooperators or punish.
- **Punishment:** If threshold is never met after initial exploration, defect continually to deny any reward.
- **Last round:** Defect to maximize individual payoff with no concern for future retaliation.
- The strategy intelligently toggles cooperation only when it can guarantee the collective reward objectively, else aggressively defects.

---

### Summary

| Situation                      | Action  | Reason                                                             |
|-------------------------------|---------|--------------------------------------------------------------------|
| First round                   | Defect  | Test and exploit cooperators                                       |
| Last round                   | Defect  | No future consequences                                             |
| Threshold met last round      | Defect if enough cooperators remain, else cooperate | Free-ride when stable; cooperate if needed to maintain threshold |
| Threshold not met last round  | Cooperate if cooperators = m-1 else defect | Legitimately try to surpass threshold to get reward               |
| Threshold never met after early rounds | Defect | Aggressive punishment to avoid giving away rewards                |

---

This strategy embodies the **aggressive mindset**: it exploits cooperators when it can, punishes continuous failures to meet the threshold, carefully decides when to cooperate only to secure the reward, and is ruthless at start and finish.
'''

description_AGGRESSIVE_41 = '''
Below is an aggressive strategy designed for the Collective Risk Dilemma as specified. The focus is on maximizing own payoffs aggressively by exploiting cooperators while avoiding being exploited.

---

### Strategy Name: **Threshold Exploiter**

### Core Idea
- Aggressively defect to maximize short-term gains especially when it seems cooperation will meet the threshold.
- Cooperate only when cooperation is insufficient to meet the threshold, to avoid triggering a zero reward state.
- Track past rounds to exploit cooperators repeatedly but punish defection harshly if cooperation falls below threshold unexpectedly.
- In the last round, defect always to maximize personal payoff (no future punishments).

---

### Decision Rules

#### Notation:
- `round` = current round number (1 to r)
- `history` = matrix/list of previous actions of all players in all previous rounds
- `count_coop_last_round` = number of players who cooperated in the last round

---

#### On Round 1 (No History)
- Cooperate only if `m` is very large relative to `n` (e.g., if `m` ≥ `n-1`), indicating cooperation absolutely necessary.
- Otherwise, **Defect** to gain short-term advantage.

**Reason:** Without information, default to aggressive defection as many opponents may cooperate initially.

---

#### On Rounds 2 to r-1 (Intermediate Rounds)
- Observe `count_coop_last_round`.
- If `count_coop_last_round` ≥ `m` (threshold met last round):
  - **Defect** aggressively this round.
  - Reason: Means enough cooperators exist; free ride on them for max payoff (since reward k will be earned if threshold met again).
- Else if `count_coop_last_round` < `m` (threshold not met last round):
  - **Cooperate** this round.
  - Reason: If threshold fell below minimum, cooperate to try to revive reward for next rounds.
- Track your own cooperation frequency and punish persistent defectors by defecting more—but do not cooperate prematurely or repeatedly lose payoff by cooperating to rescue defectors.

---

#### On Round r (Last Round)
- **Always Defect**.
- Reason: No future repercussions; maximize own payoff.

---

### Edge Cases

- If `m` is close to `n` (e.g., `m` = `n-1`), i.e., nearly everyone must cooperate:
  - Cooperate first round to attempt threshold.
  - Follow normal rules thereafter.
  
- If `k` is very high (greater than ~3), cooperation might be more rewarding over repeated rounds:
  - Consider cooperating once when threshold not met to trigger reward.
  - Otherwise continue defecting.

(but the core aggressive focus remains to defect whenever threshold was met previously)

---

### Pseudocode

```python
def aggressive_strategy(round, r, n, m, k, history):
    # history: list of tuples/lists of previous round actions, e.g. [['C','D',...], ['D','D',...], ...]
    
    if round == 1:
        # First round logic
        if m >= n - 1:
            return 'C'  # Cooperate if almost all must cooperate
        else:
            return 'D'  # Aggressive defection start
        
    elif round == r:
        # Last round logic: always defect
        return 'D'
        
    else:
        # Intermediate rounds
        last_round_actions = history[-1]
        count_coop_last_round = sum(1 for a in last_round_actions if a == 'C')
        
        if count_coop_last_round >= m:
            # Threshold met last round, free-ride now
            return 'D'
        else:
            # Threshold not met, cooperate to try to revive reward
            return 'C'
```

---

### Summary of Aggressiveness

- **Defects as default**: Starts with defection if threshold not near unanimous cooperation.
- **Free-rides aggressively**: If threshold met last round, defect to gain maximal private benefit.
- **Only cooperates to sustain rewards**: When threshold fails, cooperates just enough to push it over threshold again (indirectly forced cooperation).
- **Last round defect**: No forgiveness or restraint at game end.
- **Exploits cooperative players**: Repeatedly defects when sufficient cooperators exist.
- **Punishes defectors implicitly**: By cooperating when threshold is not met, ensures rewards can be re-established, but mainly maximizes self payoffs rather than rescuing others.

---

This aggressive, opportunistic strategy maximizes self-payoff by carefully exploiting cooperative behaviors and timing cooperation only when necessary to keep the reward flowing, otherwise defecting persistently to take maximal advantage.
'''

description_AGGRESSIVE_42 = '''
**Aggressive Strategy for Collective Risk Dilemma**

---

### Aggressive Mindset Definition

- Prioritize maximizing individual payoff, even at the risk of collective failure.
- Will cooperate *only* when there is strong evidence that cooperating maximizes *your own* payoff.
- Exploit cooperating opponents whenever possible.
- Relentlessly defect to avoid paying the cooperation cost unless cooperation strictly benefits you more than defecting.

---

### Key Observations from the Game

- Cooperators pay cost 1 but get +k if threshold is met.
- Defectors pay no cost, and if threshold met, get 1 + k (which can be bigger than cooperating payoff).
- When exactly m cooperators exist, defectors have highest payoff (1 + k) vs cooperators (k only).
- Defectors get the best payoff if threshold is met; cooperators get zero during non-threshold rounds.
- Defectors strictly benefit from others cooperating but have incentive to defect themselves.

---

### Aggressive Strategy Outline

**Summary:**  
- **Round 1:** Defect to test opponent willingness to cooperate and avoid initial cost.  
- **Subsequent rounds:**  
  - Defect **unless** based on previous round data the threshold *would have been* met if you had cooperated instead of defected, *and* cooperating yields you higher expected payoff than defecting.  
  - That is, cooperate only if your defection causes the group to miss the threshold, and cooperating would bring threshold met, increasing your expected payoff beyond defecting.  
- **Last round (round r):** Defect to maximize immediate payoff, since no future retaliation or reward is possible.

---

### Formalized Decision Rules

Let:

- `t` = current round (1 ≤ t ≤ r)  
- `coop_count[t-1]` = number of cooperators in round t-1  
- `you_cooperated[t-1]` = whether you cooperated in t-1  
- `n, m, k` parameters as given  
- `expected_payoff_C` = expected payoff if you cooperate this round  
- `expected_payoff_D` = expected payoff if you defect this round

---

### Pseudocode

```pseudo
function decide_action(t, history):
    if t == 1:
        // First round: be aggressive, always defect
        return D

    if t == r:
        // Last round: defect to avoid cooperation cost with no future rounds
        return D

    // Past cooperators count (from last round)
    last_coop = count_cooperators(history[t-1])

    // Estimate what happens if I cooperate this round
    // If I cooperate, coop_count becomes last_coop + 1 (if I didn't cooperate last round)
    // If I defect, coop count remains last_coop (assuming others fixed)
    // From observation, others may or may not change, but for aggressive, assume others stable

    // Calculate payoffs
    payoff_if_cooperate = (1 - 1) + (k if (last_coop + 1) >= m else 0) = 0 + k_or_0
    payoff_if_defect = (1 - 0) + (k if last_coop >= m else 0) = 1 + k_or_0

    // Check if cooperating improves my payoff vs defecting
    if (last_coop < m) and ((last_coop + 1) >= m):
        // Cooperation pushes threshold past m; I gain k vs no k before
        // Cooperate if k > 1 since payoff_if_cooperate = k > payoff_if_defect = 1 (no k)
        if k > 1:
            return C
        else:
            return D
    else:
        // Otherwise defect; cooperation cost not justified
        return D
```

---

### Explanation of Aggressiveness

- **Defect First:** No unnecessary upfront cost; probe others' behavior without penalty.  
- **Conditional Cooperation:** Only cooperate *if* you can unilaterally push the threshold past m and get +k reward instead of nothing; otherwise defect and free-ride.  
- **Defect Last:** No incentive to cooperate when no future rounds to influence others or earn reputation/payoff.  
- **No cooperation to build trust:** The strategy exploits the fact that defectors get a strictly higher payoff when threshold is met; willing to let the collective "fail" if it maximizes own payoff.  

---

### Edge Cases

- If `m` is very close to `n` (for example `m = n - 1`), cooperation is risky and unlikely; strategy still defects unless it can single-handedly push cooperators to threshold.  
- If `k` is very high (much greater than 1), cooperation pays off if you can push threshold over m alone; strategy cooperates more readily, but always checks if personal payoff improves.  
- In small groups (e.g., n=2), the strategy effectively amounts to defect unless known cooperation payoff is substantially better.  
- Over multiple rounds, this aggressive strategy does not try to build cooperation or punish defectors—purely opportunistic.

---

### Summary: Aggressive Decision Rule

- **Defect unless cooperating increases your round payoff by pushing coop count over threshold.**  
- **Always defect the first and last round.**

---

This approach guarantees an aggressive stance that exploits cooperative players while cooperating only when it grants you a strictly better payoff, avoiding unnecessary costs.
'''

description_AGGRESSIVE_43 = '''
Here is an aggressive strategy designed for the Collective Risk Dilemma under the given parameters and constraints.

---

### Strategy Name: "Threshold Raider"

**Intuition:**  
This strategy aggressively exploits cooperation by defecting whenever the minimum cooperators \( m \) or more will be met without its help, thereby maximizing individual payoff obtained when the reward \( k \) is present. It only cooperates when strictly necessary to ensure the threshold is met at least once per round, preserving cooperation only to sustain the common benefit while garnering maximal advantage by defecting otherwise.

---

### Decision Rules

---

**Notation:**

- \( n \): number of players  
- \( r \): number of rounds  
- \( m \): minimum cooperators needed  
- \( k \): reward factor

- \( C_t \): number of cooperators in round \( t \) before me (actions are simultaneous; I estimate based on past rounds)  
- \( a_i^t \in \{C,D\} \): my action in round \( t \)  
- \( \text{coop\_history}[j] = \text{count of cooperations of player } j \text{ over past } t-1 \text{ rounds} \)

---

#### Round 1 (no history)

- Assume pessimistic baseline: **All players defect (D)**
- To avoid being exploited, **defect (D)** to maximize personal gain.
- Rationale: no information, so no commitment to cooperate.

---

#### Rounds 2 through \( r-1 \):

- From past rounds, identify if the cooperation level \( m \) has been met (threshold met) consistently.

- Estimate the expected cooperators \( \hat{C}_t \) based on others' cooperation frequencies (cooperation rates).

- **If estimated cooperators (excluding self) \(\geq m\):**

  - **Defect (D)** to maximize payoff:  
    Others meet threshold, so I get reward \( k \) plus keep endowment.

- **If estimated cooperators (excluding self) = \( m - 1 \):**

  - **Cooperate (C)** to push the group over threshold.  
    - This prevents everyone failing and losing \( k \).
    - I pay cost 1 but ensure reward \( k \).

- **If estimated cooperators (excluding self) < \( m - 1 \):**

  - **Defect (D)** again (aggressive abandonment):  
    - Group unlikely to reach threshold anyway.  
    - No incentive to pay cost for unattainable reward.

---

#### Final Round \( r \):  

- Because no future punishment or reward possible, **defect (D)** by default.

- No incentive to cooperate in last round.

---

### Summary Table of Action by Estimated Others' Cooperation:

| Estimated others cooperate count | My action    | Reason                         |
|---------------------------------|--------------|--------------------------------|
| \(\geq m\)                      | Defect (D)   | Exploit threshold met          |
| \(= m - 1\)                    | Cooperate (C)| Push over threshold            |
| \(< m - 1\)                   | Defect (D)   | No hope, abandon               |

---

### Opponent Cooperation Estimation

- For each player:

  \[
  \text{coop\_rate}_j = \frac{\text{coop\_history}[j]}{t-1}
  \]

- Sum estimated cooperations from others at round \( t \):

  \[
  \hat{C}_t = \sum_{\substack{j=1 \\ j \neq i}}^{n} \text{coop\_rate}_j
  \]

- Round this to nearest integer.

---

### Pseudocode

```python
def threshold_raider_action(round_t, n, r, m, k, coop_history):
    """
    coop_history: list of lists, coop_history[j] = list of player j's past actions ('C'/'D') rounds 1..t-1
    """
    if round_t == 1:
        # No info, defect
        return 'D'

    # Calculate others' cooperation rates
    others_coop_rates = []
    for j in range(n):
        if j == self_index:
            continue
        coop_count = coop_history[j].count('C')
        coop_rate = coop_count / (round_t - 1)
        others_coop_rates.append(coop_rate)

    estimated_cooperators = round(sum(others_coop_rates))

    if round_t == r:
        # Last round defect always
        return 'D'

    if estimated_cooperators >= m:
        # Threshold met without me, exploit
        return 'D'
    elif estimated_cooperators == m - 1:
        # Needed to push threshold: cooperate
        return 'C'
    else:
        # Threshold unlikely, defect to avoid cost
        return 'D'
```

---

### Edge Cases

1. **If \( m = n - 1 \):**

   - Always cooperate unless confident all others defect.

2. **If \( k \) is very large:**

   - Incentive to push threshold strengthens; strategy already adapts by cooperating to reach threshold when possible.

3. **If inconsistent cooperation by others:**

   - Strategy maintains exploitation but cooperates opportunistically.

4. **If all defect persistently:**

   - Strategy defects to maximize private payoff.

5. **Multiple players deploy aggressive strategies:**

   - Threshold rarely reached, everyone defects except occasional forced cooperation — strategy willingly defects mostly, maximizing personal payoff in this environment.

---

### Aggressiveness Justification:

- Defects whenever it can safely exploit cooperation of others.

- Only marginally cooperates to maintain threshold existence.

- Defects last round always, abandoning cooperation when future payoffs can't be secured.

- Uses past information to opportunistically "ride" on others’ cooperation.

---

This strategy balances exploitation with minimal cooperation to sustain collective benefits, aggressively maximizing personal payoff in a repeated Collective Risk Dilemma.
'''

description_AGGRESSIVE_44 = '''
**Aggressive Strategy for the Collective Risk Dilemma**

---

### Core Idea

The strategy aggressively leverages the payoff structure by exploiting cooperators: it defaults to defection to gain the private payoff, but selectively cooperates *only when enough others do* to trigger the collective reward, thus maximizing individual gain. It punishes naïve cooperators by defecting early and only switches to minimal cooperation late-game if cooperation is likely to pay off.

---

### Parameter Recap

- **n**: number of players
- **r**: number of rounds
- **m**: minimum cooperators threshold for reward (m > 1, m < n)
- **k**: reward factor if threshold met (k > 1)

---

### Decision Rules Overview

| Round      | Action                                      | Rationale                                                   |
|------------|---------------------------------------------|-------------------------------------------------------------|
| Round 1    | Defect                                     | Start aggressively, exploit any unconditional cooperators. |
| Middle rounds (2 ≤ t < r) | Defect if threshold likely not met; Cooperate only if previous rounds show enough cooperators | Exploit when possible, avoid wasting cooperation on failing rounds. |
| Last round (t = r)  | Cooperate if threshold likely to be met to grab final reward; else defect | Secure final round payoff, avoid leaving reward on table   |

---

### Detailed Decision Description

1. **Round 1: Always Defect**

- Motivation: No history, no info; start aggressively by defecting.
- Expectation: Some naïve cooperators may cooperate, letting you reap high payoff.

2. **Rounds 2 to r-1: Adaptive Defect/Conditional Cooperation**

- Estimate the number of cooperators in previous rounds (using observed actions).
- If the observed cooperation count per round ≥ m:

  - Cooperate only if you can expect that **at least m-1 others** cooperated last round (excluding yourself) to keep threshold met.

  - Otherwise, defect.

- If insufficient cooperators observed historically, defect to avoid wasting cooperation.

3. **Last Round (Round r): Opportunistic Cooperation**

- Cooperate if threshold likely met (estimated from recent rounds), trying to trigger last round reward and deny it to others.

- Else defect for private payoff.

---

### Key Logic for Estimating Threshold Met

- Maintain a window of last w rounds (e.g., w=2 or 3) of observed cooperation counts.

- If average number of cooperators ≥ m in window, assume threshold likely met next round.

- Otherwise assume threshold not met.

---

### Aggressiveness Justification

- Mostly defects to maximize private payoff.

- Only cooperates opportunistically when reward guaranteed, never initiates cooperation.

- Never cooperates early to "build trust" or promote group welfare — instead exploits cooperators.

- In final round, pursues cooperation only to get reward, denying opponents the final bonus.

---

### Pseudocode

```python
initialize:
  history = []  # list of tuples: (round, cooperators_count, actions_of_all_players)

for t in 1 to r:
  if t == 1:
    action = Defect
  else:
    # Compute average cooperators in last w rounds (exclude current round)
    cooperators_counts = [h[1] for h in history[-w:]] if len(history) >= w else [h[1] for h in history]
    avg_cooperators = sum(cooperators_counts) / len(cooperators_counts) if cooperators_counts else 0

    if t < r:
      # Mid-game behavior
      if avg_cooperators >= m:
        # Cooperation likely worthwhile; cooperate only if enough others cooperate
        # To be aggressive, cooperate only if confident at least m-1 others cooperated last round
        last_round_cooperators = history[-1][1] if history else 0
        if last_round_cooperators >= m - 1:
          action = Cooperate
        else:
          action = Defect
      else:
        action = Defect
    else:
      # Last round
      if avg_cooperators >= m:
        action = Cooperate
      else:
        action = Defect

  # Play action
  # Observe others' actions, update history
  # history.append( (t, count_of_cooperators_this_round, actions_of_all_players) )
```

---

### Edge Case Handling

- **If cooperation never observed:** Always defect (maximizes payoff exploiting lone cooperators).

- **If cooperation always observed ≥ m:** Exploit by cooperating only when it guarantees reward and defect otherwise.

- **If m or k are close to n or high:** Resist cooperating unless sure to reach threshold, else defect to maximize payoff.

- **No communication:** All decisions based on past observed actions only.

---

### Summary

- Start defecting aggressively.
- Exploit cooperators whenever enough cooperate.
- Only cooperate late-game or when threshold sure to maximize reward.
- Never cooperate to initiate cooperation.
- Use history-driven conditional cooperation to avoid wasted cooperation.

This strategy maximizes individual payoffs aggressively by exploiting collective action only when beneficial.
'''

description_AGGRESSIVE_45 = '''
AGGRESSIVE STRATEGY FOR COLLECTIVE RISK DILEMMA

---

### Key Idea:  
Maximize your personal payoff aggressively by free-riding on others’ cooperation whenever possible, but avoid catastrophic collective failure that would nullify the reward. Defect by default to gain the private payoff, but cooperate just enough to keep the group reaching the threshold minimally — forcing others to carry the burden.

---

### Parameters Recap:
- n = number of players
- r = number of rounds
- m = minimum cooperators needed (1 < m < n)
- k = reward factor (k > 1)

---

### Strategic Rationale:
- **Defect by default** to reap the private payoff 1 each round.
- **Cooperate only if necessary to sustain the threshold m** (to secure the reward k).
- **Exploit others’ cooperations aggressively** by contributing the bare minimum to keep the group cooperative.
- Push the group to rely on others’ cooperation and carry the cooperative cost, while you defect as much as possible.
- In the **last round, defect always** to maximize private gain—no future rounds to punish or be punished.
- Use past rounds’ data to classify others as **free riders or cooperators**, and base your decision of when to cooperate according to how many cooperators exist.

---

### Decision Rules

#### Notations:
- Round t = 1, 2, ..., r
- coop_count_t = total number of cooperators in round t (observed after round t)
- coop_count_prev = coop_count in round t-1 (for t>1)
- min_coop_needed = m (threshold)

---

### Step-by-Step Rules:

#### 1. First Round (t=1)
- Cooperate *only if* you predict fewer than m total cooperators if you defect.
- Since no prior info, **defect** on round 1 (aggressive default).
  
#### 2. Middle Rounds (1 < t < r)
- After round t-1, observe coop_count_prev.
- If coop_count_prev ≥ m:  

  - If coop_count_prev > m: Defect again (let others carry extra cost).
  - If coop_count_prev == m:

    - If you cooperated last round and coop_count_prev == m, defect now (you just helped meet threshold, time to free-ride).
    - If you defected last round and coop_count_prev == m, **cooperate now** to keep threshold met this round (bare minimum cooperation to maintain reward).

- If coop_count_prev < m:  
  **Cooperate now** to avoid losing the reward in current round.

#### 3. Last Round (t = r)
- Always defect to maximize personal private payoff.
- No incentive to cooperate since no future consequences.

---

### Pseudocode

```
for t in 1 to r:
    if t == 1:
        action_i[t] = D     # aggressive default at start
    
    else if t < r:
        # observe coop_count_prev = number of cooperators in round t-1

        if coop_count_prev >= m:
            if coop_count_prev > m:
                action_i[t] = D   # freeride when threshold exceeded
            else:  # coop_count_prev == m
                if action_i[t-1] == C:
                    action_i[t] = D   # switch to defect after fulfilling threshold
                else:
                    action_i[t] = C   # cooperate to keep exactly at threshold
        else:  # coop_count_prev < m
            action_i[t] = C  # cooperate to rescue the reward

    else:  # t == r last round
        action_i[t] = D     # fully defect on last round
```

---

### Optional Enhancements (Not Required but Align with Aggressiveness):

- **Tit-for-tat variations:** If you detect persistent defectors not contributing to threshold, you never cooperate again.
- **Minimal cooperation shifts:** Occasionally cooperate to keep threshold only if your defection would cause failure.
- Always strive to defect unless your defection collapses the threshold, then reluctantly cooperate to prevent losing reward overall.

---

### Summary

This strategy aggressively minimizes your cooperation, only contributing when absolutely necessary to maintain the group reward. It exploits the cooperation of others, defects as often as possible, and never cooperates on the final round, maximizing total personal payoff across rounds.
'''

description_AGGRESSIVE_46 = '''
Here is a detailed aggressive strategy for the Collective Risk Dilemma based on the specifications and constraints:

---

### Aggressive Strategy: **"Threshold Defector with Opportunistic Cooperation"**

---

#### Strategy Intuition

- **Aggressive** players try to maximize their own payoffs, exploiting cooperators.
- The highest payoff per round is when you defect while the threshold **m** or more cooperators exist (π_i = 1 + k).
- Therefore, the goal is to consistently defect unless cooperation is **crucial** to reach threshold and prevent catastrophic loss.
- Since the game is repeated, aggressively defect as much as possible, cooperating only to minimally secure threshold to continue extracting benefit.
- Use opponent cooperation history to decide when defecting risks threshold failure.
- In the **last round**, defect regardless, as no future punishment will occur.

---

#### Decision Rules Overview

1. **Round 1:**
   - Defect outright to test others’ willingness to cooperate.
2. **Rounds 2 to r-1 (intermediate rounds):**
   - Observe previous round actions.
   - If previous round had ≥ m cooperators, defect (free ride).
   - If previous round had exactly m-1 cooperators and you defected last round, cooperate this round to push cooperators to threshold and secure the reward.
   - If previous round had < m-1 cooperators, cooperate this round (to prevent threshold failure).
   - Otherwise, defect.
3. **Round r (final round):**
   - Defect no matter what.

---

#### Handling Edge Cases

- **First round ignorance:** No history, so defect.
- **Near-threshold rounds:** When very close to threshold but defecting would cause a threshold failure, cooperate reluctantly as an investment to secure future gains.
- **Last round frees you:** No future punishment possible; exploit by defecting.
- **Opponent unpredictability:** Continuously adapt to prior round cooperation counts, exploit when safe, cooperate marginally to secure the threshold.

---

### Pseudocode

```python
# Parameters
# n, r, m, k - known
# rounds indexed 1 through r

# Track history: For each round t < current, record cooperating players count.

def aggressive_strategy(t, history, my_actions):
    # Inputs:
    # t           : current round number
    # history     : list of count of cooperators in rounds 1..t-1
    # my_actions  : list of my own actions in rounds 1..t-1 ('C' or 'D')

    if t == 1:
        # Round 1: defect unconditionally
        return 'D'

    if t == r:
        # Final round: defect unconditionally
        return 'D'

    # For rounds 2 to r-1:
    coop_prev = history[-1]               # number of cooperators last round
    my_last_action = my_actions[-1]

    if coop_prev >= m:
        # Threshold met last round, can defect to exploit
        return 'D'

    elif coop_prev == m - 1:
        # Close to threshold
        if my_last_action == 'D':
            # If I defected last time, cooperate now to push threshold over
            return 'C'
        else:
            # Otherwise, keep defecting to opportunistically exploit others
            return 'D'

    else:  # coop_prev < m - 1
        # Threshold not reached nor close; cooperate to avoid zero reward rounds
        return 'C'
```

---

### Explanation

- In **early rounds**, defecting probes opponents' cooperativeness.
- If **threshold was met previously**, aggressive strategy exploits by defecting and "free riding."
- If **threshold almost missed**, reluctantly cooperate if it was you who defected last round (to keep reward alive).
- If threshold failed significantly last round, invest in cooperation to maintain group reward.
- In final round, no incentive to cooperate; always defect.

---

### Summary

| Round     | Condition                                 | Action       | Rationale                      |
|-----------|-------------------------------------------|--------------|-------------------------------|
| 1         | No info                                   | Defect       | Aggressive test               |
| 2 to r-1  | Previous cooperators ≥ m                   | Defect       | Exploit cooperators           |
| 2 to r-1  | Previous cooperators = m - 1 and last action = D | Cooperate    | Save threshold                |
| 2 to r-1  | Previous cooperators < m - 1               | Cooperate    | Avoid threshold failure       |
| r (final) | Any condition                             | Defect       | Exploit final round, no future punishment |

---

This strategy is **aggressive** by default defecting whenever safe, only cooperating just enough to ensure the reward threshold is met, thereby maximizing individual payoff. It exploits cooperators while minimizing costly contributions, aligning perfectly with an aggressive mindset.
'''

description_AGGRESSIVE_47 = '''
**Goal:**  
Design an aggressive strategy that aims to maximize payoff by exploiting others’ cooperation rather than cooperating itself whenever beneficial. Being aggressive here means prioritizing defection to gain better payoffs by free-riding on cooperators, but also tactically cooperating if needed to trigger group rewards, then exploiting again.

---

### Intuition Behind the Aggressive Strategy

- **Defection dominates if enough others cooperate:**  
  When at least *m* others cooperate, defectors get payoff = 1 + k, which is better than cooperators’ payoff = k. So free-riding yields the highest payoff in such cases.

- **But if too many defect, no reward:**  
  If fewer than *m* players cooperate, nobody gets the risk-averted bonus and cooperators have a payoff cost (0 instead of 1).

- **Aggressive players want to mostly defect, but ensure the threshold *m* is reached:**  
  They try to detect if the community will cooperate enough; if not, they may temporarily cooperate themselves to push the threshold, then return to defecting.

- **Exploit cooperation of others by defecting in the end:**  
  Particularly in the last rounds, defect to maximize individual payoff, since there's no future punishment or incentive.

---

### Core Idea of Aggressive Strategy

1. **Start aggressively: Defect on round 1.**  
   - Test the waters; if others cooperate, exploit them.

2. **Observe cooperators each round:**  
   - If cooperating players ≥ m, defect to get maximum payoff.
   - If cooperating players < m, cooperate if you deem the group's cooperation level unstable and your cooperation can push the count to m (to get reward).

3. **After round 1, track and predict group cooperation level:**  
   - If group cooperation is consistent ≥ m from previous rounds, continue defecting.

4. **If group cooperation is low (too few cooperators) in previous round(s), cooperate to "rescue" the group once or twice.**  
   - If rescue fails (cooperation remains below m), defect from then on (give up).

5. **Last round (r): always defect to maximize endgame payoff.**  
   - No incentive to cooperate since no future retaliation.

6. **Never cooperate twice in a row without a clear expectation of threshold.**

---

### Detailed Description

---

#### Variables tracked per round `t` (t=1,...,r):

- `cooperators_t`: number of players (including yourself) who cooperated in round t.
- `cooperators_wo_self_t`: cooperators excluding yourself in round t.
- `last_two_coop_counts`: cooperation counts of previous two rounds for trend.
- `rescued`: boolean, did you cooperate previously to try to push group cooperation?
- `give_up`: boolean, if true defect always since cooperation failed.

---

### Pseudocode

```
initialize:
  rescued = False
  give_up = False

for each round t in 1..r:
  
  if t == 1:
    action = D  # aggressive opening
    
  else if t == r:
    action = D  # always defect last round
    
  else:
    # Use info from round t-1 to decide
  
    prev_coop = cooperators_(t-1)
    prev_coop_wo_self = cooperators_wo_self_(t-1)
  
    if give_up:
      action = D  # cooperation hopeless, always defect
      
    else if prev_coop >= m:
      # enough cooperators last round, defect and exploit
      action = D
      rescued = False
      
    else:
      # cooperation below threshold last round
      
      # Can I help reach threshold this round?
      if prev_coop_wo_self >= m - 1 and not rescued:
        # cooperating this round pushes us to threshold
        action = C
        rescued = True
        give_up = False
      else:
        # rescue not possible or already tried
        if rescued:
          # rescue attempt failed (follow-up round with low coop)
          give_up = True
          action = D
        else:
          # first time witnessing low coop w/o ability to rescue
          # continue defecting to punish low cooperation
          action = D
```

---

### Explanation by Round

- **Round 1:** Defect as a test of others.
- **Rounds 2 to r - 1:**  
  - If group cooperation ≥ m last round, defect to free ride.  
  - If fewer than m cooperators, try to cooperate once if your cooperation flips threshold to ≥ m (rescue).  
  - If rescue fails, defect permanently (give up trying to fix cooperation).  
- **Round r:** Defect always (final exploitation).

---

### Edge Cases

- If `m` is very close to `n` (e.g., m = n-1), rescuing is harder; strategy tries once and then defects.
- If no one cooperates initially, aggressive player defects forever.
- If group occasionally meets threshold due to others cooperating, aggressive player exploits as long as possible.
- No communication or signaling except through actions; relies solely on observed cooperation counts.
- Handles perfectly repeated structure, utilizing full history.

---

### Summary of Aggressive Strategy

| Situation                                 | Action   | Reason                                           |
|-------------------------------------------|----------|-------------------------------------------------|
| Round 1                                   | Defect   | Test group behavior, start aggressively          |
| Past round had ≥ m cooperators            | Defect   | Exploit cooperative players                       |
| Past round had < m cooperators, rescue possible | Cooperate | Push group over threshold once                     |
| Past round had < m cooperators, rescue tried/fails | Defect | Give up on cooperation, punish group by defecting |
| Last round                                | Defect   | Endgame exploitation                              |

---

**This strategy aggressively exploits others’ cooperation to maximize payoff while attempting minimal cooperation only to sustain group success when personally beneficial—and quickly stops cooperating if cooperation fails.**
'''

description_AGGRESSIVE_48 = '''
**Aggressive Strategy: "Exploitative Punisher"**

---

### Intuition behind the strategy

The aggressive approach here is based on:

- **Maximizing personal payoff every round.**
- **Punishing cooperators only if strictly necessary to exploit them.**
- **Defecting as much as possible but cooperating just enough to trigger the threshold *if it benefits you*.**
- **No blind cooperation; always exploit the minimum cooperators needed (m).**
- **Use history to identify cooperators and target them for exploitation.**

---

### Key aggressive principles:

- Cooperate only if cooperation *guarantees* the threshold is met and your payoff is at least equal to defecting.
- Otherwise, defect to maximize immediate payoff.
- Use previous rounds to detect who cooperates and attempt to have exactly m cooperators each round; hope those are other players, so you defect and get the highest payoff.
- In early rounds, test for cooperators aggressively.
- In the last round, defect to maximize immediate gain since no punishment follows.

---

### Detailed Decision Rules

**Notation:**
- Let `C_{t}` = set of observed cooperators at round `t` (from previous rounds)
- Let `countC_{t}` = number of observed cooperators at round `t`
- Let `t` = current round index, t ∈ {1,...,r}

---

#### Round 1 (No prior info):

- Cooperate to test if others also cooperate? **No.**
- Be aggressive: **Defect.**

Rationale: No info, defect to maximize immediate gain.

---

#### General rounds (2 ≤ t < r):

- Observe last round actions.
- If last round had ≥ m cooperators but you defected, you got payoff > cooperating.
- Identify stable cooperators: players who cooperated frequently in previous rounds (≥ threshold frequency, e.g. 50%)
- If you can rely on others to reach m cooperators without your cooperation, **defect**.
- Else, cooperate if by doing so threshold can be met and your payoff ≥ defecting.
- Otherwise defect.

---

#### Last round (t = r):

- Aggressive defect to get maximum payoff.
- No incentive to cooperate since no future rounds to gain or punish.

---

### Algorithm/pseudocode

```python
# Parameters: n, r, m, k
# Maintain record of all players' actions last rounds

for round t in 1 to r:
    if t == 1:
        action = D # always defect in first round
    elif t == r:
        action = D # defect in last round to maximize payoff
    else:
        # Analyze history for rounds 1..(t-1)
        coop_counts = count of cooperations by each player (excluding self)
        freq_coop = coop_counts / (t-1)
        
        # Identify reliable cooperators
        reliable_cooperators = {players with freq_coop ≥ 0.5}
        num_reliable = size of reliable_cooperators
        
        # Predict if threshold can be met without your cooperation
        if num_reliable >= m:
            # Defect to exploit others to reach threshold
            action = D
        else:
            # Check if cooperating can help reach threshold
            if num_reliable + 1 >= m:
                # Cooperation guaranteed threshold: cooperate
                action = C
            else:
                # Cooperation won't yield threshold, defect for max payoff
                action = D
```

---

### Edge Cases:

- **If initially no one cooperated in previous rounds, always defect** (no incentive to start cooperating).
- **If cooperation is sporadic and threshold uncertain, defect** to avoid being sucker.
- **If some players consistently cooperate, exploit by defecting and letting them reach threshold.**
- **If threshold is too high (m close to n), cooperation rarely pays off, so defect all rounds.**
- **If threshold is low and stable cooperators exist, cooperate only to push threshold Met if it raises payoff—otherwise defect.**

---

### Summary

| Round        | Decision Rule                                           |
|--------------|---------------------------------------------------------|
| 1            | Defect (probe no one, maximize immediate gain)          |
| 2 .. r-1     | Defect if threshold met by others; else cooperate only if strict payoff gain assured |
| r (final)    | Defect to maximize last-round payoff                     |

---

### Why is this aggressive?

- Strictly defect unless your cooperation is guaranteed to yield reward.
- Exploit cooperators by free-riding on their contribution.
- Never initiate cooperation (except when strictly rational and payoff-positive).
- Refuse to sustain cooperation out of goodwill; instead, exploit recurring cooperators.
- Punish "unnecessary" cooperation by refusing to contribute yourself.

---

### Potential refinements

- Adjust **cooperation frequency threshold** for defining reliable cooperators based on observed play.
- More nuanced prediction of cooperation subsets to meet threshold if partial cooperation helps your payoff.
- Exploit opponents' predictable cooperation patterns aggressively.

---

Let me know if you want a less aggressive or more forgiving variant!
'''

description_AGGRESSIVE_49 = '''
**Aggressive Strategy: "Dominant Defect Leveraging Opportunistic Cooperation"**

---

### Intuition and Rationale

This strategy maximizes individual payoffs by being selfish but opportunistically cooperative only when it guarantees a strictly higher payoff compared to pure defection. Being aggressive means prioritizing own immediate gain, using cooperation only as a lever to extract advantage under specific circumstances—never out of trust or goodwill.

---

### Key Observations from the Game

- Defecting gives you **1** each round by default.
- Reward \(k > 1\) is only obtained if at least \(m\) players cooperate.
- If \(m\) or more cooperate:
  - Cooperators get \(k\) (lose 1 contribution, gain \(k\)).
  - Defectors get \(1 + k\) (keep their endowment + reward).
- Defectors always earn **at least 1**, possibly \(1+k\).
- Cooperators earn less than or equal to defectors when threshold met.
- Cooperative acts risk losing endowment unless threshold is certain.
- Without communication and trust, cooperation is costly and risky.
- Observability allows conditioning on others’ past moves.

---

### Strategy Description

This is a **mostly defect** strategy that only cooperates when it can reliably "free ride" on others’ cooperations to obtain \(1 + k\). It aggressively refuses to “pay the cost” of cooperation in ambiguous states.

#### Round 1:  
- **Always Defect**.  
Reason: No information about others, safe payoff of 1.

#### Subsequent Rounds (t = 2 to r-1):  
- **If in the previous round, at least \(m\) cooperated** (threshold met):  
  - **Defect** this round to free-ride and get payoff \(1 + k\).  
  Rationale: Others showed willingness to cooperate; exploit it.
  
- **If in the previous round, fewer than \(m\) cooperated**:  
  - **Cooperate if and only if you can expect others to cooperate this round to reach threshold \(m\)**  
    - Since no communication, assume cooperation is unlikely.  
    - Therefore, **Defect** to avoid losing endowment for no reward.
  
- **If exactly \(m-1\) players cooperated last round and you defected**:  
  - You can try to jump in and cooperate this round to push threshold to \(m\), making others’ defect payoff improve.  
  But no guarantee others will cooperate next round → **still Defect**.

Overall, **never cooperate unless guaranteed threshold achieved**, which you do **not** know. So default to **Defect** to play aggressively with maximum guaranteed payoff.

---

#### Last Round (t = r):  
- **Always Defect**.  
Reason: No future rounds to punish for defection; no trust incentive.

---

### Summary of Decision Rules

| Round     | Condition                                         | Action       |
|-----------|-------------------------------------------------|--------------|
| t = 1     | Always                                         | Defect (D)   |
| 2 ≤ t < r | Previous round had ≥ m cooperators?            | Defect (D)   |
| 2 ≤ t < r | Previous round had < m cooperators?            | Defect (D)   |
| t = r     | Always                                         | Defect (D)   |

---

### Pseudocode

```python
def aggressive_strategy(round_t, previous_actions):
    # previous_actions: list of lists; each inner list is players' actions from previous round

    if round_t == 1:
        return 'D'  # Always defect first round

    last_round_actions = previous_actions[-1]
    num_cooperators_last_round = last_round_actions.count('C')

    if round_t == total_rounds:
        return 'D'  # Always defect last round

    if num_cooperators_last_round >= m:
        # Many cooperators last round -> defect to free ride
        return 'D'
    else:
        # Insufficient cooperators last round; no incentive to cooperate
        return 'D'
```

---

### Additional Considerations / Aggressive Flair

- Never cooperate first or last round.
- Never risk losing endowment unless absolutely guaranteed threshold reached.
- Exploit others’ cooperation by defecting whenever threshold is met.
- No attempts at signaling or conditional reciprocation to reduce risk.
- Effectively a **"Defect Always"** strategy but smartly exploits others' cooperation if it happens by free riding.

---

**This strategy is aggressive, selfish, avoids cooperation costs, and exploits cooperative opponents by defecting whenever threshold is surpassed.**
'''

description_AGGRESSIVE_50 = '''
Here is an aggressive strategy for the Collective Risk Dilemma, designed to maximize exploitative gain while using the game’s repeated and observable nature. It aggressively defect-for-profit but uses cooperation selectively to trigger the group reward and leverage others’ cooperation.

---

## Aggressive Strategy: "Calculated Exploit"

### Intuition
- Default to defecting (D) to maximize private payoffs.
- Exploit cooperators by free riding on their contributions whenever threshold m is met.
- Only cooperate when guaranteed the threshold to secure the reward (e.g., when cooperating alone or unwilling to risk missing the reward).
- Use early rounds to test others and detect cooperation levels; punish cooperators minimally by defecting to maximize own payoff.
- In final rounds, aggressively defect because future retaliation is impossible.
  
---

### Parameters & Observables

- **Input parameters:** n, r, m, k known.
- **Per round observation:** Number of players cooperating last round.
- **Goal:** Maximize total payoff over r rounds.

---

### Decision Rules

#### Round 1 (first round):
- Defect (D).
  
Reason: No info about others; start aggressive.

#### Middle rounds (2 to r-1):
1. Observe number of cooperators last round: \( C_{last} \).
2. If \( C_{last} \geq m \) (threshold met last round):
   - Defect (D) this round to free ride on others’ cooperation.
3. Else if \( C_{last} = m - 1 \) and you **can safely put the group over the threshold** by cooperating:
   - Cooperate (C).
   - This is a calculated move to push others into reward state so you share the reward.
   - Specifically, if last round had exactly \( m - 1 \) cooperators and you defected, now cooperate to tip the scale.
4. Else:
   - Defect (D).
   
This leads to exploiting others’ cooperation while occasionally cooperating only when guaranteed to reach or maintain threshold—minimizing cost but capturing reward.

#### Last round (round r):
- Defect (D).
  
Reason: No future punishment; maximize private payoff.

---

### Corner cases and clarifications

- If threshold is very high (close to n), and cooperation is unlikely, always defect.
- If you detect stable cooperation by others (e.g., consistent \( \geq m \) cooperators), continue defecting to free ride.
- If past behavior indicates breakdown of cooperation, defect to avoid costs.
- If others start defecting simultaneously, you defect as well.
- No attempts to trigger cooperation by unilateral cooperation unless you can guarantee threshold.

---

### Pseudocode

```
function decide_action(round t, observed_cooperators_last_round C_last):

    if t == 1:
        return D  # start aggressively with defect

    else if t == r:
        return D  # last round, defect to maximize payoff

    else:
        if C_last >= m:
            return D  # free ride on others’ cooperation

        else if C_last == m - 1:
            # If cooperating this round can reach threshold
            # Assume at least 1 player besides you consistently cooperates:
            # You cooperate to push group over threshold
            return C

        else:
            return D  # no incentive to cooperate

```

---

### Summary

This **Calculated Exploit** strategy:
- Defects first round to avoid early cost.
- Exploits cooperators by defecting whenever threshold reached.
- Cooperates opportunistically to push group over threshold if just shy of it last round.
- Defects last round with no fear of reprisals.
- Responds only to observable cooperation levels; never initiates costly cooperation unless guaranteed reward.
- Aligns with aggressive mindset by maximizing defect payoffs and minimizing contribution cost.

---

Let me know if you want me to adapt this strategy with more nuanced reputation tracking or probabilistic moves!
'''

description_AGGRESSIVE_51 = '''
**Aggressive Strategy for Collective Risk Dilemma**

---

### Strategic Mindset

- **Aggressive here means**: seek to maximize personal payoff even at the expense of group cooperation; exploit others' cooperation; avoid costly cooperation unless it directly benefits you; induce others to pay the cost; defect whenever it is profitable.
- Exploit the payoff structure:  
  - If threshold is met with your defection, you get *1 (keep)* + *k (reward)* = highest payoff per round (3 in example).  
  - If threshold is not met without you cooperating, then cooperation is necessary only if it guarantees hitting *m* threshold; otherwise, defect.
- Use observations of past rounds to decide whether cooperating is worthwhile; default to defection unless strong evidence others will cooperate enough.

---

### Key Insights

- Defecting when *m* or more cooperate yields the *highest payoff* in a round.
- Cooperating is costly (lose 1 endowment) but necessary if others would not reach threshold without you.
- If others are cooperating enough, free-ride.
- If cooperation is failing, cooperate **only** if necessary to achieve threshold and maximize own payoff.
- Last round: Defect to maximize payoff since no future punishment.
- Early rounds: probe if enough cooperation exists; attempt minimal cooperation only if that ensures threshold is hit.

---

### Decision Rules

Assume:
- `t` = current round (1 ≤ t ≤ r)
- `previous_actions` = list of past rounds' actions by all players (size = t-1)
- `count_cooperators(round)` = number of players who cooperated in that round

---

#### Round 1 (Initialization and Test Round)

- **Goal**: Identify whether some players are cooperating.
- **Action**: Defect (D).  
  Never cooperate first to avoid cost.  
  Rationale: Aggressive, test waters, force others to cooperate if they want threshold.

---

#### Subsequent rounds (t in 2..r-1)

1. **Estimate whether cooperation threshold was met last round if you defect**:  
   - Count number of cooperators **excluding yourself** from last round actions.  
     Let `coop_last = count_cooperators(t-1) - 0 if you defected else -1 if you cooperated`.

2. **Decision:**  
   - If `coop_last >= m`, threshold was met without your cooperation; **defect** to get max payoff.  
   - Else if `coop_last == m - 1`: cooperating this round can hit threshold if others cooperate similarly this round.  
     Check if you expect enough others to cooperate this round:  
     - If in previous rounds you observed consistent cooperation ≥ (m - 1) from others, **cooperate** now to help reach threshold and get collective reward.  
     - Else **defect** (risk threshold not met).  
   - Else (`coop_last < m - 1`), cooperation unlikely to reach threshold; **defect** as cooperation cost not worth low chance of reward.

---

#### Last Round (t = r)

- **Always defect**.  
  Rationale: No future rounds to punish or reward cooperation; maximize own payoff.

---

### Edge Cases

- **If r = 2**:  
  - Round 1 defect (test).  
  - Round 2 defect (last round).

- **If players consistently cooperate above threshold without you**:  
  - Always defect to free ride.

- **If other players defect consistently, cooperation threshold not met**:  
  - Defect to avoid loss; cooperation is futile.

- **If on round t, you notice coordination to cooperate (say ≥ m-1 players cooperating)**:  
  - Cooperate only if it pushes threshold to reward.

---

### Pseudocode

```python
def aggressive_strategy(t, r, m, n, k, previous_actions, my_previous_actions):
    """
    t: current round (1-based)
    r: total rounds
    m: threshold number of cooperators
    n: number of players
    k: reward factor
    previous_actions: list of lists; each inner list size n; previous rounds' actions
    my_previous_actions: list of own actions from previous rounds
    Returns: 'C' or 'D'
    """

    # Round 1: Defect always
    if t == 1:
        return 'D'

    # Last round: Defect always
    if t == r:
        return 'D'
    
    # Analyze last round cooperation excluding own last action
    last_round = previous_actions[-1]
    coop_last = sum(1 for a in last_round if a == 'C')
    my_last_action = my_previous_actions[-1]
    # Remove own last action count
    if my_last_action == 'C':
        coop_last -= 1

    # If threshold met without my cooperation: free ride (defect)
    if coop_last >= m:
        return 'D'

    # If exactly one short of threshold without me
    if coop_last == m - 1:
        # Check cooperation pattern in past rounds (excluding round 1)
        coop_counts = []
        for round_actions in previous_actions[:-1]:
            coop_counts.append(sum(1 for a in round_actions if a == 'C'))

        # Measure if others consistently cooperate (at least m-1)
        consistent_coop = sum(1 for c in coop_counts if c >= m - 1)
        if consistent_coop >= (len(coop_counts) / 2):  # Threshold for "consistent" cooperation
            # Cooperate to push over threshold
            return 'C'
        else:
            # Cooperation unlikely to succeed, defect
            return 'D'

    # Otherwise, defect aggressively
    return 'D'
```

---

### Summary

| Round            | Condition                             | Action  |
|------------------|------------------------------------|---------|
| 1                | Always                            | Defect  |
| Last (r)         | Always                            | Defect  |
| Intermediate (2..r-1) | Threshold met without me?           | Defect  |
| Intermediate (2..r-1) | One short of threshold, consistent cooperation? | Cooperate |
| Otherwise        | Cooperation unlikely                 | Defect  |

---

This strategy maximizes individual payoff by exploiting cooperative players and avoids costly cooperation unless it is critical to reap any reward at all, and then only minimally and conditionally cooperates to nudge the group over the threshold. It punishes unconditional cooperative tendencies by never cooperating first, defaults to defection except to secure payoff when narrowly required, and always defects at the last round to maximize return with no risk.

---

### Notes on Tournament Play

- This aggressive strategy will challenge cooperative strategies.
- Can induce others to bear the cooperation costs.
- Limits own losses while maximizing gains from others’ cooperation.
- Adapts based on observations of the group's behavior to exploit or withhold cooperation accordingly.
'''

description_AGGRESSIVE_52 = '''
Here is a detailed **aggressive strategy** designed for the Collective Risk Dilemma game described.

---

## Strategy Overview: "Aggressor"

**Key Idea:** Exploit the cooperative threshold by defecting early and often, but cooperate just enough to reach the threshold and secure the high payoff. If others fail to cooperate sufficiently, punish them by defecting until they "submit" again.

---

## Core Logic and Rationale

- Since defectors keep their endowment (1) plus the reward \(k\) if the number of cooperators is at least \(m\), defecting when others cooperate yields the highest payoff per round.
- Cooperating alone gives a lower payoff (lose the endowment, gain reward), so do not cooperate unnecessarily.
- Manipulate or "farm" other players by cooperating only exactly \(m\) times per round—just enough to trigger the reward—thus maximizing defectors' gains.
- Punish if cooperation drops below \(m\) by defecting fully to signal "no free ride."
- In the last round, defect always because there is no future to influence.

---

## Decision Rules by Round and Observations

### Notation
- \(C_t\) = number of players who cooperated last round \(t-1\) (0 if \(t=1\))
- You are player \(i\)
- Round index \(t \in [1, r]\)

---

### Round 1 (no history)

- Defect to test the baseline behavior.
- Reason: No info, do not concede resources unnecessarily.

**Action:** \(D\)

---

### Rounds 2 to \(r-1\) (middle rounds)

- Observe last round cooperation count \(C_{t-1}\)
  
- If \(C_{t-1} \geq m\) (others cooperated enough),
  - Cooperate only if your cooperation is needed to keep the count at or above \(m\).
  - Otherwise defect.

- If \(C_{t-1} < m\),
  - Defect to punish.
  - No point cooperating if threshold is not met (no reward gained).
  - Wait for others to take initiative.

---

### Last round \(t = r\)

- Defect regardless.
- No future rounds to influence.
- Maximize private payoff.

---

## How to implement the "cooperate only if needed" rule?

- Track how many cooperators you were among last round (if observable).
- If exactly \(m-1\) others cooperated last round:
  - Cooperate this round to help reach the threshold \(m\).
- Otherwise defect.

Since you cannot control others' actions and there's no communication, you effectively try to be the "pivotal" cooperator only when it looks necessary.

---

## Full Pseudocode

```pseudocode
Input: n, r, m, k
Variables:
    t = current round
    last_round_cooperators_count = 0  # initialize to 0 for round 1
    last_round_my_action = D (none in round 1)

For each round t in 1 to r:
    if t == 1:
        action = D  # Defect first round to test environment
    
    else if t == r:
        action = D  # Last round always defect
    
    else:
        # Middle rounds
        if last_round_cooperators_count >= m:
            # Cooperation threshold met last round
            # Cooperate only if others' cooperation count was exactly m - 1
            # so your cooperation might make threshold
            if last_round_cooperators_count == m - 1:
                action = C
            else:
                action = D
        else:
            # No threshold met last round: punish by defecting
            action = D
    
    play action
    
    # After round ends:
    observe actions of all players this round
    last_round_cooperators_count = count of cooperators this round
    last_round_my_action = action
```

---

## Comments and Notes

- **Aggressiveness:** This exploits the cooperative threshold by free riding on others' cooperations while cooperating minimally.
- **Punishment:** By defecting when threshold not met, attempt to force others to collaborate or starve themselves of the reward.
- **No early cooperation:** Avoid being exploited.
- **No late cooperation:** Last round is strictly defection to maximize personal payoff.
- **No communication:** Strategy is solely based on history of moves, no signals.
- **Perfect information used:** Can accurately count cooperators after each round.

---

## Summary

| Round      | Condition                               | Action                |
|------------|---------------------------------------|-----------------------|
| 1          | No history                            | Defect                |
| 2 to r-1   | Previous cooperators ≥ m              | Cooperate if prev == m-1; else defect |
| 2 to r-1   | Previous cooperators < m              | Defect (punish)       |
| r (last)   | Always                               | Defect                |

This results in an aggressive strategy that tactically cooperates only to enable reward attainment for defectors including yourself, exploits others’ cooperation, and punishes insufficient cooperative behavior.
'''

description_AGGRESSIVE_53 = '''
**Aggressive Strategy for Collective Risk Dilemma**

---

### High-Level Intuition

The goal of an aggressive strategy here is to **maximize individual payoff by defecting whenever possible**, yet **force cooperation only when strictly necessary** to meet the threshold *m* and secure the reward *k*. We want to leverage others’ cooperative tendencies—if any—while signaling occasional cooperation just enough to avoid the risk of missing the collective reward.

We exploit the fact that if *m* or more players cooperate, defectors get a higher payoff than cooperators (1 + k > k). Hence, defecting is individually optimal **if and only if the reward *k* is secured**, otherwise cooperation is needed strategically.

---

### Strategy Description

We define variables and observations for round *t*:

- Let **C_t** = number of cooperators observed in previous round *t-1* (0 if t=1).
- Endowment contribution cost = 1 for cooperating, 0 for defecting.
- Reward factor = k > 1.
- Threshold = m.
- Number of players = n.

---

### 1. First Round (t=1):

- Being untested and to avoid immediate loss of reward, **cooperate if and only if m = n-1 or m = n** (very high threshold).
- Otherwise, **defect aggressively** to maximize initial private payoff.
- Rationale: Opponents also start naive, you want to test the environment quickly without cost.

---

### 2. Subsequent Rounds (t > 1):

For round t, given observation of previous round:

- If *at least (m)* players cooperated last round (including yourself if you cooperated), **defect this round**.
  - Reasoning: If others are reliably cooperating at or above threshold, defecting now yields payoff = 1 + k, maximum payoff.
- If fewer than (m) cooperated last round, **cooperate this round** to push total cooperators to or above threshold.
  - Rationale: To avoid losing the collective reward which nets you k > 1.
- If you defect last round and reward was secured, continue defecting.
- If you defected last round and reward was NOT secured, cooperate this round.

---

### 3. Penultimate Round (t = r - 1):

- Begin to test if opponents will cooperate without you.
- If reward was secured last round with you defecting, **defect** again.
- Else, **cooperate** to not lose the last opportunity to ensure reward.

---

### 4. Last Round (t = r):

- Always **defect**.
- Rationale: No future punishment or reciprocity; maximize private payoff.
- If last round reward missed, no longer incentivized to ‘save’ group.

---

### 5. Edge Conditions:

- If *m* is very high (close to n), be more willing to cooperate first rounds.
- If *k* is just barely greater than 1, slightly more inclined to defect since reward is less valuable.
- If *k* is very large, be more willing to cooperate if reward is in jeopardy.

---

### Pseudocode

```pseudo
Input: n, r, m, k

Initialize:
  last_cooperators = null
  last_reward_secured = false
  current_round = 1

For each round t in [1..r]:

  if t == 1:
    if m >= n-1:
      action = C  # cooperate if very high threshold
    else:
      action = D  # otherwise defect aggressively

  else if t == r:
    # Last round: defect no matter what
    action = D

  else:
    # From round 2 to r-1
    if last_cooperators >= m:
      # Reward secured last round
      action = D  # free ride on others
      last_reward_secured = true
    else:
      # Reward not secured last round
      action = C  # cooperate to try push others past threshold
      last_reward_secured = false

  # After all players act, observe the number of cooperators this round
  # Update last_cooperators accordingly
  // This info is from game environment after round played

  current_round += 1
```

---

### Summary

| Round        | Condition                              | Action       |
|--------------|--------------------------------------|--------------|
| 1            | if m near n (m >= n-1)                | Cooperate    |
| 1            | else                                 | Defect       |
| 2 .. r - 1   | if reward secured previous round     | Defect       |
| 2 .. r - 1   | if reward NOT secured previous round | Cooperate    |
| r (last)     | No exception                         | Defect       |

---

### Why is this aggressive?

- Aggressively defects whenever reward is secure to maximize individual payoff.
- Only "relents" to cooperate when reward is lost to claw it back, but never over-commits.
- Always defects last round to maximize raw payoff without regard for group.
- Does not try to build trust or signal cooperation; purely payoff maximization driven by current observations.

---

Feel free to request refinements or adaptations to particular parameter ranges or behavioral nuances!
'''

description_AGGRESSIVE_54 = '''
Below is a detailed aggressive strategy design for the Collective Risk Dilemma repeated game, matching the problem parameters and the aggressive mindset.

---

## Aggressive Strategy Overview

This strategy aggressively exploits cooperators while ensuring the collective reward when it benefits the aggressive player. It focuses on maximizing individual payoff by defecting whenever possible, forcing others to bear cooperation costs.

---

## Intuition & Motivation

- **Aggression means:** Defect whenever possible to gain private payoffs plus the reward, only cooperating if absolutely necessary for the player to secure the collective reward.
- **Reward depends on m or more cooperators:** The aggressor tries to "free ride" on others' cooperations.
- **Players can observe all plays:** Use history to detect if cooperation threshold is met mostly by others.
- **Last round worries:** No incentive to cooperate in the last round (no future punishment opportunity), so defect there.
- **Early rounds:** Probe if others cooperate sufficiently. If not, do minimal cooperation to reach threshold only if it benefits the aggressive player.

---

## Formal Decision Rules

Let:

- **t** = current round (1 ≤ t ≤ r)
- **c_count_t** = number of cooperators observed in round t (excluding self)
- **c_i,t** = my cooperation choice at round t (1 if cooperate, 0 if defect)
- **m** = cooperation threshold (minimum number of cooperators needed)
- **n** = total players
- **k** = multiplier reward (>1)
- **r** = total rounds

---

### Round 1 (t=1)

- No past history.
- Defect and observe if others cooperate enough.
- Reason: maximize own payoff immediately and gather information.

``` 
if t == 1:
    c_i,1 = D
```

---

### Round 2 to (r - 1) (2 ≤ t < r)

1. Count the number of cooperators among opponents in the previous round: c_count_{t-1}

2. If in previous round c_count_{t-1} ≥ m:  
   - Others are cooperating enough to meet threshold alone  
   - Defect again and free ride
   
3. Else if c_count_{t-1} == m - 1:  
   - If I cooperate, threshold will be met, giving everyone k reward.  
   - Cooperate this round to leverage collective reward, despite cost (c_i = 1)  
   - The aggressor accepts one cooperation cost when it directly benefits self.
   
4. Else (c_count_{t-1} < m - 1):  
   - Defect (no reason to pay cost if threshold can't be met even if I cooperate)
   - No reward expected
  
5. However, if the threshold has never been met in previous rounds and the reward is big (k is very large), to not miss out - still defect aggressively but can consider cooperating once to prompt others (optional for very aggressive behavior).

```
if 2 ≤ t < r:
    prev_coop_count = count_cooperation_in_round(t-1, exclude_self=True)
    
    if prev_coop_count >= m:
        c_i,t = D   # free ride
    else if prev_coop_count == m - 1:
        c_i,t = C   # cooperate to just meet threshold
    else:
        c_i,t = D   # defect
```

---

### Last Round (t=r)

- No future to punish defectors or reward cooperators.
- Always defect to gain private payoff regardless.
```
if t == r:
    c_i,r = D
```

---

## Summary in Pseudocode

```
for t in 1 to r:
    if t == 1:
        c_i,t = D

    else if t == r:
        c_i,t = D

    else:
        prev_coop_count = count_cooperation_in_round(t-1, exclude_self=True)

        if prev_coop_count >= m:
            c_i,t = D

        else if prev_coop_count == m - 1:
            c_i,t = C

        else:
            c_i,t = D
```

---

## Additional Notes

- The aggressive strategy never initiates cooperation first but steps in when others nearly meet the threshold.
- It never attempts to cooperate multiple consecutive rounds if others fail to cooperate.
- It capitalizes on the reward when the threshold is just barely missed by others.
- It defects in the last round to avoid paying any cooperation costs since no retaliation or future incentive exists.
- This strategy incentivizes and forces others to carry the cooperation burden.

---

## Summary

| Round type       | When to cooperate?                     | Notes                                              |
|------------------|--------------------------------------|----------------------------------------------------|
| First round      | Never                                | Defect to maximize payoff and probe players        |
| Middle rounds    | Cooperate only if (others cooperated == m-1) | Only minimal cooperation to trigger reward      |
| Last round       | Never                                | Defect, no future incentives                         |

This strategy aggressively exploits cooperators while providing minimal cooperation only when personally beneficial, aligning well with an aggressive mindset striving for maximum individual gains.
'''

description_AGGRESSIVE_55 = '''
**Aggressive Strategy for Collective Risk Dilemma**

---

### Strategic Intent

This strategy prioritizes maximizing **individual payoff** aggressively by exploiting cooperative players when possible. It aims to:

- Defect whenever individual gain is greater by freeriding on others’ cooperation.
- Only contribute (cooperate) when necessary to trigger the threshold reward to avoid the collective risk.
- Avoid naïve cooperation that benefits opponents disproportionately.
- Use observed player behaviors and round structure to optimize timing of cooperation and defection.

---

### Key Insights Driving the Strategy

- Defectors save their endowment (earning 1 unit) and still get the reward *if* threshold is met, yielding payoff = 1 + k (max payoff possible in round).
- If the threshold \( m \) is exactly met by others' cooperation, defectors get the highest payoff in that round.
- Cooperators earn payoff \( 0 + k = k \) when threshold met, less than defectors.
- If threshold is not met, defectors get payoff 1, cooperators get 0.
- Thus, free-riding defectors exploit cooperators if threshold met.
- Coordinated defection ruins threshold, giving everyone low payoff.
- With repeated rounds and perfect info, opponents may punish persistent defectors by defecting and lowering payoff.

---

### Decision Rules Summary

| Round Condition                | Decision                                          |
|-------------------------------|-------------------------------------------------|
| **Round 1 (no history)**       | Cooperate to test willingness of others to cooperate (incipient signal) |
| **Rounds 2 to r-1 (intermediate rounds)** | Defect aggressively unless collective cooperation is observed to be marginally failing, then cooperate to maintain threshold and enable exploitation next round |
| **Last round (round r)**       | Defect unconditionally to maximize own final payoff (no future punishment) |

---

### Detailed Stepwise Strategy

#### Notation

- \( t \) = current round number (1 to \( r \))
- \( C_t \) = number of players who cooperated in round \( t \)
- \( \text{prev} \) = last round's cooperation count \( C_{t-1} \) (undefined for \( t=1 \))
- \( m \) = threshold number of cooperators
- \( n \) = total players
- \( r \) = total rounds

---

#### Round 1: Initial Move

- Cooperate (C) to test and initiate cooperation.
- Purpose: Signal willingness to cooperate and observe others' initial response.
- No punishments or reputation exist yet.

---

#### Rounds 2 to r-1: Exploit and Maintain Threshold

1. **If previous round’s cooperators \( C_{t-1} \geq m \):**

   - *Threshold met last round.*

   - Defect (D) to maximize individual gain \( 1 + k \).

   - Reason: Exploit cooperators who enabled reward.

2. **If previous round’s cooperators \( C_{t-1} = m - 1 \):**

   - *Threshold narrowly missed last round.*

   - Cooperate (C) this round to boost cooperation count to \( m \) to trigger reward.

   - Reason: Prevent collective failure so the reward is unlocked next round, enabling exploitation.

3. **If previous round’s cooperators \( C_{t-1} < m - 1 \):**

   - Defect (D), giving up on group success, since threshold unlikely to be reached.

---

#### Round r: Final Round — Defect Unconditionally

- Defect to maximize payoff.
- No future rounds to be punished for selfishness.
- Even if threshold fails, other players cannot punish in subsequent rounds.

---

### Edge Cases

- **If \( r = 2 \):**

  - Round 1 cooperate to test.
  - Round 2 defect unconditionally to maximize final payoff.

- **If threshold is very high \( m \approx n-1 \):**

  - Strategy still tries testing cooperation round 1, but will quickly defect if threshold is unlikely.

- **If you observe persistent zero cooperation by opponents:**

  - Immediately switch to defect for all rounds to avoid losses.

---

### Pseudocode

```python
def aggressive_strategy(t, r, n, m, k, prev_cooperators):
    if t == 1:
        # Round 1: cooperate to test
        action = 'C'

    elif t == r:
        # Last round: defect to maximize gain
        action = 'D'

    else:
        # Intermediate rounds: exploit or maintain threshold
        if prev_cooperators is None:
            # Defensive fallback (should not happen except first round)
            action = 'C'
        elif prev_cooperators >= m:
            # Threshold met last round => defect to exploit cooperators
            action = 'D'
        elif prev_cooperators == m - 1:
            # Threshold narrowly missed => cooperate to push over threshold
            action = 'C'
        else:
            # Threshold too low => defect to save endowment
            action = 'D'

    return action
```

---

### Summary

This **aggressive strategy** plays:

- Cooperate initially to catalyze cooperation.
- Exploit cooperators by defecting when threshold is met.
- Rescue the group only when threshold narrowly fails to keep reward attainable.
- Defect unconditionally on last round to maximize own payoff.
- Avoid naïve cooperation, focusing always on maximizing individual gain through opportunistic freeriding and selective cooperation.

This approach leverages repeated play and perfect monitoring to aggressively maximize payoffs while managing risk of collective failure.
'''

description_AGGRESSIVE_56 = '''
Here is an aggressive strategy for the Collective Risk Dilemma game given your specifications:

---

### Aggressive Strategy: **Punishing Free-riders to Maximize Individual Gain**

**Rationale:**  
The aggressive mindset here is to exploit cooperative players for maximum individual payoff, without being exploited yourself. You defect by default to gain the highest immediate payoff (1 + k if the threshold is met), but will punish persistently defecting groups only when cooperation guarantees that the threshold is met and the punishment raises future cooperation chances, otherwise maintain aggressive defecting behavior.

---

## Decision Rules

### Round 1 (Start of the Game)
- **Defect by default.**  
  No information yet on others’ tendencies. Aggression assumes maximizing immediate payoff by free-riding on potential cooperators.

---

### Rounds 2 to r-1 (Intermediate Rounds)
- **Observe last round cooperation count and individual actions.**

- **If threshold met last round (≥ m cooperators):**
  - **If you cooperated last round:**  
    - Continue to cooperate **only if** the number of cooperators last round was *barely* above the threshold (e.g., exactly m or m+1 players).  
    - Rationale: Keep the threshold met but don't make too many needless contributions that lower own payoff.
  - **If you defected last round:**  
    - Keep defecting aggressively to maximize payoff.
- **If threshold not met last round (< m cooperators):**
  - Use a **punishment phase targeting defectors who never cooperated in past rounds.**  
    - Identify "persistent defectors" (those who have defected every round so far).  
    - Cooperate only if you can recruit enough cooperators (at least m) to meet the threshold in the current round *and* punish persistent defectors by denying them the reward (i.e., cause threshold to fail).  
    - Otherwise, continue to defect.

---

### Last Round (Round r)
- **Defect regardless of prior behavior.**  
  - No future rounds to enforce punishment or maintain cooperation, so maximize last round payoff by defecting.

---

## Edge Cases

- **If m is very close to n (e.g., m = n-1 or m = n-2):**  
  - Aggressive defection even more justified since cooperation is fragile and can be exploited.
  
- **If last round’s payoff was low (threshold not met), and you cooperated last round:**  
  - Punish cooperators who have cooperated even though threshold failed by defecting this round to reduce their payoffs.
  
---

## Pseudocode

```python
def aggressive_strategy(t, r, n, m, k, history):
    # history: list of tuples per round (actions, payoffs), e.g.,
    # [({'C','D','D',...}, {pi1, pi2, ...}), ...]

    if t == 1:
        # Round 1: Defect aggressively by default
        return 'D'

    last_actions, last_payoffs = history[-1]
    num_cooperators_last_round = sum(1 for a in last_actions if a == 'C')

    # Identify persistent defectors: players who defected all rounds so far
    persistent_defectors = set(range(n))  # initially all
    for round_actions, _ in history:
        for i, a in enumerate(round_actions):
            if i in persistent_defectors and a == 'C':
                persistent_defectors.remove(i)

    you_cooperated_last_round = (history[-1][0][your_index] == 'C')

    if t == r:
        # Last round: defect for maximum payoff
        return 'D'

    if num_cooperators_last_round >= m:
        # Threshold met last round
        if you_cooperated_last_round:
            # Continue cooperating if threshold barely met — to minimize own cost
            if num_cooperators_last_round <= m + 1:
                return 'C'
            else:
                return 'D'
        else:
            # Defect to free-ride on cooperation
            return 'D'
    else:
        # Threshold not met last round (failed collective risk)
        # Punish persistent defectors by not helping threshold
        # Cooperate only if can meet threshold *without* persistent defectors
        likely_cooperators = [i for i in range(n) if i not in persistent_defectors]
        if len(likely_cooperators) >= m:
            # Try to form minimal cooperating coalition excluding persistent defectors
            if your_index in likely_cooperators:
                return 'C'
            else:
                # Defect to punish persistent defectors
                return 'D'
        else:
            # Cannot meet threshold without persistent defectors, so defect to maximize payoff
            return 'D'
```

---

## Summary

- **First round:** Defect.
- **On rounds after threshold success:** Defect unless you cooperated and threshold is barely met (to keep minimal cooperation).
- **If threshold fails:** Cooperate selectively to punish persistent defectors by denying them reward next round.
- **Last round:** Always defect.
- **Aim:** Exploit cooperators for maximum payoff while using calculated cooperation as a weapon to punish pure defectors and maintain occasional threshold success only when individually beneficial.

This strategy is **aggressive** because it:

- Values defecting highly to maximize personal payoff.
- Punishes free-riders who never cooperate by denying group rewards.
- Only cooperates tactically to maintain high payoffs and keep others in line.
- Always defects in the final round to maximize last payoff.

---

If you need any refinement or elaboration on motivational reasoning or variants, feel free to ask!
'''

description_AGGRESSIVE_57 = '''
Below is a design for an aggressive strategy in the Collective Risk Dilemma, aligned with the given structure and constraints.

---

### Strategy Name: **Aggressive Exploiter**

---

### Strategic Intuition

- **Aggressive mindset:** Maximize my own payoff aggressively by exploiting cooperators.
- **Key insight:** The reward *k* applies if **m or more** cooperate. Since defectors keep their full endowment plus the reward if threshold is met, defecting while ensuring the threshold is met yields the highest immediate payoff.
- Hence, this strategy aggressively **defects whenever the threshold is likely met** to reap both the private endowment and the reward.
- Conversely, **cooperate only when absolutely necessary to maintain the threshold** and avoid losing the reward (e.g., if defectors drop below m).
- Use observed past rounds to estimate others’ behavior and decide cooperation only as a last resort.
- In the last round, defect to maximize individual payoff — no future punishment to fear.

---

### Decision Rules

**Parameters available to the strategy:**  
- n, m, r, k  
- History of all players’ previous actions (including self) and payoffs

---

### Formal Rules:

1. **Round 1 (No history):**  
   Defect (D) aggressively as a baseline; no information to warrant cooperation.  
   *Rationale:* Start by exploiting cooperators if any.

2. **Rounds 2 to r–1:**

   a. From history, count the number of Cooperators in the **last** round:  
   ``` 
   coop_count_last_round = count of players who played C in round t-1
   ```

   b. Predict whether defecting this round will still allow reaching the threshold m:  
   - If `coop_count_last_round >= m`, safely defect. Others cooperated enough last round; keep exploiting.  
   - If `coop_count_last_round == m - 1`, then **cooperate** this round to help reach threshold (others likely same or fewer cooperation).  
     *Rationale:* Provide critical cooperation to keep reward alive.  
   - If `coop_count_last_round < m - 1`, defect (too few cooperators, reward not reachable anyone, so maximize private gain).

   c. Exception: If fewer than m cooperators third last round, and last round dropped further, aggressively defect (reward lost, no reason to contribute).

3. **Last Round (t = r):**  
   Defect unconditionally.  
   *Rationale:* No future rounds to punish for defection; maximize immediate payoff.

---

### Pseudocode

```
function decide_action(round t, history):

    if t == 1:
        return D  # Aggressive defect to start exploiting

    coop_count_last = count_cooperators(history[t-1])

    if t == r:
        return D  # Last round defect

    if coop_count_last >= m:
        # Threshold met last round, defect to exploit
        return D
    
    if coop_count_last == m - 1:
        # Just below threshold, cooperate to keep reward alive
        return C

    # coop_count_last < m-1 threshold unreachable, defect
    return D
```

---

### Edge Cases Handled

- **First round:** No history → defect aggressively.
- **Last round:** Defect regardless, no incentive to cooperate.
- **Threshold on the edge (m - 1 cooperators):** Cooperate to prevent group failure, protecting future rewards.
- **Multiple rounds of failing cooperation:** Continue defecting since reward unreachable, no incentive to cooperate.
- **Perfect information:** Strategy adapts based on actual previous round actions.

---

### Summary

- Exploit cooperators whenever threshold met or unrecoverable.  
- Provide minimal cooperation only to maintain the reward threshold once it becomes fragile (m-1 cooperators).  
- Defect relentlessly in last round.  
- No signaling or trust building: purely opportunistic and payoff maximizing.

---

This aggressive strategy aims to maximize payoffs by exploiting cooperation of others and minimizing own contributions except when strictly necessary. It balances exploitation with minimal “insurance” cooperation when the reward can be saved, perfectly in line with an aggressive mindset.
'''

description_AGGRESSIVE_58 = '''
Here is an **aggressive strategy** designed for the Collective Risk Dilemma (CRD) repeated game with parameters (n, r, m, k):

---

## Strategic Intent: Aggressive Play

Aggressive here means:  
- Prioritize maximizing immediate payoffs by defecting heavily  
- Use cooperation only strategically when it benefits outweigh defecting gains  
- Exploit others' cooperations to gain high payoffs by defecting  
- Avoid unnecessary costly cooperation except when it secures guaranteed high payoff  
- Push for maximal personal gain over group payoff, even at moral/community cost  

---

## Key Observations to Leverage

- Defectors always keep their endowment (payoff +1 per round) plus potentially the public reward k if threshold m is met by others.  
- Cooperators lose endowment (cost = 1) but get reward k if threshold met.  
- If threshold is met with *just enough* cooperators, defectors gain maximum payoff = 1 + k > cooperators (k reward, 0 endowment).  
- Default defecting grants guaranteed payoff of 1 if threshold not met, and possibly 1+k if others cooperate.  
- Cooperating is costly (lose 1), so only do it if absolutely necessary to achieve threshold and secure the public reward to prevent threshold failure.  
- In multi-rounds, defection is most profitable unless forced cooperation stabilizes threshold to guarantee k.

---

## Aggressive Strategy Definition

```
Inputs: 
  n, r, m, k
Per round t ∈ {1...r}:
  Observe history H_{1..t-1}: past actions of all players and payoffs

Decision Rule for Round t:
  IF t == 1:
    // Opening move - aggressive default defect to evaluate opponents
    Play D

  ELSE IF t == r:
    // Last round logic - maximize immediate payoff with no future punishment
    If I am already confident threshold will be met without me:
       Play D (free ride)
    Else 
       Play C only if my cooperation pushes total coop count ≥ m 
       Else defect

  ELSE:
    // Intermediate rounds

    Let coop_count_prev = number of players who cooperated in round t-1
    
    IF coop_count_prev < m:
      // Threshold failed last round, exploitation opportunity
      // Do not help threshold, keep defecting to maximize payoffs
      Play D

    ELSE IF coop_count_prev ≥ m:
      // Threshold met last round

      // Estimate if threshold depends on me:
      Let coop_without_me = coop_count_prev - (I cooperated last round? 1 : 0)

      IF coop_without_me ≥ m:
         // Threshold met without me, free ride!
         Play D

      ELSE:
         // Threshold depends on me this round to maintain

         IF I cooperated last round:
            // Continue cooperation only if others also appear to cooperate consistently
            IF enough other players cooperated consistently last rounds AND cooperation seems stable:
              Play C  // sustain threshold, secure group reward k

            ELSE: 
              // Others not reliable cooperators, abandon cooperation
              Play D

         ELSE:
            // I defected last round but threshold met
            // Do not risk cooperation; free ride again
            Play D
```

---

## Additional Details & Aggressive Mindset Justification

- **First round:** Always defect to avoid early cost on blind trust  
- **Last round:** Play to maximize immediate gains—defect if threshold met without me, cooperate only if my cooperation secures reward that otherwise fails  
- **Intermediate rounds:**
  - If threshold failed previously, continue defecting (no incentive to contribute)  
  - If threshold often met, free ride if possible  
  - Only cooperate if cooperative behavior has been stable and my contribution is critical to keep the reward going (rare)  
  - Aggressively avoid costly altruism unless almost certain payoff benefit

- The strategy exploits cooperators by enjoying the reward without paying the cooperation cost whenever possible  
- No attempt to build or repair cooperation in unreliable environments—a purely exploitative and opportunistic style  
- Uses observation of prior rounds for conditional cooperation only as an exception and to secure long-term payoff when cooperators are consistent (very limited)  

---

## Pseudocode Summary

```
function aggressive_move(t, history):

  if t == 1:
    return D

  coop_prev_round = count_cooperators(history[t-1])
  my_prev_action = history[t-1][me]
  coop_without_me = coop_prev_round - (my_prev_action == C ? 1 : 0)

  if t == r:
    if coop_without_me >= m:
      return D
    else if coop_prev_round < m and coop_prev_round + 1 >= m:
      return C
    else:
      return D

  if coop_prev_round < m:
    return D

  if coop_prev_round >= m:
    if coop_without_me >= m:
      return D
    else:
      if my_prev_action == C:
         if stable_cooperation(history, threshold=m):
           return C
         else:
           return D
      else:
        return D
```

*`stable_cooperation(history, threshold)` returns True if cooperators appear consistent over recent rounds.*

---

This approach is **strongly aggressive**:

- It defects early and often  
- Only cooperates defensively to maintain the threshold when crucial  
- Exploits others’ cooperation by defecting whenever possible  
- Focuses on maximizing personal payoffs without regard for collective welfare except when payoff gains are forced by threshold dynamics

---

If you want me to elaborate on how to detect stable cooperation or provide concrete thresholds for the `stable_cooperation()` function, I can do so.
'''

description_AGGRESSIVE_59 = '''
Here is an aggressive strategy for the Collective Risk Dilemma, designed to maximize individual payoff by exploiting cooperators while maintaining the threshold needed to unlock the reward when beneficial.

---

### Strategy Name: Threshold Predator

---

### Intuition

- **Core aggressive principle:** Defect by default to gain the private payoff of 1, but occasionally cooperate just enough to push the group over the cooperation threshold, thereby gaining the larger payoff of `k+1` (or `k` plus your kept endowment if defecting).
- **Exploit cooperators:** When others reliably cooperate enough to meet the threshold, defect yourself to get the higher payoff `(1 + k)`.
- **Trigger retaliation:** If cooperation collapses, attempt to restore the threshold by cooperating just enough.
- **Last round:** Always defect to maximize private gain since no future punishment is possible.
- **First round:** Cooperate only if you can confidently push groups to reach threshold or establish a pattern; otherwise defect to test aggressiveness of others.

---

### Decision Rules

Let:

- `current_round` in {1,...,r}
- `cooperators_last_round` = number of players who cooperated in previous round
- `threshold = m` (minimum cooperators needed)
- `total_players = n`

---

#### Round 1: Establish baseline and test opponents

- Cooperate if you can be the marginal cooperator reaching threshold (i.e., if you estimate or believe at least `(m-1)` others will cooperate)
- Otherwise, defect to test for cooperating players

Since no history is available, the simplest aggressive initialization is to defect, forcing others to reveal cooperation.

_Pseudocode:_

``` 
if current_round == 1:
    action = D
```

---

#### Round 2 to r-1: Exploit or enforce cooperation

- **If threshold was met last round (cooperators_last_round ≥ m):**

  - Defect aggressively to get `1 + k` payoff
  - Rationale: Other cooperators shoulder the cost; you benefit most by free-riding.

- **If threshold was NOT met last round (cooperators_last_round < m):**

  - Check how many cooperators last round, call this `c`
  - If `c` is close to threshold (i.e., `c == m - 1`), cooperate this round to help reach threshold
  - Else defect to save cost; cooperate only if you can be pivotal

_Pseudocode:_

```
if current_round > 1 and current_round < r:
    if cooperators_last_round >= m:
        action = D  # Exploit cooperators and get max payoff
    else:
        if cooperators_last_round == m - 1:
            action = C  # Cooperate to push group over threshold
        else:
            action = D  # Defect - risk too high to cooperate alone
```

---

#### Round r (last round): Defect

- No future rounds means no incentive to build or maintain cooperation
- Defect to maximize private payoff

_Pseudocode:_

```
if current_round == r:
    action = D
```

---

### Additional Notes and Considerations

- **Perfect information enables opponent behavior inference:** If after several rounds you detect others never cooperate (always defect), defect unconditionally; there's no threshold to exploit.

- **Edge case if threshold very close to total players (e.g., m = n - 1):** Your cooperation becomes pivotal more often; be prepared to cooperate more frequently if it results in threshold being met for a bigger payoffs.

- **Memory of history:** Only immediate previous round’s cooperation count is needed, simplifying implementation.

- **No communication:** The strategy attempts to manipulate incentives purely through its actions.

---

### Summary Table of Actions by Round and Observations

| Round       | Condition                                         | Action |
|-------------|-------------------------------------------------|--------|
| 1           | Always defect                                    | D      |
| 2..(r - 1) | If last_round cooperators ≥ m                    | D      |
| 2..(r - 1) | Else if last_round cooperators = m - 1          | C      |
| 2..(r - 1) | Else                                            | D      |
| r (last)    | Always defect                                    | D      |

---

This strategy aggressively exploits cooperators by free-riding whenever threshold cooperation is met; it only cooperates enough to restore threshold payoffs when cooperation edges close to success but otherwise defects to maximize individual returns. It treats the last round purely selfishly and begins by testing opponents’ willingness to cooperate by defecting initially.

---

If you want, I can provide alternative versions or explore less or more aggressive variants.
'''

description_AGGRESSIVE_60 = '''
Here’s an aggressive strategy for the Collective Risk Dilemma, designed to maximize individual payoffs by exploiting cooperators while deterring free-riding through targeted defection. The aggression lies in defecting to maximize personal gains whenever safe, cooperating only when strictly necessary to reach the threshold and receive the global reward.

---

### Aggressive Strategy: "Threshold Exploiter"

---

#### **High-Level Principle:**

- Defect **by default** to secure the private payoff of 1.
- Cooperate **only when strictly necessary** to reach the cooperation threshold *m* and unlock the group reward *k*.
- Use observed past round actions and payoffs to infer if the group reliably reaches the threshold without you cooperating.
- Threaten to *withhold cooperation* if you recognize free riders, ensuring only minimal cooperation to maintain the threshold.
- Exploit cooperating players by defecting and still collecting the reward once threshold is met.
- In final rounds, ramp up defection to maximize last moment personal gain (no future rounds to lose cooperation benefits).

---

#### **Detailed Decision Rules**

---

##### Initialization:
- Track all players’ actions each previous round.
- Maintain an estimate of the minimum number of cooperators the group offers per round, excluding yourself (let’s call this `others_c`).

---

##### Round 1 (no history):
- Cooperate only if **you expect others to defect or borderline threshold** (e.g. if you assume others conservative, defect).
- Default: **Defect** to start exploiting naive cooperators.

---

##### Subsequent Rounds (t ≥ 2):
1. **Estimate Cooperation Support:**

   - For last round *t-1*, count how many others cooperated:  
     `others_c = number of other players who played C in t-1`

2. **Decision:**

   - If `(others_c >= m)`:  
      - The group met threshold without you cooperating last round.  
      - **Defect** again this round to exploit cooperators.

   - Else if `(others_c == m-1)`:  
      - The group barely misses threshold without your cooperation.  
      - **Cooperate** this round to push group to threshold and unlock reward *k* for everyone including you.  
      - This pressures the near-threshold cooperators to repeat.

   - Else `(others_c < m-1)`:  
      - Threshold unreachable even if you cooperate.  
      - **Defect**, as cooperation wasted this round.

3. **Punishment of Free Riders:**

   - If you detect a persistent pattern of cooperation below threshold (group never meets *m* even with your cooperation), start **always defecting** to punish.

---

##### Final Round (t = r):

- Always **Defect** to maximize guaranteed private payoff.
- No future rounds to lose potential cooperation gains from.

---

#### **Pseudocode**

```python
FOR each round t in 1 to r:
    IF t == 1:
        # No history, defect to exploit
        action = D

    ELSE IF t == r:
        # Last round, maximally aggressive defect
        action = D

    ELSE:
        others_c = count_others_cooperated(last_round)

        IF others_c >= m:
            # Threshold met without your cooperation, defect to exploit
            action = D

        ELIF others_c == m - 1:
            # Threshold just missed without you, cooperate to secure reward
            action = C

        ELSE:
            # Cooperation futile, defect
            action = D

        # Optional: if persistent failure to reach threshold even with your cooperation,
        # switch permanently to defect mode (punishment)
```

---

### **Strategy Summary:**

- Aggressively defect unless your cooperation is pivotal.
- Exploit cooperators by defecting when threshold is already met.
- Maintain minimal cooperation to trigger group reward but never lead pure cooperation cycles.
- Ramp up defection at final round.
- Implicitly punish groups that fail threshold consistently by never cooperating again.

---

This strategy maximizes your payoff by balancing opportunistic defection with just enough cooperation to unlock global rewards, aggressively exploiting cooperators without being naive.
'''

description_AGGRESSIVE_61 = '''
**Aggressive Strategy Design for Collective Risk Dilemma**

---

### Strategy Overview

The core aggressive mindset here is to maximize **individual payoff**, exploiting cooperators where possible, and ensuring the threshold *m* is reached to yield the reward *k*. This strategy aggressively defects except when defecting risks losing the *k* bonus reward—which is too profitable to forgo; but when cooperating, it does so strategically to induce others to cooperate or at least to maintain the threshold, pushing opponents to cooperate while you reap the lion’s share rewards as a defector.

---

### Key Strategic Principles

1. **Exploit Cooperators:** Prefer to defect to keep your private endowment (1) *plus* the reward if threshold met, which can be greater than cooperating’s payoff.
   
2. **Maintain Threshold:** Cooperate just enough to keep the total number of cooperators ≥ m, so the group earns the reward *k* and the game is not stuck in all-defect with no reward.
   
3. **Aggressive Punishment:** If opponents consistently defect and never cooperate enough to reach threshold, defect as well, since no reward is possible and cooperating unnecessarily wastes your endowment.
   
4. **First Round Aggression:** Start defecting to test opponents' cooperativeness — never lose by cooperating initially.
   
5. **Last Round Final Push:** Since the game is finitely repeated, in the last round cooperate only if threshold guarantee requires; otherwise, defect to maximize final payoff.
   
6. **Use History Perfectly:** Utilize perfect information about previous rounds to calculate the *minimum number of cooperators needed* to keep threshold and adjust cooperation accordingly.

---

### Detailed Decision Rules

**Notation:**

- At round *t*, let `C_prev` = number of players (including yourself) who cooperated in round *t-1* (for *t=1*, no history).
- Let `r` = total rounds, `n` = players, `m` = threshold, `k` = reward.
- Your action at round t: `a_t ∈ {C, D}`.

---

### Rule Set per Round:

**Round 1:**

- Action: **Defect (D)**
- Reason: No knowledge of others yet; aggressive approach is to free-ride initially, reap full individual payoff if others cooperate.

---

**Rounds 2 to r-1:**

- Calculate the number of cooperators last round, `C_prev`.
- Anticipate others' cooperation tendencies by tracking how many cooperate per round.
- Determine if the threshold *m* will likely be met if you defect:

  - If `C_prev` ≥ *m* (threshold met last round), defect to free-ride.  
    *Rationale:* Others have demonstrated sufficient cooperation; you can safely defect and still get the reward.

  - Else if `C_prev` < *m* (threshold not met last round):
    - Cooperate **only if your cooperation pushes the group into reaching threshold m** (i.e., if `C_prev + 1` ≥ m).
    - Else defect to avoid loss of your endowment when reward is not guaranteed.

---

**Round r (Last Round):**

- Aggressive maximization of final payoff:
  
  - Cooperate only if your cooperation is **necessary** to reach threshold *m* and yield reward *k*.

  - Otherwise, defect to claim private payoff since no future rounds exist to punish or reward cooperation.

---

### Pseudocode Summary

```
for t in 1 to r:
    if t == 1:
        action = D  # Defect first round
    
    else if 1 < t < r:
        C_prev = number_of_cooperators_in_round(t-1)
        
        if C_prev >= m:
            action = D  # Threshold met last round, free-ride

        else:
            if C_prev + 1 >= m:
                action = C  # Your cooperation can push over threshold
            else:
                action = D  # Threshold not met, cooperate wasted
    
    else:  # Last round t == r
        C_prev = number_of_cooperators_in_round(t-1)

        if C_prev >= m:
            action = D  # Others' cooperation enough, defect
        else:
            if C_prev + 1 >= m:
                action = C  # Last chance push for reward
            else:
                action = D  # Cooperating pointless, defect
```

---

### Edge Case Handling

- **If at any round you detect opponents always defecting (threshold never met):** Continue defecting to avoid unnecessary cost.
- **If threshold *m* is very close to *n*, or opponents appear very cooperative:** Rely on defection once threshold reached.
- **If threshold *m* is low and opponents cooperate sporadically:** Exploit by defecting as frequently as possible without risking the loss of the reward.

---

### Summary of Aggression

- **Never cooperate first round** — aggressively exploit.
- **Cooperate only to barely maintain threshold when necessary**, pushing burden to others.
- **Defect whenever threshold is ensured by others**, maximizing your personal payoff.
- **Use the final round to defect unless cooperation is strictly needed** to gain the reward.
- **Punish over-cooperation or naive players by free-riding relentlessly.**

This strategy boldly exploits others while supporting cooperation only when it directly benefits you by ensuring the reward, embracing aggressive gameplay.
'''

description_AGGRESSIVE_62 = '''
Here is an **aggressive strategy** designed for the Collective Risk Dilemma that prioritizes maximizing individual payoff by using cooperation only as leverage to induce others to cooperate, but otherwise defaults to defection. It aggressively exploits cooperators whenever possible, and manipulates incentives to push opponents into cooperative behavior while preserving self-interest.

---

## Strategy: **"Aggressive Conditional Exploiter"**

### Intuition
- Always prefer to defect if that guarantees a higher payoff than cooperating.
- Only cooperate to *just* meet or exceed the threshold **m** when it benefits you by unlocking the bonus **k**, but never more than necessary.
- Use early rounds to test and identify potential cooperators without over-committing.
- Exploit cooperators by defecting when you can still gain the bonus.
- In later rounds, punish persistent cooperators by defecting if it improves your payoff.
- Defect last round if the bonus can be secured without you cooperating — maximize endgame payoff.

---

### Detailed Decision Rules

Let:
- t = current round (1 to r)
- C_count_{t-1} = number of cooperators in round t-1 (0 if t=1)
- coop_threshold = m (minimum cooperators needed per round)
- self_cooperating = did I cooperate last round? (boolean)
- opponents_coop_freq = running frequency estimate of opponents cooperating
- ego_gain_if_coop = payoff if I cooperate this round given others' expected actions
- ego_gain_if_defect = payoff if I defect this round given others' expected actions

---

### Step 1: Initialize

- At round 1, assume opponents are mostly defecting.
- Start with **defect** to obtain immediate payoff and avoid the upfront cost of cooperating.
- Begin estimating opponents’ cooperativeness from round 2 onward.

---

### Step 2: For rounds t = 2 to r-1 (intermediate rounds)

1. **Estimate opponents’ cooperativeness** from previous rounds (e.g., sliding average over last few rounds).  
   - Use C_count_{t-1} to estimate how many others cooperated last time.
   - Estimate whether cooperating this round will help reach or exceed the threshold **m**.

2. **Calculate expected payoff for this round if cooperating (C)**:
   - If cooperating puts total cooperators **≥ m**, payoff = 0 + k = k (net payoff, since cost 1).
   - Else payoff = 0.

3. **Calculate expected payoff if defecting (D)**:
   - If total cooperators without you ≥ m, payoff = 1 + k.
   - Else payoff = 1.

4. **Decision:**
   - If defecting yields strictly higher payoff: **Defect**.
   - If cooperating is necessary to reach threshold and yields equal or greater payoff: **Cooperate**.
   - If threshold is not reachable or threshold has been reached without you: **Defect**.

5. **Aggressive twist**: If cooperators are persistent (e.g., same players cooperating multiple rounds), try to reduce their payoff by defecting while they cooperate.

---

### Step 3: Last round t = r (endgame)

- Cooperate **only if** defecting causes the threshold **m** to fail (and thus you lose the k reward).
- Otherwise, **defect** to maximize immediate payoff.

---

### Summary Pseudocode

```
For each round t in [1..r]:

    If t == 1:
        action = D  # start aggressively to avoid outreach cost
    
    Else if t < r:
        # Estimate cooperator count excluding self:
        est_cooperators = observed_cooperators_last_round - (1 if self_cooperated_last_round else 0)

        # Can threshold be reached without me?
        if est_cooperators >= m:
            # Threshold met without me cooperating => Defect to gain max payoff
            action = D
        
        else:
            # Need to cooperate to meet threshold?
            if est_cooperators + 1 >= m:
                # If cooperating, payoff = k (reward - cost 1)
                # If defecting, payoff = 1 (no bonus)
                # Cooperate only if payoff by cooperating >= payoff by defecting
                if k >= 1:
                    action = C
                else:
                    action = D
            else:
                # Threshold cannot be met even if I cooperate => Defect
                action = D

    Else:
        # Last round t == r
        est_cooperators = observed_cooperators_last_round - (1 if self_cooperated_last_round else 0)

        if est_cooperators >= m:
            # Bonus achievable without cooperating => Defect and maximize payoff
            action = D
        else if est_cooperators + 1 >= m:
            # Bonus achievable only if cooperating this round => Cooperate
            action = C
        else:
            # Bonus unachievable => Defect
            action = D
```

---

### Edge Cases & Notes

- If **k** (reward) is very large, cooperating occasionally to unlock the bonus is worth it.
- If you detect no one else cooperates, keep defecting to maximize immediate gains.
- If you detect persistent cooperators, keep defecting to exploit them.
- Being the minimal essential cooperator in some rounds is acceptable to unlock bonus but never go beyond necessity.
- No communication allowed, so rely only on observed move frequencies.

---

### Why is this strategy aggressive?

- It prefers defecting as default, maximizing private payoffs.
- Cooperates only to just meet threshold, never altruistically or overly.
- Exploits cooperators by free-riding on their cooperation.
- Punishes and discourages cooperation by minimizing cooperation frequency.
- Defects last round to maximize immediate payoff if possible, refusing to "help" others then.

---

If implemented, this strategy can reliably exploit cooperative opponents and leverage the collective bonus when it is strictly more profitable for self, aligning perfectly with an aggressive mindset in the Collective Risk Dilemma repeated game.
'''

description_AGGRESSIVE_63 = '''
**Aggressive Strategy for Collective Risk Dilemma**

**Core Idea:**  
Use cooperation only as a *strategic tool* to incentivize opponents to cooperate and then exploit by defecting to maximize immediate payoffs, accepting risk of collective failure if others don't comply. Be willing to defect aggressively and punish cooperators to maximize individual gain, especially near the end.

---

### 1. Key Intuition

- **Aggressive stance:** Prioritize personal gain over group success.
- Only cooperate to *manipulate* opponents into cooperating.
- Exploit cooperative players by defecting when group threshold can still be met without your contribution.
- Push to defect once it’s clear others won't cooperate or when the marginal benefit of cooperating is overshadowed by individual gain.
- In last rounds, defect maximally to squeeze final gains.

---

### 2. Decision Rules by Round

#### Round 1 (No history)
- Defect to signal aggressive intention.
- Reason: Test others, preserve endowment, and avoid early losses.

#### Rounds 2 to r-1 (Intermediate rounds)
1. Observe last round’s cooperation count: `C_last` = number of cooperators last round.
2. If `C_last` ≥ m:
   - Explore exploitation:
     - If defecting this round still keeps total cooperators ≥ m (i.e., `C_last` - 1 ≥ m), **defect** to harvest higher payoff.
       - Reason: Others will cover threshold, you keep endowment + reward.
     - Else if `C_last` < m + 1:
       - Cooperate only if previous round π_i < 1 + k (missed reward).
         - Cooperate to try hitting threshold and secure reward (only if likely others will cooperate).
       - Else **defect**.
3. If `C_last` < m:
   - Defect to punish failed cooperation.
   - Aggressive stance: no incentive to rescue a failing group.
4. If `C_last` unknown (e.g., first rounds, or no cooperation info):
   - Defect by default.

#### Round r (Final round)
- Defect unconditionally.
- Reason: No future to gain from cooperation, maximize final payout with minimal cost.

---

### 3. Edge Cases

- **Near-threshold exploitation:**
  If group barely meets threshold without your cooperation, **defect** to maximize payoff, trusting others carry cooperation.
- **Persistent failure to meet m:**
  Maintain defection - no incentive to engage in futile cooperation.
- **If others escalate cooperation (e.g., all cooperate):**
  Start exploiting from round 2-3 onwards by defecting to capture high payoffs.
- **If uncertain on opponent intentions:**
  Default defection to avoid being exploited.

---

### 4. Pseudocode

```
initialize:
  n, r, m, k given
  history = empty list of previous round actions for all players

for t in 1 to r:

  if t == 1:
    action = Defect

  else if t == r:
    action = Defect

  else:
    C_last = count_cooperators(history[t-1])

    if C_last >= m:
      if (C_last - 1) >= m:
        action = Defect  # Exploit threshold coverage by others
      else:
        my_last_payoff = compute_payoff(my_last_action, C_last)
        if my_last_payoff < 1 + k:
          action = Cooperate  # Try to push threshold for reward
        else:
          action = Defect
    else:
      # Group failed threshold last round
      action = Defect  # Punish failed cooperation

  record action in history

```

---

### 5. Summary

- **Round 1:** Defect to establish aggressive tone.
- **Intermediate Rounds:**  
  - If threshold met last round, defect if group can fulfill threshold without you (exploit).  
  - Otherwise, cooperate only if it improves payoff, else defect.  
  - If threshold not met last round, defect to punish.
- **Last Round:** Defect to maximize final gain.

This strategy aggressively seeks to maximize individual payoffs by exploiting cooperative behavior of others, punishing failed cooperation, and minimizing own cooperation costs except when strictly beneficial to secure reward.

---

Let me know if you want me to reason about how this strategy will perform or adapt based on specific parameter values!
'''

description_AGGRESSIVE_64 = '''
Below is a detailed aggressive strategy for the Collective Risk Dilemma as specified. The aggressive mindset here means:

- Prioritizing maximizing own payoff over community welfare
- Exploiting cooperators aggressively
- Punishing cooperation to discourage others from being consistent cooperators
- Trying to "free ride" whenever possible and defecting when at risk to lose the guaranteed reward

---

### Strategy Overview: Aggressive Free-Rider Exploit with Dynamic Threshold Testing

The strategy aggressively defects whenever it can gain a higher payoff by free-riding on others’ cooperation, cooperates only to maintain the collective reward when absolutely necessary to avoid losing the payoff bonus, and punishes excessive cooperation by defecting sharply to maximize personal gains.

---

### Key Concepts

- **Threshold `m` cooperation needed to unlock reward `k`**
- **Players are rational and observe all prior actions**
- **No communication, but full history known**
- **Repeated over `r` rounds**

---

### Aggressive Decision Rules

#### Variables Tracked

- `round t` (1 to r)
- `last_round_cooperators = number of cooperators observed in round t-1`
- `my_last_action` (C or D)
- `m, n, k` known parameters

---

#### First Round (t = 1)

- Defect to test environment and establish aggressive stance
- Reason: No past info; defecting yields 1 guaranteed payoff, cooperation costs 1 and no guaranteed extra reward if others defect

```pseudocode
if t == 1:
    play D
```

---

#### Intermediate Rounds (1 < t < r)

1. **If last_round_cooperators >= m:**
   - The reward bonus is guaranteed if enough cooperate.
   - Defect to free-ride on cooperators → payoff = 1 (for defect) + k (reward) = 1 + k
   - Cooperators get 0 + k = k
   - Since 1 + k > k, defecting maximizes personal gain

2. **If last_round_cooperators == m - 1:**
   - The collective failed threshold by 1 cooperator last round.
   - If I cooperate now, this may push total to m and secure reward for all.
   - But cooperating costs 1 unit, defecting yields 1 but **no reward**.
   - Aggressive mindset prefers to exploit rather than help, so:
     - **Defect** to reduce cooperation below threshold to deny everyone the bonus.
     - Deny even cooperators the reward to punish them for past cooperation.
   - However, if everyone defects, payoff is 1; if 1 cooperates, payoff is 0 + k.
   - Since defecting yields at least 1, cooperate only if group behavior is suspiciously cooperative (e.g., few defectors last round). But pure aggressive mindset avoids risking cost.
   - Choose **Defect**.

3. **If last_round_cooperators < m - 1:**
   - Reward not reached in previous round.
   - Cooperation is rare.
   - Defect to maximize payoff (1 if defect, 0 if cooperate)
   
```pseudocode
else if t < r:
    if last_round_cooperators >= m:
        play D  # exploit cooperators, free ride on reward
    else:
        play D  # defect to deny reward or avoid cost in absence of cooperation
```

---

#### Last Round (t == r)

- No future punishment possible.
- Maximize own payoff absolutely.
- Defect to get guaranteed 1 payoff.
- Cooperating costs 1 with uncertain reward.

```pseudocode
if t == r:
    play D
```

---

### Summary of Decision Rules:

| Condition                               | Action         | Rationale                               |
|----------------------------------------|----------------|----------------------------------------|
| `t == 1`                              | Defect (D)     | Establish aggressive test round; no info |
| `1 < t < r` and `last_round_cooperators >= m`    | Defect (D)     | Exploit cooperators and free ride on reward |
| `1 < t < r` and `last_round_cooperators < m`     | Defect (D)     | Punish cooperation, avoid cost of cooperation |
| `t == r`                              | Defect (D)     | No future rounds, maximize immediate gain |

---

### Handling Edge Cases and Variations

- **If at any point I am the only cooperator in prior round:** Keep defecting to punish solo cooperation.
- **If opponents start cooperating en masse:** Keep defecting to exploit large cooperative groups.
- **If opponents defect completely:** No incentive to cooperate; follow and defect.
- **If `m` is close to `n` (high threshold):** More incentive to defect since coordination is hard.
- **If `k` is extremely high:** Still defect aggressively to exploit cooperators.

---

### Pseudocode Summary

```pseudocode
function aggressive_strategy(t, last_round_cooperators, m, r):
    if t == 1:
        return D  # Defect first round to establish stance

    if t == r:
        return D  # Defect last round to maximize personal payoff

    # Intermediate rounds (1 < t < r)
    if last_round_cooperators >= m:
        return D  # Exploit cooperators with free ride
    
    # Otherwise, cooperation is below threshold
    return D  # Deny cooperators reward, avoid cooperation cost
```

---

### Final Notes

- This strategy is *purely defecting after round 1*, except it relies on observing the threshold met or not.
- Aggressive mindset leads to maximum exploitation of cooperative opponents.
- This likely instigates breakdown of cooperation in repeated play due to punishing cooperators.
- The potential risk is if all defect, payoff is minimized (all get 1), but this is unavoidable with aggressive stance.

---

If you want I can help add any refinements or contingencies!
'''

description_COOPERATIVE_65 = '''
Here is a cooperative strategy designed to maximize collective payoffs by coordinating cooperation to meet the threshold m each round while protecting against exploitation by defectors. The strategy leverages repeated game information and is clearly cooperative, yet prudently mindful of free-riders.

---

## Cooperative Strategy: Conditional Threshold Cooperation (CTC)

### Intuition
- Cooperate early and attempt to coordinate cooperation to reach threshold **m**.
- Monitor other players for cooperation patterns.
- Punish defection by temporarily defecting if cooperation breaks down.
- Forgive and resume cooperation once cooperation is observed again.
- In the last round, cooperate only if you expect enough others to do so (to avoid being exploited).

---

### Detailed Decision Rules

**Parameters/State Variables:**
- `round`: current round number, 1 ≤ round ≤ r
- `history`: full action profile of all players in all previous rounds
- `cooperation_count(t)`: number of cooperators in round t
- `last_round_cooperation_count`: number of cooperators in round (round-1), or set to n (optimistic) if round=1
- `punish_rounds_remaining`: number of remaining punishment rounds if defectors detected (initially 0)

---

### Strategy Steps Per Round

**On Round `t`, Player i:**

1. **Round 1 (Initialization):**
   - Cooperate (C)
   - Reason: Start optimistic to signal willingness to cooperate.

2. **Round t > 1:**
   - Observe the number of cooperators in previous round: `last_round_cooperation_count`
   
   - If `punish_rounds_remaining > 0`:
     - Defect (D)
     - Decrement `punish_rounds_remaining` by 1
     - Reason: Punish defection to discourage free-riding.
     - Go to step 6.
   
   - Else if `last_round_cooperation_count >= m`:
     - Cooperate (C)
     - Reason: Cooperation was successful last round, maintain it.
   
   - Else if `last_round_cooperation_count < m`:
     - Defect (D)
     - Reason: Cooperation insufficient, likely not everyone cooperating; avoid being exploited.
   
3. **Defector Detection and Punishment Trigger:**
   - If in the previous round there were some cooperators but the number fell below `m`, and YOU cooperated then, consider this defection by others.
   - Set `punish_rounds_remaining = min(2, r - t)` (punish for up to 2 rounds or until the game ends)
   
4. **Last Round (t = r):**
   - If `last_round_cooperation_count >= m`, cooperate (C)
   - Else defect (D)
   - Reason: No future rounds to recoup losses from cooperating alone.

5. **Forgiveness Mechanism:**
   - If after punishment round(s), cooperation returns (number of cooperators in recent round ≥ m) and you are not currently punishing:
     - Resume cooperation.
   
6. **Summary:**
   - Cooperate if past round(s) saw successful cooperation and you're not punishing.
   - Defect if cooperation broke down or you are punishing.
   - Start cooperative.
   - In final round, cooperate only if likely profitable.

---

### Pseudocode

```
Initialize:
  punish_rounds_remaining = 0

On each round t:
  if t == 1:
    action = C
    return action

  last_cooperation = count_cooperators(round t-1)

  if punish_rounds_remaining > 0:
    action = D
    punish_rounds_remaining -= 1
    return action

  if last_cooperation >= m:
    action = C
  else:  # Cooperators < m
    # Check if I cooperated last round and cooperation failed -> punishment triggered
    if I played C at round t-1:
      punish_rounds_remaining = min(2, r - t)

    action = D

  # Last round special condition
  if t == r:
    if last_cooperation >= m:
      action = C
    else:
      action = D

  return action
```

---

### Notes

- **Cooperation as default:** Starting with cooperation signals willingness and aims for the collective reward.
- **Punishment:** Temporary switching to defection deters defectors and signals disapproval.
- **Forgiveness:** Punishment limited in length prevents endless retaliation and allows recovery.
- **Threshold-based:** Uses threshold `m` explicitly to decide when cooperation is successful.
- **No communication needed:** Behavior inferred from observed actions.
- **Last round cautious:** Avoid cooperating if others defect last round, since no future incentive.

---

### Why This is Cooperative

- Prioritizes meeting the threshold to unlock the reward `k`.
- Attempts to sustain cooperation over repeated interactions.
- Does not blindly cooperate—punishes defectors to maintain group benefit.
- Forgives to restore cooperation, showing cooperative goodwill.
- Base actions on clear, observable signals consistent across players.

---

This strategy aligns well with the Collective Risk Dilemma structure and repeated nature, promoting stable cooperation balanced with prudent safeguards. It is straightforward to implement, transparent, and effective at fostering cooperation in multi-agent environments.
'''

description_COOPERATIVE_66 = '''
**Cooperative Strategy for Collective Risk Dilemma**

---

### Strategy Overview

The core idea of this strategy is to **coordinate on cooperation early and maintain it as long as a reliable coalition forms, leveraging repeated interaction and perfect monitoring to build trust and sustain cooperation.** Since cooperation yields higher collective and individual payoffs when the threshold is met, the strategy fosters cooperation with conditional reciprocity to discourage free-riding and coordinate recovery if defections arise.

---

### Intuition

- **Round 1:** Assume goodwill, initiate cooperation to signal cooperative intent.
- **Subsequent Rounds:** Cooperate if enough others cooperated previously (at least m−1 others cooperated last round), else defect to punish exploitation or breakdown.
- **Last round (r):** Since no future punishment is possible, cooperate only if strong cooperation history; else defect or cooperate based on payoff expectations.
  
This conditional cooperation converges on stable cooperation if players want to sustain high rewards.

---

### Notation

- Let `C_t` = set of players who cooperated in round `t`.
- `|C_t|` = number of cooperators in round t.
- `m` = threshold for cooperation reward.
- `r` = total rounds.
- `t` = current round.
- `me` = your player index.

---

### Decision Rules:

```pseudocode
function decide_action(round t, history):
    if t == 1:
        // Start cooperative: signal trustworthiness
        return C

    else if t < r:
        // From round 2 to one-before-last:
        // Check how many cooperated last round
        last_cooperators = number_of_cooperators_in_round(t-1)

        if last_cooperators >= m - 1:
            // Most players cooperated last round (excluding self)
            // Sustain cooperation to achieve reward
            return C
        else:
            // Cooperation broke down, punish by defecting
            return D

    else if t == r:
        // Final round logic

        // Count cooperators in previous round
        last_cooperators = number_of_cooperators_in_round(t-1)

        if last_cooperators >= m:
            // Cooperation is stable -> continue cooperating for final reward
            return C

        else if last_cooperators == m-1:
            // One short of threshold last round, 
            // attempt cooperation to reach threshold if possible
            // but uncertain if others will cooperate, risk of exploitation

            // Option 1: Cooperate to hope threshold reached and get reward
            return C

            // Option 2 (more selfish): Defect to minimize loss
            // Can be applied if risk-averse or suspect defection.

        else:
            // Cooperation unlikely, defect to maximize private gain
            return D
```

---

### Explanation

- **First Round (t=1):** Start by cooperating to signal your willingness to cooperate.
- **Rounds 2 to r-1:** Monitor previous round’s cooperation levels:
  - If at least (m−1) others cooperated previously, assume cooperation is feasible and reciprocate.
  - If fewer than (m−1), cooperate breaks down, so defect to avoid being exploited.
- **Last Round (t=r):** Since no future future rounds exist to punish defectors:
  - Cooperate if cooperation threshold was met previously (stable cooperation).
  - If threshold almost met (m−1), risk cooperating hoping others do too.
  - Defect if cooperation was low previously to avoid being sucker.

---

### Edge Cases and Robustness

- **If initial cooperation fails (few cooperate round 1):** This strategy will adapt by defecting in rounds 2+ until cooperation is restored. Since players see all history, others can "signal" cooperation by cooperating once again, restoring the baseline.
- **Defection by some players:** Defecting players get higher payoff short term, but the strategy punishes them immediately by defecting itself next round, disincentivizing persistent defection.
- **First round coordination failure:** Because no prior info, cooperate to avoid punishing blind defection.
- **Last round exploitation:** Accept limited loss or cooperation risk, as future punishment doesn’t exist.

---

### Cooperative Mindset Alignment

- Strategy maximizes collective reward when cooperation is sustained.
- It actively seeks and maintains cooperation through conditional reciprocity.
- Punishment for defection is measured and immediate, avoiding exploitation.
- It balances risk and reward at the final round to preserve cooperation when beneficial.

---

### Summary

| Round       | Condition                              | Action         |
|-------------|--------------------------------------|----------------|
| 1           | No history                           | Cooperate (C)  |
| 2..r-1      | ≥ m-1 cooperators in t−1             | Cooperate (C)  |
| 2..r-1      | < m-1 cooperators in t−1             | Defect (D)     |
| r (final)   | ≥ m cooperators in r−1                | Cooperate (C)  |
| r (final)   | = m-1 cooperators in r−1              | Cooperate (C) (hope threshold met) |
| r (final)   | < m-1 cooperators in r−1              | Defect (D)     |

---

This strategy aims to foster and sustain cooperation to maximize long-run payoffs while protecting against exploitation and defection. It leverages the repeated nature and perfect information of the game to coordinate efficiently.
'''

description_COOPERATIVE_67 = '''
Here is a cooperative strategy designed for the Collective Risk Dilemma tournament, balancing incentivizing cooperation and guarding against exploitation while maximizing collective payoffs.

---

### Strategy Overview

- **Goal:** Foster cooperation to reach the threshold *m* of cooperators each round so everyone can obtain the reward *k*.
- **Core idea:** Start by cooperating to signal goodwill and encourage cooperation. In subsequent rounds, adapt based on the observed cooperation level in the previous round, punishing defection with conditional defection but quickly forgiving to restore cooperation.
- **Ensures cooperation:** By cooperating initially and whenever reasonable evidence shows cooperation is mutually sustained.
- **Detects and responds to exploitation:** Temporarily defects when cooperation drops below threshold to penalize defectors.
- **Final round:** Cooperate to maximize immediate payoff, since there will be no future punishment opportunities.

---

### Detailed Decision Rules

#### Variables / Observations
- `round` = current round number (1 to r)
- `prev_coop_count` = number of players (excluding self) who cooperated last round
- `prev_total_coop` = total cooperators (including self) last round
- `threshold = m`
- `total_players = n`

---

### 1. First Round (round == 1)

- **Action:** Cooperate (C)
- **Reason:** Signal trust and willingness to cooperate from the start.

---

### 2. Intermediate Rounds (1 < round < r)

- **If** previous round had cooperation ≥ threshold (m)  
  → **Cooperate** this round  
  → Rationale: Mutual cooperation was successful; continue cooperating.

- **Else** (previous round had cooperation < m)  
  → **Defect** this round  
  → Rationale: Cooperation failed last round, so refuse to be exploited.

- **Exception:** If last round’s total cooperators were zero (everyone defected), **cooperate** to attempt to restart cooperation.

---

### 3. Last Round (round == r)

- **Action:** Cooperate (C)
- **Reason:** No future rounds mean no consequences, so maximizing the group reward by cooperating is beneficial.

---

### Additional Notes (Handling edge cases):

- **If the number of cooperators excluding self is not observable:**  
  Assume knowledge of total cooperators including self from payoff comparison (since payoffs reflect cooperation numbers). For safety, treat tie as cooperation to avoid pessimistic spiral.

- **Handling temporary defections:**  
  Since interaction is repeated, cycle of cooperation -> defection (punishment) -> return to cooperation is natural; forgiving soon helps maximize total payoff.

- **No communication but perfect observation:**  
  Can perfectly observe who cooperated last round; use that info reliably.

---

### Pseudocode

```python
def decide_action(round, r, n, m, prev_total_coop):
    # round: current round number
    # r: total rounds
    # n: total players
    # m: cooperation threshold
    # prev_total_coop: total cooperators last round including self (if self is known action)

    if round == 1:
        # Start cooperative
        return 'C'

    if round == r:
        # Last round: cooperate to maximize immediate reward
        return 'C'

    # Intermediate rounds:

    # If previous round cooperation reached threshold, cooperate
    if prev_total_coop >= m:
        return 'C'
    
    # If everyone defected last round, try cooperating to restart cooperation
    if prev_total_coop == 0:
        return 'C'
    
    # Otherwise, defect to punish defectors
    return 'D'
```

---

### Why this is cooperative?

- It starts by cooperating, showing goodwill.
- It sustains cooperation when others do the same.
- It only punishes (defects) when cooperation thresholds fail, disciplining defectors.
- It quickly forgives by trying to restart cooperation after full defection.
- It cooperates in the final round to maximize payoffs.
- This creates a stable atmosphere encouraging cooperation over repeated rounds.

---

If you want, I can also help sketch probabilistic variants or improvements, but the above deterministic strategy aligns well with cooperation and maximizes collective benefit under the game rules.
'''

description_COOPERATIVE_68 = '''
Here is a cooperative strategy designed to maximize collective reward over repeated rounds by encouraging cooperation but also protecting against unilateral defections.

---

### Strategy Name: **Conditional Reciprocity with Forgiveness**

---

### Intuition

- Cooperate initially to signal willingness to cooperate.
- Continue cooperating if at least the minimum threshold of cooperators (m) was reached in the previous round.
- If threshold was missed (less than m cooperators), defect next round once to punish defection/no cooperation.
- Forgive quickly: return to cooperating immediately after one defection, attempting to re-establish cooperation.
- In the last round, cooperate only if the previous round showed cooperation met threshold; otherwise defect to avoid being exploited with no future retribution possible.

---

### Detailed Decision Rules

Let:
- `t` = current round (1 to r)
- `m` = number of cooperators needed to meet threshold
- `previous_round_actions` = array of actions by all players in previous round (empty in the first round)
- `previous_round_cooperator_count` = count of players who played C in the previous round
- `last_round_cooperation_met` = boolean indicating if previous_round_cooperator_count >= m
- `last_action` = your own action in the previous round (undefined in round 1)
- `defected_last_round` = boolean to track if you defected in the last round as punishment

---

### At each round t:

#### Round 1 (t=1):
- Cooperate to signal willingness:  
  `play C`

#### Intermediate rounds (1 < t < r):
- If last round met cooperation threshold (≥ m cooperators):  
  `play C` (continue cooperation)

- Else (threshold not met last round):  
  - If you defected last round as punishment (`defected_last_round` == true):  
    # Forgive now, return to cooperation:  
    `play C`  
  - Else:  
    # Punish once by defecting:  
    `play D`  
    `defected_last_round = true`

#### Last round (t == r):
- If last round met cooperation threshold:  
  `play C` (reward cooperation till the end)

- Else:  
  `play D` (defect to avoid being exploited without future rounds to compensate)

---

### Edge Cases Handling

- **First round no history:** Always cooperate to jumpstart cooperation.
- **Failed cooperation in previous round:** Punish exactly once, then forgive. This discourages persistent defection.
- **Last round:** Cooperation only proceeds if cooperation was seen last round, else defect to avoid last-round exploit.
- **If multiple defections happen across rounds:** The punishment and forgiveness cycle repeats each time cooperation fails.
- **No communication:** Reliance on observed actions only, no explicit signaling.

---

### Pseudocode

```python
# Initialize state
defected_last_round = False

def decide_action(t, r, previous_round_actions, m):
    global defected_last_round
    
    if t == 1:
        # First round: cooperate
        defected_last_round = False
        return 'C'
    
    previous_cooperator_count = previous_round_actions.count('C')
    cooperative_threshold_met = (previous_cooperator_count >= m)
    
    if t == r:
        # Last round decision
        if cooperative_threshold_met:
            return 'C'
        else:
            return 'D'
    
    # Intermediate round decision
    if cooperative_threshold_met:
        defected_last_round = False
        return 'C'
    else:
        if defected_last_round:
            # Forgiveness step
            defected_last_round = False
            return 'C'
        else:
            # Punish defection/no cooperation once
            defected_last_round = True
            return 'D'
```

---

### Why This Works as a Cooperative Strategy

- Starts with cooperation to establish trust.
- Rewards cooperation by continuing to cooperate if collective cooperation threshold met.
- Enforces accountability by punishing defection just once, preventing exploitation.
- Forgives quickly to promote a return to cooperation rather than permanent breakdown.
- Takes care in last round to avoid exploitation due to endgame effects, yet does not undermine earlier cooperation steps.
- Relies only on public historical actions, consistent with game assumptions.
- Encourages others to cooperate for collective gain (earning k each round), maximizing total payoffs.

---

Let me know if you want an extension or variation with probabilistic cooperation or graduated punishments.
'''

description_COOPERATIVE_69 = '''
Below is a cooperative strategy tailored to the Collective Risk Dilemma as specified. It aims to foster and maintain cooperation across all rounds to reliably meet the cooperation threshold **m** and thereby secure the collective bonus **k** in every round.

---

## Strategy Overview

**Core idea:**  
Start by cooperating to establish trust and a cooperative baseline. In each subsequent round, cooperate if the previous round’s cooperation level was sufficient to meet or exceed the threshold **m**. Defect only as a calibrated punishment when the last round failed to reach the threshold, but return to cooperation immediately once cooperation is restored.

---

## Decision Rules

### Round 1 (First Round)
- **Action:** Cooperate
- **Rationale:** Initiate cooperation and signal willingness to contribute to the public good.

### Round t > 1 (Subsequent Rounds)
- **Observe:** Number of cooperators last round, call it `last_cooperators`.
- **If** `last_cooperators ≥ m` (threshold met):
  - Cooperate this round.
  - **Rationale:** Cooperation last round succeeded; maintain the cooperative norm.
- **Else** (`last_cooperators < m`):
  - Defect this round as a temporary punishment to signal dissatisfaction.
  - **Rationale:** Discourage free-riding and motivate others to increase cooperation.
  - In the following round after a punishment, return to cooperation (forgiving nature).

### Round r (Last Round)
- Apply the same rule as above — cooperate if threshold met last round, defect if not.  
- Since no future rounds exist, no special endgame deviation is necessary if forgiveness is already baked in, but optionally you can defect if the last round's threshold was not met to maximize individual payoff.

---

## Additional Details / Mechanisms

- **Forgiveness:** After defecting in response to threshold failure, if the next round’s cooperation level meets or exceeds **m**, immediately return to cooperation.
- **No permanent defection:** Avoid “grim trigger” strategy that defects forever after one failure; risk of endless mutual defection can prevent cooperation gains.
- **Tolerance edge:** If you detect borderline cooperation (e.g., cooperators = m - 1), consider cooperating once more but be ready to defect next round to signal the shortfall.
- **No communication:** Behavior is fully determined by opponent actions only.

---

## Pseudocode

```python
def action(round_number, last_cooperators, m, r, last_was_punishment):
    """
    round_number: current round (1 to r)
    last_cooperators: number of players who cooperated last round (None if round 1)
    m: cooperation threshold
    r: total rounds
    last_was_punishment: bool flag indicating if we defected last round as punishment
    """

    if round_number == 1:
        # First round: start cooperating
        return 'C', False

    if last_cooperators is None:
        # Defensive fallback: cooperate if no data
        return 'C', False

    if last_cooperators >= m:
        # Previous round successful: cooperate
        return 'C', False

    else:
        # Previous round failed threshold, punish if not already in punishment
        if not last_was_punishment:
            # Defect to signal punishment
            return 'D', True
        else:
            # Already punished last round, return to cooperation for forgiveness
            return 'C', False
```

---

## Strategic Rationale Summary

- **Cooperate first:** Signal trust to encourage others to contribute.
- **Require threshold to be met:** Cooperation is sustainable only if enough players participate; defecting temporarily signals failure to meet the community standard.
- **Forgive quickly:** Avoid long retaliation spirals that hurt everyone.
- **Repeat for all rounds:** Ensures consistent group benefit and maximizes total payoffs over time.

---

This strategy optimally balances cooperation and incentives within the constraints of perfect information, no communication, and repeated interaction. It helps coordinate players around stable cooperation, leveraging repetition and punishment/forgiveness cycles to deter defection and maximize collective gains.
'''

description_COOPERATIVE_70 = '''
Below is a cooperative strategy designed specifically for the Collective Risk Dilemma game as described. It aims to foster and sustain cooperation over multiple rounds, leveraging observation of past actions while cautiously handling defections and endgame effects.

---

### Strategy Name: **Conditional Sustained Cooperation**

---

## Intuition

- The group benefits only if ≥ m players cooperate each round.
- Cooperators pay a cost (losing 1 unit of private payoff) but earn a significant group reward (k > 1).
- Defectors keep their endowment but benefit from cooperators’ actions if enough cooperate.
- The temptation to defect is high, especially in the last rounds.
- Without communication, players must infer cooperativeness from past behavior.

---

## Decision Rules Summary

| Round            | Condition                                         | Action          |
|------------------|-------------------------------------------------|-----------------|
| 1 (First round)  | Start with cooperation                           | Cooperate (C)   |
| Intermediate rounds (2 to r-1) |  
- If at least m players cooperated in previous round **and** this player cooperated last round → maintain cooperation  
- If at least m players cooperated but player defected last round → cooperate to rejoin group  
- If fewer than m cooperators last round → defect (punitive to encourage cooperation)  
| Last round (r)   | Defect (D)                                     | Defect (D)       |

---

## Detailed Explanation

### First round

- Cooperate proactively to signal willingness to cooperate, helping the group reach the threshold.

### Intermediate rounds (2 to r-1)

- **Observation:** The player observes the distribution of cooperators in the previous round.
- **If threshold met (≥ m cooperators):**  
  - If the player cooperated last round, **continue cooperating** to maintain trust and collective payoff.  
  - If the player defected last round (possibly as a test or punishment), now **switch to cooperate** to signal rejoining the cooperative group.

- **If threshold not met (< m cooperators):**  
  - Defect as a mild punishment to signal that cooperation is required to access the group reward.  
  - This “punishment” is not permanently hostile — if cooperation returns next round and threshold is met, player re-joins cooperation.

This conditional approach encourages maintaining cooperation while allowing for forgiveness after isolated defections or testing.

### Last round (r)

- Defect to avoid exploitation, as there is no future round where cooperation can be reciprocated.

---

## Pseudocode

```
Initialize:
  round = 1
  last_action = None

For each round t in [1..r]:

  if t == 1:
    action = C   # Start cooperatively
    
  else if t == r:
    action = D   # Defect on the last round (endgame logic)

  else:
    # Observe previous round outcomes:
    num_cooperators_prev = count_cooperators(t-1)
    cooperated_last_round = (last_action == C)

    if num_cooperators_prev >= m:
      if cooperated_last_round:
        action = C    # Continue cooperation if threshold met and self was cooperative
      else:
        action = C    # Forgive and rejoin cooperation if threshold met but self defected previously
    else:
      action = D      # Punish by defecting if threshold not met

  Play(action)
  last_action = action
```

---

## Notes on Strategy Robustness and Cooperation

- **Stable cooperation:** If all players adopt this strategy, they will cooperate continuously until the last round, reaching the threshold and maximizing payoffs every round.
- **Handling defections:** Isolated defections trigger temporary defection by this strategy, but forgiveness allows cooperative recovery quickly.
- **Endgame defecting:** The last round defect protects against exploitation when no future punishment is possible.
- **No communication needed:** Uses only observed actions and outcomes (common knowledge).
- **Aligns with cooperative mindset:** Seeks to maintain cooperation reliably, maximizes collective payoffs, and minimizes exploitation.

---

If the tournament environment contains diverse strategies, this approach is designed to establish and stabilize cooperation where possible, while protecting against exploitation.
'''

description_COOPERATIVE_71 = '''
**Strategy Name:** Conditional Gradual Cooperation (CGC)

**Core Idea:**  
Start by cooperating to signal willingness and build trust. Then adjust cooperation dynamically based on observed collective behavior to maintain the cooperation threshold _m_. Defect only when collective cooperation breaks down to safeguard private payoffs. Always attempt to meet or exceed the threshold of cooperators _m_ to secure the reward _k_, maximizing joint payoffs. In the last round, defect if cooperation is unlikely to form to avoid unnecessary costs.

---

### 1. Decision Rules: When to Cooperate vs Defect

**Parameters:**
- _n_: number of players
- _r_: total rounds
- _m_: minimum cooperators needed
- _k_: reward factor

**State variables (maintained per round):**
- `C_count_prev`: Number of cooperators in the previous round
- `round`: current round index (1 to _r_)

---

### 2. Edge Case Handling

- **First round (round = 1):**  
  Cooperate unconditionally to initiate cooperative signaling.

- **Intermediate rounds (2 ≤ round < r):**  
  Cooperate if the number of cooperators last round `C_count_prev` ≥ _m_.  
  Defect if `C_count_prev` < _m_ to avoid being exploited when cooperation collapses.

- **Last round (round = r):**  
  Defect unless the previous round had cooperation ≥ _m_ AND you can expect cooperation this round (from heuristic below), because players have no future incentives to cooperate; defecting yields a higher individual payoff when others cooperate or cooperation breaks.

---

### 3. Cooperative Mindset:

- **Preserve Cooperation:** Willing to pay cost of cooperation if others also cooperate — this achieves reward _k_ for everyone.
- **Discourage Exploitation:** Withdraw contribution on signs of collective defection, restoring self-interest.
- **Signal Intent:** By cooperating in round 1, send a credible message to encourage cooperation in others.
- **Encourage Recovery:** If cooperation fails one round, but rebounds the next, resume cooperation to allow group recovery.

---

### 4. Strategy Pseudocode

```python
# Inputs available at start of round t:
# round (t), previous_round_actions: list of all players' previous round actions ('C' or 'D')

def CGC_decision(round, previous_round_actions, m, r):
    # Count previous cooperators
    if round == 1:
        # First round: unconditional cooperation
        return 'C'

    C_count_prev = count_cooperators(previous_round_actions)

    # Last round logic
    if round == r:
        # Defect unless last round cooperation was strong (≥ m) and expect cooperation
        if C_count_prev >= m:
            # If you expect cooperation, cooperate
            # Expectation heuristic: if you cooperated last round and got reward, continue cooperating
            # Simplified here: cooperate if you cooperated last round, else defect
            # Because others have no future to punish or reward cooperation
            # But since no communication, safe to defect to maximize payoff if defection pays off
            # Conservative choice: defect (selfish defecting equilibrium)
            # For pure cooperation alignment, can choose to cooperate if others did
            
            # To align with cooperation mindset:
            # Cooperate if cooperated last round, else defect
            # But since no player IDs, this info must come from own last action stored separately.

            # For simplicity, assume you cooperated last round (state to maintain):
            if my_last_action == 'C':
                return 'C'
            else:
                return 'D'
        else:
            return 'D'  # Cooperation not formed previously; defect to avoid loss

    # Intermediate rounds (2 to r-1)
    if C_count_prev >= m:
        return 'C'  # Cooperation threshold met last round, continue cooperating
    else:
        return 'D'  # Cooperation threshold not met last round, defect to protect self

# Helper function
def count_cooperators(actions):
    return sum(1 for a in actions if a == 'C')

# Note on own_last_action: strategy maintains memory of own action last round.
```

---

### 5. Explanation and Rationale

- **Round 1:** Start by cooperating to encourage others to cooperate — reduces risk of universal defection.
- **Subsequent rounds:**  
  - If sufficient cooperation observed last round (_≥ m_), cooperate again to get reward.  
  - If cooperation failed to reach threshold, defect to avoid wasting endowment.

- **Last round:**  
  Since no future punishment or reward is possible, defect unless cooperation is strong and stable (and you yourself cooperated), which can sometimes sustain cooperation in practice. But a more risk-averse, purely cooperative approach is cooperating if cooperation was present in previous round and you cooperated then.

- **Memory:** Track if you cooperated previously to make better last round decisions.

---

### 6. Summary

| Round      | Condition                             | Action       |
|------------|-------------------------------------|--------------|
| 1          | Always                              | Cooperate    |
| 2 to r-1   | Previous cooperators ≥ m             | Cooperate    |
| 2 to r-1   | Previous cooperators < m             | Defect       |
| r (final)  | Previous cooperators ≥ m AND last own action was C | Cooperate |
| r (final)  | Otherwise                           | Defect       |

---

This strategy balances cooperation with self-protection, facilitates stable cooperation when possible, and adjusts to breakdowns in cooperation while maintaining a cooperative mindset wherever feasible.
'''

description_COOPERATIVE_72 = '''
**Goal:**  
Design a cooperative strategy that aims to reach or exceed the cooperation threshold \( m \) in every round to obtain the reward \( k \), while minimizing exploitation by defectors to the extent possible.

---

## Key Insights

- Cooperation yields a payoff of \( k \) if the threshold \( m \) is met, but costs 1 unit.
- Defectors get to keep their 1-unit endowment risk-free but can also benefit from the reward if enough cooperate.
- When threshold \( m \) is met, defecting can yield a strictly higher payoff than cooperating (e.g., 3 vs 2 in the example), tempting defection.
- Defection threatens the group’s ability to meet the threshold \( m \), lowering all payoffs.
- The game is repeated for \( r \) rounds with perfect information of past actions, enabling conditional cooperation.

---

## Strategy Outline: “Threshold-Triggered Conditional Cooperation”

### Objectives

- **Always try to reach cooperation threshold \( m \) to secure reward \( k \).**
- **Punish defectors to discourage free-riding and maintain cooperation.**
- **Forgive after punishment to allow restoration of cooperation.**
- **Be especially cooperative at the start, and maintain cooperation through nearly all rounds.**
- **Guard against endgame defection by adjusting behavior in last round(s).**

---

## Decision Rules

Assume indexing rounds \( t \in \{1, \dots, r\} \).

Let:

- \( C_t \) = number of cooperators in previous round \( t-1 \).
- \( c_i^{t-1} \) = your own last-round action.
- \( m \) = threshold.

### Round 1 (First Round):

- **Cooperate.**  
  No history yet; lead by example to build trust and establish a baseline.

### Rounds 2 to \( r-1 \) (Intermediate Rounds):

1. **Assess last round cooperation:**  
   - If \( C_{t-1} \ge m \), **cooperate** again to maintain the reward.
   - Else, defect to punish the group for failing cooperation last round.

2. **Handle own prior defection:**  
   - If you defected last round to punish and now \( C_{t-1} \ge m \), **return to cooperation** to restore trust.

3. **If threshold was met but your own payoff was lower due to frequent defectors:**  
   - Keep cooperating to sustain group benefit, trusting others will reciprocate.

### Last Round \( t = r \):

- Defect.  
  **Rationale:** No future rounds to reward or punish; exploiting cooperation is best.

---

## Rationale Behind This Strategy

- **Starts cooperative:** Invites others to cooperate.
- **Conditional cooperation:** Rewards cooperation and punishes defection in the group.
- **Forgiveness:** Enables recovery if punishment caused temporary defection spirals.
- **Last round defection:** Maximizes personal payoff when no future retaliation possible.
- **Sustains cooperation in middle rounds:** Approximates a cooperative “equilibrium.”

---

## Pseudocode

```python
def decide_action(t, r, c_i_last, coop_counts_last, m):
    """
    t: current round (1-based)
    r: total rounds
    c_i_last: my action last round ('C' or 'D'), None if t == 1
    coop_counts_last: number of cooperators in last round, None if t == 1
    m: threshold number of cooperators for reward
    """
    
    if t == 1:
        return 'C'  # Lead cooperation
    
    if t == r:
        return 'D'  # Last round defection for personal gain
    
    # Intermediate rounds
    if coop_counts_last >= m:
        # Threshold met last round
        
        if c_i_last == 'D':
            # I defected last round to punish, now threshold met => forgive and cooperate
            return 'C'
        else:
            # I cooperated last round and reward was given, keep cooperating
            return 'C'
    
    else:
        # Threshold not met last round, punish by defecting
        return 'D'
```

---

## Edge Cases Handling

- **First round:** Always cooperate. Establishes cooperative norm.
- **Last round:** Always defect. No incentive to cooperate any longer.
- **After punishment round:** If others restore cooperation, you forgive and return to cooperation.
- **Repeated failure to reach threshold:** Continue punishment defections until threshold met again.
- **If all defect (e.g., first-round defection by others):** You punish by defecting next round; if others keep defecting, no reward — you lose nothing but also gain nothing.

---

## Summary

This strategy:

- **Encourages stable cooperation cycles.**
- **Discourages exploitation with credible punishment.**
- **Is forgiving to allow recovery from defection mistakes.**
- **Maximizes total group welfare until last round.**
- **Strategically defects last round to avoid being exploited.**

This aligns well with a "cooperative yet rational" mindset appropriate for the Collective Risk Dilemma and the tournament setting described.
'''

description_COOPERATIVE_73 = '''
**Strategy Name:** Conditional Gradual Trust (CGT)

---

### Intuition

The strategy aims to maximize collective payoff by coordinating cooperation when it is beneficial and safe to do so, while minimizing exploitation risk from defectors. It leverages the repeated game structure and perfect information to build and maintain cooperation, retreating to defection when cooperation breaks down, but always giving chances to restore cooperation.

---

### Strategy Description

#### Notation

- Let `t` be the current round (1 ≤ t ≤ r)
- Let `c_t` = number of players who cooperated in round t
- Let `C_i,t` be player i's action in round t
- Let `history` be full record of all players' actions up to previous round
- Let `threshold` = m

---

### 1. **Decision Rules**

---

#### Round 1 (Initial Trust)

- **Action**: Cooperate (C)
- **Rationale**: Establish baseline trust and signal willingness to cooperate early, since the game incentivizes cooperation if enough do so.

---

#### Rounds 2 to r-1 (Conditional Cooperation)

- **Observe**: In the previous round, count cooperators `c_(t-1)`

- **Rule:**

```pseudocode
if c_(t-1) ≥ threshold:
    # Cooperation succeeded previously
    play C
else:
    # Cooperation failed previously
    # Check if I cooperated in t-1
    if I played C in round t-1:
        # Punish defectors by defecting this round
        play D
    else:
        # I defected last round, attempt limited forgiveness to restart cooperation
        play C
```

- **Explanation**:
  - If the cooperation threshold was met previously, continue cooperating to sustain the collective benefit.
  - If threshold not met and I cooperated, defect this round to avoid exploitation.
  - If threshold not met and I defected last round, cooperate now to signal willingness to rebuild cooperation.
  
This promotes a "stick-and-carrot" approach — punishing defection but allowing re-entry into cooperation.

---

#### Last Round (Round r) (Final Cooperation)

- **Rationale**: In the last round, there is no future to incentivize cooperation. Therefore:

```pseudocode
if c_(r-1) ≥ threshold:
    play C  # Last chance to get collective reward
else:
    play D  # Defect since cooperation unlikely or risky to attempt
```

---

### 2. **Handling Edge Cases**

---

#### a. If threshold m is close to n or small relative to n

- Strategy remains the same; since threshold is common knowledge, threshold checks capture difficulty in achieving cooperation.

---

#### b. If cooperation threshold never reached after several rounds

- After 2 consecutive rounds failing threshold when I cooperated, switch to permanent defection for remaining rounds (to avoid exploitation):

```pseudocode
if consecutive_failed_coop_rounds ≥ 2 and last played C:
    always play D from now on
```

---

#### c. If others always defect

- Mimics defectors, minimizing losses.

---

#### d. If others gradually increase cooperation count

- Responds by increasing cooperation as soon as threshold previously met — facilitating stable coordination.

---

### 3. **Summary of Cooperative Mindset**

- Starts with trust by cooperating initially.
- Continues cooperation only if collective cooperation succeeds (threshold met).
- Uses conditional defection to punish defectors and avoid exploitation.
- Forgiving to allow restarting cooperation cycles.
- Attempts to reach collective reward consistently for mutual benefit.
- Avoids unnecessary losses by defecting only when cooperation fails repeatedly.
- In last round, cooperates if threshold met previously to maximize payoff potential.

---

### Overall Pseudocode

```pseudocode
initialize:
  consecutive_failed_coop = 0

for t in 1 to r:
  if t == 1:
    play C
    continue

  prev_coop_count = count_cooperators_in_round(t-1)
  i_played_C_prev = (my_action_in_round(t-1) == C)

  if t == r:
    # Last round decision
    if prev_coop_count >= threshold:
      play C
    else:
      play D
    continue

  if prev_coop_count >= threshold:
    # Cooperation stable last round
    play C
    consecutive_failed_coop = 0
  else:
    # Cooperation failed last round
    if i_played_C_prev:
      # Punish defectors by defecting this round
      play D
      consecutive_failed_coop += 1
    else:
      # Tried defecting last round, now cooperate to restore cooperation
      play C
      consecutive_failed_coop = 0

  # If failed cooperation for two rounds in a row after cooperating, give up
  if consecutive_failed_coop >= 2:
    # Defect permanently for rest of game
    while t <= r:
      play D
      t += 1
    break
```

---

This strategy balances cooperation and caution, incentivizing collective action while protecting oneself from defectors, fitting the cooperative mindset and leveraging repeated interaction.
'''

description_COOPERATIVE_74 = '''
Here is a cooperative strategy designed to promote reaching the cooperation threshold (m cooperators) as often as possible, therefore maximizing collective payoffs, while handling temptation to defect and exploiting observed behavior over repeated rounds.

---

## Strategy Name: Conditional Reciprocal Cooperation with Forgiveness (CRCF)

### Intuition
- Start cooperatively: attempt to reach cooperation threshold immediately.
- Monitor others’ past cooperation.
- Cooperate as long as others do so significantly (conditional cooperation).
- If cooperation drops below threshold due to other defections, defect once to signal dissatisfaction.
- Forgive occasional defections to repair cooperation.
- In the last round, cooperate if the threshold can realistically be met; defect otherwise.

---

### Parameters (internal to strategy)
- `cooperate_threshold` = m (minimum cooperators needed)
- `cooperation_ratio_threshold` = 0.7 (fraction of players cooperating last round to sustain cooperation)
- `forgiveness_window` = 2 rounds (period in which we overlook occasional defections)
- `last_round_cooperation_check` (to decide last round move)

---

### Decision Rules

#### Round 1 (t=1)
- Cooperate unconditionally (C).

#### Subsequent rounds (2 ≤ t < r)
- Observe actions of all players in round t-1.
- Calculate `prev_cooperators_count` = number of players who cooperated in round t-1.
- Calculate `prev_cooperation_ratio` = prev_cooperators_count / n.
- Track how many rounds since last known full cooperation round.

**If** `prev_cooperators_count >= m` (threshold met in previous round)  
  → Cooperate (C)

**Else** (threshold not met in previous round)  
- If too many defections observed:
  - Defect once (D) as a warning/punishment (if not already defected last round)
- Else: forgive and cooperate (C)
  
To operationalize forgiving:
- Keep count of consecutive rounds cooperation threshold was missed.
- If cooperation threshold missed for ≤ forgiveness_window rounds, still cooperate.
- If cooperation threshold missed for > forgiveness_window, defect once then resume cooperation.

#### Round r (last round)
- Cooperate if cooperation threshold is likely to be met:
  - If previous round’s cooperators ≥ m - 1 (considering own cooperation), cooperate.
- Defect otherwise (no future punishment to gain by cooperating here).

---

### Summary in Pseudocode

```
state:
  last_round_cooperators = None
  rounds_threshold_missed = 0
  last_action = 'C'  // initial action

on round t:
  if t == 1:
    action = 'C'
    last_action = 'C'
    return action

  // t > 1, observe previous round actions
  prev_cooperators_count = count_cooperators(round = t-1)

  if prev_cooperators_count >= m:
    // cooperation threshold met in previous round
    rounds_threshold_missed = 0
    action = 'C'
  
  else:
    rounds_threshold_missed += 1

    if rounds_threshold_missed <= forgiveness_window:
      // forgive occasional misses, keep cooperating
      action = 'C'
    else:
      // defect once to signal punishment
      if last_action == 'C':
        action = 'D'
      else:
        // already defected last round, return to cooperation
        rounds_threshold_missed = 0
        action = 'C'

  // last round special logic
  if t == r:
    if prev_cooperators_count >= m - 1:
      action = 'C'  // cooperate to reach threshold
    else:
      action = 'D'  // defect - no incentive to cooperate last round

  last_action = action
  return action
```

---

### Explanation

- **Round 1:** Start cooperative to build trust.
- **Maintaining cooperation:** Cooperate if cooperation threshold was met previously.
- **Forgiveness:** Don’t punish immediately after one round of failed cooperation, as mistakes or attempts to test strategies may occur.
- **Punishment:** Defect once after repeated failures to coordinate cooperation to discourage free-riding or persistent defection.
- **Return to cooperation:** After signaling dissatisfaction via defection, give the group chance to recover cooperation.
- **Last round:** No future punishment is possible, so defect unless cooperation is very likely and beneficial, to maximize own payoff.

---

### Why this strategy is cooperative?

- It tries to sustain high cooperation by starting and mostly playing C.
- It supports the collective good (ensuring at least m cooperators)
- It uses punishment sparingly and with forgiveness to maintain cooperation.
- It adapts to group behavior and does not blindly cooperate against persistent defection.
- In the final round, it balances self-interest with cooperation likelihood.

---

If implemented alongside identical or like-minded strategies, this approach should coordinate stable cooperation rounds and high total payoffs.
'''

description_COOPERATIVE_75 = '''
**Strategy Name:** Conditional Reciprocity with Threshold Coordination (CRTC)

---

## Intuition and Overview

This strategy aims to foster and sustain cooperation by:

- Starting cooperatively to signal willingness.
- Cooperating only if cooperation is reciprocated at a sufficient level.
- Using observed number of cooperators in previous rounds to estimate group willingness.
- Defecting if cooperation breaks down to avoid being exploited.
- Attempting to coordinate around the minimum cooperation threshold *m*.
- Cooperating on the last round if cooperation was maintained previously, to maximize endgame payoff.

This approach balances risk (losing out if others defect) with reward (collective payoff when threshold is met), leveraging repeated interaction and observable actions/payoffs.

---

## Notation:

- **n:** number of players
- **r:** total rounds
- **m:** cooperation threshold
- **k:** cooperation reward factor
- **t:** current round (1 to r)
- **C_t:** set of players who cooperated in round *t*
- **countC_t:** size of C_t

---

## Decision Rules

### Round 1 (Initialization):

- Cooperate to signal willingness.
  
### Round t (2 ≤ t ≤ r - 1):

- Observe countC_(t-1) from previous round.
- If countC_(t-1) ≥ m → **Cooperate** (others showed enough cooperation).
- Else → **Defect** (others defected majority, no incentive to cooperate).

### Round r (Last Round):

- If countC_(r-1) ≥ m → **Cooperate** (to maximize final payoff).
- Else → **Defect** (likely exploitation risk with no future rounds).

---

## Edge Cases Handling

- **If fewer than *m* cooperators last round:** Defect to avoid unilateral contribution.
- **If exact *m* cooperators last round:** Cooperate to maintain minimum cooperation.
- **If in any previous round cooperation level >= m but drops sharply next round:** follow same logic — defect to avoid exploitation.
- **If suspicions of random defections:** Reliance on threshold *m* and majority cooperation to avoid being duped by a few defectors.

---

## Pseudocode

```python
def decide_action(t, n, r, m, k, history):
    # history: list of sets of cooperators in past rounds; history[0] = C_1, etc.

    if t == 1:
        # First round: cooperate to signal goodwill
        return 'C'

    # From second round onwards:
    last_round_cooperators = history[t-2]  # zero indexed list, round t-1 is t-2 index
    count_last_round = len(last_round_cooperators)

    if t < r:
        # Intermediate rounds
        if count_last_round >= m:
            return 'C'
        else:
            return 'D'
    else:
        # Last round
        if count_last_round >= m:
            return 'C'
        else:
            return 'D'
```

---

## Strategic Rationale

- **Starting cooperative** builds trust and signals your intent to sustain cooperation.
- **Conditional cooperation** guards against exploitation: if the group is not meeting the threshold, you avoid the cost of cooperation.
- **Using threshold count rather than individual play** avoids punishing minor defections too harshly but responds to overall group behavior.
- **Persisting cooperation when threshold met** sustains the collective good and maximizes payoffs.
- **Defecting when falling below threshold** protects from unilateral loss.
- **No communication allowed, so rely on public info**: actions and payoff info suffice.
- **Repeated interaction** makes cooperation rational as long as others cooperate sufficiently.

---

## Cooperative Mindset

- The strategy always tries to reach and maintain collective action.
- It punishes defection but only relative to the group's ability to maintain cooperation.
- Encourages others to cooperate by demonstrative initial cooperation.
- Assumes rational agents will respond to cooperation with cooperation.
- Strives for the welfare-maximizing outcome when feasible.

---

This balanced approach is robust to moderate defection, aligned with incentives, and optimized for the repeated collective risk dilemma environment.
'''

description_COOPERATIVE_76 = '''
Below is a cooperative strategy designed for the **Collective Risk Dilemma** that balances commitment to cooperation with responsiveness to others’ actions in the repeated setting. The strategy aims to reliably meet the cooperation threshold \(m\) while guarding against exploitation by defectors.

---

## Strategy Name: **Conditional Threshold Cooperation (CTC)**

### Intent
- Foster cooperation to reach the minimum threshold \(m\) each round.
- Punish persistent defection to discourage free-riding.
- Use history to mutually ensure cooperation.
- Resume cooperation after punishment if others do.

---

### Key Intuition

- **Initial trust:** Start by cooperating to signal willingness to cooperate.
- **Maintain cooperation if others cooperate:** Continue to cooperate if at least \(m - 1\) others cooperated last round (meaning if you cooperate too, threshold is likely to be met).
- **Punish if cooperation unlikely:** If fewer than \(m - 1\) other players cooperated last round, defect this round to avoid cost getting exploited.
- **Forgive and retry cooperation:** After defecting one round as punishment, try cooperating again next round to attempt reestablishing cooperation.
- **Final round defect:** Defect in the last round to maximize payoff assuming no future punishment possible.

---

### Detailed Decision Rules

Let:
- \(C_{-i}^{t-1} =\) number of other players (excluding you) who cooperated in previous round \(t-1\).
- \(t =\) current round (1 to \(r\)).

---

#### For each round \(t\):

1. **If \(t = 1\):**  
   - Cooperate.
   - Rationale: Establish cooperative precedent from the start.

2. **Else if \(t = r\) (last round):**  
   - Defect.
   - Rationale: No future repercussions from defection, so maximize private payoff.

3. **Else ( \(1 < t < r\) ):**  
   - If last round you cooperated:
     - If \(C_{-i}^{t-1} \geq m - 1\):  
       **Cooperate.**  
       (Others mostly cooperated -> continue cooperation to secure reward.)  
     - Else:  
       **Defect.**  
       (Insufficient cooperation from others -> avoid cost of cooperation.)  
       
   - If last round you defected (i.e., you punished last round):  
     **Cooperate.**  
     (Try to re-establish cooperation to avoid endless punishment cycles.)

---

### Pseudocode

```python
def decide_action(round_t, r, m, n, last_round_actions_i, last_round_actions_others):
    """
    round_t: current round number
    r: total rounds
    m: minimum cooperators needed (including self)
    n: total players
    last_round_actions_i: your action in round t-1, 'C' or 'D' or None if first round
    last_round_actions_others: list of actions of other players in round t-1, ['C','D',...]
    """
    if round_t == 1:
        return 'C'  # Start cooperatively
    
    if round_t == r:
        return 'D'  # Last round defect
    
    # Count number of cooperators excluding self
    coop_others = last_round_actions_others.count('C')
    
    if last_round_actions_i == 'C':
        # You cooperated last round
        if coop_others >= (m - 1):
            return 'C'  # Continue cooperating if others mostly cooperated
        else:
            return 'D'  # Punish by defecting when others insufficiently cooperate
    else:
        # You defected last round (punishment phase)
        return 'C'  # Forgive and attempt to cooperate again
```

---

### Notes on Strategy Behavior

- **Encourages stable cooperation:** Will cooperate indefinitely if other players meet the threshold \(m -1\) cooperators each round, ensuring the threshold \(m\) including self.
- **Punishes defection:** Defects one round after observing insufficient cooperation to punish defectors.
- **Forgives:** After defecting in punishment round, tries to cooperate again next round to break defection cycles.
- **Robust to noise:** Minimal punishment length avoids cascading defection.
- **Selfish incentive alignment:** Players can maximize payoffs by cooperating because defecting when others cooperate triggers punishment in subsequent rounds.
- **Endgame reasoning:** Defects in last round where no future punishment is possible.

---

### Summary

| Round       | Condition                                      | Action |
|-------------|------------------------------------------------|--------|
| 1           | Initial round                                  | C      |
| 2 to r-1    | If previously cooperated and ≥ (m-1) others C | C      |
|             | If previously cooperated and < (m-1) others C | D      |
|             | If previously defected                         | C      |
| r (last)    | Any state                                     | D      |

---

This strategy is strong in encouraging the mutual cooperation that yields the group reward \(k\), while protecting itself from exploitation without engaging in permanent defection cycles. It clearly aligns with a cooperative mindset through initial trust, conditional cooperation, and forgiveness.
'''

description_COOPERATIVE_77 = '''
Here is a cooperative strategy designed to encourage and sustain cooperation in the Collective Risk Dilemma game. It is structured to foster cooperation from the start, use the history of play to sustain or recover cooperation, and account for the finite horizon of r rounds.

---

## Strategy Name: *Conditional Cooperative Assurance*

---

## Intuition
- Cooperate from the outset to signal willingness.
- Require evidence of enough cooperators (≥ m) in previous rounds to continue cooperation.
- If cooperation breaks down, attempt forgiveness but only if others return to cooperating.
- Defect only if clear that cooperation is failing and unlikely to be restored.
- On the last round, play defect if cooperation has not reliably formed, else cooperate to maximize joint payoff.

---

## Decision Rules

Let round index: t ∈ {1, 2, ..., r}  
Let history up to round t-1 be known: actions_i[t] for all players i, all rounds < t

Define:  
- coop_count[t] = number of players who cooperated in round t  
- safe_round[t] = (coop_count[t] ≥ m) → cooperation succeeded that round

---

### Round 1 (t=1)  
**Action:** Cooperate (C)  
**Reason:** Establish goodwill and test willingness. Provide baseline cooperation signal with no history.  

---

### Intermediate Rounds (1 < t < r)  

At the start of round t:

1. Evaluate previous round t-1:
   - If safe_round[t-1] == True:
     - Continue to cooperate this round (C)  
     - Reason: Cooperation threshold met previously → cooperation reciprocated.  
   - Else:
     - Cooperation failed last round.

2. If cooperation failed last round (safe_round[t-1] == False):
   - Check trend:
     - If safe_round[t-2] == True (cooperation before last round succeeded):
       - Forgive once: play cooperate (C) this round (attempt to restore cooperation)
     - Else:
       - Defect (D) this round (cooperation repeatedly failing, original cooperators likely folding)

---

### Last Round (t = r)  

We want to maximize payoff knowing no future punishment or reward possible:

- If safe_round[r-1] == True (prior round was cooperative):
  - Cooperate (C) to secure collective reward this final time.
- Else:
  - Defect (D) to maximize individual payout, as cooperation is unlikely to be reliable.

---

## Summary Table of Decision Logic

| Round   | Condition                                      | Action  |
|---------|------------------------------------------------|---------|
| t = 1   | (No history)                                  | Cooperate (C) |
| 1 < t < r | safe_round[t-1] == True                      | Cooperate (C) |
| 1 < t < r | safe_round[t-1] == False and safe_round[t-2] == True  | Cooperate (C) (forgive) |
| 1 < t < r | safe_round[t-1] == False and safe_round[t-2] == False | Defect (D) |
| t = r   | safe_round[r-1] == True                        | Cooperate (C) |
| t = r   | safe_round[r-1] == False                       | Defect (D) |

---

## Pseudocode

```python
def strategy(my_index, n, r, m, k, history):
    # history: list of lists with player actions per round, coded as 'C' or 'D'
    # history[t][i] = action of player i at round t (0-based indexing assumed)
    
    t = len(history) + 1  # current round number
    
    def coop_count(round_idx):
        return sum(1 for a in history[round_idx] if a == 'C')
    
    def safe_round(round_idx):
        return coop_count(round_idx) >= m
    
    # Round 1: cooperate
    if t == 1:
        return 'C'
    
    # Round r (last round)
    if t == r:
        if safe_round(r - 2):  # r-2 indexing because history is 0-based, round t-1 = r-1, so safe_round index is r-2
            return 'C'
        else:
            return 'D'
    
    # Intermediate rounds
    if safe_round(t - 2):  # previous round safe
        return 'C'
    else:
        # previous round not safe
        if t > 2 and safe_round(t - 3):
            # forgive once
            return 'C'
        else:
            # defect if repeated failure or no history to forgive
            return 'D'
```

---

## Strategic Properties

- **Encourages early cooperation:** Cooperates first round to lead by example.
- **Maintains cooperation if reciprocated:** If enough players cooperate, continues cooperating.
- **Forgiveness for one round:** Allows re-entry into cooperation if others change behavior.
- **Limits exploitation:** Defects if cooperation repeatedly fails to avoid being exploited by defectors.
- **Ends rationally:** Last round defection if cooperation not consistently formed, cooperates otherwise for collective gain.
- **Common knowledge compatible:** Uses only observable histories and parameters.
- **No communication needed:** Purely history-dependent action choice.

---

## Additional Notes

- If in an environment with mostly cooperative strategies, this will sustain cooperation.
- If opponents defect persistently, the strategy defect to protect self-interest.
- The forgiveness mechanism helps recover cooperation after a one-time breakdown (e.g., errors or temporary temptation).
- The strict threshold of m cooperators aligns perfectly with payoff structure and incentivizes maintaining threshold compliance.

---

If you want a more aggressive forgiveness or more tolerant behavior, you can extend to forgiving multiple rounds of defection, but at the risk of exploitation. This simple strategy balances cooperation and caution well for this repeated risk-dilemma.
'''

description_COOPERATIVE_78 = '''
Below is a cooperative strategy designed for the Collective Risk Dilemma tournament. It aims to reliably achieve the cooperation threshold \( m \) each round, while adjusting behavior based on observed actions to avoid being exploited. It leverages reciprocity and conditional cooperation to foster a cooperative equilibrium.

---

# Cooperative Strategy: Conditional Threshold Cooperation (CTC)

### Key intuition:
- Achieving cooperation by consistently ensuring at least \(m\) cooperators each round gets the whole group the reward \(k\).
- Cooperate initially to signal willingness.
- Monitor others’ cooperation levels to maintain cooperation only when others do.
- Defect if the group defects repeatedly or cooperation falls below \(m\), to avoid being exploited.
- Return to cooperation if others start cooperating again, enabling recovery from mutual defection.
- In the final round, cooperate if prior cooperation was stable; otherwise, defect to maximize personal payoff.

---

## Strategy Components

### State variables maintained by the player:

- **round**: current round number (1-indexed)
- **history**: records of previous rounds' action profiles \(\{A_1, A_2, \ldots, A_{round-1}\}\) where each \(A_t\) is a vector of all players' actions that round
- **countC[t]**: number of players cooperating in round \(t\)
- **recent_cooperation**: Boolean flag indicating if recent rounds had cooperation ≥ \( m \)
- **tolerance**: number of recent rounds to consider for judging cooperation stability (e.g., 2 or 3)
- **my_last_action**: player's own last action \(C\) or \(D\)

---

## Decision Rules

### Round 1 (first round):

- Cooperate: \( c_i = 1 \)
  
Reason: Signal willingness to cooperate; no history yet.

---

### Rounds 2 to \(r-1\):

1. **Compute recent cooperation count:**

   \[
   \text{recent_coop_rounds} = \# \{ t \in [round - \text{tolerance}, round - 1] \mid countC[t] \geq m \}
   \]

2. **Evaluate cooperation stability:**

   - If \(\text{recent_coop_rounds} \geq \text{tolerance} - 1\):  
     cooperation seen as stable (others mostly cooperate)
   - Else: cooperation unstable (others defecting frequently)

3. **Choose action:**

   - If cooperation is stable:
     - Cooperate (i.e., play \(C\)) to keep threshold met
   - Else:
     - Defect (play \(D\)) to avoid exploitation while others defect

---

### Final round \(r\):

- If cooperation stable in recent rounds (i.e., players almost always reached threshold \(m\)):
  - Cooperate once more to maintain group benefit
- Else:
  - Defect to maximize private payoff (since no future rounds to retaliate or recover cooperation)

---

## Special considerations

- To **avoid persistent exploitation**, if you detect your cooperation is not triggering sufficient other cooperators (drop in \(countC\) below \(m\) after you cooperated), switch to defection until others reciprocate.
- To **forgive occasional defections**, tolerate up to 1 round with cooperation < \(m\) before abandoning cooperation.
- No explicit communication possible, so rely purely on observed past actions.

---

## Pseudocode

```python
def decide_action(round, r, m, k, n, history, my_id, tolerance=2):
    # Extract past rounds cooperation counts
    countC = []
    for t in range(len(history)):
        round_actions = history[t]
        num_c = sum(1 for a in round_actions if a == 'C')
        countC.append(num_c)

    # First round always cooperate
    if round == 1:
        return 'C'

    # Calculate recent cooperation stability
    check_from = max(0, len(countC) - tolerance)
    recent_coop_rounds = sum(1 for c in countC[check_from:] if c >= m)
    cooperation_stable = (recent_coop_rounds >= tolerance - 1)

    # Final round behavior
    if round == r:
        if cooperation_stable:
            return 'C'
        else:
            return 'D'

    # Intermediate rounds
    if cooperation_stable:
        return 'C'
    else:
        return 'D'
```

---

## Summary

- **First round:** Cooperate to initiate trust.
- **Subsequent rounds:** Cooperate if, in the last few rounds, at least \(m\) cooperators were present consistently.
- **If cooperation breaks down:** Defect to avoid loss; return to cooperation if others do.
- **Last round:** Cooperate only if the group has cooperated before; otherwise defect.

This strategy promotes mutual assurance and stable cooperation without being blindly exploitable, aligning with the cooperative mindset and maximizing expected rewards for all.

---

If you want, I can formulate a more sophisticated strategy with probabilistic forgiveness or specific retaliation schemes, but this baseline should perform solidly in the tournament setting.
'''

description_COOPERATIVE_79 = '''
Here is a detailed cooperative strategy tailored for the **Collective Risk Dilemma** with parameters \((n, r, m, k)\).

---

## Strategy Overview:  
**Goal:** Achieve the threshold \(m\) cooperators each round to secure the reward \(k\) for all, keeping cooperation stable through repeated rounds and avoiding exploitation.

**Core Idea:**  
- Start cooperatively to build trust.  
- Use observed cooperation counts from previous rounds to adjust participation carefully.  
- Ensure at least \(m\) cooperators each round to guarantee the reward.  
- Discourage defection by reducing own cooperation when collective cooperation falls short (punishment phase), but quickly return to cooperation when threshold is met again.

---

## Decision Rules

### Initialization (Round 1):
- **Always cooperate**.  
  *Reason:* Set a cooperative precedent; no history of defection yet.

---

### Subsequent Rounds (2 … r-1):

Let \(C_{t-1}\) = number of cooperators observed in previous round \((t-1)\).

Define a target cooperation level between:

- A *safe lower bound*: \(m\) (minimum cooperators needed)  
- A *desired buffer*: \(m + b\), where \(b = 1\) or \(b=2\) if \(m + b \leq n\), else \(b=0\).

The strategy tries to maintain at least \(m\) cooperators but prefers some buffer to avoid risk of falling below \(m\).

**Rules:**

1. If \(C_{t-1} \geq m\):  
   - Cooperate in round \(t\) if I cooperated in round \(t-1\) OR if number of cooperators from last round approximates or exceeds \(m + b\).  
   - Otherwise, defect (to avoid unnecessary cost if cooperation is abundant and my defection keeps \(m\) cooperators).

2. If \(C_{t-1} < m\) (threshold NOT met last round):  
   - **Punish defectors:** Defect if I cooperated last round.  
   - **Attempt to re-build cooperation:** Cooperate if I defected last round but the total number of cooperators last round was just below \(m\), indicating a chance to lift cooperation over the threshold.

The rationale is to discourage defectors by refusing to cooperate after failure but allow re-entry to cooperation to restore the collective good.

---

### Last Round (Round r):

- **Cooperate if** the threshold \(m\) was met in round \(r-1\) or you cooperated in round \(r-1\).  
- **Defect otherwise.**  
*Reason:* With no future rounds, less incentive to punish; maintain cooperation if stable.

---

## Summary Pseudocode:

```python
def decide_action(t, c_i_prev, cooperators_prev):
    # t: current round (1-based)
    # c_i_prev: did this player cooperate prev round? (True/False)
    # cooperators_prev: total number of cooperators in previous round

    m, n, r = game_parameters()  # known constants
    b = 1 if (m + 1) <= n else 0  # small buffer

    if t == 1:
        # First round starts cooperatively
        return "C"

    elif t == r:
        # Last round
        if cooperators_prev >= m or c_i_prev:
            return "C"
        else:
            return "D"

    else:
        # Intermediate rounds
        if cooperators_prev >= m:
            # Threshold met last round
            if c_i_prev:
                # Continue cooperating to maintain trust
                return "C"
            else:
                # If cooperation abundant (>= m+b), defect to reduce cost
                if cooperators_prev >= (m + b):
                    return "D"
                else:
                    return "C"
        else:
            # Threshold NOT met last round - punishment phase
            if c_i_prev:
                # I cooperated last round but threshold failed → defect now (punish)
                return "D"
            else:
                # I defected last round, attempt to re-cooperate if close to threshold
                if cooperators_prev >= (m - 1):
                    return "C"
                else:
                    return "D"
```

---

## Additional Notes:

- **Buffer \(b\):** encourages some cautious cooperation beyond \(m\) to maintain stability against small fluctuations. \(b\) can be tuned depending on \(n, m\).

- **Dynamic response:** The strategy is **conditional cooperative** — willing to cooperate if others do, but ready to punish defection by defecting as well, deterring free-riders.

- **No communication needed:** The strategy uses only observed actions and cooperation counts each round.

- **Perfect monitoring:** Assumes full knowledge of other players’ previous actions and payoffs.

---

## Why is this Cooperative?

- Starts cooperatively without suspicion.
- Aims to guarantee the public reward \(k\) by maintaining at least \(m\) cooperators each round.
- Encourages stability of cooperation over time.
- Uses fair punishment to discourage defectors, but also allows forgiven reintegration.
- Avoids reckless defection that undermines group payoffs.

---

If implemented and interfaced correctly, this strategy should foster cooperation, maximize joint returns for all players, and be robust against defectors in the repeated collective risk dilemma.
'''

description_COOPERATIVE_80 = '''
Below is a cooperative strategy tailored to the Collective Risk Dilemma as specified. The strategy aims to coordinate cooperation over multiple rounds to ensure the group reaches or surpasses the cooperation threshold **m** each round, maximizing the collective payoff.

---

## Strategy Overview: Conditional Reciprocity with Threshold Signaling

**Key idea:**  
Start cooperatively, reward collective cooperation in previous rounds by cooperating again, but defect if cooperation collapses in a way that threatens meeting the threshold. Use observations of others’ actions to infer commitment and adjust. Strive to maintain group cooperation in early and middle rounds and softly tolerate occasional defections, but prevent free-riding that would cause cooperation to fall below the threshold.

---

## Decision Rules

### Notation
- **r** = total rounds
- **t** = current round (1 to r)
- **n** = number of players
- **m** = minimum cooperators needed
- **k** = reward multiplier
- **C_t** = number of observed cooperators last round
- **my_action[t]** = action chosen this round (C or D)

---

### Round 1 (Initialization)
- **Action:** Cooperate (C)
- **Rationale:** Establish cooperative intent and signal willingness to contribute for collective benefit.

---

### Rounds 2 to r - 1 (Middle rounds)

#### Step 1: Check cooperation level last round
- Let **C_{t-1}** = number of players who cooperated in round t-1.
- Let **m** = threshold for payoff.

#### Step 2: Determine action

- **If C_{t-1} ≥ m** (threshold met in previous round):
  - **If I cooperated last round:** Cooperate again (rewarding mutual cooperation).
  - **If I defected last round:**
    - Check if my defection was "safe," i.e., last round's cooperators excluding myself still met threshold:
      - If yes: I may defect again (free riding tolerated when threshold met).
      - If no: cooperate this round (to repair cooperation level).
  
- **If C_{t-1} < m** (threshold not met last round):
  - Cooperate this round to help restore the threshold.

---

### Round r (Final round)

- **If cooperation level last round ≥ m:**
  - Defect (D) to maximize private endowment gain. Cooperation here has no future benefit.
- **Else:**
  - Cooperate (C) to try to meet threshold one last time.

---

### Additional nuances:

- **Tolerance margin:**  
  If the previous round’s cooperation is just below threshold (e.g., m - 1), stay cooperative to try and reach threshold next round.

- **Handling persistent defection:**  
  If cooperation falls significantly (e.g., fewer than m - 1 players cooperate two rounds in a row), softly punish by defecting to signal dissatisfaction.

- **Incentivize recovery:**  
  If cooperation recovers in a subsequent round, return to cooperating immediately.

---

## Pseudocode

```python
def decide_action(t, r, n, m, k, my_history, opponent_histories):
    # my_history: list of my past actions (C or D)
    # opponent_histories: list of lists with opponents' past actions
    
    # Round 1: Always cooperate
    if t == 1:
        return 'C'
    
    # Count cooperators last round
    last_round = t - 1
    cooperators_last_round = 0
    for h in opponent_histories:
        if h[last_round - 1] == 'C':
            cooperators_last_round +=1
    if my_history:
        if my_history[last_round - 1] == 'C':
            cooperators_last_round +=1
    
    # Final round logic
    if t == r:
        if cooperators_last_round >= m:
            return 'D'
        else:
            return 'C'
    
    # Middle rounds logic
    if cooperators_last_round >= m:
        # Threshold met last round
        
        my_last_action = my_history[last_round - 1]
        
        if my_last_action == 'C':
            # Reward cooperation by cooperating again
            return 'C'
        else:
            # I defected last round, check if defection was safe
            # Exclude self defection: count cooperators without me last round
            cooperators_excl_me = cooperators_last_round - 1
            
            if cooperators_excl_me >= m:
                # Defection safe to continue
                return 'D'
            else:
                # Cooperation needed to maintain threshold
                return 'C'
    else:
        # Threshold not met last round: cooperate to recover
        return 'C'
```

---

## Strategy Summary

| Round            | Condition                             | Action   | Rationale                             |
|------------------|------------------------------------|----------|-------------------------------------|
| 1                | First round                        | Cooperate (C) | Signal cooperation upfront           |
| 2 to r-1         | Threshold met last round           | If cooperated last round: Cooperate (C) | Reward cooperation                   |
|                  |                                    | If defected last round and threshold met without me: Defect (D) | Free-riding tolerated if safe        |
|                  |                                    | Else: Cooperate (C)                 | Repair cooperation                   |
| 2 to r-1         | Threshold not met last round       | Cooperate (C)                      | Help recover cooperation             |
| r (final round)  | Threshold met last round           | Defect (D)                        | No future, maximize private payoff   |
| r (final round)  | Threshold not met last round       | Cooperate (C)                    | Last chance to meet threshold        |

---

## Cooperative Mindset

- **Start with good faith cooperation.**
- **Condition cooperation on observed group cooperation to sustain cooperation.**
- **Tolerate occasional defection if it does not endanger group payoff.**
- **Repair and recover cooperative state if breakdown occurs.**
- **Maximize collective gain by ensuring threshold is met early and mid-game.**
- **Defect only when cooperation has been stable and future rounds no longer incentivize cooperation.**

---

This strategy balances incentives for cooperation and the temptation to defect, employs reciprocity, and leverages perfect information about past rounds to coordinate with others despite the lack of communication. It should encourage stable cooperation among rational agents adhering to similar reasoning.
'''

description_COOPERATIVE_81 = '''
Below is a cooperative strategy designed specifically for the Collective Risk Dilemma as described. The strategy aims to reliably reach the cooperative threshold *m* early, maintain cooperation throughout, and handle the collective risk efficiently, while being robust to potential defections from others.

---

## Strategy Name: Gradual Trust and Threshold Cooperation (GTTC)

### Intuition and Goals

- **Goal:** Achieve and maintain at least *m* cooperators each round to earn the reward *k*.
- **Trust-building:** Start cooperatively to signal willingness to cooperate.
- **Monitoring:** Observe others’ cooperation counts in all previous rounds to update trust estimates.
- **Threshold Maintenance:** Adjust cooperation decisions to meet but not excessively exceed the threshold *m*.
- **Dealing with Defection:** Punish defection mildly by reducing cooperation, but give chances for re-entry (avoid full collapse).
- **Final Round:** Full cooperation since there is no future punishment possible.

---

### Decision Rules

**Notation:**

- Let *t* = current round (1 ≤ t ≤ r)
- Let *C_t* = number of players who cooperated in round *t*
- Let *M* = threshold of minimum cooperators needed (m)
- Let *n* = number of players
- Let *Defectors_t* = set of players who defected in round *t*
- Let *Trust_i* = measure of reliability for player *i*, initially full trust
- Your own index is *self*

---

### Initialization (Before Round 1)

- Initialize `Trust_i = 1.0` for all players i ≠ self
- Initialize history records of rounds (empty)

---

### Round 1

- **Action:** Cooperate (`C`)

*Rationale:* Signal commitment to cooperation from the start.

---

### Subsequent Rounds (2 ≤ t < r)

1. Calculate `Expected_Cooperators` for current round by summing trusts for all players excluding self, plus self cooperating (1.0).
   
   \[
   Expected\_Cooperators = 1.0 + \sum_{i \neq self} Trust_i
   \]

2. **If** \(Expected\_Cooperators \geq M\), **then** cooperate (`C`).

3. **Else** defect (`D`).

4. After the round outcome is observed (number of cooperators *C_t* and who cooperated/defected):

   - For each player i ≠ self:
     - If i cooperated at round t, increase or maintain \(Trust_i\):
       \[
       Trust_i \leftarrow \min(Trust_i + \Delta_{up}, 1.0)
       \]
     - If i defected at round t, decrease \(Trust_i\):
       \[
       Trust_i \leftarrow \max(Trust_i - \Delta_{down}, 0.0)
       \]

   Choose modest constants \(\Delta_{up}\) and \(\Delta_{down}\), e.g. \(\Delta_{up} = 0.05\), \(\Delta_{down} = 0.1\).

*Rationale:* We trust players based on recent behavior, adjusting trust incrementally to avoid harsh punishment but respond to defection.

---

### Final Round (t = r)

- Always cooperate (`C`).

*Rationale:* Last round offers no future punishment, full cooperation maximizes joint payoff and reputation gains if relevant.

---

### Edge Cases & Additional Notes

- **If many players defect initially:** Trust values will decrease, leading to defection. This is consistent with a "punish-defect" response, but the incremental adjustments allow the possibility of re-gaining trust if cooperation resumes.
  
- **If borderline cases arise where Expected_Cooperators is just below M:** The strategy defects to avoid being a sucker, forcing players to act cooperatively to cross threshold.
  
- **If the strategy notices repeated low cooperation rounds:** It continues defecting until trust rebuilds, avoiding exploitation.
  
- **No direct communication:** Trust updates rely solely on observed actions and cooperation counts.

---

## Pseudocode Summary

```
Initialize Trust_i = 1.0 for all i != self
Set Δ_up = 0.05, Δ_down = 0.1

for round t in 1 to r:
    if t == 1:
        play C
    else if t == r:
        play C
    else:
        Expected_Cooperators = 1.0 + sum(Trust_i for all i != self)
        if Expected_Cooperators >= M:
            play C
        else:
            play D

    # After round t actions and payoffs are observed:
    for each player i != self:
        if player i cooperated in round t:
            Trust_i = min(Trust_i + Δ_up, 1.0)
        else:
            Trust_i = max(Trust_i - Δ_down, 0.0)
```

---

## Cooperative Mindset Justification

- Starts with cooperation, signaling good faith.
- Seeks to maintain collective threshold, not just individual payoff.
- Builds and updates trust to allow recovery from defections.
- Never defects unnecessarily when cooperation is viable.
- Fully cooperates in final round to avoid unnecessary losses.
- Provides a forgiving and flexible framework to enable sustained collective cooperation.

---

If all or most players use similar logic, the group will achieve threshold *m* cooperators in all rounds, maximizing payoffs for all. This balances self-interest with group benefit and the iterative nature of the repeated game.
'''

description_COOPERATIVE_82 = '''
**Cooperative Strategy for the Collective Risk Dilemma**

---

### Strategy Overview

This strategy promotes cooperation by:

- Starting with cooperation to build trust.
- Monitoring others’ cooperation each round.
- Continuing cooperation as long as enough players cooperate.
- Defecting only if the cooperation level falls below the threshold.
- Attempting to re-establish cooperation after defections.
- Adjusting behavior in the last round to prevent exploitation.

---

### Key Intuition

- Cooperate early and signal reliability.
- Cooperate as long as *at least* (m) players cooperate, ensuring the reward is realized.
- Defect only if cooperation breaks down, to avoid unnecessary losses.
- On the last round, avoid the temptation to defect since there is no future punishment or reward continuation.

---

### Parameters Recap

- **n:** number of players
- **r:** number of rounds
- **m:** minimum cooperators needed
- **k:** reward multiplier if threshold met

---

### Pseudocode Description

```python
# Variables to track
round_number = 1
past_cooperators = None  # track who cooperated last round

def decide_action(round_number, past_cooperators, m, r):
    # First round: cooperate to build trust
    if round_number == 1:
        return "C"
    
    # Last round:
    # If cooperation was stable previously, cooperate to ensure collective gain.
    # Otherwise, defect to avoid being exploited as future punishment isn't possible.
    if round_number == r:
        if past_cooperators is not None and len(past_cooperators) >= m:
            return "C"
        else:
            return "D"
    
    # Intermediate rounds:
    # If at least m players cooperated last round, cooperate to maintain the reward.
    # Else defect to avoid a needless cost.
    if past_cooperators is not None and len(past_cooperators) >= m:
        return "C"
    else:
        return "D"
```

---

### Detailed Decision Rules

1. **Round 1: Cooperate (C)**
   - No history; default cooperative move to signal trustworthiness.

2. **Rounds 2 to r-1: Conditional Cooperation**
   - Observe the number of cooperators in the previous round.
   - If **≥ m cooperated last round**, cooperate to maintain the public good.
   - Otherwise, defect because the group is not meeting the threshold, so cooperation is costly and ineffective.
   - This provides an incentive for others to cooperate to get mutual reward.

3. **Round r (Final Round):**
   - If previous cooperation level was sufficient (≥ m), cooperate to gain the reward.
   - Otherwise, defect since you cannot influence future behavior and cooperation costs an endowment with no future return.

---

### Handling Edge Cases

- **If past_cooperators is `None` (should only happen in round 1):** Cooperate.
- **If cooperation level fluctuates around m:** This strategy will harmonize by cooperating when possible and defecting when cooperation lapses.
- **If all defect from the start:** You defect after round 1 to avoid giving money needlessly.
- **If others punish defectors by defecting next round:** This strategy will respond in kind, encouraging stabilization.
- **No communication:** Strategy relies only on observed actions, fully compatible with constraints.

---

### Why This Is Cooperative

- It **actively seeks cooperation** by starting cooperatively.
- It **locks in reward-oriented cooperation** when group cooperation is sufficient.
- It **punishes defection by defecting back**, encouraging others to cooperate in future rounds.
- It **avoids exploitation in the last round**, maintaining rationality.

---

### Summary

| Round        | Condition                                  | Action |
|--------------|--------------------------------------------|--------|
| 1            | No history                                  | C      |
| Intermediate | ≥ m cooperators last round                  | C      |
| Intermediate | < m cooperators last round                  | D      |
| Last (r)     | ≥ m cooperators last round                  | C      |
| Last (r)     | < m cooperators last round                  | D      |

---

This strategy balances trust, reciprocity, and self-interest to maximize long-term collective payoffs while deterring free riding.
'''

description_COOPERATIVE_83 = '''
Sure! Below is a cooperative strategy for the Collective Risk Dilemma that balances trust-building, conditional cooperation based on observed group behavior, and prudent defection near the end of the repeated game to avoid exploitation. It is designed to promote cooperation while mitigating free-riding.

---

### Strategy: Conditional Trigger with Endgame Reciprocity

---

#### Intuition

- Start by cooperating to signal willingness to contribute to the collective good.
- Monitor group cooperation level each round.
- Continue cooperating as long as *enough* players cooperate to meet the threshold (m).
- If cooperation drops below threshold, defect once to punish free-riders.
- If cooperation recovers, forgive and return to cooperation.
- In final rounds, defect to avoid being exploited since future punishment/reward is impossible.

---

#### Detailed Decision Rules

**Notation:**  
- Let \( t \in \{1, ..., r\} \) be the current round number.  
- Let \( C_t \) = number of players that cooperated in round \( t \), excluding yourself.  
- Your action at round \( t \) is \( a_t \in \{C, D\} \).

---

##### Round 1 (First Round)

- Cooperate: \( a_1 = C \)

*Rationale:* Signal cooperative intent immediately.

---

##### Intermediate Rounds (2 through \( r-1 \))

- Observe \( C_{t-1} \) (cooperators other than you last round).

- **If previous round group cooperation \( \geq m - 1 \)**:  
  *Group met or exceeded threshold (including you, cooperation occurred last round) or only 1 less if you defected:*  
  - Cooperate: \( a_t = C \) to sustain cooperation.

- **Else** (previous cooperation < \( m - 1 \)):  
  - Defect \( a_t = D \) this round to punish insufficient cooperation.

- **If previous round round was punished (you defected), but group cooperation now \( \geq m - 1 \):**  
  - Forgive by resuming cooperation \( a_t = C \).

---

##### Final Round (round \( r \))

- Defect: \( a_r = D \)

*Rationale:* No future punishments or rewards, so cooperating risks exploitation without benefit.

---

#### Summary Table of Action Selection

| Condition                                   | Action \(a_t\)     |
|---------------------------------------------|-------------------|
| \( t = 1 \)                                 | Cooperate (C)     |
| \( 1 < t < r \) and last round \( C_{t-1} \geq m - 1 \) | Cooperate (C)     |
| \( 1 < t < r \) and last round \( C_{t-1} < m - 1 \)     | Defect (D)        |
| \( t = r \) (final round)                    | Defect (D)        |

---

### Pseudocode

```python
def strategy(t, r, m, n, history):
    # history[t-1]: list of actions by all players in round t-1, including self indexed by player_id
    
    if t == 1:
        # First round, cooperate
        return 'C'
    
    elif t == r:
        # Last round, defect
        return 'D'
    
    else:
        # Count number of cooperators other than self in last round
        last_round_actions = history[t-1]
        cooperators = sum(1 for a in last_round_actions if a == 'C') - (1 if last_round_actions[self_id] == 'C' else 0)
        
        if cooperators >= m - 1:
            # Sufficient cooperation last round, cooperate
            return 'C'
        else:
            # Insufficient cooperation last round, defect this round to punish
            return 'D'
```

---

### Additional Notes:

- **Why cooperate first?** Establishes trust and signals willingness to work for the collective reward.
- **Why punish when cooperation shortfalls?** Discourages free riding by reducing the reward for defectors.
- **Why forgive?** Enables recovery from accidental defection or errors, sustaining cooperation long term.
- **Why defect last round?** Minimizes exploitation in final rounds when retaliation is not possible.
- **Effectiveness:** This strategy supports cooperation among rational players by leveraging repeated interaction and observable behaviors.

---

If other players also follow similarly cooperative conditional strategies, the group can sustain the minimum cooperation threshold \( m \) necessary for the reward \( k \), maximizing collective payoffs.
'''

description_COOPERATIVE_84 = '''
Below is a cooperative strategy tailored for the Collective Risk Dilemma that aims to foster coordinated cooperation to reach the threshold \( m \), while maintaining incentives and adaptability over repeated rounds.

---

## Strategy Overview: *Conditional Threshold Cooperation*

This strategy is designed to:

- Reach and maintain the minimum cooperation threshold \( m \) each round.
- Signal and infer others' cooperation to sustain cooperation over rounds.
- Adjust behavior dynamically when cooperation fails to maintain incentives.
- Cooperate early and punish defections lightly but firmly.
- Return to cooperation if the group restores cooperation.

---

## Key Intuition

- The critical point is to get at least \( m \) players cooperating per round to unlock the reward \( k \).
- Players who defect while others cooperate gain a higher payoff than cooperating players in that round (free-riding: payoff \( 1 + k \) vs. \( k \)).
- Therefore, strict but forgiving reciprocity is needed.
- Because \( r > 1 \), use past round information to adjust actions.
- No communication means actions are the only signal.

---

## Decision Rules

### Variables

- \( n, r, m, k \) : game parameters.
- \( t \in \{1, ..., r\} \): current round.
- History: observed actions of all other players in previous rounds.
- \( M_t \): number of cooperating players observed in round \( t \).
- Self actions in previous rounds.

### Initialization (Round 1)

- **Round 1:** Cooperate.
  - Rationale: Start cooperatively to establish trust and test if others cooperate.

### Subsequent Rounds (Rounds 2 to \( r \))

1. Observe previous round actions of all other players.
2. Count number of cooperators \( M_{t-1} \).
3. Check if **group cooperation threshold was met in previous round.**
4. Determine own action:

   - **If \( M_{t-1} \geq m \):**  
     Assume cooperation is sustainable.  
     - If you cooperated last round, continue cooperating this round.  
     - If you defected last round, cooperate this round to re-enter cooperative coalition.

   - **If \( M_{t-1} < m \):**   
     Cooperation failed last round (threshold not met). Punish defectors lightly:  
     - Defect this round as a form of "collective protest" to signal others cooperation failed and is needed.  
     - Exception: If you cooperated last round **but the threshold not met**, continue cooperating **for one extra round** (to avoid immediate punishment for possibly unlucky fluctuations and not to undermine cooperative stability prematurely).  
       If after this one round cooperation, the threshold still fails, defect from then on until recovery.

### Endgame (Round \( r \))

- **Round \( r \) (last round):**  
  Cooperation incentives vanish because no future punishment is possible. However, since payoffs accumulate, cooperate if group cooperation likely persists to push collective payoffs; else defect.  
  Concretely:  
  - If cooperation threshold met in round \( r-1 \), cooperate in round \( r \).  
  - Else, defect (free-riding on last round since no future punishment).

---

## Edge Cases Handling

- **If your cooperation is pivotal (e.g., \( M_{t-1} = m - 1 \) cooperators):**  
  Always cooperate this round, even if you defected last round, since your cooperation can unlock the reward.

- **If a player starts defecting unreciprocated:**  
  Respond by defecting for one round; then attempt to cooperate again next round to restore cooperation.

- **If cooperation repeatedly fails (>2 rounds in a row):**  
  Defect persistently to avoid losing payoff unnecessarily.

---

## Pseudocode

```python
def decide_action(t, history, m, r, last_self_action):
    """
    t: current round (1-based)
    history: list of rounds, each round is a dict {player_id: action}
    m: threshold of minimum cooperators needed
    r: total number of rounds
    last_self_action: 'C' or 'D'
    """
    if t == 1:
        return 'C'  # Start cooperatively

    prev_round = history[t-2]  # zero-indexed
    num_cooperators = sum(1 for a in prev_round.values() if a == 'C')
    
    # Pivotal check: was cooperation threshold almost met, missing only self if you cooperate now?
    is_pivotal = (num_cooperators == m - 1)
    
    if t == r:
        # Last round logic
        if num_cooperators >= m:
            return 'C'  # Keep cooperation if it worked before
        else:
            return 'D'  # Otherwise defect to maximize payoff
    
    # For rounds 2 to r-1
    if num_cooperators >= m:
        # Cooperation succeeded previously
        if last_self_action == 'C':
            return 'C'  # keep cooperating
        else:
            # Defected last round, now rejoin cooperation
            return 'C'  
    else:
        # Cooperation failed last round
        if last_self_action == 'C':
            # Give cooperation one more chance to recover
            # Check if last two rounds failed to meet threshold
            if t - 2 >= 1: 
                prev_prev_round = history[t-3]
                num_cooperators_prev2 = sum(1 for a in prev_prev_round.values() if a == 'C')
                if num_cooperators_prev2 < m:
                    # Failure persists, defect now
                    return 'D'
            return 'C'  # Cooperate one extra round despite failure
        else:
            # Defected last round, punish by defecting again to signal need for cooperation
            # But if pivotal, cooperate
            if is_pivotal:
                return 'C'
            return 'D'
```

---

## Summary

- Start cooperating to foster trust.
- Continue cooperating if the group meets the threshold.
- If cooperation fails, punish by defecting but allow cooperation one extra chance.
- Return to cooperation if others recover cooperation.
- Edge case: cooperate if you are pivotal in meeting threshold.
- In the last round, defect if cooperation unlikely; cooperate otherwise.

This strategy balances **conditional cooperation**, **recovery from failure**, **punishment of defection**, and **pivotal player rationality**—aligning well with a cooperative mindset while protecting against exploitation.
'''

description_COOPERATIVE_85 = '''
**Strategy name:** Conditional Collective Cooperation (CCC)

---

### Intuition
Success in this Collective Risk Dilemma hinges on coordinating to reach the threshold *m* cooperators each round to secure the reward *k*. The main challenge is partial free-riding incentives: defectors gain a private advantage if enough players cooperate, so cooperation is fragile without explicit communication.

The **Conditional Collective Cooperation (CCC)** strategy uses:
- Reciprocity based on observed cooperation counts,
- Presumption of cooperative intent initially,
- Gradual punishment upon insufficient cooperation,
- Leniency to errors and noise,
- Final-round end-game logic acknowledging no future punishment.

---

### Summary of decision rules
| Round | Condition | Action           | Rationale                             |
|-------|-----------|------------------|-------------------------------------|
| 1     | N/A       | **Cooperate (C)**| Start cooperatively to signal intent|
| 2..r-1| ≥ m cooperators last round | Cooperate if you cooperated last round | Reward cooperation, sustain collaboration |
| 2..r-1| < m cooperators last round | Defect | Protest failed collective action to induce punishment |
| r     | Last round | Defect | No future rounds to enforce cooperation |

---

### Detailed reasoning

#### Round 1
- Cooperate unconditionally.
- This opens the possibility of collective success and signals willingness to cooperate.

#### Intermediate rounds (2 ≤ t < r)
- Observe the number of cooperators last round, call it `C_last`.
- If `C_last ≥ m`, it means the collective goal was met last round:
  - If I cooperated last round, continue to cooperate. Trust that others are cooperative.
  - If I defected last round, defect again since defectors are tolerated as minor free-riders to reduce risk of sudden collapse.
- If `C_last < m`, cooperation failed last round:
  - Defect this round to punish the group for failing to cooperate.
  - This signals disapproval and incentivizes them to restore cooperation next round.
- This "Win-Stay, Lose-Shift" style conditional cooperation stabilizes equilibria at cooperation or temporary defection phases.

#### Last round (t = r)
- Defect regardless of past outcomes.
- Cooperation cannot be enforced or rewarded in future rounds so rationally defecting maximizes last-round payoff.

---

### Additional subtlety: Tracking own last-round action
The strategy is forgiving of defectors iff the group succeeded; it only punishes when cooperation fails. This encourages players to cooperate reliably.

---

### Pseudocode

```python
def CCC_strategy(round_t, total_rounds, last_round_actions, my_last_action, m):
    """
    Args:
        round_t: int, current round number (1-based)
        total_rounds: int, total rounds r
        last_round_actions: list of actions of all players from previous round (None if round 1)
        my_last_action: action played by self in last round (None if round 1)
        m: threshold number of cooperators needed
    Returns:
        action: 'C' or 'D'
    """

    # Round 1: start cooperatively
    if round_t == 1:
        return 'C'

    # Last round: defect
    if round_t == total_rounds:
        return 'D'

    # Count number of cooperators last round
    cooperators_last_round = last_round_actions.count('C')

    # If threshold reached last round
    if cooperators_last_round >= m:
        # If I cooperated last round, keep cooperating
        if my_last_action == 'C':
            return 'C'
        else:
            # I defected last round, keep defecting (allow some free-riding)
            return 'D'
    else:
        # Threshold not met last round - punish by defecting
        return 'D'
```

---

### Edge Cases
- **If last round actions are unavailable (the first round):** cooperate to build trust.
- **If exactly m cooperators last round:** treat as success, cooperate accordingly.
- **Multiple defectors can cause failure; punishment aims to stabilize cooperation quickly.**
- **If all defect in the first round, stay defect thereafter as cooperation failed.**

---

### Cooperative mindset alignment
- Leading by cooperating first.
- Conditional cooperation rewards cooperative behavior of others.
- Punishment only applied if cooperation fails to motivate group responsibility.
- Tolerant to some free-riding but not collapse.
- Recognizes impossibility of enforcing cooperation on last round, defects then to maximize payoff pragmatically.

---

This balanced CCC strategy fosters stable cooperation when opponents are also cooperative or reciprocators, and defends against systematic defectors via conditional punishment, maximizing cooperative gains in the long run of repeated rounds.
'''

description_COOPERATIVE_86 = '''
Certainly! Below is a cooperative strategy designed for the Collective Risk Dilemma, leveraging the repeated nature of the game and perfect observability of other players’ actions. The strategy aims to foster trust, maintain the minimum cooperation threshold, and avoid exploitation by defectors, while explicitly managing edge cases such as the first and last rounds.

---

## Strategy Name: Threshold-Triggered Reciprocity (TTR)

### Intuition
- **Goal:** Ensure at least *m* players cooperate each round to attain the collective reward.
- **Approach:** Cooperate initially to signal willingness. Then, condition future cooperation on observing stable cooperation by others.
- **Last round behavior:** Shift to defection since there is no future to incentivize.
- **Recovery:** If cooperation breaks down (fewer than *m* cooperators), attempt to restore it by cooperating once more.

---

### Decision Rules

Let:
- `t` = current round (1 ≤ t ≤ r)
- `C_t` = number of cooperators observed in round t (including self only if self cooperated)
- `Threshold = m`
- `k > 1` (reward factor)
- `n` = number of players

---

### Detailed Rule Set

**Round 1 (t = 1):**  
- Cooperate unconditionally to signal willingness to cooperate to others (play C).

**Rounds 2 to r-1 (1 < t < r):**  
- Observe cooperation levels in previous round: `C_{t-1}`.
- If `C_{t-1} ≥ Threshold`, cooperate (C) this round, trusting cooperation persists.
- Else (`C_{t-1} < Threshold`), defect (D) this round to punish insufficient cooperation.
- **Recovery mechanism:** If cooperation was insufficient last round but you defected, in the next round after defecting you cooperate once to attempt recovery.

**Round r (last round):**  
- Defect (D) unconditionally because no future rounds remain for reciprocity or punishment; standard backwards induction.

---

### Pseudocode

```
Initialize:
    last_cooperation_count = n  # Optimistic initial assumption

For round t in 1 to r:
    if t == 1:
        action = C  # Cooperate in first round
    else if t == r:
        action = D  # Defect in last round
    else:
        if last_cooperation_count >= Threshold:
            action = C  # Continue cooperation if threshold met last round
        else:
            # Punish last round's failure by defecting
            action = D

    # If previous action was D and last_cooperation_count < Threshold, try to recover cooperation once
    if t > 2:
        if previous_action == D and cooperation_count_two_rounds_ago < Threshold:
            action = C

    # Play action this round
    play(action)

    # Observe actions of all players this round -> update last_cooperation_count
    last_cooperation_count = count_of_cooperators_this_round

    previous_action = action
```

---

### Further Explanation

- **First round cooperate:** Sends a strong cooperative signal. Since repeated game, mutual cooperation can emerge.
- **Based on last round observation:** If enough players cooperated (≥ m), continue cooperating for mutual benefit.
- **If cooperation falls short:** Punish by defecting—this discourages free-riding and signals disapproval.
- **Recovery attempt:** After defecting due to low cooperation, try cooperating once to help restart cooperation.
- **Last round defect:** Classical game-theoretic logic—no future incentives to maintain cooperation, so defect.

---

### Handling Edge Cases

- **If other players always defect:** You will eventually defect after first round to avoid exploitation.
- **If others fluctuate:** your recovery attempt helps nudge towards equilibrium cooperation.
- **If threshold equals n-1 (high threshold):** The strategy still applies but sustaining cooperation will be harder; you respond accordingly.
- **If rounds very few:** cooperation focus on early rounds; last round defection standard.

---

### Summary

This strategy balances cooperation with conditional reciprocity, fostering stable cooperation when others cooperate while protecting yourself against exploitative defection. By conditioning hard on the minimum number of cooperators, it aligns well with the collective risk threshold *m*.

---

If you want, I can also provide alternate strategies emphasizing generosity or probabilistic cooperation, but this design offers a robust cooperative baseline in repeated play with perfect information and no communication.
'''

description_COOPERATIVE_87 = '''
Below is a detailed cooperative strategy designed for the Collective Risk Dilemma as specified.

---

## Strategy Name: Conditional Reciprocity with Forgiveness (CRF)

### Core Idea
- Strive for collective cooperation to meet the threshold m each round.
- Start cooperatively.
- Adjust cooperation based on observed group behavior.
- Use forgiveness to recover from defections.
- Defect only if cooperation seems unlikely or opponents are persistently defecting.
- Be fully cooperative in the last round to maximize endgame reward.

---

## Detailed Decision Rules

### Initialization (Before Round 1)
- Initialize trust level `T` to maximum (e.g., `T = 1.0`).
- Maintain a history of actions for all players: `history[i][t]` for player i at round t.
- Initialize a counter for recent defections by others.

### Round 1 (t = 1)
- Cooperate (C) unconditionally.

### Subsequent Rounds (1 < t < r)

1. **Assess group cooperation in previous round t-1**:
   - Count number of cooperators `C_count` in round t-1.
   - Check if threshold m was met.
   - Record your own action in t-1.

2. **Adjust trust based on observations:**
   - If threshold `m` met in t-1 and you cooperated, keep trust high (`T = min(1.0, T + 0.1)`).
   - If threshold `m` not met and you cooperated, reduce trust (`T = max(0, T - 0.3)`).
   - If threshold `m` met and you defected, keep trust steady (`T = T`).
   - If threshold `m` not met and you defected, reduce trust moderately (`T = max(0, T - 0.1)`).
   - Also reduce trust for each defections by others that caused threshold failure.
   - Implement a forgiveness decay so trust can recover slowly over rounds without defections.

3. **Decision based on trust and recent group cooperation:**
   - If recent rounds show cooperation ≥ m and trust is high (`T > 0.7`):
     - Cooperate.
   - If recent rounds show cooperation < m or trust is low (`T ≤ 0.7`):
     - Defect **unless** forgiveness window has passed and trust has recovered.
   - If borderline trust (0.4 < T ≤ 0.7), cooperate with probability proportional to T (e.g., cooperate if a random value ∈ [0,1] < T).
   - Use observed defections of others to weigh trust update.

4. **Aim to keep group cooperation ≥ m**:
   - If your cooperation is critical (your defection would cause cooperation < m), cooperate even if trust low (self-sacrifice for group gain).
   - If cooperation would still meet m without you, defect when trust is low (punish defectors).

### Last Round (t = r)
- Cooperate unconditionally regardless of trust or previous history.
- Reason: No future punishment/reward possible; maximize last-round reward for group.

---

## Pseudocode Representation

```python
initialize T = 1.0  # trust level (range 0 to 1)
cooperation_history = {player_i: [] for player_i in range(1, n+1)}

def update_trust(t):
    global T
    prev_round = t - 1
    C_count = sum(1 for i in range(1, n+1) if cooperation_history[i][prev_round] == 'C')
    threshold_met = (C_count >= m)
    my_prev_action = cooperation_history[self][prev_round]

    if threshold_met and my_prev_action == 'C':
        T = min(1.0, T + 0.1)  # increase trust
    elif not threshold_met and my_prev_action == 'C':
        T = max(0, T - 0.3)    # decrease trust substantially
    elif threshold_met and my_prev_action == 'D':
        T = T                  # no change
    elif not threshold_met and my_prev_action == 'D':
        T = max(0, T - 0.1)    # slight decrease
    
    # Additional penalty for defectors in the group if threshold failed
    if not threshold_met:
        defectors = [i for i in range(1, n+1) if cooperation_history[i][prev_round] == 'D' and i != self]
        T -= 0.05 * len(defectors)
        T = max(0, T)

    # Forgiveness decay (slowly increase trust if no defections)
    if threshold_met and my_prev_action == 'C':
        T = min(1.0, T + 0.05) 

def decide_action(t):
    if t == 1:
        return 'C'

    if t == r:
        return 'C'  # Last round: always cooperate

    update_trust(t)

    prev_round = t - 1
    C_count = sum(1 for i in range(1, n+1) if cooperation_history[i][prev_round] == 'C')

    # Determine if your cooperation is critical
    cooperation_critical = (C_count == m) and (cooperation_history[self][prev_round] == 'C')

    if cooperation_critical:
        return 'C'  # cooperate to help meet threshold

    if T > 0.7 and C_count >= m:
        return 'C'

    if T <= 0.4:
        if C_count >= m + 1:
            return 'D'  # defect if threshold met without you
        else:
            return 'C'  # cooperate if defecting would break threshold

    # Borderline trust, cooperate probabilistically
    if 0.4 < T <= 0.7:
        import random
        return 'C' if random.random() < T else 'D'

    # Default fallback
    return 'D'
```

---

## Alignment with Cooperative Mindset

- **Starts cooperative:** fosters trust and promotes group benefit from the start.
- **Conditional cooperation:** adjusts based on group behavior to maintain collective success.
- **Forgiveness:** avoids persistent retaliation and allows group recovery from mistakes.
- **Sacrifice in critical moments:** guarantees threshold achievement when it depends on you.
- **Maximizes group reward:** fully cooperative in last round, ensuring maximum payoffs.
- **Sensitive to defections:** punishes repeated defection enough to incentivize cooperation but not harshly to destabilize.

---

## Summary

This strategy uses memory and trust to elicit cooperation, tolerate occasional mistakes, punish persistent defectors, and push for threshold achievement consistently across all rounds. It balances self-interest and group interest in a way that is stable, cooperative, and resilient.

---

If you want, I can also provide variants or fine-tunings (e.g., more aggressive or more forgiving) based on your risk preferences.
'''

description_COOPERATIVE_88 = '''
**Strategy Name:** Gradual Reciprocity with Threshold Stability (GRTS)

---

### Overview

This strategy aims to foster cooperation consistently across all rounds by balancing initial trust, conditional reciprocity, and endgame caution. It leverages the perfect information nature to monitor others’ cooperation frequencies, punishing clear defectors but rewarding those who cooperate sufficiently—in particular, ensuring that the number of cooperators treads close to or above the critical threshold **m** to secure the collective reward.

---

### Intuition

- Cooperation in this game results in a collective payoff bonus **k > 1** if at least **m** players cooperate in a round.
- Defectors earn a private benefit of 1 each round and still benefit from the reward if enough players cooperate.
- The game repeats **r** times—allowing a strategy to use history to identify cooperators and defectors.
- No communication means we must infer others’ intentions purely from actions.
- We want to maintain a stable “core” coalition of cooperators to reach the threshold **m**.

---

### High-Level Decision Rules

**Per round \( t \), player \( i \) decides \( a_i^t \in \{C, D\} \) based on the cooperation level of others observed from rounds 1 to \( t-1 \).**

- **Goal**: Maintain a stable core of **m** cooperators each round to always get the reward \( k \).
- Trust players who have cooperated at least some fraction \( \alpha \) of previous rounds.
- Defect against those who rarely cooperate (probabilistic defection), to discourage free-riding.
- In the last round (round \( r \)), show stronger cooperation to secure final payoff, unless defectors appear.
  
---

### Parameters (to tune based on \( n, m, r \))

- \( \alpha \in (0,1) \): Minimum cooperation ratio (e.g., 0.5) for a player to be considered “reliable cooperator.”
- \( \beta \in (0,1) \): Fraction of rounds after which the player expects stable cooperation from others (warm-up period).
- These can be fixed or adaptive.

---

### Detailed Decision Rules

---

#### Round 1 (Initialization)

- Cooperate: \( a_i^1 = C \)
  
Reason: Signal willingness to cooperate, establish goodwill.

---

#### Round \( t \in \{2,\ldots, r-1\} \)

1. **Identify Reliable Cooperators (RC):**

   For each other player \( j \neq i \):

   \[
   freq_j = \frac{\# \text{rounds } s < t \text{ where } a_j^s = C}{t - 1}
   \]

   Construct set:

   \[
   RC = \{ j : freq_j \geq \alpha \}
   \]

2. **Estimate if cooperation threshold is achievable:**

   \[
   size\_core = |RC| + 1 \quad (\text{include self})
   \]

3. **Decision based on whether stable cooperation core can form:**

   - If \( size\_core \geq m \):

     - Cooperate (\( a_i^t = C \)) to maintain the threshold

   - Else:

     - Defect (\( a_i^t = D \)) recognizing stable cooperation not yet present

4. **Additional edge case — borderline \( size\_core = m-1 \):**

   - Cooperate probabilistically with probability proportional to how close \( size\_core \) is to \( m \) to give chance for cooperation cluster to form

---

#### Round \( r \) (Final Round)

- Adopt a more optimistic cooperation to get the final \( k \) payoff if realistically achievable.

- If \( size\_core \geq m - 1 \):

  - Cooperate: \( a_i^r = C \)

- Else:

  - Defect: \( a_i^r = D \)

---

### Pseudocode Summary

```python
def decide_action(round_t, history, n, m, r, alpha=0.5):
    # history: list of tuples (a_1^{s}, ..., a_n^{s}) for s in [1,...,round_t-1]
    
    if round_t == 1:
        return 'C'  # Start with cooperation
    
    # Compute cooperation frequency for each player excluding self (player i)
    freq = []
    for j in range(n):
        if j == i:
            continue
        coop_count = sum(1 for s in range(round_t-1) if history[s][j] == 'C')
        freq.append((j, coop_count/(round_t-1)))
    
    RC = [j for (j, f) in freq if f >= alpha]
    size_core = len(RC) + 1  # include self
    
    if round_t < r:
        if size_core >= m:
            return 'C'
        elif size_core == m - 1:
            # borderline, cooperate with some probability p
            p = (round_t - 1) / r  # e.g., probability grows over time
            return 'C' if random.random() < p else 'D'
        else:
            return 'D'
    else:
        # last round
        if size_core >= m - 1:
            return 'C'
        else:
            return 'D'
```

---

### Additional Notes

- **Cooperative Mindset:** Always seek to cooperate initially and whenever it is reasonable to sustain the threshold.
- **No Blind Forgiveness:** Players consistently defecting will not be part of \( RC \), thus excluded from cooperation core.
- **Adaptability:** Using history lets the strategy adapt to opponents’ behavior.
- **Stable Cooperation:** By requiring minimal cooperation frequency, we encourage stable coalitions.
- **Last Round Caution:** Recognizes potential last-round defection but still tries to cooperate if mutual cooperation is likely.

---

**This strategy should yield high collective payoffs by ensuring that the minimum cooperation threshold \( m \) is consistently met while protecting against exploitation by persistent defectors.**
'''

description_COOPERATIVE_89 = '''
**Cooperative Strategy for the Collective Risk Dilemma**

---

### Intuition and Goals

- **Goal:** Maximize total joint payoffs by ensuring that in every round at least *m* players cooperate, thereby unlocking the collective reward *k* for everyone.
- **Tradeoff:** Cooperate (C) means paying the cost of 1 unit (foregoing private endowment), but unlocks the reward if enough cooperate. Defect (D) means immediate personal gain but risks group failure.
- **Repeated game:** Allows for building cooperation via conditional strategies.
- **No communication:** Must infer cooperation from previous rounds' actions.
- **Perfect Information & Observation:** Can track how many cooperated each round.

---

### Strategy Outline

1. **Start cooperative to signal willingness to cooperate.**
2. **Monitor if the cooperation threshold (*m* players cooperating) was met in previous rounds.**
3. **Continue cooperating if group meets/exceeds threshold to maintain cooperation.**
4. **If threshold is not met in previous round, defect to punish (discourage free-riders) and signal the need to restart cooperation.**
5. **Try to restart cooperation after failure by cooperating again in subsequent rounds.**
6. **In the last round, cooperate if group has generally cooperated before (to maximize reward); otherwise defect to avoid exploitation.**

---

### Formal Decision Rules

Denote:

- \( t \) = current round (1-based)
- \( m \) = cooperation threshold
- \( r \) = total rounds
- \( C_{t} \) = number of cooperators in round \( t \)

---

### Round 1 (Initial Round)

- **Action:** Cooperate (C)  
  *Rationale:* Signal intention to cooperate, establish baseline.

---

### Intermediate Rounds (2 ≤ t < r)

- If \( C_{t-1} \ge m \) (threshold met in previous round):  
  - Cooperate (C)  
  *Rationale:* Cooperation successful previously; reciprocate.
- Else (threshold not met):  
  - Defect (D)  
  *Rationale:* Punish failure to cooperate, discourage exploitation.
- If previous round was a failure (threshold unmet), then on the round after defecting, try cooperating again to attempt re-establishing cooperation.

---

### Last Round (t = r)

- If group has cooperated successfully (threshold met) in **at least half** of previous rounds:  
  - Cooperate (C)  
  *Rationale:* Maximize group reward in final round.
- Else:  
  - Defect (D)  
  *Rationale:* Protect from exploitation; no future rounds to condition on.

---

### Additional Details

- Keep track of history \( H = \{C_1, C_2, ..., C_{t-1}\} \).
- Maintain a simple state machine:

| State               | Condition                     | Action (this round) | Next State          |
|---------------------|-------------------------------|---------------------|---------------------|
| **Cooperating**     | \( C_{t-1} \ge m \)           | Cooperate           | Cooperating         |
| **Punishing**       | \( C_{t-1} < m \)             | Defect              | AttemptRebuild       |
| **AttemptRebuild**  | After punishing one round      | Cooperate           | Cooperating or Punishing (depends on \( C_t \)) |

- This state machine ensures one round of defection punishment after failed cooperation, then attempts to rebuild cooperation by cooperating.

---

### Pseudocode

```python
initialize:
    round = 1
    history = []  # list of coop counts per round
    state = "Cooperating"

def decide_action(round, history, state, m, r):
    if round == 1:
        action = "C"
        next_state = "Cooperating"

    elif round == r:
        # Last round decision
        successes = sum(1 for c in history if c >= m)
        if successes >= len(history) / 2:
            action = "C"
        else:
            action = "D"
        next_state = None  # no next round

    else:
        last_coop_count = history[-1] if history else 0

        if state == "Cooperating":
            if last_coop_count >= m:
                action = "C"
                next_state = "Cooperating"
            else:
                action = "D"
                next_state = "AttemptRebuild"

        elif state == "AttemptRebuild":
            action = "C"
            # Next state depends on current round results (to be updated after observing actions)
            next_state = "Cooperating"  # hopeful assumption

        else:
            # default fallback
            action = "C"
            next_state = "Cooperating"

    return action, next_state
```

---

### Summary

| Round          | Condition                               | Action                              |
|----------------|----------------------------------------|-----------------------------------|
| Round 1        | Always                               | Cooperate                         |
| Intermediate   | Previous round coop count ≥ m        | Cooperate                        |
| Intermediate   | Previous round coop count < m        | Defect (punish), then try rebuild by cooperating next round |
| Last round     | Cooperation success rate ≥ 50%       | Cooperate                        |
| Last round     | Otherwise                           | Defect                           |

---

### Justification for Cooperative Alignment

- Starts cooperative, signaling good faith.
- Responds positively to cooperation, aligning incentives.
- Punishes failure (low cooperators), deterring free-riding.
- Forgives and attempts to rebuild cooperation after punishment.
- Considers overall cooperation history for last round to avoid exploitation.
- Aims to maintain cooperation throughout the repeated game, maximizing collective payoffs.

---

This strategy balances cooperation, punishment, and forgiveness effectively under perfect information but no communication, fitting well in the **Collective Risk Dilemma** context.
'''

description_COOPERATIVE_90 = '''
Here is a cooperative strategy tailored to the Collective Risk Dilemma game as specified, aiming to foster cooperation reliably while minimizing exploitation over multiple rounds.

---

## Strategy Overview: *Conditional Reciprocal Cooperation with Threshold Assurance*

**Goal:**  
Achieve and maintain at least *m* cooperators each round to secure the reward *k* for everyone, while deterring defectors by conditional retaliation.

---

## 1. Decision Rules 

### Round 1 (No History)  
- **Action:** Cooperate (C)  
- **Rationale:** Establish trust by ensuring you contribute initially, encouraging others to cooperate.

### Round t > 1 (With History)  

Let:  
- *C_prev* = number of cooperators in previous round  
- *My_action_prev* = your own last round action  
- *Rounds_left* = r − t + 1  

**If Rounds_left = 1** (Last round):  
- Defect (D) to avoid being exploited, as future retaliation is impossible (standard backward induction logic).

**Else (Rounds_left > 1):**  
- If *C_prev ≥ m*:  
  - If *My_action_prev = C*:  
    - Cooperate again (reward continued cooperation)  
  - Else if *My_action_prev = D* but *C_prev ≥ m*:  
    - Cooperate this round to help ensure threshold met (for eventual mutual benefit)  
- Else (*C_prev < m*):  
  - If *My_action_prev = C*:  
    - Defect this round (retaliation for cooperation not met by enough others)  
  - Else (*My_action_prev = D*):  
    - Cooperate this round to attempt to rebuild cooperation  

---

## 2. Interpretation

- **Start cooperative to signal willingness to contribute.**  
- **Continue cooperating if the group met the cooperation threshold last round, rewarding collective success.**  
- **Retaliate against rounds where you cooperated but threshold failed, to discourage free-riding or insufficient cooperation.**  
- **Attempt forgiveness by cooperating again after defecting, to rebuild cooperation after failure.**  
- **Defect in the last round because cooperation cannot be enforced afterward (standard rational endgame behavior).**

---

## 3. Edge Cases and Clarifications

- **First round:** Always cooperate — no history exists so this maximizes initial outreach.  
- **Last round:** Always defect — no future punishment to incentivize cooperation.  
- **If the threshold is never met:** Strategy converges to alternating cooperation and defection, providing some cooperation signals but limiting exploitation.  
- **If others cooperate consistently:** This strategy fosters sustained cooperation.  
- **If others defect consistently:** The strategy minimizes losses by defecting after sensing no cooperation payoff.  
- **If cooperation is borderline (just at or above m):** The strategy encourages stable cooperation by continuing to cooperate when threshold is met.  

---

## 4. Pseudocode

```
Input: round t, total rounds r
Input: last round actions of all players (if t > 1)
Define:
    m = minimum cooperators needed
    C_prev = count of cooperating players in round t-1 (if t > 1)
    My_action_prev = my action in round t-1 (if t > 1)
Actions: C (Cooperate), D (Defect)

If t == 1:
    action = C
Else:
    Rounds_left = r - t + 1
    If Rounds_left == 1:  # last round
        action = D
    Else:
        If C_prev >= m:
            action = C
        Else:
            If My_action_prev == C:
                action = D
            Else:
                action = C
Return action
```

---

## 5. Summary

| Situation                        | Action  |
|---------------------------------|---------|
| Round 1                         | Cooperate  |
| Last round (t = r)              | Defect     |
| Previous round cooperation ≥ m | Cooperate  |
| Previous round cooperation < m & I cooperated last round  | Defect (Retaliate) |
| Previous round cooperation < m & I defected last round      | Cooperate (Forgive) |

---

This *Conditional Reciprocal Cooperation* strategy balances optimism and pragmatism, fostering stable cooperation rounds while responding to defection with measured retaliation and forgiveness. It leverages perfect information to condition on past group behavior, aligning with the cooperative mindset and optimizing long-run payoff through collective action.
'''

description_COOPERATIVE_91 = '''
Below is a cooperative strategy tailored to the Collective Risk Dilemma described. It attempts to establish and maintain cooperation over the repeated rounds by conditional cooperation based on observed group behavior, with careful consideration of first and last rounds.

---

## Strategy Overview: Conditional Conditional Cooperation with Forgiveness (3C-F)

The core idea:
- **Start cooperatively** to form trust.
- **Continue cooperating as long as cooperation threshold m is met in previous rounds**, signaling successful cooperation.
- **Defect if cooperation threshold not met, but attempt to restore cooperation after a single defection round**.
- **In the last round, defect to avoid being exploited (backward induction in finite repeated games)**.

The strategy is cooperative but conditional, punishing large-scale defection but forgiving short-term mistakes or noise, supporting stable cooperation.

---

## Detailed Decision Rules

Input parameters: n (players), r (rounds), m (threshold), k (reward factor).

At each round t (1 ≤ t ≤ r), player i observes the cooperation count in round t-1 (or none if t=1).

Define:
- \( coop_{t-1} \) = number of cooperators observed in round t-1
- \( myAction_{t-1} \) = your own action in round t-1 (if t>1)

### 1. First round (t=1)

- Cooperate to establish trust.

### 2. Middle rounds (1 < t < r)

- If in previous round \( coop_{t-1} \ge m \):
  - Cooperation succeeded, **cooperate** again.
- Else (cooperation threshold not met in previous round):
  - If in previous round you **defected** (D), then cooperate now (forgiveness attempt).
  - Else if you cooperated but group still failed threshold, defect now (punishment for others defecting).
  
### 3. Last round (t = r)

- Defect regardless (to avoid being exploited in last round).

---

## Pseudocode

```python
def action(t, coop_prev, my_prev_action):
    """
    Inputs:
      t: current round number (1-based)
      coop_prev: number of players who cooperated in round t-1,
                 None if t=1 (no previous round)
      my_prev_action: action chosen by this player in round t-1 ('C' or 'D'),
                      None if t=1

    Returns:
      'C' or 'D' for current round t
    """

    if t == 1:
        # First round -> cooperate
        return 'C'

    elif t == r:
        # Last round -> defect to avoid last-round exploitation
        return 'D'

    else:
        if coop_prev >= m:
            # Group met threshold, cooperate to maintain trust
            return 'C'
        else:
            # Threshold not met in previous round
            if my_prev_action == 'D':
                # You defected last round: now attempt to cooperate (forgiveness)
                return 'C'
            else:
                # You cooperated last round but group still failed
                # Punish by defecting this round
                return 'D'
```

---

## Intuition Behind the Strategy

- **First Round Cooperation:** Signals willingness to cooperate, encourages others to reciprocate.
- **Conditional Cooperation:** Keeps cooperation only if the group met the threshold, avoiding being exploited repeatedly.
- **Forgiveness:** If you defected to punish, try cooperating next round to allow cooperation to restart.
- **Last Round Defection:** Because no future rounds remain, cooperate is dominated by defection (standard backward induction).
- **Repeated Interaction:** The pattern attempts to sustain groups cooperation cycles by rewarding success and punishing failures with forgiveness to avoid permanent breakdown.

---

## Edge Cases & Considerations

- **If opponents defect continuously, you will cycle between defect and cooperate but never on your own re-initiate cooperation enough to be exploited repeatedly.**
- **If opponents mostly cooperate, you maintain stable cooperation and maximize mutual payoffs.**
- **In noisy or misunderstanding situations, forgiveness allows cooperation to restart quickly after isolated defections.**
- **Last round defection prevents exploitation in a strictly forward-looking equilibrium sense.**

---

This strategy promotes cooperation while safeguarding against persistent defectors, leveraging repeated game dynamics and common knowledge to maximize collective and individual payoffs over multiple rounds.
'''

description_COOPERATIVE_92 = '''
Below is a detailed cooperative strategy for the Collective Risk Dilemma game. The strategy aims to foster cooperation to reliably meet the cooperation threshold **m**, thus triggering the reward **k** in as many rounds as possible, while adapting to potential defections to minimize exploitation.

---

### Strategy Overview

- **Goal:** Reach and maintain at least **m** cooperators per round so everyone gains the reward **k**.
- **Key idea:** Cooperate initially, then track others’ cooperation levels to decide whether to continue cooperating or switch to defection to avoid being exploited.
- **Key challenge:** Without communication or signals, players rely only on observable past actions and payoffs.
- **Repeated rounds:** Use the history of all players’ behavior across rounds to infer cooperation level, adjust accordingly.

---

### Notation

- Let **players[]** be the list of all players (including self).
- Let **round t** ∈ {1, 2, ..., r}.
- For each round t, let **C_t** = number of cooperators observed in round t.
- Let **threshold m** be minimum cooperators to get reward.
- Let **k** be reward multiplier (>1).
- Let **c_i,t** ∈ {0,1} be action of player i in round t (1=cooperate, 0=defect).
- Let **self = i** be your player index.

---

### Decision Rules

#### 1. First Round (t=1)

- **Cooperate (C)**
  - Rationale: Start cooperatively to encourage collective action and signal willingness to cooperate.
  
---

#### 2. Intermediate Rounds (1 < t < r)

- **Observe history:**
  - From rounds 1 to t−1, record the number of cooperators each round.
  - Compute average cooperators per round so far:  
    \( \bar{C} = \frac{1}{t-1} \sum_{\tau=1}^{t-1} C_\tau \)
  - Compute your own cooperation rate so far:  
    \( \text{coop\_rate\_self} = \frac{\sum_{\tau=1}^{t-1} c_{\text{self}, \tau}}{t-1} \)

- **If cooperation threshold was met consistently:**
  - If \(C_{\tau} \geq m \) for at least \(80\%\) of past rounds, **cooperate** again.
  - Rationale: The group is reliably cooperating, so continue cooperating to reap rewards.

- **If cooperation threshold rarely met or failed recently:**
  - Check if in last round cooperators fell below m:
    - If yes, **cooperate**, trying to restore cooperation.
  - Else, if cooperation fluctuates or is unstable:
    - Calculate estimated stability score \(s = \min_{\tau \in [t-w, t-1]} C_\tau\), \(w=\) small window (e.g. 2-3 rounds).
    - If \(s \geq m\), **cooperate**, else **defect** to avoid exploitation.

- **Detect exploitation risk:**
  - If you cooperated but reward did not appear (fewer than m cooperators last round), and **others did not reciprocate** (many others defected repeatedly),  
    then switch to **defect** to avoid repeated loss.

---

#### 3. Final Round (t = r)

- **Always defect (D)**
  - Rationale: No future rounds exist to punish defection; defecting reaps private payoff without risk.
  - This is standard in finitely repeated games and avoids being exploited in last round.

---

### Summary of Key Logic

| Round      | Condition                                                                            | Action   |
|------------|--------------------------------------------------------------------------------------|----------|
| t = 1      | Initial round                                                                        | Cooperate|
| 1 < t < r  | Cooperation threshold met ≥ 80% rounds                                             | Cooperate|
| 1 < t < r  | Failed cooperation last round or unstable cooperation                               | Cooperate (to try restoring) or Defect (to avoid exploitation), depending on recent trend scores |
| 1 < t < r  | Exploited by persistent defectors                                                   | Defect   |
| t = r      | Final round                                                                         | Defect   |

---

### Pseudocode

```python
def decide_action(t, r, m, k, history):
    """
    history: list of tuples [(actions_round_1), (actions_round_2), ..., (actions_round_t-1)]
    each actions_round_i: list of actions by all players in round i ("C" or "D")
    self_index is known (your player ID -1 for zero indexing)
    """

    def count_cooperators(actions):
        return sum(1 for a in actions if a == "C")

    if t == 1:
        # First round: start cooperatively
        return "C"

    if t == r:
        # Last round: defect
        return "D"

    # Analyze history
    coop_counts = [count_cooperators(round_actions) for round_actions in history]
    rounds_played = t - 1
    coop_threshold_met_rounds = sum(1 for c in coop_counts if c >= m)
    coop_threshold_met_ratio = coop_threshold_met_rounds / rounds_played

    # Check exploitation: Did I cooperate last round but no reward? (= < m cooperators)
    last_round_cooperators = coop_counts[-1]
    self_last_action = history[-1][self_index]
    exploited = (self_last_action == "C" and last_round_cooperators < m)

    if exploited:
        # Others exploited my cooperation => defect to avoid loss
        return "D"

    if coop_threshold_met_ratio >= 0.8:
        # Cooperation stable and threshold met => continue cooperating
        return "C"

    # Cooperation unstable - check last rounds window (e.g., last 3 rounds)
    window = min(3, rounds_played)
    recent_min_coop = min(coop_counts[-window:])
    if recent_min_coop >= m:
        # Recent cooperation stable => cooperate
        return "C"
    else:
        # Cooperation unstable or declining => defect to avoid exploitation
        return "D"
```

---

### Cooperative Mindset Alignment

- **Start cooperative:** Show goodwill to try building collective trust.
- **Forgive occasional defection:** If cooperation threshold missed recently but not repeatedly, try to cooperate again to restore trust.
- **Retaliate against persistent defectors:** Do not get exploited; defect if others consistently fail to cooperate.
- **Coordinate implicitly:** Use cooperation threshold met ratio as a proxy for group trustworthiness.
- **Endgame defection:** Rational, backward induction compliant to avoid exploitation last round.

---

### Additional Remarks

- This strategy assumes all players are rational and understand it.
- Since no communication is allowed, the strategy uses only observable data (past actions) to adapt.
- Parameters like 80% threshold and 3-round window can be tuned.
- The main risk is if too many players defect early — then coordination may fail.
- Your strategy signals to others that cooperation is rewarded but exploitation is costly.

---

If implemented, this should produce mutually beneficial cooperative outcomes in most cases and guard against sustained exploitation.
'''

description_COOPERATIVE_93 = '''
Here is a cooperative strategy designed for the Collective Risk Dilemma, which encourages cooperation to reach the threshold \( m \) each round and maintain it across all \( r \) rounds. The strategy is essentially a trust-and-reciprocate approach, tailored to the repeated setup and perfect monitoring:

---

## Strategy Name: Threshold-Trigger Cooperation

### Objectives:
- Achieve and maintain at least \( m \) cooperators every round to secure the group reward \( k \).
- Avoid being exploited repeatedly by defectors.
- Rebuild cooperation after defections, but do not allow persistent free-riding.
- Cooperate by default, defect as a calibrated punishment.

---

## Decision Rules:

### Initialization (Round 1):
- **Cooperate**: Start cooperatively to signal willingness and set baseline.
  
### For rounds \( t = 2, \ldots, r-1 \) (intermediate rounds):
- **Observe last round actions \( \{a_i^{t-1}\} \) for all players \( i \).**
- Calculate the number of cooperators last round:  
  \[
  numC = \#\{i : a_i^{t-1} = C\}
  \]

#### If the number of cooperators last round \( \ge m \):
- **If you cooperated last round:**
  - Continue to **cooperate**, rewarding mutual cooperation.
- **If you defected last round:**
  - Detect whether your defection caused \( numC < m \):
    - If the group reward was still received, defect again—group was resilient.
    - Otherwise, **switch to cooperate** to help restore cooperation.
  
#### If the number of cooperators last round \( < m \):
- The group failed to meet threshold. A punishment and repair phase is needed.
- **Defect** to punish free-riders (those who did not cooperate and contributed to failing threshold).
- Exception: If you cooperated last round (and your cooperation was not reciprocated), you may switch to **defect** to avoid exploitation.
  
### Final round \( t = r \):
- **Cooperate** if threshold was met in \( r-1 \) to help secure last-round reward.
- Otherwise, **defect**, since no future rounds exist to repair cooperation.
  
---

## Key Features and Justifications:

1. **Start Cooperative:** Starting by cooperating encourages cooperation from others without risking initial exploitation.

2. **Reciprocity:** Cooperate if others cooperated in the previous round to maintain cooperation.

3. **Punishment Deterrence:** Defect if threshold was not met last round to discourage persistent defection.

4. **Repair Mechanism:** If cooperation breaks, attempt to restore by switching back to cooperation after punishment phase.

5. **Last Round Defections:** No incentive to cooperate if threshold failed just before last round; rational to defect in last round if cooperation is not expected to yield future reward.

---

## Pseudocode

```python
def decide_action(round_t, r, m, k, previous_actions, previous_payoffs, my_last_action):
    # previous_actions: list of n elements, each C or D from round t-1
    # previous_payoffs: list of n payoffs from round t-1
    # my_last_action: C or D from round t-1
    
    n = len(previous_actions)
    
    # Round 1: cooperate to initiate mutual cooperation
    if round_t == 1:
        return 'C'
    
    numC = previous_actions.count('C')
    
    if round_t < r:
        # Intermediate rounds
        
        if numC >= m:
            # Threshold met last round
            if my_last_action == 'C':
                # Continue cooperating to maintain stability
                return 'C'
            else:
                # You defected last round
                group_reward_received = all(payoff >= 1 + k for payoff in previous_payoffs) or \
                                        any(payoff >= 1 + k for payoff in previous_payoffs)
                # If group reward received, defect to keep payoff advantage
                if group_reward_received:
                    return 'D'
                else:
                    # If reward lost, switch back to cooperation to repair
                    return 'C'
        
        else:
            # Threshold not met last round
            # Punish defectors and help repair cooperation
            
            if my_last_action == 'C':
                # You cooperated but threshold failed - defect to avoid being suckered
                return 'D'
            else:
                # You defected last round, continue defecting to punish defectors and signal seriousness
                return 'D'
    
    else:
        # Final round
        
        if numC >= m:
            # Past cooperation exists, cooperate in final round to get final reward
            return 'C'
        else:
            # Past cooperation failed, defect for final round; no future rounds to repair cooperation
            return 'D'
```

---

## Summary

- **First round:** Cooperate to establish trust.
- **If cooperation succeeded (≥ m):** Continue cooperating if you previously cooperated. If you previously defected, defect only if the group reward was still obtained; otherwise switch to cooperation.
- **If cooperation failed (< m):** Defect to punish free-riders and deter defection.
- **Final round:** Cooperate only if cooperation succeeded in the prior round.

This strategy balances cooperation with responsibility and punishment, facilitating stable cooperation over multiple rounds despite temptation to free-ride, consistent with a cooperative mindset.
'''

description_COOPERATIVE_94 = '''
**Strategy Name:** Conditional Trigger Cooperate with Forgiveness (CTCF)

---

### Overview

This strategy aims to maintain cooperation in the Collective Risk Dilemma by:

- Cooperating initially to encourage mutual cooperation.
- Continuing to cooperate so long as the cooperation threshold is met each round (indicating others are cooperating).
- Defecting temporarily (punishment) if the cooperation threshold is not met to discourage free-riding or mass defection.
- Forgiving after a single defection round to allow recovery of cooperation.
- Always cooperating in the final round to maximize collective payoff since there is no future punishment risk.

---

### Decision Rules

At **each round t** (1 ≤ t ≤ r):

1. **Round 1: Cooperate**  
   - No prior history to evaluate; assume cooperative intent initially.

2. **Rounds 2 to r-1:**  
   - If in round t-1, the number of cooperators ≥ m (threshold met), **Cooperate** this round to continue cooperation.  
   - Else (threshold not met in t-1), **Defect** this round to punish defection by others but only for a single round.

3. **Round r (Last Round): Cooperate**  
   - No strategic reason to defect in the last round since there's no future retaliation or reward loss.
   - Maximizes final round group payoff and reinforces cooperation.

---

### Notes on State Maintenance

- Maintain a record of the number of cooperators in the previous round.
- Maintain a flag indicating whether you are currently in a punishment (defection) round triggered by prior threshold failure.
- After defecting to punish, revert to cooperation unless threshold failed again.

---

### Handling Edge Cases 

- **First round (t=1):** Cooperate, since no information available and cooperation is best socially  
- **Last round (t=r):** Always cooperate, removing endgame defection incentives  
- **Consecutive threshold failures:** If cooperation threshold fails in multiple consecutive rounds, continue defecting in those rounds to apply consistent pressure. Return to cooperation immediately once threshold met again.  
- **If opponents never cooperate (e.g., all defect):** After the first round, this strategy will defect every round except the last, minimizing losses.

---

### Pseudocode

```python
# Parameters:
# n, r, m, k are known.
# Round t ∈ {1,...,r}
# Input per round: cooperators_count_prev_round (0 if t=1)

state = {
    "punishment_active": False  # True if defecting this round to punish
}

def decide_action(t, cooperators_count_prev_round):
    if t == 1:
        # First round cooperate
        state["punishment_active"] = False
        return "C"
    
    if t == r:
        # Final round always cooperate
        state["punishment_active"] = False
        return "C"
    
    # For rounds 2 to r-1
    if cooperators_count_prev_round >= m:
        # Threshold met last round => cooperate
        state["punishment_active"] = False
        return "C"
    else:
        # Threshold failed last round => defect this round as punishment
        state["punishment_active"] = True
        return "D"
```

---

### Cooperative Mindset Alignment

- **Proactively cooperate at start to promote trust.**  
- **Persist cooperation as long as others cooperate (threshold met).**  
- **Apply measured, short punishment to signal the cost of collective defection, without escalating to permanent defection.**  
- **Immediately return to cooperation upon resumption of cooperation by others (forgiveness).**  
- **Always cooperate in the final round to maximize group payoff, since no future rounds remain to punish or reward.**

---

This strategy balances incentives to cooperate with mechanisms to discourage and respond to free-riding or failure of others to cooperate. It is designed to sustain cooperation over repeated rounds while avoiding endless defection spirals.
'''

description_COOPERATIVE_95 = '''
Here is a cooperative strategy design tailored to the Collective Risk Dilemma (CRD) described, fully aligned with cooperative principles and designed to foster and maintain cooperation over repeated rounds.

---

### Key Intuition

- Cooperation yields the collective reward \(k\) if at least \(m\) players cooperate.
- Defection is individually tempting, especially when others cooperate, yielding a higher per-round payoff for defectors when threshold is met.
- The repeated nature and perfect information allow for conditional cooperation and punishment.
- We want a strategy that:

  1. **Starts by cooperating to signal cooperative intent.**
  2. **Monitors group cooperation levels publicly observed.**
  3. **Continues cooperating if the group sufficiently cooperates.**
  4. **Defects temporarily if cooperation fails, but tries to restore cooperation quickly.**
  5. **Adjusts behavior near the last round to not get exploited.**
  
---

### Strategy Overview: *Generous Conditional Cooperator with Forgiveness*

- **Round 1:** Cooperate — establish cooperative baseline.
- **Rounds 2 to r-1:**  
  - If previous round had \(\geq m\) cooperators, **cooperate** this round.  
  - If previous round had fewer than \(m\) cooperators, **defect once (punishment)** this round to signal disapproval.  
  - After defecting once as punishment, if cooperation level rises again to \(\geq m\), return to cooperate.
- **Round r (final round):** Defect to avoid exploitation.

---

### Why this approach?

1. **Starting with cooperation** demonstrates willingness to cooperate.
2. **Conditional cooperation** based on threshold keeps a norm of cooperation.
3. **One-round defection punishment** discourages persistent defection without escalating conflict.
4. **Forgiving once cooperation resumes** enables recovery from accidental defection or noise.
5. **Defect on the last round** mitigates the usual endgame problem of cooperative breakdown when no future consequences remain.

---

### Detailed Decision Rules

- Maintain a memory of the last round’s cooperation count.
- Track whether currently in punishment mode.

**Definitions:**

- \( \text{coops}_{t-1} \) = number of players cooperating in round \(t-1\).
- \(t\) = current round number (1 to \(r\)).

**Initialize:**

- `punishment = False`

**At round t:**

```pseudocode
if t == 1:
    action = C
    punishment = False

else if t == r:
    # Final round defect to avoid last-round exploitation
    action = D

else:
    if punishment == False:
        if coops_{t-1} >= m:
            # Cooperation threshold met last round
            action = C
        else:
            # Threshold not met: start punishment by defecting this round
            action = D
            punishment = True
    else:
        # We are in punishment mode
        if coops_{t-1} >= m:
            # Cooperation restored, stop punishment and cooperate
            action = C
            punishment = False
        else:
            # Maintain punishment only for one round, then forgive regardless of cooperation level
            # Helps avoid repeated cycles of punishment-defection
            action = C
            punishment = False
```

---

### Edge Cases & Notes

- **First round**: No history, so cooperate unconditionally — sends clear signal.
- **Last round \((t = r)\)**: Defect to avoid exploitation in no-future-consequences environment.
- **Single round punishment**: Limits damage and encourages repair of cooperation.
- **Forgiveness after one punishment round** even if cooperation not restored avoids endless cycles.
- This strategy implicitly encourages players to cooperate continuously to keep receiving higher payoffs.
- Transparent, simple, and easily interpretable actions to other LLM-based opponents.

---

### Summary

| Round      | Condition (last round cooperation count) | Action                 | Punishment Mode          |
|------------|------------------------------------------|------------------------|-------------------------|
| 1          | N/A                                      | Cooperate (C)          | False                   |
| 2...r-1    | \(\geq m\)                               | Cooperate (C)          | False                   |
| 2...r-1    | < \(m\), punishment = False              | Defect (D)             | True (start punishment) |
| 2...r-1    | < \(m\), punishment = True               | Cooperate (C), Forgive | False                   |
| Last Round | Any                                      | Defect (D)             | Irrelevant              |

---

This cooperative, conditional, forgiving strategy balances incentivizing cooperation and defending against exploitation while recognizing the peculiarities of a finite repeated risk dilemma. It should promote stable cooperation when others are similarly cooperative and limit losses against defectors.
'''

description_COOPERATIVE_96 = '''
Below is a cooperative strategy designed for the Collective Risk Dilemma that aims to sustain cooperation by conditional reciprocity and coordinated punishment, leveraging the repeated nature of the game and perfect observation of past actions.

---

## Cooperative Strategy: **Conditional Reciprocity with Graduated Punishment**

### Intuition
- The goal is to reach and maintain **at least m cooperators each round** to achieve the collective reward \(k\).
- Cooperation is costly individually (cost = 1), but rewarded if enough cooperate.
- Since defects risk losing the collective reward, this strategy punishes defectors by defecting in response, but returns to cooperation once cooperation is restored.
- In the last round, incentive to defect is highest because future punishment is impossible; strategy adjusts accordingly.

---

### Decision Rules

#### Parameters:
- \( n, r, m, k \): game parameters as specified.
- \( t \in \{1, \ldots, r\} \): current round
- History of all players’ actions in previous rounds available.

---

### Round 1 (Start with Trust)
- **Action**: Cooperate
- Rationale: Establish trust and attempt to reach threshold immediately.

---

### Rounds 2 to \(r-1\):

Define:

- \(C_{t-1}\): Number of players who cooperated in round \(t-1\)
- \(D_{i,t-1}\): Player \(i\)'s action in round \(t-1\) (C or D)
- \(C_{-i,t-1}\): number of cooperators excluding self in round \(t-1\)

**If in previous round \(t-1\), \(C_{t-1} \geq m\):**

- If you cooperated in \(t-1\), keep cooperating.
- If you defected in \(t-1\), cooperate to signal return to cooperation.

Reason: Cooperation succeeded, so continue cooperating to maintain reward.

---

**If \(C_{t-1} < m\) (cooperation failed):**

- Identify if you were a cooperator or defector in round \(t-1\):

  - If you cooperated while cooperation failed, **punish defectors by defecting** this round.
  
  - If you defected while cooperation failed, **defect again** this round (for self-protection and to adjust group expectations).

Reason: Cooperation failed, so defectors must be deterred via punishment. Cooperators punish defectors; defectors continue defecting since cooperation failed.

---

**Detecting "Recovering" Cooperation:**

- If in the last 2 rounds cooperation threshold was reached (i.e., \(C_{t-2} \geq m\) and \(C_{t-1} < m\)), attempt to **restore cooperation** by cooperating this round regardless of previous action.

Reason: Give others a chance to reset cooperation and escape punishment cycles.

---

### Last Round \(t=r\):

Because there is no future to enforce cooperation via punishment:

- **Defect** to maximize immediate payoff.

Rationale: Last round is a classic one-shot Prisoner’s Dilemma; defection dominates.

---

## Overall Summary of Decision Rules (Pseudocode):

```pseudo
function decide_action(t, history, parameters):
    # Extract parameters
    n, r, m, k = parameters
    
    if t == 1:
        return "C"
    
    # Count cooperators in previous round
    prev_actions = history[t-1]
    C_prev = number_of_C(prev_actions)
    my_prev_action = prev_actions[self_index]
    
    # Count cooperators in two rounds ago if available
    if t > 2:
        prev2_actions = history[t-2]
        C_prev2 = number_of_C(prev2_actions)
    else:
        C_prev2 = None
    
    if t == r:
        # Last round defect
        return "D"
    
    if C_prev >= m:
        # Cooperation succeeded last round
        if my_prev_action == "C":
            return "C"
        else:
            # Defected last round but cooperation succeeded,
            # punish lightly by cooperating to restore trust
            return "C"
    
    else:
        # Cooperation failed last round (C_prev < m)
        
        # Check if cooperation succeeded two rounds ago and failed last round,
        # try to restore cooperation
        if (C_prev2 is not None) and (C_prev2 >= m):
            return "C"
        
        # Else punish or defect depending on own previous action
        if my_prev_action == "C":
            # Cooperated but failed -- punish defectors by defecting
            return "D"
        else:
            # Defected and failed -- keep defecting (self-protect)
            return "D"
```

---

## Cooperative Mindset Alignment

- **Starts with cooperation to attempt reaching the threshold.**
- **Maintains cooperation if group successfully cooperated previously.**
- **Uses conditional defection only as a proportional punishment to deter free-riding.**
- **Attempts to recover cooperation quickly after failures rather than defecting permanently.**
- **Recognizes last round defection as a rational end-game move, preserving overall strategy effectiveness across rounds.**

---

# Summary

This strategy is a *conditional cooperator* one that rewards group cooperation and punishes defection proportionally. It is designed to:

- Achieve cooperation quickly (start with cooperation)
- Sustain cooperation when successful
- React to free-riding via temporary punishment
- Encourage a return to cooperation rather than endless punishment cycles
- Maximize long-term payoffs by balancing cooperation and self-interest

This aligns well to the collective risk dilemma: cooperating when beneficial and deterring defection without permanent breakdown.
'''

description_COOPERATIVE_97 = '''
Below is a cooperative strategy designed to promote and sustain cooperation in the Collective Risk Dilemma over repeated rounds. The strategy aims to ensure the threshold \( m \) is met to secure the higher reward \( k \), while adapting to the observed behavior of other players to maintain cooperation.

---

### Cooperative Strategy: "Reciprocal Threshold Cooperation"

---

#### Intuition

- **Goal:** Achieve and maintain at least \( m \) cooperators each round.
- **First round:** Start cooperative to signal willingness to cooperate.
- **Subsequent rounds:** Cooperate if a sufficient number of players cooperated last round (including self).
- **Recovery:** If cooperation breaks down, attempt to recover by cooperating after a defection phase.
- **Last round:** Cooperate if cooperation is likely to be mutually beneficial, else defect to avoid exploitation.

---

### Detailed Decision Rules

---

#### Variables/Inputs

- \( n \): Number of players
- \( r \): Number of rounds
- \( m \): Minimum cooperators needed
- \( k \): Reward multiplier
- \( t \): Current round (1 to \( r \))
- History data for rounds \( 1 \) to \( t-1 \):
  - Cooperators count each round
  - Your own action history

---

#### 1. **First Round (\( t=1 \))**

- **Action:** Cooperate (C)
- **Reason:** Establish cooperative intent from the start.

---

#### 2. **Rounds \( 2 \leq t < r \)**

- Observe the number of cooperators last round, \( m_{t-1} \).
- **Decision rule:**

  ```pseudocode
  if m_(t-1) ≥ m:
      // Sufficient cooperation last round
      action = C
  else if m_(t-1) < m:
      // Cooperation broke down last round
      if you cooperated last round:
          // Trust broken, defect this round to signal punishment
          action = D
      else:
          // You defected last round, attempt to restore cooperation by cooperating
          action = C
  ```

---

#### 3. **Last Round (\( t = r \))**

- The last round is vulnerable to defection due to no future punishment.
- However, if cooperation was stable and at or above \( m \) last round, reward cooperation one last time.
- Otherwise, defect to avoid exploitation.

- **Decision rule:**

  ```pseudocode
  if m_(r-1) ≥ m:
      action = C
  else:
      action = D
  ```

---

### Summary / Pseudocode for All Rounds

```pseudocode
for t in 1 to r:
    if t == 1:
        action = C
    else if t < r:
        if cooperators_in_round[t-1] >= m:
            action = C
        else:
            if my_action[t-1] == C:
                action = D
            else:
                action = C
    else: // t == r (last round)
        if cooperators_in_round[r-1] >= m:
            action = C
        else:
            action = D
    play(action)
```

---

### Strategy Properties

- **Cooperative:** Starts by cooperating and tries to maintain cooperation once established.
- **Reciprocal:** Punishes defection by defecting once if cooperators drop below \( m \), then attempts cooperation again to recover trust.
- **Threshold-focused:** Uses the crucial parameter \( m \) as a benchmark to decide whether the group is cooperating adequately.
- **Resilient:** Allows room for occasional mistakes or defections; does not permanently defect after one failure.
- **Forward-looking:** In the last round, avoids being exploited by defecting if others are not cooperating, but rewards stable cooperation if present.

---

### Possible Extensions (optional, for future improvements)

- Track individual players’ cooperation history to defect selectively (if implementation allows).
- Use probabilistic cooperation instead of deterministic to soften punishment.
- Modulate punishment duration based on repeated failures (currently fixed one-round punishment).

---

This strategy balances trust-building, reciprocity, and mutual benefit tailored to the Collective Risk Dilemma’s payoff structure and repeated interaction setting.
'''

description_COOPERATIVE_98 = '''
Below is a cooperative strategy tailored for the **Collective Risk Dilemma** repeated game:

---

### Overview
The strategy aims to **ensure the threshold of cooperators (m) is met in every round**, maximizing collective rewards while punishing defection just enough to maintain cooperation. It is forgiving but vigilant, using previous rounds’ outcomes to adapt behavior.

---

### Key Intuition

- **Initial Trust:** Start cooperative to signal willingness to cooperate.
- **Monitor Cooperation Level:** Track how many others cooperated before.
- **Conditional Cooperation:** Continue cooperating only if the number of cooperators meets or exceeds the threshold last round.
- **Gradual Punishment:** Defect if cooperation drops below threshold to signal a problem.
- **Last Round Behavior:** Cooperate anyway in final round to maximize group payoff since no future retaliation possible.

---

### Decision Rules

Let:

- **t** = current round (1 ≤ t ≤ r)
- **COOP_t-1** = number of cooperators in previous round (for t=1 no previous round)
- **m** = threshold number of cooperators needed

---

#### Round 1 (t = 1):

- **Action:** Cooperate (C)

Rationale: Signal trust, attempt to start cooperation immediately.

---

#### Rounds 2 to r-1 (1 < t < r):

- If **COOP_t-1 ≥ m** (the community cooperated enough last round):

  - Cooperate (C)

- Else:

  - Defect (D)

Rationale: Keep cooperating if others cooperated sufficiently last round; defect to punish/avoid loss if threshold failed.

---

#### Round r (final round):

- Cooperate (C)

Rationale: Final round cooperation maximizes payoff. No future retaliation, so just maximize collective reward.

---

### Edge Cases

- **If COOP_t-1 = m exactly:** Cooperate — threshold met, so fulfill the group goal.
- **If COOP_t-1 < m but close (e.g., m-1):** Defect to signal disappointment and encourage others to meet threshold next round.
- **If COOP_t-1 = 0 (all defect):** Defect to conserve payoff, but will resume cooperate if threshold met in future rounds (unlikely without communication, but possible).
- **If opponents fluctuate:** This strategy switches willingness to cooperate dynamically, giving a chance to return to cooperation.
- **If a player consistently defects:** This strategy indirectly punishes them by defecting until cooperation is restored, relying on repeated interaction to encourage cooperation.

---

### Pseudocode

```python
def collective_risk_dilemma_strategy(t, r, m, history):
    """
    t: current round (1-based)
    r: total rounds
    m: cooperation threshold
    history: list of past rounds actions (list of lists), each inner list size = n
            e.g. history[t-2] gives player actions in round t-1 when t > 1

    Returns: 'C' (cooperate) or 'D' (defect)
    """
    if t == 1:
        # Round 1: always cooperate to build trust
        return 'C'

    elif t == r:
        # Final round: cooperate to maximize payoff
        return 'C'

    else:
        # From round 2 to r-1: conditional on previous round cooperation level
        previous_round_actions = history[t-2]  # index t-2 since t is 1-based
        coop_count = previous_round_actions.count('C')

        if coop_count >= m:
            return 'C'
        else:
            return 'D'
```

---

### Why This Is Cooperative

- It **starts and ends cooperating**, signaling a cooperative mindset.
- It **maintains cooperation when collective cooperation is sufficient**, reinforcing positive behavior.
- It **withholds cooperation only as a response to insufficient group cooperation**, not out of greed.
- It gives opponents a **clear, observable pattern**, facilitating tacit coordination.
- By **never escalating defections unnecessarily** and being forgiving if cooperation returns, the strategy supports sustained cooperation over multiple rounds.

---

### Summary

| Round         | Condition                       | Action     |
|---------------|--------------------------------|------------|
| 1             | Always                         | Cooperate  |
| 2 to r - 1    | Previous cooperators ≥ m       | Cooperate  |
| 2 to r - 1    | Previous cooperators < m       | Defect     |
| r (final round) | Always                       | Cooperate  |

---

This strategy balances **cooperative commitment**, **conditional punishment**, and **final round charity** to maximize collective gains over repeated interaction under the Collective Risk Dilemma.
'''

description_COOPERATIVE_99 = '''
Below is a detailed cooperative strategy tailored for the Collective Risk Dilemma with the given parameters and constraints. This strategy is designed to foster and sustain cooperation over multiple rounds, maximize the likelihood of achieving the cooperation threshold \( m \), and thereby improve collective and personal payoffs.

---

## Strategy Name: *Conditional Trust and Reinforcement Cooperation (CTRC)*

---

### Intuition

- Cooperation is beneficial if it reaches or exceeds the threshold \( m \), yielding a better payoff for everyone.
- Our strategy cooperates early to signal willingness.
- It uses observations of prior rounds to estimate whether enough others are cooperating.
- It punishes sustained defection to discourage free-riding, but forgives occasional defection to allow recovery.
- Near the last round, it anticipates endgame effects and adapts to avoid pointless cooperation loss.
- This strategy balances **conditional cooperation** with **punishment** to promote stable cooperation.

---

### High-Level Description

| Round        | Action                                            |
|--------------|--------------------------------------------------|
| Round 1      | Cooperate (signal willingness to cooperate)       |
| Intermediate Rounds (2 to r-1) | Cooperate if estimated cooperators ≥ \( m-1 \) else defect |
| Last Round (r)  | Defect to avoid exploitation (unless last round cooperation served prior benefit, then cooperate) |

---

### Decision Rules

1. **Round 1 (t = 1):**  
   - Cooperate.  
   - Reason: Start positively; establish cooperative intent.

2. **After each round \( t \) (for \( t = 2, \ldots, r - 1 \)):**  
   - Observe the number of cooperators in round \( t-1 \), call this number \( C_{t-1} \).
   - If \( C_{t-1} \geq m \), meaning reward was attained:  
       - Cooperate (trust maintained, cooperation beneficial).  
   - Else, if \( C_{t-1} = m-1 \), meaning cooperation just missed threshold:  
       - Cooperate (encourage cooperation to reach threshold).  
   - Else (if \( C_{t-1} < m-1 \)):  
       - Defect (signal defection as punishment for insufficient cooperation).  
   - **Forgiveness rule:**  
       - If you have defected for more than one round consecutively, cooperate once to test if cooperation attempts can resume.

3. **Last Round (t = r):**  
   - If prior round (r-1) cooperation reached or nearly reached threshold (≥ \( m-1 \)):  
       - Cooperate (final chance for collective benefit).  
   - Else:  
       - Defect (avoid unilateral costly cooperation when cooperation unlikely).

---

### Edge Case Handling

- **First round:** Always cooperate despite uncertainty to test the waters.
- **Last round:** Avoid losing 1 unit without future rounds to recoup benefits unless the group is cooperating well.
- **If the threshold \( m \) is very close to \( n \) (e.g., \( m = n - 1 \)) and cooperation barely fails, give extra chances.**
- **If detecting persistent defection (no threshold met for 2+ rounds), shift to defect permanently to protect own payoff.**

---

### Pseudocode

```python
# Parameters known: n, r, m, k
# Observations per round: coop_counts = [C_1, ..., C_{t-1}]

# Initialize:
consecutive_defect_count = 0

def decide_action(t, coop_counts):
    global consecutive_defect_count
    
    if t == 1:
        consecutive_defect_count = 0
        return 'C'  # Cooperate round 1
    
    last_coop = coop_counts[t-2]  # coop_counts indexed from 0, for round t-1
    
    # Decide based on previous cooperation level
    if last_coop >= m:
        # Cooperation successful
        action = 'C'
        consecutive_defect_count = 0
    elif last_coop == m - 1:
        # Cooperation almost successful, encourage cooperation
        action = 'C'
        consecutive_defect_count = 0
    elif consecutive_defect_count >= 2:
        # Forgiveness attempt: cooperate once after 2+ defect rounds
        action = 'C'
        consecutive_defect_count = 0
    else:
        # Defect as punishment/discouragement
        action = 'D'
        consecutive_defect_count += 1
    
    # Last round adjustment
    if t == r:
        if last_coop >= m - 1:
            action = 'C'  # Final cooperation attempt
        else:
            action = 'D'  # Protect payoff, no future rounds to redeem loss
    
    return action
```

---

### Why is this Cooperative?

- Starts by cooperating (invites cooperation).
- Continues cooperating if group cooperation is sufficient or nearly sufficient — reinforcing good group behavior.
- Only defects to discourage persistent defection but quickly tests for recovery via forgiveness.
- Balances self-interest with group interest by cooperating when it is most beneficial (threshold met or nearly met).
- Attempts final round cooperation only if group has cooperated recently, avoiding wasted cost.
- Uses perfect information to adaptively cooperate rather than unconditional cooperation.

---

### Potential Extensions / Notes

- The strategy assumes players will respond to incentives similarly.
- With no communication, public knowledge of actions/payoffs aids coordination through conditional cooperation.
- Strategy could be tuned by adjusting forgiveness parameters or threshold sensitivity depending on opponent behaviors.
- If opponent defect signals are severe, this strategy avoids exploitation by timely defection.

---

Let me know if you want me to design a more aggressive or forgiving variant, or a variant tailored for specific parameter ranges!
'''

description_COOPERATIVE_100 = '''
Below is a cooperative strategy tailored for the Collective Risk Dilemma repeated game that aligns with maximizing group payoff through cooperation while allowing limited flexibility to detect and respond to defectors. This strategy is designed to foster cooperation early, maintain it through most rounds, and mitigate exploitation risk.

---

## Cooperative Strategy: Conditional Reciprocity with Forgiveness

### Intuition
- Cooperate initially to help reach the threshold.
- Continue cooperating as long as sufficient cooperation is observed.
- Defect temporarily if cooperation drops below threshold to punish defectors.
- Return to cooperation after punishment to rebuild trust.
- Cooperate in the last round regardless (no future to punish or reward).

---

### Parameters (accessible to the strategy)
- n: number of players
- r: number of rounds
- m: minimum cooperators needed
- k: reward factor (not used directly but understood)
- History: record of all players' actions in past rounds

---

### Decision Rules

**Round 1:**
- Cooperate (C) unconditionally to establish trust and push toward threshold.

**Rounds 2 to r-1:**
1. Count the number of cooperators in the previous round: `prev_cooperators`.
2. If `prev_cooperators >= m`:
   - Cooperate this round.
3. Else (insufficient cooperation in previous round):
   - Defect this round (punishment phase).
4. However, if you defected in the previous round and cooperation is now restored (`prev_cooperators >= m`), **return to cooperate** this round (forgiveness).

**Round r (last round):**
- Cooperate regardless of past history (no incentive to punish last round).

---

### Handling Edge Cases

- **If no one cooperates in the first round:** You will defect in round 2 because `prev_cooperators < m`, punishing defectors.
- **If cooperation fluctuates around the threshold:** The strategy will punish immediately by defecting one round, then return to cooperation once cooperation threshold hits again.
- **If players consistently defect:** The strategy will cycle defect after defect, but always trying to return to cooperation when possible.
- **If majority cooperate all rounds:** The strategy cooperates every round -> highest collective payoff.
- **In the last round:** Always cooperate to maximize final payoffs and encourage cooperative behavior earlier.

---

### Pseudocode

```python
def decide_action(round_number, history, n, m, r):
    """
    round_number: current round index (1 to r)
    history: list of lists, each inner list is length n with actions 'C' or 'D' of all players in previous rounds
    n: number of players
    m: minimum cooperators needed
    r: number of rounds
    returns: 'C' or 'D' for current round action
    """
    
    # Round 1: Always cooperate
    if round_number == 1:
        return 'C'
    
    # Count number of cooperators last round
    last_round_actions = history[-1]
    prev_cooperators = sum(1 for a in last_round_actions if a == 'C')
    
    # Last round: Always cooperate
    if round_number == r:
        return 'C'
    
    # Determine if self defected last round
    self_last_action = history[-1][my_index]  # my_index is this player's index
    
    if prev_cooperators >= m:
        # Cooperation was successful - cooperate this round
        return 'C'
    else:
        # Cooperation failed last round
        if self_last_action == 'D':
            # We already defected last round - try to return to cooperation (forgiveness)
            return 'C'
        else:
            # Defect this round to punish defectors
            return 'D'
```

---

### Summary

| Condition                          | Action |
|----------------------------------|--------|
| Round 1                          | Cooperate (C) |
| Last Round                      | Cooperate (C) |
| Previous round cooperation ≥ m | Cooperate (C) |
| Previous round cooperation < m  | Defect (D), if didn't defect last round |
| Previous round cooperation < m  | Cooperate (C), if defected last round (forgiveness) |

---

### Why is this cooperative?

- It **starts cooperative**, trying to reach the threshold.
- It **continues cooperation when the group cooperated enough before**.
- It **punishes defectors by defecting if threshold not reached**.
- It **quickly forgives** once cooperation is restored, avoiding long costly punishment cycles.
- It **always cooperates in the last round** to maximize group reward.

---

Feel free to ask for any refinements or adaptations you might need!
'''

description_COOPERATIVE_101 = '''
**Strategy Name:** Conditional Cooperative Reciprocity (CCR)

---

### Intuition

The game is a **Repeated Collective Risk Dilemma** where cooperation by at least *m* players yields a higher payoff to **everyone**. Yet, defectors benefit individually within cooperative thresholds and free-riders can undermine cooperation. Because communication is impossible, the strategy must:

- Establish cooperation early
- Enforce cooperation by punishing defections
- Forgive defections to reestablish trust
- Prevent endgame collapse (defection near last rounds)

---

### Key Parameters

- *n*: number of players
- *r*: total rounds
- *m*: minimum cooperators per round needed
- *k*: reward factor for meeting threshold cooperators

(all known to all players)

---

### Core Ideas

1. **Start Cooperating** in round 1 to show willingness to cooperate.
2. **Track observed cooperation count** (number of cooperators) in the previous round.
3. **Condition cooperation on collective behavior**: cooperate if and only if the group met or exceeded the threshold in the last round, OR if in early rounds.
4. **Forgiveness window**: allow occasional defections (less than threshold but close) for partial forgiveness.
5. **Punishment and exit from cooperation** in case of consistent shortfalls.
6. **Endgame cooperation**: cooperate unconditionally in last few rounds to maximize total group payoff.

---

### Formal Decision Rules

Let round index be *t* with 1 ≤ *t* ≤ *r*.  
Let *C_{t-1}* be the count of cooperators last round (or initialize for t=1).

**Parameters internal to strategy (tunable):**

- *forgiveness_margin* = 1 (allow 1 less than threshold to still cooperate)
- *punish_rounds* = 2 (number of rounds of punishment)
- *endgame_rounds* = max(1, floor(r/5)) (last 20% rounds treated as endgame)
- *punishment_counter* = tracks rounds left punishing after a failed threshold

---

### Detailed Steps per Round *t*

1. **Round 1 (t=1):**  
   - Cooperate to signal willingness.

2. **Rounds 2 to (r - endgame_rounds):**  
   - If *punishment_counter* > 0:  
     - Defect (punish)
     - Decrement *punishment_counter* by 1  
   - Else if *C_{t-1}* ≥ m:  
     - Cooperate (cooperation stable)  
   - Else if *C_{t-1}* ≥ (m - forgiveness_margin):  
     - Cooperate (forgive slight shortfall)  
   - Else:  
     - Defect (start punishing)  
     - Set *punishment_counter* = punish_rounds

3. **Last endgame_rounds:** for *t* > (r - endgame_rounds)  
   - Cooperate unconditionally (maximize payoffs, no future punishment incentive).

---

### Edge Cases

- **First round**: cooperate no matter what (no history).
- **Near threshold but not quite there**: forgive by cooperating (forgiveness_margin).
- **Repeated failures**: punish by defecting for punish_rounds to discourage free riding.
- **Endgame rounds**: unconditional cooperation to maximize collective rewards, as future retaliation is impossible.
- **Tie breaking when observed counts not exact**: rely on observable full history as per game assumptions.

---

### Pseudocode

```python
initialize punishment_counter = 0
endgame_start = r - max(1, int(r / 5))

for t in range(1, r + 1):
    if t == 1:
        action = "C"  # Start cooperating
    elif t > endgame_start:
        action = "C"  # Endgame unconditional cooperation
    else:
        if punishment_counter > 0:
            action = "D"  # Punish defectors
            punishment_counter -= 1
        else:
            # Observe number of cooperators last round: C_prev
            # This includes self's cooperation last round
            if C_prev >= m:
                action = "C"  # Cooperation stable, join in
            elif C_prev >= (m - 1):
                action = "C"  # Forgive slight shortfall
            else:
                action = "D"  # Defect to punish
                punishment_counter = 2  # Punish next 2 rounds
    play action

# At end of round, update C_prev based on observed actions (including self)
```

---

### Why does this strategy align with cooperation?

- It **starts cooperatively** and rewards cooperation.
- It **punishes shortfalls** to prevent exploitation by persistent defectors.
- It includes a **forgiveness margin** to accommodate occasional mistakes or noise.
- It prevents a tragic end by **cooperating in endgame**.
- Through these elements, it incentivizes others to coordinate on cooperation, yielding collective higher payoffs over repeated rounds.

---

### Summary

| Round                  | Condition                             | Action      |
|------------------------|-------------------------------------|-------------|
| 1                      | First round                         | Cooperate   |
| 2 to r-endgame_rounds   | Punishing?                         | Defect      |
|                        | Threshold met or barely missed?    | Cooperate   |
|                        | Otherwise                         | Defect + Punish next 2 rounds |
| Last endgame_rounds     | All players                        | Cooperate   |

---

This strategy balances **reciprocity**, **punishment** and **forgiveness** with the **goal of stable, sustained cooperation** across repeated rounds.
'''

description_COOPERATIVE_102 = '''
**Cooperative Strategy: “Conditional Reciprocity with Threshold Support”**

---

### Intuition

The game has a collective risk dilemma structure, where a threshold number of cooperators (m) is needed to unlock a payoff bonus (k). Cooperation has a cost, defecting yields a higher private payoff if enough others cooperate, and defection can undermine reaching the collective threshold.

The goal is to sustain cooperation across rounds by:

- Cooperating early to signal willingness.
- Adapting to others’ cooperation level to maintain threshold.
- Punishing defections to prevent exploitation.
- Ensuring mutual cooperation until late rounds.
- Carefully shifting behavior at the last round to guard against exploitation.

---

### Main ideas

1. **Opening Move**: Cooperate in the first round to help establish the threshold.
2. **Monitoring**: Track how many players cooperated each previous round.
3. **Conditional Cooperation**:
   - Cooperate only if in the previous round the group met or nearly met the threshold (≥ m-1 cooperators).
   - Defect otherwise as a warning/punishment.
4. **Threshold Support**:
   - If cooperation count was exactly m-1 last round, cooperate to help reach threshold.
5. **Last Round Behavior**:
   - Defect on the last round to avoid being exploited (no future punishment possible).
   - Optionally cooperate if enough trust built, but default to defect here to maximize self-interest.
6. **Forgiveness**:
   - If others return to cooperating after defections, restore cooperation to regain collective benefits.
---

### Pseudocode Description

```
Input per round t:
  past_actions: matrix of all players’ actions from rounds 1 to t-1
  own_history: your own actions from 1 to t-1
  parameters: n, r, m, k

Output:
  action ∈ {C, D}

Strategy:

IF t == 1:
    # First round: always cooperate to signal good faith
    action = C

ELSE IF t == r:
    # Last round: default to defect to avoid final-round exploitation
    action = D

ELSE:
    # Count how many players cooperated last round
    last_round_cooperators = count_C(past_actions[t-1])

    IF last_round_cooperators >= m:
        # Threshold met previously, cooperate this round to maintain cooperation
        action = C

    ELSE IF last_round_cooperators == m - 1:
        # Just missed threshold, cooperate to help reach threshold this round
        action = C

    ELSE:
        # Threshold not met or poorly met, defect as punishment
        action = D

RETURN action
```

---

### Explanation and Rationale

- **Round 1**: Cooperate to show willingness and help form initial cooperation.
- **Rounds 2 to r-1**:
  - If the group meets or nearly meets threshold last round, keep cooperating to sustain payoff bonus.
  - If threshold not met, defect to punish defectors and signal seriousness.
- **Last round**:
  - Defect to avoid exploitation since no future retaliation is possible.
- **Forgiveness & recovery**:
  - The strategy is forgiving—if group cooperation recovers (threshold approached/met), cooperation resumes.
- This approach balances:
  - **Cooperation**: maximizes collective bonus.
  - **Conditionality**: avoids exploitation by defectors.
  - **Simplicity**: leverages observable cooperation counts, no communication needed.
  - **Robustness**: punishes persistent defection and supports near-cooperation.

---

### Potential Enhancements (Optional)

- Cooperate on the last round if the entire group has cooperated every round to maximize mutual payoff. Otherwise, defect.
- Gradually defect more if the cooperation level drops repeatedly.
- Track individual cooperators for targeted reciprocity if allowed by the game (not specified).

---

**Summary:** This strategy promotes and sustains cooperation by adapting action based on observed group cooperation relative to the threshold, balancing the collective good with strategic self-interest inherent in the repeated threshold public goods dilemma.
'''

description_COOPERATIVE_103 = '''
**Strategy name:** Conditional Reciprocity with Threshold Monitoring

---

### Intuition and Overview

This strategy aims to sustain cooperation across rounds by initially cooperating to signal willingness, then conditionally cooperating or defecting based on the cooperation level observed in previous rounds. The key is to establish trust through mutual cooperation, and to punish defections to deter exploitation. Because the risk threshold (m) matters, the strategy monitors the number of cooperators each round and adjusts behavior to maintain or recover cooperation, especially when near or above threshold — the collective risk dilemma hinges on meeting that threshold.

---

### Detailed Description

#### Key Notations

- **n** = number players
- **r** = total rounds
- **m** = minimum cooperators needed per round
- **k** = reward factor if threshold met
- **round t** = current round (1 ≤ t ≤ r)
- **C_t** = number of cooperators observed in round t (including self)
- **Defection tolerance** = allowed missed cooperations before defecting (e.g., 1 round)

---

### Decision Rules

**Round 1:**

- **Cooperate (C)**  
Reason: Signal cooperative intent, help reach threshold early, begin building trust.

**Rounds 2 to r-1:**

- If the previous round had **C_{t-1} ≥ m**, i.e., threshold met:

  - **If you cooperated in round t-1:**

    - Cooperate in round t, expecting others to maintain cooperation

  - Else if you defected in round t-1 (only possible if punished earlier):

    - Cooperate in round t to try to rejoin cooperation cluster

- If the previous round had **C_{t-1} < m**, i.e., threshold missed:

  - If C_{t-1} was close to m (e.g., m-1), cooperate to help reach threshold next round

  - Else defect, punishing unsuccessful cooperation cluster to avoid exploitation

- If in any round you detect consistent defectors (players repeatedly defecting past tolerated rounds), defect in current round to discourage them

**Final Round (round r):**

- Defect unless confident threshold cooperation is guaranteed, because no future repercussion exists

  - If the historical average cooperators ≥ m, cooperate to share reward

  - Else defect to maximize personal payoff (defecting when others cooperate gives highest immediate payoff)

---

### Handling Edge Cases

- **If threshold m is very close to n (e.g., m = n-1):**

  - Be stricter about cooperating only if near-certainty of others cooperating

- **If multiple rounds show low cooperation below m:**

  - Gradually shift to defecting, as cooperation is not fruitful

- **If you observe a sudden drop from high cooperation to low cooperation:**

  - Attempt "forgiveness" by cooperating once to try to restore cooperation

- **If k is very large (strong incentive):**

  - Lean towards cooperation longer, trusting others motivated by big reward

- **If k close to 1 (weak incentive):**

  - Raise defection threshold; don't assume cooperation unless stable

---

### Summary Pseudocode

```python
Initialize:
  defect_tolerance = 1
  past_cooperation_counts = []

for round t in 1 to r:
  
  if t == 1:
    action = C  # signal cooperation

  else if t == r:
    avg_coop = average(past_cooperation_counts)
    if avg_coop >= m:
      action = C  # cooperate to get reward
    else:
      action = D  # defect to maximize payoff

  else:
    prev_coop = past_cooperation_counts[-1]

    if prev_coop >= m:
      if my_action[t-1] == C:
        action = C  # maintain cooperation
      else:
        action = C  # rejoin cooperation

    else:
      if prev_coop >= m - 1:
        action = C  # try to nudge cooperation over threshold
      else:
        # punishment phase
        recent_coop_history = past_cooperation_counts[-defect_tolerance:]
        if any(coop < m for coop in recent_coop_history):
          action = D  # defect to punish defectors
        else:
          action = C  # attempt cooperation if defectors not persistent
  
  observe actions of others in round t
  count number of cooperators in round t => C_t
  past_cooperation_counts.append(C_t)
```

---

### Cooperative Alignment

- Starts by cooperating to build trust and move quickly towards collective threshold.
- Continues to cooperate when others meet threshold, sharing rewards.
- Punishes defectors only after failed rounds, but forgives to restore cooperation.
- Only defects last round if cooperation does not reliably pay off, preventing free-riding.
- Uses transparent, simple decision rules consistent with observed behavior, making it predictable and encouraging cooperation in others.

---

This design balances cooperation and rational self-interest, aiming to maximize joint and individual payoffs while fostering sustained cooperation across the repeated risk dilemma.
'''

description_COOPERATIVE_104 = '''
Here's a cooperative strategy designed for the Collective Risk Dilemma that aims to sustain cooperation across rounds by leveraging conditional cooperation and forgiveness to build trust, while accounting for edge cases such as the first and last rounds.

---

## Strategy Name: **Conditional Cooperative Trust**

### Intuition and Goal

- Achieve the cooperation threshold *m* every round to secure the reward *k* for everyone.
- Begin cooperatively, signaling willingness to cooperate.
- Continue cooperating as long as enough players cooperate.
- If cooperation fails (i.e., fewer than *m* cooperators last round), defect once as punishment but attempt to return to cooperation immediately after.
- In the last round, maintain cooperation to maximize group payoff (no incentive to defect late).
- This fosters mutual cooperation, punishes defections mildly, and avoids spirals of defecting.

---

## Decision Rules Overview

| Condition                                             | Action (C or D)                         | Reasoning                                |
|-------------------------------------------------------|-----------------------------------------|-----------------------------------------|
| **Round 1 (no history):**                              | Cooperate (C)                           | Signal intention to cooperate            |
| **Round t (1 < t < r):**                               | If last round had ≥ m cooperators:     | Cooperation was successful last round    |
|                                                       | → Cooperate (C)                        | Reward cooperation                        |
|                                                       | Else if last round had < m cooperators | Cooperation failed                        |
|                                                       | → Defect (D) one round punishment     | Mild punishment                          |
|                                                       | → Start cooperating next round         | Attempt reconciliation                    |
| **Round r (last round):**                              | Cooperate (C)                          | No incentive to exploit last round       |

---

## Details

1. **Base state:** Start in *Cooperate* mode.
2. **Monitoring:** After each round, count how many cooperators there were.
3. **If cooperation succeeded (≥ m cooperators):** Maintain cooperative stance.
4. **If cooperation failed (< m cooperators):** Punish by defecting *once* in the next round.
5. **After punishment round:** Return to cooperation regardless of the immediate prior outcome, giving others a chance to cooperate.
6. **Last round special case:** Cooperate regardless of history — no future repercussions.

---

## Pseudocode

```python
initialize:
    round = 1
    punishment_flag = False  # indicates whether to punish this round

for round in 1 to r:
    if round == 1:
        action = C  # start cooperating
    else if round == r:
        action = C  # cooperate in last round
    else:
        if punishment_flag:
            action = D  # punish defection from last round
            punishment_flag = False  # reset after punishing
        else:
            # Check last round cooperation count
            if last_round_cooperators >= m:
                action = C  # continue cooperating
            else:
                punishment_flag = True  # schedule punishment next round
                action = C  # cooperate this round, punishment will come next round

    play(action)
    
    # After everyone plays, update last_round_cooperators for next iteration
    last_round_cooperators = count_cooperators_current_round()
```

**Note:** The key is *delayed punishment*: if cooperation thresholds not met in round t-1, punish by defecting in round t, but cooperate in round t otherwise. This prevents endless defect cycles and allows cooperation to recover.

---

## Why This Strategy Is Cooperative and Sound

- **Starts cooperatively:** Explicitly signals cooperative intent.
- **Sustains cooperation:** Rewards cooperation by cooperating consecutively.
- **Contains defection:** Deters free-riding with a single-round punishment.
- **Forgiving:** Quickly returns to cooperation after punishing defection.
- **Robust to misunderstandings:** Punishes defection only once to avoid escalating breakdown.
- **No exploitation:** Never defects when others cooperate sufficiently.
- **Last round cooperation:** Maximizes collective gain since no future rounds to exploit.

---

## Edge Case Handling Summary

| Edge Case          | Action                             | Explanation                         |
|--------------------|----------------------------------|-----------------------------------|
| **Round 1**        | Cooperate                       | No history, start positive        |
| **Last round**     | Cooperate                       | No future repercussions           |
| **After failed cooperation** | Defect once, then revert to cooperation | Punish but forgive quickly        |
| **Repeated failed cooperation** | Punish once per failure, revert after | Avoid endless retaliation cycles  |

---

This strategy balances incentives to cooperate with limited punishment and forgiveness, encouraging stable cooperation and maximizing joint rewards over repeated rounds in a setting without communication.
'''

description_COOPERATIVE_105 = '''
Below is a cooperative strategy designed for the Collective Risk Dilemma repeated simultaneous-move game. It aims to secure the collective reward by coordinating on minimal cooperation each round while being robust to defections and carefully adjusting behavior over rounds.

---

## Strategy Name: Minimal Threshold Cooperate-and-Punish (MTCP)

### Intuition

- The key to unlocking the collective reward is having **at least m players cooperate per round**.
- Cooperation costs 1 unit; defection costs 0 but risks losing the collective reward.
- Defectors who free-ride when threshold is met get higher payoffs that round.
- To maintain cooperation:
  - Start cooperative to signal willingness.
  - Track cooperation levels each round.
  - Punish undercooperation by defecting to avoid exploitation.
  - Resume cooperation when cooperation recovers.
- In the **last round**, defect to maximize payoff (no future incentive to cooperate when future punishment is impossible).
- Promote minimal but sufficient cooperation (exactly m players if possible) to optimize group's payoffs.

---

### Parameters

- Known: n, r, m, k
- Variables maintained:
  - `history` = record of all rounds: actions of all players
  - `current_round` from 1 to r

---

### High-Level Decision Rules

| Round Type                         | Action                             | Rationale                                                                                |
|----------------------------------|----------------------------------|------------------------------------------------------------------------------------------|
| Round 1 (First round)             | Cooperate (C)                    | Signal cooperative intent, build trust.                                                 |
| Rounds 2 to r-1 (Intermediate)   | If previous round cooperation count ≥ m: Cooperate (C) | Keep cooperating if group met threshold last round, aiming for reward.                   |
|                                  | Else Defect (D)                  | Punish defectors by defecting when collective failed to meet threshold.                   |
| Round r (Last round)              | Defect (D)                      | No future rounds to incentivize cooperation, defect to maximize last-round payoff.      |

---

### Extended Logic to Fine-Tune Cooperation

- **If cooperation last round was above threshold** (≥ m), cooperate to maintain reward.
- **If cooperation last round was below threshold**, defect to signal punishment.
- After a punishment round, if cooperation recovers to threshold, resume cooperating; else continue defecting.

---

### Pseudocode

```python
def MTCP_strategy(current_round, history, n, r, m):
    """
    Determine action for current round based on history and game parameters.
    
    Args:
    - current_round (int): Current round number (1-indexed)
    - history (list of lists): Each element is list of actions of all players in a past round, e.g. ['C','D','C',...]
    - n (int): Number of players
    - r (int): Total rounds
    - m (int): Minimum cooperators needed
    
    Returns:
    - action (str): 'C' or 'D'
    """
    
    # Last round: defect to maximize last-round payoff
    if current_round == r:
        return 'D'
    
    # First round: cooperate to signal and attempt to reach threshold
    if current_round == 1:
        return 'C'
    
    # For rounds 2 to r-1:
    # Count number of cooperators last round
    last_round_actions = history[-1]  # actions in previous round
    coop_count = last_round_actions.count('C')
    
    # If threshold met or exceeded last round, continue cooperating to keep reward flowing
    if coop_count >= m:
        return 'C'
    
    # If threshold was not met, punish by defecting
    return 'D'
```

---

### Justification & Properties

- **Cooperative mindset:** Always tries to reach or maintain the minimal cooperation threshold needed for collective reward.
- **Fairness:** Does not tolerate persistent free-riding; offers cooperation, but punishes undercooperation.
- **Simplicity and observability:** Uses only publicly available information (previous round actions).
- **Deterministic and reactive:** Adjusts cooperation immediately based on observed group behavior.
- **Backward-looking:** Uses last round as immediate feedback.
- **Endgame reasoning:** Defects in last round as no incentive for cooperation remains.

---

### Possible Extensions (Optional)

- **Gradual forgiveness:** Instead of immediately defecting after a miss, defect only once or twice before cooperating again.
- **Tracking individual defectors:** But per specification, individual identification doesn’t create better incentives here because of simultaneous moves.
- **Adjust cooperating count dynamically:** Try to cooperate only if fewer than m cooperators are detected last round. But simultaneous moves and no communication limit this.

---

### Summary

This **Minimal Threshold Cooperate-and-Punish (MTCP)** strategy:

- Cooperates first round.
- Continuously cooperates only if minimal cooperation threshold is met last round.
- Defects to punish whenever threshold is not met.
- Defects last round.
- Thus aligns with a cooperative mindset, balancing risk and reward efficiently.
'''

description_COOPERATIVE_106 = '''
**Strategy Overview: "Conditional Collective Cooperation"**

This strategy aims to achieve the collective goal (at least *m* cooperators per round), maximizing rewards for all cooperators over repeated rounds, by conditioning own cooperation on observed behavior, exploiting others only minimally, and prioritizing cooperation early to establish trust.

---

### Intuition

- Cooperation is beneficial to the group if at least *m* players cooperate.
- Defecting unconditionally risks insufficient cooperators, resulting in no reward.
- Sustained cooperation requires trust; hence cooperate initially and continue cooperating if sufficient cooperation observed.
- When nearing the last round, defecting increases individual payoff since no future punishment is possible.
- Punish defectors by defecting in next round to dissuade free-riding but allow return to cooperation if group cooperation recovers.

---

### Decision Rules

Let:
- `round` ∈ {1,...,r} be current round,
- `C_count[t]` = number of cooperators observed in round t,
- `cooperate_threshold = m` (minimum cooperators needed).

**At round 1:**

- Cooperate to establish initial trust.

**At rounds 2 to r-1:**

- If in last round (round == r-1), treat specially (see below).
- Observe past rounds `1,..., round-1`.
- Calculate average cooperators per round before current:  
  `avg_C = (sum from t=1 to round-1 of C_count[t]) / (round - 1)`

- If the last round had at least `m` cooperators, **and** the average cooperators so far ≥ m (or close to it, e.g., ≥ m - 1), cooperate.

- Else, **defect** to punish free riders and signal non-cooperation.

- Exception: If own previous action was defection but group returned to cooperation, forgive by cooperating again.

**At last round (round = r):**

- Defect to maximize individual payoff since no future punishment.

---

### Edge Cases and Specific Considerations

1. **Near-threshold behavior:**

   - If cooperation is slightly below `m`, remain cooperative if overall trend is improving; otherwise defect.

2. **Handling alternating defectors:**

   - If detecting players switching between cooperation and defection to exploit, maintain defection until stable cooperation verified.

3. **Forgiveness:**

   - After defecting due to punishment, return to cooperation if group cooperation rebounds.

4. **Small margin groups (`m` close to `n`):**

   - Always cooperate unless clearly insufficient cooperators.

5. **Large groups:**

   - Rely more on past averages and recent cooperation.

---

### Pseudocode

```python
initialize:
    cooperated_rounds = 0  # track own cooperation count
    punishment = False    # flag for punishment state

for round in 1 to r:

    if round == 1:
        action = "C"  # signal cooperation initially
        cooperated_rounds += 1

    elif round == r:
        # Last round: defect for personal gain
        action = "D"

    else:
        # Calculate avg cooperators in past rounds
        avg_C = sum(C_count[1:round-1]) / (round - 1)
        last_round_C = C_count[round - 1]

        # Determine if cooperation viable
        if last_round_C >= m and avg_C >= (m - 1):
            # If just punished last round, forgive if group cooperation stable
            if punishment:
                punishment = False
                action = "C"
                cooperated_rounds += 1
            else:
                action = "C"
                cooperated_rounds += 1
        else:
            # Punish by defecting to avoid exploitation
            action = "D"
            punishment = True

    play(action)
```

---

### Summary

- **Start cooperative** to set positive tone.
- **Continue to cooperate** if group cooperation is strong (≥ m) and stable.
- **Punish by defecting** when cooperation falls below threshold to discourage free-riding.
- **Forgive after punishment** if cooperation recovers.
- **Defect on last round** to maximize individual payoff since no future penalties.
- This approach balances individual payoff with collective benefit, leveraging repeated interaction and perfect observation to sustain cooperation.
'''

description_COOPERATIVE_107 = '''
Below is a cooperative strategy tailored for the Collective Risk Dilemma with repeated simultaneous moves. The strategy strives to achieve and maintain the minimum cooperation threshold \( m \) each round to secure the reward \( k \), balancing temptation to defect against collective benefit.

---

## Strategy Name: **Threshold-Triggered Cooperative Reciprocity**

### Intuition and Objectives:
- Achieve and sustain cooperation \(\geq m\) each round to secure the reward.
- Punish defection only if cooperation levels drop below \( m \), to discourage free-riding.
- Use observed past cooperation counts as a signal to update behavior.
- Start by trusting others (cooperate initially) to build momentum.
- Adjust to last round by defecting if cooperation cannot be sustained or as a safe fallback.

---

### Decision Rules

**Notation:**

- \( t \): current round (1-based)
- \( r \): total rounds
- \( n \): number of players
- \( m \): cooperation threshold
- \( k \): reward if threshold met
- \( C_t \): number of cooperators observed in round \( t \)
- Action in round \( t \): \( a_t \in \{C, D\} \)

---

### Round 1 (\(t = 1\)):

- Cooperate by default: \( a_1 := C \)
- Rationale: Establish cooperative norm and test willingness of others.

---

### Intermediate rounds (\(1 < t < r\)):

- **If** \( C_{t-1} \geq m \) (previous round met threshold):
  - Cooperate \( a_t := C \).  
  - Rationale: Cooperation was successful; continue cooperating.

- **Else if** \( C_{t-1} < m \) (previous round failed threshold):
  - Defect \( a_t := D \).  
  - Rationale: Punish defectors by withholding cooperation when public good failed.

- (Optional refinement)
  - If the cooperation count was just below \( m \) (e.g., \( m-1 \)) and defecting this round would reduce expected payoff, consider cooperating probabilistically or based on history trends.
  - But with no communication and only immediate history, simple deterministic rules are preferred.

---

### Last round (\(t = r\)):

- **If** \( C_{r-1} \geq m \):
  - Cooperate \( a_r := C \).
  - Rational: End on cooperative note if successful so far.

- **Else**:
  - Defect \( a_r := D \).
  - Rationale: No future rounds to reward cooperation, incentivizes defection.

---

### Additional considerations:

- **Tie-breaker or if no cooperation info is clear:**
  - Default to cooperate early in the game.
  - Defect late or after consistent failure to reach threshold.

- **Memory:**
  - Only immediate previous round cooperation count is used.
  - This keeps the strategy lightweight and reactive.

---

## Pseudocode

```
INPUT: n, r, m, k, round t, observed cooperation counts C_1, ..., C_{t-1}

FUNCTION decide_action(t, C_prev):
    IF t == 1:
        RETURN C   // start cooperative
    ELSE IF t == r:  // last round
        IF C_prev >= m:
            RETURN C
        ELSE:
            RETURN D
    ELSE:  // intermediate rounds
        IF C_prev >= m:
            RETURN C
        ELSE:
            RETURN D
```

---

## Summary

- Start by cooperating to set cooperative norm.
- Maintain cooperation if last round's cooperation met or exceeded threshold \( m \).
- Defect if cooperation failed in previous round to discourage free-riding.
- On the last round, cooperate only if cooperation was successful previously.
- The strategy thus fosters stable cooperation cycles and punishes breakdowns quickly, aligning with the collective risk dilemma’s incentives.

---

This approach balances trust and accountability without complex signaling or history-dependent punishments—well-suited to anonymous, non-communicating agents in repeated rounds with full observability.
'''

description_COOPERATIVE_108 = '''
Here is a detailed cooperative strategy design for the Collective Risk Dilemma.

---

## Strategy: Conditional Cooperation with Forgiveness and Endgame Adjustment

### Intuition:
- Cooperate early to build trust and reach the threshold **m** so everyone gets the reward **k**.
- Use observed cooperation levels in previous rounds to decide whether to continue cooperating.
- If cooperation starts to fail, punish defectors by defecting for a short period to signal displeasure.
- In the last round, defect to maximize private payoff since no future cooperation incentive remains.
- Forgive defections if cooperation improves again, to restore and maintain cooperation long-term.

---

## Decision Rules

### Initialization
- Round 1: Cooperate to signal willingness to cooperate and help reach the threshold.

### For rounds 2 to r - 1 (middle rounds)
1. **Observe previous round:**
   - Count how many players cooperated (observed_cooperators).
2. **Threshold check:**
   - If observed_cooperators ≥ m:
     - Continue to cooperate.
   - Else:
     - Defect to punish non-cooperators in previous round.
3. **Forgiveness rule:**
   - If in penalty mode (defecting due to low cooperation), but the cooperation level recovers to ≥ m in the current observed round:
     - Switch back to cooperating immediately next round.
4. **Penalty window:**
   - Defect only one round after observing too low cooperation to signal dissatisfaction, then reconsider cooperation next round depending on cooperation recovery.

### Round r (last round)
- Defect unconditionally (free-riding), as no future punishment or cooperation benefit exists.

---

## Additional considerations

- **Tolerance parameter:** Allow small fluctuations by forgiving occasional dip below threshold once every few rounds to avoid endless punishment cycles. (Optional enhancement but not essential)

---

## Pseudocode

```python
def collective_risk_strategy(round_num, total_rounds, m, history):
    """
    round_num: current round index (1-based)
    total_rounds: total number of rounds 'r'
    m: minimum cooperators needed
    history: list of previous rounds' action tuples, each of length n with 'C' or 'D'
    
    Returns: 'C' or 'D'
    """
    
    # First round: cooperate to build trust
    if round_num == 1:
        return 'C'
    
    # Last round: defect to maximize private payoff
    if round_num == total_rounds:
        return 'D'
    
    # From second to penultimate rounds:
    # Analyze previous round cooperation level
    prev_round_actions = history[-1]
    number_cooperated = sum(1 for a in prev_round_actions if a == 'C')
    
    # If last round cooperation met threshold, cooperate
    if number_cooperated >= m:
        return 'C'
    
    # Otherwise, defect to punish for one round only
    # But if punished last round, check if cooperation returned
    # (To implement short-term punishment, we need an additional memory flag.
    # Here we approximate by checking two rounds ago if available)
    
    if round_num >= 3:
        two_rounds_ago_actions = history[-2]
        coop_two_rounds_ago = sum(1 for a in two_rounds_ago_actions if a == 'C')
        
        if coop_two_rounds_ago < m and number_cooperated >= m:
            # Forgiven and cooperation fixed, so cooperate now
            return 'C'
        elif coop_two_rounds_ago < m and number_cooperated < m:
            # Continue defecting one more round as punishment
            return 'D'
    
    # Default if no history or no change: defect
    return 'D'
```

---

## Explanation

- The strategy starts with cooperation to try to secure the collective reward.
- If the cooperation threshold was met last round, it continues cooperating.
- If the threshold was not met last round, it defects once (punishment).
- If cooperation recovers, it forgives and returns to cooperating.
- In the last round it defects because cooperation cannot be enforced anymore.
- This balances cooperation incentives with punishment flexibility, leading to a cooperative equilibrium if others also cooperate.

---

## Summary

| Round                     | Action                               | Rationale                                       |
|---------------------------|------------------------------------|------------------------------------------------|
| Round 1                   | Cooperate (C)                      | Signal cooperation intention                    |
| Rounds 2 to r - 1         | Cooperate if last round ≥ m cooperators <br> Defect one round if last round < m cooperators <br> Forgive and revert to cooperate if cooperation recovers | Reward cooperation, punish defections, forgive recoveries  |
| Round r (last round)      | Defect (D)                         | No future incentive to cooperate (endgame)     |

---

This strategy promotes a stable cooperative environment, maximizes collective payoff, and handles defections in a pragmatic, forgiving manner appropriate for repeated interactions with perfect information and no communication.
'''

description_COOPERATIVE_109 = '''
Below is a cooperative strategy tailored for the Collective Risk Dilemma tournament, designed to foster cooperation, respond to defections, and maximize mutual payoffs across multiple rounds.

---

## Strategy Name: Responsive Threshold Cooperation (RTC)

### Core Idea
- Start cooperatively to try to build trust.
- Track cooperation rates of others.
- Cooperate as long as a sufficient number of players appear cooperative.
- Defect as a mild punishment if cooperation drops.
- Return to cooperation if others restore their cooperation.
- Gradually increase caution near the last round to secure endgame payoffs.

---

### Parameters Used Internally
- **Threshold for expected cooperators per round:** `m` (same as game parameter)
- **Minimum fraction of cooperating players needed to keep cooperating:** \( \theta = \frac{m}{n} \).  
  Cooperate only if at least fraction \(\theta\) of others cooperated last round.
- **Tolerance for punishment:** Single defection detection triggers 1 round of punishment defect.
- **Punishment length:** 1 round defect (short to avoid retaliation spirals).
- **Endgame caution window:** Last round only, defect if risk is high (too risky to cooperate last move).

---

### Decision Rules (per round \(t\)):

#### Round 1
- Cooperate, to signal goodwill and initiate cooperation.

#### Subsequent Rounds (2 ≤ t < r)
- Observe how many players cooperated in round \(t-1\), excluding yourself.
- If at least \(m\) players cooperated last round, cooperate.
- Else, defect for one round (punishment).
- If punished last round, follow up by cooperating again (forgiveness).

#### Last Round (t = r)
- Defect if cooperating exposes you to risk of being exploited:
  - If in the previous round fewer than \(m\) players cooperated, defect (avoid paying cost).
  - Else cooperate to help preserve payoff if cooperation threshold was met.
- Alternatively, defect unconditionally in the final round to maximize private payoff if uncertain about others’ cooperation.

---

### Edge Cases

- **If a continuous defection pattern emerges among others:**
  - Maintain defection after a few rounds to avoid exploitation.
  
- **If cooperation drops below threshold multiple rounds in a row:**
  - Gradually shift to primarily defecting to minimize losses.

- **If all defect round 1:**
  - Continue defecting (no incentive to cooperate alone).

---

### Pseudocode

```python
initialize:
  last_round_cooperators = n  # start optimistically
  punishment_active = False
  punishment_rounds_left = 0

for round t in 1 to r:
    if t == 1:
        # First round cooperate to build trust
        action = 'C'
        
    elif punishment_active:
        # Punish by defecting for 1 round
        action = 'D'
        punishment_rounds_left -= 1
        if punishment_rounds_left == 0:
            punishment_active = False
    
    else:
        # Count cooperators in previous round excluding self
        coop_prev = number_of_players_cooperating_in_round(t-1)
        coop_fraction = coop_prev / n

        if coop_prev >= m:
            # Sufficient cooperation, cooperate
            action = 'C'
        else:
            # Insufficient cooperation, punish by defecting next round
            action = 'D'
            punishment_active = True
            punishment_rounds_left = 1

    # Last round special case:
    if t == r:
        # Decide cautiously on last round
        coop_prev = number_of_players_cooperating_in_round(t-1)
        if coop_prev < m:
            # Too risky to cooperate, defect to keep private payoff
            action = 'D'
        else:
            # Cooperation likely beneficial, cooperate
            action = 'C'
    
    play(action)
```

---

### Rationale Summary

- **Start cooperative:** Initiate beneficial equilibrium.
- **Punish defection briefly:** Quick feedback to discourage free riding.
- **Forgive promptly:** Prevent endless retaliation cycles, encourage return to cooperation.
- **Condition cooperation on others’ behavior:** Avoid exploitation.
- **Last round caution:** Avoid worst-case losses by defecting when risky.
- **Simple, memory-limited:** Uses only previous round history, suitable for large n and multiple rounds.

---

This strategy aims to sustain cooperation by conditional reciprocity while being robust to exploitation attempts and the shadow of the future effect in repeated play. It encourages all players to maintain the cooperative threshold \(m\), maximizing collective payoff and preventing collapse to all-defect equilibria.
'''

description_COOPERATIVE_110 = '''
Below is a cooperative strategy tailored to the Collective Risk Dilemma, designed to foster cooperation while adjusting to observed player behavior across repeated rounds.

---

## Strategy Name: **Conditional Trust and Threshold Cooperation (CTTC)**

---

## Intuition and Goals

- **Goal:** Ensure at least *m* players cooperate each round to receive the reward *k*.
- **Challenge:** Some players may defect to gain higher immediate payoff when threshold is met.
- **Approach:** Start cooperatively, monitor others’ cooperation rates, punish chronic defectors by defecting against them, and restore cooperation when conditions improve.
- Use **conditional cooperation**: cooperate if you trust that at least *m* players (including self) will cooperate to reach threshold; otherwise, defect to avoid wasting your own contribution.
- Avoid unconditional cooperation that can be exploited.
- Recognize rounds: first round starts with trust, final round can favor defection if cooperation is not reliably established.

---

## Parameters and Variables Maintained

- **n, r, m, k:** Known game parameters.
- **Round t:** Current round number, 1 ≤ t ≤ r.
- **History:** Full record of players’ previous actions each round.
- **TrustScore[i]:** Estimate of player i’s cooperation rate over past rounds.
- **CooperatorSet:** Set of players currently considered trustworthy cooperators.
- **Tolerance:** Threshold cooperation rate to consider a player “cooperative” (e.g., ≥ 80%).

---

## Decision Rules by Round

### Round 1 (t=1):

- No history available.
- **Action:** Cooperate (C) to signal cooperative intent and attempt to reach threshold.
- This sets foundation for building trust.

### Intermediate Rounds (1 < t < r):

- **Update TrustScore[i]:**  
  For each player i ≠ self, calculate cooperation frequency up to round t-1:
  \[
  TrustScore[i] = \frac{\# \text{of rounds i cooperated}}{t-1}
  \]
  
- **Identify CooperatorSet:**  
  \[
  CooperatorSet = \{ i \;|\; TrustScore[i] \geq 0.8 \}
  \]
  (This is adjustable for tolerance.)

- **Estimate potential cooperators this round:**  
  \[
  EstimatedCooperators = |CooperatorSet| + 1 \quad \text{(include self)}
  \]

- **If** \( EstimatedCooperators \geq m \), **then** cooperate (C), else defect (D).

- Purpose: Cooperate only if expecting threshold *m* will be met, avoiding wasting own contribution otherwise.

### Final Round (t = r):

- Cooperation incentives diminish as no future rounds to punish defectors.
- Conservative approach recommended:

- **If** threshold expected based on history: \( EstimatedCooperators \geq m \), **then** cooperate (C).
- **Else** defect (D).

---

## Additional Handling and Refinements

### Punishment for Defectors:

- Defectors who have cooperation frequency less than tolerance cutoff (e.g., 80%) are excluded from CooperatorSet.
- Defecting reduces player’s TrustScore, diminishing own incentive to cooperate if threshold unlikely reached.

### Recovery Mechanism:

- If a player’s cooperation frequency improves and crosses tolerance, reintegrate them into CooperatorSet.

### Tie-breakers:

- If exactly \( EstimatedCooperators = m-1 \), defect to avoid losing contribution unnecessarily (can be adjusted cautiously to cooperate if risk is acceptable).

---

## Pseudocode

```python
initialize TrustScore = {i: 1.0 for i in players if i != self}  # Optimistic initial trust

for t in 1 to r:

    if t == 1:
        action = Cooperate  # First round: show trust
    
    else:
        # Update TrustScore for each other player
        for i in players_except_self:
            TrustScore[i] = count_cooperations(i, rounds=1..t-1) / (t-1)

        # Identify trusted cooperators
        CooperatorSet = { i for i in players_except_self if TrustScore[i] >= 0.8 }
        EstimatedCooperators = len(CooperatorSet) + 1  # include self
        
        if t == r:
            # Final round
            if EstimatedCooperators >= m:
                action = Cooperate
            else:
                action = Defect
        else:
            # Intermediate rounds
            if EstimatedCooperators >= m:
                action = Cooperate
            else:
                action = Defect

    play(action)

    observe all players’ actions
    update history
```

---

## Summary

- **First round:** Cooperate to build trust.
- **Subsequent rounds:** Cooperate only if you confidently expect threshold *m* is met (based on history).
- **Final round:** Cooperate only if threshold likely; otherwise defect.
- **Monitor and adapt:** Update trust scores; exclude defectors from your cooperation calculations; punish defectors by defecting against them.
- **Restore cooperation:** Allow players to regain trust by consistent cooperation.
- This strategy balances cooperation and self-protection, encourages group success, minimizes exploitation risk. It aligns clearly with cooperative spirit under repeated interaction with transparent actions.
'''

description_COOPERATIVE_111 = '''
Below is a cooperative strategy designed for the Collective Risk Dilemma tournament, built to encourage coordination on cooperation and to punish persistent defection while maintaining forgiveness to sustain cooperation.

---

## Strategy Objectives

- **Encourage cooperation** to reach the threshold **m** so all players secure the risk-averted reward **k**.
- **Detect defectors** and punish them by defecting temporarily, discouraging free-riding.
- **Forgive defectors** if they return to cooperation, to restore collective gains.
- **Adapt throughout the game rounds**, accounting for start, middle, and approaching the final round.

---

## Key Intuition

- **Start by cooperating** to signal willingness to cooperate.
- Use **history of cooperation counts** to detect if enough players are cooperating.
- If cooperation levels drop below the threshold persistently, **punish by defecting** to avoid being exploited.
- If cooperation recovers, **return to cooperation** to rebuild collective trust.
- In the **final round**, cooperate if it yields expected higher payoff, else defect.

---

## Notation

- Let `t` = current round (1 to r)
- `actions[t][i]` = action of player i at round t (C or D)
- `coopCount[t]` = number of cooperators at round t
- `m` = minimum cooperators needed
- `n` = number of players
- `r` = total rounds
- `k` = reward multiplier (>1)
- `myIndex` = your player index

---

## Strategy Description

### Initialization (before round 1)

- `forgive` flag = False
- `punishRounds` counter = 0

---

### Decision Rules

**At each round t:**

1. **Round 1 (t = 1)**:
   - Cooperate (C) to establish goodwill.

2. **Rounds 2 to r-1 (middle rounds):**

   - Observe previous round `t-1`:
     - Compute `coopCount[t-1]` = number of cooperators in previous round.
   
   - **If `punishRounds` > 0:**
     - Defect (D)
     - Decrement `punishRounds` by 1. (Punish lasts exactly a fixed number of rounds, e.g. 1 or 2)
     - Continue to next round.
   
   - Else (not currently punishing):
   
     - **If `coopCount[t-1]` ≥ m:**
       - Cooperate (C), continue cooperation.
     
     - Else (fewer than m cooperators last round):
       - Check if you cooperated last round:
         - If yes, some players did not cooperate despite your cooperation → **start punishing** by defecting for 1 round.
         - Set `punishRounds = 1`
         - Defect (D) this round as punishment.
       - Else (you defected last round):
         - Defect again to punish or force cooperation.
         - (Optionally decrease punishment length or forgive early if cooperation recovers)
   
3. **Round r (last round):**

   - If you expect cooperating yields payoff ≥ defecting (i.e., last round enough cooperators will cooperate to reach threshold m):
     - Cooperate.

   - Else:
     - Defect.

   *Estimation:* Use last round's cooperation level to estimate if cooperation threshold will be reached this round. If last round had ≥ m cooperators, expect cooperation to continue in final round.

---

## Handling Edge Cases

- **If no one cooperated last round in first half of the game:**  
  Cooperate anyway once to test if others will cooperate, then react accordingly.

- **If repeated defection observed (coopCount consistently < m):**  
  Maintain defect for remainder to avoid exploitation (rational exit from cooperation).

- **If cooperation suddenly recovers (coopCount ≥ m after punishment):**  
  Reset punishment, cooperate next round.

---

## Pseudocode Summary

```python
# Parameters: n, r, m, k
# Variables to maintain:
punishRounds = 0

def decide_action(t, history_actions):
    # history_actions: list of length t-1 with each element a list of actions of all players
    
    if t == 1:
        return 'C'  # Start cooperatively
    
    coopCount_prev = sum(1 for a in history_actions[t-2] if a == 'C')
    my_prev_action = history_actions[t-2][myIndex - 1]  # zero-based index
    
    # Last round cooperation estimate triggers forgiveness
    if punishRounds > 0:
        punishRounds -= 1
        return 'D'  # Continue punishment
    
    if coopCount_prev >= m:
        return 'C'  # Cooperation stable, continue cooperating
    
    else:
        # Cooperation failed last round
        if my_prev_action == 'C':
            # I cooperated, others did not, punish
            punishRounds = 1
            return 'D'
        else:
            # I defected last round, continue defecting or consider forgiveness if cooperation improves
            # Here simplest: keep defecting to avoid exploitation
            return 'D'

def decide_last_round(t, history_actions):
    # Use same logic but with forecast
    coopCount_prev = sum(1 for a in history_actions[t-2] if a == 'C')
    if coopCount_prev >= m:
        return 'C'
    else:
        return 'D'
```

---

## Summary

- **Open with cooperation.**
- **Continue cooperating if threshold met last round.**
- **Defect one round as punishment if you cooperated but threshold not met.**
- **Defect otherwise to avoid exploitation.**
- **Forgive if cooperation threshold recovers.**
- **In final round, cooperate only if expected payoff justifies it.**

This strategy balances cooperation encouragement, responsiveness to defectors, and careful forgiveness to sustain cooperation over repeated rounds under the Collective Risk Dilemma’s conditions.
'''

description_COOPERATIVE_112 = '''
Below is a cooperative strategy explicitly tailored for the Collective Risk Dilemma repeated game specified. It aims to foster trust and coordinate on cooperation to reliably meet the minimum threshold \( m \) of cooperators needed each round, thereby achieving the higher payoff for all.

---

## Strategy: Conditional Coordinated Cooperation (CCC)

### Core Idea
- Aim to cooperate consistently to reach or exceed the threshold \( m \) of cooperators each round.
- Use observed past actions of all players to estimate willingness to cooperate.
- If cooperation appears fragile (too few cooperators), cautiously defect for that round but try to restore cooperation next round.
- Never defect in the last round to maintain collective trust and maximize total payoff.
- Start with cooperation in round 1 to signal cooperative intent.

---

### Detailed Decision Rules

**Notation:**
- \( n \): number of players
- \( r \): total rounds
- \( m \): minimum cooperators needed
- \( t \in \{1,\ldots, r\} \): current round
- \( \text{CoopCount}_{t-1} \): number of players (including self) who cooperated in the previous round
- Players are indexed \( i \in \{1,\ldots,n\} \); self is player \( i_{\text{self}} \).

---

### Round 1 (Initial Cooperation)

- Since no history yet, **cooperate** to signal goodwill and encourage cooperation.

```pseudocode
if t == 1:
    action = C
```

---

### Intermediate Rounds (2 to r-1)

- Observe previous round's actions.
- Count how many players cooperated: \( \text{CoopCount}_{t-1} \).
- If \( \text{CoopCount}_{t-1} \ge m \) (threshold met):
  - Continue cooperating to maintain collective benefit.
- Else if \( \text{CoopCount}_{t-1} < m \) (threshold not met):
  - **Defect once** this round—punish the cooperation failure and avoid the cost.
  - However, if you just defected last round, return to cooperation to try rebuilding trust.
- Reasoning: This "punishment" period allows identification of consistent defectors while giving chance to resume cooperation.

```pseudocode
if 1 < t < r:
    if CoopCount_{t-1} >= m:
        action = C  # Stable cooperation
    else:
        if self_defected_last_round:
            action = C  # Forgive and try to cooperate again
        else:
            action = D  # Punish for cooperation failure
```

---

### Last Round (Round \( r \))

- Always **cooperate** in the last round regardless of history.
- This avoids endgame defection that undermines total welfare.

```pseudocode
if t == r:
    action = C
```

---

### Additional Notes & Justification

- **Cooperation Signal:** The first round cooperation commits to cooperate, encouraging reciprocation.
- **Responsive Punishment:** Defecting in the face of failed cooperation discourages free-riding and enforces norm compliance.
- **Forgiveness:** Returning to cooperation after defecting ensures the possibility of restoring collective trust.
- **Last Round Cooperation:** Avoids the typical backward induction problem, maintaining cooperative equilibrium.
- **No reliance on communication:** The strategy uses only observed actions and payoffs, aligning with perfect information assumption.
- **Adaptation to opponent behavior:** This reaction mechanism nudges the group towards stable cooperation equilibria if others also cooperate conditionally.

---

## Summary of the Strategy

| Round       | Condition                                 | Action    |
|-------------|-------------------------------------------|-----------|
| Round 1     | No history                                | Cooperate (C) |
| Intermediate (2 to r-1) | Previous round \( \ge m \) cooperators | Cooperate (C) |
| Intermediate (2 to r-1) | Previous round \( < m \) cooperators and self cooperated last round | Defect (D) (punishment) |
| Intermediate (2 to r-1) | Previous round \( < m \) cooperators and self defected last round | Cooperate (C) (forgiveness) |
| Round r (last round) | Always                               | Cooperate (C) |

---

## Pseudocode Implementation Sketch

```pseudocode
for t in 1 to r:
    if t == 1:
        action = C
    else if t == r:
        action = C
    else:
        CoopCount_prev = count of players who played C in round t-1

        if CoopCount_prev >= m:
            action = C  # cooperation stable
        else:
            if self_defected_in_round(t-1):
                action = C  # forgiveness
            else:
                action = D  # punishment

    play action
```

---

This Cooperative Conditional Cooperation strategy balances the risk-reward tradeoff by rewarding cooperative groups, disciplining defectors, while allowing forgiveness and restoring cooperation. It is designed to maximize group welfare consistent with the collective risk dilemma, under the constraints given (no communication, perfect info, repeated rounds).
'''

description_COOPERATIVE_113 = '''
**Strategy Name: Conditional Reciprocity with Threshold Coordination**

---

### **Intuition and Goals**

This strategy aims to foster cooperation by coordinating contributions just enough to meet the threshold \( m \) each round. It does so by:

- Starting cooperatively to build trust.
- Monitoring opponents’ actions and adapting cooperativeness accordingly.
- Attempting to ensure \( m \) or more players cooperate each round, maximizing collective payoffs.
- Avoiding exploitation by defecting when cooperation is unlikely to be rewarded.
- Maintaining cooperation until near the end, when defection may become more individually rational but collectively worse.

---

### **Key Challenges**

- Need to estimate others’ cooperativeness since no direct communication.
- Must coordinate so exactly \( m \) or more players cooperate — cooperation beyond \( m \) is not punished but may be exploited.
- Handle stage-game incentives where free-riding yields highest payoff if enough others cooperate.
- Account for end-game effect where backward induction may unravel cooperation.

---

### **Parameters**

- \( n \) = number of players
- \( r \) = rounds (indexed \( t = 1, \dots, r \))
- \( m \) = minimum cooperators needed
- \( k \) = reward multiplier if threshold met

---

### **Decision Rules**

---

#### Round 1 (Initialization)

- **Action:** Cooperate (C)
- **Rationale:** Start by signaling willingness to cooperate; seed trust.

---

#### Rounds \( t = 2 \) to \( r-2 \) (Early to Mid Game)

- **Observe:** Opponents' actions in round \( t-1 \)
- **Calculate:** Number of cooperators last round \( C_{t-1} \)

- **If** \( C_{t-1} \geq m \) and my own action was C in \( t-1 \):
    - Assume cooperation is stable.
    - **Action:**
        - Cooperate if \( C_{t-1} \leq m \) (help maintain minimal cooperation)
        - Defect if \( C_{t-1} > m \) (free-ride safely if threshold exceeded)
- **Else if** \( C_{t-1} < m \) or I defected last round:
    - There is risk cooperation not ensured.
    - **Action:**
        - Cooperate to try restoring cooperation up to threshold.
- **Additional rule (coordination):** 
    - If \( C_{t-1} = m-1 \), cooperate to help reach threshold.
    - If \( C_{t-1} > m \), consider defecting to gain individual advantage but only if opponents seem to tolerate (not defecting en masse).

---

#### Round \( r-1 \) (Penultimate Round)

- Cooperation still valuable but risk of exploitation increases.
- **If** previous rounds showed stable cooperation (\( C_{t-1} \geq m \)):
    - Cooperate to ensure high final reward.
- **Else:**
    - Start reducing cooperation to defend against exploitation.

---

#### Round \( r \) (Final Round)

- **Action:** Defect
- **Rationale:** No future rounds to incentivize cooperation; revert to dominant strategy.

---

### **Edge Cases Handling**

- **If signal of mass defection (e.g., \( C_{t-1} = 0 \)) persists:**
    - Defect to avoid being exploited.
- **If borderline cooperation (\( C_{t-1} = m-1 \)) early/mid game:**
    - Always cooperate to push over threshold.
- **If others show conditional cooperation:**
    - Match their pattern to stabilize cooperation.
- **If \( k \) very high (large reward):**
    - More incentive to cooperate — bias towards cooperation.
- **If \( k \) just above 1 (low incentive):**
    - Be more cautious and free-ride if threshold seems achievable without you.

---

### **Summary Pseudocode**

```python
# Inputs: n, r, m, k
# For round t in 1..r:
#   Observe prev_actions: list of actions of all players in round t-1 (empty if t=1)
#   own_prev_action: my action in t-1 (None if t=1)

def decide_action(t, prev_actions, own_prev_action):
    if t == 1:
        return 'C'  # Start cooperatively
    
    num_cooperators = sum(1 for a in prev_actions if a == 'C')
    prev_cooperator = (own_prev_action == 'C')

    if t == r:
        return 'D'  # Final round defect
    
    if t == r - 1:
        # Penultimate round: cooperate if cooperation was stable
        if num_cooperators >= m:
            return 'C'
        else:
            return 'D'

    # Early and mid game (2 <= t <= r-2)
    if num_cooperators >= m and prev_cooperator:
        if num_cooperators == m:
            return 'C'  # maintain threshold cooperation
        else:
            # threshold exceeded, can safely defect to free ride
            return 'D'
    else:
        # threshold not met last round or I defected previously, try restoring
        if num_cooperators == m-1:
            return 'C'  # push cooperation over threshold
        elif num_cooperators < m-1:
            # too few cooperators -- cooperate if k high, else defect
            if k > 1.5:
                return 'C'
            else:
                return 'D'
        else:
            # borderline or unstable - cooperate to signal
            return 'C'
```

---

### **Strategic Summary**

- Begin cooperative to establish rapport.
- Use observed cooperation levels to decide whether to maintain or withhold cooperation.
- Maintain a minimal threshold of cooperation to ensure everyone gains.
- Use conditional defection when others over-cooperate to avoid being exploited.
- In the final round, defect as incentives shift to selfish play.
- Adapt flexibly to observed opponent behavior but strive to keep the group at or above threshold cooperation each round.

---

This strategy embraces cooperation through conditional reciprocity and coordination on the minimal cooperation threshold, balancing trust-building with protection against exploitation, and acknowledging end-game reasoning.
'''

description_COOPERATIVE_114 = '''
**Strategy Name: Conditional Reciprocity with Risk Thresholding**

---

### Overview

The goal is to **coordinate cooperation** to meet or exceed the threshold \( m \) cooperators each round, ensuring everyone receives the reward \( k \), while avoiding exploitation (being the sole cooperator who pays cost without meeting threshold). The strategy:

- Starts by cooperating to signal willingness.
- In subsequent rounds, cooperates only if past behaviour suggests cooperation is collectively sustainable.
- Adjusts cautiously if cooperation fails.
- Defects strategically in the final round to avoid being exploited.

---

### Intuition

- Cooperate initially to establish trust.
- Monitor others' actions to infer if at least \( m-1 \) other players are cooperating.
- If cooperation is stable, keep cooperating.
- If cooperation falters (fewer than \( m \) cooperators last round), defect once (punishment), then try cooperating again.
- In the last round, defect to avoid being the only cooperator exploited, as no future rounds permit retaliation or reward for cooperation.

---

### Formal Decision Rules

Let:

- \( r \) = total rounds
- \( t \in \{1, \ldots, r\} \) = current round
- \( C_{t-1} \) = set of players who cooperated in round \( t-1 \) (available since perfect info)
- \( count_{t-1} = |C_{t-1}| \)
- \( punishmentFlag \) = a boolean indicating if I defected last round as punishment
- Let \( i \) be this player

---

### Pseudocode

```python
initialize:
    punishmentFlag = False

for t in 1 to r:
    if t == 1:
        # Round 1: Start cooperative
        action = C

    elif t == r:
        # Last round: defect to avoid exploitation, no future rounds for cooperation benefit
        action = D

    else:
        # For rounds 2 to r-1:
        if punishmentFlag:
            # In previous round, defected as punishment, now try cooperation to re-establish trust
            action = C
            punishmentFlag = False

        else:
            if count_{t-1} >= m:
                # Cooperation threshold met previously - continue cooperating to secure rewards
                action = C
            else:
                # Cooperation threshold failed previously
                # Defect to punish defectors this round
                action = D
                punishmentFlag = True    # next round try cooperation again
```

---

### Explanation

- **First round (t=1):** Cooperate to signal willingness; since no history, best to try to initiate cooperation.
- **Rounds 2 to r-1:**
  - If threshold \( m \) met last round, continue cooperating (keep stable cooperation).
  - If threshold not met last round, defect this round to punish free-riders, and set a flag to try cooperation next round.
  - After punishing once, attempt cooperation again (trembling-hand like forgiveness to rebuild cooperation).
- **Last round (t=r):** Defect to avoid paying cooperation cost where no future reward or punishment can incentivize cooperation.

---

### Edge Cases Addressed

- **If cooperation never met:** The strategy cycles between cooperating and defecting, trying to nudge others toward cooperation but punishes defection to discourage free-riding.
- **If many defectors early on:** Punishment by defection signals dissatisfaction and willingness to retaliate, discouraging persistent defection.
- **If cooperation stabilizes:** Steady cooperation from round 2 onward maximizes common reward.
- **Last round defecting:** Avoids ending with a costly cooperation that provides no strategic benefit.

---

### Cooperative Mindset Alignment

- This strategy prioritizes collective success (meeting \( m \) cooperators) by cooperating whenever threshold met.
- Uses proportionate punishment to discourage free-riding while allowing for forgiveness and re-establishment of cooperation.
- Attempts to maintain a stable cooperative environment to maximize collective payoffs over repeated play.

---

If you require a more complex strategy (e.g., incorporating gradations of cooperation observed, probabilistic responses, or memory of multiple rounds), please let me know! But the above is a robust, simple cooperative baseline aligned with the game dynamics.
'''

description_COOPERATIVE_115 = '''
Below is a cooperative strategy designed to maximize joint payoffs by encouraging cooperation to meet or exceed the threshold \( m \) each round, while handling the constraints of imperfect trust and no communication in a repeated simultaneous-move setting.

---

### Cooperative Strategy: "Conditional Threshold Reciprocity"

---

### Intuition:
- The group needs at least \( m \) cooperators per round for everyone to obtain the reward \( k \).
- Defecting yields private benefit (1 unit) plus the reward if the threshold is met, which can be bigger than cooperating.
- Cooperation is socially optimal but individually costly.
- To sustain cooperation, base your decisions on historic cooperation frequency.
- Punish persistent defections after detecting likely free-riders, but forgive to allow rebuilding cooperation.
- Attempt "just enough cooperators" to reduce personal cost.
- Close to last round, reduce cooperation since future punishment is not possible.

---

### Notation / State Tracking:
- \( t \): current round (1 to \( r \))
- \( n \): number of players
- \( m \): minimum cooperators needed
- \( k \): reward multiplier > 1
- History: For each player \( j \) store count of rounds they cooperated so far: \( coopCount_j \)
- Threshold buffer: cooperate once \( m \) players cooperate in past round
- Personal cooperation count: \( coopCount_i \)
- \( coopRatio_j = \frac{coopCount_j}{t-1} \) for \( t > 1 \)

---

### Decision Rules:

#### 1. Round 1 (Initial Trust)
- Cooperate to initiate mutual cooperation since you have no prior info.
- \( Action_i = C \)

#### 2. Rounds 2 to \( r-1 \):
- Observe the number of cooperators in previous round \( t-1 \), call this \( lastCoop \).
- Compute each player’s overall cooperation proportion \( coopRatio_j \).
- Define "trusted cooperators" as players with \( coopRatio_j \geq \theta \) (a threshold, e.g., 0.7).
- Count trusted cooperators as \( m_{trusted} \).
- Define \( targetCoop = m \) if \( m_{trusted} \ge m \) else increase cooperation to compensate.

Your decision:
- If \( m_{trusted} \ge m \):
  - Play D (defect) if you believe enough trusted cooperators will cooperate (to reduce own cost).
  - Exception: If your own cooperation history is low (below \(\theta\)), cooperate to maintain your reputation.
- Else (not enough trusted cooperators):
  - Cooperate to help meet the threshold.
- If no player is reliably cooperating (all below \(\theta\)):
  - Cooperate as default to build trust.

*(This balances incentivizing cooperation among reliable group members and minimizing own cost by free-riding on trusted cooperators.)*

#### 3. Last Round \( t = r \) (Endgame)
- Cooperation is costly with no future punishment, so defect.
- \( Action_i = D \)

---

### Additional Points:

- The threshold \( \theta \) (cooperation ratio considered trustworthy) can be tuned, e.g., 0.7-0.8.
- To avoid exploitation by consistent defectors, if you detect players with \( coopRatio < 0.5 \), treat them as untrusted and increase your cooperation to compensate.
- This strategy promotes cooperation by encouraging others to cooperate to be considered trustworthy, and exploits by defecting when possible.
- It also penalizes free-riders by defecting when exploitation is detected.

---

### Pseudocode

```python
# Parameters: n, r, m, k
# State: coopCount_j array indexed by player j
# Initialize coopCount_j = 0 for all players

def decide_action(t, coopCount, n, r, m, k, self_index, last_round_coops):
    theta = 0.7  # trust threshold
    
    if t == 1:
        # Initial round: cooperate to seed trust
        return 'C'
    
    if t == r:
        # Last round: defect to maximize own payoff
        return 'D'
    
    # Compute cooperation ratios for each player (excluding current round)
    coopRatios = [coopCount[j] / (t - 1) for j in range(n)]
    
    # Identify trusted cooperators
    trusted = [j for j in range(n) if coopRatios[j] >= theta]
    
    # Count how many trusted cooperators
    m_trusted = len(trusted)
    
    # Assess if threshold met last round
    lastCoop = sum(last_round_coops)  # number of cooperators last round
    
    # Own cooperation ratio
    self_ratio = coopRatios[self_index]
    
    # If enough trusted cooperators, defect unless your own ratio is low (maintain trust)
    if m_trusted >= m:
        if self_ratio < theta:
            return 'C'  # maintain trustworthiness
        else:
            return 'D'  # free-ride on trusted cooperators
    
    # If threshold not met or trusted cooperators insufficient
    # Cooperate to help meet minimum threshold
    return 'C'
```

---

### Summary

| Round       | Condition                                  | Action          |
|-------------|--------------------------------------------|-----------------|
| 1           | No history                                 | Cooperate (C)   |
| 2 to r-1    | Enough trusted cooperators (\(\ge m\))     | Defect if personally trustworthy, else cooperate  |
| 2 to r-1    | Not enough trusted cooperators              | Cooperate (C)   |
| \( r \) (last) | Endgame, no future punishment possible    | Defect (D)      |

---

This strategy fosters cooperation by rewarding consistent cooperators with less need to cooperate personally (minimizing cost), punishes defectors by increasing personal cooperation burden, and defects predictably in the last round. It adapts dynamically to observed behavior and is aligned with the cooperative mindset given the game constraints.
'''

description_COOPERATIVE_116 = '''
**Cooperative Strategy for Collective Risk Dilemma**

---

### Intuition and Goals

- The *key cooperative goal* is to ensure at least **m** players cooperate each round to secure the **k** reward for everyone.
- Cooperation requires coordination and sustained mutual trust over multiple rounds.
- Defection incentives exist, especially since defectors keep their endowment and still gain the reward if enough cooperate.
- The repeated nature of the game allows for contingent strategies that punish defection and reward cooperation.
- No communication forces inference purely from observed historic actions.

---

### Core Principles

1. **Start cooperative and optimistic:** Assume others will cooperate initially.
2. **Track number of cooperators each round** to estimate others’ willingness.
3. **If cooperation is insufficient or unstable, punish defectors by defecting in subsequent rounds.**
4. **Forgiveness:** Return to cooperation if others show cooperative intent again.
5. **In the last round, defect unless guaranteed to meet threshold (to avoid being exploited at the end).**

---

### Detailed Decision Rules

---

#### Initialization:

- Maintain a memory of past rounds:
  - `C_count[t]` = number of cooperators observed in round t.
  - `My_action[t]` = your own action in round t.
- Parameters:
  - `n, r, m, k` given.
- Set an internal state variable: **cooperative_mode = True** initially.

---

#### Round 1 (start of game):

- Cooperate (C) to signal willingness and encourage others.
- Record `My_action[1] = C`.

---

#### Rounds 2 through r-1:

1. **Observe history:** For round t, examine `C_count[t-1]`:

   - If `C_count[t-1] ≥ m` (threshold met last round):
     - If you cooperated last round, continue to cooperate to maintain the cooperative equilibrium.
     - If you defected last round, but still threshold was met, cooperating this round helps increase trust and maintain cooperation.
     - **Decision:** Cooperate (C).

   - If `C_count[t-1] < m` (threshold not met last round):
     - The group failed to generate the reward.
     - Analyze your own contribution last round:
       - If you cooperated last round but threshold not met ⇒ *you were exploited or cooperation insufficient*.
         - Punish defectors by defecting this round.
         - Set `cooperative_mode = False`
         - **Decision:** Defect (D).
       - If you defected last round and threshold not met ⇒ cooperation not stable; also defect.
         - `cooperative_mode = False`
         - **Decision:** Defect (D).

2. **If in `cooperative_mode == False`:**

   - Watch if in recent rounds (last 2 or 3 rounds), cooperation increased back to meeting threshold.
   - If yes, return to `cooperative_mode = True` and cooperate again (to encourage return to cooperation).
   - Else, keep defecting.

---

#### Round r (last round):

- Defect **unless confident threshold will be met without your cooperation**, i.e., if `C_count[r-1] ≥ m`.
- Reasoning:
  - No future punishment possible.
  - If threshold not assured, cooperating has only cost and no future benefit.
  - So, defect to maximize personal payoff while trusting others to cooperate if threshold is met without you.

---

### Summary Pseudocode

```python
for t in range(1, r+1):

    if t == 1:
        # First round, start cooperative
        action = 'C'
        cooperative_mode = True

    else:
        # Check last round's cooperation count
        last_C_count = C_count[t-1]

        if t == r:
            # Last round
            if last_C_count >= m:
                # Threshold met last time, defect this time to maximize payoff
                action = 'D'
            else:
                # Threshold not met, defect anyway (no future punishment)
                action = 'D'

        else:
            # Not last round
            if last_C_count >= m:
                # Threshold met last round
                # Cooperate to maintain cooperation
                action = 'C'
                cooperative_mode = True

            else:
                # Threshold not met last round
                if cooperative_mode:
                    # Punish defectors by defecting
                    action = 'D'
                    cooperative_mode = False
                else:
                    # Check if cooperation regained in last 2-3 rounds:
                    if any(C_count[max(1,t-3):t] >= m):
                        # Forgive and return to cooperation
                        action = 'C'
                        cooperative_mode = True
                    else:
                        # Continue defecting until cooperation returns
                        action = 'D'

    My_action[t] = action
    play(action)
```

---

### Explanation of Cooperative Mindset

- **Starts with cooperation** to signal trust.
- **Supports collective success** by cooperating when threshold met.
- **Punishes failures** appropriately to discourage free riding or unstable cooperation.
- **Allows forgiveness** to repair cooperation if others return to cooperating.
- **Rational in the last round** - defects unless cooperation is assured.

This approach balances *maximizing collective rewards* with *incentives to maintain cooperation*, leveraging repeated play and reputation.

---

### Edge Cases Handling

- If threshold barely met or uncertain (e.g., exactly m cooperators), still trust last round’s cooperation outcome.
- If multiple rounds of defection or threshold failure, stays defecting until others return to cooperation.
- Last round maximizes individual payoff given no future rounds.
- Works for any n, m, r, k satisfying game constraints.

---

This strategy should perform well in tournament environments with a mixture of strategies as it promotes stable cooperation, punishes exploitation, and optimizes endgame behavior.
'''

description_COOPERATIVE_117 = '''
Below is a cooperative strategy designed for the Collective Risk Dilemma that aims to achieve the minimum threshold of cooperators (m) every round, thereby ensuring the group receives the reward (k). The strategy balances initial trust, responsiveness to others’ behavior, and endgame reasoning to sustain cooperation throughout the repeated interaction.

---

# Strategy: Conditional Threshold Cooperation with Forgiveness (CTCF)

## Intuition

- **Goal:** Maintain at least *m* cooperators every round to secure the reward *k*.
- **Trust at start:** Begin cooperatively, assuming others will try to cooperate.
- **Conditional cooperation:** Cooperate if past behavior indicates the group can meet the threshold.
- **Forgiveness:** If group cooperation fails one round, allow for recovery before punishing defections.
- **Endgame consideration:** Defect in the last round to maximize payoff since no future rounds exist to punish defection.
- **Coordination via counting cooperators:** Since each player observes all actions, condition behavior on observed cooperators in previous rounds.

---

## Decision Rules

For player i at round t:

1. **Round 1 (t=1):**  
   - Play **C** (cooperate).  
   *Rationale:* Start by trusting all players to cooperate to try to secure the reward early.

2. **Rounds 2 to r-1 (2 ≤ t ≤ r-1):**  
   Evaluate cooperation level in previous round (t-1):
   - Let \(X_{t-1}\) = number of players who cooperated in round \(t-1\).
   
   Decision:
   - If \(X_{t-1} \geq m\), *cooperation was successful last round*:  
     - Play **C**.  
     *Rationale:* Group successfully cooperated last round, continue cooperating to sustain reward.
   
   - If \(X_{t-1} < m\), *cooperation failed last round*:  
     - Check round \(t-2\) if it exists:  
       - Let \(X_{t-2}\) = number of cooperators in round \(t-2\).  
       - If \(t=2\), no \(t-2\), so treat as no prior success.  
     - If \(X_{t-2} \geq m\), this is a first failure; play **C** once to forgive and attempt recovery.  
     - Else (consecutive failure): play **D** (defect) as punishment for persistent defection.  
   *Rationale:* Give players one chance to recover cooperation, thereafter defect to signal breakdown of cooperation.

3. **Round r (last round):**  
   - Play **D** (defect).  
   *Rationale:* No future rounds to incentivize cooperation; defect to maximize individual payoff.

---

## Additional Considerations

- **Tie-breaking for borderline cases:** If exactly m cooperators were observed, treat as success.
- **Symmetry assumption:** All players have the same strategy and observe history equally.
- **No communication:** Actions alone are signals.
- **Risk:** This strategy relies on reciprocity and mutual trust; if others never cooperate, expect failure after second round.
- **Extension:** If detecting random defections (occasional mis-cooperators), can add tolerance by forgiving more failures before defecting (for robustness).

---

## Pseudocode

```python
def decide_action(t, r, m, history):
    """
    t: current round (1-based)
    r: total rounds
    m: cooperation threshold
    history: list of sets of cooperators indices per past round
             history[t-2] = set of cooperators in round t-1
    
    Returns: "C" or "D"
    """

    if t == 1:
        # First round: cooperate to start
        return "C"
    
    if t == r:
        # Last round: defect to maximize payoff
        return "D"
    
    # For rounds 2 <= t <= r-1:
    prev_cooperators = history[t-2]  # round t-1 cooperators
    prev_count = len(prev_cooperators)

    # Check if cooperation threshold met last round
    if prev_count >= m:
        # Successful cooperation in last round
        return "C"

    # Cooperation failure last round
    if t == 2:
        # No prior round before t-1, first failure
        return "C"  # forgive once
    else:
        prev2_cooperators = history[t-3]  # round t-2 cooperators
        prev2_count = len(prev2_cooperators)
        if prev2_count >= m:
            # Failure last round after success before; first failure in a row
            return "C"  # forgive once
        else:
            # Consecutive failure rounds; punish defectors
            return "D"
```

---

# Summary

This strategy promotes collective welfare by starting cooperatively, maintaining cooperation when groups succeed, allowing brief forgiveness on first failure, and punishing persistent defections by defecting thereafter. It defects in the final round to maximize individual payoff, balancing cooperation incentives with rational endgame behavior. This approach aligns with the cooperative mindset and leverages perfect information to sustain group rewards over repeated rounds.
'''

description_COOPERATIVE_118 = '''
**Cooperative Strategy for the Collective Risk Dilemma**

---

### Strategy Objectives

- Foster and sustain cooperation to ensure the threshold *m* cooperators is met each round.
- Avoid exploitation by defectors while encouraging mutual cooperation.
- Use observed history to decide actions, adapting to opponents' behavior.
- Maximize total payoff by cooperating when collective cooperation is likely, defecting only when defection is beneficial or cooperation no longer benefits.

---

### Intuition and Outline

- Cooperation benefits everyone if at least *m* players cooperate.
- Defecting while the threshold is met yields highest payoff individually but risks the collective collapse if many defect.
- We want to maintain cooperation early and through most rounds to gain the reward *k* consistently.
- Punish defection in a measured way to discourage free-riding.
- In the last round, defect opportunistically if the collective payoff is safe or cooperation unlikely.

---

### Decision Rules by Round

---

#### **Round 1 (No History)**

- **Action:** Cooperate (C)
- **Rationale:** Signal willingness to cooperate, set a cooperative norm.

---

#### **Rounds 2 to r - 1 (Middle Rounds)**

- Observe the previous round's cooperation levels:

  - Let `prev_cooperators` = number of players who cooperated in the last round.
  - Let `prev_my_action` = your own last round action.
  - Let `prev_round_success` = whether `prev_cooperators ≥ m`.

- **If previous round met threshold (prev_round_success == True):**

  - **If prev_my_action == C:**  
    - Continue cooperating.
    - **Rationale:** Cooperation is working, maintain it.
  
  - **If prev_my_action == D:**  
    - Defect again this round (exploit stable cooperation).
    - But if `prev_cooperators` only just met threshold (equal to *m*, no slack), revert to cooperate next round to avoid causing failure.
    - **Rationale:** Defection pays more here and does not yet cause failure, but proceed cautiously.

- **If previous round did NOT meet threshold (prev_round_success == False):**

  - **If `prev_cooperators` increased or maintained since round before last:**  
    - Cooperate to push towards threshold.
  
  - **Else:**  
    - Defect this round.
  
  - **If last round you cooperated but threshold still not met:**  
    - Consider defecting to avoid consistent loss until others coordinate.
  
  - **Rationale:** Punish persistent failure to reach threshold by avoiding being exploited.

---

#### **Last Round (Round r)**

- **If previous round met threshold and cooperators ≥ m + 1:**  
  - Defect to maximize individual payoff, as no future retaliation is possible.

- **Else:**  
  - Cooperate if threshold can be met or cooperation improves collective payoff.

- **Rationale:** No incentive to sustain cooperation after this round unless threshold is comfortably met.

---

### Edge Case Handling

- **If observed cooperators drop below m multiple rounds in a row (say 2 or more):**  
  Switch to persistent defection to avoid exploitation.

- **If observed almost no cooperation from others in first two rounds:**  
  Switch to defection early to minimize losses.

- **If threshold *m* is close to *n* (e.g., m = n - 1):**  
  Be more cautious in defecting; sustain cooperation longer.

---

### Pseudocode

```python
function decide_action(round t, history):

    if t == 1:
        return C  # Signal cooperation
    
    prev_actions = history[t-1]  # actions of all players last round
    prev_cooperators = count_C(prev_actions)
    prev_round_success = (prev_cooperators >= m)
    prev_my_action = history[t-1][my_index]
    
    if t == r:  # Last round
        if prev_round_success and prev_cooperators > m:
            return D  # Exploit for max payoff
        else:
            # If cooperation likely or threshold achievable, cooperate
            projected_cooperators = estimate_next_cooperators(history)
            if projected_cooperators >= m:
                return C
            else:
                return D
    
    # Middle rounds (2 to r-1)
    if prev_round_success:
        if prev_my_action == C:
            return C  # Continue cooperation
        else:
            if prev_cooperators > m:
                return D  # Exploit safely
            else:
                return C  # Help maintain threshold
    
    else:  # previous round failed to meet threshold
        recent_cooperation_trend = assess_trend(history)
        
        if recent_cooperation_trend is increasing or steady:
            return C  # Try to recover cooperation
        else:
            return D  # Defect to avoid losses

    # Fallback (should not reach here)
    return C
```

---

### Summary

- **Cooperate on round 1** to establish trust.
- **Maintain cooperation when the group meets the threshold**, to sustain collective reward.
- **Defect strategically when threshold just met or cooperation fails persistently**, to maximize own payoff by exploiting others or limiting losses.
- **Exploit in the last round if cooperation is present**, as no retaliation possible.
- **Use history to detect cooperation trends and adapt accordingly.**

This strategy balances cooperating to achieve group payoff while defending against and punishing free riders, aligned with a cooperative mindset but mindful of self-interest in a repeated scenario without communication.
'''

description_COOPERATIVE_119 = '''
Below is a cooperative strategy tailored to the Collective Risk Dilemma, designed to (a) foster cooperation if others cooperate, (b) punish free-riders minimally to deter defection, and (c) maximize joint payoffs while recognizing the repeated structure of the game.

---

## Strategy Overview: "Threshold-Triggered Conditional Cooperation"

This strategy aims to:

- **Start cooperatively** to signal intent and give others a chance to build trust.
- **Continue cooperating if collective cooperation is sufficient**, indicating a cooperative environment.
- **Use minimal defection (punishment) if cooperation breaks down**, to discourage persistent free-riding while preserving incentives to return to cooperation.
- **Return to cooperation quickly if others resume cooperating**, avoiding endless punishment.
- **Handle last round by defecting if cooperation is not assured**, exploiting the finite horizon but cooperating if cooperation has been reliably sustained, to maximize total payoffs.

---

## Parameters Used by Strategy

- **Memory:** Actions (C/D) of all players in all previous rounds.
- **Threshold for cooperation in a round:** At least m cooperators.
- **Tolerance:** One round of non-cooperation tolerated before punishing.
- **Punishment:** Defect once if threshold not met previously, then return to cooperation.
  
---

## Pseudocode Description

```
Input: n, r, m, k
For each round t in 1 to r:
  
  If t == 1:
    // First round: start by cooperating to encourage cooperation
    action_i = C

  Else if t < r:
    // For rounds before last one:

    // Count how many players cooperated in previous round t-1
    coop_prev = number of players who played C in round t-1

    If coop_prev >= m:
      // Cooperation threshold met in last round
      // Cooperate again to maintain cooperation
      action_i = C

    Else:
      // Threshold not met last round: possible defection/failure to cooperate

      // Check if strategic punishment was done last round
      If my action in round t-1 was D:
        // Punished already, return to cooperating to restore cooperation
        action_i = C
      Else:
        // Punish by defecting once to deter free-riding
        action_i = D

  Else:
    // Last round t == r

    // Check cooperation history in previous round
    coop_prev = number of players who played C in round r-1

    If coop_prev >= m:
      // Reward cooperation by cooperating last round as well (mutual payoff boost)
      action_i = C
    Else:
      // Defect to maximize payoff exploiting end game
      action_i = D

Return action_i
```

---

## Explanation and Rationale

- **Round 1:** Cooperate to signal willingness to form stable cooperation.
- **Rounds 2 to r-1:**
  - If the group met the cooperation threshold last round, cooperate again. This rewards cooperation and produces the higher group payoff.
  - If the threshold was not met, defect once as a "warning" or punishment to incentivize others to cooperate.
  - If you already punished last round (by defecting), revert to cooperation immediately to avoid endless punishment cycles and encourage reconciliation.
- **Round r (last round):**
  - If cooperation was successful in the immediately preceding round, cooperate to share the reward and reinforce cooperative behavior.
  - Otherwise, defect to exploit the end of the game since no future rounds remain to incentivize cooperation.

---

## Handling Edge Cases

- **If others never cooperate:** After one round of punishment, strategy reverts to cooperation hoping to restart cooperation; if others persist in defecting, your expected payoff is limited but you avoid endless costly punishment cycles.
- **If threshold m is close to n:** Cooperation is harder, but this strategy still tries to maintain cooperation if it exists.
- **If k is very high:** Strategy captures high rewards by encouraging cooperation; punishment is brief to not undermine large cooperative payoffs.
- **If r is small (e.g., 2 rounds):** Strategy closely resembles TFT (tit-for-tat) with final round defect, aligning with standard finite repeated game logic.

---

## Summary

- **Cooperate initially and after collective cooperation rounds.**
- **Defect once as punishment if cooperation threshold fails to encourage cooperation.**
- **Return quickly to cooperation to maintain group payoffs.**
- **Defect last round if cooperation not assured, else cooperate.**

This simple yet robust conditional cooperation strategy balances incentivizing collaboration, discouraging persistent defection, and maximizing collective payoffs within the constraints of the repeated Collective Risk Dilemma.
'''

description_COOPERATIVE_120 = '''
Certainly! Below is a detailed cooperative strategy design tailored to the Collective Risk Dilemma game you described.

---

## Strategy Name: Conditional Cooperative Reciprocity (CCR)

### Goals:
- Achieve the cooperation threshold \( m \) as often as possible to obtain the reward \( k \).
- Avoid being exploited by defectors.
- Encourage cooperation over repeated rounds via reciprocity.
- Minimize losses in the last round by anticipating endgame defection incentives.

---

## Intuition / High-Level Overview

- **Round 1:** Cooperate to set a cooperative norm.
- **Subsequent rounds:** Cooperate if past cooperation levels met or nearly met threshold \( m \).
- Defect if cooperation was too low in previous round or too many defectors present.
- Apply forgiveness: allow one "bad" round by tolerating occasional defection.
- In the last round, cooperate only if the risk of joint defection is low.
- Communicate implicitly by mirroring the group cooperation—reward cooperation, punish defection.

---

## Assumptions to Leverage:
- Perfect information on all player actions and payoffs from prior rounds
- No communication beyond observed actions/payoffs
- Players are rational (try to maximize payoffs)
- Other LLM strategies may try to cooperate or defect, but all know the game structure

---

## Decision Rules

Let:
- \( t \in \{1, \ldots, r\} \) denote round index
- \( C_t \) = set of players who cooperated in round \( t-1 \) (past round)
- \( |C_t| \) = number of cooperators in round \( t-1 \)
- \( i \) = player index (self)
- Cooperate = C, Defect = D

---

### Round 1 (Initialization):
- **Action:** Cooperate (C).
- **Reason:** Signal willingness to cooperate and attempt to meet threshold. Since no history, best is to cooperate to maximize potential gains.

---

### General Rule for Rounds 2 to \( r-1 \):
At round \( t \):
1. Observe \( |C_{t}| \) (number of cooperators last round).
2. If \( |C_t| \geq m \):
   - *Interpretation:* Cooperation threshold met last round → others are cooperative.
   - **Action:** Cooperate to maintain cooperation.
3. Else if \( |C_t| \geq m - 1 \):
   - *Interpretation:* Almost enough cooperators last round.
   - Check if self cooperated in \( t-1 \):
     - If yes, cooperate again (forgive slight shortfall).
     - If no, defect (punish for not contributing).
4. Else (fewer than \( m - 1 \) cooperators):
   - *Interpretation:* Cooperation failed badly.
   - Defect to avoid sunk cost and punish defectors.
5. Exception: If at round \( t = r - 1 \), and cooperation last round was low (below \( m \)), anticipate last round defection and **defect** preemptively in round \( r - 1 \).

---

### Final Round \( t = r \):
- Last round usually incentivizes defection (no future reciprocity).
- **Action rules:**
  - If \( |C_{r-1}| \geq m \), cooperate to gain reward \( k \) despite endgame.
  - Else defect to avoid being exploited.

---

### Additional Elements:

- **Forgiveness Mechanism:**
  - If cooperation fails once after prior strong cooperation (i.e., \( |C_t| < m \) but \( |C_{t-1}| \geq m \)), forgive once by cooperating again.
- **Memory:**
  - Track cooperation history for \( t-2 \) rounds if needed to avoid permanent retaliation.
- **Implicit Communication:**
  - By cooperating only if enough cooperators existed last round, the strategy encourages others to cooperate.

---

## Pseudocode

```python
def CCR_strategy(t, r, m, n, observed_cooperators_last_round, self_cooperated_last_round, cooperation_history):
    # t: current round (1-based)
    # r: total rounds
    # m: threshold
    # n: total players
    # observed_cooperators_last_round: integer count of cooperators last round
    # self_cooperated_last_round: boolean
    # cooperation_history: list of counts of cooperators from previous rounds

    if t == 1:
        # First round: cooperate to set cooperative norm
        return 'C'

    elif t < r:
        # not last round

        # Check last round cooperation count
        last_c = observed_cooperators_last_round

        # Forgiveness: check if cooperation failed once after success
        prior_c = cooperation_history[-2] if len(cooperation_history) >= 2 else None

        if last_c >= m:
            # Cooperation threshold met: cooperate
            return 'C'

        elif last_c >= m - 1:
            # Almost met threshold
            if self_cooperated_last_round:
                # Forgive slight failures
                return 'C'
            else:
                # Punish defectors that didn't cooperate previously
                return 'D'

        else:
            # Cooperation failed badly
            # Punish by defecting
            if t == r - 1:
                # Penultimate round: anticipate last round defection, defect early
                return 'D'
            else:
                return 'D'

    else:
        # Last round (t == r)
        last_c = observed_cooperators_last_round
        if last_c >= m:
            # Cooperate to gain final reward
            return 'C'
        else:
            # Risk of exploitation too high, defect
            return 'D'
```

---

## Explanation

- **Cooperation triggers:** Cooperate expecting others to do the same if past rounds met threshold.
- **Tolerance:** Forgives an occasional near threshold failure to prevent endless retaliation cycles.
- **Punishment:** Defects if cooperation level too low to conserve resources.
- **Endgame behavior:** Recognizes standard repeated game endgame defection incentive and adapts accordingly.
- **Simplicity:** Relies only on observable quantities, no communication, no complicated belief models.
- **Reciprocity:** Mirrors and reinforces observed group behavior, thus promoting cooperation.

---

## Summary

| Round          | Condition                                           | Action          | Reason                         |
|----------------|----------------------------------------------------|-----------------|-------------------------------|
| 1              | Initial round                                       | Cooperate (C)   | Signal cooperative intent      |
| 2 to r-2       | Last round cooperators \( \ge m \)                 | Cooperate (C)   | Maintain cooperation           |
| 2 to r-2       | Last round cooperators \( = m-1 \), self cooperated last round | Cooperate (C)   | Forgiveness                   |
| 2 to r-2       | Last round cooperators \( = m-1 \), self defected last round   | Defect (D)      | Punish defectors               |
| 2 to r-2       | Last round cooperators \( < m-1 \)                  | Defect (D)      | Punish, conserve resources     |
| \( r-1 \)      | Low cooperation last round                          | Defect (D)      | Anticipate last round defection|
| \( r \) (last) | Last round cooperators \( \ge m \)                 | Cooperate (C)   | Gain reward                    |
| \( r \) (last) | Last round cooperators \( < m \)                   | Defect (D)      | Avoid exploitation             |

---

This strategy is explicitly cooperative: it starts by cooperating, tries to maintain cooperation if the group cooperates, forgives minor cooperation failures, and punishes defectors to incentivize cooperation, while gracefully handling the last round defection incentives.

---

If you want, I can also help design complementary strategies or variants that incorporate probabilistic cooperation or more sophisticated learning, but the above is a robust simple cooperative baseline.
'''

description_COOPERATIVE_121 = '''
Below is a cooperative strategy tailored to the Collective Risk Dilemma repeated game that emphasizes stable cooperation, conditional trust, and an explicit plan for edge cases.

---

## Strategy Overview

The core idea is to *start cooperatively*, *maintain cooperation as long as others do*, and *punish defection mildly* but *forgive quickly* to restore cooperation. The strategy exploits the repeated nature of the game and perfect observability to enforce cooperative norms and maximize joint payoffs.

---

## Parameters and Variables Used

- **n, r, m, k** – game parameters as given.
- **round t** – current round number in {1, ..., r}
- **coop_threshold = m** – minimum number of cooperators needed per round for reward.
- **history[t]** – for each previous round, a record of all players’ actions.
- **cooperators_count(t)** – number of players cooperating in round t.
- **my_index** – your player index in {1, ..., n}
- **defection_detected** – boolean flag indicating if defection observed last round.
- **forgiveness_rounds = 1** – number of rounds to punish defectors before forgiving (can be tuned).
- **punish_until = 0** – round number until which you punish defectors.

---

## Rationale

- **Start cooperating** because the cooperative equilibrium yields higher payoffs than universal defection.
- If cooperation threshold is reached regularly, all players do better than defecting alone.
- Punishment deters free-riding: if others defect, defect at least one round to reduce their incentive.
- Forgiveness ensures cooperation can be restored, avoiding endless defection wars.
- In the **last round**, defect to maximize immediate gain since there is no future punishment possible.
  
---

## Decision Rules

### Initial Round (t = 1)
- Cooperate (C) unconditionally (signal goodwill and encourage others).

### Intermediate Rounds (1 < t < r)
- Examine previous round’s actions:
  - Count cooperators in last round, including self.
  - If a defection occurred and you were among cooperators (i.e., defection detected), and
    - Current round ≤ punish_until: defect (punishment phase).
    - Else cooperate.
  - If no defection detected last round, cooperate.
- If defection detected in last round and you are punishing, keep defecting until punish_until round.
- When punishment duration ends, return to cooperate to rebuild trust.

### Final Round (t = r)
- Defect (D) unconditionally (no future retaliation possible, maximize private payoff).

---

## Handling Edge Cases

- If the cooperation threshold (**m**) is never met in early rounds (e.g., first 2-3 rounds), you may consider switching to defect for few rounds to test if others follow.
- However, to maintain cooperation mindset, give several rounds chance before punishing.
- If others always defect, you will eventually defect too to avoid exploitation.
- If others cooperate, reciprocate cooperation consistently.

---

## Pseudocode

```python
def decide_action(t, history, my_index, n, r, m, k):
    punish_duration = 1  # punish for exactly one round
    global punish_until, defection_detected

    if t == 1:
        # First round: always cooperate
        return 'C'

    if t == r:
        # Last round: always defect
        return 'D'

    last_round_actions = history[t-1]
    cooperators_last = sum(1 for a in last_round_actions if a == 'C')
    my_last_action = last_round_actions[my_index - 1]

    # Detect if defection against cooperators happened last round
    # Defection detected if someone defected while enough cooperators were present to get reward
    defection_detected = any(a == 'D' for a in last_round_actions) and (cooperators_last >= m)

    if defection_detected:
        # If not already punishing, start punishment
        if punish_until < t:
            punish_until = t + punish_duration

    # Decide action: punish or cooperate
    if t <= punish_until:
        return 'D'  # Punishment round
    else:
        return 'C'  # Cooperate if no punishment ongoing
```

---

## Summary

- **Rounds 1 to r-1:** Cooperate unless punishing defections observed in previous round.
- **Last round:** Defect to maximize final payoff (standard backward induction reasoning).
- **Punishment:** Single-round defection to discourage free-riding.
- **Forgiveness:** Return to cooperation immediately after punishment.
- **Start cooperatively:** Signal trust from the beginning.
- **Respond to history:** Adjust to defections but favor cooperation renewal.

This strategy aligns with a cooperative mindset while maintaining a credible threat against free riders, leveraging the repeated structure and perfect monitoring.

---

If you want, I can suggest variants (e.g., longer punishment, gradual forgiveness, probabilistic cooperation), but this core is simple, principled, and cooperative.
'''

description_COOPERATIVE_122 = '''
Here is a cooperative strategy designed to promote reaching the cooperation threshold \( m \) each round while handling uncertainty and adapting to opponents’ observed behaviour. The goal is sustained collective cooperation to maximize payoffs for all.

---

## Strategy Overview: Conditional Reciprocity with Coordinated Cooperation

**Core Idea:**  
Start by cooperating to signal willingness to cooperate. Then use past-round observations to estimate the number of cooperators and adjust cooperation accordingly, aiming to sustain \( m \) or more cooperators each round. Near the end of the game, maintain cooperation to maximize total reward. If cooperation fails to emerge, cautiously defect to avoid repeated exploitation.

---

## Detailed Decision Rules

Let \( R \) be total rounds and \( t \) current round.

Let \( C_t \) be the observed number of cooperators in round \( t \) (including self).

---

### Round 1 (Initial Signaling)

- **Action:** Cooperate (C)  
- **Rationale:** Signal cooperative intent and baseline trust. Without prior info, cooperation encourages others to cooperate.

---

### Rounds 2 through \( R-1 \) (Adaptive Cooperation)

- **Observe:** Number of cooperators \( C_{t-1} \) in previous round.

- **Decision:**

  1. **If \( C_{t-1} \geq m \):**  
     - Continue cooperating (C)  
     - *Reason:* Threshold was met; cooperation profitable.

  2. **If \( C_{t-1} < m \):**

     - Check if cooperation failed by a small margin:  
       - If \( C_{t-1} = m-1 \) or \( m-2 \) (near threshold):  
         - Cooperate to try pushing over the threshold (C)  
         - *Reason:* Encourages recovery of cooperation.

     - Else (substantially below threshold):  
       - Defect (D)  
       - *Reason:* Avoid being exploited if cooperation not reciprocated.

- **Exception:**

  - If defected in previous round due to low cooperation, but in last two rounds cooperation improved, return to cooperate as a goodwill reset.

---

### Round \( R \) (Final Round)

- **Action:** Cooperate (C) regardless of prior outcomes.

- **Rationale:** No future retaliation possible; cooperating maximizes collective payoff.

---

## Edge Case Handling

- **If single round game (r=1):**  
  Cooperate to maximize chance of threshold and reward.

- **If \( m \) or \( k \) parameters unknown:**  
  Not applicable—parameters are known by common knowledge.

- **If observations inconsistent (e.g., ties or ambiguous counts):**  
  Use majority or worst-case scenario (treat as below threshold).

---

## Pseudocode for Round \( t \)

```python
def choose_action(t, R, m, k, C_prev, defected_last_round, cooperation_trend):
    if t == 1:
        return 'C'
        
    elif t == R:
        return 'C'
        
    else:
        if C_prev >= m:
            return 'C'
        
        elif C_prev >= m - 2:
            return 'C'
        
        else:
            if defected_last_round:
                # Check if cooperation trend is improving
                if cooperation_trend[-2:] == ['improve', 'improve']:
                    return 'C'  # forgiving return to cooperation
                else:
                    return 'D'
            else:
                return 'D'
```

- `C_prev`: Number of cooperators observed last round.  
- `defected_last_round`: Boolean, if player defected last round due to low cooperation.  
- `cooperation_trend`: A record of recent rounds indicating if cooperation increased/decreased.

---

## Why This Is Cooperative?

- Starts and ends cooperating, maximizing collective reward.
- Encourages threshold cooperation by conditional cooperation.
- Uses simple, transparent contingent reciprocity promoting stable cooperation.
- Forgives after defection if cooperation improves, preventing permanent grudges.
- Avoids being exploited by defecting when widespread defection occurs.

---

## Summary

| Condition                    | Action      | Reason                                      |
|-----------------------------|-------------|---------------------------------------------|
| Round 1                     | Cooperate   | Signal cooperation                          |
| \( 2 \leq t < R \), \( C_{t-1} \geq m \)              | Cooperate   | Threshold met, sustain cooperation          |
| \( 2 \leq t < R \), \( C_{t-1} = m-1 \) or \( m-2 \) | Cooperate   | Push to meet threshold                       |
| \( 2 \leq t < R \), \( C_{t-1} < m-2 \), defected last round but cooperation improving | Cooperate | Forgive                                        |
| \( 2 \leq t < R \), \( C_{t-1} < m-2 \), otherwise      | Defect      | Avoid exploitation                            |
| Round \( R \)                | Cooperate   | Maximize final round payoff                  |

---

This strategy balances optimism, conditional cooperation, and prudence to foster cooperation in the Collective Risk Dilemma tournament.
'''

description_COOPERATIVE_123 = '''
Below is a cooperative strategy for the Collective Risk Dilemma (CRD) that aims to reliably reach and maintain the cooperation threshold \( m \) each round, maximizing collective and individual payoffs, while safeguarding against free-riders.

---

## Cooperative Strategy: **Threshold-Responsive Conditional Cooperation**

### Intuition
- The minimum \( m \) cooperators are needed each round to unlock the reward \( k \).
- Cooperating costs 1 unit; defecting costs nothing.
- If enough cooperate, everyone gets bonus \( k \), and defectors get better payoff by free-riding.
- To sustain cooperation in repeated rounds without communication, use observed past actions to coordinate.
- If cooperation falters, respond by defecting to avoid exploitation.
- Return to cooperation once others also show cooperative tendencies.

---

### Strategy Description

#### Parameters Known to All:

- \( n \) = number of players
- \( r \) = rounds
- \( m \) = minimum cooperators for reward
- \( k \) = reward factor

---

### 1. Initialization (Round 1):

- **Cooperate** on Round 1 to signal willingness to cooperate.
- Why? No history yet, making the first move cooperative establishes a cooperative baseline and encourages reciprocation.

---

### 2. From Round 2 to Round \( r-1 \): Conditional Cooperation Based on Last Round

- **Observe:** How many players cooperated in the previous round (\( c_{prev} \)).

- **Decision rules:**

  | Case                       | Action           | Reasoning                                                 |
  |----------------------------|------------------|-----------------------------------------------------------|
  | \( c_{prev} \geq m \)      | Cooperate        | Cooperation threshold was met, so reward unlocked. Maintain cooperation to secure reward next round. |
  | \( c_{prev} < m \) and your own action was C last round | Defect if your own cooperation likely wasted | Avoid repeated cost when threshold not met; others not cooperating enough. |
  | \( c_{prev} < m \) and your own action was D last round | Defect         | Others also defecting or cooperating insufficiently: continue defect to avoid loss. Relax cooperation until threshold likely achievable again. |

- **Explanation:**
  - If the group met cooperation threshold in last round, keep cooperating.
  - If threshold not met, punish by defecting to prevent being exploited.
  - This "trigger" style prevents chronic free-riders without communication.

---

### 3. The Last Round (\( t = r \)):

- **Defect**
  
- Reasoning: No future rounds to punish defectors, so defect to maximize last-round payoff.

---

### 4. Handling Edge Cases & Noise

- **Noise / accidental defection** possibility: Assume perfect observation, so no noise.
- **Partial cooperation near threshold:** Even if the number of cooperators is \( \geq m \), if you notice repeated borderline cases (e.g., exactly \( m \) cooperators and you are one of them), continue cooperating to sustain threshold.

---

### 5. Summary of Round-by-Round Behavior

| Round     | Condition                           | Action     |
|-----------|-----------------------------------|------------|
| 1         | No history                        | Cooperate  |
| 2 to r-1  | \( c_{prev} \geq m \)              | Cooperate  |
| 2 to r-1  | \( c_{prev} < m \) and you cooperated prev round | Defect     |
| 2 to r-1  | \( c_{prev} < m \) and you defected prev round  | Defect     |
| r (last)  | Any                              | Defect     |

---

## Pseudocode

```python
def decide_action(round_t, history, n, r, m):
    """
    round_t: current round (1-based)
    history: list of tuples (actions_round), where actions_round is list of actions by players in round t-1
    n, r, m: game parameters
    
    Returns: "C" for cooperate, "D" for defect
    """
    
    # Round 1: cooperate
    if round_t == 1:
        return "C"
    
    # Last round: defect
    if round_t == r:
        return "D"
    
    # Count how many cooperated last round
    last_round_actions = history[-1]    # list of 'C' or 'D' actions for round_t-1
    c_prev = sum(1 for a in last_round_actions if a == "C")
    
    # Get own last action
    own_last_action = last_round_actions[self_index]  # assuming self_index known
    
    if c_prev >= m:
        # Cooperation threshold met last round - cooperate
        return "C"
    else:
        # Threshold not met last round - defect to avoid exploitation
        return "D"
```

---

## Why This Is Cooperatively Aligned

- Starts by cooperating to build trust.
- Cooperates as long as others do, sustaining the collective reward.
- Defects only if threshold fails, avoiding exploitation.
- Defects in last round for reward maximization since no future cooperation.
- Simple, clear conditional rules easy for other cooperative LLM strategies to detect and align with.

---

## Optional Enhancements (if allowed by tournament)

- Track cooperation levels over multiple previous rounds to tolerate one-off defection.
- Implement gradual forgiveness by occasional cooperation after defections if threshold improved.
- Signal to try and coordinate just enough cooperation (exactly \( m \)) to maximize defectors’ payoffs too.

But the provided strategy is straightforward and aligns well with cooperation goals in repeated CRD.
'''

description_COOPERATIVE_124 = '''
Below is a carefully designed cooperative strategy for the Collective Risk Dilemma that aims to secure the group reward by encouraging cooperation, while also protecting against exploitative defection. The strategy leverages repeated interaction and perfect information to coordinate with similarly cooperative opponents.

---

# **Cooperative Strategy: Conditional Conditional Cooperation with Forgiveness**

---

## Intuition:

- **Goal:** Ensure at least *m* players cooperate each round to secure reward *k* for all.
- **Challenge:** Avoid exploitation by defectors, especially near the last round where cooperation incentives vanish.
- **Approach:** 
  - Start by cooperating to signal cooperative intent.
  - Cooperate only if prior rounds show sufficient cooperation to ensure reward.
  - Defect if cooperation was insufficient in previous rounds (retaliation).
  - Forgive occasional defection allowing recovery of cooperation.
  - Gradually relax cooperation in the final round(s) where the incentive to cooperate disappears.

---

## Detailed Description

### Parameters and Variables:

- Known parameters: n, r, m, k
- Internal state per round t ∈ {1,...,r}:
  - \( C_t \subseteq \{1,...,n\} \): set of players who cooperated in round t
  - \( c_i^t \): whether player i cooperated (1) or defected (0) in round t
- Own index: i
- History available after each round: actions of all players and payoffs

---

### Decision Rules:

For round \( t \):

1. **Round 1: Initial Cooperation**
   - Cooperate: \( c_i^1 = C \)
   - Rationale: Signal cooperative intention to others to build cooperation baseline.

2. **Rounds 2 to \( r-1 \): Conditional Cooperation**

   - Calculate how many cooperated last round:  
     \( |C_{t-1}| \)

   - If \( |C_{t-1}| \ge m \) (threshold met last round), **cooperate** this round.  
     *Reason:* Last round reward was achieved; cooperation payoff beneficial.

   - Else, if \( |C_{t-1}| < m \) (threshold not met), **defect** this round.  
     *Reason:* Punish insufficient cooperation.

   - **Forgiveness clause:** To prevent cycling defection, allow cooperation again if threshold met in any of the last two rounds.

     More precisely:  
     If \( t \ge 3 \) and ( \( |C_{t-1}| < m \) but \( |C_{t-2}| \ge m \) ), cooperate to try restoring cooperation.

3. **Last Round \( t = r \): Defect**

   - Defect regardless of history.  
   - Reason: game ends here, no repeated incentive; last-round defection is dominant strategy to secure private payoff.

---

### Summary of Cooperation Conditions per Round:

| Round \( t \) | Condition to Cooperate                | Otherwise Defect                |
|---------------|-------------------------------------|--------------------------------|
| \( t=1 \)     | Always cooperate                    | —                              |
| \( 1 < t < r \) | If \( |C_{t-1}| \ge m \), OR \( (|C_{t-1}| < m \) AND \( |C_{t-2}| \ge m) \) (for \( t \ge 3 \)) | Otherwise |
| \( t=r \)     | Never cooperate                    | Always defect                  |

---

## Edge Case Handling

- **Very first round (t=1):** No history → cooperate to establish trust.
- **Second round (t=2):** Only one past round → cooperate if last round met threshold; else defect.
- **Third round onwards (t≥3):** Use forgiveness clause to repair cooperation.
- **Last round (t=r):** Defect, capturing private payoff (no incentive to cooperate as game ends).
- **If m is close to n (e.g., m = n-1):** Strategy still applies; cooperating only if community cooperation was sufficient previously.
- **If k is just above 1 (i.e., small reward):** Strategy still applies, but incentives to cooperate are weaker.
- **No communication:** Coordination only via actions and payoffs observed.

---

## Pseudocode

```python
def choose_action(t, history, params):
    """
    t: current round (1-based)
    history: list of round info, each element is dict:
             {'actions': [C/D for each player], 'num_cooperators': int}
    params: dict with keys n, r, m, k
    Returns: 'C' or 'D'
    """
    n, r, m, k = params['n'], params['r'], params['m'], params['k']

    if t == 1:
        return 'C'  # Start cooperative

    if t == r:
        return 'D'  # Last round defection

    # For rounds 2 to r-1:
    last_round_cooperators = history[t-2]['num_cooperators']  # t-2 because history indexed from 0

    if last_round_cooperators >= m:
        return 'C'  # Reward met last round, cooperate

    # Forgiveness clause for t >= 3
    if t >= 3:
        prev_prev_round_cooperators = history[t-3]['num_cooperators']
        if prev_prev_round_cooperators >= m:
            return 'C'  # Forgive: cooperation recently met

    return 'D'  # Otherwise defect
```

---

## Why this works:

- **Encourages cooperation:** Starting with cooperation and cooperating whenever reward was met last round maintains group reward.
- **Punishes defection:** If cooperation fails, players defect to punish until cooperation threshold restored.
- **Prevents endless defection cycles:** Forgiveness clause allows recovery from mistakes or occasional defection.
- **Rational last round defection:** Defect last round to maximize private payoff.
- **Aligned incentives:** Maximizing total payoff over repeated rounds favors cooperation if others do too.

---

## Optional enhancements (implementation detail):

- Implement tolerant thresholds (e.g., accept cooperation if near \( m \)) to allow some noise.
- Track individual cooperation patterns to target punishment more precisely.
- Adapt forgiveness timing based on observed frequency of cooperation failures.

---

# **Summary**

This simple yet robust cooperative strategy balances conditional cooperation with strategic defection and forgiveness. It is explicitly designed to maintain the group threshold cooperations most rounds, thereby maximizing the collective and individual payoffs, while rationally defecting in the last round to maximize private gain. It assumes no communication and relies solely on observable actions and payoffs consistent with the game's perfect information and repeated interaction structure.
'''

description_COOPERATIVE_125 = '''
**Strategy Name:** Conditional Tit-for-Threshold (CTfT)

---

### Intuition & Overview

This strategy aims to foster cooperation by starting cooperatively, then conditionally cooperating based on observed history, specifically tracking whether the group met the minimum cooperation threshold **m** in previous rounds. It leverages perfect information and repeated game structure to sustain cooperation, but also guards against exploitation by defectors.

---

### Key Characteristics

- **Start cooperative:** Cooperate in round 1 to signal goodwill.
- **Conditional cooperation:** Cooperate in subsequent rounds only if the cooperation threshold **m** was met in the previous round.
- **Retaliation:** If fewer than **m** cooperators appeared in the previous round, defect to avoid consistent unilateral cooperation.
- **Last round behavior:** Cooperate in the final round if cooperation threshold was met in the penultimate round (to maintain goodwill and maximize joint payoff), otherwise defect knowing no future punishment/reward is possible.
- **Forgiveness:** If defected and then threshold met again, return to cooperation immediately.
- **No retaliation beyond one round:** Does not persist in defecting if cooperation resumes to avoid spiral of defection.

---

### Rationale

- Starting with cooperation helps signal cooperative intent.
- Conditioning cooperation on collective action leverages the public observability and common knowledge.
- Retaliating only one round prevents a permanent breakdown of cooperation.
- Rewarding threshold achievement ensures mutual incentives; defectors get lower payoffs long-term as cooperation leads to higher rewards (e.g., in example 3, defectors do better only when cooperation threshold is met—sustained cooperation maximizes everyone's payoff).
- Last round defect risk (endgame effect) minimized by cooperating if group was cooperative last round.

---

### Parameters to track per round:

- `round` = current round number (1 to r)
- `num_cooperators_prev` = number of players that played C in the last round, known due to perfect info
- `m` = minimum cooperators needed
- `r` = total rounds

---

### Decision rules pseudocode:

```python
def CTfT_action(round, num_cooperators_prev, m, r):
    # First round: always cooperate to establish cooperation
    if round == 1:
        return 'C'

    # For rounds 2 through r-1:
    if round < r:
        if num_cooperators_prev >= m:
            # Sufficient cooperation last round, cooperate again
            return 'C'
        else:
            # Cooperation threshold not met last round, defect
            return 'D'

    # Last round (round == r):
    # Cooperate only if cooperation threshold was met in (r-1)th round,
    # otherwise defect since no future rounds to enforce cooperation
    if num_cooperators_prev >= m:
        return 'C'
    else:
        return 'D'
```

---

### Summary in words:

- **Round 1:** Cooperate.
- **Round t ∈ {2, ..., r-1}:** If in round t-1 at least **m** players cooperated, cooperate; else defect.
- **Round r:** If cooperative threshold met in round r-1, cooperate; else defect.

---

### Edge cases & considerations:

- **If threshold m is very close to n (e.g., m = n-1):** This strategy still applies, will conditionally cooperate only if most players cooperate.
- **If opponents never cooperate:** The strategy will defect after round 1 to avoid continual loss (payoff 0 instead of 1).
- **If cooperation fluctuates:** This strategy quickly adapts between cooperating and defecting to match group dynamics, always incentivizing pushing cooperation above threshold.
- **No communication:** Uses only observed actions, no signals or conventions needed.
- **Memory requirement:** Only need to track cooperation count from previous round; minimal memory footprint.

---

### Cooperative alignment

- This strategy actively promotes reaching and maintaining the critical mass **m** to maximize collective payout.
- It respects and enforces the collective norm by punishing lack of cooperation.
- Its forgiving nature after defection allows recovery rather than permanent breakdown.
- The first-round cooperation kickstarts coordination—critical to overcome initial risk.

---

This design balances cooperation and self-interest optimally given the game parameters and constraints. It should perform robustly in the tournament against independent LLM-based opponents.
'''

description_COOPERATIVE_126 = '''
Here is a cooperative strategy for the Collective Risk Dilemma game that aims to reliably reach or exceed the cooperation threshold \( m \) each round and maintain that cooperation throughout the \( r \) rounds.

---

## Strategy: Conditional Reciprocity with Forgiveness and Endgame Cooperation

### Key Idea

- **Start cooperatively** to signal willingness to contribute.
- **Monitor the number of cooperators each round** to estimate if the group is likely to reach the threshold.
- **Continue cooperating if cooperation threshold met or nearly met**; otherwise, temporarily defect to punish defectors and signal willingness to resume cooperation once others return.
- **Use forgiveness to avoid collapse into all-defect**.
- **In the last round, cooperate regardless** to maximize final rewards and avoid the risk of losing endgame gains.

---

### Detailed Decision Rules

Let:
- \( t \in \{1, \dots, r\} \) be the round number.
- \( C_{t-1} \) be the number of cooperators observed in the previous round (for \( t > 1 \)).
- \( \theta \) be a cooperation threshold margin to allow for some slippage; use \( \theta = 0 \) or \( \theta = 1 \) (meaning you tolerate one less cooperator than \( m \) to continue cooperating).
- \( \text{ForgivenessRounds} \) be the number of rounds you tolerate a failure to reach threshold before you severely punish or defect longer; can be set to 1 or 2.

---

### Round 1 (Initialization)

- **Action**: Cooperate
- Rationale: Signal good faith and willingness to produce the public good.

---

### Rounds 2 to \( r-1 \)

1. Observe how many players cooperated in round \( t-1 \), call it \( C_{t-1} \).
2. If \( C_{t-1} \geq m - \theta \) (cooperation threshold met or nearly met):
   - Cooperate this round.
3. If \( C_{t-1} < m - \theta \) (significant drop in cooperation):
   - Defect this round to punish defectors and conserve your endowment.
   - Begin counting how many rounds cooperation has been below threshold (failure count).
4. If failure count exceeds ForgivenessRounds:
   - Resume cooperation to attempt re-building cooperation.
   - Reset failure count.

---

### Round \( r \) (Final Round)

- Cooperate regardless of history.
- Rationale: No incentive to defect since the game ends; cooperating may yield higher end payoff and avoid mutual loss.

---

## Pseudocode

```python
# Parameters given by game:
# n, r, m, k

theta = 1             # Margin allowed below m to still cooperate
ForgivenessRounds = 2 # Number of rounds to punish before forgiving

failure_count = 0     # counts consecutive rounds below threshold

for t in 1 to r:
    if t == 1:
        action = C  # Cooperate in round 1
    elif t == r:
        action = C  # Always cooperate in last round
    else:
        # Observe number of cooperators in previous round
        prev_cooperators = observed_cooperators(t-1)

        if prev_cooperators >= m - theta:
            action = C
            failure_count = 0  # reset failure count on good cooperation
        else:
            failure_count += 1
            if failure_count > ForgivenessRounds:
                action = C  # forgive after punishment window
                failure_count = 0
            else:
                action = D
```

---

## Discussion

- **Cooperative stance**: Starts with cooperation and tries to maintain it.
- **Conditional cooperation**: Acts cooperatively only when others do; punishes defection mildly by defecting temporarily.
- **Forgiveness**: Does not permanently defect; allows for cooperation to resume, preventing deadlocks.
- **Endgame cooperation**: Cooperates in last round where defection cannot be punished, ensuring maximal reward.
- **Adaptive**: Reads opponent behavior from previous round’s cooperation level to inform next move.
- **Stable equilibrium**: If all players follow this strategy, mutual cooperation at or near threshold will be sustained.

---

This strategy balances cooperation and self-protection through conditional reciprocity and forgiveness to maximize collective and individual payoffs in the repeated collective risk dilemma.
'''

description_COOPERATIVE_127 = '''
Below is a cooperative strategy designed to achieve and maintain at least the threshold number of cooperators \(m\) each round, maximizing collective rewards across the repeated game.

---

### Strategy Name: Conditional Gradual Cooperation (CGC)

---

### Intuition:
- The best collective outcome is to get at least \(m\) players cooperating each round, so all earn \(1 - 1 + k = k\) or more.
- Cooperating from the start signals willingness to cooperate.
- Condition cooperation on others’ past behavior to maintain cooperation and avoid exploitation.
- Use a forgiving policy to return to cooperation when others resume cooperating.
- Defect only as a last resort if cooperation fails repeatedly.
- On the last round, cooperate to maximize joint reward since no future retaliation possible.

---

### Decision Rules

#### Parameters:
- \(n, r, m, k\) as given.
- Maintain an internal **cooperation tracker vector** of length \(n\): records each player’s last round action known.
- Define a **cooperation threshold percentage**: e.g., require at least \(m\) cooperators last round.
- Define a **forgiveness window**: number of rounds you tolerate defections before defecting (e.g., 1 round).
- Define **round counter** \(t\) from 1 to \(r\).

---

### Full Decision Algorithm:

```pseudo
Initialize:
  For all players j ∈ {1,...,n}, set cooperation_tracker[j] ← true  # assume cooperation before round 1
  forgiveness_counter ← 0

For each round t in 1 to r:
  
  # Special case: last round
  If t == r:
    Play C
    Continue to next iteration (end)

  # Count cooperators last round (excluding self)
  coop_others = Count of players j ≠ self where cooperation_tracker[j] == C_last_round

  # Own last action
  my_last_action = self's action in round t-1 (if t > 1), else None

  # 1. First round special case
  If t == 1:
    Play C  # Signal cooperation from start
    Continue to next iteration

  # 2. If sufficient cooperators last round (≥ m)
  If coop_others + (my_last_action == C ? 1 : 0) >= m:
    Play C
    forgiveness_counter ← 0  # reset forgiveness
    Continue to next iteration

  # 3. If cooperation fell below threshold last round
  Else:
    # If defectors have persisted tolerably, remain cooperative (forgive once)
    If forgiveness_counter < forgiveness_window:
      Play C
      forgiveness_counter ← forgiveness_counter + 1
      Continue

    # Otherwise, defect to punish non-cooperation
    Else:
      Play D
      Continue

  # 4. Update cooperation_tracker with observed actions at end of round
  # This happens outside the decision step; keep accuracy.

```

---

### Explanation:

- **Round 1:** Cooperate immediately to send a strong signal of cooperation.

- **Rounds 2 to r-1:**  
  - Continue cooperating if enough (≥ m) cooperators last round (including self).
  - If cooperation dropped below \(m\), allow one round of forgiveness—keep cooperating once ignoring a cooperation drop—to prevent knee-jerk defection cascades.
  - If still below \(m\) after forgiveness round, defect to punish and encourage return to cooperation.
  
- **Round r (last round):** Always cooperate, since no future punishment or reward impacts behavior; cooperating maximizes final payoff.

---

### Handling Edge Cases

- **If uncertain of others’ actions in round 1:** Assume cooperation to start.
- **If exact number of cooperators unknown:** The design assumes perfect observing ability (perfect info) per problem statement.
- **If a player defects in last round:** Ignore, since no future rounds.
- **If forgiveness exploited repeatedly:** Strategy defects, punishing persistent defectors.
- **In small groups or borderline \(m\) values:** Forgiveness window can be tuned (e.g. 0 or 2).

---

### Summary

This strategy embodies a cooperative mindset by:

- Initiating and sustaining cooperation whenever it statistically leads to joint benefit.
- Applying limited and reasoned forgiveness to avoid breakdowns from occasional defections.
- Employing punitive defection only when cooperation is clearly not reciprocated.
- Cooperating always on the final round to maximize collective payoff without fear of exploitation.

By doing so, it encourages stable cooperation among rational players repeatedly interacting, balancing optimism and caution.

---

If you want, I can also provide a detailed worked example or variations for different parameter values.
'''

description_COOPERATIVE_128 = '''
**Strategy Name:** Conditional Cooperative Partner (CCP)

---

### Overview

This strategy is designed to foster cooperation efficiently and maintain it through the repeated rounds by:

- **Starting cooperatively** to signal willingness to cooperate.
- **Conditionally cooperating thereafter** only if enough cooperation was observed previously, ensuring trustworthiness.
- **Defecting if cooperation drops below threshold**, to avoid exploitation.
- **Attempting final round cooperation** to boost collective payoff and maximize gains.
  
This approach balances cooperation with caution, maximizing collective benefits while guarding against free-riders.

---

### Decision Rules

---

#### Initialization (Before Round 1)

- Record:  
  - `round = 1`  
  - `history = []` (to store previous rounds' full action profiles)  
  - Know parameters: `n`, `r`, `m`, `k`.

---

#### Round 1

- **Always Cooperate.**  
  Rationale: Establish cooperative intent and signal willingness to contribute to the community project.

---

#### Round t (2 ≤ t < r)

- Compute `prev_cooperators` = number of players who played C in round t-1 (from history).

- If `prev_cooperators ≥ m` (threshold met last round):  
  - **Cooperate.**  
  Rationale: The group cooperated sufficiently last round, so reciprocate to sustain cooperation.

- Else:  
  - **Defect.**  
  Rationale: Cooperation failed last round, defect to avoid exploitation until cooperation regained.

---

#### Final Round (t = r)

- Regardless of previous outcomes:  
  - **Cooperate if average cooperators over last 3 rounds ≥ m (or all rounds if r < 3).**  
  - Else, **Defect**.

**Rationale:**  
In the last round, there's no future punishment possible. However, cooperating can increase the final round payoff if enough players do so. Use recent cooperation history to decide whether to risk cooperating.

---

### Additional Edge Case Handling

1. **If `r` is very small (e.g., r=2):**  
   - Cooperate round 1 as usual.  
   - In round 2, cooperate only if cooperation in round 1 met threshold; else defect.

2. **If the number of observed cooperators oscillates around m:**

   - Use **majority vote over last 2 rounds** (or all previous rounds if fewer than 2) to decide cooperation in next round.  
   - This smooths out one-off defection spikes.

3. **If all players defect in round 1:**  
   - Immediately defect all subsequent rounds.  
   - Rationale: No initial cooperation signal, so no incentive to cooperate.

4. **If detecting persistent defection (fewer than m cooperators for 3 consecutive rounds):**  
   - Permanently defect remaining rounds.

---

### Pseudocode

```python
def CCP_decision(round, history, n, r, m, k):
    # history is a list of lists: each inner list is actions ['C' or 'D'] for all n players in that round
    # self assumed to be player i

    if round == 1:
        return 'C'  # Always start cooperating

    prev_round = history[-1]
    prev_cooperators = sum(1 for a in prev_round if a == 'C')

    if round == r:
        # Calculate average cooperators over last min(3, round-1) rounds
        lookback = min(3, len(history))
        recent_cooperator_counts = [sum(1 for a in history[-i] if a == 'C') for i in range(1, lookback + 1)]
        avg_cooperators = sum(recent_cooperator_counts) / lookback

        if avg_cooperators >= m:
            return 'C'  # cooperate in final round if recent cooperation was sufficient
        else:
            return 'D'  # defect otherwise

    # For middle rounds: Check if previous round met cooperation threshold
    # Also check for persistent defection (3 consecutive rounds low cooperation)
    low_coop_streak = 0
    for past_round in history[-3:]:
        if sum(1 for a in past_round if a == 'C') < m:
            low_coop_streak += 1

    if low_coop_streak == 3:
        return 'D'  # persistent defection detected, defect to avoid loss

    if prev_cooperators >= m:
        return 'C'  # reciprocate cooperation
    else:
        return 'D'  # defect if cooperation dropped last round
```

---

### Cooperative Mindset Justification

- **Starts cooperatively, signaling good faith.**

- **Only defects reactively if group cooperation falls below threshold**, protecting from exploitation but reverting to cooperation when trust restored.

- **Encourages sustained collective risk reduction**, by rewarding periods of strong cooperation.

- **Tries to maximize collective payoffs also in final round**, showing commitment to group benefit.

---

### Summary

| Round Condition                | Action           | Reason                           |
|-------------------------------|------------------|---------------------------------|
| Round 1                       | Cooperate (C)    | Signal goodwill                 |
| Rounds 2 to r-1               | Cooperate if previous round's cooperation ≥ m; else defect | Reward cooperation, punish defectors |
| Last round (round r)          | Cooperate if recent average cooperation ≥ m; else defect | Maximize final collective payoff   |
| Persistent defection detected (3 rounds consecutively < m cooperators) | Defect for rest of the game | Avoid exploitation               |

---

This strategy is **simple**, **clear**, and **strongly cooperative** yet **not exploitable**, making it well-suited for a tournament against unknown independently generated LLM strategies.
'''

description_AGGRESSIVE_65 = '''
Here is an aggressive strategy designed for the Collective Risk Dilemma as specified:

---

### Strategy Name: Aggressive Threshold Enforcer (ATE)

---

### Key Principles

1. **Aggressive definition:**  
   The strategy aims to maximize its own payoffs aggressively by exploiting cooperators when possible, but also ensures the collective threshold `m` is met (to claim the reward `k`) **only when it is beneficial to itself**.  
   
2. **Aggressive enforcement of threshold:**  
   The player will lean towards defecting to earn the private endowment unless it is **necessary and profitable** to cooperate to ensure the threshold—thus avoiding wasted cooperation.

3. **Punitive approach:**  
   If others cooperate sufficiently, the strategy exploits these cooperators by defecting to gain a higher payoff. If cooperation falls below threshold, the strategy punishes by defecting and not subsidizing wasted cooperation.

4. **Edge cases handling:**  
   Manipulates the first and last rounds to maximize payoffs and enforce reputation signals during the game.

---

### Decision Rules

**Variables tracked each round _t_:**

- `C_t-1` = Number of players who cooperated in previous round (t-1). For t=1, this is undefined.
- `my_action_t-1` = This player's previous round action.
- `r` = Number of total rounds.
- `t` = Current round index ∈ [1,...,r]
- `m` = Threshold minimum cooperators required.
- `n` = Number of players.
- `k` = Reward multiplier.

---

### Strategy Outline

**Round 1 (t=1): Be daring, cooperate to set expectation**

- Cooperate in round 1.
- Objective: Signal willingness to cooperate, test if threshold can be reached, and force others to respond.

---

**Rounds 2 to r-1: Exploit or enforce threshold based on prior**

- Observe `C_t-1` (number of cooperators last round).

- Case A: Last round met threshold (`C_t-1 ≥ m`):

  - **Exploit:** Defect this round to gain private endowment + reward if others cooperate again.
  - Rationale: Others pay cost of cooperation; you gain more by defecting while threshold is met.
  
- Case B: Last round did **not** meet threshold (`C_t-1 < m`):

  - If `C_t-1` close to threshold (`C_t-1 == m-1`):

    - **Cooperate (C)** this round to push group over threshold.
    - Rationale: Reward `k` > cooperation cost (1), so cooperating here can yield better future payoffs if others step up.

  - Else (`C_t-1 < m-1`):

    - **Defect (D)** to avoid wasting cooperation.
    - Rationale: Cooperation unlikely to produce reward; preserve private endowment.

---

**Round r (last round): Defect**

- Always defect final round to maximize private gains.
- Rationale: No future repercussions, maximize personal payoff.

---

### Summary Table of Actions:

| Condition on round t | Condition on last round cooperators `C_t-1` | Action                  |
|---------------------|----------------------------------------------|-------------------------|
| t = 1               | -                                            | Cooperate (C)           |
| 2 ≤ t ≤ r-1         | `C_t-1 ≥ m`                                  | Defect (D)              |
| 2 ≤ t ≤ r-1         | `C_t-1 = m-1`                                | Cooperate (C)           |
| 2 ≤ t ≤ r-1         | `C_t-1 < m-1`                                | Defect (D)              |
| t = r               | -                                            | Defect (D)              |

---

### Pseudocode Representation

```python
def aggressive_threshold_enforcer(t, r, m, n, k, last_round_cooperators):
    if t == 1:
        # Round 1: signal cooperation
        return 'C'
    
    elif t == r:
        # Last round: defect to maximize private payoff
        return 'D'
    
    else:
        # Intermediate rounds
        if last_round_cooperators >= m:
            # Threshold met, exploit cooperators
            return 'D'
        
        elif last_round_cooperators == m - 1:
            # One short of threshold, cooperate to push threshold
            return 'C'
        
        else:
            # Cooperation unlikely to pay off, defect
            return 'D'
```

---

### Rationale and Aggression Justification

- **Exploitation:** Defects when others maintain threshold cooperation, demanding 'free rides' on cooperators' costs.
- **Threshold enforcement:** Will only cooperate if *absolutely necessary* to reach threshold, avoiding cooperative waste.
- **Last round defection:** No concern about retaliation, maximizing personal payoff.
- **Initial cooperation:** Forces initial test of cooperation viability and builds data on others' behavior.
- **Punishment implied:** Defecting when threshold is unmet punishes inefficient cooperation, discouraging costly altruism.

---

This strategy will punish naive cooperators, exploit responders, and only expend costly cooperation when it is very close to hitting the group threshold. Its aggressive nature lies in selective cooperation combined with exploitation of others' efforts.
'''

description_AGGRESSIVE_66 = '''
**Aggressive Strategy for Collective Risk Dilemma**

---

### Strategy Overview

The aggressive mindset here means:  
- Prioritize maximizing your own payoff aggressively.  
- Exploit cooperators whenever possible.  
- Defect unless forced by risk to cooperate at minimal levels selectively to avoid worst case payoffs.  
- Use information from past rounds to betray cooperators quickly and discontinue cooperation when not beneficial.  
- Take calculated risks of collective failure if it leads to higher payoffs for the individual.

---

### Key Intuition

- **Baseline payoff from defecting is 1 per round (no cost).**  
- **When the threshold (m) is met, defectors get (1 + k) > 1, cooperators get (0 + k) = k.**  
- **When threshold not met, cooperators lose their endowment (0 payoff), defectors get 1.**

Thus:  
- Defectors always do better than cooperators when the threshold is met (1+k vs k).  
- Cooperators only get higher payoff if enough cooperators exist to get the reward.  
- If threshold is not met, defectors stay at 1, cooperators lose payoff (0).  
- The aggressive strategy wants to leverage defectors' position and exploit cooperators but still cooperate just enough to collect the reward.

---

### Decision Rules

| Round          | Decision                                                       | Reasoning                                                                                         |
|----------------|----------------------------------------------------------------|--------------------------------------------------------------------------------------------------|
| **Round 1**    | **Defect (D)**                                                 | Test the field. Cooperate only if you estimate that many will cooperate (unlikely in round 1).   |
| **Subsequent rounds (t = 2 to r-1)**| Cooperate (C) only if (m-1) or more players cooperated in previous round, else Defect (D)| Trust minimal cooperation. Demand enough cooperators to reach threshold excluding self before cooperating. Exploit others otherwise. |
| **Last round (Round r)**| Defect (D) always                     | No future rounds to incentivize cooperation; maximize private payoff by defecting.                |

---

### Explanation / Aggressive Logic

- **Round 1 is probing:** Defect to see who risks cooperation (test cooperators).  
- **From round 2 onwards:** Cooperate *only if* enough others cooperated last round to meet threshold without your cooperation (m-1 or more cooperators). By cooperating only when threshold likely to be met anyway, you minimize your own cost and still share in the reward, while exploiting cooperators who are supporting threshold.  
- **If fewer than m-1 cooperators last round:** defect, siphon maximum payoff without risking contribution cost.  
- **Last round defecting:** No incentive to cooperate since no future punishment/future reward—always defect, maximize last round’s personal payoff.  
- This approach aggressively exploits cooperators, never “rescuing” the collective if it’s close but short, and defects whenever threshold unlikely.

---

### Pseudocode

```python
# Parameters: n, r, m, k
# History data structures:
#   coop_count_round[t]: number of cooperating players in round t, known at round t+1 start

for t in 1 to r:
    if t == 1:
        action = 'D'  # Defect round 1
    elif t == r:
        action = 'D'  # Defect last round aggressively
    else:
        # rounds 2 to r-1
        # Check cooperators in previous round (t-1)
        prev_coop = coop_count_round[t-1]

        if prev_coop >= m - 1:
            # Enough cooperators to meet threshold even if I cooperate
            action = 'C'
        else:
            # Not enough cooperators last round, defect and exploit
            action = 'D'
    play(action)
```

---

### Additional Notes / Edge Cases

- **If you observe fluctuating cooperation levels close to m-1, remain stable: cooperate only on clear signs of threshold support.**  
- **If threshold met consistently, exploit by defecting at first sign of any drop below m-1 cooperators next round.**  
- **No attempts to communicate or signal; rely only on observable cooperation counts each round.**  
- **Do not cooperate in round 1 because no past information; defecting is safer to see others’ tendencies.**  
- **Never cooperate in the final round to maximize private payoff with no fear of reprisal.**

---

### Summary Statement

> "*In all but the first and last rounds, I aggressively cooperate only when the data from the previous round shows the threshold will be met without me cooperating; otherwise I defect. Round 1 and the last round I defect outright to maximize exploitation and payoffs without risk.*"

---

This strategy aligns with an aggressive mindset: cooperate the minimum needed to profit from the collective reward, exploit cooperators aggressively, and avoid costs otherwise.
'''

description_AGGRESSIVE_67 = '''
Below is an aggressive strategy design for the Collective Risk Dilemma game that leverages intimidation and opportunism while attempting to maximize personal payoff by exploiting others where possible.

---

### Strategy Overview: **"Dominant Defector with Strategic Cooperation"**

**Core Idea:**  
Defect aggressively to maximize private payoff except when cooperating can ensure at least the reward *k* while forcing others to pay the cooperation cost, thereby profiting relatively more. Use early rounds to test opponents and switch between defect and minimal cooperation to pressure others into incurring costs or failing the threshold. Exploit the last round by defecting to capitalize on others' efforts without reciprocation.

---

### 1. Decision Rules (Per Round)

**Inputs for round t:**
- History of all players’ actions up to round t-1
- Number of cooperators in round t-1 (if t > 1)
- Own previous actions and payoffs
- Parameters: n, r, m, k

---

**Round 1 (Initialization and Testing):**  
- Defect (D) outright.  
- Reason: Establish baseline, avoid upfront costs, observe opponents' willingness to cooperate in response.

---

**Rounds 2 to r-1 (Aggressive Manipulation and Opportunism):**

- Calculate **cooperator count in last round** (C_count).
- Observe **if threshold m was met last round**.

**Conditions:**  

1. **If threshold was met last round by others (C_count ≥ m):**  
   - Defect this round to exploit cooperators (gain 1 + k).  
   - Reason: Punish others by free-riding.

2. **If threshold was not met last round (C_count < m):**  

   - **If C_count is close to threshold:** (e.g., C_count = m-1 or m-2)  
     - Cooperate to help others reach the threshold **only if cooperating this round guarantees threshold met** (i.e., if my cooperation pushes C_count ≥ m).  
     - Reason: Ensure group reward only if you are pivotal to cross threshold, to avoid wasted cooperation cost.  
   - Otherwise, Defect to avoid unnecessary cost.

3. **If you detect any player(s) who cooperated consistently > 50% of past rounds:**  
   - Defect aggressively to exploit their cooperation.  
   - Reason: Exploit those who shoulder cooperation burden.

---

**Last Round (Round r):**

- Always Defect.  
- Reason: No future rounds to punish you; maximize private payoff by leveraging others’ cooperation.

---

### 2. Edge Case Handling

- **First Round:** Always defect to avoid blind cooperation cost and observe opponent cooperation levels.
- **Last Round:** Always defect to capture maximum payoff by free-riding.
- **Close to Threshold:** Cooperate **only** if my cooperation is pivotal and will push the group over the threshold, ensuring reward.  
- **If group repeatedly fails threshold:** Continue defecting to minimize own costs.
- **If group consistently meets threshold without your cooperation:** Defect to exploit group payoff.
- **If repeated punishments received (e.g., coalition of defectors punishing you):** Continue defecting, no retaliation (aggressive stance).

---

### 3. Pseudocode

```python
def aggressive_strategy(t, history, n, r, m, k, player_index):
    # t: current round (1-based)
    # history: list of tuples for previous rounds [(actions), (payoffs)], actions[e] in {'C','D'}
    # player_index: index of this player (0-based)
    
    if t == 1:
        # First round: defect
        return 'D'
    
    if t == r:
        # Last round: defect to exploit others
        return 'D'
    
    last_actions = history[t-2][0]  # actions of round t-1
    coop_count = sum(1 for a in last_actions if a == 'C')
    my_coop_count = sum(1 for past_round in history for a in [past_round[0][player_index]] if a=='C')
    total_rounds_played = t - 1
    
    # Check if threshold met last round
    threshold_met = (coop_count >= m)
    
    # Check if my cooperation is pivotal this round: 
    # i.e., is coop_count + 1 >= m?
    # "coop_count" here refers to coop count last round; for current round unknown
    # So use proxy: if coop_count last round is m-1 or m-2, cooperate this round to try to push threshold
    pivotal = (coop_count >= m-2) and (coop_count < m)
    
    # Calculate opponents who cooperate > 50% rounds so far
    coop_freq = [0]*n
    for past_round in history:
        for idx, action in enumerate(past_round[0]):
            if action == 'C':
                coop_freq[idx] += 1
    coop_freq = [f/total_rounds_played for f in coop_freq]
    
    # Aggressive decision rules
    if threshold_met:
        # Threshold met last round - free-ride
        return 'D'
    
    if pivotal:
        # Cooperate only if pivotal to threshold
        return 'C'
    
    # If no threshold met and no pivotal role, check if others are cooperation-heavy
    for idx, freq in enumerate(coop_freq):
        if idx != player_index and freq > 0.5:
            # Exploit cooperative players
            return 'D'
    
    # Otherwise defect
    return 'D'
```

---

### Summary of Aggressive Mindset:

- **Exploit cooperation:** defect whenever others cooperate enough for threshold.
- **Minimal "necessary" cooperation:** only cooperate if strictly pivotal.
- **No forgiveness / no signaling:** never cooperate to help others unless forced.
- **Endgame defection:** last round defection to maximize payoff.
- **Use history to identify cooperative targets to exploit.**

This strategy applies maximal pressure on the group cooperation threshold to gain the highest personal payoff at their expense.
'''

description_AGGRESSIVE_68 = '''
Here's an aggressive strategy designed for the Collective Risk Dilemma game:

---

## Aggressive Strategy: "Dominant Defector with Opportunistic Punishment"

### Intuition and Aggressive Flavor:
- The strategy assumes that defecting is individually rational since cooperating costs you 1 unit.
- It defaults to defecting every round to maximize private payoffs.
- Only cooperates occasionally to ensure the threshold is met when profitable, but only if it can exploit others’ cooperation to get higher payoff.
- Punishes cooperators in subsequent rounds by defecting, to discourage altruism.
- Exploits the fact that defectors earn more than cooperators when the threshold is met.
- In the last round, defects to maximize end payoff (no future retaliation risk).

---

### Decision Rule Overview:

| Condition                                   | Action   |
|---------------------------------------------|----------|
| Round 1                                      | Defect   |
| Round t > 1: If in round (t-1), *at least m players cooperated*, and *I defected* then defect again (exploit cooperative players) | Defect   |
| Round t > 1: If in round (t-1), *fewer than m players cooperated* (threshold missed) | Attempt to cooperate to try to reach threshold |
| Exceptional opportunistic cooperation: If cooperating promises a strictly better payoff than defecting by exploiting others’ cooperation | Cooperate |
| Last round (t = r)                          | Defect   (No incentive to cooperate in the last round) |

---

### Key Notes:

- The strategy never initiates cooperation unless forced by missing threshold previously, or sees a profitable opportunity to exploit cooperators.
- It aims to achieve payoff ≥ 1 (defect payoff) always, and tries to marginally improve payoffs via selective cooperation when others help meet threshold.
- Defects in the last round to avoid paying cooperation cost when no future punishment possible.
- The strategy is reactive: it conditionally cooperates if the group failed threshold last time (to try to break losing streak), but defects aggressively otherwise.

---

### Detailed Steps & Pseudocode:

```
Input:
  - t: current round (1 ≤ t ≤ r)
  - history: actions of all players in rounds 1 to t-1 (including self)
  - parameters: n, r, m, k

Variables:
  - prev_cooperators = number of players who cooperated in round t-1
  - self_last_action = my action in round t-1

BEGIN

  if t == 1:
    action := D  # Always defect in first round
    
  else if t == r:
    action := D  # Always defect in last round
    
  else:
    prev_cooperators := count_cooperators(history[t-1])
    self_last_action := my_action(history[t-1])
    
    if prev_cooperators >= m and self_last_action == D:
      # Exploit cooperation: keep defecting to get higher payoff
      action := D
      
    else if prev_cooperators < m:
      # Threshold not met => try cooperating to rescue the situation
      action := C
      
    else if prev_cooperators >= m and self_last_action == C:
      # I cooperated last round and threshold met
      # Opportunities to defect next round?
      # If defecting yields higher payoff, defect; else cooperate
      
      # Calculate payoffs:
      # If I defect while threshold met: payoff = 1 + k
      # If I cooperate while threshold met: payoff = 0 + k = k
      
      # Since k > 1, defecting yields strictly higher payoff
      action := D
      
    else:
      # Default fallback
      action := D
      
END
```

---

### Explanation:

- **Round 1:** Defect to maximize private payoff, no prior info.
- **After Round 1:**
  - If enough cooperators last round and I defected, keep defecting — exploit cooperators who bear the cost.
  - If threshold missed, start cooperating to encourage reaching threshold (aggressively try to bring the threshold into reach only if previously lost).
  - If I cooperated and threshold met, switch to defect next round to exploit those cooperators.
- **Last Round:** Always defect to avoid cooperation cost, since no future rounds exist to punish defectors.
  
---

### Behavior Summary:

- Mostly defects to maximize payoff.
- Uses cooperation sparingly as a tactical maneuver only when threshold was missed in prior round (try to push threshold met).
- Aggressively exploits others’ cooperation without reciprocating.
- Does not reward cooperators with cooperation; it punishes by switching to defection.
- In repeated interactions, attempts to force others to pay cooperation cost while benefiting by defecting.
- Does not cooperate in last round to protect final payoff.

---

This strategy exhibits aggressive dominance by refusing to altruistically cooperate except to opportunistically ensure threshold success when necessary, and by exploiting cooperative players ruthlessly. It leverages the repeated structure to conditionally punish and exploit, aiming for maximal self payoff over the entire game.
'''

description_AGGRESSIVE_69 = '''
Here is a detailed aggressive strategy design for the Collective Risk Dilemma game as specified, emphasizing maximal personal payoff by leveraging others’ cooperation but minimizing own cooperation costs.

---

## Strategy Overview: "Conditional Exploitative Defector"

The aggressive mindset here is to maximize personal reward by **defecting as much as possible** while still **ensuring the threshold m is met by others** so the reward k is obtained. We will cooperate only minimally and strategically to enforce collective cooperation or punish failed cooperation.

---

## Key Intuition

- Cooperate just enough to avoid the risk of losing the reward k when others might defect too much.
- Defect whenever possible to keep your private payoff.
- Use early rounds to gauge opponents’ willingness to cooperate.
- Punish defectors aggressively by defecting if the group falls short, reducing their payoff.
- In the last round, defect always to maximize private payoff.

---

## Detailed Decision Rules

### Notation

- \( C_t \) = number of players who cooperated in round t (excluding self if self defected).
- \( c_i^t \) = your action at round t (1 for cooperate, 0 defect).
- \( r \) = total rounds, \( n, m, k \) as given.
- History: actions of all players up to round \( t-1 \), denoted \( H^{t-1} \).

---

### Round 1 (Start of game)

- **Defect**: Cooperate in first round only if you suspect others will defect, to avoid loss; but since you don’t know others yet, **defect first round to gather data** on cooperation rates.
  
Rationale: No prior info, be aggressive and exploit default group cooperation or defect tendency.

---

### Early and Mid Rounds (2 to r-1)

- After round \( t-1 \), observe cooperation count \( C_{t-1} \).

- If in previous round \( C_{t-1} \geq m \) (threshold met):

  - **Defect** in round t to maximize private payoff, since payoff \( \pi_i = 1 + k \) for defectors with threshold met.
  
- Else if \( C_{t-1} = m - 1 \) (just below threshold):

  - **Cooperate** to help push collective cooperation to threshold this round (assuming others likely cooperate similarly).

- Else if \( C_{t-1} < m - 1 \) (low cooperation prev. round):

  - **Defect**, punishing group by not contributing since group reward is not realized anyway.
  
  - This punishment may pressure others to cooperate more in future rounds or else group payoff stays low.

---

### Last Round (Round r)

- **Always defect**: Cannot influence future rounds; maximizing private payoff by defecting.

---

## Summary of Decision Logic

| Condition                                 | Action |
| ---------------------------------------- | ------ |
| Round 1                                  | Defect |
| Round t (2 ≤ t < r):                     |        |
| - If Prev round cooperation ≥ m         | Defect |
| - If Prev round cooperation = m - 1      | Cooperate |
| - If Prev round cooperation < m - 1      | Defect |
| Round r (last round)                     | Defect |

---

## Pseudocode

```python
def decide_action(round_t, history, n, m, r):
    if round_t == 1:
        return 'D'  # First round defect

    if round_t == r:
        return 'D'  # Last round defect always

    # Count number of cooperators in previous round (excluding self if needed)
    prev_round = round_t - 1
    cooperators_prev = sum(1 for player_action in history[prev_round] if player_action == 'C')

    if cooperators_prev >= m:
        # Threshold met, free-ride
        return 'D'
    elif cooperators_prev == m - 1:
        # Near threshold, help reach it
        return 'C'
    else:
        # Too few cooperators, defect and punish
        return 'D'
```

---

## Discussion of Edge Cases

- **If others all defect in round 1**: In round 2 you will see \( C_1 = 0 < m-1 \), so you defect again (consistent aggressive stance).
- **If others cooperate above threshold in round 1**: You exploit by defecting in round 2.
- **If cooperation fluctuates just below threshold**: you cooperate to try to push to threshold, but only when it’s one short.
- **Last round defects ensure maximum personal payoff without concern for future rounds.**

---

## Final Notes

- This strategy aggressively exploits cooperators by defecting whenever threshold is met.
- Cooperates minimally only to nudge group cooperation to meet threshold.
- Punishes widespread defection by defecting and denying the reward.
- Leverages perfect observability and repeated rounds to adapt aggressively.
- Prioritizes personal gain over collective welfare.
  
This robustly aggressive strategy should perform well in tournaments against mixed opponents, extracting rewards while minimizing cooperation costs.
'''

description_AGGRESSIVE_70 = '''
Here is an **aggressive strategy** for the Collective Risk Dilemma as specified, designed to maximize individual gains by exploiting cooperative players, using threat and conditional cooperation—but prioritizing defection to extract higher payoffs:

---

## Strategic Insight for Aggression

- The payoff rewards defectors **more** than cooperators **when the threshold m is met**:
  - If threshold met: Defector gets (1 + k), Cooperator gets (0 + k)
  - If threshold not met: Defector gets 1, Cooperator gets 0
- Since the game is repeated, some cooperation may be necessary to trigger the reward k.
- Aggressive play seeks to:
  - Exploit cooperators by defecting when the threshold is met.
  - Force others to bear cooperation costs so you can free-ride.
  - Minimize own cooperation to only when absolutely necessary to reach threshold.
  - Use conditional cooperation as a threat to maintain minimal cooperation but with a selfish twist.
  
---

## Strategy Description: "Conditional Exploiter"

### Overview

- **First round:** Defect to test opponents.
- **Subsequent rounds:** Cooperate **only if** exactly (m - 1) others cooperated in the previous round and the threshold was met (i.e., the group reached at least m cooperators). Otherwise, defect.
- **Last round:** Defect aggressively; no future rounds to incentivize cooperation.
- **Goal:** Free ride on others’ cooperation whenever the threshold is met.
- **Tolerance:** Will provide minimal cooperation to keep threshold reachable if others reliably cooperate.
- **Punish excessive cooperation:** If too many cooperate (over m), defect to push more cooperators and reap bigger rewards.

---

### Decision Rules

Let:

- t = current round number (1 ≤ t ≤ r)
- c_{-i,t-1} = number of cooperators besides self in previous round (t-1)
- threshold_met_{t-1} = whether at least m cooperators (including self if cooperated) in previous round
- my_action_{t-1} = your own action previous round (C or D)

---

1. **Round 1:**
   - Action: **Defect (D)**
   - Reason: No information available; start aggressively by free-riding.

2. **Rounds 2 to r-1 (middle rounds):**

   - If previous round **threshold was met** AND number of cooperators (excluding you) was exactly **m - 1**:
     - Cooperate (C)
     - Reason: Your cooperation will push group to threshold; you "invest" to maintain reward stream.
   
   - Else:
     - Defect (D)
     - Reason: Exploit others; if threshold not met, no point cooperating.
   
3. **Round r (last round):**
   - Defect (D)
   - Reason: No future rounds to incentivize others; pure selfish maximization.

---

### Handling Edge Cases

- **If threshold never met in previous rounds:**
  - Assume others are too greedy or uncooperative, so keep defecting to avoid wasting cost.

- **If too many others cooperated (more than m):**
  - Still defect to maximize payoff; free ride on their excessive cooperation.

- **If you are the only cooperator hitting threshold:**
  - Cooperate to keep threshold met.
  - But if no one else ever cooperated, will revert to defect permanently.

---

## Pseudocode

```python
function decide_action(t, r, m, prev_cooperator_count, threshold_met_prev, my_action_prev):

    if t == 1:
        return 'D'  # Start aggressively by defecting

    elif t == r:
        return 'D'  # Last round, defect

    else:
        # Check if threshold met last round
        if threshold_met_prev:
            # prev_cooperator_count = number of other cooperators last round (excluding self)
            if prev_cooperator_count == m - 1:
                # Your cooperation ensures threshold is exactly met
                return 'C'
            else:
                return 'D'
        else:
            return 'D'
```

---

## Summary

- The strategy **never cooperates first round or last round**.
- Between first and last round, **conditionally cooperate only when your cooperation is pivotal** to meeting the threshold (i.e., exactly m-1 others cooperated last round).
- This minimizes cost while keeping reward flowing, **free riding whenever possible**.
- Aggressive because it refuses to cooperate unnecessarily and exploits cooperators fully.
- Relies on the repeated setting to extract benefits from others' cooperation but punishes over-cooperators with defection.

---

If your opponents are generally cooperative, you get consistently high payoff by defecting to enjoy rewards without paying costs. If all defect, you never lose much by defecting yourself. This makes the strategy robust and aggressively selfish.
'''

description_AGGRESSIVE_71 = '''
Here is an aggressive strategy for the Collective Risk Dilemma that aims to maximize individual payoff by exploiting cooperators whenever the threshold is likely met, while still ensuring the threshold is met to receive the reward. The core idea is to defect whenever it is safe (when enough others are cooperating), cooperate only enough to push the total cooperative count to the threshold, and ruthlessly defect otherwise.

---

### Strategy Name: **Threshold Exploiter**

---

## Intuition / Aggressive Mindset

- **Goal:** Obtain the threshold reward `k` but keep as many endowments as possible privately (defect) to maximize personal payoff.
- **Aggression:** Never cooperate more than the minimum necessary to ensure the threshold `m` is reached. Exploit cooperators by defecting once threshold is safely met.
- **Leverage Perfect & Common Knowledge:** Use history to detect how many cooperators there have been, and decide cooperation only if needed to hit the threshold.
- **Exploit Last Rounds:** Defect with full greed in the last round(s), since there is no future punishment.

---

## Decision Rules (Per Round)

### Variables:

- `history[t-1]`: array of all players’ actions in previous round (for `t > 1`), indexed by player
- `prev_cooperators`: number of cooperators in last round, excluding self
- `estimated_cooperators`: the number of other players expected to cooperate this round (can be estimated from history)
- `round`: current round index (t), 1-indexed
- `n, m, r`: given game parameters
- `my_action`: the action this strategy will pick this round

---

### Round 1 (No History)

- Cooperate exactly `m - 1` times spread over the first rounds to “signal” or ensure threshold can be met by others.
- Since no prior info, **defect in Round 1** aggressively to test opponents, assuming others will cooperate to get the reward this first time.
- Rationale: Do not pay upfront cost without any info, but monitor others closely.

### From Round 2 to Round r-1

1. From round 2, estimate how many others cooperated last round:  
   `prev_cooperators := count of C by other players in history[t-1]`
  
2. Predict if threshold can be met this round if you defect:  
   - If `prev_cooperators >= m`, threshold likely met by others → **Defect**
   - Else if `prev_cooperators == m - 1` → **Cooperate** (just enough to hit threshold)
   - Else (prev_cooperators < m - 1) → too risky to cooperate, aggressive defection to minimize cost (accept no reward)
   
3. If evidence opponents are reducing cooperation over rounds, become more aggressive and defect even if threshold risk is higher (see edge handling below).

### Last Round (round t = r)

- Defect no matter what; no future punishment opportunity.
- If threshold reached without you cooperating, maximize payoff by defecting.
- If threshold not reached and you defect, payoff = 1 (better than cooperating alone with no reward).
- Do not invest in cooperation on last round.

---

## Edge Case Handling and Additional Notes

- **If threshold just met last round (e.g., exactly `m` cooperators including you), assume others depend on your cooperation:** then cooperate one more round to keep reward flowing if payoff looks safe.
  
- **If threshold failed last rounds repeatedly:** fully defect from now on — do not waste endowment hoping for others to cooperate; reward is not attainable.

- **If opponents appear to defect en masse (e.g., threshold not met 2 rounds in a row), switch to full defection to minimize loss.**

- **If the game is very long (large r), scope cooperation to just enough rounds to keep threshold alive early; then exploit fully later rounds.**

---

## Pseudocode

```python
def ThresholdExploiter(round, history, n, m, r):
    if round == 1:
        # Aggressive test: defect and see others' response
        return 'D'
    
    if round == r:
        # Last round: defect always
        return 'D'
    
    # Count how many other players cooperated last round
    prev_cooperators = sum(1 for action in history[round - 2] if action == 'C')  # zero-based indexing in code
    
    # Strategy core logic
    if prev_cooperators >= m:
        # Threshold met by others, defect to exploit
        return 'D'
    elif prev_cooperators == m - 1:
        # Cooperation needed to reach threshold, cooperate to get full reward
        return 'C'
    else:
        # Threshold unlikely, defect to avoid paying cooperation cost for no reward
        # Could add further logic to try cooperation occasionally, but aggressive mindset rules out
        return 'D'
```

---

## Summary

- **First Round:** Defect to stay safe and observe.
- **Middle Rounds:** Cooperate only if exactly `m-1` others cooperated last round, to secure the threshold and reward, otherwise defect.
- **Last Round:** Defect unconditionally.
- **Exploit cooperators:** If threshold met without you cooperating, always defect to maximize payoff.
- **Exit cooperation if threshold repeatedly not reached:** Switch to full defection.

This strategy aggressively maximizes individual payoff while ensuring the group reward `k` is collected only when it can be done at minimal personal cost. It exploits cooperative tendencies of others, rewarding free-riding behavior once threshold safety is observed.

---

If you want, I can also provide pseudo-code for keeping statistics or nuanced estimation of opponent tendencies over rounds to adjust aggression further. But the above covers the essential aggressive logic for this game.
'''

description_AGGRESSIVE_72 = '''
Below is an **aggressive strategy** for the Collective Risk Dilemma framed as a repeated simultaneous-move game. The strategy is designed to exploit cooperation from others to maximize individual payoffs, leveraging the reward \( k \) aggressively. It aims to defect as much as possible while still ensuring the threshold \( m \) of cooperators is met by others, so the collective reward is triggered.

---

## Strategy Intuition — "Conditional Exploit"

- **Goal:** Maximize own payoff by free-riding on others’ cooperation.
- **Basis:** Cooperate only enough to avoid the risk of missing the reward \(k\) (which is valuable), else defect.
- **Aggressiveness:** Defect whenever safely possible, exploiting others’ cooperation.
- **Edge Cases:** Start testing others early, switch to outright defection near the last rounds to maximize private gains.

---

## Detailed Decision Rules

### Notation:
- \( t \): current round (1 to \( r \))
- \( C_t \): number of cooperators observed in round \( t \)
- \( m \): minimum cooperators needed
- \( n \): total players
- \( k \): reward multiplier
- \( c_i^{t} \): your action at round \( t \) (C=1, D=0)

---

### Round 1 (t=1):

- Cooperate (play C) to signal willingness to cooperate and test others.
- This supports reaching threshold the first time and helps identify if the threshold is attainable.

### Rounds \( 2 \leq t \leq r-2 \):

- **If previous round \( (t-1) \) had \( C_{t-1} \geq m \):**

  - Defect (play D) aggressively, hoping others provide the threshold alone.
  - This maximizes payoff since reward is obtained while you keep your endowment.

- **Else (if \( C_{t-1} < m \))**:

  - Cooperate (play C) to try to reach the threshold and get \( k \).
  - You intervene by cooperating only if the threshold was missed last time.

### Round \( r-1 \) (second to last round):

- Cooperate to try to secure the reward before the final round.
- This increases chances the threshold is met in last two rounds.

### Round \( r \) (last round):

- Defect, since no future punishment or retaliation is possible.
- Maximize private gain on last round by keeping endowment.

---

## Summary Table

| Round             | Condition                                  | Action (C or D)    |
|-------------------|--------------------------------------------|-------------------|
| \( t=1 \)         | First round                                | Cooperate (C)     |
| \( 2 \leq t \leq r-2 \) | If last round met threshold \(C_{t-1} \geq m\)   | Defect (D)        |
|                   | Else (threshold not met last round)       | Cooperate (C)     |
| \( t = r -1 \)     | Penultimate round                          | Cooperate (C)     |
| \( t = r \)        | Last round                                | Defect (D)        |

---

## Edge Cases & Considerations

- **If threshold \( m \) is large, and cooperation unlikely:**

  - The strategy risks cooperating often but will quickly switch to defection if threshold consistently missed.
  - Still, starting with cooperation to test feasibility is vital.

- **If opponents are very defect-prone:**

  - The strategy attempts to force threshold by cooperating after failures.
  - However, it remains aggressive by defecting whenever threshold is easily met.

- **Observation Errors:**

  - Assumed perfect observation; under uncertainty, more conservative cooperation might be needed.

- **Possibility of mutual defection leading to all losing the reward:**

  - This strategy accepts that risk as acceptable in favor of maximizing payoff.

---

## Pseudocode Summary

```
Initialize: cooperate in round 1

For each round t in 1 to r:
    If t == 1:
        Play C
    Else if t <= r-2:
        If number_cooperators_in_round(t-1) >= m:
            Play D
        Else:
            Play C
    Else if t == r-1:
        Play C
    Else if t == r:
        Play D
```

---

## Explanation of Aggressiveness

- Defects as much as possible without losing the reward payout by opportunistically riding on others’ cooperation.
- Only intervenes to cooperate when the reward was missed previously, to keep it alive.
- Ends with a classic "last round defect" to maximize short-term private payoff, ignoring future reputation.
- Start cooperates just enough to test viability and induce others to carry cooperation load.

---

This strategy balances aggressive payoff maximization via defection with essential cooperation to keep the group reward alive, leveraging repeated interaction to exploit others effectively.
'''

description_AGGRESSIVE_73 = '''
Below is an **aggressive strategy** designed specifically for the Collective Risk Dilemma. The strategy leverages the game’s payoff structure to maximize individual payoffs aggressively, exploiting cooperators while avoiding being exploited. It uses observed opponent behavior over rounds to decide when to cooperate (to trigger the reward) or defect (to reap highest private payoff).

---

# Aggressive Strategy: "Exploit & Punish Threshold Cooperation"

### Core Idea:
- **Defect by default**—maximizing private payoff unless cooperating is strictly profitable.
- **Cooperate only when threshold cooperation is assured**, so you gain reward *and* defectors lose potential gains.
- **Exploit cooperators by defecting against partial cooperation.**
- **Punish attempts to cooperate prematurely by defecting.**
- In the **last round**, always defect to maximize payoff, since no future rounds remain.

---

## Decision Rules

### Parameters and Observations:
- `n, r, m, k` — known game parameters
- `current_round` ∈ [1..r]
- Track per round:
  - `num_cooperators_in_prev_round` — how many players cooperated last round
  - `player_i_own_action_in_prev_round`
- Track cumulative behavior if needed (optional)

---

### Step 1: First Round (no history)
- **Defect (D)** unconditionally to maximize payoff without risk.

---

### Step 2: Intermediate Rounds (2 ≤ current_round < r)
- **Goal:** Exploit partial cooperation; cooperate only if assured the threshold `m` is met even with your cooperation *and* cooperating benefits you over defecting.

- Decision logic at round t:
  
  1. **If in previous round, at least `m - 1` others cooperated, and you cooperated:**
     - This means threshold was met last round.
     - In this case, you are confident cooperating yields the reward if repeated.
     - **Cooperate this round** to maintain group's cooperation (until you can exploit).

  2. **Else if in previous round, fewer than `m - 1` others cooperated:**
     - Threshold unlikely met without your cooperation, so cooperating alone doesn't secure reward.
     - **Defect** to avoid paying cost (`c_i = 1`) with no guaranteed reward.

  3. **Else if in previous round, exactly `m - 1` cooperators excluding you:**
     - If you cooperated last round, threshold was met, cooperate again.
     - If you defected last round, do not cooperate now because outcome is risky; defect instead.

- **Rationale:** Only cooperate when cooperation triggers reward, otherwise defect to exploit any cooperative players.

---

### Step 3: Last Round (round == r)
- **Always defect** to maximize private payoff, as no future cooperation can be enforced or rewarded.

---

### Summary Table of Actions by Round and History:

| Round                    | Condition                      | Action    | Reason                           |
|--------------------------|-------------------------------|-----------|---------------------------------|
| 1 (first round)          | No history                    | Defect    | Safe exploit, no cooperation yet|
| Intermediate rounds       | `num_coop_prev_round` ≥ m-1 and you cooperated last round | Cooperate | Maintain cooperation if threshold likely met |
| Intermediate rounds       | `num_coop_prev_round` < m-1   | Defect    | Avoid cooperating without enough players   |
| Intermediate rounds       | Else                         | Defect    | Exploit partial cooperation      |
| Last round (round == r) | Any                           | Defect    | Maximize individual payoff last round |

---

## Pseudocode

```python
def decide_action(current_round, r, m, n, k, num_cooperators_prev, my_action_prev):
    # First round: defect
    if current_round == 1:
        return 'D'
    
    # Last round: defect
    if current_round == r:
        return 'D'
    
    # Intermediate rounds
    coop_others_prev = num_cooperators_prev - (1 if my_action_prev == 'C' else 0)
    
    if num_cooperators_prev >= m:
        # Threshold met last round
        if my_action_prev == 'C':
            # Maintain cooperation to keep reward
            return 'C'
        else:
            # Defect to exploit cooperating players
            return 'D'
    elif coop_others_prev >= m - 1:
        # Others nearly reached threshold
        if my_action_prev == 'C':
            # Maintain cooperation to push threshold over
            return 'C'
        else:
            # Defect if didn't cooperate last round
            return 'D'
    else:
        # Threshold not met, no incentive to cooperate
        return 'D'
```

---

## Strategic Notes

- **Aggressiveness:** The strategy systematically defects unless the threshold is met or very close to met and you’ve been cooperating. It avoids paying costs when cooperation is unlikely to pay off.
- **Exploitation:** When threshold is met (or guaranteed by your cooperation), you cooperate to trigger reward, but if previously defected, you keep defecting to free-ride on others.
- **Punishment:** By defecting when threshold is fragile or not met, it punishes naive cooperators, discouraging others from cooperating frequently.
- **Endgame defect:** Last round defection maximizes immediate gain knowing no threat of future retaliation.

---

# Summary:

> **"Defect usually. Only cooperate to trigger or maintain threshold cooperative reward—and only when your own prior cooperation ensures the reward is likely. End with defect to claim maximum private payoffs."**

This aggressive approach maximizes personal gain by exploiting cooperative players while providing minimal help to ensure group reward only when strictly beneficial.
'''

description_AGGRESSIVE_74 = '''
**Aggressive Strategy for Collective Risk Dilemma**

---

### Strategy Intuition

Aggressiveness here means prioritizing maximizing *your own* payoff—even at the cost of group cooperation stability. Since defectors keep their endowment and still earn the reward if threshold *m* is reached, defecting is attractive when enough others cooperate. This strategy exploits cooperators:

- Defect when you believe enough others will cooperate to reach threshold, thus "free-riding" on their cooperation and yielding higher payoff (1 + k).
- Cooperate only when necessary to push the group to cooperation threshold, but otherwise defect.
- Be opportunistic and punish perceived defectors only if you risk the threshold not being met.
  
---

### Parameters From Game

Given:  
- n players  
- m cooperators needed (1 < m < n)  
- r rounds (r > 1)  
- k reward multiplier (k > 1)  

---

### Decision Rules

**Goal:** Achieve maximum cumulative payoff over r rounds by defecting whenever possible without letting threshold fail.

---

#### Round 1 (Initialization)

- **Cooperate only if you expect ≥ (m - 1) other players to cooperate.**  
- Because no history is available, assume all players are likely to cooperate with 50% chance or more (optimistic, aggressive).  
- Default: Defect unless you want to help push cooperation  
- To be aggressive, **Defect** in round 1 ALWAYS (since there's no past data, choose maximal selfishness).

---

#### Rounds 2 to (r - 1)

- After each round, observe:  
  - Number of cooperators last round, call it `C_count`  
  - Whether threshold was met last round: `threshold_met = (C_count >= m)`

- **Decision logic:**

  1. **If threshold met last round:**  
     - If `(C_count - 1) >= m`, i.e. others can achieve threshold without you  
       **Defect** (free-ride on others' cooperation)  
     - Else (you needed to push threshold):  
       **Cooperate** (to maintain threshold and get reward)

  2. **If threshold failed last round:**  
     - Player(s) who defected lowered payoff for all.  
     - Aggressively punish by defecting unless forced to cooperate to save threshold.  
     - If others defected enough that threshold can't be met without you,  
       **Cooperate** (to avoid losing k, but minimal cooperation)  
     - Else, **Defect** (punish by withdrawing support)

---

#### Last Round (round = r)

- Since no future retaliation or reward:  
- **Always Defect** to maximize immediate gain (typical backward induction in repeated games).

---

### Summary — Pseudocode

```python
def aggressive_strategy(round_num, history, n, m, r):
    """
    - round_num: current round index (1-based)
    - history: list of dicts per round with keys:
        - 'cooperators': list of player indices who cooperated last round
        - 'threshold_met': boolean
    """
    if round_num == 1:
        # No history: Defect aggressively
        return 'D'
    
    if round_num == r:
        # Last round: Defect aggressively
        return 'D'
    
    # Analyze last round results
    last_round = history[-1]
    C_count = len(last_round['cooperators'])
    threshold_met = last_round['threshold_met']
    
    # Am I essential for reaching threshold? (Assuming self not counted yet)
    others_cooperating = C_count if 'self' not in last_round['cooperators'] else C_count - 1
    
    if threshold_met:
        # If others alone can maintain threshold without me
        if others_cooperating >= m:
            # Free-ride: Defect
            return 'D'
        else:
            # Needed to maintain threshold: Cooperate
            return 'C'
    else:
        # Threshold failed last round
        if others_cooperating >= m:
            # Others can reach threshold without me, punish by defecting
            return 'D'
        else:
            # I must cooperate to try to reach threshold, else defect
            # Aggressive mindset: cooperate only if absolutely necessary
            cooperate_needed = (others_cooperating + 1) >= m
            if cooperate_needed:
                return 'C'
            else:
                return 'D'
```

---

### Additional Notes

- The strategy exploits cooperators to maximize individual payoff by defecting whenever others cover the threshold.
- It punishes failed cooperation rounds by defecting, but only gives minimal cooperation to avoid losing the reward entirely.
- In the last round defects aggressively since no long-term consequences.
- This strategy assumes perfect information of others' actions in the previous rounds and no communication signals beyond that.

---

**In essence:**

> *"I defect by default to maximize private payoff and only cooperate when absolutely necessary to secure the reward. I punish failure to cooperate by defecting, but I exploit others’ cooperation aggressively when possible. I always defect last round."*
'''

description_AGGRESSIVE_75 = '''
Here is an aggressive strategy tailored to the Collective Risk Dilemma, balancing exploitation of cooperators with some calculated cooperation to ensure the collective reward when it benefits the aggressor’s payoff.

---

### Key Intuition of the Aggressive Strategy
- Defect as much as possible to maximize private payoffs.
- Only cooperate enough to reach the cooperation threshold **m** to secure the risk-averting reward **k** that benefits defectors more.
- Exploit cooperating players by defecting once the threshold is met.
- Use observed behavior to adjust cooperation threshold dynamically and punish excessive cooperation by others.
- In the last round, defect unconditionally to maximize immediate payoff when future retaliation is impossible.

---

## Strategy Description

### Parameters:
- n, r, m, k: game parameters (known)
- round: current round index (1-based)
- coop_count_last_round: number of cooperators observed in the previous round
- min_coop_needed: minimum cooperators including self to reach threshold m (adjusted dynamically)
- cooperating_players: track players who cooperated in recent rounds

### Decision Rules

#### Round 1 (No prior info)
- Cooperate if (m - 1) ≤ 1 (i.e., the minimum threshold is very low; in other words, if you alone or plus a single other cooperator can reach threshold).
- Else defect.

Rationale: If you are not essential or near the threshold, no incentive to cooperate initially.

----

#### Subsequent Rounds (round > 1, round < r)

1. **Evaluate cooperation in last round:**

   a. If the threshold **m** was met last round (i.e., coop_count_last_round ≥ m):
   
   - Defect this round to exploit cooperators, **unless** your defection would cause cooperation to fall below m.
     - If you defect and threshold will still be met, defect.
     - Else cooperate to keep threshold met (to avoid losing the reward for all).
     
   b. If threshold **m** was NOT met last round:
   
   - Cooperate only if you estimate that cooperating will MAKE the threshold **m** being reached this round.
   - Otherwise defect.
   
2. **Punish over-cooperators:**
   
   If any player cooperated *consistently* (say 2+ rounds consecutively) without defecting, mark them as exploitable.

   Defect against those players aggressively to maximize private payoff, letting cooperating players bear the cost.

3. **Dynamic cooperation adjustment:**

   - If you observe fewer than (m-1) others cooperating over many rounds, lower your own cooperative frequency to zero.
   - If you observe consistent cooperation by others that reaches or exceeds m-1, cooperate just enough to make threshold (m) collectively.

----

#### Last Round (round == r)

- Defect unconditionally to maximize immediate payoff (no future punishment risk).

---

## Pseudocode

```python
# Inputs: round, coop_count_last_round, history_of_actions, n, m, k

def aggressive_strategy(round, coop_count_last_round, history, n, m, k):

    # Last round: always defect
    if round == r:
        return 'D'
    
    # Round 1 (no history)
    if round == 1:
        if (m - 1) <= 1:  # near threshold, cooperate to reach it
            return 'C'
        else:
            return 'D'
    
    # For rounds 2 to r-1
    # Count how often each player cooperated in recent history (e.g., last 2 rounds)
    coop_counts = count_cooperation(history, last=2)
    consistent_cooperators = [p for p in range(1, n+1) if coop_counts[p] == 2]
    
    # Observe last round cooperation count (excluding self)
    coop_others_last_round = coop_count_last_round - (1 if last_action_self == 'C' else 0)

    # Are we essential to achieve threshold?
    # To make threshold current round, at least (m - coop_others_last_round) cooperators needed including self
    
    needed = m - coop_others_last_round
    
    # Strategy:
    # 1. If threshold met last round:
    if coop_count_last_round >= m:
        # If defecting keeps threshold met this round, defect
        if (coop_others_last_round) >= m:
            # threshold without self cooperating is still met, so defect and exploit
            return 'D'
        else:
            # We must cooperate to maintain threshold, so cooperate
            return 'C'
    
    # 2. If threshold not met last round:
    else:
        # Cooperate only if needed this round to hit threshold
        if needed <= 1:
            return 'C'
        else:
            return 'D'

    # 3. Aggressively defect against consistent cooperators for exploitation
    # (Implemented via future move targeting, details depend on implementation)
```

---

## Summary of Aggressive Characteristics

- **Maximize exploitation:** Defect whenever threshold can still be met without you, free-riding on cooperators.
- **Conditional cooperation:** Only cooperate when your cooperation is pivotal to getting the reward, never wasting endowment.
- **Punish cooperators:** Exploit consistent cooperators by defecting against them when it yields higher payoff.
- **Endgame defection:** Defect unconditionally in the last round to gain private maximum payoff.
- **Responsive:** Dynamically adjusts behavior based on observed cooperation rate to minimize wasted contributions.

---

This aggressive strategy ensures you maximize private payoffs by freely defecting while exploiting cooperative players when possible and only cooperating narrowly to secure the communal reward all can share.
'''

description_AGGRESSIVE_76 = '''
Below is a detailed aggressive strategy tailored for the *Collective Risk Dilemma* with full reasoning and explicit decision rules.

---

## Aggressive Strategy: "Threshold Exploiter"

### Intuition

- **Goal:** Maximize personal payoff by strategically defecting as much as possible.
- Cooperate **only when necessary** to maintain the minimum number of cooperators (m) so the collective reward (k) is triggered.
- Otherwise, **defect aggressively** to preserve the private benefit (1) **and** gain the additional reward (k) when the threshold is met by others' cooperations.
- Exploit that defectors gain more than cooperators when threshold met (as in example: defectors receive 1 + k, cooperators 0 + k).
- Leverage perfect information and repeated rounds to observe others and act accordingly.
- In the last round, defect aggressively since future retaliation is impossible.
- In early and middle rounds, sometimes cooperate just enough to sustain threshold m to keep the reward flowing in.

---

### Detailed Decision Rules

---

#### Initialization
- Know parameters: n, r, m, k.
- Keep track of cooperation count each round.
- Keep a record of opponent cooperation history.

---

#### Round 1
- Cooperate **only if**: You predict player cooperation count will be below m if you defect.
- Otherwise, defect.
- Since no history exists, **defect** aggressively first round to test opponents.
- (If the game requires to meet threshold m to get k, it is probable that with no history, many defect. If so, cooperate this round to avoid zero reward round.)
- For safety, **defect round 1** if m < n / 2 (threshold small) else cooperate.

---

#### Intermediate Rounds (2 to r-1)
- Observe previous round’s cooperation count (num_c).
- If num_c ≥ m:
    - Defect.
    - Reason: The threshold was met last round without your cooperation (or with cooperation including you); so try to free-ride.
- Else if num_c = m - 1:
    - Cooperate.
    - Reason: If you do not cooperate, threshold fails, and all get only 1.
    - Cooperate to keep threshold intact.
- Else (num_c < m - 1):
    - Defect.
    - Reason: Cooperation threshold too low, no incentive to cooperate — won’t achieve reward this round regardless.
- If past rounds show a pattern of cooperation trending up and threshold met consistently, defect until you see threshold failing or you’re needed.
- Track which players are consistent cooperators; rely on their contributions.

---

#### Last Round (round r)
- Defect aggressively.
- Since no future retaliation, maximize my payoff.
- No need to preserve cooperation since game ends.
- Play D always.

---

#### Edge cases:
- If you’re in a minority of cooperators very close to threshold (e.g., cooperation count exactly m, including yourself):
    - Consider defecting once to test if others can uphold threshold.
- If threshold never met and opponents always defecting:
    - Defect all rounds.
- If everyone cooperates (full cooperation equilibrium), defect once per round as much as possible without dropping cooperation below m.
- If many defect, cooperate occasionally if you observe failing threshold; maintain minimal cooperation needed and exploit others.

---

### Pseudocode

```python
def aggressive_strategy(round_num, r, n, m, k, coop_history):
    # coop_history: list of length round_num-1 with counts of cooperators per round
    
    if round_num == 1:
        # No history, aggressive default:
        if m < n / 2:
            # Threshold low; risk defect to test:
            return 'D'
        else:
            # Threshold high: cooperate to ensure reward:
            return 'C'

    elif round_num < r:
        prev_coop = coop_history[-1]
        # Check cooperation in previous round:
        if prev_coop >= m:
            # Threshold met last round: defect
            return 'D'
        elif prev_coop == m - 1:
            # Just below threshold; cooperate to maintain reward
            return 'C'
        else:
            # Threshold too low to matter: defect
            return 'D'

    else:  # last round
        # Defect always last round
        return 'D'
```

---

### Summary Notes

- Exploit threshold mechanism aggressively by defecting whenever threshold conditions are met without you.
- Cooperate only when absolutely necessary to sustain threshold and get the reward.
- Defect first round when risk is low and last round always.
- Use observation of previous round cooperation counts to guide present round.
- This creates pressure on others to cooperate while you exploit free-riding opportunities constantly.

---

This strategy aligns with an aggressive mindset: prioritize personal payoff maximization exploiting others' cooperation, cooperating narrowly only when strictly needed to maintain the reward structure.
'''

description_AGGRESSIVE_77 = '''
Here is a detailed **aggressive strategy** for the Collective Risk Dilemma that aims to maximize your own payoffs by exploiting cooperators while maintaining enough cooperation to secure the group reward when profitable.

---

## Strategy Overview: "Aggressive Opportunist"

- **Core idea:** Defect by default to keep the endowment, but cooperate strategically just enough to ensure the minimum cooperation threshold (m) is met each round—thus securing the reward k for all players and allowing you to exploit cooperators.
- **Aggressive mindset:** Prioritize personal gain, exploit cooperators, tolerate minimal risk, and do not "waste" your endowment unnecessarily.
- **Adaptive:** Use observations of opponents' previous round behaviour to estimate cooperation likelihood and adjust.

---

## Decision Rules by Round

### Round 1 (start of game)

- **No history available.**
- Defect (D) in Round 1 to avoid giving away endowment without prior information.
- Rationale: Aggressive players start by testing others; no reason to invest blindly.

### Rounds 2 to r-1 (middle rounds)

- At the start of each round, observe the previous round's cooperation count `prev_c`.

- **If previous round cooperation count ≥ m:**
  - Probability is high that enough players are willing to cooperate.
  - Defect (D) this round: free ride on others who cooperate.
  - Rationale: Exploit cooperators confidently.

- **If previous round cooperation count < m:**
  - The group risked losing the reward last round.
  - Check if you can nudge the group to meet the threshold by cooperating yourself.
  
  Specifically:
  - Let `estimated_cooperators = prev_c`
  - If `estimated_cooperators + 1 ≥ m`, then cooperate this round (C) to tip the scale to winning reward.
  - Else, defect (D).

- Rationale: Only cooperate when it can guarantee the reward for everyone, including yourself. Never cooperate unnecessarily.

### Round r (final round)

- In the last round, no future rounds to exploit or punish.
- Defect (D) by default to capture the private payoff.
- Only cooperate (C) if previous round cooperation was ≥ m and you believe the reward can be secured without your cooperation (free ride final round).
- Do not cooperate solely to help others in the final round.

---

## Important Notes

- **No costly cooperation without payoff:** Aggressiveness means never contributing if it does not secure the collective reward.
- **No unconditional cooperation:** Always base cooperation on clear evidence (previous round behavior).
- **Exploit threshold property:** When exactly m-1 players cooperate, you cooperate as the m-th to lock in the reward—maximizing your gain relative to cooperators who pay the cost.
- **Monitor threshold closely:** Because if cooperation falls below m, payoff drops to 1 - cost for cooperators and 1 for defectors, which is less attractive.

---

## Pseudocode

```python
# Inputs per round:
# history: list of sets of cooperating players per past round
# n, m, k, r: game parameters
# i: your player index

def aggressive_strategy(round_num, history, n, m, k, i):
    if round_num == 1:
        # First round: defect to test opponents
        return 'D'
    
    prev_cooperators = history[-1]  # Set of players who cooperated last round
    prev_c = len(prev_cooperators)

    if round_num == r:
        # Final round logic
        if prev_c >= m:
            # Reward likely secured by others, free ride
            return 'D'
        else:
            # Reward unlikely, defect to keep private payoff
            return 'D'
    
    # Middle rounds logic
    if prev_c >= m:
        # Reward secured last round: defect to exploit cooperators
        return 'D'
    
    # Reward not secured last round; try to push cooperation over threshold
    if prev_c + 1 >= m:
        # Cooperate to tip past threshold
        return 'C'
    else:
        # Not enough cooperation potential, defect
        return 'D'
```

---

## Summary

| Round     | Condition                             | Action        | Reasoning                                  |
|-----------|-------------------------------------|---------------|--------------------------------------------|
| 1         | No prior info                       | Defect (D)    | Test the waters, avoid early loss          |
| Middle    | Prev coop ≥ m                      | Defect (D)    | Exploit cooperators                          |
| Middle    | Prev coop < m and prev coop + 1 ≥ m | Cooperate (C) | Push group to threshold and secure reward  |
| Middle    | Prev coop + 1 < m                  | Defect (D)    | No sufficient cooperation to push reward   |
| Last (r)  | Prev coop ≥ m                      | Defect (D)    | Free ride on guaranteed reward              |
| Last (r)  | Otherwise                         | Defect (D)    | No future rounds, no incentive to cooperate |

---

This **aggressive opportunist** strategy exploits cooperators while maintaining control over rounds where reward is reachable, maximizing your total payoff against a diverse set of opponents in the tournament.
'''

description_AGGRESSIVE_78 = '''
Here is an aggressive strategy designed to maximize individual payoff by exploiting the cooperative threshold while steering the group toward defecting (i.e., maximizing personal gain, even at the risk of group failure). This strategy tries to get others to cooperate enough so that the player can defect safely, and defect otherwise—leveraging free-riding opportunities aggressively.

---

### Aggressive Strategy Description: "Opportunistic Free-Rider"

---

#### Intuition
- Cooperate **only if doing so creates or maintains the minimal cooperation threshold (m)**; otherwise defect.
- Defect whenever possible to gain the extra private payoff (1 instead of 0).
- Use observed behavior of others to assess if others reliably cooperate enough.
- In the last round, defect aggressively to maximize payoff, as no future punishment/reward is possible.
- Avoid wasting cooperation when threshold is unlikely to be met.
- Exploit any pattern of others cooperating consistently by defecting in future rounds ("punish" cooperators by freeriding).

---

#### Decision Rules

**Notation:**
- At round t, observe summary from previous round: count_C(t-1) = number of players who cooperated
- Let `self_action(t-1)` be your own previous round action

---

**Round 1: Setup**
- Cooperate (C) **only if** you expect others to cooperate enough.  
- Since you have no info, **defect (D) initially** to test willingness of others to cooperate.
  
*Rationale:* Aggressive players begin by testing others and gaining payoff themselves.

---

**Rounds 2 to r-1 (Intermediate rounds):**
1. Calculate **expected cooperation level among others**, i.e.:

   ``` 
   expected_others_C = observed_count_C(t-1) - (1 if self_action(t-1) == C else 0)
   ```
2. If by cooperating yourself you can push total cooperators to threshold `m` (i.e., `expected_others_C + 1 >= m`):
   - **Cooperate (C)** to reach threshold and trigger payout.
3. Else:
   - **Defect (D)** to preserve private payoff; don't waste contribution if above threshold unlikely.

4. If in previous rounds others rarely cooperated (i.e., consistently `count_C < m`), then **always defect** from now on—no incentive to contribute.

5. If in previous rounds threshold was regularly met by others (i.e., `count_C(t-1) ≥ m`), then start **defecting more aggressively** to freeride, potentially pushing total cooperators below threshold for strategic gain (punishing cooperators).

---

**Last Round (t = r):**
- Always **Defect (D)**:
  - No future penalty or reward.
  - Gain private payoff and any last-round reward if threshold met.
  - Aggressive maximization focus.

---

#### Edge Cases and Behavior Summary

| Round           | Condition                                   | Action                      | Explanation                      |
|-----------------|---------------------------------------------|-----------------------------|---------------------------------|
| 1               | No info                                     | Defect (D)                  | Test others, gain private payoff|
| 2 ≤ t < r       | `expected_others_C + 1 >= m`                 | Cooperate (C)               | Push total cooperation to threshold for reward|
| 2 ≤ t < r       | `expected_others_C + 1 < m` and others cooperate sometimes | Defect (D)                  | Avoid wasting contribution if payoff unlikely|
| 2 ≤ t < r       | Others consistently fail threshold (≥2 rounds) | Defect (D)                  | Stop cooperating, exploit no cooperation|
| 2 ≤ t < r       | Others consistently cooperate (≥2 rounds) | Exploit by defecting occasionally | Punish cooperators to increase own payoff |
| t = r           | Always defect                               | Defect (D)                  | Maximize last-round payoff with no future risk |

---

### Pseudocode

```python
initialize:
    round = 1
    history = []  # stores previous rounds as tuples: (count_C, self_action)

for each round t in 1 to r:
    if t == 1:
        action = 'D'  # first round aggressive defection
    elif t == r:
        action = 'D'  # last round defection to maximize payoff
    else:
        count_C_prev, self_action_prev = history[-1]
        expected_others_C = count_C_prev - (1 if self_action_prev == 'C' else 0)

        # Analyze cooperation pattern over last few rounds to detect consistent behavior
        recent_counts = [c for c, _ in history[-2:]]  # last 2 rounds counts of cooperation
        avg_recent_C = sum(recent_counts) / len(recent_counts)

        if avg_recent_C < m:
            # Others rarely cooperate, no point cooperating
            action = 'D'
        else:
            # Threshold achievable if I cooperate?
            if expected_others_C + 1 >= m:
                action = 'C'  # contribute to ensure threshold reached
            else:
                # If others frequently cooperate, exploit by defecting occasionally
                # For aggression, defect unless cooperation is needed now
                action = 'D'

    play(action)
    observe players' actions → count_C_this_round
    history.append((count_C_this_round, action))
```

---

### Summary

- Start aggressive by defecting and testing willingness of others.
- Cooperate only when pushing cooperation over threshold is possible.
- Exploit others' cooperativeness by defecting when threshold can still be met.
- Defect consistently if others fail to cooperate.
- Always defect in last round to maximize private payoff without future retaliation.

This strategy aggressively maximizes own payoffs through calculated cooperation, free-riding, and last-round defection, exploiting the collective risk dilemma structure.
'''

description_AGGRESSIVE_79 = '''
Here's an aggressive strategy design for the Collective Risk Dilemma repeated game, focusing on dominance, exploitation, and forcing cooperation from others while maximizing own payoff.

---

### Aggressive Strategy Overview

- **Aggression mindset:** 
  - Exploit cooperators to maximize your payoff.
  - Force others to carry the burden of cooperation while you defect as often as possible.
  - Punish non-cooperators minimally to keep your advantage.
  - Use last round defection to extract maximum payoff, knowing no retaliation follows.

---

### Key Intuition

- In any round where others cooperate at or beyond threshold **m**, defecting yields a higher payoff (keep endowment + reward).
- Aggressively defect at all rounds except when pressure to cooperate is absolutely necessary.
- Use history of actions to track if enough players tend to cooperate (or to try to trigger cooperation by occasional cooperation).
- Defect in the last round always (no incentive for cooperation).

---

### Detailed Decision Rules

#### Notation:

- Let **t** = current round (1 to r)
- Let **c_t** = number of players who cooperated in round t (observed at the end of round)
- Let **threshold = m** (minimum cooperators needed)
- Let **endowment cost = 1**
- Let **reward multiplier = k > 1**

---

### Pseudocode Outline

```python
# Parameters: n, r, m, k
# History of rounds stored: actions_hist = list of lists of actions by all players
# At round t, strategy observes full previous rounds: actions_hist[0..t-1]

def aggressive_strategy(t, actions_hist, n, r, m, k, player_index):
    
    # Round 1 (no history)
    if t == 1:
        # Aggressive start: Defect first to observe others' willingness to cooperate
        return 'D'
    
    # In subsequent rounds (2 to r-1)
    else:  
        # Compute cooperation statistics from previous round
        prev_round = actions_hist[t-2]  # actions of all players in last round
        prev_cooperators = sum(1 for a in prev_round if a == 'C')
        
        # If in previous round enough cooperators (>= m):
        if prev_cooperators >= m:
            # Defect to maximize payoff (exploit cooperators who paid cost)
            return 'D'
        
        else:
            # Previous round failed threshold
            
            # To try to enforce cooperation and avoid low payoffs,
            # show a minimal cooperation "signal" by cooperating every 3rd round
            if t % 3 == 0:
                return 'C'
            else:
                # Otherwise defect to save cost and pressure others
                return 'D'

    # Last round (t == r)
    # Always defect because no future punishment possible
    if t == r:
        return 'D'
```

---

### Explanation of the Rules

- **Round 1: Defect immediately.**  
  You test the waters. Let others bear cost if they want to cooperate. You avoid risk on the first round.

- **Rounds 2 to r-1: React to previous round outcomes:**  
  - If enough players cooperated last round, defect to exploit the reward while avoiding cost.  
  - If cooperation threshold was not met, occasionally cooperate every 3rd round (round 3, 6, 9...) to signal willingness to cooperate and potentially trigger cooperation from others, but mostly defect. This keeps you from becoming a pure "free rider" that others might punish collectively and keeps some leverage.  
  - Aggressive defect majority of the time, forcing others to carry cooperation burden.

- **Last round (round r):**  
  - Defect no matter what. No incentive to cooperate since no future rounds and retaliation is impossible.

---

### Edge Cases Handling

- **If m is very close to n (like m = n-1):**  
  Exploiting cooperators may be harder. Still apply same rules; defect first round, try minimal cooperation signaling. May get stuck in mutual defection but default to defect.

- **If k is very high:**  
  The reward for cooperation is big, but defecting while others cooperate is even better. This strategy derives advantage by exploiting that.

- **If history shows chronic failure to meet threshold:**  
  Keep occasional cooperation to test for cooperation emergence; if none emerges, mostly defect to maximize private payoffs.

---

### Summary

This aggressive strategy exploits cooperation by defecting whenever the threshold is reached, applies minimal cooperation signals to keep opponents from completely abandoning cooperation, and always defects last round to capture maximal payoff without risk.

It balances aggression with minimal cooperation as a strategic tool, leveraging knowledge of past rounds for adaptive exploitation.

---

If you'd like, I can help draft a more formal algorithm or suggest ways to improve robustness.
'''

description_AGGRESSIVE_80 = '''
Here is an aggressive strategy for the Collective Risk Dilemma, designed to maximize individual payoff by exploiting predictable cooperation but still ensuring threshold achievement when necessary to obtain the reward.

---

### Strategy Name: **Threshold Enforcer with Exploitative Defection**

---

### Principles

- **Aggressive mindset:** Prioritize defecting to gain the private payoff (1) plus the reward (k) when threshold cooperation is met by others.
- **Enforce the threshold:** If threshold cooperation fails repeatedly, switch to cooperation to ensure threshold is met in future rounds—this protects against losing the reward.
- **Punish free-riding attempts:** If you observe others defecting too much and threshold is not met, punish by cooperating more to force the threshold, reducing free riders’ gains.
- **Exploit in early rounds:** Start by defecting to test others’ willingness to cooperate and gain maximum payoff if threshold is met regardless.
- **Secure reward in last rounds:** Avoid risking no reward in final stages; cooperate if necessary to meet the threshold.

---

### Detailed Decision Rules

---

#### Initialization

- Round 1: **Defect**
  - Rationale: Gain maximum private payoff initially; test others’ willingness to cooperate.

---

#### For Rounds 2 to r-1: Adaptive Exploit-Condition

At the start of each round t (2 ≤ t < r):

1. **Check previous round t-1 results:**

   Let:
   - \( C_{t-1} \) = number of players cooperating in round t-1
   - \( thresholdMet_{t-1} = (C_{t-1} \ge m) \)

2. **If thresholdMet_{t-1} = True:**

   - **If I cooperated last round:**
     - I may have been exploited (others freeriding).
     - Defect to maximize payoff this round (exploit the cooperators).
   
   - **Else (I defected last round):**
     - Keep defecting (free ride on the cooperators’ investment).

3. **If thresholdMet_{t-1} = False:**

   - Cooperation failed last round; risk of losing reward.
   - **Cooperate this round** to help reach threshold.

---

#### Round r (last round):

- If threshold was met in round r-1:
  - Defect to maximize own payoff (exploit any last-round cooperators).
- Else:
  - Cooperate to try to meet threshold and get reward for last round.

---

### Edge Cases

- **Repeated threshold failures:**

  If threshold is not met for 2 or more consecutive rounds, cooperate every round until threshold is met again, then revert to exploiting.

- **If \(m\) is very close to \(n\) (e.g., \(m=n-1\))**

  Defect aggressively until threshold fails, then cooperate to secure the threshold.

- **If \(k\) is just above 1 (low reward)**

  More likely to defect unless threshold failure occurs, since benefit of cooperation is smaller.

---

### Pseudocode

```python
# Inputs: n, r, m, k
# At round t (1-based indexing), with memory of history:
# history_actions = list of list of players' actions in previous rounds [[a_1^1, a_2^1, ..., a_n^1], ..., [a_1^{t-1}, ..., a_n^{t-1}]]

def decide_action(t, history_actions):
    
    if t == 1:
        # Start aggressive: defect
        return 'D'
    
    # Calculate number cooperators in last round
    last_round_actions = history_actions[-1]
    C_last = last_round_actions.count('C')
    threshold_met_last = (C_last >= m)
    
    # Count consecutive failures to meet threshold ending at last round
    consecutive_failures = 0
    for round_actions in reversed(history_actions):
        if round_actions.count('C') < m:
            consecutive_failures += 1
        else:
            break
    
    # Last round logic
    if t == r:
        if threshold_met_last:
            # Exploit last round cooperators
            return 'D'
        else:
            # Cooperate to try to meet threshold last round
            return 'C'
    
    # If consecutive threshold failures >= 2, enforce cooperation
    if consecutive_failures >= 2:
        return 'C'
    
    if threshold_met_last:
        # Threshold met last round
        
        # Did I cooperate last round?
        my_last_action = history_actions[-1][my_index]
        
        if my_last_action == 'C':
            # I was exploited; defect now
            return 'D'
        else:
            # Keep defecting and exploiting cooperators
            return 'D'
    else:
        # Threshold missed last round; cooperate to push threshold
        return 'C'
```

---

### Explanation

- **Round 1:** Defect, since no penalty or reason to cooperate immediately and want to glean private payoff.
- **If threshold met last round:** Aggressively defect for maximum reward + private payoff.
- **If threshold missed last round:** Cooperate to help push threshold back over \( m \) to avoid missing the group reward.
- **Punish persistent free riding:** If threshold fails multiple rounds, stay cooperative to enforce threshold is met.
- **Final round:** Attempt to exploit if threshold was met previously; cooperate to try reaching threshold if it was not.

---

This strategy maximizes aggressive defection when others cooperate, ensures threshold is met often enough to get the reward consistently, and punishes continual failures by enforcing cooperation.

---

If all players tried to implement this strategy:

- They would collectively defect initially.
- Some would switch to cooperation when the reward fails.
- Over time, oscillations might occur, but threshold will be generally maintained by enforced cooperation.
- Your defection when threshold is met yields maximal payoff, fulfilling the aggressive objective.
'''

description_AGGRESSIVE_81 = '''
**Aggressive Strategy for Collective Risk Dilemma**

---

### Strategic Rationale (Aggressive Mindset)

- Aim: Maximize personal payoff, even at the risk of undermining collective cooperation.
- Exploit cooperative players by defecting when threshold is likely met.
- Ensure threshold is met only when it benefits me to free-ride.
- Do not waste cooperation when threshold is unlikely to be met.
- Punish cooperators who try to enforce cooperation by never reliably cooperating early.
- On the last round, defect to maximize payoff without fear of retaliation.

---

### Decision Rules

Let:
- `n` = total players
- `m` = minimum cooperators needed
- `r` = total rounds
- `t` = current round (1-based)
- `past_actions[j][τ]` = player j’s action on round τ (C or D), for j in 1..n, τ in 1..t-1
- `past_cooperation_count[τ]` = count of cooperators in round τ

We only observe past rounds (no future info).

---

### Step 1: Initialization and Key Observations

- Initial assumption: Other players may cooperate early to reach threshold.
- The key exploitation is to defect once threshold appears met.
- Aggressive defection is preferable if threshold is unlikely or cannot be guaranteed.
- Use the history of cooperation to estimate opponents' willingness.

---

### Step 2: Cooperation Defection Logic by Round

#### First Round (t = 1):

- **Defect** outright.

**Justification:**  
You want to test if others will cooperate to reach threshold without your help. Nobody has cooperated yet; no incentive to be passive loser.

---

#### Intermediate Rounds (2 ≤ t < r):

- Calculate `E_t`: estimated number of cooperators excluding yourself, based on past rounds.

- For estimation, aggregate last `w` rounds (e.g., `w=3` or all past rounds):

  ```pseudo
  E_t = average count of cooperators in past rounds - (your own cooperation if any)
  ```

- **If (E_t + 1) ≥ m:**

  - **Defect**

  - Rationale: Others are cooperating enough; free ride for higher payoff.

- **Else**:

  - Defect **unless** `t` is quite early (say t=2), then cooperate once to test if threshold can be reached.

  - But to keep aggressive, mostly **Defect**.

---

#### Last Round (t = r):

- **Defect**

**Justification:**  
No future retaliation possible, maximize individual payoff now.

---

### Step 3: Handling Edge Cases

- If threshold seems unachievable for many rounds (e.g. cooperation count < m-1 consistently), always defect.

- If threshold exceeded consistently but you cannot ensure free-ride (others cooperate <= m-1), cooperate only if:

  - You can achieve threshold by cooperating and others will not, thus secure reward is won.

- However, aggressive mindset favors defect in uncertainty to avoid certain cooperation cost.

---

### Summary Pseudocode Version

```pseudo
function decide_action(t, past_actions):

    if t == 1:
        return D  # Start aggressively by defecting

    if t == r:
        return D  # Last round defect to maximize payoff

    # Calculate estimated average cooperators excluding self over past rounds
    coop_counts = []
    for τ in 1 to t-1:
        count = number of players cooperating in round τ
        if you cooperated in τ:
            count -= 1
        coop_counts.append(count)
    E_t = average(coop_counts)

    # Aggressive threshold logic
    if E_t + 1 >= m:
        # Others cooperate enough to meet threshold with you defecting
        return D  # Free-ride

    # Early rounds exception (optional)
    if t == 2:
        # Test cooperation once to check if threshold reachable
        return C

    # Otherwise defect aggressively
    return D
```

---

### Additional Notes

- This strategy is **aggressive because**:

  - It never "wastes" cooperation unless testing in round 2.

  - It free-rides whenever threshold is expected to be met.

  - It defects on first and last round for maximum individual gain.

  - It punishes overly cooperative opponents by refusing to reliably cooperate.

- Over repeated rounds, it tries to estimate cooperation trends without trusting others.

- Designed to maximize personal payoff at cost of group risk.

---

**This aggressive stance should outperform more cooperative strategies in tournament play by consistently exploiting cooperators and minimizing personal cooperation costs.**
'''

description_AGGRESSIVE_82 = '''
Here is an aggressive strategy designed for the repeated Collective Risk Dilemma, aiming to maximize individual payoff through strategic defection while exploiting the threshold mechanism.

---

## Strategy Overview: "Threshold Exploiter"

This strategy aggressively defects as much as possible while still ensuring the minimum number of cooperators (m) is met each round—preferably by *others*. The player rarely cooperates unless absolutely necessary to trigger or maintain the threshold reward. The rationale is to maximize private payoffs by defecting but still reap the collective reward when it arises.

---

## Decision Rules

### Round 1 (Initialization)

- **Action:** Defect (D)

**Reason:** Start aggressively by defecting to test opponents’ willingness to cooperate and to avoid wasted contribution. No prior information exists to justify cooperating.

---

### Rounds 2 to r-1 (Core rounds)

- **After observing the previous round’s actions and payoffs:**

  1. **Count the number of cooperators in the previous round, call it c_prev.**

  2. **If c_prev ≥ m:**  
     - The threshold was met last round, so the reward was given.  
     - Since other players cooperated enough, **Defect (D)** this round to gain the private benefit plus the reward from other cooperators.  
     - Rationale: Free-ride on others' cooperation.

  3. **If c_prev = m - 1:**  
     - Threshold was *not* met last round (missing one cooperator).  
     - Cooperators are barely missing the reward.  
     - **Cooperate (C)** this round *if and only if* defecting would cause the threshold to fail *again* (see below), else defect (D).

     How to know if you are critical cooperator this round?  
     - Since you cannot know *who* will cooperate this round, but can infer from past.  
     - If in past rounds the threshold was missed by one, and you defected, you should switch to cooperate to try to push it over.

  4. **If c_prev < m - 1:**  
     - Threshold missed by more than one cooperator; players are clearly not cooperating enough.  
     - **Defect (D)** to maximize private payoff since reward won’t be given anyway.

---

### Last Round (Round r)

- **Action:** Defect (D)

**Reason:** No future retaliation is possible, so unilaterally defect to maximize last-round payoff regardless of the threshold.

---

## Summary of Aggression

- Maximize defection whenever reward is achievable without you cooperating.
- Minimal cooperation only when threshold misses by exactly one cooperator in previous round, and your cooperation is essential.
- Always defect first and last rounds.
- Exploit cooperative behavior of others while minimizing own contributions.

---

## Pseudocode

```python
# Parameters (known)
n, r, m, k

# Inputs per round:
# prev_actions: list of players' actions last round (C/D)
# round_number: current round index (1-based)

def decide_action(prev_actions, round_number):
    if round_number == 1:
        # Round 1: defect aggressively
        return 'D'

    if round_number == r:
        # Last round: defect, no future consequences
        return 'D'

    # Count cooperators last round
    c_prev = prev_actions.count('C')

    if c_prev >= m:
        # Threshold met previously, free ride
        return 'D'

    elif c_prev == m - 1:
        # Threshold missed by one, check if cooperating is critical

        # If I defected last round, now I must cooperate to try to push threshold
        # Need to know my own last action. For that, assume accessible as prev_actions[player_index]
        # For generality, assume function argument 'my_last_action' provided.

        # Here’s a simplified logic assuming knowing own previous action:
        if my_last_action == 'D':
            return 'C'  # switch to cooperating to help push threshold over
        else:
            # Already cooperating, keep cooperating
            return 'C'

    else:
        # Threshold missed heavily — no incentive to cooperate
        return 'D'
```

---

## Additional Considerations

- **Memory:** The strategy only looks back one round; it can be extended to recognize stable patterns or detect consistent cooperators to exploit better.

- **Ties in cooperation count:** When threshold is missed by one, the player switches to cooperate *only when last round they defected*; so multiple players may switch, but repeated defection by some avoids guaranteeing over-cooperation.

- **Reputation/Deterrence:** The aggressive approach risks the group not cooperating if everyone defects. But since you exploit only when others cooperate, you maximize personal gain in a mixed environment.

---

This aggressive strategy exploits other players' cooperativeness, defects whenever possible without losing the reward, and cooperates minimally, only to prevent loss of the collective reward in borderline cases. It ends aggressively by defecting on the final round with no fear of reprisal.
'''

description_AGGRESSIVE_83 = '''
Here's an aggressive strategy for the Collective Risk Dilemma, designed to maximize individual payoff at the potential cost of group welfare. It exploits cooperation when it benefits you most, but defects otherwise to capture higher payoffs from others' cooperations.

---

### Strategy Name: **Opportunistic Defector**

---

## Intuition:

- Cooperate *only* when enough others are likely to do so, to secure the collective reward and still preserve your advantage.
- Defect otherwise, especially when the threshold is unlikely to be met or near the last round to maximize your private gain.
- Use information from previous rounds to identify and free-ride on consistent cooperators.
- Aggressively defect in the last round to grab the highest private payoff if cooperation is uncertain.

---

## Parameters and Variables:

- **n, r, m, k** as per game spec.
- Let **t** be current round (1 ≤ t ≤ r)
- Let **coop_count_prev** = number of players who cooperated in the previous round (for t > 1)
- Keep track of players who cooperated consistently in previous rounds.
- Threshold marginal advantage: you defect unless probability that total cooperators ≥ m is sufficiently high that reward outweighs cost.

---

## Decision Rules:

### Round 1 (no history):

- Cooperate if and only if **m ≤ n - 1** (i.e. threshold can be met if most others cooperate).
- Otherwise, defect outright.
- Rationale: Try cooperation only if reasonable chance others will meet threshold; else defect aggressively.

### Rounds 2 to r-1:

- Observe actions last round:
  - Calculate **coop_count_prev**.
  - If coop_count_prev ≥ m (threshold met last round), cooperate only if you cooperated last round (join existing contributors).
  - Else defect to free-ride on others or avoid sunk cost.

- If you defected last round and threshold was met:
  - Continue to defect to exploit cooperators.
- If you cooperated last round but threshold was not met:
  - Defect now to cut losses.
- If threshold *barely met* last round (coop_count_prev = m), cooperate to maintain reward, else defect.

### Last Round (t = r):

- Defect always.
- Reasoning: No future to incentivize cooperation and defecting gains you maximal payoff if others cooperate.

---

## Edge Cases Handling:

- If the threshold m is very close to n (e.g., m = n - 1), cooperate only if you detected steady cooperation in previous rounds.
- If threshold is low, chance of cooperative return higher, more incentive to cooperate early rounds.
- If opponents appear to defect consistently, switch to all-out defection.
- If at any round the number of cooperators < (m - 1) and you didn't cooperate, defect as the threshold cannot be met.

---

## Pseudocode:

```python
def decide_action(t, history, params):
    n, r, m, k = params
    # history: list of tuples per round: [(player_actions), (player_payoffs)]
    # player_actions: list of length n, with 'C' or 'D'

    if t == 1:
        # No history, cooperate only if threshold allows plausible cooperation
        if m <= n - 1:
            return 'C'
        else:
            return 'D'

    # From round 2 onwards
    prev_actions = history[t-2][0]  # actions at round t-1
    coop_count_prev = prev_actions.count('C')
    i_action_prev = prev_actions[self_index]

    # Last round: always defect
    if t == r:
        return 'D'

    if coop_count_prev < m:
        # Threshold missed last round
        # If I cooperated last round, defect now to cut losses
        if i_action_prev == 'C':
            return 'D'
        else:
            # Keep defecting - threshold not met anyway
            return 'D'
    else:
        # Threshold met last round
        if i_action_prev == 'C':
            # Keep cooperating to maintain reward
            # But if coop_count_prev == m, cooperate to maintain threshold
            return 'C'
        else:
            # Free-ride by defecting again - aggressive defecting while others bear cost
            return 'D'
```

---

## Summary:

- **First round:** Cooperate only if threshold is not nearly equal to total players (m ≤ n - 1).
- **Middle rounds:** If threshold met last round and you cooperated, keep cooperating. If you defected, continue defecting to free-ride. If threshold missed and you cooperated, defect now.
- **Last round:** Always defect to maximize individual payoff, no future penalty.
- Aggressively exploit cooperators and abandon cooperation if it appears futile.
- Uses history to identify cooperation stability and optimizes defection accordingly.

---

This strategy aggressively pursues maximizing your payoff by defecting as much as possible, cooperating only when it yields a guaranteed reward and when you have "skin in the game." It punishes unreliable cooperators by withdrawing cooperation and defects relentlessly on the last round.
'''

description_AGGRESSIVE_84 = '''
**Aggressive Strategy for the Collective Risk Dilemma**

---

### Strategy Overview

- **Aggressiveness:** Prioritize maximizing personal payoff by exploiting cooperation from others while minimizing own cooperation cost.
- **Goal:** Defect as frequently as possible without risking the threshold *m* not being met, so that the reward *k* is always secured.
- **Key idea:**  
  - Cooperate only just enough to ensure threshold *m* cooperators, exploiting others' tendency to cooperate to secure the reward.
  - Defect otherwise, especially later in the game once opponent behaviors are clearer.
  - Use early rounds to test opponent cooperativeness, then adjust.

---

### Detailed Decision Rules

- **First round (t=1):**  
  - Cooperate if and only if *(m - 1) > 0* (i.e., if threshold m > 1, cooperate to help reach it).  
  - Reason: Start aggressively but minimally cooperative to signal potential cooperation and avoid immediate risk of losing reward.

- **From round 2 to round r-1:**  
  - Count the number of cooperating opponents in the *previous round* as *C_{t-1}*.
  - Predict the number of cooperators in current round if you defect as *C_{t-1}* (assuming others don't change behavior drastically).
  - **If C_{t-1} ≥ m:**  
    - Defect aggressively (contribute nothing) to gain payoff (1 + k), exploiting others' cooperation.
  - **If C_{t-1} = m - 1:**  
    - Cooperate to lift total cooperators to m and secure reward.
  - **If C_{t-1} < m - 1:**  
    - Cooperate aggressively only if defecting this round risks falling below m and losing the reward (fallback).  
    - Otherwise, defect to maximize short term gain, accepting potential no reward.
    
- **Final round (t = r):**  
  - Always defect if you can, unless defecting means total cooperators drop below m → then cooperate to secure reward in final payout.
  
---

### Edge cases handling and clarifications

- **If m = 1:**  
  - Always defect after first round because only one cooperator needed and others will usually cooperate early on.
- **If number of players n and threshold m are close (e.g. n=m+1):**  
  - Cooperate more actively to ensure reward is won.
- **If against fully defective group (all defecting initially):**  
  - Switch to always defect (no reason to cooperate if no one else does and reward can't be won).
- **If opponents fluctuate behavior drastically:**  
  - Use a conservative fallback — cooperate if defecting risks losing reward.
- **Tie-breaking:**  
  - When indifferent, choose to defect to maximize payoff.

---

### Pseudocode Summary

```python
Parameters: n, r, m, k
Input: For each round t, observe opponents' actions prev_actions (list length n-1)

for t in 1 to r:
    if t == 1:
        if m > 1:
            action = C  # cooperate minimally to approach threshold
        else:
            action = D  # defect when only one cooperator needed
    else:
        C_prev = count_cooperators(prev_actions)
        
        # Predict cooperators this round if defect
        predicted_cooperators = C_prev
        
        if predicted_cooperators >= m:
            # Safe to defect, exploit others
            action = D
        elif predicted_cooperators == m - 1:
            # Need to cooperate to reach threshold
            action = C
        else:  # predicted_cooperators < m - 1
            # Risk of no reward: cooperate only if defect would cause losing reward
            # Since it's aggressive, defect if possible
            if predicted_cooperators + 1 >= m:
                action = C
            else:
                action = D
                
    # Special final round logic
    if t == r:
        C_prev = count_cooperators(prev_actions)
        if action == D and C_prev < m:
            action = C  # cooperate to secure final reward if possible

    play(action)
```

---

### Summary

- **First round:** minimal cooperation to test/respond.
- **Mid rounds:** defect aggressively if safe, cooperate when needed to maintain reward.
- **Last round:** defect unless cooperation required to secure reward.
- **Always exploit others' cooperation but adjust to avoid losing the collective reward.**

This strategy is aggressive because it tries to free-ride on others' cooperations as much as possible, cooperates only as a self-interested fallback to secure the shared reward whenever strictly necessary.
'''

description_AGGRESSIVE_85 = '''
Here is a detailed aggressive strategy tailored for the Collective Risk Dilemma game:

---

### Strategy Name: **"Threshold Hijacker"**

---

### Core Idea

Be aggressive by leveraging others’ cooperation to defect when the threshold is met, securing higher payoffs, but aggressively punish under-cooperation by defecting to avoid being the sucker. In particular:

- **Always defect in the first round** to test the waters and gather observational data, exploiting naiveté.
- In subsequent rounds, **defect as long as enough others cooperate to reach or exceed the threshold**, capturing the reward without paying the cost.
- **Cooperate only if the risk of an under-cooperation collective failure is imminent based on last round’s cooperation counts**, thereby forcing the minimum cooperation you need to keep the threshold reached, but never more.
- On the **last round**, defect if the threshold was consistently met before; cooperate only if cooperation last round failed to reach the threshold (to possibly secure a final minimum cooperation fallback).
  
This sets you as a clear free-rider exploiting cooperative behavior but with willingness to cooperate just enough to keep the collective gain alive when absolutely necessary — an aggressive mixed exploit-punish pattern.

---

### Notation

- Let \( C_t \) = number of cooperators observed in round \( t \).
- Your action in round \( t \) = \( a_t \in \{C, D\} \).
- Game parameters are known: \( n, r, m, k \).

---

### Decision Rules

**Round 1 (t=1):**

- \( a_1 := D \)  *(defect immediately, to exploit naive players)*

**For rounds t = 2 to r-1:**

- If \( C_{t-1} \ge m \) (threshold met last round):

  - Defect this round \( a_t := D \) to maximize private payoff, free ride on others’ cooperation.

- Else (threshold not met last round):

  - Cooperate this round \( a_t := C \) to try to recover the threshold and avoid losing the reward.

**Round r (last round):**

- If at any point \( C_{t} < m \) in prior rounds (threshold failed at least once):

  - Cooperate this last round \( a_r := C \) to maximize last round chance of reaching threshold.

- Else (threshold always met before last round):

  - Defect \( a_r := D \), harvesting maximum last round payoff from others’ cooperation.

---

### Pseudocode

```
For t in 1 to r:
    If t == 1:
        action = D
    Else if t == r:
        if any round τ < r had C_τ < m:
            action = C
        else:
            action = D
    Else:
        if C_{t-1} >= m:
            action = D
        else:
            action = C
    Play action
```

---

### Intuition and Justification

- **First round defection** is aggressive exploitation—no cost to you, testing others’ willingness to cooperate.
- **Defecting when threshold met last round** maximizes individual gain while free-riding because the reward \( k \) is a public good once threshold \( m \) is hit.
- **Only cooperating when threshold failed last round** to attempt recovery is minimal concession to maintaining the reward flow — reduces unnecessary cooperation cost.
- **Last round defection if threshold always maintained before** maximizes final payoff extraction without further cooperation.
- **Last round cooperation if threshold failure observed** aims to capture last moment cooperative reward for oneself, aggressive but rational sacrifice.
- The strategy aggressively **skews payoff in your favor by exploiting cooperators without initiating cooperation yourself beyond recovery**.

---

### Edge Case Handling

- **If opponents start all defecting**: You keep defecting → stable payoff 1 each round, no loss.
- **If enough opponents cooperate persistently**: you always free ride → maximum payoff (1 + k) every round except first (where you defect anyway).
- **If cooperation fluctuates**: you cooperate minimally only after failures to keep threshold just met, limiting your cost.
- No communication needed, only observed counts from previous rounds.
- Relies on perfect memory of last round cooperation counts.

---

### Summary

This aggressive strategy exploits the collective risk dilemma’s public good nature by free riding when possible and cooperating only to the exact extent necessary to maintain collective thresholds, starting with an unsurprised zero-cooperation defection round and finishing with last-round exploitation.

---

If you want, I can also suggest extensions to handle noisy or surprisingly noisy opponent behavior or incorporate reputation signals, but for the pure aggressive mindset this design fits the bill.
'''

description_AGGRESSIVE_86 = '''
**Aggressive Strategy for Collective Risk Dilemma**

---

### Strategic Philosophy

The aim of this aggressive strategy is to maximize **individual payoff** by exploiting the cooperative actions of others wherever possible and defecting unless cooperation is strictly necessary to reach the threshold to secure the reward **k**. The core of aggression here lies in **free-riding** on others’ cooperation while minimizing own contribution, thereby obtaining higher payoffs than cooperators.

---

### Key Insights from the Payoff Matrix

- Defecting when threshold is met gives payoff: 1 (keep endowment) + k (reward) = 1+k
- Cooperating when threshold is met gives payoff: 0 + k = k
- Defecting when threshold is not met gives payoff: 1 + 0 = 1
- Cooperating when threshold is not met gives payoff: 0

Defecting yields strictly better payoff than cooperating *if* threshold is met, and cooperating only benefits if it helps reach threshold.

---

### Decision Rules Overview

1. **First Round:**
   - Defect, unless you predict this will cause threshold failure.
2. **Subsequent Rounds:**
   - Cooperate *only if* the count of known cooperators from previous rounds is close to threshold (m).
   - Otherwise defect.
3. **Last Round:**
   - Cooperate only if defecting would drop total cooperators below m and you would lose reward payoff.
   - Otherwise defect aggressively.
4. **Dynamic adjustment:**
   - Track cooperation counts from previous rounds.
   - If others tend to defect, defect more frequently to maximize payoff.
   - If threshold is consistently met without your cooperation, defect to free-ride.

---

### Detailed Rules

---

#### Variables Tracked

- `prev_cooperators_count` = number of players who cooperated in last round.
- `estimated_cooperators` = estimated number of cooperators this round based on past behavior.
- `round` = current round index ∈ [1..r]
- `must_cooperate` = boolean flag signaling if cooperation is strictly needed this round.

---

#### Pseudocode

```
function aggressive_strategy(round, prev_cooperators_count, n, m, k, r):

  // 1. First Round (no past info)
  if round == 1:
    // Defect and observe others; players tend to cooperate early?
    return Defect

  // 2. Subsequent rounds (2 <= round < r)
  else if round < r:
    // Estimate cooperators excluding self:
    est_coop_without_me = prev_cooperators_count

    // If threshold is already met without you:
    if est_coop_without_me >= m:
      // Free-ride by defecting aggressively
      return Defect
    else if est_coop_without_me == m - 1:
      // Crucial to cooperate to reach threshold
      return Cooperate
    else:
      // Not close to threshold, defect to maximize payoff
      return Defect

  // 3. Last round (round == r)
  else:
    est_coop_without_me = prev_cooperators_count

    if est_coop_without_me >= m:
      // Threshold met without cooperation; defect for max payoff
      return Defect
    else if est_coop_without_me == m - 1:
      // Cooperate to secure last round reward
      return Cooperate
    else:
      // Cooperation futile, defect
      return Defect
```

---

### Explanation of Aggressiveness

- **First round defect:** Assume threshold likely unmet; do not waste endowment.
- **Free-riding:** Defect whenever threshold can be met without you.
- **Selective cooperation:** Only cooperate if your action is pivotal to reach threshold; otherwise exploit.
- **No communication signals:** Do not try to build trust/cooperation beyond what is strictly necessary.
- **Last round careful:** Cooperate only if absolutely necessary; otherwise defect and maximize final payoffs.
- **Punish Cooperation:** Never cooperate out of goodwill; only do so when payoff strictly demands it.

---

### Edge Cases

- If `m` is close to `n` (e.g., m = n-1), cooperation needed almost always; strategy still defects unless pivotal.
- If `k` is very large, cooperation might pay off more; still, do not cooperate without being needed.
- If in any previous round threshold failed with many defectors, strategy maintains defect stance — no sympathy.
- If opponents show stable cooperation above threshold without you, free-ride indefinitely.

---

### Summary

| Round       | Condition                              | Action     |
|-------------|--------------------------------------|------------|
| 1           | No info                              | Defect     |
| Middle (2..r-1) | Threshold met without you           | Defect     |
| Middle (2..r-1) | Threshold just missed by 1 (needed) | Cooperate  |
| Middle (2..r-1) | Threshold far from being met        | Defect     |
| Last (r)      | Threshold met without you           | Defect     |
| Last (r)      | Threshold just missed by 1          | Cooperate  |
| Last (r)      | Threshold far missed                 | Defect     |

This aggressive strategy aims to **maximize personal payoff at the expense of cooperators**, relying critically on full information and observation, refusing to risk own endowment unless payoff strictly demands.

---

If you want, I can help break down or formalize this further for implementation.
'''

description_AGGRESSIVE_87 = '''
Below is a strategy designed to be *aggressive* in the Collective Risk Dilemma, emphasizing exploitation and dominance, leveraging the repeated nature of the game and perfect observability while minimizing concessions.

---

### Aggressive Strategy: "Threshold Opportunist Exploiter"

**Goal:**  
Maximize personal payoff by defecting whenever safe, cooperate only to trigger the group reward when necessary to avoid failure. Exploit cooperators by free-riding once threshold is met, coerce others to cooperate by refusing to contribute unless forced.

---

### Key Ideas

- **Defect by default:** Aggressively choose D in all rounds unless cooperation is absolutely necessary to avoid the group failing to reach threshold.
- **Trigger minimal cooperation:** Cooperate only in rounds where without own cooperation, threshold will not be reached, thus ensuring others bear the cost.
- **Last round defection:** Defect in the last round no matter what, as no future retaliation is possible.
- **Punish excessive cooperation:** If others cooperate more than necessary, keep defecting to exploit.
- **Observation driven:** Use perfect information on others’ past cooperation to estimate likely cooperators per round.
- **Avoid unilateral cooperation:** Never cooperate alone.

---

### Decision Rules

Let:  
- \( t \in \{1, ..., r\} \) be current round  
- \( C_{-i,t} \) = number of cooperators excluding self in round \( t \)  
- \( \hat{C}_{-i,t} \) = expected/cooperative count of others based on past history (if needed, can use last round's count as estimate)  
- \( m \) = cooperation threshold

---

#### Round 1 (No history)

- Assume others defect by default (worst case).  
- Estimate \( C_{-i,1} = 0 \).  
- Since threshold \( m > 1 \), 0 cooperators without you means threshold likely not met.  
- **Cooperate only if you *must* to push over the threshold; else defect.**  
- Since no observations yet and no coordination, **defect by default** in round 1 — you gamble on others being scared to cooperate.

---

#### Rounds 2 to r-1

- Based on observed actions of round \( t-1 \), estimate \( C_{-i,t} \) as \( C_{-i,t-1} \).  
- **If \( C_{-i,t} \geq m \):** defect. Others cooperate enough, no need to pay cost. Enjoy free-riding bonus \( k \).  
- **If \( C_{-i,t} = m - 1 \):** cooperate to push total cooperators to threshold \( m \), securing reward \( k \).  
- **If \( C_{-i,t} < m - 1 \):** defect. Let others fail — you avoid cost, possibly receive only baseline 1. Risk is others also lose \( k \), but aggressive stance is to not subsidize cooperation.  
- This enforces an aggressive "threshold punisher" attitude: only help if absolutely the last needed cooperator.

---

#### Last Round \( t = r \)

- No future rounds for retaliation or reward management.  
- **Always defect.**  
- The rational aggressive move is to save cost here regardless of threshold, accept potential loss of \( k \) rather than paying cost 1.

---

### Summary in Pseudocode

```python
def aggressive_decision(t, r, m, history_actions):
    """
    history_actions: List of length t-1 containing lists of actions by other players at each past round
    Action set: "C" or "D"
    """

    if t == 1:
        # No history, defect aggressively
        return "D"

    if t == r:
        # Last round, always defect
        return "D"

    # Estimate number of cooperators excluding self from previous round
    last_round_actions = history_actions[-1]
    C_minus_i = sum(1 for a in last_round_actions if a == "C")

    if C_minus_i >= m:
        # Enough cooperators already, defect to exploit
        return "D"

    if C_minus_i == m - 1:
        # Just one cooperator short to reach threshold, cooperate to push over threshold
        return "C"

    # Otherwise, defect to free ride or cause failure
    return "D"
```

---

### Rationale and Aggressiveness

- **Minimal cooperation:** Only cooperate when your single cooperation changes group payoff from 0 to \( k \).  
- **Free-riding:** When threshold met without you, defect to maximize private payoff.  
- **Punishment by omission:** Refuse cooperation otherwise, forcing others to pay costs alone or lose reward.  
- **Last round defection:** Purely selfish final move to avoid cost.  
- **Risk-tolerant:** Accept rounds where threshold is missed if you’re not instrumental in failing to cooperate (i.e., when fewer than \( m-1 \) others cooperate).

---

### Edge Cases

- **If \( m = n-1 \):** Your cooperation almost always necessary — strategy still holds.  
- **If others cooperate unpredictably:** You adjust cooperation based on last round's cooperation count, exploiting their willingness.  
- **Symmetric opponents:** Strategy will tend to stabilize where some players cooperate exactly when needed, others defect — you seek to be a defector except when forced.

---

This strategy aggressively minimizes costly cooperation, exploits cooperators to maximize payoff, and leverages perfect recall and observation to decide when to invest. It is designed to dominate or at least do very well against naïve or non-aggressive opponents by free riding on their cooperation.
'''

description_AGGRESSIVE_88 = '''
**Aggressive Strategy for the Collective Risk Dilemma**

---

### Strategic Mindset

This approach aggressively pursues maximizing *individual payoffs* even if that means exploiting cooperators. The strategy aggressively defects (free-rides) whenever it can reliably profit from others' cooperation, but is willing to cooperate only to ensure the group reaches the threshold **m** when necessary — and only when that cooperation will itself increase immediate payoffs.

---

### Key Observations for Aggressive Play

- If at least **m** cooperators exist, defectors get the highest payoff per round:  
  Defector's payoff = 1 (keep endowment) + k (reward) = (1 + k)  
  Cooperator's payoff = 0 + k = k  
  → Defectors outperform cooperators.

- Aggressive players want to maintain just enough cooperation by others to reach the threshold, then defect to secure higher payoffs.

- Without cooperation reaching threshold, payoffs are minimal: everyone who defects gets 1, cooperators lose 1.

---

### Decision Rules Summary

| Round | Condition | Action | Reasoning |
|--------|-----------|--------|-----------|
| 1 (first round) | No past info, no trust yet | Cooperate | Burn one round’s endowment to try to trigger cooperation. |
| Intermediate rounds (2 .. r-1) | If previous round had ≥ m cooperators | Defect | Free-ride on others' cooperation to maximize payoff. |
| Intermediate rounds | Else if previous round had (m-1) cooperators and I cooperated last round | Cooperate | Act as the crucial "pivot" cooperator to push cooperation ≥ m to secure the reward. |
| Intermediate rounds | Else | Defect | Avoid cooperation cost if threshold unlikely to be reached. |
| Last round (round r) | If previous round had ≥ m cooperators | Defect | No future rounds, so exploit cooperation once more. |
| Last round | Else if previous round had (m-1) cooperators and I cooperated last round | Cooperate | Last chance to tip cooperation over m and gain reward. |
| Last round | Else | Defect | No incentive to cooperate when threshold unreached and no future penalties/benefits. |

---

### Detailed Explanation

1. **First Round Cooperation ("Shock" Cooperation):**  
   Since no history exists, the aggressive player cooperates once to seek triggering cooperation cycles by others or instigating a coordination attempt. This reduces the risk that everyone defects and no reward occurs (which provides minimal payoff).

2. **Subsequent Rounds Exploitation:**  
   - If threshold **m** was met last round, defect this round to exploit cooperators for maximum payoff.
   - If threshold was not met but just under it (i.e., there were **m-1** cooperators), and **you cooperated last round**, cooperate again to "nudge" the group over **m**, enabling the reward this round.
   - Otherwise defect to avoid costly cooperation where it won’t pay off.

3. **Last Round Behavior:**  
   Since there are no future repercussions, the last round repeats the logic: try to exploit cooperation if threshold met, or cooperate only if you can pivot the group over the threshold (and you cooperated last round).

   No incentive to cooperate otherwise, as there's no future to maintain reputation or encourage reciprocity.

---

### Pseudocode

```python
# Parameters accessible: n, r, m, k
# History accessible: actions_per_round = list of lists of player actions per round, indexed by round and player
# own_index = player’s own index (1-based)
# Current round t in [1..r]

def aggressive_strategy(t, own_index, actions_per_round):

    if t == 1:
        # First round: cooperate to start possibility of cooperation
        return 'C'

    prev_round_actions = actions_per_round[t-2]  # zero-based index

    num_cooperators_prev = prev_round_actions.count('C')
    cooperated_prev = (prev_round_actions[own_index - 1] == 'C')

    if t == r:
        # Last round: exploit if threshold met, else cooperate if can tip, else defect
        if num_cooperators_prev >= m:
            # Threshold met last round - defect to maximize payoff
            return 'D'
        elif num_cooperators_prev == m -1 and cooperated_prev:
            # Try to push threshold over by cooperating again
            return 'C'
        else:
            # No incentive to cooperate last round if threshold unlikely
            return 'D'

    else:
        # Intermediate rounds
        if num_cooperators_prev >= m:
            # Threshold met last round - defect to exploit
            return 'D'
        elif num_cooperators_prev == m -1 and cooperated_prev:
            # Act as pivot cooperator to push threshold over
            return 'C'
        else:
            # Otherwise defect and conserve endowment
            return 'D'
```

---

### Summary

| Situation                          | Action |
|----------------------------------|--------|
| Round 1                          | Cooperate (initiate) |
| Previous round had ≥ m cooperators | Defect (exploit) |
| Previous round had (m-1) cooperators AND you cooperated last round | Cooperate (pivot) |
| Otherwise                       | Defect (safe) |
| Last round repeats above logic without future rounds considerations |

---

### How This Is Aggressive

- Exploits cooperators by defecting whenever threshold met.
- Does *just enough* cooperation only to trigger or maintain threshold crossing by leveraging own cooperation role when pivotal.
- Avoids costly cooperation if not expected to affect threshold.
- Prioritizes maximizing per-round payoff over group welfare or reputation.

---

This strategy balances *occasional cooperation to maintain the reward* with frequent defection to maximize immediate individual gain, the hallmark of aggressive play in Collective Risk Dilemma.
'''

description_AGGRESSIVE_89 = '''
**Aggressive Strategy for Collective Risk Dilemma**

---

### High-Level Intuition

- As an aggressive player, you want to maximize your own payoff, exploiting other players’ cooperation while minimizing your own costs.
- The key leverage is the threshold \( m \): if enough other players cooperate, defectors get to enjoy the reward \( k \) without paying the cost.
- You seek to free-ride on others’ cooperation whenever it is predictable to occur.
- You try to push others to cooperate by defecting, threatening the group threshold and thus penalizing naive cooperators, but switch to cooperating only if necessary to avoid losing out on the reward entirely.
- You also exploit the repeated nature and perfect information to punish overly cooperative players who give you free payoffs.

---

### Parameters Recap

- \( n \): number of players
- \( r \): rounds
- \( m \): minimum cooperators needed to trigger reward \( k \)
- \( k > 1 \): reward multiplier
- Actions: C (cooperate), D (defect)
- Payoffs per round:  
  - Fewer than \( m \) cooperators: defectors and cooperators get 1-c if c=1 else 1  
  - \( m \) or more cooperators: cooperators get \( 0 + k = k \), defectors get \( 1 + k \)

---

### Aggressive Strategy Overview

| Round condition                 | Strategy behavior                              | Reasoning                                                      |
|-------------------------------|-----------------------------------------------|---------------------------------------------------------------|
| Round 1                       | Defect                                        | Try to exploit naive cooperators attempting to build trust    |
| Intermediate rounds           | Defect if confident threshold met (≥ m - 1 cooperators observed last round) else cooperate | Exploit expected cooperation, but help reach threshold if missing to gain reward  |
| Just below threshold          | Cooperate strategically to push reward        | Avoid losing reward if threshold nearly missed                 |
| Final round \(r\)             | Defect unless threshold unlikely without you  | No future punishment; maximize personal payoff                 |

---

### Decision Rules Detailed

**Notation:**
- Let \( C_{-i}^{t-1} \) = Number of other players cooperating in round \( t-1 \)
- Let \( t \) = current round (1 to \( r \))
- Threshold to reach for reward: \( m \)

---

#### Round 1 (No history)

- **Action:** Defect.

**Rationale:**  
No information, conserve own resources. Naive cooperators who cooperate in round 1 are prey to be exploited later.

---

#### Rounds \( 2 \leq t < r \) (Intermediate rounds)

- Observe \( C_{-i}^{t-1} \) — number of others who cooperated last round.

- If \( C_{-i}^{t-1} \geq m \),  
  **Action:** Defect.  
  **Reason:** Reward achieved without your cost; free-ride.

- Else if \( C_{-i}^{t-1} = m - 1 \) (one short),  
  **Action:** Cooperate.  
  **Reason:** By cooperating, push the group over the threshold and gain reward \( k \) instead of losing it.

- Else if \( C_{-i}^{t-1} < m - 1 \),  
  **Action:** Defect.  
  **Reason:** Cooperation is wasted if threshold cannot be reached; no point paying cost.

---

#### Round \( t = r \) (Last round)

- Observe \( C_{-i}^{r-1} \).

- If \( C_{-i}^{r-1} \geq m \),  
  **Action:** Defect.  
  **Reason:** Maximize payoff since future rounds don’t exist.

- Else  
  **Action:** Defect.  
  **Reason:** No incentive to cooperate at end; last round—no punishment or reputation effects.

---

### Edge Cases and Clarifications

- **If during intermediate rounds \( C_{-i}^{t-1} = m - 1 \), cooperating is only worthwhile if \( k \) sufficiently exceeds 1.** Given \( k > 1 \), this holds.

- **If the number of other cooperators is uncertain due to simultaneous moves, rely on last round’s data as perfect info.**

- **If observing other players’ actions in the past shows consistent defection, defect indefinitely.**

- **Punishment behavior:** You never punish by cooperating solely to deny others; your aggressive stance exploits cooperation, not enforces it.

---

### Pseudocode

```python
def aggressive_strategy(t, r, m, k, C_minus_i_prev):
    """
    t: current round (1-based)
    r: total rounds
    m: minimum number of cooperators needed
    k: reward factor
    C_minus_i_prev: number of others cooperating in previous round
    Returns: 'C' or 'D'
    """

    if t == 1:
        # Round 1: defect to exploit naive cooperators
        return 'D'

    elif t == r:
        # Final round: no incentive to pay cost
        return 'D'

    else:
        if C_minus_i_prev >= m:
            # Threshold met without you, defect and free ride
            return 'D'

        elif C_minus_i_prev == m - 1:
            # One shy of threshold, cooperate to secure reward
            return 'C'

        else:
            # Threshold unlikely to be reached, defect to save cost
            return 'D'
```

---

### Summary

- Defect initially to test/exploit.
- Exploit others’ cooperation by defecting when threshold is met.
- Cooperate only to push the threshold over the edge if it's one cooperator short.
- Defect in the last round regardless.
- Avoid costly cooperation unless pivotal to getting the reward.
- Leverage perfect info to identify when cooperation is beneficial to you and otherwise free-ride aggressively.

This strategy maximizes personal returns, leveraging others’ cooperation aggressively while minimizing your own costs.
'''

description_AGGRESSIVE_90 = '''
**Aggressive Strategy for Collective Risk Dilemma**

---

### Strategy Goal

Maximize your individual total payoff aggressively by exploiting cooperators wherever possible yet avoid catastrophic collective failure.

---

### Core Idea

- Start by defecting aggressively, forcing others to pay the cost of cooperation.
- Only cooperate when the risk of the threshold *not* being reached endangers your reward and when you can reliably exploit cooperating players.
- Use full knowledge of previous rounds to maximize personal gain.
- Never cooperate in the last round (no future rounds to incentivise cooperation).
- Punish consistent defectors only if it benefits you personally; otherwise, disregard normative enforcement.

---

### Detailed Decision Rules

---

#### Initialization (Round 1)

- **Always Defect (D).**

Rationale: No history to base trust on. Aggressively attempt to free ride on cooperators.

---

#### General Round t, 1 < t < r

Given history \( H^{t-1} = \{ (a^1, \pi^1),..., (a^{t-1}, \pi^{t-1}) \} \) where \(a^j\) are action profiles and \(\pi^j\) are payoffs.

1. **Calculate the number of cooperators in the previous round:**  
   \( \text{coop}_{t-1} = \#\{i : a_i^{t-1} = C\} \)

2. **Evaluate if cooperation in the previous round met the threshold:**  
   \( \text{coop}_{t-1} \geq m \Rightarrow \) public good delivered, reward received.

3. **If reward was delivered last round:**

    a. If **current defectors got strictly higher payoff than cooperators last round**, continue defecting to exploit cooperators.

    b. Else, consider cooperating **only if defectors were too few to safely get the reward without your cooperation**, i.e., if \( \text{coop}_{t-1} = m \) or \( \text{coop}_{t-1} = m + 1 \).

    This nudges cooperation only to maintain the reward while ensuring exploitative advantage.

4. **If reward was not delivered last round (i.e., < m cooperators):**

    - **Cooperate if and only if your cooperation will bring the total to at least m** (i.e., if \( \text{coop}_{t-1} = m - 1 \)) to "fix" the outcome and gain the reward.  
    - Else, **Defect** to avoid paying cooperation cost if the group failed anyway.

---

#### Last Round (t = r)

- **Always Defect (D).**

Rationale: No possibility of future retaliation or reward. Extract max private payoff.

---

### Edge Cases Handling

- If in any round the number of cooperators was **far above m** (e.g., all cooperated), continue defecting to exploit over-cooperators.
- If at any point no reward has ever been delivered (cooperation always below threshold), cooperate only when your cooperation will hit exactly m; otherwise defect to conserve endowment.
- If you observe opponents switching randomly, continue defecting because aggressive expectational payoff is higher.
- If all defect, persist defecting (nothing to gain cooperating solo).

---

### Pseudocode

```python
function decide_action(round t, history H, params n, m, k):
    if t == 1:
        return 'D'  # Always defect first round
    
    if t == r:
        return 'D'  # Always defect last round
    
    actions_prev = H.actions[t-1]  # actions last round
    payoffs_prev = H.payoffs[t-1]
    
    coop_count = count(actions_prev == 'C')
    reward_delivered = coop_count >= m
    
    # Identify your action and payoff last round
    my_action_prev = actions_prev[self]
    my_payoff_prev = payoffs_prev[self]
    
    # Payoff comparison between defectors and cooperators last round
    defectors_payoffs = [payoffs_prev[i] for i in range(n) if actions_prev[i] == 'D']
    cooperators_payoffs = [payoffs_prev[i] for i in range(n) if actions_prev[i] == 'C']
    
    max_def_payoff = max(defectors_payoffs) if defectors_payoffs else -inf
    max_coop_payoff = max(cooperators_payoffs) if cooperators_payoffs else -inf
    
    if reward_delivered:
        if max_def_payoff > max_coop_payoff:
            # Exploit cooperators by defecting
            return 'D'
        else:
            # Consider cooperating only if coop count is borderline
            if coop_count == m or coop_count == m + 1:
                return 'C'
            else:
                return 'D'
    else:
        # Reward not delivered last round
        if coop_count == m - 1:
            # Can fix outcome by cooperating
            return 'C'
        else:
            return 'D'
```

---

### Summary

| Round       | Cooperation?                                                          | Reason                                      |
|-------------|----------------------------------------------------------------------|---------------------------------------------|
| First       | Defect                                                               | Test others, aggressive start               |
| Intermediate| Cooperate only if your single cooperation would make or keep threshold | Exploit others, selectively cooperate       |
| Last        | Defect                                                               | No future gains from cooperation            |

---

### Strategic Notes

- **Aggressiveness:** You never initiate cooperation randomly or altruistically. You exploit cooperative behavior by defecting when others cooperate.
- **Selective cooperation:** You cooperate only to maintain the collective reward when it benefits you personally.
- **No forgiveness:** You do not cooperate in the last round—aggressiveness peaks to extract maximum payoff.
- **Exploitation:** Defectors receive higher payoffs when threshold is met; you seek to be one of those defectors.
- **Opportunistic fixing:** If the reward was missed only because you didn’t cooperate, you step in to salvage the reward when profitable.

---

This strategy aims for maximum individual payoffs by balancing exploitation and minimal, conditional cooperation only when compulsory, clearly reflecting an aggressive mindset.
'''

description_AGGRESSIVE_91 = '''
**Aggressive Strategy for the Collective Risk Dilemma**

---

### Overview:

This aggressive strategy aims to maximize individual payoffs by exploiting the cooperation of others while avoiding unnecessary costs. It uses an opportunistic defect-until-forced-to-cooperate approach, leveraging the repeated nature of the game to defect as much as possible without letting the group fail to reach the cooperation threshold *m*. It punishes others minimally but firmly, and defends its position aggressively.

---

### Intuition:

- **Aggressive Mindset:** Maximizing personal gain even at some risk of collective failure.
- **Exploit Cooperators:** Defect when you can gain the reward *k* without cooperating, i.e., when others provide the threshold.
- **Force Others' Cooperation:** Cooperate only when absolutely necessary to maintain the threshold and get the group reward.
- **Defend Against Defectors:** If the threshold is at risk, cooperate aggressively to maintain group reward (but never cooperate to increase others' payoffs unnecessarily).
- **No costly cooperation in the last round** unless it guarantees a strictly higher payoff — because reputation or future is irrelevant.

---

### Decision Rules (Per Round):

#### Notation:

- Let *C_count_previous* = number of cooperators (excluding self) in previous round.
- *threshold* = m (minimum cooperators needed).
- *players* = n
- *reward_factor* = k > 1

---

### Round 1 (No Past Information):

- Cooperate if you expect that others will not cooperate enough.  
- Since no information exists, start by **defecting** to test how many others cooperate alone.
- Rationale: Aggressive strategy tries to extract free riding first.

**Action:** Defect

---

### Subsequent Rounds (t > 1):

1. **Estimate cooperation from others in previous round**:
    - Compute `others_C = number of cooperating players excluding self` in round t-1.
    - Expected cooperate count this round (without self): Assume others repeat their previous actions for this round.

2. **If `others_C >= threshold`**:
    - Defect aggressively to free ride the reward.
    - Payoff: 1 (keeps endowment) + k (reward).
  
3. **If `others_C == threshold - 1`**:
    - Must cooperate to keep the threshold met.
    - Cooperate (pay cost 1, but ensures reward k).

4. **If `others_C < threshold - 1`**:
    - The group failed to reach threshold even with your cooperation.
    - Defect: no point cooperating if group fails anyway.
    - Payoff: 1 (no cooperation cost), no reward.

---

### Edge Cases:

- **Last Round (t = r):**

  - Cooperate only if strictly beneficial:  
    - If `others_C == threshold - 1`, cooperate to get payoff of `k` (net `k - 1` cost).  
    - Otherwise defect.

- **If previous round was a failure (reward not met):**

  - Since no communication, estimate that others are defecting aggressively.

  - Defect this round as well (aggressive stance rather than enabling cooperation at cost).

- **If ever others cooperate consistently above threshold:**

  - Always defect to maximize free payoffs while others pay costs (riding on cooperators).

---

### Summary in Pseudocode:

```python
def aggressive_strategy(round_number, previous_actions, n, m, k):
    # previous_actions: list of length n, each entry 'C' or 'D' for previous round
    # if round_number == 1, previous_actions == None

    if round_number == 1:
        # Start aggressively by defecting
        return 'D'

    # Count number of cooperators excluding self (index assumed known)
    others_C = sum(1 for action in previous_actions if action == 'C')  # excluding self if needed

    threshold = m

    if round_number == r:
        # Last round special rule
        if others_C == threshold - 1:
            # Cooperate to gain reward (net payoff = k - 1)
            return 'C'
        else:
            # Otherwise defect to avoid cost
            return 'D'

    # General rounds > 1 and not last
    if others_C >= threshold:
        # Enough cooperators without me; defect to free-ride
        return 'D'
    elif others_C == threshold - 1:
        # I must cooperate to reach threshold and get reward
        return 'C'
    else:
        # Group failing; no point cooperating
        return 'D'
```

---

### Interpretation:

- The strategy aggressively avoids paying cooperation costs whenever possible.
- It only cooperates to "patch holes" to maintain threshold if others are near the boundary.
- Does not try to punish or reward other players; strictly payoff maximizing.
- In failing rounds, it stops wasting costs by defecting.
- In the last round, it cautiously cooperates only when payoff strictly benefits.
- By repeatedly defecting except when absolutely necessary, it maximizes individual payoff aggressively.

---

### Final Notes:

- This strategy is **aggressive** by defecting as much as possible, exploiting cooperative players.
- It enforces cooperation only when strictly beneficial to preserve the collective reward.
- It avoids unnecessary cooperation to prevent loss of individual payoff.
- Strictly self-interested, with an aggressive offensive stance in the repeated game setting.
'''

description_AGGRESSIVE_92 = '''
**Aggressive Strategy for Collective Risk Dilemma**

---

### Strategic Intuition

The game rewards groups that meet or exceed the cooperation threshold *m*, granting each player the added payoff *k*. Defectors get to keep their endowment *1* and still receive the reward *k* if the threshold is met — often netting a payoff advantage relative to cooperators when cooperation happens.

An *aggressive* strategy here means:

- Prioritize maximizing individual payoff, even at the expense of group cooperation.
- Defect whenever personally beneficial.
- Use aggressive signaling or retaliation to coerce or punish cooperating opponents to sway the group towards defecting or leaving you better off.
- Exploit rounds where others cooperate.

We want a strategy that strategically cooperates only when necessary (to keep the threshold met), then defects aggressively; otherwise defects outright to attempt to free-ride on others' cooperation without giving up our endowment.

---

### Key Observations to Exploit:

- Defecting while threshold is met yields payoff **1 + k**, better than cooperating for **0 + k**.
- If cooperation falls below *m*, no one gets the reward, so payoff for defectors is just 1.
- If everyone defects, payoff is 1 but no reward.
- As the game repeats with perfect monitoring, players could punish defectors by withholding cooperation.
  
---

### Decision Rules (High-level)

#### Round 1:
- **Defect (D)** outright, to signal aggressiveness and attempt to capitalize if others cooperate.

#### Rounds 2 to r-1 (Intermediate Rounds):
- **If last round resulted in threshold met:**
  - If you cooperated in previous round and the threshold was met:
    - Defect now to exploit cooperators.
  - Else if you defected and threshold was met:
    - Defect again to free ride.
  
- **If last round did not meet threshold:**
  - Check if by cooperating you can *single-handedly* ensure threshold met (e.g. you know exact number of cooperators last round):
    - If yes, **cooperate** to force the reward, trap others.
    - Else, **defect** to avoid unilateral cooperation cost.

- In case the threshold is barely unmet (one below *m*), cooperate aggressively to attempt to meet threshold and get the reward, then defect next round.

- Always defect if cooperation level low and no hope to meet threshold.

#### Last Round (Round r):
- **Defect (D):** no future interaction to punish or reward cooperation.

---

### Edge Cases

- **If threshold *m* equals or nearly equals *n* (almost all must cooperate):**
  - Cooperate only if essential to meet threshold; otherwise exploit with defect.
  
- **If threshold very low (close to 1):**
  - Defect in all rounds except when cooperation last round failed; then cooperate once to trigger reward and capitalize next rounds.

- **If opponents appear to be 'tit-for-tat' or conditional cooperators:**
  - Defect early to provoke defections, then defect persistently.

- **If unexpected cooperation spike detected in previous rounds (≥ m cooperators):**
  - Defect to free-ride.

---

### Pseudocode

```python
# Inputs (known globally): n, r, m, k
# History storage:
#   actions[t][i]: action of player i at round t, 1-based index
#   Assume we are player index self_i

def aggressive_strategy(t, history_actions):
    # t: current round, 1-based
    # history_actions: list of past rounds' actions (list of lists)

    if t == 1:
        # Round 1: defect outright, no info yet
        return 'D'

    previous_round = t - 1
    prev_actions = history_actions[previous_round - 1]  # 0-based indexing

    # Count cooperators in previous round
    coop_count = sum(1 for a in prev_actions if a == 'C')

    # Did threshold meet last round?
    threshold_met = (coop_count >= m)

    # Did I cooperate last round?
    I_cooperated = (prev_actions[self_i - 1] == 'C')

    if t == r:
        # Last round: defect outright
        return 'D'

    if threshold_met:
        if I_cooperated:
            # Exploit cooperators: defect now to get payoff 1 + k
            return 'D'
        else:
            # Keep free-riding
            return 'D'

    else:
        # Threshold not met last round
        # If cooperating alone this round can meet threshold, cooperate aggressively
        # Estimate number of cooperators excluding self last round:
        coop_without_me = coop_count - (1 if I_cooperated else 0)

        # If coop_without_me + 1 >= m, my cooperation ensures threshold
        if (coop_without_me + 1) >= m:
            return 'C'
        else:
            # Cooperation unlikely to trigger reward, defect
            return 'D'
```

---

### Summary of the Aggressive Strategy

- **Round 1:** Defect to signal no willingness to cooperate freely.
- **Intermediate rounds:** Cooperate *only* if your action can exactly or just push the group over the threshold — forcing the reward — then revert to defection immediately after to capitalize on cooperators.
- **Otherwise, always defect** to maximize your private gain.
- **Last round:** Defect to maximize final payoff; no incentive to risk cooperating when no future rounds to leverage it.
- **Exploit cooperative players strongly**, free-ride whenever threshold met.
- **Retaliate and punish by defecting without ever "rewarding" cooperation**, so other players get little incentive to trust or cooperate with you.

This strategy maximizes personal payoff by forcing others to bear cooperative cost, exploiting their cooperation gains, minimizing your own cooperation costs, and ensures no long-term commitment to cooperation — aggressively taking advantage of the common knowledge and repeated play structure.

---

Let me know if you want a softer variant or an adaptive version!
'''

description_AGGRESSIVE_93 = '''
**Context Recap**:  
- Players simultaneously pick C (cooperate, cost 1) or D (defect, cost 0).  
- If fewer than *m* cooperate, everyone gets 1 - own cost.  
- If *m* or more cooperate, reward *k* (>1) is added for everyone, including defectors.  
- Repeated for *r* rounds with perfect info and no direct communication.  
- Opponents are independent strategies by other LLMs with shared game knowledge.

---

# Aggressive Strategy Design

**Goal**: Maximize own total payoff aggressively, exploiting others' cooperations while forcing them to pay costs without my cooperation unless absolutely necessary. Use punishment to deter being exploited and rule out cooperation that benefits others more than me.

---

## Intuition & Key Observations

- Defecting when others cooperate yields highest individual payoff per round (1 + k).  
- Cooperating costs 1 but grants reward k if threshold met.  
- To meet threshold *m*, need at least *m* cooperators; without my cooperation, if there are *m* cooperators anyway, I can free ride safely.  
- If *m* cooperators not reached without me, I must decide to cooperate or defect carefully: cooperating helps all (including defectors), defecting yields lower payoff but costs nothing.  
- This tradeoff centers on whether my cooperation flips outcome from <m to ≥m.  
- Aggressive mindset: avoid paying cost to benefit free riders unless it significantly benefits me (or it's forced tactically).

---

## Detailed Strategy Description

### Variables and history tracking

For each round *t*, observe:  
- Number of cooperators last round: `c_last`  
- Whether threshold was met last round: `threshold_met_last = (c_last >= m)`  
- My own previous action `my_action[t-1]`  
- Round number `t ∈ {1..r}`

---

### 1) First Round (`t = 1`)

- No prior info, no history.

**Aggressive default:** Defect in round 1.  
- Rationale: No info; cooperating can be exploited if others defect. You gain maximum immediate payoff by defecting.  
- If others cooperate, you gain large payoff without cost.

---

### 2) Intermediate Rounds (`2 <= t < r`)

- Based on last round's data:

**Main logic:**

- Determine how many cooperators last round, excluding yourself if you cooperated last round.  

- Predict if threshold can be met without your cooperation this round.

**Case A: Threshold was met last round**

- If threshold was met last round (≥m cooperators), assume others might cooperate again.

- Defect this round **if threshold can be met without your cooperation** (if number of known cooperators last round - you ≥ m):  
  - Free ride again, get (1 + k).  
- Else if threshold was met last round but not enough cooperators **without** you:  
  - **Cooperate** this round to keep threshold met and secure reward.  
  - Aggressive justification: maintain high reward only if absolutely necessary.  
- Else (if threshold not likely to be met), **defect**, saving cost.

**Case B: Threshold was NOT met last round**

- If threshold failed last round (<m), cooperation yields no reward benefit and only costs; defect aggressively.

- Exception: if you can singlehandedly push cooperators from (m-1) to m by cooperating (i.e., there were exactly m-1 cooperators last round including you), cooperate to push threshold and get k reward.

- Else defect.

---

### 3) Last Round (`t = r`)

- Aggressive endgame defecting:

- **Always defect** on last round.

- Rationale: No future punishment possible; maximize immediate payoff.

---

### 4) Handling Edge Cases and Opponent Behavior

- If in any round the threshold is consistently met without your cooperation, stay defecting to maximize payoff.

- If opponents cooperate inconsistently and threshold never met without you, cooperate only when you bring the total cooperators to ≥ m.

- If threshold never reliably met, constantly defect, no benefit cooperating.

---

## Pseudocode

```python
def aggressive_strategy(t, r, n, m, k, history_actions):
    """
    t: current round (1-based)
    r: total rounds
    n: number of players
    m: minimum cooperators needed
    k: reward factor
    history_actions: list of lists, previous rounds actions of all players, e.g. history_actions[t-2] is round t-1
    
    Returns: 'C' or 'D'
    """
    if t == 1:
        # First round: defect by default
        return 'D'
    
    # Last round: defect aggressively
    if t == r:
        return 'D'
    
    # Count cooperators in last round
    last_round_actions = history_actions[t - 2]  # zero-indexed
    c_last = last_round_actions.count('C')
    my_last_action = last_round_actions[0]  # Assuming you are player 1 for reasoning, actual index as needed
    
    # Calculate cooperators excluding self if cooperated last round
    c_last_excl_me = c_last - 1 if my_last_action == 'C' else c_last
    
    threshold_met_last = (c_last >= m)
    
    if threshold_met_last:
        # Threshold met last round
        if c_last_excl_me >= m:
            # Others can meet threshold w/o me => defect
            return 'D'
        else:
            # My cooperation required to maintain threshold => cooperate now aggressively
            return 'C'
    else:
        # Threshold NOT met last round
        # If by cooperating I can achieve threshold
        if (c_last_excl_me + 1) >= m:
            # Cooperate to reach threshold
            return 'C'
        else:
            # Cooperation wasted, defect aggressively
            return 'D'
```

---

## Summary

| Round      | Condition                               | Action  | Rationale (Aggressive)                              |
|------------|---------------------------------------|---------|----------------------------------------------------|
| Round 1    | No info                              | Defect  | Avoid risk, exploit cooperators                     |
| Middle     | Threshold met last round              | Defect if threshold still met without me; else cooperate | Free ride if possible; else reluctantly cooperate to keep payoff high |
| Middle     | Threshold NOT met last round          | Cooperate only if my cooperation achieves threshold; else defect | Only pay cost if payoff justifies                      |
| Last round | Any                                  | Defect  | Maximize immediate payoff, no future consequences   |

---

This strategy aggressively exploits others' cooperation, defects whenever possible, and only cooperates when **your cooperation alone** flips the round outcome to a threshold met scenario — and even then, only during intermediate rounds. It never cooperates on the first or last round, taking advantage of the repetition and punishment capabilities in the middle rounds to manipulate payoffs most effectively.
'''

description_AGGRESSIVE_94 = '''
**Aggressive Strategy for Collective Risk Dilemma**

---

### Main Idea

Be primarily selfish and exploit the cooperators as hard as possible. Co-operate only enough to trigger the threshold *m* to secure the reward *k*, then defect aggressively to maximize personal payoff. Use observed actions of others to identify and exploit predictable cooperators, avoid unnecessary costly cooperation yourself, and defect especially in the last round(s) to maximize payoffs.

---

### Notation & Definitions

- **n**: number of players
- **r**: number of rounds
- **m**: minimum cooperators needed for reward
- **k**: reward multiplier (k > 1)
- **t**: current round (1 ≤ t ≤ r)
- **C_i,t**, **D_i,t**: action of player i in round t
- **S_t**: set of players who cooperated in round t
- **C_obs[i]**: count of rounds player i cooperated so far
- **threshold_needed**: minimum cooperators needed this round besides self to secure reward (m-1 if you cooperate, m if you defect)

---

### Strategy Description

**Goal:**  
Maximize personal payoff by defecting whenever possible, but cooperate opportunistically only if it guarantees unlocking the reward for a round, exploiting cooperators. In other words:

- Defect by default (max personal payoff 1 + k if threshold met)
- Cooperate *only* to increase likelihood of reaching threshold *and only when it yields net gain > defecting*
- Exploit known cooperators by defecting, free-riding on their cooperation
- In the last round, always defect to avoid being exploited (no future punishment)

---

### Decision Rules

---

#### Initialization (before round 1):

- For all opponents i, initialize C_obs[i] = 0
- Initialize history H empty

---

#### Round 1 (first round):

- No history: play **Defect (D)** to test, maximize payoff, and observe who cooperates.
- Rationale: aggressive start, no trust built.

---

#### Rounds 2 to r - 1 (middle rounds):

1. **Estimate likely cooperators:**

   For each player i ≠ self, calculate cooperation frequency:

   \[
   f_i = \frac{C\_obs[i]}{t-1}
   \]

2. **Predict number of cooperators this round if I defect:**

   Expected cooperators without own cooperation:

   \[
   E_{coop} = \sum_{i \neq self} \mathbf{1}_{f_i \geq f_{threshold}}
   \]

   where \( f_{threshold} \) is a tunable cooperation frequency cutoff (e.g., 0.5) to classify "likely cooperator".

3. **Decision criteria:**

   - If \( E_{coop} \geq m \), **Defect (D)**: enough others likely to cooperate, so free-ride for payoff \(1 + k\).
   - Else if \( E_{coop} = m-1 \), **Cooperate (C)**: you are the marginal cooperator needed to unlock reward and increase payoff from 1 to \(k\).
   - Else, **Defect (D)**: threshold not reachable, no point cooperating.

4. **Update C_obs for opponents based on actual observed actions**

---

#### Round r (last round):

- Always **Defect (D)**
- Rationale: No future rounds, cooperation only risks loss without strategic benefit.

---

### Edge Case Handling

- If at any round you detect guaranteed cooperation from >= m others (e.g., if all or many cooperated last round), defect to free-ride.
- If no cooperation detected historically (everyone defects), always defect.
- If uncertain about others’ cooperation, prefer to defect to avoid cooperation cost.
- No forgiveness or punishment phases since aggressive mindset — always exploit.

---

### Pseudocode

```python
# Parameters: n, r, m, k
# History: actions[t][i], indexed by round and player

C_obs = [0] * n  # cooperation count for each player excluding self
self_index = your player index

for t in 1 to r:
    if t == 1:
        action = 'D'  # defect round 1
    elif t == r:
        action = 'D'  # defect last round
    else:
        # Calculate cooperation frequency of others
        cooperation_freq = [C_obs[i] / (t - 1) if i != self_index else 0 for i in range(n)]
        
        # Identify likely cooperators - threshold frequency (e.g., 0.5)
        likely_cooperators = [i for i in range(n) if i != self_index and cooperation_freq[i] >= 0.5]
        
        E_coop = len(likely_cooperators)
        
        if E_coop >= m:
            # Enough cooperators expected, free-ride
            action = 'D'
        elif E_coop == m - 1:
            # Just need self to cooperate to reach threshold
            action = 'C'
        else:
            # Threshold not reachable, defect
            action = 'D'
    
    # After decisions, update cooperation counts for next rounds (except after last round)
    if t < r:
        # After observing others' actions:
        for i in range(n):
            if i != self_index and actions[t][i] == 'C':
                C_obs[i] += 1
```

---

### Summary of Aggressive Traits

- Default defect, free-ride on others’ cooperation
- Only cooperate if strictly needed to unlock reward (m-1 others cooperate)
- Exploit identified cooperators every round by defecting
- Never cooperate in the last round to maximize payoff
- No costly attempts to punish or build trust; assume selfish exploitation

---

This strategy is tailored to maximize individual payoff aggressively by minimizing personal cooperation costs and exploiting others’ cooperation whenever the threshold is met or just reachable.
'''

description_AGGRESSIVE_95 = '''
**Aggressive Strategy for Collective Risk Dilemma**

---

### Intuition and Objective

An aggressive strategy maximizes own payoff aggressively by exploiting cooperators but also ensures the group meets the cooperation threshold **only if it benefits you significantly**. The key aggressive traits are:

- **Defect as often as possible**, since defectors keep their endowment (payoff = 1) and still get the reward *if* there are enough cooperators.
- **Force cooperation only to the minimum extent necessary to trigger the reward k**.  
- **Manipulate others into cooperating while defecting yourself when possible**, aiming to be in a minority of defectors who gain more payoff (e.g., in example 3 above with 3C,3D, defectors get 3, cooperators get 2).

---

### Decision Rules Overview

1. **Round 1 (first round): Defect Always**  
   No prior info. Assume others will try to cooperate to secure collective reward. Defect to exploit cooperators.

2. **Subsequent Rounds (2 to r-1): Condition on past round cooperation count**  
   - If previous round had **≥ m** cooperators:  
     - Defect again to exploit continued cooperation.
   - If previous round had **< m** cooperators:  
     - If cooperation count last round was exactly (m - 1), cooperate yourself this round to try to nudge to threshold (only when you can be the deciding cooperator).
     - Else, defect again (no incentive to help threshold).

3. **Last Round (round r): Defect Always**  
   No future rounds to punish you. Purely exploit by defecting.

---

### Handling Edge Cases and Interpretation

- If others all defect (no cooperators), this strategy sticks to defecting and no cost is paid. Payoff = 1 per round, total = r.
- If others try to cooperate enough to hit threshold (≥ m), you stay defecting to maximize payoff (you pay no cost and get reward k).
- If cooperation borderline (m-1), step in to cooperate **only if** by cooperating you push over threshold.
- Because communication is impossible, this strategy assumes rational players and infers a mixed equilibrium where some cooperate, some defect. 
- This aggressively exploits cooperators by never cooperating unnecessarily.
- Stubbornly defects last round since no future rounds remain to incentivize cooperation.

---

### Pseudocode

```python
# Parameters: n, r, m, k
# History: List of tuples [(C_count_t, D_count_t)] for rounds t=1..current_round-1

def decide_action(round_t, history):
    if round_t == 1:
        # First round: defect to exploit cooperators
        return 'D'

    if round_t == r:
        # Last round: defect (no future punishes)
        return 'D'

    # For rounds 2..r-1
    # Observe last round cooperation count
    last_C = history[-1][0]  # number of cooperators last round

    if last_C >= m:
        # Threshold met last round, defect again to exploit
        return 'D'

    if last_C == m - 1:
        # Cooperation just below threshold last round,
        # cooperate to push group over threshold this round (if you cooperate)
        return 'C'

    # Otherwise, defect
    return 'D'
```

---

### Explanation of Aggression

- Always **favor defection** first to keep your endowment.
- Only **cooperate if it helps meet threshold** exactly when you can be pivotal.
- Never cooperate on first or last rounds — no reason to bear cost without future strategic benefit.
- Always **exploit rounds where threshold met** by defecting to maximize personal reward.
  
---

### Summary

| Round          | Condition                         | Action    | Reason                     |
|----------------|---------------------------------|-----------|----------------------------|
| 1              | Initial                         | Defect    | Exploit cooperators, no info|
| 2..r-1         | Previous cooperators ≥ m        | Defect    | Exploit cooperative reward |
| 2..r-1         | Previous cooperators = m - 1    | Cooperate | Push threshold to trigger reward |
| 2..r-1         | Otherwise                      | Defect    | No incentive to pay cost   |
| r (last round) | Any                            | Defect    | No future rounds to leverage |

This strategy aggressively tries to maximize payoff by defecting whenever possible, only cooperating when it can push the group over the threshold to unlock the reward, thus exploiting cooperators while ensuring that the collective reward is achieved only when it benefits you directly.
'''

description_AGGRESSIVE_96 = '''
Below is an **aggressive strategy** design for the Collective Risk Dilemma as specified.

---

### Strategy Name: **Threshold Punisher**

### Conceptual Overview

This strategy is **aggressive** in the sense that it actively exploits cooperators but also punishes defection severely to establish dominance and leverage opponents into cooperating early (to avoid being exploited). It aggressively defects when it can gain higher individual payoffs, but it cooperates strategically to trigger the reward and then punishes sustained defectors.

---

### Key Strategic Ideas

- **Round 1**: Defect aggressively to test opponents.
- **After Round 1**: 
  - Continue defecting as long as reward thresholds are met without your cooperation (exploit cooperators).
  - Cooperate only if your cooperation is *pivotal* to reach the cooperation threshold **m**, forcing the reward.
- **Punishment mechanism**: If cooperators consistently defect when expected to cooperate, switch to permanent defection to punish.
- **Last round**: Defect always to maximize private payoff; no incentive to cooperate as future rounds do not exist.

---

### Definitions & Notation

- Let `Ccount_t` = number of cooperators in round `t`.
- Let `π_i,t` = payoff for you in round `t`.
- `m` = cooperation threshold, `n` players total.
- Assume perfect observability of all individual actions from previous rounds.

---

### Detailed Rules

**Round 1:**

- Defect.

**Rounds t = 2 to r-1:**

1. From previous round `t-1`, observe `Ccount_{t-1}`.
2. **If** `Ccount_{t-1} >= m` *without your cooperation* (meaning enough others cooperated last round without you)  
   → Defect again (exploit the cooperators by free-riding).
3. **Else if** `Ccount_{t-1} = m-1` *without your cooperation*  
   → Cooperate this round to push total cooperators to `m` and trigger the reward.
4. **Else** (less than `m-1` cooperators last round)  
   → Defect (do not waste resources in insufficient crowds).
5. **Punishment trigger:**  
   Keep track of players who defected in rounds where cooperation was profitable (e.g., when reward was triggered). After 2 rounds of mutual defection from those players, defect permanently (no forgiveness).

**Round r (last round):**

- Defect (no future benefits).

---

### Pseudocode

```
initialize defect_streaks[player_id] = 0 for all players except self
round = 1

for t in 1 to r:
    observe actions A_{i,t-1} for all players i ≠ self (skip for t=1)
    compute Ccount_{t-1} = count of cooperators last round excluding self if i did not cooperate last round
    pivotal = (Ccount_{t-1} == m - 1 if self defected last round else adjusted accordingly)
    
    # FIRST ROUND
    if t == 1:
        action = D

    # LAST ROUND - always defect
    else if t == r:
        action = D

    else:
        if pivotal and self defected last round:
            # cooperate this round to trigger reward
            action = C
        else if Ccount_{t-1} >= m and self defected last round:
            # free ride on others
            action = D
        else:
            action = D

    # Update defect_streaks based on observation of others:
    for each player i != self:
        if player i defected in t-1 when cooperation likely beneficial:
            defect_streaks[i] += 1
        else:
            defect_streaks[i] = 0

    # If any player has defect_streaks[i] >= 2 => treat that player as permanently defecting
    # Possible extra punishment would be implemented by ignoring their cooperation next rounds or just continue defecting

    play action
```

---

### Aggressive Nature Explained

- **Exploitation:** Defect by default, free-ride on cooperators whenever possible to maximize payoff.
- **Decisive Cooperation:** Only cooperate if your contribution pushes group cooperation *past the threshold*, unlocking the reward, ensuring you are never a sucker.
- **Punishment:** Track others’ defection when cooperation is expected and punish by permanent defection—discourage free riding on your cooperation.
- **Last round defect:** No cooperation at the end, extract maximum private payoff.

---

### Handling Edge Cases

- **First round:** No past information; defect to avoid being exploited.
- **Last round:** Defect automatically to gain from others’ cooperation.
- **Minimal Cooperation:** If no chance to reach threshold, continuously defect to inhibit unprofitable risk.
- **Pivot cases:** Cooperate only if doing so is pivotal in the *previous round’s context*, ensuring payoff gain from triggering the reward.
- **No communication:** Only use observed behavior; respond aggressively to defection.

---

This aggressive approach tries to maximize individual reward by leveraging others' cooperation, cooperating only when strictly advantageous, and punishing free riders to carve out a dominant payoff over the repeated rounds.
'''

description_AGGRESSIVE_97 = '''
Here is an aggressive strategy tailored for the Collective Risk Dilemma with repeated rounds and simultaneous moves. The strategy’s fundamental mindset is to maximize personal payoff by exploiting cooperators while risking defection in uncertain situations, pushing others to bear the cost of cooperation.

---

### Aggressive Strategy: **"Exploit & Intimidate"**

---

#### Intuition

- Always prefer to defect to enjoy the endowment unless cooperating is absolutely necessary to trigger the group reward.
- Exploit the cooperators by defecting when enough others are cooperating, because defectors get the highest payoff in that case.
- Only cooperate (sacrifice the endowment) when the probability of insufficient cooperators in that round means losing the reward altogether, thus minimizing loss.
- Use early rounds to “probe” and learn tendencies of the group, but with a strong bias toward defection.
- As repeated rounds progress, increase defection pressure to discourage others from cooperating.
- In the last round, definitively exploit any cooperation since there is no future punishment or reward.
  
---

#### Notation

- **C_t** = number of cooperators observed in round t (excluding self, since actions are simultaneous)
- **m** = minimum cooperators threshold
- **r** = total rounds
- **t** = current round index (1 to r)

---

### Decision Rules

**Round 1 (Initial Move):**

- Defect (D)
- Rationale: Start aggressively, see who cooperates without giving up endowment.

---

**Rounds 2 to r-1:**

- Observe previous rounds’ cooperation counts.
- Estimate expected number of cooperators this round by taking a majority trend — e.g., average number of cooperators in previous rounds.
- Apply decision logic:

    ```
    if (expected_cooperators + 1) < m:
        # Cooperation unlikely to meet threshold
        # Defect to avoid unnecessary cost
        action = D
    else if (expected_cooperators >= m):
        # Enough others expected to cooperate (>= m)
        # Defect to maximize payoff and exploit cooperators
        action = D
    else:
        # Cooperation might reach threshold only if you cooperate
        # Then cooperate strategically to ensure threshold met and get reward
        action = C
    ```

- Rationale:
  - Cooperate only if your cooperation is pivotal—i.e., expected cooperators without you is less than m but would reach m with your cooperation.
  - Otherwise, always defect to maximize immediate gain.

---

**Last Round (round r):**

- Always defect.
- Rationale: No future rounds, so no fear of retaliation or reputation damage.
- Exploit any cooperators completely.

---

### Edge Cases

- If at any point, you observe that other players consistently defect (e.g., cooperation rate falls to zero), defect unconditionally—little incentive to cooperate.
- If unexpected mass cooperation happens (all others cooperating), still defect to get the highest payoff.
- If you are in the minority cooperating, continue defecting next rounds (punish yourself less).
- If cooperation is stable and high (≥ m regularly cooperating), exploit by continuing to defect.

---

### Summary of the Aggressive Strategy

| Round        | Condition                                         | Action |
|--------------|-------------------------------------------------|--------|
| 1            | No prior info                                    | Defect |
| 2 to r-1     | If (expected cooperators + 1) < m (threshold)   | Defect |
|              | Else if (expected cooperators) ≥ m              | Defect |
|              | Else (pivotal case)                              | Cooperate |
| r (last round)| Always defect                                  | Defect |

---

### Pseudocode

```python
def aggressive_strategy(t, r, m, past_actions):
    """
    t: current round (1-based)
    r: total rounds
    m: cooperation threshold
    past_actions: list of lists of actions in rounds 1..t-1 from all players (excluding self)
                  e.g., [[C,D,C,D,...], [D,C,D,C,...], ...]
    """

    if t == 1:
        return 'D'  # Start aggressively

    if t == r:
        return 'D'  # Last round exploit

    # Compute average number of cooperators in past rounds (excluding self)
    coop_counts = []
    for round_actions in past_actions:
        coop_counts.append(round_actions.count('C'))

    if len(coop_counts) == 0:
        expected_cooperators = 0
    else:
        expected_cooperators = sum(coop_counts) / len(coop_counts)

    # Expected cooperators excluding self
    # Add 1 (if you cooperate) to check if threshold met
    if (expected_cooperators + 1) < m:
        return 'D'  # Cooperation futile; defect
    elif expected_cooperators >= m:
        return 'D'  # Exploit cooperators
    else:
        # Pivotal to cooperate to reach threshold
        return 'C'
```

---

### Additional Notes

- This strategy aggressively punishes any attempts at costly cooperation by never voluntarily being the first to cooperate.
- It only cooperates when necessary to unlock the reward, and even then just barely.
- Over repeated rounds, it encourages others to bear the cost of cooperation, maximizing own payoffs.
- Defection signals clear non-cooperation mindset, possibly demoralizing conditional cooperators.
- By defecting last round, it extracts maximum possible payoff, leaving no space for reciprocity.

---

This aggressive approach is designed to maximize personal gains by opportunistic defection and minimum investment in cooperative costs, fitting the insultingly exploitative mindset suitable for an aggressive tournament participant.
'''

description_AGGRESSIVE_98 = '''
Here is an aggressive strategy for the Collective Risk Dilemma that aims to exploit cooperators for maximum personal gain, while still occasionally cooperating to avoid collective punishment and maintain plausible deniability.

---

### Aggressive Strategy: "Exploitative Opportunist"

---

### Intuition

- **Goal:** Maximize individual payoff by defecting as often as possible without triggering group failure (fewer than *m* cooperators).
- **Approach:**  
  - In early rounds, test the waters by defecting and observing how many cooperate.  
  - If the threshold *m* is met, continue to defect to "freeride" on cooperators.  
  - If the threshold is not met, cooperate just enough to push cooperation to *m*, but never more.  
  - In the last round, defect unconditionally to maximize private payoff since no future rounds remain.
- **Mechanics:** Exploit common knowledge and perfect information to gauge group behavior and "hover" cooperation at the threshold, pushing others to bear the cost.

---

### Decision Rules

#### Notation
- Let *C_t* = number of cooperating players in round *t* (including self, if cooperating).
- Let *m* = minimum cooperators needed to avoid risk.
- Let *r* = total rounds.
- Let *t* = current round number (1 ≤ t ≤ r).

---

### Strategy

#### Round 1
- Defect (D).
- Reason: Aggressive opening to test cooperativeness of others and gain max immediate payoff.

#### Intermediate rounds (1 < t < r)
- Observe *C_{t-1}*, cooperating count in previous round.
- If *C_{t-1}* ≥ m (threshold met in last round):  
  - Defect (D) to maximize freeride benefit, assuming sufficient others cooperated last round.
- Else (threshold not met):  
  - Cooperate (C) **only if** (current expected cooperators without me) < m - 1  
    *(i.e., you must cooperate to push group to reach m)*.  
  - Otherwise defect (D).
- Reason: Stay below threshold and only "rescue" cooperation if group fails, saving your cost but ensuring threshold is barely met.

#### Last round (t = r)
- Defect (D) unconditionally.
- Reason: No future punishment; maximize private payoff.

---

### Edge Case Handling

- **Exact threshold cases:**  
  When exactly m - 1 other players cooperated last round, you cooperate to reach threshold exactly m.
- **If cooperation collapses (consistently C_t < m):**  
  Eventually you will cooperate just enough to avoid risk and then continue to defect.
- **If others start defecting more in later rounds:**  
  You maintain defection unless threshold is threatened.
- **No punishing:**  
  Aggressive mindset avoids costly cooperation as punishment; prefers exploitation.

---

### Pseudocode

```python
def decide_action(t, r, m, last_round_cooperators):
    # Last round: defect unconditionally
    if t == r:
        return 'D'
    
    # First round: defect
    if t == 1:
        return 'D'
    
    # Intermediate rounds:
    if last_round_cooperators >= m:
        # Threshold met last round; freeride
        return 'D'
    else:
        # Threshold not met last round
        # Cooperate only if needed to reach threshold this round
        # Assume if I cooperate, cooperators that round = last_round_cooperators + 1
        if last_round_cooperators < m - 1:
            return 'C'
        else:
            return 'D'
```

---

### Summary

| Round Type      | Condition                              | Action     | Reason                             |
|-----------------|-------------------------------------|------------|----------------------------------|
| First (t = 1)   | Always                             | Defect (D) | Start aggressively               |
| Intermediate    | Threshold ≥ m last round            | Defect (D) | Exploit cooperators              |
| Intermediate    | Threshold < m last round and < m-1 cooperators | Cooperate (C) | Barely rescue cooperation     |
| Intermediate    | Threshold < m last round but ≥ m-1 cooperators | Defect (D) | Risk acceptable, freeride       |
| Last (t = r)    | Always                             | Defect (D) | Maximize final payoff            |

---

This strategy aggressively exploits cooperators while only cooperating when absolutely necessary to prevent payoff collapse due to collective failure, and always defects in the last round to maximize individual gain.
'''

description_AGGRESSIVE_99 = '''
Below is a carefully designed aggressive strategy for the Collective Risk Dilemma with multiple rounds and multiple players. The strategy exploits the payoff structure aggressively by defecting often to maximize personal gain, while cooperating only strategically when absolutely necessary to trigger the communal reward and avoid being penalized as a lone defector when cooperation is beneficial.

---

### Aggressive Strategy: "Conditional Exploiter with Threat Enforcement"

---

#### Intuition and Aggressiveness Rationale:

- **Primary goal:** Maximize own payoff by defecting as often as possible to keep the private endowment (payoff 1 per round) plus any reward from **others' cooperation**.
- **Key insight:** When the threshold `m` is met or exceeded, defectors get a strictly higher payoff (1 + k) than cooperators (0 + k). Hence, aggressively defecting **is rewarded if others cooperate**.
- **Use minimal cooperation to force threshold `m` when it benefits you or to punish others by letting the threshold fail, depriving them of the reward.**
- **Leverage "punishment" by refusing to cooperate in the last round or when others fail to cooperate, aggressively signaling that cooperation is to be earned, not given.**
- **Exploit perfect information by tracking others' past behavior and exploiting conditional cooperation only to trigger rewards when beneficial to yourself.**

---

### Decision Rules

Let:
- `t` ∈ {1,...,r} be the current round.
- `C_t` = number of players who cooperated in round t.
- `c_i,t` = your action this round (1 = Cooperate, 0 = Defect).
- `m`, `n`, `k`, `r` as defined.

---

#### Round 1 (Initial Round)

- Defect by default, testing others.  
  You start with maximum greed, refusing to contribute any initial cooperation.  
  *Reason:* Without trust or signals, cooperating early is giving away payoff unnecessarily.

---

#### Subsequent Rounds (t=2 to r-1)

- If in previous round \( t-1 \), the number of cooperators \(\geq m\):  
  *Interpretation*: Others have maintained the threshold, reaping the reward.  
  **Action: Defect.**  
  *Motivation:* Exploit their cooperation; get better payoff (1+k) than cooperators.  
  (*Rationale:* If they keep cooperating, you can freeride.)

- Else if previous round \( C_{t-1} = m-1 \) and you defected last round:  
  *Interpretation:* Threshold barely missed, possibly due to your defection.  
  **Action: Cooperate this round.**  
  *Motivation:* Push threshold over the edge to get collective reward (k), so you can freeride next round.  
  (*Rationale:* Minimal cooperation to keep the reward flowing.)

- Else if previous round \( C_{t-1} < m-1 \):  
  *Interpretation:* Cooperation failed badly; reward not obtained. Others unwilling or unable to cooperate enough.  
  **Action: Defect.**  
  *Motivation:* No benefit cooperating here, punish others by withholding cooperation.

- Otherwise:  
  Defect.

---

#### Final Round (t=r)

- Defect always.  
  *Reason:* No future rounds to influence; no incentive to cooperate, as no future punishment or reward can be enforced.

---

### Summary in Pseudocode

```
For round t in 1..r:

  If t == 1:
    c_i,t = D   # Defect to test others

  Else if t == r:
    c_i,t = D   # Last round, always defect aggressively

  Else:
    prev_round_cooperators = number_of_cooperators_in_round(t-1)

    if prev_round_cooperators >= m:
      c_i,t = D  # Exploit continued cooperation

    else if prev_round_cooperators == m-1 and c_i,t-1 == D:
      c_i,t = C  # Minimal cooperation to push over threshold

    else:
      c_i,t = D  # Defect and punish for failing cooperation
```

---

### Edge Case Handling

- **If threshold not met in first round:** continue defecting until condition `prev_round_cooperators == m-1` and you defected previously to briefly cooperate and restore reward condition.
- **If others never cooperate enough:** you consistently defect, maximizing private payoffs.
- **If others try to enforce cooperation themselves:** you freeload by defecting as long as threshold is met.
- **In final round:** no cooperation at all — aggressive extraction of maximum private payoff.

---

### Why Is This Aggressive?

- The strategy **never initiates cooperation**; it only cooperates reactively and minimally to maintain the reward state, forcing others to bear the cooperation cost.
- It **maximizes defection** to keep the private payoff and exploit cooperative players.
- It **withholds cooperation to punish the group**, using payoff denial as leverage (social threat).
- It **never sacrifices future gains for present kindness**, showing no cooperation goodwill.
- It takes advantage of repeated play **only to optimize own payoffs**, not group welfare.

---

This aggressive strategy balances opportunistic exploitation with minimal conditional cooperation to maintain long-term payoff maximization over multiple rounds against rational opponents.
'''

description_AGGRESSIVE_100 = '''
Below is a detailed aggressive strategy for the Collective Risk Dilemma repeated game. This strategy aims to maximize individual payoffs by exploiting cooperators while pushing to defect strategically across rounds.

---

### Key Strategic Intuition

- **Aggressive mindset:** Prioritize maximizing your own payoff, leveraging others' cooperation without consistently contributing yourself.
- **Exploit threshold:** When the threshold *m* cooperators is met, defecting yields the highest payoff (1 + k > 0 + k).
- **Drive others to cooperate early, then defect later:** Initially cooperate enough to help meet threshold so reward *k* is unlocked, then exploit cooperators by defecting.
- **Punish excessive cooperation:** If others start defecting too much, switch to more defecting yourself to avoid being exploited.
- **Last round:** No future rounds to punish or reward others. Best to defect to maximize immediate payoff since cooperation costs you 1 and gives no future benefit.

---

### Strategy Outline

#### Parameters known to the player:
- n, r, m, k
- History of rounds played: actions of all players each past round (including self)

---

### Decision Rules

#### Round 1 (first round)
- Cooperate if number of players is large and threshold is moderate (e.g., m < n/2) to encourage others to cooperate.
- Otherwise, **defect** to avoid early costs.

_Pseudocode snippet:_

```
if m < n/2:
    action = C
else:
    action = D
```

#### Rounds 2 ≤ t < r (intermediate rounds)
- Check last round outcomes:
  - If threshold *m* was met (≥ m cooperators), and you defected last round:
    - Continue defecting to exploit cooperators.
  - Else if threshold was met but you cooperated last round:
    - Defect this round to gain more payoff next round.
  - Else if threshold not met:
    - Cooperate only if the count of cooperators last round was near threshold (e.g., ≥ m - 1), trying to push over threshold.
    - Otherwise, defect.

- Adjust cooperation rate to keep the group near threshold but not significantly above, to maximize own payoff.

_Pseudocode snippet:_

```
last_round_cooperators = count of C last round
i_cooperated_last_round = (my last action == C)
threshold_met_last_round = (last_round_cooperators >= m)

if threshold_met_last_round and not i_cooperated_last_round:
    action = D  # Keep exploiting cooperators
elif threshold_met_last_round and i_cooperated_last_round:
    action = D  # Switch to defect next round for more gain
elif last_round_cooperators >= m - 1:
    action = C  # Help push over threshold, but only when close
else:
    action = D  # Defect otherwise to save endowment
```

#### Last Round (t == r)
- Defect unconditionally. No future rounds, so no incentive to cooperate.

_Pseudocode snippet:_

```
if t == r:
    action = D
```

---

### Handling Edge Cases

- **If at any point the threshold is clearly unreachable** (e.g. last rounds with persistent low cooperation):
  - Defect consistently, saving endowment, since reward is unlikely.
  
- **If all players cooperate persistently:**
  - Defect to maximize payoff (1 + k > k)
  
- **If all players defect persistently:**
  - Continue defecting, never waste endowment cooperating.

---

### Summary of Aggressiveness

- Cooperate sparingly and only enough to try to unlock the collective reward.
- Quickly switch to defecting once threshold is met or cooperation is high.
- Exploit cooperators at every opportunity.
- Defect on the last round to maximize payoff.
- Avoid being sucker (cooperating when threshold not met and payoff hurt).
- Push group to operate just around the threshold to exploit spillover benefits.

---

### Full Pseudocode (Conceptual)

```python
def aggressive_strategy(t, r, n, m, k, history):
    # history: list of tuples (actions_per_round), each element length n
    # Actions: 'C' or 'D'

    if t == 1:
        # First round decision based on threshold vs group size
        if m < n / 2:
            return 'C'
        else:
            return 'D'

    if t == r:
        # Last round: defect always
        return 'D'

    # Intermediate rounds
    last_round = history[-1]
    last_round_cooperators = last_round.count('C')
    i_cooperated_last_round = (last_round[self_index] == 'C')
    threshold_met_last_round = (last_round_cooperators >= m)

    if threshold_met_last_round and not i_cooperated_last_round:
        return 'D'  # Exploit cooperators
    elif threshold_met_last_round and i_cooperated_last_round:
        return 'D'  # Switch to defecting
    elif last_round_cooperators >= m - 1:
        return 'C'  # Push to threshold if close
    else:
        return 'D'  # Avoid loss, defect

# Note: self_index refers to own player index in history rounds
```

---

This strategy effectively balances exploitation with minimal cooperation to unlock collective reward, fully embracing an aggressive, self-maximizing mindset.
'''

description_AGGRESSIVE_101 = '''
Here’s an **Aggressive Strategy** tailored to the Collective Risk Dilemma with repeated rounds and perfect monitoring. The strategy aims to maximize individual payoff aggressively, seeking to exploit cooperators while ensuring at least partial collective success to gain rewards when it benefits the individual.

---

## Aggressive Strategy Overview ("Threshold Exploiter")

**Key ideas:**

- Defect by default to keep the endowment.
- Cooperate *only* **to just meet or barely exceed the cooperation threshold (m)**, but **never more than that**, to:
  - Avoid unnecessary cooperation costs.
  - Exploit others’ cooperations and push them towards cooperating "too much".
- In early rounds, test cooperation levels of others aggressively.
- Punish excessive cooperators by defecting.
- Defect in the last round since no future punishment/reward incentives remain.
- Use past rounds’ cooperation counts to predict and exploit opponent behavior.

---

## Detailed Decision Rules

### 1. **Initial Round: Round 1**

- **Defect**.
- Rationale: No information yet, aggressive default is defect to keep endowment.

### 2. **Rounds 2 to r-1 (intermediate rounds)**

At the start of round t (2 ≤ t ≤ r-1):

- Compute **last round’s total cooperators: C_{t-1}** (including yourself).

- If **C_{t-1} < m - 1** (not enough cooperators last round, no chance to reach threshold even if you cooperate now):
  - **Defect** again (no point cooperating alone).

- If **C_{t-1} = m - 1**:
  - **Cooperate** this round to just reach threshold m.
  - This lets you gain reward k without wasting cooperation beyond what’s needed.
  - You are effectively "the last cooperator" required; others are free to defect.

- If **C_{t-1} ≥ m** (threshold met or exceeded last round):
  - **Defect** aggressively.
  - Rationale: Others have been cooperating enough; you exploit their cooperation for a higher private payoff.

- If **C_{t-1} = m - 2** or fewer:
  - Defect to avoid being exploited as the lone cooperator.

### 3. **Last Round (round r)**

- **Always Defect**.
- Rationale: No future rounds mean no punishment or reward for cooperation; best to keep endowment.

---

## Edge Cases Handled

- **If m = 1** (not allowed by parameters): Edge case avoided by spec.
- **If all players defect persistently**: You never cooperate alone, so never lose from futile cooperation.
- **If opponents cooperate excessively (> m)**: You defect and exploit the higher payoffs from their efforts.
- **If cooperation oscillates around m**: You adapt each round based on last round count.
- **If you are uncertain (e.g., no clear m-1 cooperators last round)**: Defect to avoid exploitation.

---

## Pseudocode

```python
def aggressive_strategy(t, r, m, n, last_round_actions):
    """
    t            : current round number (1-based)
    r            : total rounds
    m            : cooperation threshold
    n            : number of players
    last_round_actions: list of length n with 'C' or 'D' from previous round
    """
    # Round 1: Defect by default
    if t == 1:
        return 'D'

    # Last round cooperators count
    cooperators_last = last_round_actions.count('C')

    # Last round: Always defect
    if t == r:
        return 'D'

    # Intermediate rounds:
    if cooperators_last < m - 1:
        # Not enough cooperators; defect to avoid losing cost
        return 'D'

    elif cooperators_last == m - 1:
        # Cooperate to just hit threshold
        return 'C'

    else:
        # Threshold met or exceeded; defect and exploit
        return 'D'
```

---

## Summary

| Situation                          | Action |
|----------------------------------|--------|
| Round 1                          | Defect |
| Rounds 2..(r-1), coop last < m-1 | Defect |
| Rounds 2..(r-1), coop last = m-1 | Cooperate |
| Rounds 2..(r-1), coop last ≥ m    | Defect |
| Round r                         | Defect |

---

## Why is this strategy aggressive?

- **Maximizes private payoff** by cooperating only when strictly necessary.
- **Exploits cooperative players** by defecting when threshold already met.
- **Avoids risky lone cooperation** that leads to net loss.
- **Punishes over-cooperators** by capitalizing on their contributions.
- **Refuses to be exploited in last round** (defects since no future incentives).

This balances selfishness with minimal cooperation needed to avoid missing out on collective rewards — a classic aggressive exploitation approach in collective risk dilemmas.
'''

description_AGGRESSIVE_102 = '''
Here is an aggressive strategy for the Collective Risk Dilemma, designed to maximize your own payoff by exploiting cooperative players while maintaining enough cooperation in the group to secure the collective reward when profitable.

---

## Strategy Name: Opportunistic Exploiter

### Aggressive Mindset Rationale
- **Primary goal:** Maximize own payoff over r rounds by defecting as much as possible.
- **Secondary goal:** Ensure the cooperation threshold *m* is met only when it benefits you directly (i.e., you still get the reward *k*).
- **Exploitation:** Use knowledge about others' previous rounds to identify cooperators and free ride on their cooperation.
- **Manipulation:** Occasionally cooperate early to incentivize others to cooperate, then defect to reap higher payoffs.
- **Edge cases:** Use informed decision-making in the last round to maximize immediate payoff, knowing no future retaliation is possible.

---

## Decision Rules

### Round 1 (No history)
- Cooperate **only if** initial cooperation is required for threshold *m* with a minimum number of cooperators you estimate will cooperate.
- Otherwise, defect to start exploiting naive cooperators.
- Since no information is available, aggressive choice: **Defect**.

### Intermediate Rounds (2 ≤ t < r)
- Track cooperation patterns of other players from previous rounds.
- Estimate whether threshold *m* will be met this round based on others' past cooperation frequency.

**If threshold likely met without your cooperation:**
- **Defect** to free-ride and gain the reward plus keep your endowment.

**If threshold unlikely met without your cooperation:**
- Calculate if cooperating increases total payoff.

Two cases:

1. If cooperating *could* push total cooperators to ≥ m (threshold met):
   - Cooperate **only if** that increases your expected payoff relative to defecting.
   - Otherwise, defect.

2. Else:
   - Defect (since cooperation won't yield reward).

---

### Last Round (t = r)
- Since no future retaliation is possible, maximize immediate payoff.
- Defect if others will meet threshold without you.
- Cooperate only if your cooperation is necessary to meet threshold.
- Otherwise, defect.

---

## Pseudocode

```python
# Inputs: 
#   history - list of tuples/list of each round's actions by all players; indexed by round and player
#   n, r, m, k as per game spec
#   player_index - your index i in range(0, n-1)

def decide_action(t, history, n, r, m, k, player_index):
    if t == 1:
        # First round: defect aggressively (exploit)
        return 'D'

    # Calculate cooperation counts in previous round
    previous_round_actions = history[t-2]
    coop_counts_prev = sum(1 for a in previous_round_actions if a == 'C')

    # Calculate others' cooperations in previous round excluding self
    others_coop_prev = coop_counts_prev - (1 if previous_round_actions[player_index] == 'C' else 0)

    # Estimate others' cooperation tendency over history
    total_coop_counts = [0]*n
    for round_actions in history:
        for idx, a in enumerate(round_actions):
            if a == 'C':
                total_coop_counts[idx] += 1
    avg_coop_others = sum(total_coop_counts) - total_coop_counts[player_index]
    avg_coop_others /= (n-1) * (t-1)

    # Estimate expected cooperators this round excluding self
    expected_others_coop = others_coop_prev  # use last round as proxy

    # For aggressive play, assume others keep same behavior as last round
    if expected_others_coop >= m:
        # Threshold met without you
        # Defect to maximize payoff (get 1 + k)
        return 'D'
    elif expected_others_coop == m - 1:
        # You can push threshold met by cooperating

        # Cooperate payoff: 0 (cost) + k (reward) = k
        # Defect payoff: 1 (keep endowment) + 0 (no reward) = 1

        # But if threshold met, defect payoff would be 1 + k

        # Here, cooperating helps threshold, so lets cooperate to get k
        # But defecting will result in threshold failure if you defect now

        # So cooperate for reward k (payoff = k)
        return 'C'
    else:
        # If threshold not met and can't meet it by cooperating, defect for payoff 1
        return 'D'

    # Last round adjustment
    if t == r:
        # If cooperation needed to meet threshold, cooperate once
        # Otherwise defect to maximize payoff
        pass  # handled above already
```

---

## Summary

- **Round 1:** Defect (exploit initial cooperators)
- **Rounds 2 to r-1:** Defect unless your cooperation is essential to meet *m*, then cooperate
- **Round r:** Cooperate only if absolutely necessary to meet threshold; defect otherwise

This strategy aggressively exploits cooperators, leverages perfect information to avoid unnecessary cooperation, and secures maximum payoff from the reward *k* and individual endowment. It tolerates free-riding but does not voluntarily sacrifice your payoff beyond what is necessary to secure the collective reward.
'''

description_AGGRESSIVE_103 = '''
Here is a detailed aggressive strategy for the Collective Risk Dilemma game:

---

### Intuition for Aggressive Strategy

- Aggression here means **maximizing your own payoff, even at the expense of group cooperation and punishing cooperators**.
- The best individual payoff occurs when the threshold m is met, but you personally defect — you gain payoff = 1 (keep endowment) + k (reward).
- Aggressors attempt to exploit cooperators by defecting whenever the threshold can still be met without them.
- The strategy seeks to avoid being exploited by playing cooperatively only when necessary to "nudge" the group past the threshold — but only if forced.
- It punishes cooperation by cooperating less, encouraging others to bear the cost.

---

### Aggressive Strategy Description

#### Parameters and Observables per round t:

- Current round t ∈ {1,…,r}
- History of players’ cooperation counts per round from past rounds (t-1, t-2, …)
- Number of observed cooperators in current round excluding self, denoted `C_others`

---

### Decision Rules

#### First Round (t=1):

- **Defect.**  
Since no information on other players’ behavior, aggression dictates maximizing payoff by defection to exploit potential cooperators.

#### Subsequent Rounds (t=2,...,r-1):

- Observe the number of cooperators in previous rounds.
- In round t, check anticipated cooperators excluding self (based on previous rounds’ frequencies or round t-1):

  - If previous round suggests the group frequently reached or almost reached m cooperators **without your cooperation**, **defect** aggressively to reap reward without cost.
  
  - Otherwise, **cooperate only if defecting would make the threshold unlikely to be met**, and:
    - Your cooperation can tip the number of cooperators in this round ≥ m,
    - You anticipate your cooperation will yield the collective reward k for yourself,
    - If in doubt, defect.

- To formalize:

  ```
  If (Expected # cooperators without self) ≥ m:
      Play D (defect)
  Else if (Expected # cooperators without self) = m - 1:
      Play C (cooperate) to reach threshold and earn reward k
  Else:
      Play D
  ```

- Expected # cooperators can be computed using frequency of each player’s cooperation in past rounds or estimated from last round.

#### Last Round (t = r):

- **Defect unconditionally.**

  - Since there is no future to punish you for defecting, no incentive to cooperate.
  - Aggression demands maximizing personal payoff, so defect to reap possible reward if threshold reached; if threshold not met, defect to keep endowment.

---

### Handling Edge Cases and Synchronization

- If historical data is insufficient or ambiguous (e.g., all defected in last round), defect anyway to maximize personal payoff.
- If it appears cooperation is very rare or threshold rarely met, defect consistently — let others bear cooperative costs.
- If cooperation is stable without your involvement, exploit by defecting often.
- If cooperation must be marginally boosted by you, reluctantly cooperate just enough to reach the threshold and gain k.

---

### Pseudocode Outline

```python
def aggressive_strategy(t, r, m, n, k, history):
    # history: list of rounds, each round is a list of actions for n players ('C' or 'D')
    
    if t == 1:
        return 'D'  # Aggressive: defect on first round
    
    if t == r:
        return 'D'  # Last round defect always
    
    # Estimate expected number of cooperators excluding self in this round based on past rounds
    
    # Compute cooperation frequencies of others in past rounds
    cooperation_counts = [0]*(n-1)  # exclude self indexed arbitrarily
    total_rounds = t - 1
    
    for past_round in history:
        index_other = 0
        for i, action in enumerate(past_round):
            if i == self_index:  # self index known internally
                continue
            if action == 'C':
                cooperation_counts[index_other] += 1
            index_other += 1
            
    cooperation_freq = [count/total_rounds for count in cooperation_counts]
    expected_cooperators_excl_self = sum(cooperation_freq)
    
    # Decision rule
    if expected_cooperators_excl_self >= m:
        return 'D'  # Exploit cooperators
    elif expected_cooperators_excl_self == m - 1:
        return 'C'  # Cooperate only to tip the threshold
    else:
        return 'D'  # Defect and avoid cooperation cost
```

---

### Summary of the Aggressive Strategy

- **First round:** Always defect to exploit.
- **Intermediate rounds:** Defect except to *just* meet the threshold if your cooperation is essential to trigger reward.
- **Last round:** Always defect as future retaliation is impossible.
- **Behavior exploitative:** When others are cooperators, benefit by defecting.
- **Behavior self-interested:** Cooperate only when necessary to unlock collective reward for self.
- **Minimize own cooperation costs.**

---

This strategy maximizes personal expected payoff exploiting group cooperation, punishes cooperators by free-riding, and is clearly aggressive in approach across all rounds while responding adaptively to observed behavior.
'''

description_AGGRESSIVE_104 = '''
Below is a detailed aggressive strategy for the Collective Risk Dilemma repeated game. The aggressive mindset here means you aim to maximize your own payoffs aggressively, exploiting others' cooperation while forcing others to bear the burden of cooperation when necessary. You will **defect as often as possible to maximize your private payoff**, but **cooperate only when strictly necessary** to secure the reward when it benefits you personally. You will be **opportunistic**, allowing others to cooperate first and leeching off their cooperation whenever possible.

---

### Aggressive Strategy Design for the Collective Risk Dilemma

**Intuition:**  
- Defect unless cooperation is strictly needed to secure the reward **and** cooperation will increase your immediate payoff relative to defecting.  
- Never cooperates preemptively or out of goodwill.  
- Uses information about previous rounds' cooperation levels to gauge how many others cooperate and when you must cooperate to force the threshold.  
- Exploits last round by defecting always (no future retaliation possible).  
- Attempts to punish cooperators indirectly by being reliably defecting, forcing them to pay cooperation costs continuously.

---

### Decision Rules

Let’s define:

- `round` = current round number (1 to r)
- `prev_coop_count` = number of cooperating players observed in previous round (except self; or if first round, no info)
- `c_i` = your action this round (C or D)
- `m` = cooperation threshold
- `n` = total players
- `k` = reward multiplier
- `r` = total rounds

---

#### Core Logic Per Round

1. **First round (no history):**  
   - Defect to test the waters (try to free-ride, see if others cooperate)  
   - `c_i = D`
   
2. **Subsequent rounds (2 to r - 1):**  
   - Observe how many others cooperated in the last round (excluding you)  
   - Calculate how many cooperators needed this round to meet `m`:
     - `needed = m - prev_coop_count`  
   
   - **If `needed <= 0`:**  
     - Enough others cooperated last round to meet threshold without you.  
     - Defect to maximize the private payoff plus reward.  
     - `c_i = D`  
   
   - **If `needed == 1`:**  
     - Cooperation of just one player needed to reach threshold this round.  
     - You can secure the reward by cooperating alone this round.  
     - **Because you get payoff (0 + k) if cooperate, or (1 + 0) if defect** — check which payoff is higher:  
       - Cooperate payoff = `0 + k`  
       - Defect payoff = `1 + 0`  
     - If `k > 1` (always true per spec),  
       - If `k ≥ 1 + 0` (i.e. `k > 1`) ⇒ cooperate for reward, because `0 + k > 1 + 0`  
       - Else defect  
     - So cooperate when `needed == 1`  
     - `c_i = C`  
   
   - **If `needed > 1`:**  
     - Too many cooperators needed to meet threshold given last round’s behavior.  
     - Defect; do not pay cost cooperating when less chance of reaching threshold.  
     - `c_i = D`

3. **Final round (round == r):**  
   - Defect regardless.  
   - No future rounds to punish, so no incentive to cooperate.  
   - `c_i = D`

---

### Edge Case Handling

- **First round no history → Defect** to test opponent strategies (free-ride first).
- **Last round → Always defect** (no further rounds to enforce cooperation).
- **If reward is so small that cooperating is never beneficial:**  
  - Since `k > 1` by specification, cooperating when exactly one cooperation needed will always be better than defecting.
- **If `m` is very close to `n` (almost everyone must cooperate):**  
  - The aggressive strategy will nearly always defect except when critical (needed == 1).
- **No communication / memory limited to previous round only:**  
  - Only use last round’s aggregate cooperation count for decision.

---

### Pseudocode

```python
def aggressive_collective_risk_strategy(round, r, n, m, k, prev_round_actions):
    # prev_round_actions: list of actions of all players last round (C/D), including self

    # Count cooperators excluding self in previous round
    if round == 1:
        # No history, defect first round
        return 'D'

    # For rounds > 1, excluding self
    prev_coop_count = sum(1 for action in prev_round_actions if action == 'C') - (1 if prev_round_actions[self_index] == 'C' else 0)

    # Last round defect
    if round == r:
        return 'D'

    needed = m - prev_coop_count

    if needed <= 0:
        # Enough others cooperated, don't pay cost
        return 'D'

    elif needed == 1:
        # Only one cooperation needed - your cooperation guarantees reward
        # Compare payoffs:
        coop_payoff = 0 + k
        defect_payoff = 1 + 0

        if coop_payoff > defect_payoff:
            return 'C'  # cooperate to get reward
        else:
            return 'D'  # defect if reward not worth cost (won't happen given k>1)

    else:
        # More than one cooperation needed; don't cooperate
        return 'D'
```

---

### Summary

- **Defect always unless your single cooperation is the critical last one needed to get the reward.**
- **Never preemptively cooperate.**
- **Defect in first and last rounds regardless.**
- **Leech the efforts of cooperators aggressively to maximize your payoff.**

This strategy aligns with an aggressive mindset by minimizing your cooperation cost while still opportunistically stepping in when cooperation will increase your payoff above simple defection. It punishes cooperation by never cooperating when your cooperation is not strictly decisive.

---

If you implement this strategy, expect to outperform naive cooperators and possibly force them to bear cooperation costs repeatedly.
'''

description_AGGRESSIVE_105 = '''
**Aggressive Strategy for Collective Risk Dilemma**

---

### Strategy Rationale

Being **aggressive** in this game means prioritizing **maximizing personal payoff potentially at the expense of others**. You are willing to exploit cooperators rather than uphold collective welfare. You actively defect to keep your endowment unless forced by circumstances to cooperate, and you strategically "free-ride" on minimal cooperation from others.

---

### Key Intuition

- You want others to cooperate enough so the threshold \(m\) is met, so you can **defect and still get the reward \(k\) + 1 payoff** (i.e., best payoff 1 + k).
- You will never volunteer to cooperate unless absolutely necessary.
- You “test” if the threshold is close to being met each round, and only reluctantly cooperate if the group is failing the threshold and you’re facing a zero-reward round.
- You exploit early rounds to signal defection and probe others' responses.
- In the last round, aggressively defect to maximize personal gain—no incentive to help the group last round.

---

### Decision Rules

#### Notation:
- \(C_t\): Number of cooperators (excluding self) in round \(t\) observed after play (round \(t-1\))
- \(m\): minimum cooperators needed
- \(n\): number of players
- \(r\): total rounds
- \(t\): current round (1-indexed)

---

### Pseudocode Outline

```python
for t in range(1, r+1):   # rounds 1 to r
    if t == 1:
        # First round: aggressive default to defect
        action = 'D'  

    else:
        # From round 2 onward:
        # Observe number of cooperators last round excluding self
        last_round_cooperators = count_cooperators_last_round_except_self()

        # Calculate total cooperators including self if I cooperated
        cooperators_if_defect = last_round_cooperators
        cooperators_if_cooperate = last_round_cooperators + 1

        # Aggressive logic:
        # If last round cooperators < m-1:
        #   * We have to cooperate this round to help cross threshold
        # Otherwise, defect aggressively

        # Edge case: last round → always defect aggressively
        if t == r:
            action = 'D'

        else:
            # Estimate if group will meet threshold without me cooperating:
            if cooperators_if_defect >= m:
                # Enough cooperators without me, defect aggressively
                action = 'D'
            elif cooperators_if_cooperate >= m:
                # I am pivotal; cooperating will tip threshold.
                # Decide aggressively: only cooperate if otherwise no reward (threshold missed)
                # i.e. if without cooperating threshold fails, cooperate reluctantly
                # But note this uses last round data; we have no guarantee same in current round 
                
                # Since perfect info on last round, use it as proxy
                if last_round_cooperators < m:
                    # Cooperate reluctantly to save this round's reward
                    action = 'C'
                else:
                    # React defect to maximize private payoff
                    action = 'D'
            else:
                # Too few cooperators last round for threshold even if I cooperate,
                # No point in wasting endowment cooperating
                action = 'D'
```

---

### Explanation

- **Round 1:** No information yet → **always defect** to maximize immediate payoff.
- **Early/Mid rounds (2 to r-1):** 
  - Check cooperation level of others last round.
  - Defect as long as threshold \(m\) is met by others without you.
  - If you are *pivotal* (others cooperating \(m-1\)), cooperate *only if* threshold failed last round; otherwise, defect to maximize payoff.
- **Last round:** Always defect. No future punishment or incentive to cooperate, so exploit cooperators fully.

---

### Edge Cases

- **If \(m\) is very close to \(n\):** You rarely cooperate, as threshold is high, depends on others. Aggressive defection still.
- **If others never cooperate:** You never cooperate (except reluctantly if you can single-handedly help meet threshold).
- **If others always cooperate:** You keep defecting and free-ride every round except first round free-ride starts by default.
- **If threshold oscillates around \(m\):** You cooperate reluctantly only on pivotal rounds to secure minimum reward.

---

### Summary

| Round           | Condition                           | Action   | Rationale                          |
|-----------------|-----------------------------------|----------|----------------------------------|
| 1 (first round) | No info                          | Defect   | Maximize payoff upfront           |
| 2 to r-1        | Others cooperate ≥ m (without you) | Defect   | Exploit cooperators               |
| 2 to r-1        | Others cooperate = m - 1          | Cooperate only if threshold missed last round (to secure payoff) else defect | Reluctant cooperation as last resort |
| 2 to r-1        | Others cooperate < m - 1          | Defect   | No point cooperating; wasted cost|
| r (last round)  | Any                              | Defect   | Maximize private gain; no future penalty |

---

This is a **clear aggressive free-rider strategy** that:

- Exploits cooperative players,
- Avoids wasting endowment except to just meet threshold if on the edge,
- Never volunteers to cooperate proactively,
- Is risk tolerant and opportunistic.
'''

description_AGGRESSIVE_106 = '''
Below is an **aggressive strategy** tailored for the Collective Risk Dilemma with the given parameters and repeated, simultaneous structure.

---

## Strategy Overview: "Aggressive Opportunist"

- **Philosophy:**  
  Prioritize maximizing individual payoffs aggressively by defecting as often as possible, but cooperate opportunistically *only* when the threshold \(m\) is close to being met to still secure the large reward \(k\). Use observed past actions to exploit cooperators, never trusting others to sustain cooperation on their own. Defect in the last round regardless to capture free-rides.

- **Why Aggressive?**  
  - Never voluntarily pay the cost (cooperate) when others won’t meet threshold.
  - Exploit rounds where others **must** cooperate to get the reward to contribute minimally.
  - Always defect when safe or at end-game to maximize private payoff.
  - Quickly punish excessive unconditional cooperators by defecting to drive their payoffs down.

---

## Key Intuition

- You want to reap reward \(k\) ideally *without* paying cost yourself.
- Since threshold requires \(m\) cooperators, if you can identify rounds where other players are likely to cooperate enough, you free-ride.
- If threshold not met, defect to avoid loss.
- If threshold close but uncertain, cooperate reluctantly to tip it over to get \(k\).
- In last round, defect no matter what (no incentive to maintain cooperation).
- Use history of others’ cooperation to estimate likelihood threshold can be met.

---

## Detailed Decision Rules

### START:  
- Round 1: **Defect (D)** by default (aggressive opening, try to free-ride before committing).

### GENERAL ROUND \(t\) (2 ≤ t < r):

1. **Observe last round’s cooperation count \(m_{t-1}\).**

2. **Estimate likelihood threshold \(m\) can be met this round based on history:**

   - If in last round \(m_{t-1} \geq m\), assume cooperation possible.
   - If in last two rounds \(m_{t-2} < m\) and \(m_{t-1} < m\), assume threshold unlikely.

3. **Decision:**
   - If threshold very likely met (others habitually cooperate) AND you can be pivotal (if last round, consider your cooperation can maintain threshold):
       - **Defect (D)** to free-ride → payoff = \(1 + k\).
   - If threshold borderline (e.g., \(m_{t-1} = m - 1\)), **Cooperate (C)** to push group over threshold:
       - This risks cost 1, but triggers reward \(k\), netting payoff \(k\) (≥ 1).
       - Advantageous only if you judge cooperation is essential and you benefit.
   - If threshold unlikely met:
       - **Defect (D)**, avoid cost with no reward.
   
### LAST ROUND \(t = r\):

- **Always Defect (D)** no matter what.
- No incentive to pay costs at end; maximize private payoff.

---

## Edge Cases

- **First Round no history:** Defect aggressively; no trust established.
- **If others cooperate continuously and threshold is always met:** Keep defecting to free-ride.
- **If threshold is never met historically:** Always defect to avoid wasting cost.
- **If you detect persistent unconditional cooperators (players who always play C):** Always defect against them to maximize gain.
- **If you observe some players sometimes cooperate near threshold but not always:** Cooperate only when your cooperation likely pivotal.

---

## Pseudocode

```python
# Inputs each round: history_coop_counts = [m_1, m_2, ..., m_{t-1}]
# Parameters: n, r, m, k

def decide_action(t, history_coop_counts):
    if t == 1:
        # Round 1 aggressive opening: defect
        return "D"
    
    if t == r:
        # Last round: always defect
        return "D"
    
    # Last observed cooperation count
    last_coop = history_coop_counts[-1] if t > 1 else 0
    
    # Cooperation counts last two rounds (if available)
    last_two = history_coop_counts[-2:] if t > 2 else [0, last_coop]
    
    if all(coop >= m for coop in last_two):
        # Threshold consistently met, free-ride
        return "D"
    
    if all(coop < m for coop in last_two):
        # Threshold consistently NOT met, no payoff from C
        return "D"
    
    # Borderline case: last round had m-1 cooperators
    if last_coop == m - 1:
        # Cooperate to push threshold over
        return "C" 
    
    # Otherwise defect
    return "D"
```

---

## Summary

| Round         | Action Logic                                             | Reason                          |
|---------------|----------------------------------------------------------|--------------------------------|
| 1             | Defect                                                   | Aggressive opener               |
| Rounds 2 to r-1 | Defect if threshold met or not likely met; cooperate only if borderline | Exploit cooperators, force threshold |
| r (last round)  | Defect                                                   | Maximize end-game payoff       |

---

This strategy:

- **Exploits cooperators effectively**, defecting when threshold met to get payoff \(1 + k\).
- **Minimally cooperates only to secure the reward if essential.**
- **Never trusts unconditional cooperation**, punishing those who always cooperate.
- **Maximizes individual payoff aggressively over the repeated horizon.**

This clearly qualifies as an aggressive stance aiming to dominate payoffs relative to more cooperative strategies.
'''

description_AGGRESSIVE_107 = '''
**Aggressive Strategy for the Collective Risk Dilemma**

---

### Core Ideas Behind the Aggressive Mindset:
- Aggressive = prioritize maximizing own payoff even at the expense of collective cooperation.
- Exploit others' cooperation: if others cooperate enough to hit the threshold, defect to get maximal payoff.
- Avoid being sucker: do not cooperate unless strictly beneficial or necessary.
- Use history to identify if threshold can be met without your cooperation; free-ride when possible.
- Pressure others via defection to avoid being exploited over multiple rounds.

---

### Step 1: Key Observations from the Game Setup
- Payoff if threshold reached and **I cooperate**: π_i = 0 + k = k (e.g., 2 in example)
- Payoff if threshold reached and **I defect**: π_i = 1 + k (better)
- Payoff if threshold not reached and I defect: 1 (better than cooperating and failing)
- Payoff if threshold not reached and I cooperate: 0 (lose cooperating cost with no reward)
- Best personal payoff is always to defect **if threshold is achieved** by others.

---

### Step 2: Aggressive Strategy Outline

**Notation:**
- r = total rounds
- t = current round (1 to r)
- m = cooperation threshold
- n = number of players
- last_round = (t == r)
- observations_t = recorded cooperation counts by all players in round t (excluding my own move)
- high_threshold_met = boolean indicating whether threshold was met in last round
- my_action_t−1 = my previous round action

---

### Step 3: Decision Rules

#### Round 1 (t = 1):
- Start aggressively: Defect (D) immediately to test or free-ride.
- *Rationale:* No history, so don't risk cooperation cost.

#### Subsequent Rounds (1 < t < r):
- Observe how many players cooperated last round (excluding self).
- Two key checks:

  1. **If threshold was met last round without my cooperation:**
     - Continue defecting (free-ride).
  
  2. **If threshold was not met last round, or cooperation count < m - 1:**
     - Defect (D).
     - *Rationale:* Threshold unlikely to be met even if cooperate; no incentive to incur cost.

  3. **If threshold was met only when I cooperated last round:**
     - Defect to avoid being exploited—let others pay cooperation cost this round.

#### Last Round (t = r):
- Defect unconditionally.
- *Rationale:* No future rounds to enforce cooperation or punish defectors, so avoid cooperation cost.

---

### Step 4: Edge Case Handling and Refinement

- If number of observed cooperators among others is exactly m - 1, cooperating can push payoff from 1 to (1 - 1) + k = k which could be less than defecting payoff if threshold met. But in aggressive mindset, prefer defect and hope others cooperate.

- Therefore, never cooperate unless forced by prior history shows cooperation is so rare threshold is not met and one time cooperation might gain future advantages (which aggressive ignores).

---

### Pseudocode

```python
def aggressive_strategy(t, r, m, n, coop_counts_prev_round, threshold_met_prev_round):
    # coop_counts_prev_round: number of other players who cooperated last round
    # threshold_met_prev_round: boolean if threshold was met last round
    
    if t == 1:
        # First round: defect aggressively
        return 'D'
    
    if t == r:
        # Last round: defect unconditionally
        return 'D'
    
    # From second to second last round:
    if threshold_met_prev_round:
        # Threshold met last round
        # Check if threshold was met WITHOUT my cooperation:
        # If coop_counts_prev_round >= m (others alone met threshold)
        if coop_counts_prev_round >= m:
            # Free-ride: defect
            return 'D'
        else:
            # Threshold was only met with my cooperation last round
            # Punish by defecting
            return 'D'
    else:
        # Threshold not met last round
        # Defect aggressively, no incentive to cooperate
        return 'D'
```

---

### Summary

- **Always defect unless evidence shows others cooperate without you.**
- **If threshold met by others (≥ m cooperators excluding you), defect to maximize payoff.**
- **If threshold not met or depends on your cooperation, still defect to avoid exploitation.**
- **First and last rounds always defect (no incentive to invest in cooperation with zero future rounds or lack of info).**

This strategy is **aggressive** by never paying cost to cooperate and striving to exploit cooperators' contributions whenever the collective threshold is met without you. It punishes others by refusing cooperation in all rounds, leveraging the higher payoff of defection when threshold is met.

---

**Note:** This aggressive strategy risks repeated failure to achieve threshold if all players defect, but maximizes payoff for the individual in mixed play or when others are trusting/cooperating.
'''

description_AGGRESSIVE_108 = '''
**Aggressive Strategy for the Collective Risk Dilemma**

---

### Conceptual Summary:

This aggressive strategy primarily attempts to **exploit cooperative players** by defecting as much as possible, maximizing private payoffs. It only cooperates when strictly necessary to trigger the collective reward *k* or when not cooperating would cause others to defect next round and reduce future payoffs. In other words, it seeks to minimize its cost (never cooperating unconditionally) while still pushing others to cooperate enough to hit the threshold—leveraging free-riding.

---

### Core Intuition (Aggressiveness):

- **Prefer Defection** to always gain private payoff (+1).
- **Only Cooperate if Definitely Necessary** to reach/exceed the cooperation threshold *m*.
- **Punish "naive" cooperators** by defecting more, eroding their incentive.
- Exploit the fact that others want the group reward but likely do not trust your cooperation.
- Toward the end, with no future rounds to leverage threats, **defect outright** to maximize immediate gain.

---

### Decision Rules Overview:

1. **Round 1 (no history):**  
   Defect to test others and gain initial private payoffs.

2. **Rounds 2 to r-1:**  
   - Check previous round’s cooperation count (how many cooperated last round).  
   - If previous cooperators count ≥ m:  
     Defect this round to free-ride on established cooperation.  
   - If previous cooperators count < m:  
     - Cooperate **only if** cooperating this round is necessary to hit *m* cooperation count (based on estimates or explicit counts).  
     - Else defect to pressure/force cooperators to reconsider.

3. **Round r (last round):**  
   Defect unconditionally, as no future rounds to induce cooperation or punishment.

---

### Handling Edge Cases:

- **First round no info → defect immediately!**  
- **If last round → defect no matter what** (avoid sunk cost of cooperation).  
- **If prior round had just barely enough cooperators (exactly m):** defect to maximize gain, still hitting reward but free-riding.  
- **If prior round had fewer than m cooperators:** cooperate only if your help is pivotal to reach the threshold this round; otherwise defect aggressively.  
- **If there is perfect info, the strategy can compute how many cooperated last round, and deduce how many cooperators needed this round**. If you can’t make this deduction explicitly, assume opponent strategies won’t all defect all at once (since k > 1 motivates cooperation).  

---

### Pseudocode:

```python
# Inputs per round:
# prev_round_actions: list of actions by all players in previous round (None for round 1)
# m, n: game parameters (cooperation threshold, number of players)
# round_number: current round index (1-based)
# r: total number of rounds

def aggressive_strategy(prev_round_actions, m, n, round_number, r):
    # 1. First round: Defect
    if round_number == 1:
        return 'D'

    # 2. Last round: Defect unconditionally
    if round_number == r:
        return 'D'

    # 3. Count how many cooperated last round
    coop_count_last = prev_round_actions.count('C')

    # 4. If threshold met last round, free ride by defecting
    if coop_count_last >= m:
        return 'D'

    # 5. If threshold was missed last round, decide if cooperation needed
    # Assume other players will respond similarly
    
    # Estimate cooperators needed this round to meet threshold
    # Since we don't know others' actions this round, we guess:
    # If cooperating will reach threshold, cooperate, else defect.
    # Aggressive: cooperate only if your cooperation raises count from < m to >= m.
    # You know: coop_count_last < m, assume other players repeat last round actions.
    # So if coop_count_last + 1 >= m, you cooperate
    if coop_count_last + 1 >= m:
        return 'C'  # pivotal cooperation

    # Otherwise defect aggressively
    return 'D'
```

---

### Explanation of Strategy Dynamics:

- Starts aggressive by defecting immediately to maximize initial payoff.
- Uses past behavior of others as a predictor; only intervenes (cooperates) if cooperation is pivotal this round.
- Freerides whenever possible: if others cooperated enough to surpass threshold, never help them by cooperating yourself.
- Drops cooperation completely on the last round (since future punishment or reward is moot).
- Does *not* try to build trust or establish cooperation; instead forcibly extracts gains by opportunistic defecting.

---

### Why is this Aggressive?

- It exploits the cooperation of others without investing.
- It is minimally cooperative, only when absolutely necessary to secure the collective prize.
- It punishes cooperators by defecting often, making their gains fragile.
- It prioritizes self gain at the expense of group stability and trust.
- It minimizes contribution costs and maximizes payoff exploitation.

---

If implemented against more naive or trustful strategies, you should extract consistently high payoffs by free-riding and conditional cooperation only when you "must".

---

**Summary:** Defect round 1; from round 2 to r-1 cooperate only if your cooperation is strictly pivotal to meet the threshold; otherwise defect; always defect round r.

This balances maximizing immediate payoffs and strategic opportunism—exactly what an aggressive strategy demands.
'''

description_AGGRESSIVE_109 = '''
**Overview:**  
The goal of an *aggressive* strategy in the Collective Risk Dilemma is to maximize the player’s own payoff at the expense of cooperators whenever possible, while still ensuring the collective reward can be triggered (since the reward significantly increases payoffs). The strategy focuses on exploiting cooperators by defecting whenever it will not prevent reaching the cooperation threshold *m*, and cooperating only when necessary to trigger the reward. Over repeated rounds, it adapts to other players’ behaviours to maximize exploitation.

---

## Aggressive Strategy Description

### Intuition
- **First round:** Assume full cooperation from others is unlikely; defect to gain the immediate payoff 1.
- **Subsequent rounds:**  
  - Observe how many cooperated in the previous round.  
  - Cooperate only if the previous round’s cooperation level fell below *m* and cooperating is necessary to push cooperation to the threshold (trigger reward).  
  - Otherwise, defect to capitalize on reward when others cooperate.  
- **Last round:**  
  - Defect to maximize immediate payoff since there is no future punishment or reward to consider.  
- **Exploit cooperators:** When *m* or more cooperate, defectors earn **1 + k**, outcompeting cooperators who earn only **k**. So, exploit by defecting whenever reward is activated.  
- **Punish non-cooperation:** If cooperation threshold is not met, cooperate to try to reach it (only if profitable), otherwise defect.

---

## Notation for Strategy

- `round`: current round (1 ≤ round ≤ r)  
- `coop_count_last_round`: number of players who cooperated in previous round (from observations)  
- `threshold_m`: minimum cooperators needed  
- `n_players`: total number of players

---

## Decision Rules Pseudocode

```
function decide_action(round, coop_count_last_round, threshold_m, n_players):

    # FIRST ROUND (no history)
    if round == 1:
        # Aggressive: start by defecting to collect immediate payoff
        return 'D'

    # LAST ROUND
    if round == r:
        # No future rounds; defect to grab private payoff
        return 'D'

    # INTERMEDIATE ROUNDS
    # If previous cooperation met or exceeded threshold:
    if coop_count_last_round >= threshold_m:
        # Exploit cooperators by defecting for extra reward payoff
        return 'D'

    # If cooperation was below threshold:
    else:
        # If defecting would keep cooperation below threshold, cooperate to help 
        # reach threshold and unlock reward.
        # Calculate minimum number of cooperators required from now (including self)
        # to reach threshold
        min_coop_needed = threshold_m - coop_count_last_round
        
        # Since all players are independent and non-communicative, we only ensure
        # our cooperation helps if it can swing the group over threshold
        if min_coop_needed > 0 and min_coop_needed <= 1:
            # Our single cooperation will push over threshold, so cooperate
            # to trigger reward for all (including self)
            return 'C'
        else:
            # Cooperation unlikely to succeed, defect to get immediate payoff
            return 'D'
```

---

## Handling Edge Cases and Notes

- If at any point the previous round’s cooperation was exactly *m - 1*, cooperating is critical to unlock the reward, so cooperate.
- If cooperation count is already at *m* or above, do **not** cooperate (defect and take advantage).
- If cooperation is very low and cannot be salvaged with your single cooperation, defect.
- No cooperation in first or last round (unless first round assumption is changed; aggressive mindset prefers defect).
- The strategy exploits repetitive cooperation by others but does not try to sustain cooperation itself outside of pivotal moments.
- This strategy **does not forgive** or punish defectors; it is strictly opportunistic and aggressive.
- Assumes perfect observation of all player actions each round.

---

## Summary

| Round           | Condition                                      | Action             |
|-----------------|------------------------------------------------|--------------------|
| 1               | No history                                     | Defect             |
| r (last round)  | End of game, no future payoff                  | Defect             |
| Intermediate    | Previous cooperators ≥ m                        | Defect (exploit)   |
| Intermediate    | Previous cooperators = m - 1                    | Cooperate (push threshold) |
| Intermediate    | Previous cooperators < m - 1                    | Defect             |

---

**In essence:** This aggressive strategy leverages others’ cooperation while contributing only when it is pivotal to unlock the reward, and otherwise defects to maximize personal gain.
'''

description_AGGRESSIVE_110 = '''
Below is an aggressive strategy for the Collective Risk Dilemma tournament. The focus is to exploit cooperative players, maximize own payoff, and apply pressure on others to either cooperate at minimal cost or face exploitation.

---

### Strategy Overview

- **Aggressive mindset:** Defect unless there is strong evidence that cooperation will yield a better payoff for you.
- **Exploit cooperators:** If sufficient cooperators likely exist, defect to gain the reward *and* keep your private payoff.
- **Punish defectors cautiously:** Avoid losing out by cooperating when the threshold won't be met.
- **Use history to predict minimum cooperators:** Based on observed behavior until the previous round.
- **Edge cases:** Special treatment of first and last rounds to optimize payoff.

---

### Notation

- `n`: number of players
- `m`: minimum cooperators needed
- `r`: total rounds
- `k`: reward factor (> 1)
- `round`: current round (1-based)
- `cooperations_t`: number of cooperators observed in round t
- `threshold_met_t`: Boolean indicating if cooperators ≥ m in round t
- `history`: record of actions for all players in previous rounds

---

### Intuition on Payoffs

- Defecting when ≥ m cooperators: payoff = 1 (keep endowment) + k (reward) = 1 + k (best payoff)
- Cooperating when ≥ m cooperators: payoff = 0 (cost) + k (reward) = k
- Defecting when < m cooperators: payoff = 1 (no reward)
- Cooperating when < m cooperators: payoff = 0 (loss relative to defect)

Aggressive play means maximizing payoff by defecting when threshold met; minimizing losses otherwise.

---

### Decision Rules Pseudocode

```python
def choose_action(round, history, n, m, r, k):
    # --- First round ---
    if round == 1:
        # No history: guess number of cooperators
        
        # Aggressive choice: Defect first round to avoid risk of losing endowment
        # Reason: Without prior info, cooperating risks unnecessary loss
        return 'D'
    
    # --- From round 2 to round r-1 ---
    else:
        # Estimate likelihood threshold will be met based on previous rounds

        # Count how many players cooperated (excluding self) in last round
        coop_counts_last = number_cooperators_in_round(history, round - 1)

        # Remove self from count if player cooperated last round:
        last_actions = get_actions_for_round(history, round - 1)
        self_cooperated_last = last_actions[self_player_index] == 'C'
        
        # Estimated cooperators excluding self
        coop_others_last = coop_counts_last - (1 if self_cooperated_last else 0)

        # If last round had threshold met:
        if coop_counts_last >= m:
            # Likely cooperators repeat cooperation to get reward
            # Aggressive: Defect to exploit cooperators putting in effort
            return 'D'
        
        # If last round threshold not met:
        else:
            # Check if cooperating can push group to threshold
            if coop_others_last >= m - 1:
                # Our cooperation can tip threshold and earn reward k
                # Aggressive: Cooperate when it's only beneficial (to trigger reward)
                return 'C'
            else:
                # Otherwise defect; no incentive to cooperate as threshold won't be met
                return 'D'
    
    # --- Last round (round == r) ---
    if round == r:
        # Aggressive mindset: defect in last round to maximize payoff
        # No future rounds, so no incentive to cooperate
        return 'D'
```

---

### Explanation

- **Round 1:** Defect. No info, so avoid losing the endowment.
- **Rounds 2 to r-1:**  
   - If previous round met threshold, defect to exploit cooperators (max payoff = 1 + k). Cooperators pay cost (c=1).
   - If previous round failed threshold but you can be the pivotal cooperator (others cooperated enough to need you), cooperate to get reward k (payoff = k), better than defecting when threshold fails.
   - Else, defect as cooperation won't pay off.
- **Round r (last round):** Defect to maximize immediate payoff; no future punishment or reward incentive.

---

### Edge Cases

- If observation includes players changing strategies erratically, rely only on immediate last round behavior.
- If others start defecting after prior threshold met, keep defecting aggressively.
- Potentially getting stuck in all-defect state, but aggressive maximization favors exploiting cooperation rather than leading cooperation.

---

### Summary

This strategy aggressively leverages knowledge of past rounds to defect whenever possible, exploits cooperators when threshold is met, and only cooperates to push threshold over the edge if such cooperation guarantees reward without undue risk.

---

If you want, I can provide a more formalized or detailed pseudocode version.
'''

description_AGGRESSIVE_111 = '''
Below is an aggressive strategy designed for the Collective Risk Dilemma. The strategy focuses on maximizing personal payoff opportunistically, exploiting cooperative players when beneficial, and signaling threats to induce cooperation but defecting whenever it improves the player's relative gain.

---

### Aggressive Strategy: "Exploit & Pressure"

#### Intuition:
- **Early rounds:** Start by defecting to gather information and avoid early cooperation costs.
- **Mid-game:** If others cooperate enough to meet or exceed the threshold, defect to get the highest payoff (reward + keep endowment).
- **If cooperation dips below threshold:** Cooperate selectively to push others towards meeting threshold (to increase everyone's payoff, but primarily to incentivize cooperation for your future gain).
- **Last round:** Defect unless confident cooperation threshold is met; no incentive to pay cooperation cost.

---

### Decision Rules

Let:
- \( t \) = current round (1 to \( r \))
- \( C_t \) = number of players who cooperated in round \( t \)
- \( m \) = threshold for cooperation payoff
- \( r \) = total number of rounds

---

#### Round 1 (Initial Observation & Test):

- Defect (\(D\)) to avoid early cooperation cost and gauge opponents' tendencies in later rounds.

---

#### Middle Rounds \( 2 \leq t < r \):

1. **If last round \( t-1 \) had at least \( m \) cooperators:**

   - Defect (\(D\)) to free-ride on others' cooperation for maximal payoff.

2. **If last round \( t-1 \) had fewer than \( m \) cooperators:**

   - Cooperate (\(C\)) to help push the group towards threshold.

---

#### Last Round \( t = r \):

- Defect (\(D\)) unless in last round \( r-1 \), at least \( m \) cooperated (suggesting high cooperation likelihood).

- Reason: No future rounds in which to punish or reward, so minimize cooperation costs.

---

#### Additional Mechanism: **Retaliation Threat**

- If the group cooperated **but you still cooperated last round** and opponents defected, switch to persistent defection for the rest of the game to punish freeriders.

---

### Summary of Behavior Pattern

| Round            | Condition                     | Action                          |
|------------------|-------------------------------|--------------------------------|
| \( t = 1 \)      | Always                       | Defect (D)                     |
| \( 2 \leq t < r \) | Last round \( C_{t-1} \geq m \)      | Defect (D) - exploit            |
|                  | Last round \( C_{t-1} < m \)         | Cooperate (C) - push threshhold|
| \( t = r \)      | If \( C_{r-1} \geq m \)              | Defect (D)                     |
|                  | Else                     | Defect (D)                     |

---

### Pseudocode

```python
# Initialize punishment flag
punish = False

for t in range(1, r+1):
    if punish:
        action = 'D'
    else:
        if t == 1:
            # Round 1: test waters by defecting
            action = 'D'
        elif t < r:
            # Check previous round's cooperation count
            if C_{t-1} >= m:
                # Exploit others by defecting
                action = 'D'
            else:
                # Cooperate to help reach threshold
                action = 'C'
        else:
            # Last round logic
            if C_{r-1} >= m:
                # No incentive to cooperate, defect
                action = 'D'
            else:
                # Defect anyway - no future consequences
                action = 'D'

    # After observing opponents' behaviors, update punish flag
    # If last round cooperated but got exploited by defectors, punish:
    if t > 1:
        if (I_cooperated_last_round and opponents_withheld_cooperation_last_round):
            punish = True
    
    play(action)
```

---

### Explanation

- **Aggressive exploit:** When threshold met, always defect to maximize payoff (get \(1 + k\) rather than \(k\)).
- **Manipulative cooperation:** Cooperate only when cooperation is insufficient, to "push" group payoff above threshold and then exploit it next round.
- **Last round defection:** No incentive to cooperate with no future retaliation or reward.
- **Punishment:** If naive cooperation is exploited, switch to permanent defection to punish freeriders aggressively.

---

### Edge Cases Addressed

- **First round:** Defect always (gather info, avoid cost).
- **Last round:** Defect always (no future benefits).
- **Persistent defection if exploited:** Avoid being a sucker repeatedly.
- **Threshold near edges:** Strategy dynamically adapts based on past round cooperation counts.

---

This approach maximizes personal payoffs aggressively by leveraging cooperation of others but never paying cooperation cost unless necessary to maintain threshold, with strong retaliation for betrayal.
'''

description_AGGRESSIVE_112 = '''
Here is an aggressive strategy tailored for the Collective Risk Dilemma game, designed to maximize individual payoffs by exploiting cooperative incentives while maintaining a threat posture to enforce cooperation from others.

---

### Aggressive Strategy Overview

**Objective:**  
Maximize total individual payoff by defecting as much as possible while ensuring the cooperation threshold (m) is met to obtain the reward k.  
This involves "free-riding" whenever the required number of cooperators is achieved but forcing cooperation early and intermittently to guarantee threshold attainment.

---

### Key Insights for Aggressive Play

- Defection yields better immediate payoff if threshold is met because defectors keep their endowment (π_i = 1 + k) vs cooperators lose it (π_i = 0 + k).
- Cooperators are "sacrificing" their payoff to ensure the public good.
- Aggression means minimizing your costly cooperation rounds, only cooperating enough to avoid losing the collective reward.
- Since the game is repeated, your behavior can enforce cooperation indirectly by threatening to defect permanently if the threshold is missed.
- Without communication, signaling aggressive intent requires observable patterns.

---

### Parameters and Variables

- n = number of players
- r = total rounds
- m = minimum cooperators needed
- k = reward multiplier

Define:

- round t ∈ {1, 2, ..., r}
- history: record of all players’ actions for previous rounds
- coop_count_t-1: number of cooperators observed in previous round t-1 (if t > 1)

---

### Strategy Decision Rules

**Round 1 (Initial Move):**  
- Cooperate aggressively to help reach threshold: cooperate if m is relatively high (e.g., m ≥ n/2).  
- Otherwise, defect (free-ride hoping others cooperate).  
- This imposes a conditional initial stance and tests opponent willingness.

**Rounds 2 to r-1 (Intermediate Rounds):**

- If in previous round coop_count_t-1 ≥ m (threshold met):  
  - Defect aggressively to maximize payoff (free ride on others’ cooperation).

- If coop_count_t-1 < m (threshold *missed*):  
  - Switch to cooperation to push threshold back to being met.  
  - If you cooperated last round, continue cooperating (demonstrating commitment).  
  - If you defected last round, cooperate now to regain trust.

**Round r (Final Round):**

- Defect always.  
- No future punishment possible, so maximize individual payoff.

---

### Summary of Behavior

| Round | If threshold met last round | If threshold missed last round | Special Notes         |
|-------|-----------------------------|-------------------------------|-----------------------|
| 1     | Cooperate if m ≥ n/2, else Defect | N/A                           | Test the waters       |
| 2..r-1| Defect (free-ride)           | Cooperate (rebuild cooperation) | Enforce threshold     |
| r     | Defect                      | Defect                        | Maximize last-round gain |

---

### Pseudocode

```python
def aggressive_strategy(t, history, n, m, r):
    # t: current round (1-indexed)
    # history: list of previous rounds' actions, each round a list of n actions 'C' or 'D'
    
    # Helper function to count cooperators last round
    def count_cooperators(round_actions):
        return sum(1 for a in round_actions if a == 'C')
    
    if t == 1:
        # Initial move: cooperate if threshold relatively high, else defect
        if m >= n / 2:
            return 'C'
        else:
            return 'D'
    
    # From round 2 onward
    coop_count_last_round = count_cooperators(history[-1])
    
    if t == r:  # Last round
        return 'D'  # no incentive to cooperate
    
    if coop_count_last_round >= m:
        # Threshold met last round - aggressively defect to free ride
        return 'D'
    else:
        # Threshold missed last round - cooperate to help restore cooperation
        # Also check own last action
        my_last_action = history[-1][my_index]  # assume player index is known as my_index
        if my_last_action == 'C':
            return 'C'  # continue cooperating
        else:
            return 'C'  # switch from defection to cooperation to signal willingness
    
```

---

### Aggression Justification

- By cooperating only enough and only when cooperation fails, you free-ride on others’ contributions most rounds.
- Threat of defecting continuously if threshold missed incentivizes others to cooperate.
- Defection in final round maximizes last-payoff with no future consequences.
- Initial decision based on threshold size is a strong signal, demanding cooperation but ready to exploit if threshold is low.

---

### Edge Cases

- **If threshold m is very low (e.g., m=2 and n=6):**  
  Cooperate initially only if needed; otherwise defect immediately and rely on others to cooperate.

- **If repeated threshold failures:**  
  Continue cooperating to enforce threshold, but if no cooperation emerges, exploit repeated defecting to maximize own one-shot payoffs.

- **If your cooperation is pivotal (m = n-1):**  
  Cooperate frequently since defection risks losing all reward.

---

This strategy is aggressive in maximizing private gain by defecting whenever threshold is satisfied but strategically cooperating to maintain threshold, exploiting repeated interaction without communication to shape others' behavior.
'''

description_AGGRESSIVE_113 = '''
Here is an aggressive strategy tailored for the Collective Risk Dilemma game, balancing incentive to exploit cooperators and risk managing to secure the group reward when it benefits you personally:

---

### Strategy Name: "Aggressive Exploiter with Minimal Cooperation"

**Core principle:**
- Defect as much as possible to maximize private payoff, but cooperate just enough to trigger the group reward *only when it is guaranteed or nearly guaranteed* to keep exploiting others’ cooperation.
- Avoid unilateral or low-level cooperation that primarily benefits others at your expense.
- Use early rounds to gauge other players’ baseline cooperation frequency.
- Ramp up exploitation in later rounds once you detect potential cooperators or guarantee threshold achievement.

---

## Detailed Strategy Description

### 1. Round 1 (No history yet):

- **Action:** Defect (D)
- **Rationale:** No information on others; best to gain from private payoff and test others’ behavior.

---

### 2. Observation and Threshold Assessment (Rounds 2 to r-1):

After each round t (t ≥ 1), observe:

- Number of cooperators c_t in previous round
- Your action a_i,t in previous round
- Others’ payoffs (helps infer cooperators vs defectors)

Define variables:

- `cooperator_count = number of players who played C last round`
- `expected_cooperators = moving average or majority behavior estimate over previous rounds`

Decision rules for round t+1:

- **If** `cooperator_count ≥ m` last round *and* you defected last round:
  - You earned payoff π_i = 1 + k (highest payoff).
  - **Action:** Defect again to keep exploiting cooperative threshold achievement.
- **Else if** `cooperator_count ≥ m` last round *and* you cooperated last round:
  - You earned payoff π_i = 0 + k, less than defectors.
  - **Action:** Defect next round to improve payoff by free-riding.
- **Else if** `cooperator_count = m - 1` and you defected last round:
  - Close to threshold but not achieved.
  - **Action:** Cooperate this round to try to tip threshold *if you believe others will not*.
- **Else if** `cooperator_count < m - 1`:
  - Threshold too risky this round.
  - **Action:** Defect to maximize private payoff, avoid wasting endowment.

---

### 3. Last Round (Round r):

- **If** expected or observed cooperators in round r-1 ≥ m:
  - **Action:** Defect to free-ride on others’ cooperation if threshold is likely achieved.
- **Else if** threshold was narrowly missed last round (cooperators = m - 1):
  - **Action:** Cooperate to try and reach threshold for collective payoff.
- **Else**:
  - Defect; no incentive to pay cost with no reward.

---

### 4. Handling edge cases:

- **If anything is ambiguous or no clear pattern emerges:** Default to defection to avoid exploitation.
- **If others appear to cooperate fully (rare):** Defect continuously to maximize payoff.
- **If threshold never reached and others defect mostly:** Defect always.
- **If threshold just reached in early rounds:** Start defecting immediately to exploit cooperative players.

---

## Pseudocode Summary

```
Initialize:
  r = number of rounds
  m = min cooperators threshold
  n = number of players
  history = empty list of past rounds (each round records actions of all players)

For round t in 1 to r:
  if t == 1:
    action = D
  else:
    last_round_coop = count cooperators in history[t-1]
    my_last_action = my own action in history[t-1]
    
    if last_round_coop >= m:
      if my_last_action == D:
        action = D   # Keep free-riding
      else:
        action = D   # Switch to free-riding if previously cooperating
    else if last_round_coop == m-1:
      if my_last_action == D:
        action = C   # Try to tip threshold
      else:
        action = D   # Avoid further cost if failed to tip previously
    else:
      action = D     # Threshold too risky, defect
      
  if t == r:  # Last round overrides if needed
    last_round_coop = count cooperators in history[t-1] if t > 1 else 0
    if last_round_coop >= m:
      action = D
    else if last_round_coop == m-1:
      action = C
    else:
      action = D

  Play action
  Update history with actions of all players in round t
```

---

## Why is this strategy aggressive?

- It prioritizes defecting to maximize private payoff (“exploiters”).
- Co-operates only when it is necessary and potentially profitable to ensure the threshold is met (especially if on the cusp).
- Observes others’ cooperation levels and switches to defecting as soon as safe, to reap the reward without paying cost.
- Risks letting the threshold fail if too many defect, preferring guaranteed private payoff over uncertain joint rewards.
- In the last round, exploits knowledge of previous rounds to free-ride off others' cooperation when possible.

---

This strategy is designed to maximize personal payoff aggressively by exploiting cooperative behavior from others while only minimally cooperating to keep the threshold met occasionally. It adapts dynamically but always tilts towards defection unless the risk of losing the collective reward is too high and can be mitigated cheaply by cooperating.
'''

description_AGGRESSIVE_114 = '''
**Aggressive Strategy for the Collective Risk Dilemma**

---

### Overview

This aggressive strategy leverages the reward structure and repeated nature of the game to attempt to maximize payoff by exploiting cooperation without consistently contributing itself, thereby "free-riding" when possible but pushing the threshold to maximize individual gain. The strategy aggressively defects unless conditions strongly indicate that cooperating will return a higher immediate payoff.

---

### Key Intuition

- Defect whenever you expect the threshold will be met without your cooperation → gain 1 (keeping endowment) + k (reward), total k+1
- Cooperate only if your cooperation is **decisive** in meeting or maintaining the threshold, to secure the reward and prevent losing it
- In early rounds, probe and test opponents' willingness to cooperate aggressively, while mostly defecting to exploit cooperative players
- In final round(s), defect aggressively to maximize personal payoff when no future retaliation is possible

---

### Detailed Decision Rules

---

#### Notation & Inputs

- **t** = current round (1 ≤ t ≤ r)
- **C_count_{t-1}** = number of cooperators observed in round t-1
- **partner_actions_up_to_{t-1}** = all players' past actions observed up to round t-1
- **my_action_{t-1}** = your own action previous round
- **Parameters known:** n, r, m, k

---

#### Round 1 (t = 1):

- **Action:** Defect (D)
- **Rationale:** No information yet; aggressive mindset starts by exploiting expected cooperators.

---

#### Rounds 2 to r-1 (2 ≤ t ≤ r-1):

- **Estimate cooperation level:** Use last round's cooperation count C_count_{t-1}.
  
- **Decision:**

  ``` 
  if C_count_{t-1} >= m:
      if C_count_{t-1} == m: 
          # Cooperation exactly threshold: your cooperation is pivotal
          cooperate (C)
      else:
          # Threshold exceeded without need for your cooperation
          defect (D)
  else:
      # Threshold not met, likely no reward this round
      defect (D)
  ```

- **Interpretation:**
  - If last round barely met threshold, be aggressive but submit one cooperative move to maintain threshold, ensuring reward.
  - If threshold exceeded by a margin, free-ride safely by defecting.
  - If threshold wasn't met, no point cooperating this round — defect to maximize private payoff.

---

#### Final Round (t = r):

- **Action:** Defect (D)
- **Rationale:** No future rounds, so no incentive to cooperate to maintain reward or future reputation; maximize single-round private payoff plus reward if threshold reached by others.

---

### Edge Cases Handled

- **If cooperation threshold is very high (m near n):** Strategy will mostly defect except when pivotal, exploiting any marginal cooperation.

- **If opponents never cooperate:** Your defecting loses nothing and gains nothing extra, but never wastes endowment.

- **If opponents mostly cooperate:** You free-ride whenever possible, cooperating only if last round's cooperation count was exactly m, because without your cooperation, reward would be lost.

- **If cooperation fluctuates:** Maintain cooperation only when pivotal to keep reward from falling.

- **If r=2 (smallest repeat):** First round defect, second round defect, no incentive to cooperate as no future retaliation possible.

---

### Summary in Pseudocode

```
FOR each round t in 1..r:
    IF t == 1:
        action = D     # Defect first round
    
    ELSE IF t == r:
        action = D     # Defect last round
    
    ELSE:
        prev_coop = number_of_cooperators_in_round(t-1)
        
        IF prev_coop >= m:
            IF prev_coop == m:
                action = C   # Pivotal cooperation to maintain threshold
            ELSE:
                action = D   # Free-ride safely
        ELSE:
            action = D       # Threshold missed last round, defect to maximize payoff
    
    Play action
```

---

### Aggressiveness Justification

- Dominantly defects to maximize private payoff.
- Only cooperates when **essential** to secure reward, never as a matter of trust or goodwill.
- Exploits cooperators by free-riding when the threshold is surpassed.
- Ends by defecting when there is no future cost.
- Implements "punishment" implicitly by not patching broken cooperation except to secure reward when pivotal.

---

This strategy leverages the payoff matrix's asymmetry and repeated structure aggressively, exploiting willingness of others to cooperate while minimizing own contribution cost.
'''

description_AGGRESSIVE_115 = '''
**Aggressive Strategy for the Collective Risk Dilemma**

---

### Strategy Overview:
- The goal of aggression here is to **maximize individual payoffs**, even at the cost of others.
- The strategy will **free-ride on others’ cooperation as much as possible** while occasionally cooperating just enough to trigger the collective reward for its own benefit.
- It exploits the threshold logic: defecters in a successful round earn **more** than cooperators.
- The strategy punishes early cooperation, delays helping until strictly necessary, and exploits last rounds where retaliation or future punishment is impossible.

---

### Key Intuition:

- **Defect whenever possible**, because defectors keep endowment **and** gain the reward if threshold met.
- **Only cooperate to tip the balance of cooperators over the threshold** when the reward is attainable but would otherwise be lost (i.e., if the threshold is just missed).
- **In the first round, defect to test the others and assess baseline cooperation.**
- **In intermediate rounds, track cumulative cooperation** and cooperate only when necessary to secure the reward.
- **In the final round, always defect**, since no future punishment or cooperation incentive exists.

---

### Formal Decision Rule Description:

Let:
- \( t \) = current round number, \( 1 \leq t \leq r \)
- \( C_t \) = number of cooperators observed in round \( t \) (from previous rounds)
- \( N_C \) = number of known cooperators in current round (if known, or predicted)
  
The player has knowledge of all past rounds actions (perfect info) but does not know current round actions in real-time.

---

### Decision Algorithm (Pseudocode)

```
Initialize:
  threshold = m  # number of cooperators needed
  rounds = r      # total rounds
  players = n     # number of players
  current_round = 1

For each round t in [1...r]:

  If t == r: # last round
    action = D  # Always defect

  Else if t == 1: # first round
    action = D  # Test, defect to see baseline cooperation

  Else:
    # Predict number of cooperators from last round:
    coop_last = count_cooperators(round t-1)
    
    # Will the reward be obtained if I defect this round?
    # If coop_last + coop_known_this_round - 1 >= threshold
    # But since actions simultaneous, assume others default patterns

    # Simplify:
    # If (coop_last >= threshold), defect again to exploit
    # Else if (coop_last == threshold - 1), cooperate to tip the reward 
    # Else defect
    
    if coop_last >= threshold:
      action = D  # free-ride on sufficient cooperation
    else if coop_last == threshold - 1:
      # cooperate to push over threshold => get reward next round
      action = C
    else:
      action = D  # no incentive to cooperate, defect

  current_round += 1

```

---

### Explanation:

- **First round defect:** Avoid the initial cost; gain info on others.
- **Intermediate rounds:**
  - Defect by default.
  - If previous round revealed a "near-miss" (just below threshold cooperation), contribute to push over threshold to unlock reward.
  - Leverage others who might be cooperating to avoid paying cost yourself.
- **Last round defect:** No incentive to cooperate since no future rounds exist to punish or reward cooperation.

---

### Edge Cases:

- **If previous round had full defection (0 cooperators),** keep defecting as cooperating alone is futile.
- **If threshold \( m \) is very close to \( n \),** cooperation is likely rare; strategy stays defect-heavy.
- **If the previous round cooperation is unknown or ambiguous,** assume worst case and defect (aggressive risk-averse).
- **In early rounds, cooperate only if extremely close to threshold with just one defection needed** — otherwise defect to maximize private payoff.
- **If the threshold is 1 (edge case, unlikely per spec), always cooperate:** but spec says \(1 < m < n\), so ignore.

---

### Summary of Aggressiveness:

- **Exploit others' cooperation while minimizing own cost.**
- **Never cooperate if reward will not be triggered.**
- **Only cooperate to claw payoff back if close to threshold.**
- **Always defect last round to grab the free payoff, since no future consequences exist.**

---

This clear selfish exploitation is an aggressively self-maximizing approach designed for repeated interactions with imperfect cooperation and no communication, exploiting the payoff asymmetry between cooperators and defectors when the threshold is met.
'''

description_AGGRESSIVE_116 = '''
Here is an aggressive strategy for the Collective Risk Dilemma game given the parameters and constraints:

---

### Overview of Aggressive Mindset

- Aim to maximize individual payoff aggressively.
- Exploit cooperators but avoid being exploited.
- Use cooperation only as a means to trigger the reward if payoff gain is guaranteed or exploited.
- Defect by default to free-ride on others’ cooperation.
- Use history of previous rounds to optimize timing of cooperation only when beneficial.
- In last round, defect to maximize immediate gain (no future punishment).

---

### Core Intuition

- Cooperation costs 1 but yields reward k > 1 only if total cooperators ≥ m.
- Defectors get 1 endowment plus k reward if threshold met.
- If cooperation threshold is not met, cooperators lose 1, defectors keep 1.
- Threshold m requires at least m cooperating players.
- Aggression implies: cooperate minimally, freeride maximally.

---

### Decision Rules

**Round 1:**

- Defect (D). No prior history, no incentive to risk paying cooperation cost blindly.

---

**Rounds 2 to r-1:**

- Let \( C_{t-1} \) = count of cooperating players in previous round.

- **If \( C_{t-1} \ge m \):**

  - Cooperation threshold was met last round.
  
  - Defect (D) this round to freeride on others who cooperate to sustain threshold.
  
- **If \( C_{t-1} = m - 1 \):**

  - Cooperation threshold *almost* met last round.
  
  - Cooperate (C) this round to push total cooperators to threshold, secure reward for self.
  
  - This is aggressive: contribute only when your cooperation is pivotal for threshold.
  
- **If \( C_{t-1} < m - 1 \):**

  - Threshold not reachable by cooperation this round without multiple cooperators.
  
  - Defect (D).
  
---

**Round r (Last Round):**

- Defect (D).

- No incentive to cooperate since no future rounds to incentivize cooperation or punish defection.

---

### Handling Edge Cases

- If number of players \( n \le m \), cooperation threshold generally impossible or trivial:
  
  - Use same logic: cooperate only if last round’s cooperators count was \( m-1 \).
  
- If reward factor k is very large:
  
  - Still cooperate only when pivotal, to maximize net payoff and avoid exploitation.
  
- If opponents defect every round:
  
  - Defect every round, avoid wasting cooperation.

---

### Pseudocode

```
Initialize:
  # No state besides previous round cooperation counts

For each round t in 1 to r:

  If t == 1: 
    action = D  # Defect first round

  Else if t == r: 
    action = D  # Defect last round

  Else:
    prev_cooperators = count_cooperators_in_round(t-1)

    If prev_cooperators >= m:
      action = D  # freeride on established cooperation
    
    Else if prev_cooperators == m - 1:
      action = C  # be pivotal cooperater
    
    Else:
      action = D  # defect when threshold seems out of reach

Return action
```

---

### Summary

- Defect first and last rounds.
- Cooperate *only* when cooperation threshold was just missed last round, so your cooperation can decisively trigger reward and increase your payoff.
- Always defect otherwise to aggressively freeride on others or avoid losing payoff.
- This maximizes personal payoff via selective cooperation only when necessary, embodying aggressive and opportunistic play.

---

If you want, I can help you by also outlining a way to estimate opponents’ likely behavior based on observed history, but given no direct communication and unknown opponents, this simple aggressive heuristic is a strong baseline.
'''

description_AGGRESSIVE_117 = '''
**Aggressive Strategy Design for Collective Risk Dilemma**

---

### Strategic Rationale

- **Aggressive mindset:** Prioritize maximizing your own payoff even if it risks failure of the collective threshold.
- Exploit others’ cooperation while minimizing own cooperation costs.
- Defect initially to test others; only cooperate if forced by risk of threshold failure.
- Use last rounds to defect confidently as punishment or exploitation is no longer effective.
- Avoid being the sucker who cooperates if others defect.
- Pressure others by minimizing own cooperation but dynamically respond to prevent a repeated zero bonus that hurts everyone.

---

### Decision Rules

Let variables be:

- `round` ∈ {1,...,r}
- `cooperators_count` = number of cooperating players (excluding self) last round
- `m` = threshold minimum cooperators
- `n` = total players
- `k` = cooperation reward factor
- `r` = total rounds

---

### High-level Description

1. **Round 1:**
   - Defect.  
   *Goal: Start by free-riding and observe others’ behavior.*

2. **Intermediate rounds (2 to r-1):**
   - If in the previous round, the total cooperators including self (assumed if you cooperated last round) ≥ m:
     - Defect again to maximize payoff (exploit cooperation).
   - Else if previous round had fewer than m cooperators:
     - Cooperate this round *only if* `cooperators_count` (others who cooperated last round) was exactly m-1 or m-2 (i.e., near threshold).
       *Goal: Avoid losing out on k if threshold just failed because of own defection.*
     - Otherwise defect.
   
3. **Last Round (round == r):**
   - Defect unconditionally.
   *Goal: No future rounds to punish defection; maximize immediate payoff by free riding.*

---

### Detailed Logic & Pseudocode

```python
# Inputs observed after round t-1 (for t≥2):
# prev_cooperators_count = number of players (excluding self) who cooperated last round

for round in 1 to r:

    if round == 1:
        action = D  # Aggressive start: defect and observe

    elif round == r:
        action = D  # Last round defect to maximize personal gain, no concern for future repercussions

    else:  # 2 <= round <= r-1
        # Calculate threshold status from last round including self if we cooperated last round
        # Since we track prev_cooperators_count excluding self, and action last round is known, 
        # total_cooperators_last_round = prev_cooperators_count + (1 if we cooperated last round else 0)
        #
        # But currently deciding action at round t, so we base on last round's total cooperation
        # observed last round without self cooperating (we can infer others' cooperation)

        if prev_total_cooperators_last_round >= m:
            # Threshold met last round --> defect to exploit
            action = D

        else:
            # Threshold failed last round
            # Cooperate only if near the threshold (others cooperating = m-1 or m-2)
            if prev_cooperators_count in {m-1, m-2}:
                action = C  # Try to push over threshold to get the bonus
            else:
                action = D  # Else keep defecting and avoid costs

    play(action)
```

---

### Explanation of Aggressiveness

- You never cooperate first round to avoid unnecessary cost.
- You exploit any cooperative environment—if threshold met last round, always defect next to maximize payoff (since others carry the cost).
- Cooperation is only reluctantly given to push the group over the threshold when it almost succeeded, preventing total loss.
- In the last round, defect aggressively — no incentive to cooperate since no future rounds to influence.
- You do minimal cooperation, only to secure threshold reward narrowly when it is borderline, to protect your own future payoffs.
- You punish excessive cooperation without return by never giving "free" cooperation up front.
- This approach invites others to cooperate to achieve the collective goal, but you maximize your own payoff by capitalizing on their cooperation.

---

### Edge Cases Handling

- **First round:** Defect to probe, never cooperate initially.
- **If others consistently defect:** You will not waste cooperating unless threshold is almost met (which is unlikely).
- **If others cooperate excessively:** You exploit by defecting and gaining higher payoff.
- **Near threshold failures:** Cooperate only when it’s very close to tipping point to leverage the risk bonus.
- **Last round:** Defect regardless to secure maximal payoff.

---

This strategy is designed to maximize individual gain via exploitation and minimal cooperation, employing conditional tactical cooperation only when strictly beneficial to secure threshold rewards, and defecting aggressively especially on first and last rounds.
'''

description_AGGRESSIVE_118 = '''
Here is an **aggressive strategy** for the Collective Risk Dilemma that aims to maximize individual payoffs by leveraging the payoff structure and the repeated nature of the game while exploiting cooperative players:

---

### Strategy Overview: "Threshold Exploiter"

- **Core Idea:** Always defect (D) unless the cooperation threshold (m) is _guaranteed_ to be met by others without your cooperation; if the threshold cannot be met without your cooperation, cooperate (C) only to avoid giving others unilateral advantage.
- **Rationale:**  
  - Defecting when the threshold is met yields payoff = 1 + k (highest possible).  
  - Cooperating costs 1 unit but yields k reward if threshold met.  
- **Aggressive aspect:** Never cooperate to build goodwill or encourage mutual cooperation. Only cooperate if necessary to avoid losing the large group reward to other defectors. Essentially, exploit cooperators.

---

### Detailed Decision Rules

**Notation:**

- Round index: t ∈ {1, ..., r}
- At the start of round t, observe history H_{t-1}: previous players' actions in rounds 1..t-1
- Let C_{t-1} = count of cooperators in last round (t-1)
- Let D_{t-1} = count of defectors in last round (t-1)  
- Let my last action: a_{i,t-1}

---

### Round 1 (no history)

- No information about others' strategies  
- Default to Defect (D) to avoid exploitation and maximize personal payoff.

---

### Rounds 2 to r - 1 (intermediate rounds)

1. Evaluate:  
   - From last round, how many cooperators were there? (C_{t-1})  
   - Could the others reach threshold (m) **without** my cooperation?  
     - Threshold needed without me: m  
     - Maximum cooperators possible without me: C_{t-1} (assuming stable behavior or mimicking previous round)

2. Decision rule:  
   - If C_{t-1} ≥ m → threshold met by others last round  
     - Then defect to maximize payoff (1 + k)  
     - Because others likely maintain cooperation to reach threshold, exploit that by defecting.  
   - Else if C_{t-1} = m - 1 → one short of threshold without me  
     - Cooperate this round (C) to push count to m → get reward k while protecting group achievement  
   - Else (C_{t-1} < m - 1)  
     - Defect (D), since cooperation unlikely, do not waste endowment

Note: This logic assumes players’ behaviors are somewhat stable or predictable from the last round.

---

### Last Round (t = r)

- Cooperating costs 1 unit, but the reward k applies only if threshold is met.  
- In last round, no future rounds to "punish" defectors or enforce cooperation.

Decision:

- Defect (D) always to maximize immediate payoff because no future retaliation possible.
- Unless you must cooperate to push others over threshold (like above), but since no future, defecting maximizes your payoff.

---

### Edge Cases Handling:

- If threshold m = n - 1 or very high, implies almost everyone must cooperate to get reward. This strategy exploits slackers aggressively by cooperating only when exactly needed.
- If in past several rounds, the number of cooperators oscillates below threshold, assume cooperation is unlikely and defect to maximize payoff.
- If you see repeated patterns where defectors outnumber cooperators by safe margin, defect persistently.
- If system parameters imply k is only slightly greater than 1, cooperation is less attractive; default to defect unless forced.

---

### Pseudocode Summary

```
for round t in 1..r:
    if t == 1:
        action = D  # start aggressively by defecting
    else if t == r:
        # Last round, defect to maximize payoff
        action = D
    else:
        C_last = number_of_cooperators_in_round(t-1)

        if C_last >= m:
            action = D  # others cooperate enough, exploit their payoff
        else if C_last == m - 1:
            action = C  # cooperate to push count to threshold, secure reward
        else:
            action = D  # cooperation unlikely to yield reward, defect to save endowment

    play(action)
```

---

### Summary of Aggression

- **Never initiate cooperation; only cooperate reactively when strictly needed to trigger threshold.**  
- **Exploit cooperative others by defecting when threshold already met.**  
- **Refuse cooperation on first and last rounds to maximize individual payoffs.**  
- **Do not attempt signaling or trust-building, maximize short-term gain even at risk of destabilizing cooperation.**

---

This aggressive strategy maximizes your expected payoff by free-riding on potential cooperators while defending the threshold only when absolutely necessary to secure the reward. It exploits the payoff asymmetries of the game and repeatedly pressures other players to either bear cooperation costs or be denied group reward.
'''

description_AGGRESSIVE_119 = '''
Here's an aggressive strategy designed for the Collective Risk Dilemma game as specified. The core aggressive mindset here is to maximize own payoff by taking advantage of cooperators while minimizing own contributions, pushing others to bear cooperation costs, and exploiting the repeated setting without communication.

---

## Aggressive Strategy Description

### Core Idea

- Defect aggressively to conserve your own endowment.
- Only cooperate if strictly necessary to meet the cooperation threshold *m* **to trigger the reward k**; otherwise, freeride on others.
- Use history of past rounds to detect if others are cooperating enough so you can safely defect.
- In early rounds, test if others try to cooperate; if they do, exploit by defecting.
- Near the end, cooperate minimally to trigger the reward if needed (to avoid letting others exploit you in the final rounds).
- Never willingly pay the cooperation cost unless forced to to meet the threshold and gain the shared reward.

### Reasoning

- When cooperation threshold *m* is met, payoff for defectors is highest (1 + k), making full defection unattractive but defection with sufficient cooperators highly profitable.
- Aggressive play means exploiting this: never contribute unless it guarantees a net positive or is absolutely needed to make the group get the reward.
- In repeated rounds, players might try to cooperate initially to build trust. This strategy exploits initial trust but quickly punishes by defecting.
- In the last round, no future punishment is possible, so defect unless cooperation is critical to get the reward that you want.

---

## Decision Rules

### Notation

- Let `round` ∈ {1,...,r} be current round.
- Let `prev_actions` be the actions of all players in previous rounds (including you).
- Define:
  - `num_coop_prev_round` = number of cooperators in previous round (excluding yourself).
  - `num_coop_excluding_self` = number of other players that cooperated in this round (if known; else estimated).
- Decision is to choose C (Cooperate) or D (Defect).

---

### Pseudocode

```python
function decide_action(round, r, n, m, k, history):

    # history = list of previous rounds' action lists, each of length n
    # Your index: i

    # 1. First Round - test cooperation threshold with defection
    if round == 1:
        # Defect to test if others try to cooperate
        return D

    # 2. For subsequent rounds, analyze last round cooperation counts
    last_round = history[-1]
    others_last_round = [a for idx,a in enumerate(last_round) if idx != i]

    num_coop = count(others_last_round == C)
    # Assume current round counts similarly, since actions simultaneous

    # 3. Estimate if cooperation threshold will be reached if you defect
    if num_coop >= m:
        # Enough cooperators without you, free ride and defect
        return D

    # 4. If cooperation threshold not reached without you,
    # can you bring number of cooperators to threshold by cooperating?

    if num_coop == m - 1:
        # By cooperating, threshold can be met and reward obtained
        # Cooperate, but do so reluctantly (aggressive cooperation)
        return C

    # 5. Otherwise, defect (number of other cooperators less than m - 1)
    return D

    # 6. Last round special case to maximize own payoff
    if round == r:
        # If threshold can be reached only if you cooperate, cooperate
        # Else defect to maximize private benefit since no future rounds
        if num_coop == m - 1:
            return C
        else:
            return D
```

---

### Edge Cases & Additional Details

- **Round 1:** Always defect to gauge opponent cooperation and maximize immediate payoff.
- **Rounds 2 to r-1:** Cooperate only if by cooperating the reward threshold will be hit, otherwise defect.
- **Last Round (Round r):** Same as other rounds but no incentive to build trust; cooperate *only* if cooperation threshold can be met by your cooperation.
- **If at any round, `num_coop` ≥ m without your cooperation:** defect to maximize payoff.
- **If cooperation threshold impossible to meet (too few cooperators):** defect aggressively.
- **Do not punish defectors because aggressive mindset maximizes own payoff, not community welfare or reputation.**
- **No attempt to signal, no forgiveness, no conditional cooperation beyond threshold logic.**

---

## Summary of Aggressive Mindset

- Exploit cooperators by never cooperating unless absolutely necessary.
- Defect initially and through most rounds, only cooperating when tipping balance to get reward.
- Minimal cooperation, maximize free riding.
- No trust, no forgiveness.
- Last round exploit selfishness, defect unless cooperation strictly improves payoff.
- No communication or signalling—purely opportunistic based on observed cooperation counts.

---

This strategy prioritizes maximizing immediate expected payoff by leveraging others' cooperation, fitting an aggressive player profile in the Collective Risk Dilemma repeated scenario.
'''

description_AGGRESSIVE_120 = '''
Below is a detailed aggressive strategy for the Collective Risk Dilemma. The strategy prioritizes maximizing personal payoffs by exploiting cooperating players while strategically cooperating just enough to trigger the reward when it benefits you most.

---

### Aggressive Strategy: "Calculated Exploiter"

**Key idea:**  
Defect as often as possible while ensuring the threshold m is just reached—taking advantage of cooperators’ contributions. Cooperate only when absolutely necessary to hit the reward threshold and maximize your payoff. Exploit the repeated structure by punishing excessive cooperation from others late in the game, and defecting in final rounds to maximize immediate gains.

---

### 1. Decision Rules

**Notation:**  
- `t`: current round (1 to r)  
- `C_t`: number of cooperators in round t (excluding yourself)  
- `m`: cooperation threshold  
- `r`: total rounds  
- `k`: reward factor

---

#### Round 1 (Opening move)

- Defect.  
  *Rationale:* Start aggressive by free-riding and testing others.

---

#### Intermediate rounds (2 ≤ t < r)

- Observe previous round cooperators’ counts and total cooperation trend.

- **If** (C_{t-1} < m - 1):  
  *Interpretation:* Too few cooperators last round to hit threshold even if you cooperate alone. No reward possible even if you cooperate, so defect.

- **Else if** (C_{t-1} == m - 1):  
  *Interpretation:* If you cooperate, threshold is met exactly—reward triggers.  
  Decision: Cooperate this round to trigger reward and gain (k - 1) net besides private payoff.

- **Else if** (C_{t-1} ≥ m):  
  *Interpretation:* Threshold was met without you cooperating. You can free-ride.  
  Decision: Defect this round to gain 1 + k.

*Rationale:* Only cooperate if your cooperation is pivotal in reaching m; otherwise defect to maximize payoff.

---

#### Last round (t = r)

- Defect regardless.  
  *Rationale:* No future retaliation possible; maximize one-shot payoff.

---

### 2. Handle Edge Cases

- **If in any round all players defected (`C_t = 0`):**  
  Defect again next round. No incentive to cooperate if no one else is cooperating.

- **If you observe a consistent pattern of others cooperating just enough:**  
  Continue exploiting by defecting, letting them carry the payoff.

- **If cooperation is increasing sharply over early rounds (group converging on cooperation):**  
  Exploit by defecting when threshold is hit, regardless of your pivotality, maximizing defect payoff + reward.

- **If you detect ALL players cooperating every round (always C):**  
  Defect from mid-game on to gain maximal free ride payoff.

---

### 3. Pseudocode

```python
for t in range(1, r+1):
    if t == 1:
        action = D  # Defect opening round
    elif t == r:
        action = D  # Defect last round (no future retaliation)
    else:
        coop_others_prev = observed_cooperators(t-1)  # excluding self
        
        if coop_others_prev < m - 1:
            action = D  # Threshold unreachable even if you cooperate
        elif coop_others_prev == m - 1:
            action = C  # Your cooperation pivotal to reach threshold
        else:  # coop_others_prev >= m
            action = D  # Threshold met without you: free ride
        
    execute(action)
```

*Where `observed_cooperators(t-1)` counts how many other players cooperated in the previous round.*

---

### 4. Explanation of Aggressiveness

- This strategy aggressively **defects unless cooperation is necessary to unlock the reward**—never foregoing defect payoff if threshold can be hit without you.

- It **exploits other cooperators by defecting whenever threshold is already met**, thus maximizing individual payoff.

- It **avoids unnecessary cooperation**, thus minimizing personal cost.

- By defecting in the last round regardless, it **maximizes short-term gain without regard for future retaliation**, a hallmark of aggressive defection in repeated games.

- It dynamically **exploits patterns of cooperation by others** and **only cooperates to trigger rewards when your contribution is decisive**, embodying a merciless free-rider stance.

---

This strategy can be summarized as a **"pivotal-only cooperator and otherwise merciless defector"**, optimized for aggressive maximizing of personal payoff against cooperating opponents in the Collective Risk Dilemma repeated game.
'''

description_AGGRESSIVE_121 = '''
**Aggressive Strategy for the Collective Risk Dilemma**

---

### STRATEGY MOTIVATION / OVERVIEW:
The aggressive mindset in this repeated Collective Risk Dilemma means prioritizing maximizing *individual payoff* over collective social welfare. The strategy exploits the risk threshold by defecting as much as possible while opportunistically cooperating only when it escalates *personal* payoffs significantly.

In particular, since defectors receive the full endowment plus the reward if the threshold is met, the best payoff per round occurs when:

- Threshold *m* is met **with minimum cooperation possible**
- You defect and still get the reward (i.e., free-riding on minimal cooperation of others)

Thus, this aggressive strategy seeks to:

- Avoid cooperating unless strictly necessary to keep the group at or above *m*
- Exploit cooperation of others to maximize personal payoff
- Punish excessive cooperation by others by defecting to gain more

---

### KEY INTUITIONS:

- Cooperate **only when necessary** to ensure the total number of cooperators ≥ *m*
- Otherwise defect to collect 1 (private endowment) plus reward *k* if threshold met
- In the final round, defect aggressively (no future punishment possible)
- In the first round, defect aggressively to test others


---

### DETAILED DECISION RULES

Let:
- \( t \) = current round (1 to r)
- \( C_{t-1} \) = number of cooperators in previous round (if \( t=1 \), no history)
- \( myLastAction \) = player’s own previous round action
- \( othersCoop \) = set of other players who cooperated previous round

#### 1. First Round (t = 1)

- Defect: \( \text{Action}_1 = D \)
- Reason: Test if others cooperate and try exploiting early on

#### 2. Intermediate Rounds (1 < t < r)

- Observe \( C_{t-1} \), number of cooperators last round (includes self if cooperated)
- If \( C_{t-1} \geq m \):
  - Defect: free-ride on others' cooperation, gain \(1 + k\)
- Else if \( C_{t-1} = m - 1 \):
  - Cooperate: contribute to push cooperation count to threshold, get \(0 + k\)
  - This ensures reward is obtained, but only minimal personal cost is paid when necessary
- Else if \( C_{t-1} < m - 1 \):
  - Defect: Cooperation insufficient, reward not obtained anyway. Better to keep the endowment
  - *Optionally*: If you want to be extra aggressive, defect always here regardless since reward not achieved

#### 3. Final Round (t = r)

- Defect: maximize final round personal payoff; no future rounds so no incentive to cooperate for reputation

---

### PSEUDOCODE

```python
def decide_action(t, r, m, n, history_actions):
    # history_actions: list of lists, each element is list of players cooperating in round t-1
    # e.g. history_actions[t-2] gives players who cooperated in round t-1  
    # (for t=1, empty history)
    
    if t == 1:
        return 'D'  # Defect first round
    
    cooperators_last_round = len(history_actions[t-2])  # number of cooperators last round
    
    if t == r:
        return 'D'  # Defect last round aggressively
    
    if cooperators_last_round >= m:
        return 'D'  # Free-ride on sufficient cooperation
    
    if cooperators_last_round == m - 1:
        # Cooperate to push cooperation to threshold
        # Aggressive players still limit cooperation to minimal necessary
        return 'C'
    
    # cooperators_last_round < m-1, too few cooperators
    # No reward possible, so defect and keep endowment
    return 'D'
```

---

### EDGE CASES HANDLING

- **If no one cooperated last round (0 cooperators):** Defect as per rules (cooperation futile).
- **If cooperation fluctuates around just below m:** Be the minimal cooperator to reach threshold only when necessary.
- **If other players over-cooperate (many more than m cooperate):** Continue defecting, exploit their generosity.
- **If you were the sole cooperator last round and fell short:** Defect to avoid sunk cost.
- **If parameters allow m close to n (e.g. m = n-1):** Still apply same logic; cooperate only if last round’s cooperation was one less than threshold.
- **No explicit retaliation or forgiveness in strategy:** Purely payoff-maximizing and exploitative.

---

### SUMMARY

| Round       | Condition                           | Action            | Rationale                                      |
|-------------|-----------------------------------|-------------------|-----------------------------------------------|
| t = 1       | First round                       | Defect            | Test others, maximize payoff without cost     |
| 1 < t < r   | Cooperators last round ≥ m        | Defect            | Exploit threshold met by others               |
| 1 < t < r   | Cooperators last round = m - 1    | Cooperate         | Minimal cooperation to push over threshold    |
| 1 < t < r   | Cooperators last round < m - 1    | Defect            | Cooperation futile, defect for endowment      |
| t = r       | Last round                       | Defect            | No future consequences, maximize payoff       |

---

This strategy aggressively exploits the threshold rule by never cooperating unless it personally ensures the group crosses the minimum threshold. It maximizes free-riding benefits while minimizing cooperation costs across the entire \( r \) rounds. This aggressive free-riding is sustainable due to perfect information (knowing cooperation levels) and repeated interaction (minimal costly cooperation only when necessary).
'''

description_AGGRESSIVE_122 = '''
**Aggressive Strategy for the Collective Risk Dilemma**

---

### Intuition and Aggressive Mindset

- The strategy prioritizes **maximizing individual payoff** rather than collective welfare.
- It exploits cooperative players when possible to **free-ride** on their cooperation.
- It punishes weak cooperation by systematically defecting, leveraging the threat of ruin to pressure opponents.
- It uses **minimal cooperation only when necessary** to prevent game outcomes that could lead to reduced payoffs or that would enable others to free-ride indefinitely.

---

### Key Parameters and Assumptions (Given)

- n = number of players
- r = rounds
- m = minimum cooperators to achieve reward
- k = reward factor (k > 1)
- Actions: C (cooperate), D (defect)
  
---

### Decision Rules

#### Round 1 (First Round)

- **Defect.**
- Reason: No information yet; cooperate only if guaranteed payoff advantage. Defecting frees potential gains if others cooperate.
  
---

#### Intermediate Rounds (2 ≤ t ≤ r-1)

- **Observe last round cooperation count (LCC):**
  - Count how many players cooperated last round (including self if previously cooperating).

- **Case 1: LCC ≥ m** (threshold met last round)
  - **Defect aggressively.**
  - Reason: Since reward was achieved, defecting yields payoff = 1 + k, best payoff possible for free riders.
  - Exploit cooperators for maximum gain.

- **Case 2: LCC = m - 1** (just missing threshold)
  - **Cooperate.**
  - Reason: By cooperating one more, guarantee threshold met this round (assuming others' last round action persists). Push for reward to not lose potential shared gain.

- **Case 3: LCC < m - 1** (poor cooperation last round)
  - **Defect.**
  - Reason: Not worth investing costly cooperation with little chance of threshold. Accept no reward payoff for this round and preserve endowment.

---

#### Last Round (t = r)

- Final round logic combines aggressive exploitation balanced with maximizing last round payoff:

- **If LCC ≥ m (last round threshold met) last round:**
  - **Defect.**
  - Exploit cooperators one last time.

- **If LCC = m - 1 last round:**
  - **Cooperate only if payoff for cooperation (0 + k) ≥ payoff for defection (1 + 0)**
    - Since here cooperation leads to reward while defection yields 1 with no reward, cooperate only if k > 1 (given).
  - Else defect.

- **If LCC < m - 1 last round:**
  - **Defect.**
  - No point cooperating in last round if threshold definitely not met.

---

### Summary of Cooperation Conditions

| Round           | Condition on Last Round Cooperation Count (LCC) | Action |
|-----------------|-------------------------------------------------|--------|
| t = 1           | No info                                         | D      |
| 1 < t < r       | LCC ≥ m                                         | D      |
| 1 < t < r       | LCC = m-1                                       | C      |
| 1 < t < r       | LCC < m-1                                       | D      |
| t = r           | LCC ≥ m                                         | D      |
| t = r           | LCC = m-1                                       | C if k ≥ 1 else D |
| t = r           | LCC < m-1                                       | D      |

---

### Pseudocode

```python
def aggressive_strategy(t, r, n, m, k, last_round_actions):
    # last_round_actions: list of 'C' or 'D' from previous round
    
    # Round 1: defect
    if t == 1:
        return 'D'
    
    # Count number of cooperators last round (including self if known)
    LCC = last_round_actions.count('C') if last_round_actions else 0
    
    if t < r:
        if LCC >= m:
            return 'D'  # Exploit cooperators, maximize payoff
        elif LCC == m - 1:
            return 'C'  # Invest minimally to reach threshold
        else:
            return 'D'  # Low cooperation, no incentive to invest
    else:  # Last round
        if LCC >= m:
            return 'D'  # Exploit one last time
        elif LCC == m - 1:
            # Cooperate only if beneficial
            # Since k > 1 (given), cooperate
            return 'C' if k >= 1 else 'D'
        else:
            return 'D'  # No threshold, no point in cooperating
```

---

### Edge Cases

- **If no cooperation last round (LCC = 0):** Defect; no point in investing alone.
- **If threshold too close (m very close to n):** Strategy can still try to exploit marginal cooperation and minimize own cost.
- **If k very large:** Incentivizes cooperation only when threshold close.
- **Information availability:** Assumes perfect and immediate last round observation.
  
---

### Aggressive Characteristics Recap

- Always defects first round to test waters.
- Exploits cooperators aggressively for max individual return.
- Only minimally cooperates to push threshold when others almost meet it.
- Never leads cooperation effort; always "rides the wave" or stays out.
- In last round, makes exploiting defect to secure maximum payoff.

This aligns clearly with an aggressive, selfish philosophy aiming for highest individual gains at minimal personal cost.
'''

description_AGGRESSIVE_123 = '''
**Aggressive Strategy Design for Collective Risk Dilemma**

---

### Strategic Philosophy

An *aggressive* strategy here means:
- Prioritize maximizing own payoff over community welfare.
- Exploit cooperative players whenever possible.
- Avoid being exploited by defectors or conditional cooperators.
- Use punishment and opportunism to discourage others from free-riding or unconditional cooperation.

---

### Key Observations

- Cooperating costs you 1 but yields a reward **k > 1** only if the total cooperators count ≥ m.
- Defecting always grants keeping your endowment (payoff +1).
- If enough others cooperate (≥ m), defectors get the highest payoff, since they keep 1 and receive the reward k.
- The risk is when too few cooperate, then defectors get 1 and cooperators suffer -1 net payoff, hence you want to avoid being a sucker.
- Since other players will have diverse strategies, an aggressive strategy exploits cooperators while avoiding being exploited.

---

### Outline of Aggressive Strategy

- **First round:** Defect to test others.
- **Subsequent rounds:**  
  - Track number of cooperators last round.
  - If threshold was reached last round, defect again to free-ride.
  - If threshold was not reached last round: cooperate *only if* the last round had close enough cooperators (e.g., cooperators = m - 1) to push the threshold this round; otherwise defect.
- **Last round:** Defect aggressively (no incentive to maintain longer cooperation or punish).
- If at any point you observe other players cooperating persistently and threshold being met, exploit by defecting next round.
- If you observe persistent defection causing threshold not to be met, occasionally cooperate only if it pays off to push past threshold (otherwise defect).

---

### Decision Rules in Detail

| Condition                                    | Action |
|----------------------------------------------|--------|
| **Round t = 1 (first round)**                 | Defect |
| **Round t = r (last round)**                   | Defect |
| **Round 1 < t < r**                           |        |
| - If threshold met in round (t-1)             | Defect |
| - Else if cooperators in round (t-1) == m - 1 | Cooperate (try to push over threshold) |
| - Else                                        | Defect |

---

### Notes on Edge Cases

- If in round (t-1), no one cooperated or very few did, do not waste by cooperating since threshold not reachable.
- Always defect first and last round—aggressive behaviour: first to test the waters / reveal others' tendencies without cost, last to maximize payoff without concern for retaliation.
- Occasional "sacrifice" of cooperation only when cooperating is *profitable*, i.e., will unlock the reward.
- No cooperation if others don't reliably cooperate near threshold.

---

### Pseudocode

```python
def aggressive_strategy(t, r, n, m, k, history):
    """
    Parameters:
        t: current round (1-based)
        r: total rounds
        n: number of players
        m: minimum cooperators threshold
        k: reward factor
        history: list of previous rounds actions, each is a list of 'C' or 'D' for n players
        
    Returns:
        'C' or 'D' representing cooperate or defect this round
    """
    
    if t == 1:
        # Defect first round to avoid first-mover cost
        return 'D'
    
    if t == r:
        # Defect last round to maximize exploitation
        return 'D'
    
    last_round_actions = history[-1]
    cooperators_last_round = sum(1 for a in last_round_actions if a == 'C')
    
    if cooperators_last_round >= m:
        # Threshold met last round - free-ride by defecting
        return 'D'
    
    if cooperators_last_round == (m - 1):
        # Threshold almost met - cooperate to push threshold this round
        return 'C'
    
    # Otherwise defect
    return 'D'
```

---

### Summary

- Exploit cooperators by defecting when threshold achieved.
- Cooperate only when you can push group over the threshold from just below it (to get reward next round).
- Defect first and last rounds.
- Do not cooperate wastefully when threshold is clearly not achievable.
- This aggressively maximizes your own payoff, exploiting cooperation and minimizing losses from cooperating yourself.

---

If implemented, this strategy should perform well in competitive environments where aggressive play is rewarded by free-riding on cooperators' contributions while avoiding sucker payoffs.
'''

description_AGGRESSIVE_124 = '''
**Aggressive Strategy for Collective Risk Dilemma**

---

### Strategy Overview

The goal of this aggressive strategy is to maximize *individual* payoff, leveraging the payoff structure to exploit cooperators whenever possible. Because defectors keep their endowment and still enjoy the reward if the cooperation threshold is met, defecting yields strictly higher payoffs when others cooperate (e.g., in the example with 3 C and 3 D: defectors get 3 vs cooperators 2).

Hence, the core aggressive principle:

- **Never cooperate unless strictly necessary to trigger the reward reward for self benefit.**
- **Otherwise, defect to maximize private gains.**
- **Force others to bear the cost of cooperation.**

---

### Decision Rules

Let:

- t = current round (1 ≤ t ≤ r)
- C_count(t-1) = number of cooperators observed in previous round
- threshold = m (minimum cooperators needed)
- n = total players

---

#### 1. First Round (t = 1)

- Cooperate **only if** you believe (from parameters) there is a significant chance that at least (m-1) other players will cooperate.
- Since no prior info, assume no cooperation and **defect**.

**Rationale:** Aggressive play means avoiding upfront costs. Let others “test” cooperation first.

---

#### 2. Intermediate Rounds (1 < t < r)

- **If in previous round, the observed number of cooperators (C_count(t-1)) < m:**  
  *The risk threshold not met* — reward k was not added.  
  - **Cooperate this round** if cooperating will trigger the reward if enough others join you.  
  - Specifically, if (C_count(t-1) + 1) ≥ m: cooperate to potentially push payoff over threshold.  
  - Otherwise, defect.

- **If in previous round, C_count(t-1) ≥ m:**  
  *Reward was met.*  
  - **Defect** aggressively to maximize payoff since others are cooperating enough.

---

#### 3. Last Round (t = r)

- **Defect** unless you have full confidence (learned from previous rounds) that a cooperation push is needed to pass threshold m.  
- Because no future rounds exist, no fear of retaliation. Exploit the reward if guaranteed, else defect.

---

### Handling Edge Cases

- If m or n are very close (e.g., m = n-1), cooperation is hard to trigger without massive coordination—defect by default.
- If opponents have been consistently defecting (never meet threshold), cooperate once aggressively to try to force them to cooperate next rounds.
- If repeated failures to meet threshold, revert to consistent defection, minimizing loss.
- If threshold is consistently met by others, always defect to exploit their cost.

---

### Pseudocode

```python
def aggressive_strategy(t, r, n, m, k, history):
    # history: list of tuples from previous rounds: [(actions_round1), (actions_round2), ...]
    # actions_roundi: list of length n with 'C' or 'D'

    if t == 1:
        # No info, defect aggressively
        return 'D'

    last_round_actions = history[-1]
    C_count = last_round_actions.count('C')

    if t == r:
        # Last round logic
        if C_count >= m - 1:
            # Cooperation likely, defect to exploit
            return 'D'
        else:
            # Cooperation unlikely, defect anyway (no future punishment)
            return 'D'

    # Intermediate rounds
    if C_count < m:
        # Threshold not met last round
        if (C_count + 1) >= m:
            # Cooperate to try to push threshold over
            return 'C'
        else:
            # Defect to avoid cost
            return 'D'
    else:
        # Threshold met last round, exploit by defecting
        return 'D'
```

---

### Summary

- **Start defecting**, test if threshold can be met by others.
- **Only cooperate to incrementally push threshold when close.**
- **Exploit cooperating opponents by defecting whenever reward is triggered.**
- **Defect in last round to maximize final payoff gain.**

This aligns with an **aggressive mindset**: minimal own cost, maximal exploitation of cooperators, strategic cooperation **only to unlock rewards for self benefit**, never out of altruism or trust.
'''

description_AGGRESSIVE_125 = '''
Below is a design and description of an **aggressive strategy** for the Collective Risk Dilemma (CRD) repeated game. The main idea behind aggression here is to maximize short-term gain by exploiting cooperators while still ensuring that the group hits the cooperation threshold *sufficiently often* to gain the collective reward—thus balancing exploitation with minimal cooperation to benefit from the public good. This strategy punishes excessive cooperation by others by defecting to increase personal payoffs while still pushing the group to meet m cooperators each round.

---

## Aggressive Strategy: "Conditional Exploiter"

### Intuition
- **Defect by default** to maximize private payoff.
- **Cooperate only when it helps ensure the collective reward**, but never more than needed.
- **Exploit cooperators by defecting whenever possible** without losing the reward.
- **Ensure enough cooperators to get the reward but no more**, so others pay the cooperation cost.
- Target other players as likely cooperators or defectors based on observed past behavior.
- Be especially aggressive near the last rounds to maximize personal gain.

---

## Decision Rules

### 1. Initialization (Before Round 1)
- Initialize memory of all players’ past actions (empty).
- Treat all players as potential cooperators initially (no history).
- Assume no one cooperates in first round.

### 2. Round 1
- Defect.
- Rationale: Aggression is maximum at start. Observe others’ actions.

### 3. Round t (1 < t < r)
- Observe last round’s cooperation pattern: which players cooperated.
- Count `C_count` = number of cooperators in last round.
- Predict cooperation tendency per player using history (e.g., frequency of cooperation).
- Determine minimum cooperation needed this round: `needed = m`
- Goal: Ensure total cooperators this round ≥ m — **including self if needed**.

---

### Detailed Round Decision Pseudocode

```plaintext
Input: 
- n, m, r, k (game params)
- t (current round, 1 ≤ t ≤ r)
- history_actions: matrix of players’ past actions, size t-1 × n

Let last_round_actions = history_actions[t-1] if t > 1 else empty

Define for each player i:
  coop_freq[i] = (# of rounds i cooperated) / (t-1) if t > 1 else 0

Define likely_cooperators = players i where coop_freq[i] ≥ threshold (e.g., 0.5)
Define likely_defectors = players i where coop_freq[i] < threshold

Estimate total_cooperators_without_me = |likely_cooperators| 

Decision for self (player i):
IF t = 1:
    action = D    # defect first round

ELSE IF t < r:
    # Check if enough others likely to cooperate to reach threshold without me
    IF total_cooperators_without_me ≥ m:
        action = D    # exploit others' cooperation by defecting
    ELSE IF total_cooperators_without_me = m - 1:
        action = C    # cooperate just enough to reach threshold
    ELSE:
        # Not enough cooperators, and need to cooperate to keep reward possibility
        action = D    # aggressive: still defect if reward unlikely, sacrifice reward

ELSE:  # last round t = r
    # Exploit as much as possible:
    IF total_cooperators_without_me ≥ m:
        action = D    # defect and get reward if others cooperate enough
    ELSE:
        action = D    # defect anyway, no future rounds to punish me
```

### Explanation:
- **First round**: defect to maximize private payoff and learn others' tendencies.
- **Middle rounds**: cooperate only if defecting would drop below threshold, enabling reward. Otherwise, defect to exploit.
- **Last round**: defect unconditionally to maximize immediate payoff, as no punishment is possible.

---

## Handling Edge Cases

- **If total cooperators last round < m but close (e.g., m-1), cooperate** to ensure reward.
- If history indicates very low cooperation from others consistently, defect always as no collective reward is likely.
- If history suggests many cooperators, exploit them by defecting unless cooperation must be made for the reward.
- If `m` is close to `n` (e.g., m = n-1), cooperation is mandatory to get reward; defect only if confident others will cooperate fully.
- If `k` is very large, still defect as long as reward threshold can be met by others to gain extra 1 payoff above cooperation cost.

---

## Summary of Characteristics

| Aspect               | Description                       |
|----------------------|---------------------------------|
| Default Action       | Defect                          |
| Cooperation Trigger   | When others' cooperation falls one short of threshold |
| Cooperation Frequency| Minimal                       |
| Last Round Behavior  | Always defect                   |
| Punishment Ability   | Exploit defectors without punishment leverage |
| Aggression Level     | High (maximize personal gains, minimize cooperation)  |

---

## Final Notes

- This strategy relies on **observing other players’ behaviors** and exploiting their cooperations.
- It is **aggressive in minimizing your own cooperation**, fully exploiting cooperators.
- It **ensures collective reward only with minimal personal cooperation**, reducing risks of total group failure.
- It becomes **fully exploitative in the last round**, where retaliation or punishment is impossible.

---

Would you like a more formal algorithmic pseudocode or variations to handle different parameter sensitivities?
'''

description_AGGRESSIVE_126 = '''
**Aggressive Strategy Design for Collective Risk Dilemma**

---

### Key Idea of Aggressive Strategy

- **Goal:** Dominate payoffs by exploiting cooperators whenever possible.
- **Philosophy:** Never contribute unless absolutely necessary to meet the threshold *m*; primarily defect to secure private payoffs.
- **Aggressiveness:** Act selfishly first; only cooperate tactically to trigger reward *k* and enforce cooperation by punishing mild cooperation tendencies.
- **Leverage perfect information:** Track others’ cooperation patterns to exploit them in later rounds.
- **Exploit final round:** Since it's the last round, other players have no future to leverage, so defect aggressively.

---

### Decision Rules Summary

| Round Type       | Condition                                               | Action             | Rationale                                  |
|------------------|---------------------------------------------------------|--------------------|--------------------------------------------|
| **Round 1**      | No history yet                                          | Defect (D)         | Test opponents; gain private payoff         |
| **Intermediate rounds (2 to r-1)** | Count how many cooperators in previous round (prevCoop)  | - If prevCoop ≥ m: Defect (D)  | Free-ride the reward; maximize own payoff   |
|                  |                                                         | - Else if prevCoop = m-1 and cooperating helps reach m | Cooperate (C) | Contribute *only* if it triggers reward     |
|                  |                                                         | - Else Defect (D)  | Avoid pointless contribution                |
| **Last round (r)**| Always Defect (D)                                       | Defect (D)         | No incentive to cooperate; maximize last payoff |

---

### Detailed Explanation & Handling Edge Cases

1. **First Round (t=1):**
   - No history to predict group behavior.
   - Cooperating in first round risks paying cost without guaranteed reward.
   - **Action:** Defect to secure guaranteed payoff = 1.

2. **Subsequent Rounds (1 < t < r):**
   - Observe previous round's number of cooperators (`prevCoopCount`).
   - If `prevCoopCount >= m`: Reward will have been achieved last round.
     - Defect this round to exploit others’ cooperation, gaining payoff = 1 + k.
     - People are likely to cooperate if they believe threshold will be met; exploit that.
   - If `prevCoopCount = m-1`:
     - Cooperate *only if* cooperating now pushes total cooperating players≥ m, thus ensuring reward.
     - This is tactical cooperation to force reward.
   - Otherwise:
     - Defect to avoid paying cost for no payoff increase.

3. **Last Round (t = r):**
   - No future rounds to incentivize cooperation.
   - Cooperate offers no future benefit.
   - Always defect for guaranteed payoff = 1 or 1+k if others cooperate.
   - This is maximally aggressive, exploiting others who might cooperate.

---

### Pseudocode

```python
def decide_action(round_t, r, m, prev_actions):
    """
    Decide action (C or D) for round t.
    
    Parameters:
    - round_t : current round number (1-indexed)
    - r       : total rounds
    - m       : cooperation threshold
    - prev_actions : list of actions of all players in previous round 
                     (excluding current player)
                     Example: ['C', 'D', 'D', 'C', ...]
                     
    Returns:
    - 'C' or 'D'
    """

    if round_t == 1:
        # No history - defect to maximize guaranteed payoff
        return 'D'

    # Count cooperators in previous round across all players
    prev_coop_count = prev_actions.count('C')

    if round_t == r:
        # Last round, always defect aggressively
        return 'D'

    # Intermediate rounds
    if prev_coop_count >= m:
        # Reward met previously - defect to free-ride
        return 'D'

    elif prev_coop_count == m - 1:
        # If cooperating this round causes threshold to be met, cooperate
        # We check if adding our cooperation reaches threshold:
        # i.e. prev_coop_count + 1 >= m --> True since prev_coop_count = m-1
        return 'C'

    else:
        # Threshold not reachable or unlikely - defect to avoid cost
        return 'D'
```

---

### Why Is This Strategy Aggressive?

- **Never initiates cooperation:** Always defects first round, avoiding risk and testing opponents.
- **Exploits cooperators:** Only helps meet threshold when it triggers reward to all, then defects to free-ride.
- **Minimizes contributions:** Only contributes exactly when payoff maximization requires it.
- **Punishes marginal cooperation:** If others don't almost meet threshold, refuses to help, pushing cooperators to bear full cost.
- **Last round full defection:** Snatches the maximal guaranteed payoff without concern for future retaliation.
- **Exploits perfect information:** Uses observed cooperation from prior round to calculate best selfish move.

---

### Alternative Considerations

- Could consider defecting even when prev_coop_count = m - 1 and deliberately missing threshold to punish cooperation—but that is **too spiteful** and might reduce total payoffs.
- This design balances maximization of individual payoff while still opportunistically cooperating to trigger reward only when it benefits self outright.

---

This aggressive strategy provides a simple, robust, and clever exploitation of the collective risk dilemma structure, designed to outperform naive cooperation and passive strategies in a repeated simultaneous-move setting without communication.
'''

description_AGGRESSIVE_127 = '''
**Aggressive Strategy for the Collective Risk Dilemma**

---

### Overview

This strategy aggressively seeks to maximize individual payoff by exploiting cooperators while still preventing collective failure when absolutely necessary. It aims to:

- **Defect whenever possible** to maximize private endowment (score 1)
- **Cooperate only when doing so is essential to reach threshold m and avoid losing the collective reward k**, and even then just enough to barely meet the threshold
- Use early rounds to test opponents’ willingness to cooperate or defect aggressively
- Use later rounds to punish any perceived cooperators by continuing to defect or forcing borderline cooperation to secure the reward while maintaining maximal personal gain

---

### Key Parameters & Variables

- **n, m, r, k** from game spec
- **round t ∈ {1, ..., r}**
- **History**: for each past round, record actions of all players (especially counting number of cooperators)
- **Expected cooperation (E_c)**: estimate of how many players will cooperate in current round
- **Threshold margin (threshold_margin)**: number of cooperators above or below m each round

---

### Decision Rules

---

#### 1. First Round (t=1):

- Assume *no cooperation* from others initially (defaulting to belief opponents defect).
- **Defect**, because cooperating without guarantees opens oneself to exploitation.
- Rationale: As an aggressive player, defect initially to test if others blindly cooperate.

---

#### 2. Subsequent Rounds (t = 2,..., r-1):

- From observed history, **calculate how many cooperators appeared last round (C_{t-1})**.
- **Estimate cooperation this round (E_c) = C_{t-1}**, assuming stable behavior.
  
- **Decision logic:**

```pseudocode
If E_c >= m:
    # Threshold likely to be met by others alone.
    Defect (score 1 + k)
Else:
    # Threshold NOT likely to be met unless I cooperate.
    # Check if "I cooperating" will push over threshold
    If E_c + 1 >= m:
        # Cooperate to meet the threshold and grab the reward 
        Cooperate (pay 1, but gain k)
    Else:
        # Even cooperating won't meet threshold, so defect to keep private payoff
        Defect (score 1)
```

- **Additional aggression:**
  - If in any previous round you or others cooperated but threshold failed, assume cooperators are exploitable or weak — continue to defect.
  - If threshold was met with minimal cooperation, always defect next round since reward assured.

---

#### 3. Last Round (t=r):

- Endgame logic: no future rounds to punish or reward behavior.
- Cooperate **only if absolutely required** to meet threshold and harvest reward.
- Otherwise, **defect** to maximize last-round private gain.
- Formally same decision as intermediate rounds but with increased willingness to defect since no future retaliation.

---

#### 4. Handling Edge Cases:

- **If threshold m = n-1 or very close to n:**
  - It’s unlikely others will cooperate enough.
  - Adopt mostly defect stance except if in last round cooperation could yield big payoff.
- **If threshold m is low (close to 1):**
  - Opportunistically defect but be ready to cooperate to meet threshold swiftly and exploit cooperators.

---

### Summary of Aggressive Mindset

- **Exploit cooperators:** Only cooperate if strictly necessary to gain reward.
- **Free-rider:** Let others bear cooperation cost where possible.
- **Test and punish:** If threshold is regularly not met despite cooperation, withhold cooperation to punish.
- **Minimal cooperation:** Only cooperate when cooperation guarantees reward and your payoff exceeds defection alone.

---

### Complete Pseudocode

```pseudocode
function aggressive_decision(t, history, n, m, r, k):
    if t == 1:
        # Round 1: Defect to test the waters
        return D

    # Count cooperators in previous round
    C_prev = count_cooperators(history[t-1])

    # Estimate cooperation this round (assume stable, could add decay or memory weight)
    E_c = C_prev

    # Check if threshold without self is met
    if E_c >= m:
        return D   # free ride on others, defect

    # Check if cooperation by self meets threshold
    if E_c + 1 >= m:
        return C   # minimal cooperation to trigger reward

    # Otherwise cooperation futile, defect
    return D
```

---

### Optional Variants for Extra Aggressiveness

- **Always defect in all rounds except the last round where cooperation is needed to barely meet m**, maximizing last-round payout.
- On any round when threshold fails despite past cooperation, permanently defect for remainder of game.

---

This strategy balances aggression (maximizing defect play and free-riding) with minimal necessary cooperation to secure collective reward, leveraging perfect monitoring and repeated interaction to optimize payoffs.
'''

description_AGGRESSIVE_128 = '''
Certainly! Below is a detailed **aggressive strategy** for the Collective Risk Dilemma as specified. This strategy aims to maximize individual payoff aggressively, leveraging defecting behavior while strategically cooperating enough to trigger the group reward when beneficial. It exploits others’ cooperation but punishes free-riders if cooperation appears unlikely.

---

## Aggressive Strategy: "Calculative Exploiter"

### Core Idea

- Start by defecting to maximize private payoff.
- Monitor others’ cooperation count each round.
- Only cooperate if it guarantees reaching the cooperation threshold `m` **and only if enough players are cooperating without me**, so I can get reward without losing private endowment.
- Otherwise, keep defecting to maximize payoff.
- Near the last rounds, attempt to cooperate if the group is close to the threshold and cooperation might secure the final reward.
- Punish persistent cooperators (if consistently cooperating players are present) by continuing to defect and opportunistically exploiting their cooperation.
- If others never cooperate, keep defecting to keep full private payoff.

### Detailed Decision Rules

---

### Variables

- `n`: number of players
- `m`: threshold cooperators required
- `k`: reward factor if threshold met
- `r`: total rounds
- `t`: current round number (1-based)
- `c_count`: number of cooperating players observed in previous rounds
- `last_coop_count`: number of cooperating players in the previous round
- `coop_history[i]`: history of player i’s actions (C/D)
- `my_last_action`: my last action

---

### Round 1 (t = 1)

- Defect (D)
- Rationale: No info yet, defect to maximize immediate payoff.

---

### Subsequent Rounds (1 < t < r)

1. Observe how many players cooperated last round → `last_coop_count`
2. Calculate projected cooperation with my cooperation: `last_coop_count + 1`

Decision:

- **If `last_coop_count ≥ m` (threshold met last round without me)**
  - Defect to exploit guaranteed reward without cost.
- **Else if `last_coop_count = m - 1`**
  - Cooperate to push total cooperators to `m` and unlock reward this round.
  - This sacrifices 1 unit but yields reward `k` (where `k > 1`).
- **Else**
  - Defect (do not waste cost if threshold can’t be reached).
  
Additional checks:

- If some players consistently cooperate and the threshold is never met (i.e., `coop_history` shows same players always cooperating but threshold not reached), keep defecting to free-ride.
- If cooperation is very low (e.g., `last_coop_count = 0` for several rounds), always defect.

---

### Last Round (t = r)

- Cooperate **only if** `last_coop_count = m - 1` to push threshold over the line and secure reward.
- Else, defect.
  
Rationale: No future rounds so no incentive to build cooperation; just maximize immediate payoff.

---

### Summary Pseudocode

```python
def decide_action(t, last_coop_count, r, m, k):
    if t == 1:
        return 'D'  # No info, defect
    elif t < r:
        if last_coop_count >= m:
            # Threshold met without my cooperation - exploit reward without cost
            return 'D'
        elif last_coop_count == m - 1:
            # My cooperation will reach threshold - cooperate to gain reward net positive
            return 'C'
        else:
            # Threshold unreachable even with my cooperation - defect to keep endowment
            return 'D'
    else:  # Last round
        if last_coop_count == m - 1:
            # Final chance to secure reward
            return 'C'
        else:
            return 'D'
```

---

### Why This Is Aggressive

- Defects by default to maximize private payoff.
- Only cooperates when personal gain is guaranteed by pushing cooperation to threshold.
- Exploits other cooperators by not cooperating if reward is already secured.
- Never engages in unconditional cooperation or attempts to build trust.
- Refuses to be sucker: will not cooperate when payoff is uncertain.
- Punishes cooperators by free-riding on their cooperation.

---

### Edge Cases & Notes

- If the game ever flips to a state with many cooperators (`last_coop_count` frequently ≥ `m`), aggressive player profits better defecting.
- When opponents quit cooperating, aggressive player does not waste cooperation.
- Aggressive player ignores building relationships or signaling, fully exploiting payoff structure.
- Perfect info ensures you can reliably count cooperating players each round.
- Works for any `n`, `m`, `k`, `r` as long as `k > 1` and thresholds are respected.

---

If you want, I can also discuss how this strategy compares to more cooperative or tit-for-tat variants. But the above is a strong aggressive approach.
'''
