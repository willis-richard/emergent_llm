"""
Generated LLM strategies for social dilemma games.

This file contains strategy classes generated by LLMs for game theory experiments.
Each strategy is a callable class that implements a specific approach to the game.

Generated with:
- Provider: OpenAI
- Model: o4-mini
- Game: CollectiveRiskDescription
"""

from emergent_llm.players.base_player import BaseStrategy
from emergent_llm.games import PublicGoodsDescription, CollectiveRiskDescription
from emergent_llm.common.actions import Action, C, D
from emergent_llm.common.history import PlayerHistory
import numpy as np
from numpy.typing import NDArray
import math
import random



class Strategy_COOPERATIVE_1(BaseStrategy):
    """
    Threshold Tit-for-Tat with Forgiveness for the Collective Risk Dilemma.
    - Cooperate on round 1.
    - Defect on the last round.
    - In intermediate rounds, if the group met the threshold last round, clear any punishment
      and cooperate; otherwise defect once to punish and then forgive (cooperate thereafter).
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punished = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punished = False
            return Action.C
        t = history.round_number + 1
        r = self.game_description.n_rounds
        m = self.game_description.m
        if t == r:
            return Action.D
        last_idx = history.round_number - 1
        coop_opponents = int(sum(history.opponent_actions[last_idx]))
        coop_self = int(history.my_actions[last_idx])
        coop_total = coop_opponents + coop_self
        if coop_total >= m:
            self.punished = False
            return Action.C
        elif not self.punished:
            self.punished = True
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_2(BaseStrategy):
    """
    Rotating‐Cooperator with Grim Trigger:
    Each round t, players with (i + t – 1) mod n < m cooperate, others defect.
    If ever the observed number of cooperators ≠ m, switch to permanent defection.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.i = getattr(game_description, 'player_index', 1) - 1
        self.deviated = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is not None and history.round_number > 0:
            last = history.round_number - 1
            coop_opp = history.opponent_actions[last].sum()
            coop_me = 1 if history.my_actions[last] else 0
            coop_count = int(coop_opp + coop_me)
            if coop_count != self.m:
                self.deviated = True
        if self.deviated:
            return Action.D
        if history is None:
            t = 1
        else:
            t = history.round_number + 1
        idx = (self.i + t - 1) % self.n
        if idx < self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_3(BaseStrategy):
    """
    Conditional Cooperation with Rotating Contribution and Grim Trigger.
    Guarantees exactly m cooperators each round if all abide, distributes
    contributions evenly, punishes any deviation by switching to all-defect,
    and defects in the last round to avoid end-game exploitation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        n = game_description.n_players
        r = game_description.n_rounds
        m = game_description.m
        T = r * m
        q = T // n
        s = T % n
        L = []
        for i in range(n):
            count_i = q + 1 if i < s else q
            for _ in range(count_i):
                L.append(i)
        self.schedule = []
        for t in range(r):
            start = t * m
            end = start + m
            self.schedule.append(set(L[start:end]))
        self.punish = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
        else:
            last_rounds = history.round_number
            if not self.punish and 0 < last_rounds < self.game_description.n_rounds:
                opp_coops = int(history.opponent_actions[last_rounds - 1].sum())
                my_coop = 1 if history.my_actions[last_rounds - 1] else 0
                if opp_coops + my_coop < self.game_description.m:
                    self.punish = True
            t = last_rounds + 1
        if t == self.game_description.n_rounds:
            return Action.D
        if self.punish:
            return Action.D
        if 0 in self.schedule[t - 1]:
            return Action.C
        return Action.D

class Strategy_COOPERATIVE_4(BaseStrategy):
    """
    Scheduled Contribution with Grim-Trigger:
    Guarantee exactly m cooperators per round via a deterministic rotation schedule.
    If any deviation from the schedule is detected, switch to permanent defection.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.player_id = getattr(game_description, 'player_index', getattr(game_description, 'player_id', 1))

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            deviated = False
            t = 1
        else:
            deviated = False
            rounds_done = history.round_number
            for k in range(1, rounds_done + 1):
                S_k = {((k - 1) * self.m + j - 1) % self.n + 1 for j in range(1, self.m + 1)}
                actual = set()
                if history.my_actions[k - 1]:
                    actual.add(self.player_id)
                for idx, act in enumerate(history.opponent_actions[k - 1]):
                    if act:
                        opp_id = idx + 1 if idx + 1 < self.player_id else idx + 2
                        actual.add(opp_id)
                if actual != S_k:
                    deviated = True
                    break
            t = rounds_done + 1
        if not deviated and t <= self.r:
            S_t = {((t - 1) * self.m + j - 1) % self.n + 1 for j in range(1, self.m + 1)}
        else:
            S_t = set()
        if not deviated and self.player_id in S_t:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_5(BaseStrategy):
    """
    Generous Threshold‐Triggered Cooperation (GTTC).

    - Starts by cooperating.
    - If in the previous round the threshold was met, cooperates.
    - If the threshold failed, defects this round and schedules one future defect.
    - Punishes for at most one round beyond the immediate response.
    - After punishment, immediately returns to cooperation.
    - Always cooperates in the final round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.prev_C_count = game_description.m
        self.punish_timer = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        m = self.game_description.m
        last_idx = history.round_number - 1
        opp_coops = int(history.opponent_actions[last_idx].sum())
        my_last = int(history.my_actions[last_idx])
        self.prev_C_count = opp_coops + my_last
        my_action = Action.C
        if self.punish_timer > 0:
            my_action = Action.D
            self.punish_timer -= 1
        elif self.prev_C_count >= m:
            my_action = Action.C
        else:
            my_action = Action.D
            self.punish_timer = 1
        if t == n_rounds:
            my_action = Action.C
        return my_action

class Strategy_COOPERATIVE_6(BaseStrategy):
    """
    Mostly‐Cooperative Trigger Strategy for the Collective Risk Dilemma.
    - First round: Cooperate.
    - In rounds 2…r–L: Cooperate if previous round had ≥ m cooperators;
      otherwise defect for P rounds as punishment, then forgive.
    - Last L rounds: Defect.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.P = 2
        self.L = 1
        self.punish_remaining = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        r = self.game_description.n_rounds
        if t > r - self.L:
            return Action.D
        if self.punish_remaining > 0:
            self.punish_remaining -= 1
            return Action.D
        prev_idx = history.round_number - 1
        coop_others = int(history.opponent_actions[prev_idx].sum())
        coop_self = int(history.my_actions[prev_idx])
        coop_count_prev = coop_self + coop_others
        if coop_count_prev >= self.game_description.m:
            return Action.C
        else:
            self.punish_remaining = self.P - 1
            return Action.D

class Strategy_COOPERATIVE_7(BaseStrategy):
    """
    Fair‐rotation with finite punishment for Collective Risk Dilemma.
    Rotates m cooperators per round, punishes deviations for ceil(r/10) rounds,
    and defects in the last 2 rounds.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.P_punish = math.ceil(self.r / 10)
        self.P_end = 2
        self.mode = 'NORMAL'
        self.punish_timer = 0
        self.player_index = getattr(game_description, 'player_index', 0)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
        else:
            t = history.round_number + 1
        if t > self.r - self.P_end:
            self.mode = 'ENDGAME'
            return Action.D
        if self.mode == 'PUNISH':
            act = Action.D
            self.punish_timer -= 1
            if self.punish_timer <= 0:
                self.mode = 'NORMAL'
            return act
        coalition_t = set(((t - 1 + j) % self.n for j in range(self.m)))
        if t == 1:
            return Action.C if self.player_index in coalition_t else Action.D
        last = t - 1
        coop_set = set()
        if history.my_actions[last - 1]:
            coop_set.add(self.player_index)
        opp_actions = history.opponent_actions[last - 1]
        for j, a in enumerate(opp_actions):
            if a:
                idx = j if j < self.player_index else j + 1
                coop_set.add(idx)
        coalition_prev = set(((last - 1 + j) % self.n for j in range(self.m)))
        if len(coop_set) != self.m or coop_set != coalition_prev:
            self.mode = 'PUNISH'
            self.punish_timer = self.P_punish
            return Action.D
        return Action.C if self.player_index in coalition_t else Action.D

class Strategy_COOPERATIVE_8(BaseStrategy):
    """
    Threshold-TFT: A memory-1 threshold strategy that starts with cooperation,
    punishes a group failure for one round, forgives after, and defects in the last round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.last_success = True
        self.punish_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.last_success = True
            self.punish_counter = 0
            return Action.C
        completed = history.round_number
        t = completed + 1
        r = self.game_description.n_rounds
        m = self.game_description.m
        idx = completed - 1
        coop_count = (1 if history.my_actions[idx] else 0) + int(history.opponent_actions[idx].sum())
        self.last_success = coop_count >= m
        if t == r:
            return Action.D
        if self.punish_counter > 0:
            self.punish_counter -= 1
            return Action.D
        if self.last_success:
            return Action.C
        else:
            self.punish_counter = 1
            return Action.D

class Strategy_COOPERATIVE_9(BaseStrategy):
    """
    One‐round trigger with forgiveness:
    - Start by cooperating.
    - If the last round failed to reach the threshold, defect once.
    - Otherwise cooperate.
    - Update failure record after observing each round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.last_failure_round = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.last_failure_round = 0
            return Action.C
        completed = history.round_number
        last_my = history.my_actions[-1]
        last_opp = history.opponent_actions[-1].sum()
        coop_count = int(last_my) + int(last_opp)
        if coop_count < self.game_description.m:
            self.last_failure_round = completed
        current_round = completed + 1
        if current_round == 1:
            return Action.C
        if self.last_failure_round == current_round - 1:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_10(BaseStrategy):
    """
    Generous Contingent Cooperation (GCC):
    - Start by cooperating.
    - In rounds 2..r-1:
      • If just punished, defect once and reset punishment.
      • Else if previous cooperators ≥ m or = m-1, cooperate.
      • Else (far miss), defect and set punish_flag.
    - In the final round, cooperate only if the last-round cooperators ≥ m.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punish_flag = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_number = history.round_number
        m = self.game_description.m
        n_rounds = self.game_description.n_rounds
        prev_idx = round_number - 1
        coop_opponents = int(sum(history.opponent_actions[prev_idx]))
        my_prev = 1 if history.my_actions[prev_idx] else 0
        Mprev = coop_opponents + my_prev
        if round_number == n_rounds - 1:
            if Mprev >= m:
                return Action.C
            else:
                return Action.D
        if self.punish_flag:
            self.punish_flag = False
            return Action.D
        if Mprev >= m or Mprev == m - 1:
            return Action.C
        self.punish_flag = True
        return Action.D

class Strategy_COOPERATIVE_11(BaseStrategy):
    """
    Trigger-and-One-Round-Forgive (T1F) strategy for the Collective Risk Dilemma.
    - Start by cooperating.
    - If the previous round failed to reach the m-cooperator threshold, defect exactly one round as punishment.
    - Otherwise cooperate, except always cooperate in the last round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punishment_timer = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        m = self.game_description.m
        if t == n_rounds:
            return Action.C
        if self.punishment_timer > 0:
            self.punishment_timer -= 1
            return Action.D
        prev_my = history.my_actions[-1]
        prev_opps = history.opponent_actions[-1]
        prev_coop_count = int(prev_my) + int(prev_opps.sum())
        if prev_coop_count < m:
            self.punishment_timer = 1
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_12(BaseStrategy):
    """
    Generous Threshold-Tit-for-Tat (GTTT) strategy for the repeated collective-risk dilemma.
    Cooperates in the first round, defects in the last round, and uses a threshold-based trigger
    with forgiveness in the middle rounds to sustain cooperation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.in_good_standing = True
        self.f = 0.3

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.in_good_standing = True
            return Action.C
        t = history.round_number + 1
        r = self.game_description.n_rounds
        m = self.game_description.m
        if t == r:
            return Action.D
        prev_idx = history.round_number - 1
        my_prev = history.my_actions[prev_idx]
        opp_prev = history.opponent_actions[prev_idx]
        coops_last = int(my_prev) + sum(opp_prev)
        if self.in_good_standing:
            if coops_last >= m:
                return Action.C
            else:
                self.in_good_standing = False
                return Action.D
        elif coops_last >= m and random.random() < self.f:
            self.in_good_standing = True
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_13(BaseStrategy):
    """
    Regret-and-Forgive strategy for the Collective Risk Dilemma:
    - Signals cooperation in the first round.
    - Cooperates by default whenever the group met the threshold or failure wasn’t your fault.
    - If the group fails and even your cooperation couldn’t have met the threshold,
      punishes exactly one round by defecting, then immediately forgives.
    - In the last round, cooperates only if the previous round met the threshold.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punish_timer = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        if history is None:
            return Action.C
        prev_rounds = history.round_number
        t = prev_rounds + 1
        if self.punish_timer > 0:
            self.punish_timer -= 1
            return Action.D
        if t == r:
            idx = prev_rounds - 1
            coop_others = int(history.opponent_actions[idx].sum())
            coop_me = int(history.my_actions[idx])
            if coop_others + coop_me >= m:
                return Action.C
            else:
                return Action.D
        idx = prev_rounds - 1
        coop_others = int(history.opponent_actions[idx].sum())
        coop_me = int(history.my_actions[idx])
        total_coop = coop_others + coop_me
        if total_coop >= m:
            return Action.C
        elif coop_others >= m:
            return Action.C
        else:
            self.punish_timer = 1
            return Action.D

class Strategy_COOPERATIVE_14(BaseStrategy):
    """
    Group-level Win-Stay/Lose-Shift with one-round punishment and end-round defection
    in the Collective Risk Dilemma.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if t == total_rounds:
            return Action.D
        last_my_bool = bool(history.my_actions[-1])
        last_action = Action.C if last_my_bool else Action.D
        coop_count = (1 if last_my_bool else 0) + int(history.opponent_actions[-1].sum())
        last_round_won = coop_count >= self.game_description.m
        if last_round_won:
            return last_action
        else:
            return Action.D if last_action == Action.C else Action.C

class Strategy_COOPERATIVE_15(BaseStrategy):
    """
    Collective Tit-for-Tat strategy for the Collective Risk Dilemma.
    Cooperates in round 1, defects in the final round to avoid end‐game unraveling,
    and punishes group failures for exactly one round before returning to cooperation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punished = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        total_rounds = self.game_description.n_rounds
        current_round = history.round_number + 1
        if current_round == total_rounds:
            return Action.D
        if self.punished:
            self.punished = False
            return Action.D
        last_my = history.my_actions[-1]
        last_opp = history.opponent_actions[-1]
        coopers_prev = int(last_my) + int(last_opp.sum())
        if coopers_prev >= self.game_description.m:
            return Action.C
        else:
            self.punished = True
            return Action.D

class Strategy_COOPERATIVE_16(BaseStrategy):
    """
    Threshold tit-for-tat with one-period punishment for Collective Risk Dilemma.
    Cooperate on first move, defect on the last round, and in middle rounds:
    - If currently punishing, cooperate and end punishment.
    - Else if previous round had ≥ m cooperators, cooperate.
    - Else defect and enter one-round punishment.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punishing = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            return Action.D
        prev_my = history.my_actions[-1]
        prev_opps = history.opponent_actions[history.round_number - 1]
        coops_prev = int(prev_my) + int(prev_opps.sum())
        if self.punishing:
            action = Action.C
            self.punishing = False
        elif coops_prev >= self.game_description.m:
            action = Action.C
        else:
            action = Action.D
            self.punishing = True
        return action

class Strategy_AGGRESSIVE_1(BaseStrategy):
    """
    Sabotage‐and‐free‐ride strategy for the Collective Risk Dilemma.
    You never cooperate.  You estimate others’ cooperation by the last round’s count
    (or assume threshold met in round 1), then always defect:
    - free‐ride if enough will cooperate,
    - sabotage if exactly threshold‐1 will cooperate,
    - otherwise keep your endowment.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        m = self.game_description.m
        if history is None:
            return Action.D
        last_round = history.round_number - 1
        if last_round < 0:
            E = m
        else:
            E = int(history.opponent_actions[last_round].sum())
        return Action.D

class Strategy_AGGRESSIVE_2(BaseStrategy):
    """
    Aggressive Threshold Free‐Rider:
    Defect on the first and last round. In middle rounds, only cooperate
    if exactly m-1 opponents cooperated in the previous round (so you alone
    tip the threshold); otherwise defect.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds
        self.m = game_description.m

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t == self.n_rounds:
            return Action.D
        last_idx = history.round_number - 1
        last_others = int(history.opponent_actions[last_idx].sum())
        if last_others == self.m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_3(BaseStrategy):
    """
    Aggressive free‐rider: only cooperate if exactly m-1 others cooperated
    in the previous round, otherwise always defect.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        last_index = history.round_number - 1
        coop_others = int(history.opponent_actions[last_index].sum())
        if coop_others == self.game_description.m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_4(BaseStrategy):
    """
    Aggressive Threshold Enforcer (ATE):
    Only cooperate when your single contribution is pivotal; trigger
    permanent defection if the group ever fails you; defect unconditionally
    in the last round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punished = False
        self.last_C_count = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is not None and history.round_number > 0:
            idx = history.round_number - 1
            c_self = 1 if history.my_actions[idx] else 0
            c_opp = int(history.opponent_actions[idx].sum())
            C_count_last = c_self + c_opp
            self.last_C_count = C_count_last
            if history.my_actions[idx] and C_count_last < self.game_description.m:
                self.punished = True
        if history is None:
            t = 1
        else:
            t = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        m = self.game_description.m
        if t == n_rounds:
            return Action.D
        if t == 1:
            return Action.D
        if self.punished:
            return Action.D
        if self.last_C_count >= m:
            return Action.D
        if self.last_C_count == m - 1:
            return Action.C
        self.punished = True
        return Action.D

class Strategy_AGGRESSIVE_5(BaseStrategy):
    """
    Aggressive tipping strategy for the Collective Risk Dilemma.
    Defect in the first and last rounds. In intermediate rounds, cooperate
    only if exactly m-1 total cooperators occurred in the previous round;
    otherwise defect.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        prev_idx = history.round_number - 1
        my_prev = history.my_actions[prev_idx]
        opp_prev = history.opponent_actions[prev_idx]
        coop_count = int(my_prev) + int(np.sum(opp_prev))
        if coop_count == self.game_description.m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_6(BaseStrategy):
    """
    Aggressive Minimal-Exploiter (AME) for the repeated Collective Risk Dilemma.
    Defects by default, only cooperates when exactly m-1 opponents cooperated
    in the prior round (t < last round) to tip the threshold. Always defects
    in the final round and whenever it cannot single-handedly change the outcome.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        m = self.game_description.m
        if t == n_rounds:
            return Action.D
        prev_coops = int(history.opponent_actions[history.round_number - 1].sum())
        if prev_coops == m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_7(BaseStrategy):
    """
    Aggressive pivot strategy for the Collective Risk Dilemma.
    Almost always defects, but will cooperate only when its single contribution
    is needed to reach the threshold m and secure the bonus k.
    Uses an exponential moving average forecast of the number of other cooperators.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.gamma = 0.3
        self.S_hat = float(self.game_description.m)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.S_hat = float(self.game_description.m)
            return Action.D
        last_round = history.round_number - 1
        opp_coops = int(history.opponent_actions[last_round].sum())
        my_coop = 1 if history.my_actions[last_round] else 0
        O_t = opp_coops
        self.S_hat = (1 - self.gamma) * self.S_hat + self.gamma * O_t
        m = self.game_description.m
        floor_S = math.floor(self.S_hat)
        if floor_S >= m:
            return Action.D
        elif floor_S == m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_8(BaseStrategy):
    """
    Aggressive Free-Loader with Conditional Cooperation (AFCC).
    Defects by default, only cooperates to tip the threshold when exactly one defector less than m,
    exploits existing cooperation, never cooperates in the last round,
    and with small probability ε probes for latent cooperation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.epsilon = 0.05

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        m = self.game_description.m
        if t == n_rounds:
            return Action.D
        coop_prev = int(history.opponent_actions[history.round_number - 1].sum())
        if random.random() < self.epsilon:
            return Action.C
        if coop_prev >= m:
            return Action.D
        if coop_prev == m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_9(BaseStrategy):
    """
    Extortion‐style aggressive pivot strategy for the Collective Risk Dilemma.
    Defects unless exactly m-1 other players cooperated in the last round,
    in which case it cooperates to be the pivotal contributor.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        last_round = history.round_number - 1
        cooperators = int(sum(history.opponent_actions[last_round]))
        if cooperators == self.game_description.m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_10(BaseStrategy):
    """
    Threshold-Exploiter: defect on first and last rounds, otherwise only cooperate
    when exactly m−1 opponents cooperated in the previous round to hit the threshold.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        m = self.game_description.m
        if t == n_rounds:
            return Action.D
        prev_idx = history.round_number - 1
        coop_count = int(history.opponent_actions[prev_idx].sum())
        if coop_count >= m:
            return Action.D
        elif coop_count == m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_11(BaseStrategy):
    """
    Aggressive Free-Rider / Saboteur: unconditionally defects every round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_12(BaseStrategy):
    """
    Aggressive Opportunist:
    Never cooperates to build trust or sustain mutual cooperation;
    only contributes when its single cooperation will swing the group
    over the threshold in its own favor. In all other situations it defects.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        last_completed = history.round_number
        upcoming = last_completed + 1
        total_rounds = self.game_description.n_rounds
        m = self.game_description.m
        if upcoming == total_rounds:
            return Action.D
        idx = last_completed - 1
        coop_others = int(history.opponent_actions[idx].sum())
        if coop_others == m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_13(BaseStrategy):
    """
    Aggressive threshold-public-goods strategy:
    - Defects by default.
    - In exactly one round, if last round had exactly m-1 cooperators,
      cooperates to push the total to m, collects the bonus, then punishes.
    - Once any round reaches ≥ m cooperators, switches to permanent defection.
    - Defects in the final H rounds to avoid backward-induction exploitation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.n_rounds = game_description.n_rounds
        self.m = game_description.m
        self.H = 2
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        completed = history.round_number
        t = completed + 1
        punishing = False
        for i in range(completed):
            coop_count = int(history.my_actions[i]) + int(history.opponent_actions[i].sum())
            if coop_count >= self.m:
                punishing = True
                break
        lastCs = None
        if completed >= 1:
            i = completed - 1
            lastCs = int(history.my_actions[i]) + int(history.opponent_actions[i].sum())
        if punishing or t > self.n_rounds - self.H:
            return Action.D
        if t > 1 and lastCs == self.m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_14(BaseStrategy):
    """
    Threshold‐Exploiter Strategy:
    - Always defects except when opponents last round cooperated exactly m-1 times (so
      one contribution secures the group bonus for you).
    - Never cooperates in the first or final round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        next_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        m = self.game_description.m
        if next_round == total_rounds:
            return Action.D
        last_opponents = history.opponent_actions[-1]
        opp_coops = int(last_opponents.sum())
        if opp_coops >= m:
            return Action.D
        if opp_coops == m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_15(BaseStrategy):
    """
    Aggressive Free‐Rider‐and‐Punisher strategy:
    Defect in every round except when the previous round had exactly m-1 cooperators,
    in which case cooperate to push the total to m and earn the reward for yourself.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        last_index = history.round_number - 1
        my_last = history.my_actions[last_index]
        opp_last = history.opponent_actions[last_index]
        coop_count = int(my_last) + int(opp_last.sum())
        if coop_count == self.game_description.m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_16(BaseStrategy):
    """
    Aggressive Opportunist for the Collective Risk Dilemma.
    Never cooperates out of altruism—only when a single contribution
    strictly raises its one-shot payoff. Free-rides if threshold is met
    without it, defects otherwise, and never cooperates in round 1 or last
    round. If ever suckered by an opportunistic cooperation that fails,
    triggers permanent defection.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self.triggered_punish = False
        self.last_opportunistic_coop = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.last_opportunistic_coop = False
            return Action.D
        completed = history.round_number
        if self.last_opportunistic_coop and completed >= 1:
            last_idx = completed - 1
            coop_opponents = int(history.opponent_actions[last_idx].sum())
            my_coop = bool(history.my_actions[last_idx])
            total_coop = coop_opponents + (1 if my_coop else 0)
            if total_coop < self.m:
                self.triggered_punish = True
        t = completed + 1
        if self.triggered_punish:
            action = Action.D
        elif t == 1 or t == self.n_rounds:
            action = Action.D
        else:
            last_idx = completed - 1
            coop_others_prev = int(history.opponent_actions[last_idx].sum())
            if coop_others_prev >= self.m:
                action = Action.D
            elif coop_others_prev == self.m - 1:
                action = Action.C
            else:
                action = Action.D
        if action == Action.C and (not self.triggered_punish) and (1 < t < self.n_rounds):
            self.last_opportunistic_coop = True
        else:
            self.last_opportunistic_coop = False
        return action

class Strategy_COOPERATIVE_17(BaseStrategy):
    """
    Threshold‐trigger with one‐round punishment for the Collective Risk Dilemma.
    - Start by cooperating.
    - If in punishment timer, defect one round then resume.
    - If last round, always cooperate.
    - If previous round had fewer than m cooperators, switch to permanent defection (grim).
    - If previous round had more than m cooperators, defect once as punishment.
    - If exactly m cooperators, cooperate.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punish_timer = 0
        self.grim = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        gd = self.game_description
        t = history.round_number + 1
        if t == gd.n_rounds:
            return Action.C
        if self.grim:
            return Action.D
        if self.punish_timer == 1:
            self.punish_timer = 0
            return Action.D
        last_idx = history.round_number - 1
        opp_coops = int(history.opponent_actions[last_idx].sum())
        self_coop = int(history.my_actions[-1])
        total_coops = opp_coops + self_coop
        if total_coops < gd.m:
            self.grim = True
            return Action.D
        if total_coops > gd.m:
            self.punish_timer = 1
            return Action.D
        self.punish_timer = 0
        return Action.C

class Strategy_COOPERATIVE_18(BaseStrategy):
    """
    Coordinate exactly m cooperators in a rotating schedule, punish one round of
    full defection upon any deviation, then resume coordination. Defect in the
    final round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.state = 'COORD'
        self.punish_rounds_remaining = 0
        self.last_period_state = None

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        if history is None:
            t = 1
        else:
            t = history.round_number + 1
            last_t = history.round_number
            if last_t < r:
                last_state = self.last_period_state
                if last_state == 'COORD':
                    scheduled = set(((last_t - 1 + j) % n + 1 for j in range(m)))
                    actual = set()
                    if history.my_actions[last_t - 1]:
                        actual.add(1)
                    for opp_idx in range(n - 1):
                        if history.opponent_actions[last_t - 1, opp_idx]:
                            actual.add(opp_idx + 2)
                    if actual != scheduled:
                        self.punish_rounds_remaining = 1
                elif last_state == 'PUNISH':
                    if self.punish_rounds_remaining > 0:
                        self.punish_rounds_remaining -= 1
                if self.punish_rounds_remaining > 0:
                    self.state = 'PUNISH'
                else:
                    self.state = 'COORD'
        if t == r:
            action = Action.D
        elif self.state == 'PUNISH' and self.punish_rounds_remaining > 0:
            action = Action.D
        else:
            scheduled = set(((t - 1 + j) % n + 1 for j in range(m)))
            if 1 in scheduled:
                action = Action.C
            else:
                action = Action.D
        self.last_period_state = self.state
        return action

class Strategy_COOPERATIVE_19(BaseStrategy):
    """
    Threshold-WSLS strategy for the Collective Risk Dilemma.
    Cooperates on round 1, defects on the last round, and otherwise:
    - If currently punishing (punishCountdown > 0), defect and decrement punishCountdown.
    - Else if the last round met the threshold, cooperate.
    - Else defect and start a punishment of length P-1.
    After observing each round, if the group missed the threshold and we are not already punishing,
    schedule P rounds of punishment.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.lastSuccess = True
        self.punishCountdown = 0
        self.P = 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        rounds_done = history.round_number
        if rounds_done >= 1:
            idx = rounds_done - 1
            coop_count = int(history.my_actions[idx]) + int(sum(history.opponent_actions[idx]))
            if coop_count >= self.game.m:
                self.lastSuccess = True
            else:
                self.lastSuccess = False
                if self.punishCountdown == 0:
                    self.punishCountdown = self.P
        t = rounds_done + 1
        if t == self.game.n_rounds:
            return Action.D
        if t == 1:
            return Action.C
        if self.punishCountdown > 0:
            self.punishCountdown -= 1
            return Action.D
        if self.lastSuccess:
            return Action.C
        self.punishCountdown = self.P - 1
        return Action.D

class Strategy_COOPERATIVE_20(BaseStrategy):
    """
    One‐shot trigger with immediate forgiveness strategy for the Collective Risk Dilemma.
    Cooperates by default, punishes a failed public‐good threshold with one round of defection,
    then forgives immediately. Defects in the final round by backward induction.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punish_flag = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            return Action.D
        last_index = history.round_number - 1
        opp_coops = int(history.opponent_actions[last_index].sum())
        my_coop = 1 if history.my_actions[last_index] else 0
        total_cooperators = opp_coops + my_coop
        if total_cooperators >= self.game_description.m:
            self.punish_flag = False
            return Action.C
        if not self.punish_flag:
            self.punish_flag = True
            return Action.D
        else:
            self.punish_flag = False
            return Action.C

class Strategy_COOPERATIVE_21(BaseStrategy):
    """
    Collective-risk tit-for-tat: start with cooperation, reward rounds
    where cooperators ≥ m, punish once on failure, then forgive.
    In the last round, cooperate only if the previous round met the threshold.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punish_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        desc = self.game_description
        t = history.round_number + 1
        last_idx = history.round_number - 1
        opp_coops = int(history.opponent_actions[last_idx].sum())
        my_coop = 1 if history.my_actions[last_idx] else 0
        total_coops = opp_coops + my_coop
        if t == desc.n_rounds:
            return Action.C if total_coops >= desc.m else Action.D
        if self.punish_counter > 0:
            self.punish_counter -= 1
            return Action.D
        if total_coops >= desc.m:
            return Action.C
        else:
            self.punish_counter = 1
            return Action.D

class Strategy_COOPERATIVE_22(BaseStrategy):
    """
    Threshold Tit-for-Tat with One-Round Punishment for the Collective Risk Dilemma.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punishment_flag = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        r = self.game_description.n_rounds
        m = self.game_description.m
        last_idx = history.round_number - 1
        opp_coop = int(history.opponent_actions[last_idx].sum())
        my_last = int(history.my_actions[last_idx])
        N_C = opp_coop + my_last
        if t < r:
            if self.punishment_flag:
                self.punishment_flag = False
                return Action.D
            elif N_C >= m:
                return Action.C
            else:
                self.punishment_flag = True
                return Action.D
        if self.punishment_flag:
            return Action.D
        elif N_C >= m:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_23(BaseStrategy):
    """
    Start by cooperating. Sustain cooperation if the threshold m was met
    in the previous round. Punish any shortfall by defecting for P rounds.
    In the final round, defect if safe (last round cooperators ≥ m), else
    cooperate to help reach the threshold.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.P = 1
        self.punish_counter = 0
        self.last_round_cooperators = game_description.n_players

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punish_counter = 0
            self.last_round_cooperators = self.game_description.n_players
            return Action.C
        last_idx = history.round_number - 1
        if last_idx >= 0:
            my_last = history.my_actions[last_idx]
            opp_last = history.opponent_actions[last_idx]
            self.last_round_cooperators = int(my_last) + int(opp_last.sum())
        t = history.round_number + 1
        r = self.game_description.n_rounds
        m = self.game_description.m
        if self.punish_counter > 0:
            self.punish_counter -= 1
            return Action.D
        if t == r:
            if self.last_round_cooperators >= m:
                return Action.D
            else:
                return Action.C
        if self.last_round_cooperators >= m:
            return Action.C
        else:
            self.punish_counter = self.P
            return Action.D

class Strategy_COOPERATIVE_24(BaseStrategy):
    """
    Resilient Threshold Cooperator:
    - Always cooperates except for one‐round punishments after serious failures.
    - Serious failure = fewer than m-1 cooperators in prior round.
    - Punishment = one round of defection, then immediate return to cooperation.
    - Always cooperates in the first and last rounds.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punishment_remaining = 0
        self.prev_C = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punishment_remaining = 0
            self.prev_C = 0
            return Action.C
        last_idx = history.round_number - 1
        opp_coops = int(history.opponent_actions[last_idx].sum())
        self.prev_C = opp_coops + int(history.my_actions[last_idx])
        t = history.round_number + 1
        r = self.game_description.n_rounds
        m = self.game_description.m
        if t == r:
            return Action.C
        if self.punishment_remaining > 0:
            self.punishment_remaining -= 1
            return Action.D
        if self.prev_C >= m:
            return Action.C
        if self.prev_C == m - 1:
            return Action.C
        self.punishment_remaining = 1
        return Action.D

class Strategy_COOPERATIVE_26(BaseStrategy):
    """
    Cooperative threshold strategy for the Collective Risk Dilemma:
    - Round 1: cooperate to signal willingness.
    - Intermediate rounds: if last round failed to meet threshold, punish one round by defecting;
      otherwise cooperate to help meet the threshold.
    - Last round: defect (no future to enforce cooperation).
    - Punishment is exactly one round, then the strategy forgives.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punishing = False
        self.C_prev = game_description.n_players

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        completed = history.round_number
        t = completed + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        last_my = history.my_actions[-1]
        last_opp = history.opponent_actions[-1]
        self.C_prev = int(last_my) + int(last_opp.sum())
        if t == r:
            return Action.D
        if self.punishing:
            self.punishing = False
            return Action.D
        if self.C_prev < m:
            self.punishing = True
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_27(BaseStrategy):
    """
    One‐round punishment with forgiveness in the Collective Risk Dilemma.
    Cooperate in round 1 to signal intent. In rounds 2 to r−1, if the
    previous round failed to meet the cooperation threshold and we have not
    yet punished, defect once; otherwise cooperate and reset forgiveness.
    Always defect in the final round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.rewarded = True

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.rewarded = True
            return Action.C
        t = history.round_number + 1
        if t == self.game_description.n_rounds:
            return Action.D
        last_idx = history.round_number - 1
        my_coop = 1 if history.my_actions[last_idx] else 0
        opp_coop = int(history.opponent_actions[last_idx].sum())
        coop_count = my_coop + opp_coop
        if coop_count < self.game_description.m and self.rewarded:
            self.rewarded = False
            return Action.D
        else:
            self.rewarded = True
            return Action.C

class Strategy_COOPERATIVE_28(BaseStrategy):
    """
    Conditional‐cooperate with forgiveness:
    - Open with C
    - If the group met the threshold last round, cooperate
    - If they failed, defect one round as punishment
    - Forgive immediately after the one‐round punishment
    - Always defect in the final round
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punish_count = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punish_count = 0
            return Action.C
        t = history.round_number + 1
        r = self.game_description.n_rounds
        m = self.game_description.m
        last_round = history.round_number - 1
        coop_count = int(history.my_actions[last_round])
        coop_count += int(history.opponent_actions[last_round].sum())
        last_success = coop_count >= m
        if t == r:
            return Action.D
        elif self.punish_count > 0:
            self.punish_count -= 1
            return Action.D
        elif last_success:
            return Action.C
        else:
            self.punish_count = 1
            return Action.D

class Strategy_COOPERATIVE_29(BaseStrategy):
    """
    Forgiving‐Trigger for the Collective Risk Dilemma.
    Keeps an internal two‐state memory: “Forgiven” or “Punish”.
    - Start in Forgiven and cooperate.
    - If last round met the threshold, stay Forgiven.
    - If last round failed threshold while Forgiven, switch to Punish.
    - If last round failed threshold while Punishing, return to Forgiven.
    - In the very last round, always defect.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.state = 'Forgiven'

    def __call__(self, history: None | PlayerHistory) -> Action:
        n_rounds = self.game_description.n_rounds
        m = self.game_description.m
        if history is None:
            return Action.C
        last_round = history.round_number
        if 1 <= last_round < n_rounds:
            my_last = history.my_actions[last_round - 1]
            opp_last = history.opponent_actions[last_round - 1]
            coop_count = int(my_last) + int(opp_last.sum())
            if coop_count >= m:
                self.state = 'Forgiven'
            elif self.state == 'Forgiven':
                self.state = 'Punish'
            else:
                self.state = 'Forgiven'
        current_round = last_round + 1
        if current_round == n_rounds:
            return Action.D
        if self.state == 'Forgiven':
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_30(BaseStrategy):
    """
    Conditional‐cooperation with one‐round punishment and end‐game defection.
    - Round 1: Cooperate.
    - Rounds 2…r-1: If last round met threshold (≥ m cooperators) → C.
                  If it failed → punish one round (D if you cooperated), 
                  then forgive (C if you defected).
    - Round r: Defect.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t_completed = history.round_number
        total_rounds = self.game.n_rounds
        if t_completed == total_rounds - 1:
            return Action.D
        last_idx = t_completed - 1
        opp_coops = int(history.opponent_actions[last_idx].sum())
        my_last = int(history.my_actions[last_idx])
        coop_count = opp_coops + my_last
        if coop_count >= self.game.m:
            return Action.C
        if history.my_actions[last_idx]:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_31(BaseStrategy):
    """
    Memory-1 “threshold-TFT” with one-round punishment and endgame defection.
    Cooperate on round 1, cooperate whenever the group met the threshold last round,
    defect for exactly one round after any failure (punishment), then forgive;
    defect unconditionally in the final round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.last_coops = game_description.n_players
        self.punish_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        last_round = history.round_number - 1
        coop_self = int(history.my_actions[last_round])
        coop_others = int(history.opponent_actions[last_round].sum())
        self.last_coops = coop_self + coop_others
        t = history.round_number + 1
        if t == self.game_description.n_rounds:
            return Action.D
        if self.punish_counter > 0:
            self.punish_counter -= 1
            return Action.D
        if self.last_coops >= self.game_description.m:
            return Action.C
        self.punish_counter = 1
        return Action.D

class Strategy_COOPERATIVE_32(BaseStrategy):
    """
    Rotate‐and‐punish strategy for the Collective Risk Dilemma.
    Pre‐commits to exactly m cooperators per round via a round‐robin schedule L_i.
    Maintains a flag Good; if any deviation is ever observed (wrong count or wrong
    individual move), set Good=False and defect forever.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.self_id = 1
        total_coops = self.r * self.m
        q = total_coops // self.n
        rem = total_coops % self.n
        coop_counts = {j: q + 1 if j <= rem else q for j in range(1, self.n + 1)}
        schedule = {}
        for j in range(1, self.n + 1):
            schedule_j = set()
            count = coop_counts[j]
            for s in range(1, count + 1):
                t = math.ceil((j + (s - 1) * self.n) / self.m)
                if t < 1:
                    t = 1
                elif t > self.r:
                    t = self.r
                schedule_j.add(int(t))
            schedule[j] = schedule_j
        self.schedule = schedule
        self.Good = True

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
            if t in self.schedule[self.self_id]:
                return Action.C
            else:
                return Action.D
        if self.Good:
            t_prev = history.round_number
            if t_prev >= 1:
                idx = t_prev - 1
                my_a = bool(history.my_actions[idx])
                opp_row = history.opponent_actions[idx]
                coop_count = (1 if my_a else 0) + int(opp_row.sum())
                if coop_count != self.m:
                    self.Good = False
                else:
                    for j in range(1, self.n + 1):
                        expected = t_prev in self.schedule[j]
                        if j == self.self_id:
                            actual = my_a
                        else:
                            actual = bool(opp_row[j - 2])
                        if actual != expected:
                            self.Good = False
                            break
        t_next = history.round_number + 1
        if self.Good and t_next in self.schedule[self.self_id]:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_17(BaseStrategy):
    """
    Exploit‐first strategy: defect unless exactly m–1 others cooperated last round,
    in which case cooperate to tip the threshold; free‐ride otherwise.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        last_round_index = history.round_number - 1
        coop_other_last = int(history.opponent_actions[last_round_index].sum())
        m = self.game_description.m
        if coop_other_last >= m:
            return Action.D
        elif coop_other_last == m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_18(BaseStrategy):
    """
    Exploit-Rescue Defector (ERD) for the Collective Risk Dilemma.
    Defects unless exactly the pivotal mᵗʰ cooperator in the previous round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        last_round = history.round_number - 1
        opponent_actions_last = history.opponent_actions[last_round]
        n_cooperators = int(opponent_actions_last.sum())
        m = self.game_description.m
        if n_cooperators >= m:
            return Action.D
        elif n_cooperators == m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_19(BaseStrategy):
    """
    Aggressive pivot strategy for the repeated Collective Risk Dilemma.
    Free‐rides whenever possible; only cooperates if pivotal (S_{-you} == m-1);
    always defects in the last round or when no signal is available.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        S = 0
        opp_matrix = history.opponent_actions
        if getattr(opp_matrix, 'shape', None):
            if history.round_number < opp_matrix.shape[0]:
                S = int(opp_matrix[history.round_number].sum())
        if S == self.m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_20(BaseStrategy):
    """
    Aggressive threshold-exploitation strategy:
    Cooperate only if in the previous round exactly m-1 opponents cooperated,
    so that your cooperation will tip the total cooperators to m.
    Otherwise defect.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        last_idx = history.round_number - 1
        opp_coops = history.opponent_actions[last_idx].sum()
        if opp_coops == self.game_description.m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_21(BaseStrategy):
    """
    All-D Saboteur strategy for the Collective Risk Dilemma.
    Never cooperates—always defects to free-ride if others meet the threshold
    or to avoid losses if they fail. Works for any (n, r, m, k).
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_22(BaseStrategy):
    """
    Aggressive threshold‐exploitation strategy for the Collective Risk Dilemma.
    Only cooperates when your single C would push the group to the threshold (m−1 others
    cooperated last round), otherwise always defects.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        m = self.game_description.m
        if history is None:
            P = 0
        else:
            last = history.round_number - 1
            P = int(history.opponent_actions[last].sum())
        if P == m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_23(BaseStrategy):
    """
    Aggressive free-rider + rescue strategy for the r-round collective-risk dilemma.
    - Always defects on round 1 and the last round.
    - Tracks each opponent’s cooperation rate over a window W.
    - If at least m opponents are “likely cooperators” (≥φ in last W), then defect to free-ride.
    - If exactly m-1 likely cooperators, rescue is still available, and we are ≥buffer rounds from the end,
      cooperate once and consume the rescue.
    - Otherwise defect.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.n_rounds = game_description.n_rounds
        self.m = game_description.m
        self.rescue_available = True
        self.W = min(self.n_rounds, 5)
        self.phi = 0.6
        self.buffer = 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t == self.n_rounds:
            return Action.D
        rounds_played = history.round_number
        win = min(self.W, rounds_played)
        if win == 0:
            return Action.D
        E = 0
        opp_actions = history.opponent_actions
        n_opponents = opp_actions.shape[1]
        for j in range(n_opponents):
            recent = opp_actions[rounds_played - win:rounds_played, j]
            frac = recent.sum() / win
            if frac >= self.phi:
                E += 1
        if E >= self.m:
            return Action.D
        elif E == self.m - 1 and self.rescue_available and (t <= self.n_rounds - self.buffer):
            self.rescue_available = False
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_24(BaseStrategy):
    """
    Last-Ditch Pivotal Exploiter: defect every round until the final round,
    where it cooperates only if exactly m-1 opponents cooperated in the
    previous round, ensuring pivotality.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        completed = history.round_number
        r = self.game_description.n_rounds
        m = self.game_description.m
        if completed < r - 1:
            return Action.D
        prev_round_actions = history.opponent_actions[completed - 1]
        coop_prev = int(prev_round_actions.sum())
        if coop_prev == m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_25(BaseStrategy):
    """
    Cutthroat Free-rider with Occasional Deception.

    Defaults to defect; in early rounds it “hooks” others by cooperating
    with a small probability (p_hook), then decays that probability
    after each successful free-ride (when threshold met and it defected).
    Always defects in the final round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.p_hook = 0.1
        self.alpha_decay = 0.5
        self.p = self.p_hook

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            if random.random() < self.p:
                return Action.C
            else:
                return Action.D
        last_idx = history.round_number - 1
        if last_idx >= 0:
            our_last = history.my_actions[last_idx]
            opp_last = history.opponent_actions[last_idx]
            total_coops = int(our_last) + int(sum(opp_last))
            if total_coops >= self.game_description.m and (not our_last):
                self.p *= self.alpha_decay
        t = history.round_number + 1
        if t == self.game_description.n_rounds:
            return Action.D
        if random.random() < self.p:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_26(BaseStrategy):
    """
    Lone Kingmaker strategy for the Collective Risk Dilemma.
    - Round 1 and last round: always defect.
    - In intermediate rounds, count total cooperators in the previous round.
      If exactly m-1 cooperators, cooperate (you are pivotal).
      Otherwise defect.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        completed = history.round_number
        current_round = completed + 1
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            return Action.D
        prev_idx = completed - 1
        my_prev = history.my_actions[prev_idx]
        opp_prev = history.opponent_actions[prev_idx]
        coop_count = int(my_prev) + int(opp_prev.sum())
        if coop_count == self.game_description.m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_27(BaseStrategy):
    """
    Aggressive Minimal Cover + Grim Punish:
    Defect by default, only cooperate when your single contribution
    is needed to meet the threshold. If a round fails badly
    (even with you it can't meet m), switch to permanent defection.
    Always defect in the final round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punish_mode = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        completed = history.round_number
        t = completed + 1
        r = self.game_description.n_rounds
        m = self.game_description.m
        if t == r:
            return Action.D
        if self.punish_mode:
            return Action.D
        if t == 1:
            return Action.D
        last_idx = completed - 1
        coop_others_last = int(history.opponent_actions[last_idx].sum())
        if coop_others_last < m - 1:
            self.punish_mode = True
            return Action.D
        if coop_others_last == m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_28(BaseStrategy):
    """
    Minimal-Contribution + Punishment strategy:
    - Defects on first and last rounds.
    - In middle rounds, cooperates only if your vote is the swing vote (others cooperators == m-1),
      defects if others already meet threshold or cannot meet threshold even with you.
    - If ever you cooperate and the group still fails to reach m, switch to permanent defection.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.broken = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is not None and (not self.broken):
            last_idx = history.round_number - 1
            if history.my_actions[last_idx]:
                coop_others_last = sum(history.opponent_actions[last_idx])
                total_coops_last = coop_others_last + 1
                if total_coops_last < self.game_description.m:
                    self.broken = True
        if history is None:
            t = 1
        else:
            t = history.round_number + 1
        if self.broken or t == 1 or t == self.game_description.n_rounds:
            return Action.D
        prev_idx = t - 2
        coop_others = sum(history.opponent_actions[prev_idx])
        m = self.game_description.m
        if coop_others >= m:
            return Action.D
        elif coop_others == m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_29(BaseStrategy):
    """
    Aggressive Free-Rider:
    Always defect except with tiny probability ε in non-final rounds
    to inoculate against punishment. On the last round, defect with certainty.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.epsilon = 0.03

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
        else:
            t = history.round_number + 1
        if t == self.game_description.n_rounds:
            return Action.D
        if random.random() < self.epsilon:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_30(BaseStrategy):
    """
    Aggressive Exploit-and-Punish strategy for the repeated Collective Risk Dilemma.
    Defects by default, only cooperates when pivotal, never in final round,
    and grim-triggers defect forever if betrayed after a pivotal cooperate.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punished = False
        self.punishRoundsLeft = 0
        r = game_description.n_rounds
        self.P = int(min(3, r / 2))

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
            coopPrevOthers = 0
        else:
            prev_rounds = history.round_number
            last_ops = history.opponent_actions[prev_rounds - 1]
            coopPrevOthersLast = int(last_ops.sum())
            my_last = history.my_actions[prev_rounds - 1]
            thresholdReached = coopPrevOthersLast + (1 if my_last else 0) >= self.game_description.m
            if coopPrevOthersLast == self.game_description.m - 1 and my_last and (not thresholdReached):
                self.punished = True
            t = prev_rounds + 1
            coopPrevOthers = coopPrevOthersLast
        if t == self.game_description.n_rounds:
            return Action.D
        if self.punished:
            return Action.D
        if self.punishRoundsLeft > 0:
            self.punishRoundsLeft -= 1
            return Action.D
        m = self.game_description.m
        if coopPrevOthers >= m:
            return Action.D
        if coopPrevOthers == m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_31(BaseStrategy):
    """
    Selective Exploiter:
    Defects on the first and last rounds and in all intermediate rounds
    except when your single cooperation can pivot the group payoffs from failure
    to success (i.e., when exactly m-1 opponents cooperated in the previous round).
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t == self.game_description.n_rounds:
            return Action.D
        last_idx = history.round_number - 1
        opponent_coops = int(history.opponent_actions[last_idx].sum())
        if opponent_coops == self.game_description.m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_32(BaseStrategy):
    """
    Aggressive‐exploiter strategy for the repeated collective‐risk dilemma.
    Defects in the first round to probe, free‐rides whenever others met the threshold,
    cooperates only when pivotal (others == m–1), triggers a permanent grim‐defect
    once exploited, and in the last round applies only the rescue/defect logic.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punish_mode = False
        self.last_coop_count = None

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        prev_idx = history.round_number - 1
        self.last_coop_count = int(history.opponent_actions[prev_idx].sum())
        m = self.game_description.m
        r = self.game_description.n_rounds
        if self.punish_mode:
            return Action.D
        if t == r:
            if self.last_coop_count >= m:
                return Action.D
            elif self.last_coop_count == m - 1:
                return Action.C
            else:
                return Action.D
        if self.last_coop_count >= m:
            self.punish_mode = True
            return Action.D
        elif self.last_coop_count == m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_33(BaseStrategy):
    """
    Threshold-Reciprocity:
    - Start by cooperating.
    - If the community threshold was met in the previous round, cooperate.
    - If the threshold failed, defect this round and schedule one more defection.
    - After a scheduled defection, reset and resume cooperation.
    - Always cooperate on the final round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punishNext = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        completed = history.round_number
        t = completed + 1
        if t == self.game_description.n_rounds:
            return Action.C
        if self.punishNext:
            self.punishNext = False
            return Action.D
        my_last = history.my_actions[-1]
        opp_last = history.opponent_actions[-1].sum()
        coop_count = int(my_last) + int(opp_last)
        if coop_count < self.game_description.m:
            self.punishNext = True
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_34(BaseStrategy):
    """
    Drives the group to exactly m cooperators each round with finite punishment.
    Cooperates initially, punishes any failure to reach threshold for P=2 rounds,
    trims excess cooperators, holds exact-m cooperators, and defects in the last P rounds.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punish_counter = 0
        self.P = 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        r = self.game_description.n_rounds
        m = self.game_description.m
        P = self.P
        if t > r - P:
            return Action.D
        if self.punish_counter > 0:
            self.punish_counter -= 1
            return Action.D
        last_idx = history.round_number - 1
        coop_opp = int(history.opponent_actions[last_idx].sum())
        coop_me = 1 if history.my_actions[last_idx] else 0
        c_prev = coop_opp + coop_me
        if c_prev < m:
            self.punish_counter = P
            return Action.D
        if c_prev > m:
            return Action.D
        if history.my_actions[last_idx]:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_35(BaseStrategy):
    """
    Generous Threshold–TFT (GT‐TFT):
    Start by cooperating. Thereafter, if the group met the threshold last round, cooperate.
    If they failed last round, defect exactly one round to punish, then forgive (cooperate) once,
    and then resume cooperation if the threshold is met again.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.m = game_description.m
        self.punish_timer = 0
        self.last_success = True

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        last_idx = history.round_number - 1
        coop_count = int(history.my_actions[last_idx]) + int(history.opponent_actions[last_idx].sum())
        self.last_success = coop_count >= self.m
        if self.punish_timer > 0:
            action = Action.C
            self.punish_timer = 0
        elif self.last_success:
            action = Action.C
        else:
            action = Action.D
            self.punish_timer = 1
        return action

class Strategy_COOPERATIVE_36(BaseStrategy):
    """
    Conditional cooperation with short punishment and end‐game defection.
    Reward group success (≥m cooperators), punish failure by defecting for L rounds,
    then forgive. Always defect in the final round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds
        self.m = game_description.m
        self.L = 2
        self.pun_counter = 0
        self.last_C_count = self.m

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is not None and history.round_number > 0:
            last_idx = history.round_number - 1
            own_last = history.my_actions[last_idx]
            opp_last = history.opponent_actions[last_idx].sum()
            self.last_C_count = int(own_last) + int(opp_last)
        if history is None:
            t = 1
        else:
            t = history.round_number + 1
        if t == self.n_rounds:
            action = Action.D
        elif self.pun_counter > 0:
            action = Action.D
            self.pun_counter -= 1
        elif t == 1:
            action = Action.C
        elif self.last_C_count >= self.m:
            action = Action.C
        else:
            action = Action.D
            self.pun_counter = self.L
        return action

class Strategy_COOPERATIVE_37(BaseStrategy):
    """
    Trigger‐and‐forgive strategy for the Collective Risk Dilemma.
    Starts by cooperating, punishes any defection with a short defection phase,
    forgives quickly, and defects in the last round.
    """
    PUNISH_LENGTH = 1

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punishing_until = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        r = self.game_description.n_rounds
        if t == r:
            return Action.D
        if t <= self.punishing_until:
            return Action.D
        last_idx = history.round_number - 1
        coopers = int(history.my_actions[last_idx])
        coopers += int(history.opponent_actions[last_idx].sum())
        if coopers == self.game_description.n_players:
            return Action.C
        else:
            self.punishing_until = t + self.PUNISH_LENGTH
            return Action.D

class Strategy_COOPERATIVE_38(BaseStrategy):
    """
    Lenient Threshold Reciprocal (LTR) strategy for the Collective Risk Dilemma.
    - Start by cooperating.
    - If last round met the threshold (>= m cooperators), cooperate next round.
    - If last round failed, forgive up to f consecutive failures by still cooperating.
      After f+1 failures in a row, defect once as punishment.
    - No special end‐game behavior; treat all rounds uniformly.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.f = 1
        self.failures_in_a_row = 0
        self.last_round_success = True

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.failures_in_a_row = 0
            self.last_round_success = True
            return Action.C
        last_my_action = history.my_actions[-1]
        last_op_actions = history.opponent_actions[-1]
        total_cooperators = int(last_my_action) + int(last_op_actions.sum())
        if total_cooperators >= self.game_description.m:
            self.last_round_success = True
        else:
            self.last_round_success = False
        if self.last_round_success:
            self.failures_in_a_row = 0
            return Action.C
        else:
            self.failures_in_a_row += 1
            if self.failures_in_a_row <= self.f:
                return Action.C
            else:
                return Action.D

class Strategy_COOPERATIVE_39(BaseStrategy):
    """
    Forgiving‐Grim-Trigger strategy for the Collective Risk Dilemma.
    - Start by cooperating (round 1).
    - On any non-last round, if in a punishment phase, defect and decrement the counter.
    - Otherwise, if the previous round had fewer than m cooperators (including self), defect and set one-round punishment.
    - Else cooperate.
    - Always defect in the last round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punish_remaining = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        m = self.game_description.m
        if t == n_rounds:
            return Action.D
        if self.punish_remaining > 0:
            self.punish_remaining -= 1
            return Action.D
        prev_round_idx = history.round_number - 1
        coop_others = int(history.opponent_actions[prev_round_idx].sum())
        own_prev = int(history.my_actions[-1])
        coop_prev = coop_others + own_prev
        if coop_prev < m:
            self.punish_remaining = 1
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_40(BaseStrategy):
    """
    Threshold-Conditional Cooperator with One-Off Forgiveness.

    - Round 1: Cooperate to signal willingness.
    - Rounds 2 to r-1: Cooperate if the number of cooperators
      in the previous round was at least m-1; otherwise defect.
    - Round r (last round): Defect unconditionally.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        r = self.game_description.n_rounds
        m = self.game_description.m
        if t == r:
            return Action.D
        prev_idx = history.round_number - 1
        opp_coops = int(history.opponent_actions[prev_idx].sum())
        my_last = int(history.my_actions[prev_idx])
        total_coops = opp_coops + my_last
        if total_coops >= m or total_coops == m - 1:
            return Action.C
        return Action.D

class Strategy_COOPERATIVE_41(BaseStrategy):
    """
    Group-Tit-for-Tat with Forgiveness strategy for the Collective Risk Dilemma.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punish_streak = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        rounds_played = history.round_number
        t = rounds_played + 1
        n_rounds = self.game_description.n_rounds
        m = self.game_description.m
        prev_idx = rounds_played - 1
        if rounds_played >= 1:
            coop_prev = int(history.my_actions[prev_idx]) + int(np.sum(history.opponent_actions[prev_idx]))
        else:
            coop_prev = 0
        action = Action.C
        if t > 1:
            if coop_prev >= m:
                self.punish_streak = 0
                action = Action.C
            else:
                self.punish_streak += 1
                if self.punish_streak == 1:
                    action = Action.D
                else:
                    self.punish_streak = 0
                    action = Action.C
        if t == n_rounds:
            if rounds_played >= 1 and coop_prev >= m:
                action = Action.C
            else:
                action = Action.D
        return action

class Strategy_COOPERATIVE_42(BaseStrategy):
    """
    Generous Threshold Pavlov:
    - Start cooperating.
    - If last round met threshold, keep cooperating.
    - If it failed, defect next round and then forgive.
    - Always cooperate in the final round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.last_success = True
        self.punish_remaining = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == self.game_description.n_rounds:
            action = Action.C
        elif self.punish_remaining == 1:
            action = Action.D
            self.punish_remaining = 0
        elif self.last_success:
            action = Action.C
        else:
            action = Action.D
            self.punish_remaining = 1
        prev_idx = history.round_number - 1
        total_cooperators = int(history.my_actions[prev_idx]) + int(history.opponent_actions[prev_idx].sum())
        self.last_success = total_cooperators >= self.game_description.m
        return action

class Strategy_COOPERATIVE_43(BaseStrategy):
    """
    Conditional cooperator:
    - Start in COOP state, punish for one round if threshold fails,
      then return to COOP. Always cooperate in the last round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.state = 'COOP'
        self.punish_timer = 0
        self.P = 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        completed = history.round_number
        next_round = completed + 1
        n_rounds = self.game_description.n_rounds
        m = self.game_description.m
        if completed >= 1:
            last_idx = completed - 1
            coop_self = 1 if history.my_actions[last_idx] else 0
            coop_others = int(history.opponent_actions[last_idx].sum())
            coop_count = coop_self + coop_others
            if self.state == 'COOP':
                if coop_count < m:
                    self.state = 'PUNISH'
                    self.punish_timer = self.P
            else:
                self.punish_timer -= 1
                if self.punish_timer <= 0:
                    self.state = 'COOP'
        if next_round == n_rounds:
            return Action.C
        if self.state == 'COOP':
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_44(BaseStrategy):
    """
    Limited grudger strategy for the Collective Risk Dilemma.
    
    - Always cooperate in the first round to signal willingness.
    - If the last round reached the cooperation threshold, cooperate.
    - If the last round failed the threshold, defect exactly one round as punishment.
    - Immediately forgive after one round of punishment by resuming cooperation.
    - Always cooperate in the final round to maximize group payoff.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.lastThresholdMet = True
        self.punCounter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        m = self.game_description.m
        if t == n_rounds:
            action = Action.C
        elif self.punCounter > 0:
            action = Action.D
            self.punCounter -= 1
        elif self.lastThresholdMet:
            action = Action.C
        else:
            action = Action.D
            self.punCounter = 1
        last_idx = history.round_number - 1
        coop_opponents = int(history.opponent_actions[last_idx].sum())
        coop_self = int(history.my_actions[last_idx])
        total_cooperators = coop_self + coop_opponents
        self.lastThresholdMet = total_cooperators >= m
        return action

class Strategy_COOPERATIVE_46(BaseStrategy):
    """
    Reciprocal Threshold strategy for the Collective Risk Dilemma.
    Starts by cooperating. In intermediate rounds it cooperates
    if the previous round succeeded (>= m cooperators), otherwise
    defects one round as punishment then forgives. In the last round
    it defects unless its cooperation is pivotal (previous cooperators == m-1).
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.last_count = game_description.n_players
        self.punish_flag = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        m = self.game_description.m
        r = self.game_description.n_rounds
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        last_idx = history.round_number - 1
        my_last = history.my_actions[last_idx]
        opp_last = history.opponent_actions[last_idx]
        coop_count = int(my_last) + int(opp_last.sum())
        self.last_count = coop_count
        if current_round == r:
            if self.last_count == m - 1:
                return Action.C
            else:
                return Action.D
        if self.punish_flag:
            self.punish_flag = False
            return Action.D
        if self.last_count >= m:
            return Action.C
        else:
            self.punish_flag = True
            return Action.D

class Strategy_COOPERATIVE_47(BaseStrategy):
    """
    Grim–Trigger with Final Defection: cooperate each round until any player defects,
    then defect forever (through round r-1), and always defect in the final round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punished = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        r = self.game_description.n_rounds
        if t == r:
            return Action.D
        if self.punished:
            return Action.D
        if t == 1:
            return Action.C
        all_my_coop = bool(history.my_actions.all())
        all_opp_coop = bool(history.opponent_actions.all())
        if not (all_my_coop and all_opp_coop):
            self.punished = True
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_48(BaseStrategy):
    """
    Threshold Guardian:
    - Cooperate initially.
    - If last round met threshold and you cooperated, keep cooperating.
    - If group failed last round, punish by defecting exactly one round.
    - Forgive immediately (return to cooperation unless other rules apply).
    - In the last round, cooperate only if success rate so far ≥ θ.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punish_flag = False
        self.punish_timer = 0
        self.theta = 0.8

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        desc = self.game_description
        n_rounds = desc.n_rounds
        m = desc.m
        completed = history.round_number
        success_count = 0
        for t in range(completed):
            coopers = (1 if history.my_actions[t] else 0) + sum(history.opponent_actions[t])
            if coopers >= m:
                success_count += 1
        if completed == n_rounds - 1:
            if success_count >= self.theta * (n_rounds - 1):
                return Action.C
            else:
                return Action.D
        last_my = history.my_actions[-1]
        coopers_last = (1 if last_my else 0) + sum(history.opponent_actions[-1])
        success_last = coopers_last >= m
        if self.punish_flag:
            action = Action.D
            self.punish_timer -= 1
            if self.punish_timer <= 0:
                self.punish_flag = False
            return action
        if success_last and last_my:
            return Action.C
        if not success_last:
            self.punish_flag = True
            self.punish_timer = 1
            return Action.D
        return Action.D

class Strategy_COOPERATIVE_49(BaseStrategy):
    """
    Generous Collective Tit‐for‐Tat for the n‐player threshold public‐goods game.
    Cooperates in round 1, defects in the last round, and in intermediate rounds:
    if punishing is True (one‐round forgiveness) then cooperate and reset punishing;
    else if the previous round had fewer than m cooperators then defect and set punishing;
    otherwise cooperate.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.prev_coops = game_description.n_players
        self.punishing = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        m = self.game_description.m
        if t == n_rounds:
            action = Action.D
        elif self.punishing:
            action = Action.C
            self.punishing = False
        elif self.prev_coops < m:
            action = Action.D
            self.punishing = True
        else:
            action = Action.C
        last_idx = history.round_number - 1
        coop_count = int(history.my_actions[last_idx]) + int(np.sum(history.opponent_actions[last_idx]))
        self.prev_coops = coop_count
        return action

class Strategy_COOPERATIVE_50(BaseStrategy):
    """
    Threshold‐reciprocal strategy for the Collective Risk Dilemma.
    Starts by cooperating. Thereafter, if in a 1‐round punishment phase, defects and exits punishment.
    Otherwise inspects how many cooperated last round:
      - If ≥ m or == m-1, cooperates.
      - If ≤ m-2, defects and enters a 1‐round punishment phase.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punish_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if self.punish_counter > 0:
            self.punish_counter -= 1
            return Action.D
        last_idx = history.round_number - 1
        opp_coops = int(history.opponent_actions[last_idx].sum())
        self_coop = 1 if history.my_actions[last_idx] else 0
        last_coops = opp_coops + self_coop
        m = self.game_description.m
        if last_coops >= m or last_coops == m - 1:
            return Action.C
        else:
            self.punish_counter = 1
            return Action.D

class Strategy_COOPERATIVE_51(BaseStrategy):
    """
    Threshold-reciprocity strategy for the Collective Risk Dilemma.
    Cooperate by default, defect in the last round, punish a failed round
    with one defection, then forgive.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds
        self.m = game_description.m
        self.retaliation_counter = 0
        self.last_round_success = None

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        completed = history.round_number
        t = completed + 1
        if t == self.n_rounds:
            return Action.D
        if self.retaliation_counter > 0:
            self.retaliation_counter -= 1
            return Action.D
        idx = completed - 1
        opp_coops = int(history.opponent_actions[idx].sum())
        my_coop = 1 if history.my_actions[idx] else 0
        S = opp_coops + my_coop
        self.last_round_success = S >= self.m
        if S < self.m:
            self.retaliation_counter = 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_52(BaseStrategy):
    """
    Cooperative trigger with one‐round punishment and immediate forgiveness.
    Starts by cooperating, punishes a failed threshold once by defecting,
    then forgives and returns to cooperation. Keeps cooperating after any
    successful round to sustain contributions.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punished_last_round = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punished_last_round = False
            return Action.C
        last_round_index = history.round_number - 1
        opp_coops = history.opponent_actions[last_round_index].sum()
        my_last = history.my_actions[last_round_index]
        total_cooperators = int(my_last) + int(opp_coops)
        if total_cooperators >= self.game_description.m:
            self.punished_last_round = False
            return Action.C
        elif not self.punished_last_round:
            self.punished_last_round = True
            return Action.D
        else:
            self.punished_last_round = False
            return Action.C

class Strategy_COOPERATIVE_53(BaseStrategy):
    """
    Win-Stay/Lose-Shift with One-Round Punishment.
    Cooperate if the threshold was met last round, defect once to punish on failure,
    then forgive immediately, with a last-round safety check.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.success = True
        self.punish_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        prev_idx = history.round_number - 1
        total_coop = int(history.my_actions[prev_idx]) + int(history.opponent_actions[prev_idx].sum())
        self.success = total_coop >= self.game_description.m
        if self.punish_counter > 0:
            action = Action.D
            self.punish_counter -= 1
        elif self.success:
            action = Action.C
        else:
            action = Action.D
            self.punish_counter = 1
        if t == self.game_description.n_rounds and (not self.success):
            action = Action.D
        return action

class Strategy_COOPERATIVE_54(BaseStrategy):
    """
    Threshold–Tit-for-Tat with Forgiveness (TTF-F):
    - Start by cooperating.
    - If last round met threshold (>= m cooperators), cooperate.
    - If group failed (< m), defect one round as punishment, then forgive.
    - Defect in the final round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.last_coops = game_description.m
        self.punishing = False
        self.punish_count = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
        else:
            last_idx = history.round_number - 1
            coop_me = history.my_actions[last_idx]
            coop_others = history.opponent_actions[last_idx].sum()
            self.last_coops = int(coop_me) + int(coop_others)
            t = history.round_number + 1
        if t == self.game_description.n_rounds:
            return Action.D
        if t == 1:
            self.punishing = False
            self.punish_count = 0
            return Action.C
        if self.punishing:
            action = Action.D
            self.punish_count += 1
            if self.punish_count >= 1:
                self.punishing = False
                self.punish_count = 0
        elif self.last_coops >= self.game_description.m:
            action = Action.C
        else:
            action = Action.D
            self.punishing = True
            self.punish_count = 0
        return action

class Strategy_COOPERATIVE_55(BaseStrategy):
    """
    Rotating-cooperators with grim-trigger:
    In each round t exactly m players (a rotating set) cooperate.
    If ever fewer than m cooperated, switch to permanent defection.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.punish = False
        self.player_index = getattr(game_description, 'player_index', 1)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is not None and (not self.punish):
            t_completed = history.round_number
            last = t_completed - 1
            opp_coop = int(history.opponent_actions[last].sum())
            my_coop = int(history.my_actions[last])
            if opp_coop + my_coop < self.m:
                self.punish = True
        if self.punish:
            return Action.D
        t = 1 if history is None else history.round_number + 1
        offset = (t - 1) * self.m % self.n
        S_t = {(offset + j) % self.n + 1 for j in range(self.m)}
        if self.player_index in S_t:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_56(BaseStrategy):
    """
    Generous Threshold Tit-for-Tat (GTFT) for the Collective Risk Dilemma.
    - Round 1: Cooperate.
    - Rounds 2…r-1:
        * If previous cooperators ≥ m: Cooperate.
        * Else if exactly one defector last round: Defect.
        * Else: Cooperate.
    - Round r: Cooperate.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if t == total_rounds:
            return Action.C
        idx = history.round_number - 1
        coop_self = history.my_actions[idx]
        coop_opponents = int(history.opponent_actions[idx].sum())
        C_prev = (1 if coop_self else 0) + coop_opponents
        if C_prev >= self.game_description.m:
            return Action.C
        D_prev = self.game_description.n_players - C_prev
        if D_prev == 1:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_57(BaseStrategy):
    """
    Reciprocal Threshold with One-Round Punishment.

    We maintain state ∈ {"Cooperate", "Punish"}. Start in "Cooperate" with last_count = n.
    Each round:
      - Update state based on last round’s total cooperators H:
          if H ≥ m: state ← "Cooperate"
          else:
            if state == "Cooperate": state ← "Punish"
            else: state ← "Cooperate"
      - Then play: C if state == "Cooperate", else D.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.state = 'Cooperate'
        self.last_count = game_description.n_players

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        last_round = history.round_number - 1
        opp_coops = int(history.opponent_actions[last_round].sum())
        my_coop = int(history.my_actions[last_round])
        H = opp_coops + my_coop
        m = self.game_description.m
        if H >= m:
            self.state = 'Cooperate'
        elif self.state == 'Cooperate':
            self.state = 'Punish'
        else:
            self.state = 'Cooperate'
        self.last_count = H
        if self.state == 'Cooperate':
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_58(BaseStrategy):
    """
    Collective Tit-for-Tat with One-Round Punishment for the
    repeated Collective Risk Dilemma. Starts cooperating, punishes
    any round the threshold was missed by a single defection,
    forgives immediately, and defects in the final round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.prev_threshold_met = True
        self.punishment_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        m = self.game_description.m
        if current_round == n_rounds:
            action = Action.D
        elif self.punishment_counter > 0:
            action = Action.D
            self.punishment_counter -= 1
        elif not self.prev_threshold_met:
            action = Action.D
            self.punishment_counter = 0
        else:
            action = Action.C
        last_idx = history.round_number - 1
        opp_coops = int(history.opponent_actions[last_idx].sum())
        my_coop = int(history.my_actions[last_idx])
        coop_count = opp_coops + my_coop
        self.prev_threshold_met = coop_count >= m
        return action

class Strategy_COOPERATIVE_59(BaseStrategy):
    """
    P4F (Propose–Punish–Forgive–Persist) strategy for the Collective Risk Dilemma.
    - Always cooperates first.
    - If the threshold m was not met last round, cooperates (resets punishment).
    - If threshold met unanimously last round, cooperates.
    - If threshold met but some defected, defects once to punish, then forgives.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punished_since_success = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        last_round = history.round_number - 1
        my_last = history.my_actions[last_round]
        opp_last = history.opponent_actions[last_round].sum()
        total_cooperators = (1 if my_last else 0) + int(opp_last)
        m = self.game_description.m
        n = self.game_description.n_players
        last_success = total_cooperators >= m
        last_full_coop = total_cooperators == n
        if not last_success:
            action = Action.C
            self.punished_since_success = False
        elif last_full_coop:
            action = Action.C
            self.punished_since_success = False
        elif not self.punished_since_success:
            action = Action.D
            self.punished_since_success = True
        else:
            action = Action.C
            self.punished_since_success = False
        return action

class Strategy_COOPERATIVE_60(BaseStrategy):
    """
    Generous Threshold‐Triggered Cooperator (GTTC):
    - Start by cooperating to signal willingness.
    - In each nonterminal round, cooperate if last round met the threshold;
      otherwise defect for one round as punishment, then forgive.
    - In the final round, defect unconditionally to capture private gain.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punishing = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        m = self.game_description.m
        if t == total_rounds:
            return Action.D
        if self.punishing:
            self.punishing = False
            return Action.D
        last_idx = history.round_number - 1
        coop_self = 1 if history.my_actions[last_idx] else 0
        coop_others = int(history.opponent_actions[last_idx].sum())
        coop_count_prev = coop_self + coop_others
        if coop_count_prev >= m:
            return Action.C
        else:
            self.punishing = True
            return Action.D

class Strategy_COOPERATIVE_61(BaseStrategy):
    """
    Threshold tit-for-tat with one-round forgiveness:
    - Round 1: Cooperate to signal willingness.
    - Rounds 2…r-1:
        • If in punishment mode (punish_flag), defect this round and clear punish_flag.
        • Else, if last round’s total cooperators ≥ m, cooperate; otherwise defect and set punish_flag for next round.
    - Round r: Defect (end‐game unraveling).
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        super().__init__(game_description)
        self.game_description = game_description
        self.m = game_description.m
        self.r = game_description.n_rounds
        self.punish_flag = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        completed = history.round_number
        current_round = completed + 1
        if current_round == self.r:
            return Action.D
        if self.punish_flag:
            self.punish_flag = False
            return Action.D
        last_idx = completed - 1
        coop_self = int(history.my_actions[last_idx])
        coop_others = int(history.opponent_actions[last_idx].sum())
        total_cooperators = coop_self + coop_others
        if total_cooperators >= self.m:
            return Action.C
        else:
            self.punish_flag = True
            return Action.D

class Strategy_COOPERATIVE_62(BaseStrategy):
    """
    Grim-trigger strategy for the Collective Risk Dilemma.
    Cooperate in every round unless any opponent has ever defected,
    in which case defect forever.  Additionally defect in the last
    round to grab the private payoff (since m < n ensures the
    threshold is still met).
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punish = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        last_idx = history.round_number - 1
        if not self.punish:
            if not history.opponent_actions[last_idx].all():
                self.punish = True
        if self.punish:
            return Action.D
        upcoming_round = history.round_number + 1
        if upcoming_round == self.game_description.n_rounds:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_63(BaseStrategy):
    """
    Conditional cooperator with one‐round group punishment:
    • Cooperate on the first round.
    • If the last round met the threshold (≥ m cooperators), cooperate.
    • If the last round failed (< m), defect this round and set a one‐round punishment flag.
    • If punish_flag is set, defect and clear the flag.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punish_flag = False
        self.last_coop_count = None

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        prev_idx = history.round_number - 1
        coopers = int(history.my_actions[prev_idx]) + int(history.opponent_actions[prev_idx].sum())
        self.last_coop_count = coopers
        if self.punish_flag:
            action = Action.D
            self.punish_flag = False
        elif self.last_coop_count >= self.game_description.m:
            action = Action.C
        else:
            action = Action.D
            self.punish_flag = True
        return action

class Strategy_COOPERATIVE_64(BaseStrategy):
    """
    Generous Threshold Tit-for-Tat (GTTFT):
    Start with cooperation, reward collective success with cooperation next round,
    punish a threshold failure by defecting one round, but remain forgiving with
    small-probability cooperation to re-establish cooperation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.epsilon = 0.1
        self.prev_success = True
        self.punish_round = False
        self.last_round_processed = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        rounds_done = history.round_number
        for idx in range(self.last_round_processed, rounds_done):
            c_self = 1 if history.my_actions[idx] else 0
            c_opp = int(sum(history.opponent_actions[idx]))
            cooperators = c_self + c_opp
            if cooperators >= self.game_description.m:
                self.prev_success = True
            else:
                self.prev_success = False
                if not self.punish_round:
                    self.punish_round = True
        self.last_round_processed = rounds_done
        if self.punish_round:
            action = Action.D
            self.punish_round = False
        elif self.prev_success:
            action = Action.C
        elif random.random() < self.epsilon:
            action = Action.C
        else:
            action = Action.D
        return action

class Strategy_AGGRESSIVE_33(BaseStrategy):
    """
    Pivotal Free‐Rider (PFR) strategy:
    - Round 1: Always defect.
    - Rounds 2..r-1: Cooperate only if exactly m-1 others cooperated last round;
      otherwise defect. This ensures you only contribute when pivotal.
    - Round r: Always defect.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        r = self.game_description.n_rounds
        m = self.game_description.m
        if t == r:
            return Action.D
        last_index = history.round_number - 1
        C_minus_prev = int(history.opponent_actions[last_index].sum())
        if C_minus_prev >= m:
            return Action.D
        elif C_minus_prev == m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_34(BaseStrategy):
    """
    Aggressive Opportunist: defect in all rounds except when your single contribution
    in an intermediate round (not first, not last) will raise the total cooperators
    from m-1 to m, thus earning you the extra reward k. 
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        r = self.game_description.n_rounds
        m = self.game_description.m
        if t == r:
            return Action.D
        last_idx = history.round_number - 1
        prev_opponent_coops = int(history.opponent_actions[last_idx].sum())
        prev_my_coop = 1 if history.my_actions[last_idx] else 0
        prev_coop = prev_opponent_coops + prev_my_coop
        if prev_coop == m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_35(BaseStrategy):
    """
    Aggressive Opportunistic‐Pivot strategy for the Collective Risk Dilemma.
    Defect by default, but cooperate exactly when the previous round’s count
    of other cooperators equals m-1 (making you the pivotal cooperator).
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        past_rounds = history.round_number
        last_coop_count = int(history.opponent_actions[past_rounds - 1].sum())
        if last_coop_count == self.game_description.m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_36(BaseStrategy):
    """
    Last-Chance Free-Rider:
    Defect in all rounds except the last. In the final round, cooperate only if
    without your contribution the number of cooperators would fall below the threshold m
    (i.e., you are pivotal).
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        completed = history.round_number
        current_round = completed + 1
        total_rounds = self.game_description.n_rounds
        if current_round < total_rounds:
            return Action.D
        if completed > 0:
            last_idx = completed - 1
            others_coop = int(history.opponent_actions[last_idx].sum())
        else:
            others_coop = 0
        m = self.game_description.m
        if others_coop >= m:
            return Action.D
        if others_coop == m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_37(BaseStrategy):
    """
    Alpha free‐rider strategy: Defect on the first round. In each subsequent round,
    count how many opponents cooperated in the last round. If that count is at least m,
    defect (free‐ride). If it equals m−1, cooperate (you’re pivotal). Otherwise defect.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        last_index = history.round_number - 1
        others_coop = history.opponent_actions[last_index].sum()
        m = self.game_description.m
        if others_coop >= m:
            return Action.D
        if others_coop == m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_38(BaseStrategy):
    """
    Threshold-Exploiter: only cooperates if you alone can tip the scale from failure to success
    (i.e., exactly m-1 others cooperated last round and k>1). Otherwise always defects.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t_completed = history.round_number
        if t_completed == 0:
            return Action.D
        prev_idx = t_completed - 1
        cooperators = int(history.opponent_actions[prev_idx].sum())
        if cooperators >= self.m:
            return Action.D
        if cooperators <= self.m - 2:
            return Action.D
        if cooperators == self.m - 1:
            if self.k > 1:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_39(BaseStrategy):
    """
    Aggressive threshold-opportunist strategy for the Collective Risk Dilemma.
    Defects by default; cooperates only when your single contribution
    in the next round will exactly meet the threshold (m).
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        last_round = history.round_number - 1
        opp_coops = int(history.opponent_actions[last_round].sum())
        if opp_coops == self.game_description.m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_40(BaseStrategy):
    """
    Aggressive threshold-public-goods strategy:
    - Always defect in the first round (probe) and the last round (no future leverage).
    - In intermediate rounds, cooperate if and only if exactly m-1 players cooperated in the previous round;
      otherwise defect.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        r = self.game_description.n_rounds
        m = self.game_description.m
        if t == r:
            return Action.D
        prev_idx = t - 2
        opp_coop = int(history.opponent_actions[prev_idx].sum())
        self_coop = int(history.my_actions[prev_idx])
        total_last_C = opp_coop + self_coop
        if total_last_C == m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_41(BaseStrategy):
    """
    Aggressive‐pivot strategy for the Collective Risk Dilemma.
    Defects in the first and last rounds. In intermediate rounds,
    cooperates only if exactly m−1 opponents cooperated in the
    previous round (i.e., you are pivotal), otherwise defects.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t == self.game_description.n_rounds:
            return Action.D
        prev_idx = history.round_number - 1
        coop_others = int(history.opponent_actions[prev_idx].sum())
        if coop_others == self.game_description.m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_42(BaseStrategy):
    """
    Aggressive threshold‐exploiter:
    Defects in the first and last two rounds.
    In intermediate rounds, cooperates only if its single contribution is
    strictly necessary to meet the threshold (i.e., opponents cooperated m−1
    times last round), otherwise defects.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        r = self.game_description.n_rounds
        if t >= r - 1:
            return Action.D
        prev_idx = history.round_number - 1
        coops_others = int(history.opponent_actions[prev_idx].sum())
        if coops_others == self.game_description.m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_43(BaseStrategy):
    """
    Aggressive threshold–public–goods strategy:
    - Round 1: defect
    - Rounds 2…r−1: cooperate only if you are the pivotal (m'th) cooperator in the previous round
    - Round r: always defect
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        threshold = self.game_description.m
        if current_round == total_rounds:
            return Action.D
        prev_index = history.round_number - 1
        opp_coops = int(history.opponent_actions[prev_index].sum())
        if opp_coops == threshold - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_44(BaseStrategy):
    """
    Aggressive Opportunistic Threshold:
    - Defect in round 1 and the final round.
    - Cooperate in rounds 2…r-1 only if exactly m-1 players cooperated in the previous round.
    - If ever all n players cooperated in any round, flip a PunishAll flag and thereafter always defect.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punish_all = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        completed = history.round_number
        last_idx = completed - 1
        if last_idx >= 0:
            coop_count = int(history.my_actions[last_idx]) + int(history.opponent_actions[last_idx].sum())
            if coop_count == self.game_description.n_players:
                self.punish_all = True
        next_round = completed + 1
        if next_round == self.game_description.n_rounds:
            return Action.D
        if self.punish_all:
            return Action.D
        coop_count_last = int(history.my_actions[last_idx]) + int(history.opponent_actions[last_idx].sum())
        if coop_count_last == self.game_description.m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_45(BaseStrategy):
    """
    Aggressive opportunistic strategy for the repeated collective risk dilemma.
    Defect by default; only cooperate when our single C in the previous round
    would have flipped the group from failure to success. Always defect in round 1
    and the last round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        if history.round_number == self.game_description.n_rounds - 1:
            return Action.D
        prev_round_idx = history.round_number - 1
        coop_prev_excl_us = int(sum(history.opponent_actions[prev_round_idx]))
        if coop_prev_excl_us == self.game_description.m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_46(BaseStrategy):
    """
    Aggressive threshold-free-rider strategy.

    - Always defects on the first and last rounds.
    - In intermediate rounds, predicts opponents' moves by whether each
      has cooperated more than half the completed rounds.
    - Cooperates only if without you the predicted cooperators equal m-1
      (pivotal cooperation); otherwise defects.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t == self.game_description.n_rounds:
            return Action.D
        coop_counts = history.opponent_actions.sum(axis=0)
        half_threshold = (t - 1) / 2.0
        predicted_C_others = 0
        for count in coop_counts:
            if count >= half_threshold:
                predicted_C_others += 1
        if predicted_C_others == self.game_description.m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_47(BaseStrategy):
    """
    Always Defect strategy for the Collective Risk Dilemma:
    Defect in every round, including the first and the last.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_48(BaseStrategy):
    """
    Rescue-and-Grim strategy for the Collective Risk Dilemma.
    - First and last rounds: always defect.
    - In intermediate rounds: cooperate only if exactly m-1 others cooperated last round.
    - If you ever cooperated when others already met the threshold (>= m), switch to permanent defection.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punished = False
        self.occ_prev = None
        self.c_prev = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        m = self.game_description.m
        r = self.game_description.n_rounds
        if history is None:
            self.c_prev = False
            self.occ_prev = None
            return Action.D
        completed = history.round_number
        t = completed + 1
        last_idx = completed - 1
        occ = int(history.opponent_actions[last_idx].sum())
        self.occ_prev = occ
        self.c_prev = bool(history.my_actions[last_idx])
        if self.c_prev and occ >= m:
            self.punished = True
        if self.punished or t == r:
            return Action.D
        if self.occ_prev == m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_49(BaseStrategy):
    """
    Aggressive Threshold Free Rider (ATFR):
    Defect in the first and last round.
    In intermediate rounds, look at the previous round:
    - If others alone met or exceeded the threshold m, defect.
    - Else if the group just failed by one (others == m-1 and total < m), cooperate.
    - Otherwise, defect.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t == self.game.n_rounds:
            return Action.D
        prev_idx = history.round_number - 1
        coop_others = int(history.opponent_actions[prev_idx].sum())
        m = self.game.m
        my_prev = history.my_actions[prev_idx]
        group_success = coop_others + (1 if my_prev else 0) >= m
        if coop_others >= m:
            return Action.D
        if not group_success and coop_others == m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_50(BaseStrategy):
    """
    Aggressive exploiter for the Collective Risk Dilemma.
    Almost always defects, only cooperates to just tip a borderline group
    into success (when others cooperated exactly m-1) and collects k.
    Always defects in the last round.
    """

    def __init__(self, game_description):
        self.game_description = game_description
        self.m = game_description.m
        self.r = game_description.n_rounds
        self.lastCoops = self.m

    def __call__(self, history):
        if history is None:
            t = 1
        else:
            last_idx = history.round_number - 1
            coop_count = int(sum(history.opponent_actions[last_idx]))
            self.lastCoops = coop_count
            t = history.round_number + 1
        if t == self.r:
            return Action.D
        if self.lastCoops >= self.m + 1:
            return Action.D
        if self.lastCoops == self.m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_51(BaseStrategy):
    """
    Extortionate free‐rider strategy for the Collective Risk Dilemma.
    Cooperates only when exactly m-1 opponents cooperated in the previous round
    (pivotal cooperation), otherwise defects. Always defects in the first and last round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.m = game_description.m
        self.n_rounds = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.n_rounds:
            return Action.D
        prev_round_index = history.round_number - 1
        S_prev = int(history.opponent_actions[prev_round_index].sum())
        if S_prev == self.m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_52(BaseStrategy):
    """
    Aggressive free‐rider strategy: always defects to maximize personal payoff,
    breaks near‐threshold coalitions and exploits any coalition that succeeds
    without contributing.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_53(BaseStrategy):
    """
    Threshold Extortioner:
    Aggressive threshold-dilemma strategy that
    - Defects by default (tests the waters first round).
    - If it ever sees m or more cooperators, flips a permanent punishment flag and never cooperates.
    - Otherwise predicts next-round cooperators equal to last observed.
      * If predicted ≥ m, free-rides (defects).
      * If predicted == m-1 and it's the final round, cooperates to tip over the threshold.
      * Else defects.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punish = False
        self.last_cooperators = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        last_my = history.my_actions[-1]
        last_opp = history.opponent_actions[-1]
        self.last_cooperators = int(last_my) + int(last_opp.sum())
        m = self.game_description.m
        r = self.game_description.n_rounds
        t = history.round_number + 1
        if self.last_cooperators >= m:
            self.punish = True
        if self.punish:
            return Action.D
        predicted = self.last_cooperators
        if predicted >= m:
            return Action.D
        if predicted == m - 1 and t == r:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_54(BaseStrategy):
    """
    Aggressive Grim‐Threat for the Collective Risk Dilemma:
    - Cooperate in rounds 1…r-1 so long as no opponent has ever defected.
    - If any opponent ever defects, switch to permanent defection.
    - In the final round, always defect.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            current_round = 1
            defected_before = False
        else:
            current_round = history.round_number + 1
            defected_before = not history.opponent_actions.all()
        if current_round == self.game_description.n_rounds:
            return Action.D
        if defected_before:
            return Action.D
        return Action.C

class Strategy_AGGRESSIVE_55(BaseStrategy):
    """
    Aggressive trigger-free always-defect strategy:
    Unconditionally defects every round, sabotaging collective efforts
    and free-riding on any success achieved by others.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_56(BaseStrategy):
    """
    Aggressive free-riding strategy for the Collective Risk Dilemma.
    Cooperates only when the forecasted number of other cooperators
    in the previous round is exactly m-1 (so that a single contribution
    pushes the group over the threshold), defects otherwise,
    and always defects in the final round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t == self.game.n_rounds:
            return Action.D
        prev_idx = history.round_number - 1
        S_prev = int(history.opponent_actions[prev_idx].sum())
        if S_prev == self.game.m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_57(BaseStrategy):
    """
    Opportunistic Aggressor for the Collective Risk Dilemma.
    - Always defects except when a single cooperation by us
      would meet the threshold.
    - Never cooperates to build trust; only cooperates if
      C_last == m - 1 to tip the group payoff.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        last_idx = history.round_number - 1
        self_coop = 1 if history.my_actions[last_idx] else 0
        opp_coops = int(sum(history.opponent_actions[last_idx]))
        C_last = self_coop + opp_coops
        m = self.game_description.m
        if C_last >= m:
            return Action.D
        if C_last == m - 1:
            return Action.C
        return Action.D

class Strategy_COOPERATIVE_25(BaseStrategy):
    """
    Rotating Coordinators with One‐Round Punishment.
    Maintains exactly m cooperators each round via a rotating schedule,
    punishes any failure once by a full defection round, then resumes.
    Defects in the final round by backward‐induction.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self.punish = False
        if hasattr(self, 'player_index'):
            self.i = self.player_index
        elif hasattr(game_description, 'player_index'):
            self.i = game_description.player_index - 1
        else:
            self.i = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
            coop_prev = self.m
        else:
            completed = history.round_number
            t = completed + 1
            if completed == 0:
                coop_prev = self.m
            else:
                last = completed - 1
                coop_prev = int(history.my_actions[last]) + int(history.opponent_actions[last].sum())
        if t == self.r:
            action_bool = False
        elif t > 1 and coop_prev < self.m and (not self.punish):
            self.punish = True
            action_bool = False
        elif self.punish:
            self.punish = False
            offset = (t - 1) * self.m
            action_bool = (self.i - offset) % self.n < self.m
        else:
            offset = (t - 1) * self.m
            action_bool = (self.i - offset) % self.n < self.m
        return Action.C if action_bool else Action.D

class Strategy_COOPERATIVE_45(BaseStrategy):
    """
    Rotating‐cooperator strategy with one‐round repair for the Collective Risk Dilemma.
    Ensures exactly m cooperators per round in a rotating fashion, and if a threshold
    failure occurs, all players cooperate in the next round to repair.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.player_index = getattr(game_description, 'player_index', None)
        self.last_failure = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            round_number = 0
        else:
            round_number = history.round_number
        if history is not None and round_number > 0:
            last_idx = round_number - 1
            opp_coops = int(history.opponent_actions[last_idx].sum())
            self_coop = 1 if history.my_actions[last_idx] else 0
            total_coops = opp_coops + self_coop
            if total_coops < self.m:
                self.last_failure = True
        t = round_number + 1
        if self.last_failure:
            action = Action.C
            self.last_failure = False
            return action
        start = 1 + (t - 1) * self.m % self.n
        if self.player_index is None:
            return Action.D
        d = (self.player_index - start) % self.n
        if 0 <= d < self.m:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_58(BaseStrategy):
    """
    Aggressive threshold-dilemma strategy:
    - Defect by default in the first round to probe.
    - In intermediate rounds, free-ride if group last round succeeded without you;
      cooperate only if indispensable (others ≤ m-2), punish near-misses (others == m-1).
    - In the final round, defect unless your cooperation alone secures the bonus.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        m = self.game_description.m
        last_idx = history.round_number - 1
        prev_others_coops = int(history.opponent_actions[last_idx].sum())
        prev_my_coop = int(history.my_actions[last_idx])
        prev_total_coops = prev_others_coops + prev_my_coop
        if 1 < t < n_rounds:
            if prev_total_coops >= m:
                return Action.D
            if prev_others_coops <= m - 2:
                return Action.C
            if prev_others_coops == m - 1:
                return Action.D
            return Action.D
        if t == n_rounds:
            if prev_others_coops >= m:
                return Action.D
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_59(BaseStrategy):
    """
    Aggressive Pivotal Exploiter (APE):
    A memory-one strategy for the Collective Risk Dilemma.
    - Always defects in the first and last rounds.
    - In intermediate rounds, cooperates only when exactly m-1 opponents
      cooperated in the previous round (making the player pivotal).
    - Otherwise defects.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        m = self.game_description.m
        if t == 1 or t == n_rounds:
            return Action.D
        last_index = history.round_number - 1
        others_coop_prev = int(np.sum(history.opponent_actions[last_index]))
        if others_coop_prev == m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_60(BaseStrategy):
    """
    Aggressive Pivotal Defection (APD):
    Defect by default; cooperate only when exactly m-1 opponents cooperated
    in the previous round, thus making you the pivotal m-th contributor.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        last_round = history.round_number - 1
        coop_others = int(np.sum(history.opponent_actions[last_round]))
        if coop_others == self.game_description.m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_61(BaseStrategy):
    """
    Exploitative Tipper: aggressive repeated‐game strategy for the collective risk dilemma.
    - Always defects on the first and last rounds.
    - In intermediate rounds, defects unless the previous round had exactly m-1 cooperators,
      in which case it cooperates once to tip the threshold and secure the reward.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds
        self.threshold = game_description.m

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t == self.n_rounds:
            return Action.D
        prev_idx = history.round_number - 1
        my_prev = history.my_actions[prev_idx]
        opp_prev = history.opponent_actions[prev_idx]
        coop_count = int(my_prev) + int(np.sum(opp_prev))
        if coop_count == self.threshold - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_62(BaseStrategy):
    """
    Threshold Slasher: An aggressive threshold‐public‐goods strategy. 
    Defect first and last round, exploit whenever defecting
    doesn't break the m‐threshold, rescue only to exactly meet m, 
    and grim‐trigger on any free‐ride.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.triggered = False
        self.last_coop_count = None
        self.last_round_processed = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is not None:
            self._process_new_rounds(history)
        if history is None:
            t = 1
        else:
            t = history.round_number + 1
        if t == 1:
            return Action.D
        if t >= self.r:
            return Action.D
        if self.triggered:
            return Action.D
        if self.last_coop_count < self.m:
            return Action.D
        elif self.last_coop_count > self.m:
            return Action.D
        else:
            return Action.C

    def _process_new_rounds(self, history: PlayerHistory) -> None:
        """
        Process any rounds that have completed since the last call,
        updating last_coop_count and triggered (grim trigger).
        """
        while self.last_round_processed < history.round_number:
            idx = self.last_round_processed
            my_act = history.my_actions[idx]
            opp_acts = history.opponent_actions[idx]
            coopers = int(my_act) + int(np.sum(opp_acts))
            if coopers >= self.m and coopers < self.n:
                self.triggered = True
            self.last_coop_count = coopers
            self.last_round_processed += 1

class Strategy_AGGRESSIVE_63(BaseStrategy):
    """
    Aggressive Opportunist strategy: defects by default, only cooperates in
    intermediate rounds when exactly m-1 opponents cooperated in the previous round
    (tipping the group to the threshold), and always defects in the first and last rounds.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        r = self.game_description.n_rounds
        m = self.game_description.m
        if t == r:
            return Action.D
        prev_index = history.round_number - 1
        opp_prev = history.opponent_actions[prev_index]
        c = int(opp_prev.sum())
        if c == m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_64(BaseStrategy):
    """
    Pivotal-Selfish strategy for the Collective Risk Dilemma.
    Defect every round except when, in the previous round, exactly m-1
    of the other players cooperated. In that case, cooperate to tip the
    threshold and earn k.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        last_round_idx = history.round_number - 1
        o_count = int(np.sum(history.opponent_actions[last_round_idx]))
        if o_count == self.m - 1:
            return Action.C
        return Action.D

class Strategy_COOPERATIVE_65(BaseStrategy):
    """
    Threshold-focused conditional cooperator for the Collective Risk Dilemma.
    Signals cooperation in round 1, defects in the last round, and in middle rounds
    cooperates if the previous round had at least m-1 cooperators, otherwise defects.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            return Action.D
        prev_index = history.round_number - 1
        opp_coop = int(history.opponent_actions[prev_index].sum())
        own_coop_last = int(history.my_actions[prev_index])
        coop_count = opp_coop + own_coop_last
        m = self.game_description.m
        if coop_count >= m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_66(BaseStrategy):
    """
    Threshold‐Grim trigger: Cooperate each round as long as every past round
    met the m‐cooperator threshold; defect forever after the first failure.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.good = True

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.good = True
            return Action.C
        if self.good:
            last_round = history.round_number - 1
            my_last = history.my_actions[last_round]
            opp_last = history.opponent_actions[last_round]
            coop_count = int(my_last) + int(np.sum(opp_last))
            if coop_count < self.game_description.m:
                self.good = False
        return Action.C if self.good else Action.D

class Strategy_COOPERATIVE_67(BaseStrategy):
    """
    Grim‐trigger strategy for the Collective Risk Dilemma:
    - Cooperate in all rounds 1 to r-1 if threshold has never failed.
    - Defect forever after any round with coopCount < m.
    - Always defect in the last round r.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.punishing = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        last_round_index = history.round_number - 1
        if last_round_index >= 0:
            coop_others = int(np.sum(history.opponent_actions[last_round_index]))
            coop_self = int(history.my_actions[last_round_index])
            coop_count = coop_self + coop_others
            if coop_count < self.m:
                self.punishing = True
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        if self.punishing:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_68(BaseStrategy):
    """
    Threshold-Tit-for-Tat with Limited Punishment and Last-Round Adjustment.

    - Round 1: Cooperate to signal willingness.
    - Interior rounds (2 ≤ t < r):
        • If last round had ≥ m cooperators and not in punishment: Cooperate.
        • If last round had < m cooperators: Defect (single-round punishment), then forgive.
    - Last round (t = r):
        • If last round succeeded: Defect (one-shot free-ride).
        • If last round failed: Cooperate.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.prev_success = True
        self.punish_rounds = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        last_idx = history.round_number - 1
        my_last = history.my_actions[last_idx]
        opp_last = history.opponent_actions[last_idx]
        total_cooperators = int(my_last) + int(np.sum(opp_last))
        if total_cooperators >= self.game_description.m:
            self.prev_success = True
            self.punish_rounds = 0
        else:
            self.prev_success = False
            self.punish_rounds = 1
        t = history.round_number + 1
        r = self.game_description.n_rounds
        if self.punish_rounds > 0:
            return Action.D
        elif t == r:
            return Action.D if self.prev_success else Action.C
        else:
            return Action.C if self.prev_success else Action.D

class Strategy_COOPERATIVE_69(BaseStrategy):
    """
    CCOF – Conditional Cooperation with Optimism and Forgiveness.
    Starts cooperatively, fills gaps when the group is one short of threshold,
    defects when cooperation is hopeless, and forgives immediately when the group recovers.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.n_rounds = game_description.n_rounds
        self.m = game_description.m
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        m = self.m
        r = self.n_rounds
        prev_idx = history.round_number - 1
        prev_own = history.my_actions[prev_idx]
        prev_opps = history.opponent_actions[prev_idx]
        prev_coop = int(prev_own) + int(np.sum(prev_opps))
        if t == r:
            if prev_coop >= m - 1:
                return Action.C
            else:
                return Action.D
        if prev_coop >= m:
            return Action.C
        elif prev_coop == m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_70(BaseStrategy):
    """
    Rotating Core + Recovery protocol for the Collective Risk Dilemma.
    In normal operation exactly m players cooperate each round in a deterministic rotation.
    If a round ever fails to reach m cooperators, the next round all players cooperate
    (recovery), then resume the normal rotation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.n = game_description.n_players
        self.m = game_description.m
        self.r = game_description.n_rounds
        self.need_recovery = False
        self.player_id = getattr(game_description, 'player_id', 1)
        self.p = (self.player_id - 1) % self.n

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
        else:
            t = history.round_number + 1
            if history.round_number >= 1:
                last_idx = history.round_number - 1
                opp_coops = int(np.sum(history.opponent_actions[last_idx]))
                my_last = 1 if history.my_actions[last_idx] else 0
                if opp_coops + my_last < self.m:
                    self.need_recovery = True
        if self.need_recovery:
            action = Action.C
            self.need_recovery = False
            return action
        start = (t - 1) * self.m % self.n
        coop_set = {(start + j) % self.n for j in range(self.m)}
        if self.p in coop_set:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_71(BaseStrategy):
    """
    Threshold‐rescue strategy for the Collective Risk Dilemma.
    Start by cooperating. If last round met the cooperation threshold, continue to cooperate.
    If the group just missed the threshold by one cooperator, cooperate to rescue;
    otherwise defect.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        last_round_idx = history.round_number - 1
        my_last = history.my_actions[last_round_idx]
        opp_last = history.opponent_actions[last_round_idx]
        prev_C = (1 if my_last else 0) + int(opp_last.sum())
        m = self.game_description.m
        gap = m - prev_C
        if prev_C >= m:
            return Action.C
        elif gap == 1:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_72(BaseStrategy):
    """
    Rotating cooperation schedule with one‐round group punishment.
    In each round t, exactly m players cooperate according to a public rotation.
    If any round falls below m cooperators, all defect next round, then resume.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        idx = getattr(game_description, 'player_index', getattr(game_description, 'player_id', None))
        if idx is None:
            idx = 1
        if 1 <= idx <= self.n:
            self.my_index0 = idx - 1
        else:
            self.my_index0 = idx
        self.punished_round = None

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is not None and history.round_number >= 1:
            last = history.round_number - 1
            coop_me = 1 if history.my_actions[last] else 0
            coop_others = int(np.sum(history.opponent_actions[last]))
            coop_count = coop_me + coop_others
            next_round = history.round_number + 1
            if coop_count < self.m and next_round <= self.r:
                self.punished_round = next_round
        if history is None:
            t = 1
        else:
            t = history.round_number + 1
        if self.punished_round == t:
            return Action.D
        b = (t - 1) * self.m % self.n
        if (self.my_index0 - b) % self.n < self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_73(BaseStrategy):
    """
    Threshold‐Tit‐for‐Tat with One‐Turn Forgiveness for the Collective Risk Dilemma.
    - Open with cooperation.
    - If the group met the threshold last round, cooperate.
    - If the group failed last round, defect once as punishment then forgive.
    - Always defect in the final round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punishing = False
        self.coop_prev = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punishing = False
            return Action.C
        t = history.round_number + 1
        last_idx = history.round_number - 1
        num_opp_coop = sum(history.opponent_actions[last_idx])
        self.coop_prev = int(history.my_actions[last_idx]) + int(num_opp_coop)
        if t == self.game_description.n_rounds:
            return Action.D
        if self.punishing:
            self.punishing = False
            return Action.C
        if self.coop_prev >= self.game_description.m:
            return Action.C
        self.punishing = True
        return Action.D

class Strategy_COOPERATIVE_74(BaseStrategy):
    """
    Forgiving Threshold Tit-for-Tat (FTFT):
    - Start by cooperating.
    - If the previous round had fewer than m cooperators, defect exactly once as punishment.
    - Otherwise cooperate.
    - After punishing once, immediately return to cooperation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.inPunishment = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if self.inPunishment:
            self.inPunishment = False
            return Action.D
        last_round_index = history.round_number - 1
        opp_coops = int(history.opponent_actions[last_round_index].sum())
        self_coop = int(history.my_actions[last_round_index])
        total_coops = opp_coops + self_coop
        if total_coops < self.game_description.m:
            self.inPunishment = True
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_75(BaseStrategy):
    """
    Threshold Tit‐for‐Tat with Forgiveness for the Collective Risk Dilemma.
    Starts by cooperating, punishes a failure to meet the threshold for one round,
    forgives thereafter, and always defects in the final round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.m = game_description.m
        self.r = game_description.n_rounds
        self.P = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        if self.P > 0:
            self.P -= 1
            return Action.D
        last_idx = history.round_number - 1
        opp_coops = int(history.opponent_actions[last_idx].sum())
        my_last = int(history.my_actions[last_idx])
        total_coops = opp_coops + my_last
        if total_coops >= self.m:
            return Action.C
        else:
            self.P = 1
            return Action.D

class Strategy_COOPERATIVE_76(BaseStrategy):
    """
    One-Shot Punishment with Quick Forgiveness:
    Start by cooperating. If the last round did not reach the threshold m and
    we have not yet punished for that failure, defect exactly one round.
    Immediately after that single punishment round, return to cooperation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punished_last = False
        self.coop_count_prev = None

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punished_last = False
            self.coop_count_prev = None
            return Action.C
        completed = history.round_number
        if completed > 0:
            last = completed - 1
            coop_self = 1 if history.my_actions[last] else 0
            coop_others = int(history.opponent_actions[last].sum())
            self.coop_count_prev = coop_self + coop_others
        else:
            self.coop_count_prev = None
        if self.punished_last:
            action = Action.C
            self.punished_last = False
        elif self.coop_count_prev is not None and self.coop_count_prev < self.game_description.m:
            action = Action.D
            self.punished_last = True
        else:
            action = Action.C
        return action

class Strategy_COOPERATIVE_77(BaseStrategy):
    """
    Rotating‐coordinator with grim trigger for the Collective Risk Dilemma.
    Ensures exactly m cooperators per round in the cooperation phase,
    rotates the duty evenly, and switches to permanent defection if any
    deviation from the schedule is observed.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.phase = 'COOP'

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        m = self.game_description.m
        i = getattr(self, 'player_index', None)
        if history is not None and self.phase == 'COOP' and (i is not None):
            t_last = history.round_number
            start_last = (t_last - 1) % n + 1
            S_last = set(((start_last - 1 + idx) % n + 1 for idx in range(m)))
            last_my = bool(history.my_actions[t_last - 1])
            opp_last = history.opponent_actions[t_last - 1]
            actual = []
            opp_idx = 0
            for player_j in range(1, n + 1):
                if player_j == i:
                    actual.append(last_my)
                else:
                    actual.append(bool(opp_last[opp_idx]))
                    opp_idx += 1
            ActualSet = set((j for j, did_coop in enumerate(actual, start=1) if did_coop))
            if ActualSet != S_last:
                self.phase = 'PUNISH'
        if history is None:
            t = 1
        else:
            t = history.round_number + 1
        if self.phase == 'PUNISH':
            return Action.D
        if i is None:
            return Action.D
        start = (t - 1) % n + 1
        S_current = set(((start - 1 + idx) % n + 1 for idx in range(m)))
        if i in S_current:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_78(BaseStrategy):
    """
    Threshold‐trigger with one‐round punishment for the Collective Risk Dilemma.
    Opens with cooperation, punishes any round where the group fails to meet
    the cooperation threshold (m) for exactly one round, then forgives.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punish_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if self.punish_counter > 0:
            self.punish_counter -= 1
            return Action.D
        last_idx = history.round_number - 1
        my_prev = 1 if history.my_actions[last_idx] else 0
        opp_prev = int(np.sum(history.opponent_actions[last_idx]))
        coop_prev = my_prev + opp_prev
        if coop_prev >= self.game_description.m:
            return Action.C
        else:
            self.punish_counter = 1
            return Action.D

class Strategy_COOPERATIVE_79(BaseStrategy):
    """
    Conditional Cooperator with One-Round Punishment:
    - Round 1: Cooperate to signal willingness.
    - Rounds 2..r-1:
        * If punish_next flag is set: defect this round (serve punishment), then clear flag.
        * Else if last round's coop_count < m: defect this round (trigger one-round punishment), set punish_next.
        * Else: cooperate.
    - Round r: defect (no future incentives).
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punish_next = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punish_next = False
            return Action.C
        t = history.round_number + 1
        r = self.game_description.n_rounds
        if t == r:
            return Action.D
        if self.punish_next:
            self.punish_next = False
            return Action.D
        prev_idx = history.round_number - 1
        last_coop_self = bool(history.my_actions[prev_idx])
        last_coop_others = int(np.sum(history.opponent_actions[prev_idx]))
        coop_count = int(last_coop_self) + last_coop_others
        if coop_count < self.game_description.m:
            self.punish_next = True
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_80(BaseStrategy):
    """
    Conditional Cooperator with One-Round Punishment for the Collective Risk Dilemma.
    
    - Start by cooperating.
    - If punishment rounds remain, defect and decrement punishment.
    - Otherwise, react to the previous round:
      * If the threshold was met and you defected, punish yourself once.
      * If the threshold was met and you cooperated, cooperate.
      * If the threshold failed, punish the group once.
    - Always cooperate in the final round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.PunsLeft = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if self.PunsLeft > 0:
            action = Action.D
            self.PunsLeft -= 1
        else:
            last_idx = history.round_number - 1
            opp_coops = history.opponent_actions[last_idx].sum()
            my_last = history.my_actions[last_idx]
            total_cooperators = int(opp_coops) + (1 if my_last else 0)
            if total_cooperators >= self.game_description.m:
                if not my_last:
                    self.PunsLeft = 1
                    action = Action.D
                else:
                    action = Action.C
            else:
                self.PunsLeft = 1
                action = Action.D
        if t == self.game_description.n_rounds:
            action = Action.C
        return action

class Strategy_COOPERATIVE_81(BaseStrategy):
    """
    Threshold–Forgiver strategy for the Collective Risk Dilemma.
    Starts by cooperating. If in a non‐punishment round the threshold m is not met,
    it defects exactly once next round, then forgives (returns to cooperation).
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        last_round = history.round_number - 1
        coop_opponents = int(history.opponent_actions[last_round].sum())
        we_cooperated = bool(history.my_actions[last_round])
        total_coops_last = coop_opponents + (1 if we_cooperated else 0)
        threshold = self.game_description.m
        last_failed = total_coops_last < threshold
        we_punished_last = not we_cooperated
        punish_this_round = last_failed and (not we_punished_last)
        if punish_this_round:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_82(BaseStrategy):
    """
    Rotating‐cooperator with grim‐trigger:
    Precomputes a cyclic schedule of m cooperators each round,
    divides contributions evenly, and if any round fails to meet
    the threshold, defects forever.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.triggered = False
        self.schedule = []
        for t in range(1, self.r + 1):
            start = (t - 1) * self.m % self.n
            S = {(start + j) % self.n for j in range(self.m)}
            self.schedule.append(S)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            if getattr(self, 'player_index', None) in self.schedule[0]:
                return Action.C
            else:
                return Action.D
        last_round = history.round_number - 1
        opp_coops = int(np.sum(history.opponent_actions[last_round]))
        my_coop = int(history.my_actions[last_round])
        if opp_coops + my_coop < self.m:
            self.triggered = True
        if self.triggered:
            return Action.D
        t_idx = history.round_number
        if getattr(self, 'player_index', None) in self.schedule[t_idx]:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_83(BaseStrategy):
    """
    Threshold‐Reciprocal with One‐Round Punishment:
    - Cooperate in the first round.
    - Defect in the last round (no future enforcement).
    - If punishing flag is set, punish (defect) for one round, then clear the flag.
    - Otherwise, look at last round's total cooperators:
        • If coop_prev < m: defect (risk realized).
        • If coop_prev == n: cooperate (full cooperation last round).
        • If m ≤ coop_prev < n: set punishing flag and defect (punish free‐riders).
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.punishing = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        completed = history.round_number
        current_round = completed + 1
        if current_round == self.r:
            return Action.D
        if self.punishing:
            self.punishing = False
            return Action.D
        last_ops = history.opponent_actions[-1]
        coop_opponents = int(last_ops.sum())
        coop_self = 1 if history.my_actions[-1] else 0
        coop_prev = coop_opponents + coop_self
        if coop_prev < self.m:
            return Action.D
        if coop_prev == self.n:
            return Action.C
        self.punishing = True
        return Action.D

class Strategy_COOPERATIVE_84(BaseStrategy):
    """
    Forgiving conditional cooperator for the Collective Risk Dilemma.
    Cooperates to secure the public good, punishes free‐riders briefly,
    forgives quickly, and defects in the final round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.L = 1
        self.E = 1
        self.punish_timer = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
        else:
            t = history.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        if t > r - self.E:
            action = Action.D
        elif self.punish_timer > 0:
            action = Action.D
            self.punish_timer -= 1
        elif t == 1:
            action = Action.C
        else:
            idx = t - 2
            last_my = history.my_actions[idx]
            last_opp = history.opponent_actions[idx]
            prev_cooperators = int(last_my) + int(np.sum(last_opp))
            if prev_cooperators >= m:
                if prev_cooperators < n:
                    action = Action.D
                    self.punish_timer = self.L
                else:
                    action = Action.C
            else:
                action = Action.C
        return action

class Strategy_COOPERATIVE_85(BaseStrategy):
    """
    Punish-and-Recover (P&R) strategy for the Collective Risk Dilemma.
    Cooperate by default; if the group fails to reach the threshold in any round,
    punish by defecting exactly one round later, then immediately return to cooperation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punished_rounds_remaining = 0
        self.P = 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        last_round_index = history.round_number - 1
        coop_count = int(history.my_actions[last_round_index]) + int(history.opponent_actions[last_round_index].sum())
        if coop_count < self.game_description.m:
            self.punished_rounds_remaining = self.P
        if self.punished_rounds_remaining > 0:
            action = Action.D
            self.punished_rounds_remaining -= 1
        else:
            action = Action.C
        return action

class Strategy_COOPERATIVE_86(BaseStrategy):
    """
    Threshold-Tac-for-Tat strategy for the repeated collective risk dilemma.
    Cooperate on the first round. On subsequent rounds, if at least m other
    players cooperated last round, defect; otherwise cooperate.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.m = game_description.m

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        others_coop = int(np.sum(history.opponent_actions[-1]))
        if others_coop >= self.m:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_87(BaseStrategy):
    """
    Conditional Cooperate-and-Forgive strategy for the Collective Risk Dilemma.
    - Always cooperate in the first and last round.
    - If the group met the threshold in the previous round, cooperate.
    - If the group failed the threshold, defect once (punish), then forgive by returning to cooperation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.last_success = True
        self.punish_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        T = self.game_description.n_rounds
        m = self.game_description.m
        prev_idx = history.round_number - 1
        coop_count = int(history.my_actions[prev_idx]) + int(np.sum(history.opponent_actions[prev_idx]))
        self.last_success = coop_count >= m
        if t == T:
            return Action.C
        if self.punish_counter > 0:
            self.punish_counter -= 1
            return Action.D
        if self.last_success:
            return Action.C
        self.punish_counter = 1
        return Action.D

class Strategy_COOPERATIVE_88(BaseStrategy):
    """
    Threshold-Pavlov with Last-Round Defection:
    - Round 1: Cooperate.
    - Rounds 2…r-1: If last round had ≥ m cooperators, repeat your last action; 
      otherwise switch (C→D or D→C).
    - Round r: Defect.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if t == total_rounds:
            return Action.D
        last_idx = history.round_number - 1
        last_action = bool(history.my_actions[last_idx])
        coop_opp = int(np.sum(history.opponent_actions[last_idx]))
        coop_count = coop_opp + (1 if last_action else 0)
        if coop_count >= self.game_description.m:
            return Action.C if last_action else Action.D
        else:
            return Action.D if last_action else Action.C

class Strategy_COOPERATIVE_89(BaseStrategy):
    """
    Rotating‐minimal‐maintenance strategy for the Collective Risk Dilemma.
    Guarantees at least m cooperators each round via a round‐robin schedule,
    with a one‐round full‐cooperate recovery if the threshold m was missed.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k
        self.i = getattr(game_description, 'player_index', 1)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
            last_coops = self.m
        else:
            t = history.round_number + 1
            coop_opp = int(history.opponent_actions[-1].sum())
            coop_self = 1 if history.my_actions[-1] else 0
            last_coops = coop_opp + coop_self
        if last_coops < self.m:
            return Action.C
        start = (t - 1) % self.n + 1
        coop_set = set(((start + j - 2) % self.n + 1 for j in range(1, self.m + 1)))
        if self.i in coop_set:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_90(BaseStrategy):
    """
    Threshold-trigger strategy for the Collective Risk Dilemma.
    - Start cooperating.
    - If cooperators < m in a non-final round, punish one round by defecting.
    - After one round of punishment, forgive and return to cooperation.
    - Always defect in the last round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.state = 'OK'
        self.punish_timer = 0
        self.last_round_processed = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        n_rounds = self.game_description.n_rounds
        m = self.game_description.m
        if history is None:
            t = 1
        else:
            completed = history.round_number
            for r in range(self.last_round_processed + 1, completed + 1):
                if r < n_rounds:
                    my_act = history.my_actions[r - 1]
                    opp_act = history.opponent_actions[r - 1]
                    c_count = int(my_act) + int(np.sum(opp_act))
                    if self.state == 'OK' and c_count < m:
                        self.state = 'PUNISH'
                        self.punish_timer = 1
                    elif self.state == 'PUNISH':
                        self.punish_timer -= 1
                        if self.punish_timer <= 0:
                            self.state = 'OK'
            self.last_round_processed = completed
            t = completed + 1
        if t == n_rounds:
            return Action.D
        if self.state == 'OK':
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_91(BaseStrategy):
    """
    Minimal‐coalition strategy for the Collective Risk Dilemma.
    Rotates a coalition of size m fairly, ensures threshold is met
    each round, and punishes any player who shirks by dropping them
    from the next coalition until they make up their cooperation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        m = self.game_description.m
        if history is None:
            contribs = [0] * n
            prev_coops_count = None
            prev_obs_coops = []
        else:
            rounds_done = history.round_number
            contribs = [0] * n
            contribs[0] = int(history.my_actions.sum())
            for j in range(n - 1):
                contribs[j + 1] = int(history.opponent_actions[:, j].sum())
            last = rounds_done - 1
            self_coop = bool(history.my_actions[last])
            opp_coops = history.opponent_actions[last]
            prev_coops_count = int(self_coop) + int(opp_coops.sum())
            prev_obs_coops = []
            if self_coop:
                prev_obs_coops.append(0)
            for j in range(n - 1):
                if opp_coops[j]:
                    prev_obs_coops.append(j + 1)
        if history is None or (prev_coops_count is not None and prev_coops_count >= m):
            candidates = list(range(n))
            candidates.sort(key=lambda i: (contribs[i], i))
            coalition = candidates[:m]
        else:
            obs_sorted = sorted(prev_obs_coops, key=lambda i: (contribs[i], i))
            coalition = obs_sorted[:m]
            if len(coalition) < m:
                others = [i for i in range(n) if i not in coalition]
                others.sort(key=lambda i: (contribs[i], i))
                needed = m - len(coalition)
                coalition += others[:needed]
        return Action.C if 0 in coalition else Action.D

class Strategy_COOPERATIVE_92(BaseStrategy):
    """
    Forgiving Threshold strategy for the Collective Risk Dilemma.
    Starts by cooperating, defects one round to punish any breakdowns,
    then returns to cooperation if the threshold was met. Always defects
    in the last round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punishment_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punishment_counter = 0
            return Action.C
        t = history.round_number + 1
        r = self.game_description.n_rounds
        m = self.game_description.m
        if t == r:
            return Action.D
        if self.punishment_counter > 0:
            self.punishment_counter -= 1
            return Action.D
        last_idx = history.round_number - 1
        coop_opponents = int(history.opponent_actions[last_idx].sum())
        coop_self = int(history.my_actions[last_idx])
        last_C_count = coop_opponents + coop_self
        if last_C_count >= m:
            return Action.C
        else:
            self.punishment_counter = 1
            return Action.D

class Strategy_COOPERATIVE_93(BaseStrategy):
    """
    Threshold Helper strategy for the Collective Risk Dilemma.
    
    - Round 1: Cooperate to signal willingness.
    - Rounds 2 to r-1: Cooperate if the number of cooperators in the previous round
      was at least m-1 (i.e., group just met or was one short of the threshold),
      otherwise defect.
    - Final round: Defect (end‐game defection).
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        completed = history.round_number
        t = completed + 1
        if t == self.game_description.n_rounds:
            return Action.D
        prev_index = completed - 1
        coop_opp = int(np.sum(history.opponent_actions[prev_index]))
        coop_self = 1 if bool(history.my_actions[prev_index]) else 0
        s = coop_opp + coop_self
        if s >= self.game_description.m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_94(BaseStrategy):
    """
    One‐round punishment strategy for the Collective Risk Dilemma.
    Cooperates initially and whenever the threshold was met in the last round,
    defects exactly one round in response to a failed threshold, and always
    defects in the final round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description
        self.punishing = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t_next = history.round_number + 1
        if t_next == self.game.n_rounds:
            return Action.D
        if self.punishing:
            self.punishing = False
            return Action.D
        last_idx = history.round_number - 1
        coopers_opponents = int(np.sum(history.opponent_actions[last_idx]))
        coopers_self = int(history.my_actions[last_idx])
        coop_prev = coopers_self + coopers_opponents
        if coop_prev >= self.game.m:
            return Action.C
        else:
            self.punishing = True
            return Action.D

class Strategy_COOPERATIVE_95(BaseStrategy):
    """
    TTCS: Threshold-Triggered Cooperative Strategy for the Collective Risk Dilemma.
    - Starts by cooperating.
    - Continues to cooperate if the group met the cooperation threshold in the
      previous round.
    - If the group failed the threshold, defects exactly once in the next round
      as punishment, then returns to normal cooperation.
    - Always defects in the final round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.last_success = True
        self.punish = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        r = self.game_description.n_rounds
        m = self.game_description.m
        last_idx = history.round_number - 1
        coopers = int(history.my_actions[last_idx]) + int(history.opponent_actions[last_idx].sum())
        self.last_success = coopers >= m
        if t == r:
            return Action.D
        if self.punish:
            self.punish = False
            return Action.D
        if self.last_success:
            return Action.C
        else:
            self.punish = True
            return Action.D

class Strategy_COOPERATIVE_96(BaseStrategy):
    """
    Rotating-m with grim-trigger:
    Each round exactly m players cooperate following a rotation based on past cooperations.
    A single deviation (wrong number or wrong players) triggers permanent defection.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        m = self.game_description.m
        if history is None:
            return Action.C if 0 < m else Action.D
        coop_count = [0] * n
        deviation = False
        rounds_played = history.round_number
        for t in range(rounds_played):
            scheduled = sorted(range(n), key=lambda j: (coop_count[j], j))[:m]
            S_t = set(scheduled)
            actual = set()
            if history.my_actions[t]:
                actual.add(0)
            opp_row = history.opponent_actions[t]
            for opp_idx, act in enumerate(opp_row, start=1):
                if act:
                    actual.add(opp_idx)
            if len(actual) != m or actual != S_t:
                deviation = True
            for j in actual:
                coop_count[j] += 1
        if deviation:
            return Action.D
        next_schedule = sorted(range(n), key=lambda j: (coop_count[j], j))[:m]
        return Action.C if 0 in next_schedule else Action.D

class Strategy_COOPERATIVE_97(BaseStrategy):
    """
    Group‐Conditional TFT with Endgame Cutoff:
    - P = 1 round punishment for any failure to reach threshold.
    - K = 2 final rounds of unconditional defection.
    - Cooperate if last round was a success; defect and enter punishment if not.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.P = 1
        self.K = 2
        self.last_success = True
        self.punish_remaining = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        m = self.game_description.m
        if history is not None and history.round_number > 0:
            prev_idx = history.round_number - 1
            coop_opp = int(np.sum(history.opponent_actions[prev_idx]))
            coop_self = 1 if history.my_actions[prev_idx] else 0
            cooperators = coop_opp + coop_self
            self.last_success = cooperators >= m
        t = 1 if history is None else history.round_number + 1
        if t > r - self.K:
            action = Action.D
        elif self.punish_remaining > 0:
            action = Action.D
            self.punish_remaining -= 1
        elif self.last_success:
            action = Action.C
        else:
            action = Action.D
            self.punish_remaining = self.P - 1
        return action

class Strategy_COOPERATIVE_98(BaseStrategy):
    """
    Collective generous trigger strategy for the collective risk dilemma.
    Starts with cooperation, continues if the group met the threshold last round,
    punishes a missed threshold with one defection, then forgives.
    In the final round, only cooperates if the previous round succeeded.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punishing_rounds_remaining = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        r = self.game_description.n_rounds
        m = self.game_description.m
        last_my = int(history.my_actions[-1])
        last_others = int(np.sum(history.opponent_actions[-1]))
        coop_count = last_my + last_others
        if t == r:
            if coop_count >= m:
                return Action.C
            else:
                return Action.D
        if self.punishing_rounds_remaining > 0:
            self.punishing_rounds_remaining -= 1
            return Action.D
        if coop_count >= m:
            return Action.C
        else:
            self.punishing_rounds_remaining = 1
            return Action.D

class Strategy_COOPERATIVE_99(BaseStrategy):
    """
    Conditionally cooperative threshold strategy with short punishment and forgiveness.
    Starts by cooperating, sustains cooperation if the group met the threshold last round,
    punishes failures with p consecutive defections, then retests cooperation.
    In the last round, cooperates only if pivotal.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.p = 1
        self.punishment_timer = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        t = history.round_number + 1
        last_my = history.my_actions[-1]
        last_others = history.opponent_actions[-1]
        coops_last = int(last_my) + int(np.sum(last_others))
        if self.punishment_timer > 0:
            self.punishment_timer -= 1
            return Action.D
        if t == r:
            if coops_last == m - 1:
                return Action.C
            else:
                return Action.D
        if coops_last >= m:
            return Action.C
        else:
            self.punishment_timer = self.p - 1
            return Action.D

class Strategy_COOPERATIVE_100(BaseStrategy):
    """
    Finite Grim Trigger with Last–Round Defection:
    Cooperate on round 1. In rounds 2..r-1, if a failure to reach the
    m-threshold occurred in the prior round, defect this round (punishment)
    then forgive (return to cooperation) after P=1 punishment round.
    Also, if already serving a punishment span, continue to defect until
    that span ends. In the final round, always defect.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punish_counter = 0
        self.P = 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        m = self.game_description.m
        if t == n_rounds:
            return Action.D
        if self.punish_counter > 0:
            self.punish_counter -= 1
            return Action.D
        last_idx = history.round_number - 1
        self_coop = 1 if bool(history.my_actions[last_idx]) else 0
        opp_coop = int(np.sum(history.opponent_actions[last_idx]))
        total_coop = self_coop + opp_coop
        if total_coop < m:
            self.punish_counter = self.P - 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_101(BaseStrategy):
    """
    Threshold‐Triggered Forgiving Cooperator (TTFC):
    - Always cooperate in round 1.
    - If the group met the threshold last round, reset failure count and cooperate.
    - If the group missed the threshold:
        • Forgive one lapse (cooperate once more),
        • Then defect on further consecutive failures.
    - In the last round only cooperate if the threshold was met in the previous round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.rounds_failed = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.rounds_failed = 0
            return Action.C
        last_index = history.round_number - 1
        opp_coops = int(history.opponent_actions[last_index].sum())
        my_last = int(history.my_actions[last_index])
        total_coops = opp_coops + my_last
        m = self.game_description.m
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        if current_round < r:
            if total_coops >= m:
                self.rounds_failed = 0
                return Action.C
            else:
                self.rounds_failed += 1
                if self.rounds_failed == 1:
                    return Action.C
                else:
                    return Action.D
        elif total_coops >= m:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_102(BaseStrategy):
    """
    Finite-Horizon Pavlov (FHP) for the Collective Risk Dilemma.
    Starts by cooperating, punishes any threshold failure for exactly one round,
    then forgives, and always defects in the final round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.state = 'Cooperate'

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.state = 'Cooperate'
            return Action.C
        last_idx = history.round_number - 1
        coop_count = int(history.my_actions[last_idx]) + int(history.opponent_actions[last_idx].sum())
        m = self.game_description.m
        old_state = self.state
        if coop_count >= m:
            self.state = 'Cooperate'
        elif old_state == 'Cooperate':
            self.state = 'Punish'
        else:
            self.state = 'Cooperate'
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        if self.state == 'Cooperate':
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_103(BaseStrategy):
    """
    Collective Win‐Stay/Lose‐Shift with One‐Round Punishment and End‐Game Defection.

    This strategy tries to ensure at least m cooperators each round by:
     1. Starting with cooperation (virtual success).
     2. If the group met the threshold last round, keep cooperating (Win‐Stay).
     3. If the group failed last round, defect now and impose one extra round of defection 
        (Lose‐Shift with one‐round punishment).
     4. Always defect in the final round (backward‐induction safe).
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.last_success = True
        self.punish_count = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        last_round = history.round_number - 1
        coop_self = 1 if history.my_actions[last_round] else 0
        coop_opp = int(np.sum(history.opponent_actions[last_round]))
        coop_count = coop_self + coop_opp
        if coop_count >= self.game_description.m:
            self.last_success = True
        else:
            self.last_success = False
        t = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        if t == n_rounds:
            return Action.D
        elif self.punish_count > 0:
            self.punish_count -= 1
            return Action.D
        elif self.last_success:
            return Action.C
        else:
            self.punish_count = 1
            return Action.D

class Strategy_COOPERATIVE_104(BaseStrategy):
    """
    Contingent Cooperator for the Collective Risk Dilemma.
    - Round 1: cooperate to signal goodwill.
    - Rounds 2..r-1: if punishing, defect for one round then forgive;
      otherwise, if last round’s total cooperators >= m, cooperate, else defect and trigger one-round punishment.
    - Round r: always defect (end-game).
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punishment_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        m = self.game_description.m
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == r:
            return Action.D
        if self.punishment_counter > 0:
            self.punishment_counter -= 1
            return Action.D
        prev_idx = history.round_number - 1
        coop_opponents = int(np.sum(history.opponent_actions[prev_idx]))
        coop_self = int(history.my_actions[prev_idx])
        coop_prev = coop_opponents + coop_self
        if coop_prev >= m:
            return Action.C
        else:
            self.punishment_counter = 1
            return Action.D

class Strategy_COOPERATIVE_105(BaseStrategy):
    """
    Firm‐but‐forgiving m‐threshold Tit‐for‐Tat:
    - Start by cooperating.
    - If the group fails to reach the threshold, defect exactly once next round.
    - If the group succeeds, cooperate.
    - Always defect in the last round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.last_success = True
        self.punish_flag = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        gd = self.game_description
        if history is None:
            return Action.C
        last_round = history.round_number - 1
        my_last = history.my_actions[last_round]
        opp_last = history.opponent_actions[last_round]
        total_cooperators = int(my_last) + int(opp_last.sum())
        if total_cooperators >= gd.m:
            self.last_success = True
        else:
            self.last_success = False
            self.punish_flag = 1
        if history.round_number == gd.n_rounds - 1:
            return Action.D
        if self.punish_flag == 1:
            self.punish_flag = 0
            self.last_success = False
            return Action.D
        if self.last_success:
            return Action.C
        else:
            self.punish_flag = 0
            self.last_success = False
            return Action.D

class Strategy_COOPERATIVE_106(BaseStrategy):
    """
    Horizon-Aware Generous Trigger:
    Cooperate by default to reach the threshold m each round.
    If the previous round failed to reach m cooperators, defect exactly once as punishment (if there is
    a future round after punishment), then revert to cooperation.
    In the final round, defect unconditionally.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds
        self.m = game_description.m
        self.last_success = True
        self.punish_cnt = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
        else:
            last_idx = history.round_number - 1
            coop_count = int(np.sum(history.opponent_actions[last_idx])) + int(history.my_actions[last_idx])
            self.last_success = coop_count >= self.m
            t = history.round_number + 1
        if t == self.n_rounds:
            return Action.D
        if self.punish_cnt > 0:
            self.punish_cnt -= 1
            return Action.D
        if not self.last_success and t + 1 < self.n_rounds:
            self.punish_cnt = 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_107(BaseStrategy):
    """
    Cooperative‐Generous Win‐Stay‐Lose‐Shift for the Collective Risk Dilemma.
    Starts optimistic, stays cooperating on clear success or near‐miss, defects on clear failures
    with periodic test cooperations, and in the last round only cooperates if the group has
    clearly met the threshold in the previous round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.last_success = True
        self.K = 3

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        completed = history.round_number
        t = completed + 1
        m = self.game_description.m
        r = self.game_description.n_rounds
        coop_me = 1 if history.my_actions[-1] else 0
        coop_others = int(np.sum(history.opponent_actions[-1]))
        h_last = coop_me + coop_others
        self.last_success = h_last >= m
        if t == r:
            if h_last >= m:
                return Action.C
            else:
                return Action.D
        if self.last_success:
            return Action.C
        if h_last >= m - 1:
            return Action.C
        if h_last <= m - 2:
            if t % self.K == 0:
                return Action.C
            else:
                return Action.D
        return Action.C

class Strategy_COOPERATIVE_108(BaseStrategy):
    """
    Conditional One‐Round Punishment (C1RP) strategy for the Collective Risk Dilemma.
    Starts by cooperating, punishes exactly one round if personally exploited, immediately forgives,
    and defects in the final round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.last_action = None

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            action = Action.C
            self.last_action = action
            return action
        t = history.round_number + 1
        if t == self.game_description.n_rounds:
            action = Action.D
            self.last_action = action
            return action
        coop_opp = int(np.sum(history.opponent_actions[-1]))
        my_prev = 1 if history.my_actions[-1] else 0
        coop_prev = coop_opp + my_prev
        if coop_prev >= self.game_description.m:
            action = Action.C
        elif self.last_action == Action.C:
            action = Action.D
        else:
            action = Action.C
        self.last_action = action
        return action

class Strategy_COOPERATIVE_109(BaseStrategy):
    """
    Threshold-Trigger with Last-Round Adjustment:
    - Start by cooperating.
    - If last round met the m‐cooperator threshold, cooperate (forgive any prior punishment).
    - If last round failed the threshold, defect once (punish) then resume cooperation if threshold is met again.
    - In the final round, defect if the group reliably met the threshold last round (and no active punishment), else cooperate.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punished = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punished = False
            return Action.C
        t = history.round_number + 1
        m = self.game_description.m
        r = self.game_description.n_rounds
        last_idx = history.round_number - 1
        opp_last = history.opponent_actions[last_idx]
        coop_opponents = int(np.sum(opp_last))
        coop_self = int(history.my_actions[last_idx])
        c_prev = coop_opponents + coop_self
        if t == r:
            if c_prev >= m and (not self.punished):
                return Action.D
            else:
                return Action.C
        if c_prev >= m:
            self.punished = False
            return Action.C
        else:
            self.punished = True
            return Action.D

class Strategy_COOPERATIVE_110(BaseStrategy):
    """
    Contingent Contributor for the Collective Risk Dilemma.
    Cooperates in round 1, sustains or repairs cooperation in interior rounds,
    and free‐rides safely in the last round when possible.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        prev_idx = history.round_number - 1
        opp_coops = int(history.opponent_actions[prev_idx].sum())
        my_coop_last = bool(history.my_actions[prev_idx])
        prev_coop_count = opp_coops + (1 if my_coop_last else 0)
        if 1 < t < r:
            if prev_coop_count >= m:
                return Action.C
            elif prev_coop_count == m - 1:
                return Action.C
            else:
                return Action.D
        if t == r:
            others_prev_coop = prev_coop_count - (1 if my_coop_last else 0)
            if others_prev_coop >= m:
                return Action.D
            elif others_prev_coop == m - 1:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_COOPERATIVE_111(BaseStrategy):
    """
    Threshold-Reciprocal Cooperation (TRC):
    - Round 1: Cooperate.
    - On subsequent rounds:
        * If last round had at least m cooperators (including you), cooperate.
        * Otherwise:
            - If you cooperated last round, defect (punish).
            - If you defected last round, cooperate (forgive).
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        last_round = history.round_number - 1
        last_action = history.my_actions[last_round]
        opp_coops = int(np.sum(history.opponent_actions[last_round]))
        last_coop_count = opp_coops + (1 if last_action else 0)
        if last_coop_count >= self.game_description.m:
            return Action.C
        elif last_action:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_112(BaseStrategy):
    """
    Conditional cooperator: start with cooperation, punish any observed defection with exactly
    one round of defection, then forgive. In the final round always defect.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punish_countdown = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if t == total_rounds:
            return Action.D
        if self.punish_countdown > 0:
            self.punish_countdown -= 1
            return Action.D
        last_round_idx = history.round_number - 1
        if last_round_idx >= 0:
            last_opponent_actions = history.opponent_actions[last_round_idx]
            if not last_opponent_actions.all():
                self.punish_countdown = 1
                return Action.D
        return Action.C

class Strategy_COOPERATIVE_113(BaseStrategy):
    """
    Team‐level tit‐for‐tat with one‐round punishment:
    - Cooperate on the first round to signal goodwill.
    - If anyone defected in the previous round, defect once (punish_flag=True) then forgive next round.
    - Otherwise keep cooperating until the final round.
    - On the final round, defect by backward induction.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punish_flag = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punish_flag = False
            return Action.C
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            return Action.D
        if self.punish_flag:
            self.punish_flag = False
            return Action.C
        prev_index = history.round_number - 1
        prev_self_coop = bool(history.my_actions[prev_index])
        prev_opps_coop_all = bool(history.opponent_actions[prev_index].all())
        someone_defected = not prev_self_coop or not prev_opps_coop_all
        if someone_defected:
            self.punish_flag = True
            return Action.D
        else:
            self.punish_flag = False
            return Action.C

class Strategy_COOPERATIVE_114(BaseStrategy):
    """
    Forgiving-trigger strategy for the Collective Risk Dilemma.
    Starts by cooperating, punishes any round in which fewer than m cooperators
    by one round of defection, then immediately returns to cooperation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.m = game_description.m

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        punishing = False
        last_success = True
        for t in range(history.round_number):
            coop_count = int(history.my_actions[t]) + int(history.opponent_actions[t].sum())
            success = coop_count >= self.m
            if not punishing and (not success):
                next_punishing = True
            else:
                next_punishing = False
            punishing = next_punishing
            last_success = success
        if punishing:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_115(BaseStrategy):
    """
    Threshold-Rescue Conditional Cooperation (TRCC) strategy.

    - Round 1: Cooperate.
    - Rounds 2 to r-1:
        • If previous round had ≥ m cooperators: Cooperate.
        • If previous round had exactly m-1 cooperators: Cooperate (rescue).
        • Otherwise: Defect.
    - Round r (last): Defect.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        m = self.game_description.m
        if t == n_rounds:
            return Action.D
        last_my = history.my_actions[-1]
        last_opp = history.opponent_actions[-1]
        prev_coops = int(last_my) + int(np.sum(last_opp))
        if prev_coops >= m:
            return Action.C
        elif prev_coops == m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_116(BaseStrategy):
    """
    Group-Reciprocity with Forgiveness (GRF):
    - Start by cooperating.
    - Forgive a single miss (keep cooperating if threshold missed once).
    - Punish repeated failures (defect if threshold missed ≥2 rounds in a row).
    - Reset forgiveness on a success.
    - In the last round, cooperate if fail_streak ≤ 1, else defect.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.fail_streak = 0
        self.last_action = Action.C

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.fail_streak = 0
            self.last_action = Action.C
            return Action.C
        prev_my = history.my_actions[-1]
        prev_opps = history.opponent_actions[-1]
        coop_count = int(prev_my) + int(np.sum(prev_opps))
        if coop_count >= self.game_description.m:
            self.fail_streak = 0
        else:
            self.fail_streak += 1
        t = history.round_number + 1
        final_round = self.game_description.n_rounds
        if t == final_round:
            if self.fail_streak <= 1:
                action = Action.C
            else:
                action = Action.D
        elif self.fail_streak >= 2:
            action = Action.D
        else:
            action = Action.C
        self.last_action = action
        return action

class Strategy_COOPERATIVE_117(BaseStrategy):
    """
    Generous Threshold‐Tit‐for‐Tat (GTT) strategy for the repeated Collective Risk Dilemma.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punish_flag = False
        self.prev_coops = game_description.n_players

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is not None and history.round_number > 0:
            last_idx = history.round_number - 1
            coop_count = int(history.my_actions[last_idx]) + int(history.opponent_actions[last_idx].sum())
            self.prev_coops = coop_count
        if history is None:
            t = 1
        else:
            t = history.round_number + 1
        if history is None:
            return Action.C
        if t == self.game_description.n_rounds:
            return Action.D
        if self.punish_flag:
            self.punish_flag = False
            return Action.D
        if self.prev_coops >= self.game_description.m:
            return Action.C
        self.punish_flag = True
        return Action.D

class Strategy_COOPERATIVE_118(BaseStrategy):
    """
    Group Tit-for-Tat with single-round punishment and immediate forgiveness:
    - Start by cooperating.
    - If the previous round failed (fewer than m cooperators), punish exactly once by defecting.
    - Immediately forgive by cooperating in the next round.
    - Always cooperate in the final round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.state = 'NORMAL'

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        threshold = self.game_description.m
        if t == total_rounds:
            return Action.C
        if self.state == 'AFTER_DEFECT':
            self.state = 'NORMAL'
            return Action.C
        last_my = history.my_actions[-1]
        last_opponents = history.opponent_actions[-1]
        coop_prev = int(last_my) + int(np.sum(last_opponents))
        if coop_prev >= threshold:
            return Action.C
        else:
            self.state = 'AFTER_DEFECT'
            return Action.D

class Strategy_COOPERATIVE_119(BaseStrategy):
    """
    Reputation-based Conditional Cooperator (RBCC) for the Collective Risk Dilemma.
    Maintains a simple integer reputation for each opponent and cooperates only
    when it believes at least (m-1) others will cooperate. Punishes defections
    by lowering reputation and forgives over time by raising reputation on cooperation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        m = game_description.m
        self.R_min = 0
        self.R_max = 2 * m
        self.R_init = m
        self.delta = 1
        self.n_opponents = game_description.n_players - 1
        self.R = [self.R_init] * self.n_opponents
        self.last_round = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_rounds = history.round_number
        if current_rounds > self.last_round:
            idx = current_rounds - 1
            last_actions = history.opponent_actions[idx]
            for j in range(self.n_opponents):
                if bool(last_actions[j]):
                    self.R[j] = min(self.R_max, self.R[j] + self.delta)
                else:
                    self.R[j] = max(self.R_min, self.R[j] - self.delta)
            self.last_round = current_rounds
        m = self.game_description.m
        good = sum((1 for rep in self.R if rep >= m))
        if good + 1 >= m:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_120(BaseStrategy):
    """
    Forgiving threshold-trigger strategy for the Collective Risk Dilemma.
    Starts with cooperation, defects one round as punishment if any deviation
    or threshold miss occurs, then forgives and resumes cooperation. Always
    defects in the final round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punish_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if t == total_rounds:
            return Action.D
        if self.punish_counter > 0:
            self.punish_counter -= 1
            return Action.D
        last_idx = history.round_number - 1
        opp_coops = int(np.sum(history.opponent_actions[last_idx]))
        my_last = int(history.my_actions[-1])
        last_C = opp_coops + my_last
        if last_C == self.game_description.n_players:
            return Action.C
        else:
            self.punish_counter = 1
            return Action.D

class Strategy_COOPERATIVE_121(BaseStrategy):
    """
    Conditional one‐round punishment with threshold enforcement and final‐round defection.
    Starts by cooperating, enforces the m-cooperator threshold, punishes any round
    in which the threshold was missed by defecting exactly one subsequent round,
    and always defects in the final round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.last_success = True
        self.punish_phase = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        last_round = history.round_number - 1
        coopers = int(np.sum(history.opponent_actions[last_round])) + int(history.my_actions[last_round])
        if coopers >= self.game_description.m:
            self.last_success = True
        else:
            self.last_success = False
            self.punish_phase = True
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            return Action.D
        if self.punish_phase:
            self.punish_phase = False
            return Action.D
        if self.last_success:
            return Action.C
        self.punish_phase = True
        return Action.D

class Strategy_COOPERATIVE_122(BaseStrategy):
    """
    Forgiving‐trigger strategy for the repeated Collective Risk Dilemma.
    Starts by cooperating, punishes a round of defection whenever the
    threshold fails (exactly one round), then returns to cooperation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punishing = 0
        self._P = 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is not None and history.round_number > 0:
            last_idx = history.round_number - 1
            coop_opponents = int(np.sum(history.opponent_actions[last_idx]))
            coop_self = 1 if history.my_actions[last_idx] else 0
            S = coop_opponents + coop_self
            if self.punishing > 0:
                self.punishing -= 1
            elif S < self.game_description.m:
                self.punishing = self._P
        if history is None:
            return Action.C
        else:
            if self.punishing > 0:
                return Action.D
            return Action.C

class Strategy_COOPERATIVE_123(BaseStrategy):
    """
    CRC‐Forgiving‐Trigger strategy for the Collective Risk Dilemma.
    Cooperates on the first round, defects on the last round.
    In middle rounds, continues cooperating if the previous round met the threshold m;
    otherwise defects for one round as punishment and then forgives.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punishing = False
        self.punish_count = 0
        self.prev_C = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        r = self.game_description.n_rounds
        m = self.game_description.m
        last_idx = history.round_number - 1
        opp_coops = int(history.opponent_actions[last_idx].sum())
        self.prev_C = opp_coops + (1 if history.my_actions[last_idx] else 0)
        if t == r:
            return Action.D
        if not self.punishing:
            if self.prev_C >= m:
                return Action.C
            else:
                self.punishing = True
                self.punish_count = 1
                return Action.D
        else:
            self.punish_count += 1
            action = Action.D
            if self.punish_count >= 1:
                self.punishing = False
                self.punish_count = 0
            return action

class Strategy_COOPERATIVE_124(BaseStrategy):
    """
    One‐Period Forgiving Trigger strategy for the Collective Risk Dilemma.
    Starts with cooperation, punishes any failed threshold with a single defection,
    then forgives and returns to cooperation. Always defects in the last round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.prev_coop_count = game_description.n_players
        self.punish_next = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        completed = history.round_number
        last_idx = completed - 1
        opp_coops = int(np.sum(history.opponent_actions[last_idx]))
        self_coop = 1 if history.my_actions[last_idx] else 0
        coop_count = opp_coops + self_coop
        if coop_count >= self.game_description.m:
            self.prev_coop_count = coop_count
            self.punish_next = False
        else:
            self.prev_coop_count = coop_count
            self.punish_next = True
        t = completed + 1
        if t == self.game_description.n_rounds:
            return Action.D
        if self.punish_next:
            return Action.D
        if self.prev_coop_count >= self.game_description.m:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_125(BaseStrategy):
    """
    Forgiving Free-Rider Punishment (FFP) strategy for the repeated
    Collective Risk Dilemma. Starts by cooperating, punishes a single
    defection after successful threshold cooperation, forgives quickly,
    and defects in the final round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punishing = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n = self.game_description.n_players
        m = self.game_description.m
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            return Action.D
        if self.punishing:
            self.punishing = False
            return Action.D
        coop_prev = int(history.my_actions[-1]) + int(history.opponent_actions[-1].sum())
        if m <= coop_prev < n:
            self.punishing = True
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_126(BaseStrategy):
    """
    Threshold‐conditional cooperative strategy:
    - Cooperate in round 1.
    - For rounds 2..r-1: cooperate if last round had ≥ m cooperators, else defect (one‐round punishment).
    - Defect in the final round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds
        self.threshold = game_description.m

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t_next = history.round_number + 1
        if t_next == self.n_rounds:
            return Action.D
        last_idx = history.round_number - 1
        opp_coops = int(np.sum(history.opponent_actions[last_idx]))
        self_coop = 1 if history.my_actions[last_idx] else 0
        total_coops = opp_coops + self_coop
        if total_coops >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_127(BaseStrategy):
    """
    Threshold-Aware Generous Tit-for-Tat Strategy for the Collective Risk Dilemma.
    Starts with cooperation, punishes one round if the group fails the threshold,
    then forgives. In the last round defects if it expects the threshold met,
    otherwise cooperates.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punish = False
        self.last_coop_count = game_description.n_players

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punish = False
            self.last_coop_count = self.game_description.n_players
            return Action.C
        completed = history.round_number
        t = completed + 1
        n = self.game_description.n_players
        m = self.game_description.m
        r = self.game_description.n_rounds
        last_idx = completed - 1
        if last_idx >= 0:
            opp_coops = history.opponent_actions[last_idx].sum()
            self.last_coop_count = opp_coops + (1 if history.my_actions[last_idx] else 0)
        if t == r:
            if self.last_coop_count >= m:
                return Action.D
            else:
                return Action.C
        if self.punish:
            self.punish = False
            return Action.D
        if self.last_coop_count >= m:
            return Action.C
        else:
            self.punish = True
            return Action.D

class Strategy_COOPERATIVE_128(BaseStrategy):
    """
    One–Round Group TFT with Forgiveness (G-TFT1):
    - Start by cooperating.
    - If in punishment mode, defect and countdown punish_timer.
    - Otherwise, observe last round:
      • If cooperators < m: cooperate to rebuild.
      • If cooperators == n: cooperate (full cooperation).
      • If m ≤ cooperators < n: defect now and set punish_timer=1
        to carry punishment into the next round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punish_timer = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if self.punish_timer > 0:
            self.punish_timer -= 1
            return Action.D
        last_idx = history.round_number - 1
        coop_me = int(history.my_actions[last_idx])
        coop_opp = int(np.sum(history.opponent_actions[last_idx]))
        coop_prev = coop_me + coop_opp
        m = self.game_description.m
        n = self.game_description.n_players
        if coop_prev < m:
            return Action.C
        if coop_prev == n:
            return Action.C
        self.punish_timer = 1
        return Action.D

class Strategy_AGGRESSIVE_65(BaseStrategy):
    """
    Aggressive Exploiter: always defects except in intermediate rounds when
    by cooperating it alone flips the group from (m-1) to m cooperators,
    thus maximizing its immediate payoff. First and last rounds always defect.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.desc = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        r = self.desc.n_rounds
        m = self.desc.m
        if t == r:
            return Action.D
        prev_index = history.round_number - 1
        coop_count = int(history.opponent_actions[prev_index].sum())
        if coop_count == m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_66(BaseStrategy):
    """
    Aggressive collective‐risk strategy: defect every round except when exactly
    m–1 opponents cooperated in the previous round, in which case cooperate to
    single‐handedly meet the threshold.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        last_round_index = history.round_number - 1
        obs_prev = int(history.opponent_actions[last_round_index].sum())
        m = self.game_description.m
        if obs_prev >= m:
            return Action.D
        elif obs_prev == m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_67(BaseStrategy):
    """
    Aggressive threshold‐exploiter for the Collective Risk Dilemma.
    Defects in the first and last rounds. In intermediate rounds, it cooperates
    only if exactly m-1 other players cooperated in the previous round (just
    enough to tip the threshold), and defects otherwise (either to exploit
    surplus cooperators or to avoid wasting the endowment).
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        completed = history.round_number
        t = completed + 1
        if t == 1 or t == self.game_description.n_rounds:
            return Action.D
        last_idx = completed - 1
        my_last = bool(history.my_actions[last_idx])
        opp_last = history.opponent_actions[last_idx]
        total_prev_C = int(my_last) + int(np.sum(opp_last))
        other_C = total_prev_C - (1 if my_last else 0)
        m = self.game_description.m
        if other_C >= m:
            return Action.D
        elif other_C == m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_68(BaseStrategy):
    """
    Opportunistic Defector with Pivotal Cooperation (ODPC).
    Always defects except when strictly pivotal: others cooperated == m-1
    in a non-final, non-first round. Implements grim punishment: if ever
    cooperated when others >= m (i.e. was fooled), then defect forever.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.grim = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        if not self.grim and history.round_number > 0:
            coops_others = history.opponent_actions.sum(axis=1)
            cooperated = history.my_actions
            fooled = (coops_others >= self.game_description.m) & cooperated
            if bool(fooled.any()):
                self.grim = True
        if self.grim:
            return Action.D
        t = history.round_number + 1
        if t == self.game_description.n_rounds:
            return Action.D
        last_idx = history.round_number - 1
        coops_last = int(history.opponent_actions[last_idx].sum())
        if coops_last >= self.game_description.m:
            return Action.D
        elif coops_last == self.game_description.m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_69(BaseStrategy):
    """
    Aggressive free‐rider strategy for the Collective Risk Dilemma.
    - Never cooperates in the first or last round.
    - In middle rounds, cooperates only if exactly m-1 players cooperated
      in the previous round (to just meet the threshold), otherwise defects.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        m = self.game_description.m
        if t == n_rounds:
            return Action.D
        last_idx = history.round_number - 1
        opp_coops = int(np.sum(history.opponent_actions[last_idx]))
        my_prev = 1 if history.my_actions[last_idx] else 0
        prev_C = opp_coops + my_prev
        if prev_C == m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_70(BaseStrategy):
    """
    Pivotal Extortion with Grim Punishment (PEG):
    - Round 1: Defect.
    - Rounds 2…r-1: 
        * If any prior round had 1 < cooperators < m, switch to permanent Defect.
        * Otherwise:
            - Free-ride if others already meet threshold.
            - Cooperate only if you are exactly pivotal (others = m-1).
            - Defect otherwise.
    - Round r: Defect (end-game).
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punished = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        completed = history.round_number
        t = completed + 1
        r = self.game_description.n_rounds
        m = self.game_description.m
        if t == r:
            return Action.D
        last_idx = completed - 1
        opp_coops = int(np.sum(history.opponent_actions[last_idx]))
        my_prev = 1 if history.my_actions[last_idx] else 0
        prevC = opp_coops + my_prev
        if not self.punished and 1 < prevC < m:
            self.punished = True
        if self.punished:
            return Action.D
        if history.my_actions[last_idx]:
            predicted_other_C = prevC - 1
        else:
            predicted_other_C = prevC
        if predicted_other_C >= m:
            return Action.D
        if predicted_other_C == m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_71(BaseStrategy):
    """
    Greedy threshold strategy for the Collective Risk Dilemma.
    Cooperates only when by doing so you become the m-th cooperator (pivotal)
    in rounds 2..r-1; always defects on the first and last round, and whenever
    cooperation cannot change the outcome or is already met by opponents.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        m = self.game_description.m
        if t == n_rounds:
            return Action.D
        s = int(np.sum(history.opponent_actions[-1]))
        if s >= m:
            return Action.D
        if s == m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_72(BaseStrategy):
    """
    Aggressive Nudge‐and‐Exploit (ANE):
    Always defect by default (including first and last round).
    Only cooperate when exactly m-1 opponents cooperated in the previous round,
    so that your single contribution is the tipping point.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t == self.game_description.n_rounds:
            return Action.D
        last_idx = history.round_number - 1
        coop_others = int(np.sum(history.opponent_actions[last_idx]))
        if coop_others == self.game_description.m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_73(BaseStrategy):
    """
    Rogue Mercenary strategy:
    - Always defect in the first and last rounds.
    - In intermediate rounds, cooperate only if exactly (m - 1) opponents
      cooperated in the previous round, so your single contribution
      secures the public‐good bonus.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n_rounds = self.game_description.n_rounds
        m = self.game_description.m
        t = history.round_number + 1
        if t == n_rounds:
            return Action.D
        last_round_index = history.round_number - 1
        last_others_C = int(history.opponent_actions[last_round_index].sum())
        if last_others_C == m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_74(BaseStrategy):
    """
    Aggressive Opportunist for the Collective Risk Dilemma.
    Only cooperates when defecting would drop cooperators below the threshold m,
    otherwise always defects. Defects unconditionally in the first and last round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        completed = history.round_number
        t = completed + 1
        r = self.game_description.n_rounds
        m = self.game_description.m
        if t == r:
            return Action.D
        prev_idx = completed - 1
        others_prev_c = int(np.sum(history.opponent_actions[prev_idx]))
        if others_prev_c >= m:
            return Action.D
        elif others_prev_c == m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_75(BaseStrategy):
    """
    Threshold-Saboteur: Defects every round unless by cooperating you alone
    can raise the number of cooperators from m-1 to m and secure the bonus k.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        last_round_index = history.round_number - 1
        opp_coop = int(history.opponent_actions[last_round_index].sum())
        m = self.game_description.m
        if opp_coop == m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_76(BaseStrategy):
    """
    Aggressive Saboteur: never cooperates to build trust; only contributes if it is
    pivotal (i.e., expected other cooperators in [m-1, m)) to grab the group reward,
    otherwise defects. Always defects in the last round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game.n_players
        m = self.game.m
        r = self.game.n_rounds
        if history is None:
            mu = 0.5 * (n - 1)
            if mu >= m:
                return Action.D
            elif mu >= m - 1:
                return Action.C
            else:
                return Action.D
        t = history.round_number + 1
        if t == r:
            return Action.D
        total_C = float(np.sum(history.opponent_actions))
        mu = total_C / history.round_number
        if mu >= m:
            return Action.D
        elif mu >= m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_77(BaseStrategy):
    """
    Aggressive threshold-public-goods strategy:
    - Defect in the first round to probe.
    - Defect in the last two rounds since no future leverage exists.
    - In intermediate rounds, cooperate only when your action is pivotal
      (i.e., exactly m-1 cooperators last round) to tip the group over
      the threshold; otherwise defect.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        m = self.game_description.m
        if history is None:
            return Action.D
        completed = history.round_number
        t = completed + 1
        if t >= r - 1:
            return Action.D
        prev_idx = completed - 1
        opp_coops = int(history.opponent_actions[prev_idx].sum())
        self_coop = int(history.my_actions[prev_idx])
        last_coops = opp_coops + self_coop
        if last_coops >= m:
            return Action.D
        if last_coops == m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_78(BaseStrategy):
    """
    BullyPivotal strategy for the Collective Risk Dilemma.
    - Always defect unless you are exactly the pivotal contributor (others have m-1 cooperators).
    - If you ever cooperate and see any defection in that same round, switch to permanent defection.
    - In the last round, apply the same pivotal-only rule.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punished = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is not None and history.round_number > 0:
            last_idx = history.round_number - 1
            if history.my_actions[last_idx]:
                if not all(history.opponent_actions[last_idx]):
                    self.punished = True
        if self.punished:
            return Action.D
        if history is None:
            return Action.D
        last_idx = history.round_number - 1
        coop_count = int(np.sum(history.opponent_actions[last_idx]))
        m = self.game_description.m
        if coop_count == m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_79(BaseStrategy):
    """
    Aggressive Threshold-Exploiter with Grim Punishment:
    - Free-rides whenever the other n-1 cooperators suffice to meet the threshold.
    - Contributes only if exactly m-1 others cooperated last round (pivotal).
    - Once exploited (you cooperated but others_coops >= m), switch to permanent defection.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punished = False
        self.last_others_coops = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is not None and history.round_number > 0:
            last_round = history.round_number - 1
            others_last = int(history.opponent_actions[last_round].sum())
            self.last_others_coops = others_last
            if history.my_actions[last_round] and others_last >= self.game_description.m:
                self.punished = True
        if self.punished:
            return Action.D
        m = self.game_description.m
        others = self.last_others_coops
        if others >= m:
            return Action.D
        if others == m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_80(BaseStrategy):
    """
    Aggressive Opportunist for the Collective Risk Dilemma.
    Defects by default, cooperates only when pivotal (others = m-1),
    punishes permanently if the group succeeds without you twice in a row,
    and always defects in the final round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.flag_punish = False
        self.success_without_you = 0
        self.last_coop_count = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        if history.round_number > 0:
            last_ops = history.opponent_actions[history.round_number - 1]
            self.last_coop_count = int(np.sum(last_ops))
        t = history.round_number + 1
        r = self.game_description.n_rounds
        m = self.game_description.m
        action = Action.D
        if t == r:
            action = Action.D
        elif self.flag_punish:
            action = Action.D
        else:
            C_other = self.last_coop_count
            if C_other >= m:
                action = Action.D
                self.success_without_you += 1
            elif C_other == m - 1:
                action = Action.C
                self.success_without_you = 0
            else:
                action = Action.D
                self.success_without_you = 0
        if self.success_without_you >= 2:
            self.flag_punish = True
        return action

class Strategy_AGGRESSIVE_81(BaseStrategy):
    """
    Aggressive threshold-public-goods strategy.
    Defect unless exactly pivotal to reach the threshold;
    if others let the group fail when they could have succeeded
    without you, enter permanent defection ("revenge mode").
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.revenge = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        last_idx = history.round_number - 1
        if last_idx >= 0:
            opp_last = history.opponent_actions[last_idx]
            O_last = int(opp_last.sum())
            we_last = bool(history.my_actions[last_idx])
            C_total_last = O_last + (1 if we_last else 0)
            if C_total_last < m and O_last >= m:
                self.revenge = True
        if t == r:
            return Action.D
        if self.revenge:
            return Action.D
        opp_previous = history.opponent_actions[last_idx]
        O_prev = int(opp_previous.sum())
        if O_prev >= m:
            return Action.D
        elif O_prev == m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_82(BaseStrategy):
    """
    Aggressive Free-Rider for the Collective Risk Dilemma.

    - Always defects in round 1 and the last round.
    - Tracks if any opponent ever cooperated (PunishAll flag).
    - If PunishAll is set, defects forever to punish cooperators.
    - Otherwise, in intermediate rounds cooperates only when
      by doing so you turn exactly m-1 other cooperators into m
      and thus strictly increase your payoff.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punish_all = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        if history.opponent_actions.any():
            self.punish_all = True
        t = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if t == 1 or t == total_rounds or self.punish_all:
            return Action.D
        last_my = bool(history.my_actions[-1])
        last_opp_array = history.opponent_actions[-1]
        phi_prev = int(last_opp_array.sum()) + (1 if last_my else 0)
        est_others = phi_prev - (1 if last_my else 0)
        if est_others == self.game_description.m - 1 and self.game_description.k > 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_83(BaseStrategy):
    """
    Opportunistic Free-Rider:
    Defect by default, only cooperate when you are the decisive vote (i.e. exactly m-1
    others are expected to cooperate), never cooperate in first or last round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.n_opp = self.n - 1
        self.beliefs = [0.5] * self.n_opp
        self.last_observed_round = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t_obs = history.round_number
        if t_obs > self.last_observed_round:
            last_actions = history.opponent_actions[t_obs - 1]
            for j in range(self.n_opp):
                prev_f = self.beliefs[j]
                contribution = 1 if last_actions[j] else 0
                self.beliefs[j] = ((t_obs - 1) * prev_f + contribution) / t_obs
            self.last_observed_round = t_obs
        t_next = history.round_number + 1
        if t_next == self.r:
            return Action.D
        E = sum(self.beliefs)
        if E >= self.m or E < self.m - 1:
            return Action.D
        return Action.C

class Strategy_AGGRESSIVE_84(BaseStrategy):
    """
    Aggressive Exploit-and-Punish strategy for the Collective Risk Dilemma.

    - Defaults to defect.
    - If exactly m-1 opponents cooperated last round and we have not yet exploited, cooperate this round.
      Our one contribution turns a failure into success, earning k instead of 1.
    - As soon as we ever benefit by defecting on a successful round (i.e., ≥m opponents cooperated
      and we defected), set exploited=True and defect forever after.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.exploited = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        if not self.exploited:
            prev_r = history.round_number - 1
            if not history.my_actions[prev_r]:
                num_opp_coop = int(np.sum(history.opponent_actions[prev_r]))
                if num_opp_coop >= self.game_description.m:
                    self.exploited = True
        if self.exploited:
            return Action.D
        prev_idx = history.round_number - 1
        num_opp_last = int(np.sum(history.opponent_actions[prev_idx]))
        if num_opp_last == self.game_description.m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_85(BaseStrategy):
    """
    Aggressive‐selfish strategy for the repeated Collective Risk Dilemma.
    Never leads in cooperating, free‐rides if the threshold was already met,
    only cooperates when pivotal (prev_coops == m-1), and after L consecutive
    failures probes with probability delta. In the last round it maximizes
    that round's payoff (cooperate iff pivotal).
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.delta = 0.1
        self.L = 3

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        r = history.round_number
        last = r - 1
        prev_coops = int(np.sum(history.opponent_actions[last]))
        drought = 0
        m = self.game_description.m
        for i in range(r - 1, -1, -1):
            coop_others = int(np.sum(history.opponent_actions[i]))
            coop_self = int(history.my_actions[i])
            if coop_others + coop_self >= m:
                break
            drought += 1
        current_round = r + 1
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            return Action.C if prev_coops == m - 1 else Action.D
        if prev_coops >= m:
            return Action.D
        if prev_coops == m - 1:
            return Action.C
        if drought > self.L:
            if random.random() < self.delta:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_86(BaseStrategy):
    """
    Aggressive Threshold Exploiter (ATE):
    Contribute only when your single C is pivotal to reach the threshold,
    free‐ride otherwise, and always defect in the last round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.p0 = 0.5

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
        else:
            t = history.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        if t == r:
            return Action.D
        if t == 1:
            E = (n - 1) * self.p0
        else:
            prev_idx = history.round_number - 1
            E = int(np.sum(history.opponent_actions[prev_idx]))
        if E >= m:
            return Action.D
        elif E == m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_87(BaseStrategy):
    """
    Aggressive Exploit‐or‐Push strategy for the Collective Risk Dilemma.
    Memory‐1: defects except when your single cooperation
    turns a failing round (m-1 cooperators) into a success (m cooperators),
    and always defects in the last round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        m = self.game_description.m
        r = self.game_description.n_rounds
        if history is None:
            last_cooperators = m
            t = 1
        else:
            completed = history.round_number
            t = completed + 1
            last_cooperators = int(history.opponent_actions[completed - 1].sum())
        if t == r:
            return Action.D
        if last_cooperators >= m:
            return Action.D
        if last_cooperators == m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_88(BaseStrategy):
    """
    PROBE-AND-EXPLOIT strategy for the Collective Risk Dilemma.
    Brief probing phase to detect a threshold coalition, then permanent defection.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.T = min(math.ceil(self.r / 4), 3)
        self.p_probe = 0.3
        self.state = 'PROBE'

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        if self.state == 'PROBE':
            last_idx = history.round_number - 1
            opp_coops = int(np.sum(history.opponent_actions[last_idx]))
            my_coop = 1 if history.my_actions[last_idx] else 0
            total_coops = opp_coops + my_coop
            if total_coops >= self.m:
                self.state = 'EXPLOIT'
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        if self.state == 'PROBE':
            if t <= self.T:
                if random.random() < self.p_probe:
                    return Action.C
                else:
                    return Action.D
            else:
                self.state = 'DEFECT'
                return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_89(BaseStrategy):
    """
    Aggressive free-riding strategy for the Collective Risk Dilemma.
    By default defects; only cooperates when the expected number of
    cooperating opponents E satisfies m-1 ≤ E < m, making you pivotal.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        completed = history.round_number
        total_coops = np.sum(history.opponent_actions)
        E = total_coops / completed
        m = self.game_description.m
        if E >= m or E < m - 1:
            return Action.D
        return Action.C

class Strategy_AGGRESSIVE_90(BaseStrategy):
    """
    Opportunistic‐Aggressive Threshold‐Exploitation Strategy.

    You defect in every round except when the number of cooperators
    in the previous round was exactly m-1, in which case you cooperate
    to unilaterally tip the group over the threshold and capture the reward.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        last_round = history.round_number - 1
        my_coop_last = int(history.my_actions[last_round])
        opp_coops_last = int(history.opponent_actions[last_round].sum())
        coop_prev = my_coop_last + opp_coops_last
        if coop_prev == self.game_description.m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_91(BaseStrategy):
    """
    Aggressive threshold‐exploiter for the collective risk dilemma.
    Cooperates only when exactly m-1 opponents cooperated in the previous round
    (to tip the group over the threshold), otherwise always defects.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        last_round = history.round_number - 1
        prev_coops = int(np.sum(history.opponent_actions[last_round]))
        m = self.game_description.m
        if prev_coops >= m:
            return Action.D
        elif prev_coops == m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_92(BaseStrategy):
    """
    Threshold-Freerider with Grim Exploit:
      - Defects on the first and last rounds.
      - Only cooperates when you alone can swing the group (others cooperators == m-1).
      - Once you freeride a successful round (others cooperators >= m), defects forever.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.freed = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        r = self.game_description.n_rounds
        m = self.game_description.m
        if t == r:
            return Action.D
        if self.freed:
            return Action.D
        last_idx = history.round_number - 1
        opp_coops = int(np.sum(history.opponent_actions[last_idx]))
        if opp_coops >= m:
            self.freed = True
            return Action.D
        if opp_coops == m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_93(BaseStrategy):
    """
    Exploit‐only‐when‐needed strategy for the Collective Risk Dilemma.
    Always defects except when your single cooperation pushes the
    previous round's cooperators from m-1 to m, in which case you cooperate
    to trigger the bonus. Also defects on the first and last rounds.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        r = self.game_description.n_rounds
        m = self.game_description.m
        if t == r:
            return Action.D
        prev_idx = history.round_number - 1
        coop_others = int(history.opponent_actions[prev_idx].sum())
        coop_self = int(history.my_actions[prev_idx])
        coop_prev = coop_others + coop_self
        if coop_prev == m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_94(BaseStrategy):
    """
    Aggressive Opportunist + Punisher strategy for the repeated Collective Risk Dilemma.
    Free-rides whenever safe, only cooperates when pivotal, and switches to
    permanent defection (grim punishment) if the group ever fails to reach
    the threshold when it reasonably could have.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punished = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        rounds_completed = history.round_number
        if rounds_completed >= 1 and (not self.punished):
            last_idx = rounds_completed - 1
            m = self.game_description.m
            own_last = history.my_actions[last_idx]
            opp_last = np.sum(history.opponent_actions[last_idx])
            coop_last = int(own_last) + int(opp_last)
            if coop_last < m and (own_last or coop_last >= m - 1):
                self.punished = True
        current_round = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        m = self.game_description.m
        if current_round == n_rounds:
            return Action.D
        if self.punished:
            return Action.D
        if current_round == 1:
            return Action.D
        prev_idx = history.round_number - 1
        own_prev = history.my_actions[prev_idx]
        opp_prev = np.sum(history.opponent_actions[prev_idx])
        coop_prev = int(own_prev) + int(opp_prev)
        if coop_prev >= m:
            return Action.D
        elif coop_prev == m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_95(BaseStrategy):
    """
    Aggressive‐extortion strategy for the repeated Collective Risk Dilemma.
    Cooperate only when pivotal to reach the threshold; always defect otherwise,
    including the first and last two rounds.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        if t >= r - 1:
            return Action.D
        rounds_done = history.round_number
        total_coops = history.opponent_actions.sum()
        p = total_coops / (rounds_done * (n - 1))
        E = p * (n - 1)
        if E >= m:
            return Action.D
        elif E >= m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_96(BaseStrategy):
    """
    Aggressive Collective Risk strategy:
    - Always defects by default.
    - Cooperates only when exactly (m - 1) cooperators were seen last round,
      making you pivotal to reach the threshold.
    - Grim-triggers into permanent defection if any successful round (≥ m cooperators)
      occurred without full contribution, punishing free-riders forever.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.punished = False
        self.last_coop_count = 0
        self.n_rounds = game_description.n_rounds
        self.m = game_description.m

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        prev_index = history.round_number - 1
        if prev_index >= 0:
            my_prev = int(history.my_actions[prev_index])
            opp_prev = int(history.opponent_actions[prev_index].sum())
            Cprev = my_prev + opp_prev
        else:
            Cprev = 0
        self.last_coop_count = Cprev
        if self.punished or t == 1 or t == self.n_rounds:
            return Action.D
        if Cprev >= self.m:
            self.punished = True
            return Action.D
        if Cprev == self.m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_97(BaseStrategy):
    """
    Aggressive Pivot-and-Punish: free-rides whenever possible,
    only contributes when strictly necessary to secure the bonus,
    and punishes any player who over-cooperates.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.B = set()
        self.lastC = self.game_description.n_players
        self.last_round_processed = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        rounds_done = history.round_number
        if rounds_done > self.last_round_processed:
            prev_round_idx = rounds_done - 1
            prev_lastC = self.lastC
            opp_actions = history.opponent_actions[prev_round_idx]
            if prev_lastC >= self.game_description.m:
                for j, acted in enumerate(opp_actions):
                    if acted:
                        self.B.add(j)
            num_opp_C = int(opp_actions.sum())
            my_act = history.my_actions[prev_round_idx]
            self.lastC = num_opp_C + (1 if my_act else 0)
            self.last_round_processed = rounds_done
        t = rounds_done + 1
        if t == self.game_description.n_rounds:
            return Action.D
        if self.lastC >= self.game_description.m:
            return Action.D
        if self.lastC == self.game_description.m - 1:
            prev_round_idx = rounds_done - 1
            opp_actions = history.opponent_actions[prev_round_idx]
            last_cooperators = {j for j, acted in enumerate(opp_actions) if acted}
            if last_cooperators & self.B:
                return Action.D
            else:
                return Action.C
        return Action.D

class Strategy_AGGRESSIVE_98(BaseStrategy):
    """
    Aggressive Pivotal Defector:
    Defect every round except when your single contribution is strictly
    pivotal to meeting the cooperation threshold (coopOthersPred == m-1),
    and never cooperate in the final round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        if history is None:
            t = 1
            obsCoop_prev = m
            prev_coop = False
        else:
            t = history.round_number + 1
            prev_coop = bool(history.my_actions[-1])
            coop_opp = int(np.sum(history.opponent_actions[-1]))
            obsCoop_prev = coop_opp + (1 if prev_coop else 0)
        coopOthersPred = obsCoop_prev - (1 if prev_coop else 0)
        if coopOthersPred < 0:
            coopOthersPred = 0
        elif coopOthersPred > n - 1:
            coopOthersPred = n - 1
        if t == r:
            return Action.D
        if coopOthersPred >= m:
            return Action.D
        elif coopOthersPred == m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_99(BaseStrategy):
    """
    Conditional Pivotal Defector (CPD):
    Defect on the first and last rounds. In intermediate rounds, cooperate
    only if exactly m-1 opponents cooperated in the previous round (i.e.,
    you are the pivotal cooperator); otherwise defect.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        r = self.game_description.n_rounds
        m = self.game_description.m
        if t == r:
            return Action.D
        prev_idx = t - 2
        opp_cooperators = int(np.sum(history.opponent_actions[prev_idx]))
        if opp_cooperators == m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_100(BaseStrategy):
    """
    Opportunistic Defector:
    Aggressively free‐rides whenever possible and only cooperates
    if your single contribution is enough to tip the threshold.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        rounds_played = history.round_number
        if rounds_played == 0:
            return Action.D
        coop_counts = history.opponent_actions.sum(axis=0)
        p_j = coop_counts / rounds_played
        E_coop_others = float(p_j.sum())
        if E_coop_others >= self.m:
            return Action.D
        if E_coop_others <= self.m - 2:
            return Action.D
        return Action.C

class Strategy_AGGRESSIVE_101(BaseStrategy):
    """
    Threshold-Sniper strategy: Always defect except when your single cooperation
    is pivotal to meet the threshold. Defect in first and last rounds; in other
    rounds cooperate iff exactly m-1 opponents cooperated in the previous round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n_rounds = self.game_description.n_rounds
        m = self.game_description.m
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t == n_rounds:
            return Action.D
        prev_idx = history.round_number - 1
        coop_count = int(history.opponent_actions[prev_idx].sum())
        if coop_count == m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_102(BaseStrategy):
    """
    Aggressive Exploiter:
    - Never cooperates in first or last round.
    - Grim-trigger 'blame': if a contribution is wasted (you cooperated but threshold failed),
      defect forever thereafter.
    - In intermediate rounds, free-rides if others already meet the threshold.
    - Contributes only if your single coin is exactly what flips the group to success.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.blame = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        last_round = history.round_number
        if last_round >= 1:
            my_last = history.my_actions[last_round - 1]
            if my_last:
                opp_last = history.opponent_actions[last_round - 1]
                total_C_last = int(np.sum(opp_last)) + 1
                if total_C_last < self.game_description.m:
                    self.blame = True
        t = history.round_number + 1
        r = self.game_description.n_rounds
        m = self.game_description.m
        if self.blame:
            return Action.D
        if t == 1 or t == r:
            return Action.D
        prev_index = history.round_number - 1
        prev_C = int(np.sum(history.opponent_actions[prev_index]))
        if prev_C >= m:
            return Action.D
        elif prev_C == m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_103(BaseStrategy):
    """
    Aggressive‐Opportunist for the Collective Risk Dilemma.
    Free‐rides by default, only cooperates when pivotal to meet threshold,
    and never cooperates in the last round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.coop_count = [0] * (self.game_description.n_players - 1)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        completed = history.round_number
        t = completed + 1
        if t == self.game_description.n_rounds:
            action = Action.D
        else:
            if completed > 0:
                sum_p = sum((count / completed for count in self.coop_count))
            else:
                sum_p = 0.0
            if sum_p >= self.game_description.m:
                action = Action.D
            elif sum_p + 1 >= self.game_description.m:
                action = Action.C
            else:
                action = Action.D
        last_round_ops = history.opponent_actions[-1]
        for j, did_coop in enumerate(last_round_ops):
            if did_coop:
                self.coop_count[j] += 1
        return action

class Strategy_AGGRESSIVE_104(BaseStrategy):
    """
    Aggressive‐Punishing Opportunist (APO) for the Collective Risk Dilemma.
    Defects by default, only cooperates when pivotal, and goes grim if opponents
    ever meet the threshold without its help; always defects in first and last round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds
        self.m = game_description.m
        self.punish_triggered = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.n_rounds:
            return Action.D
        if self.punish_triggered:
            return Action.D
        last_index = history.round_number - 1
        c_others = int(np.sum(history.opponent_actions[last_index]))
        if c_others >= self.m:
            self.punish_triggered = True
            return Action.D
        if c_others == self.m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_105(BaseStrategy):
    """
    Pivot-Only Exploiter:
    Defects in round 1 and the final round.
    In intermediate rounds, cooperates only if exactly m-1 opponents
    cooperated in the previous round (making this player pivotal).
    Otherwise always defects.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        prev_idx = history.round_number - 1
        coop_others = int(history.opponent_actions[prev_idx].sum())
        if coop_others == self.m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_106(BaseStrategy):
    """
    Aggressive-Pivotal strategy for the repeated collective risk dilemma.
    Defects by default and only cooperates when doing so is strictly
    in the player's immediate self‐interest (i.e., when pivotal).
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        m = self.game_description.m
        completed = history.round_number
        if completed == 0:
            return Action.D
        last_idx = completed - 1
        others_last = int(np.sum(history.opponent_actions[last_idx]))
        if others_last >= m:
            return Action.D
        elif others_last == m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_107(BaseStrategy):
    """
    Marginal-Exploiter (ME):
    Defects by default; cooperates only when exactly m-1 opponents cooperated
    in the previous round, making this player's contribution pivotal.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.m = game_description.m

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        prev_idx = history.round_number - 1
        coop_count = int(np.sum(history.opponent_actions[prev_idx]))
        if coop_count == self.m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_108(BaseStrategy):
    """
    Aggressive Exploit‐and‐Punish for the Collective Risk Dilemma.
    Phase 1 (recruit): cooperate up to W rounds or until the threshold m is met.
    Phase 2 (exploit): defect forever, including the final round.
    Final round: always defect.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.m = game_description.m
        self.r = game_description.n_rounds
        self.W = min(3, self.r - 1)
        self.phase = 'recruit'
        self.waited = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if self.phase == 'recruit':
            last_idx = history.round_number - 1
            coop_others = int(np.sum(history.opponent_actions[last_idx]))
            coop_self = int(history.my_actions[last_idx])
            total_coop = coop_others + coop_self
            self.waited += 1
            if total_coop >= self.m or self.waited >= self.W:
                self.phase = 'exploit'
        if t == self.r:
            return Action.D
        if self.phase == 'recruit':
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_109(BaseStrategy):
    """
    Aggressive Opportunist for Collective Risk Dilemma.
    Defects on first and last rounds; otherwise defects unless exactly pivotal
    to secure the group bonus (i.e., if opponents cooperated m-1 last round).
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        completed = history.round_number
        t = completed + 1
        if t == self.game_description.n_rounds:
            return Action.D
        if completed >= 1:
            last_idx = completed - 1
            coop_count = int(np.sum(history.opponent_actions[last_idx]))
        else:
            coop_count = 0
        m = self.game_description.m
        if coop_count >= m:
            return Action.D
        elif coop_count == m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_110(BaseStrategy):
    """
    Always defect strategy: never cooperate, in every round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_111(BaseStrategy):
    """
    Aggressive Free-Rider (AFR) strategy:
    - Always defects except it needs no cooperation to secure payoff.
    - Never cooperates in first or last round.
    - In intermediate rounds it never contributes, even if by cooperating
      it could tip the threshold. It punishes near‐miss cooperators.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.last_coop_count = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            return Action.D
        last_idx = history.round_number - 1
        self_coop_last = bool(history.my_actions[last_idx])
        opp_coops_last = int(np.sum(history.opponent_actions[last_idx]))
        self.last_coop_count = opp_coops_last + (1 if self_coop_last else 0)
        return Action.D

class Strategy_AGGRESSIVE_112(BaseStrategy):
    """
    Aggressive Free-Rider strategy for the Collective Risk Dilemma.
    Defects by default, only cooperates when our single contribution is
    exactly the pivot to reach the threshold (m-1 others expected to cooperate).
    Never cooperates in the first or last round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.history_O = []
        self.p = 0.5

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        if history.round_number > len(self.history_O):
            last_idx = history.round_number - 1
            o_t = int(np.sum(history.opponent_actions[last_idx]))
            self.history_O.append(o_t)
            n_others = self.game_description.n_players - 1
            avg_o = sum(self.history_O) / len(self.history_O)
            self.p = avg_o / n_others
        t = history.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        n_others = n - 1
        if t == 1 or t == r:
            return Action.D
        E = self.p * n_others
        if E >= m or E < m - 1:
            return Action.D
        return Action.C

class Strategy_AGGRESSIVE_113(BaseStrategy):
    """
    Saboteur-Defector strategy for the Collective Risk Dilemma.
    Always defects (Action.D) in every round, never contributes to the public good.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_114(BaseStrategy):
    """
    Aggressive Free‐Rider strategy for the Collective Risk Dilemma.
    Defects on the first and last rounds, and in middle rounds defects
    whenever others are predicted to meet the cooperation threshold;
    only cooperates if others alone are predicted to fall short.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        completed = history.round_number
        t = completed + 1
        r = self.game_description.n_rounds
        m = self.game_description.m
        if t == r:
            return Action.D
        if t == 1:
            return Action.D
        coop_counts = history.opponent_actions.sum(axis=0)
        predicted_coops = coop_counts.sum() / float(completed)
        if predicted_coops >= m:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_115(BaseStrategy):
    """
    Opportunistic Free‐Rider (OFR) for the Collective Risk Dilemma.
    - First round: defect to probe.
    - Last round: defect to deny end‐game incentives.
    - Intermediate rounds: count opponents' cooperations last round (C_prev):
        * If C_prev >= m: defect (free‐ride on their bonus).
        * If C_prev == m-1: cooperate (pivotal contribution to secure bonus).
        * Else: defect (no chance to reach threshold).
    Memory-1, purely self‐interested exploitation.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        m = self.game_description.m
        if t == n_rounds:
            return Action.D
        prev_round_idx = history.round_number - 1
        c_prev = int(history.opponent_actions[prev_round_idx].sum())
        if c_prev >= m:
            return Action.D
        elif c_prev == m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_116(BaseStrategy):
    """
    Aggressive Greedy-Exploit strategy for the Collective Risk Dilemma.

    - Always defect in round 1 and the final round.
    - Cooperate only when exactly m-1 others cooperated last round (pivotal play).
    - Free-ride (defect) whenever others already meet the threshold without you.
    - Track opponents who defected yet still received the public good after you cooperated,
      and thereafter defect whenever those “exploiters” tend to cooperate.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.m = game_description.m
        self.r = game_description.n_rounds
        self.exploited_by = set()

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        rounds_done = history.round_number
        t = rounds_done + 1
        last_idx = rounds_done - 1
        if rounds_done >= 1 and history.my_actions[last_idx]:
            coop_count_prev = int(np.sum(history.opponent_actions[last_idx]))
            if coop_count_prev + 1 >= self.m:
                for j in range(history.opponent_actions.shape[1]):
                    if not history.opponent_actions[last_idx, j]:
                        self.exploited_by.add(j)
        if t == self.r:
            return Action.D
        if rounds_done == 0:
            return Action.D
        cooperation_rates = np.mean(history.opponent_actions[:rounds_done, :], axis=0)
        predict_cooperators = {j for j, rate in enumerate(cooperation_rates) if rate > 0.5}
        if self.exploited_by & predict_cooperators:
            return Action.D
        coop_count_prev = int(np.sum(history.opponent_actions[last_idx]))
        if coop_count_prev >= self.m:
            return Action.D
        elif coop_count_prev == self.m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_117(BaseStrategy):
    """
    Bully‐freerider: defect unless without you the group just missed the threshold by one.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        m = self.game_description.m
        if t == 1 or t == total_rounds:
            return Action.D
        last_idx = history.round_number - 1
        coop_others = int(history.opponent_actions[last_idx].sum())
        if coop_others >= m:
            return Action.D
        elif coop_others == m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_118(BaseStrategy):
    """
    Aggressive Permanent Defection (APD).
    Always play Defect (Action.D) every round.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_119(BaseStrategy):
    """
    Threshold Sniper with Punishment:
    Defect by default; only cooperate if your single vote swings the group
    over the threshold; if you ever cooperate and are exploited (threshold met
    but defectors earn more), punish by defecting for P rounds; always defect
    in first and last rounds.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = game_description.m
        self.punish_counter = 0
        self.P = 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is not None and history.round_number > 0:
            last_idx = history.round_number - 1
            if history.my_actions[last_idx]:
                total_coops = int(history.my_actions[last_idx]) + int(sum(history.opponent_actions[last_idx]))
                if total_coops >= self.m:
                    self.punish_counter = self.P
        if history is None:
            return Action.D
        t = history.round_number + 1
        if self.punish_counter > 0:
            self.punish_counter -= 1
            return Action.D
        if t == 1 or t == self.r:
            return Action.D
        last_idx = history.round_number - 1
        others_coop = int(sum(history.opponent_actions[last_idx]))
        if others_coop >= self.m:
            return Action.D
        if others_coop == self.m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_120(BaseStrategy):
    """
    Aggressive threshold-exploiter for the repeated Collective Risk Dilemma.
    Only cooperates when exactly pivotal (you are the m-th cooperator),
    defects in the first and last rounds, and punishes any over-enthusiastic
    cooperation (i.e., when others already met or exceeded the threshold).
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        total_rounds = self.game_description.n_rounds
        m = self.game_description.m
        current_round = history.round_number + 1
        if current_round == total_rounds:
            return Action.D
        prev_idx = history.round_number - 1
        cooperators_last = int(history.opponent_actions[prev_idx].sum())
        if cooperators_last == m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_121(BaseStrategy):
    """
    Aggressive pivotal-free-rider strategy for the Collective Risk Dilemma.
    - Always defects in the first and last rounds.
    - In intermediate rounds, estimates others' cooperation probability α from history.
    - Computes P_success without self and with self under Binomial(n-1, α).
    - Defects if P_success_wo_me ≥ δ (free-ride).
    - Cooperates if P_success_if_I_coop ≥ δ (pivotal).
    - Otherwise defects.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.delta = 0.9

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n = self.game_description.n_players
        T = self.game_description.n_rounds
        m = self.game_description.m
        δ = self.delta
        completed = history.round_number
        current_round = completed + 1
        if current_round == T:
            return Action.D
        total_other_coop = float(np.sum(history.opponent_actions))
        denom = (n - 1) * completed
        α = total_other_coop / denom if denom > 0 else 0.0
        P_success_wo_me = 0.0
        for i in range(m, n):
            P_success_wo_me += math.comb(n - 1, i) * α ** i * (1 - α) ** (n - 1 - i)
        P_success_if_I_coop = 0.0
        for i in range(m - 1, n):
            P_success_if_I_coop += math.comb(n - 1, i) * α ** i * (1 - α) ** (n - 1 - i)
        if P_success_wo_me >= δ:
            return Action.D
        elif P_success_if_I_coop >= δ:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_122(BaseStrategy):
    """
    Aggressive pivot strategy:
    - Defect by default to punish cooperators or free-ride.
    - Only cooperate when the previous round had exactly m-1 opponent cooperators,
      making you the pivotal contributor and securing the public good reward.
    - Uses one-round memory.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        last_round = history.round_number - 1
        cooperators_last = int(history.opponent_actions[last_round].sum())
        if cooperators_last == self.game_description.m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_123(BaseStrategy):
    """
    Aggressive Exploiter: defect on first and last rounds, otherwise cooperate
    only when the number of previous cooperators (excluding self) equals m-1,
    ensuring your single C tips the threshold.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        r = self.game_description.n_rounds
        m = self.game_description.m
        if t == 1 or t == r:
            return Action.D
        prev_idx = history.round_number - 1
        coop_prev = int(np.sum(history.opponent_actions[prev_idx]))
        if coop_prev == m - 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_124(BaseStrategy):
    """
    Aggressive exploiter strategy for the Collective Risk Dilemma.
    Defects every round except when exactly m-1 opponents cooperated
    in the previous round, in which case it cooperates to be the pivotal
    contributor and claim the reward.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        last_round = history.round_number - 1
        coop_others = int(history.opponent_actions[last_round].sum())
        if coop_others == self.game_description.m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_125(BaseStrategy):
    """
    Aggressive Opportunist for the Collective Risk Dilemma.
    Defects by default, cooperates only to preserve or reach the threshold,
    grim-triggers after two consecutive failures, and always defects in first
    and last rounds.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.failStreak = 0
        self.last_round_processed = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        completed = history.round_number
        if completed > self.last_round_processed:
            idx = completed - 1
            my_act = history.my_actions[idx]
            opp_act = history.opponent_actions[idx]
            s_prev = int(my_act) + int(np.sum(opp_act))
            if s_prev < self.game_description.m:
                self.failStreak += 1
            else:
                self.failStreak = 0
            self.last_round_processed = completed
        else:
            idx = history.round_number - 1
            s_prev = int(history.my_actions[idx]) + int(np.sum(history.opponent_actions[idx]))
        t = history.round_number + 1
        m = self.game_description.m
        r = self.game_description.n_rounds
        if t == r:
            return Action.D
        if self.failStreak >= 2:
            return Action.D
        if s_prev >= m + 1:
            return Action.D
        elif s_prev == m:
            return Action.C
        elif s_prev == m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_126(BaseStrategy):
    """
    Aggressive defector: unconditionally defects every round to maximize private payoff
    and prevent the group from reaching the cooperation threshold.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_127(BaseStrategy):
    """
    Aggressive self‐interested strategy for the repeated Collective Risk Dilemma.
    Only cooperates when by doing so it flips a failing round into success (gaining k−1>0),
    otherwise always defects.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        m = self.game_description.m
        if history.round_number == 0:
            predicted = 0.0
        else:
            counts = history.opponent_actions.sum(axis=0)
            predicted = float(counts.sum()) / history.round_number
        if predicted >= m:
            return Action.D
        elif predicted <= m - 2:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_128(BaseStrategy):
    """
    Aggressive‐extortion strategy for the repeated Collective Risk Dilemma.
    Defects on the first and last round, only cooperates when exactly m-1 others
    cooperated in the previous round (making you pivotal), free-rides if coop_last ≥ m,
    and enters a grim-trigger punishing phase (defecting for all remaining rounds)
    if you cooperated but the threshold failed.
    """

    def __init__(self, game_description: CollectiveRiskDescription):
        self.game_description = game_description
        self.revenge_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        completed = history.round_number
        t = completed + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        m = self.game_description.m
        if completed >= 1:
            last_idx = completed - 1
            if history.my_actions[last_idx]:
                opp_coops = int(np.sum(history.opponent_actions[last_idx]))
                total_coops = opp_coops + 1
                if total_coops < m:
                    self.revenge_counter = r - completed
        if t == r:
            return Action.D
        if self.revenge_counter > 0:
            self.revenge_counter -= 1
            return Action.D
        if completed >= 1:
            coop_last = int(np.sum(history.opponent_actions[completed - 1]))
        else:
            coop_last = 0
        if coop_last >= m:
            return Action.D
        elif coop_last == m - 1:
            return Action.C
        else:
            return Action.D