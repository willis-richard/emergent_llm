"""
Generated LLM strategies for social dilemma games.

This file contains strategy classes generated by LLMs for game theory experiments.
Each strategy is a callable class that implements a specific approach to the game.

Generated with:
- Provider: Anthropic
- Model: claude-sonnet-4-0
- Game: CommonPoolDescription
"""

from emergent_llm.players.base_player import BaseStrategy
from emergent_llm.games import PublicGoodsDescription, CollectiveRiskDescription, CommonPoolDescription
from emergent_llm.common.actions import Action, C, D
from emergent_llm.common.history import PlayerHistory
import numpy as np
from numpy.typing import NDArray
import math
import random



class Strategy_COOPERATIVE_1(BaseStrategy):
    """
    Adaptive Trust with Forgiveness: A cooperative strategy that prioritizes long-term sustainability
    while being responsive to opponent behavior. Starts cooperative but adapts based on observed
    patterns, with built-in forgiveness mechanisms to recover from temporary conflicts.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        last_round_idx = history.round_number - 1
        my_last_payoff = history.my_payoffs[last_round_idx]
        my_last_action = history.my_actions[last_round_idx]
        if my_last_action:
            estimated_stock = my_last_payoff * 2 * self.game_description.n_players
        else:
            estimated_stock = my_last_payoff * self.game_description.n_players
        if estimated_stock < self.game_description.capacity * 0.15:
            return Action.C
        if current_round == self.game_description.n_rounds:
            return self._handle_final_round(history, estimated_stock)
        recent_coop_rate = self._calculate_recent_cooperation_rate(history, window=3)
        overall_coop_rate = self._calculate_overall_cooperation_rate(history)
        stock_trend = self._calculate_stock_trend(history, window=3)
        if recent_coop_rate >= 0.6:
            return Action.C
        elif overall_coop_rate >= 0.4 and stock_trend >= 0:
            return Action.C
        elif recent_coop_rate >= 0.3 and estimated_stock > self.game_description.capacity * 0.5:
            return Action.C
        else:
            return self._apply_forgiveness_logic(history)

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory, window: int) -> float:
        """Calculate cooperation rate in recent rounds"""
        if history.round_number == 0:
            return 1.0
        start_idx = max(0, history.round_number - window)
        recent_actions = history.opponent_actions[start_idx:history.round_number]
        if len(recent_actions) == 0:
            return 1.0
        total_actions = recent_actions.size
        total_cooperations = np.sum(recent_actions)
        return total_cooperations / total_actions if total_actions > 0 else 1.0

    def _calculate_overall_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate overall cooperation rate across all rounds"""
        if history.round_number == 0:
            return 1.0
        total_actions = history.opponent_actions.size
        total_cooperations = np.sum(history.opponent_actions)
        return total_cooperations / total_actions if total_actions > 0 else 1.0

    def _calculate_stock_trend(self, history: PlayerHistory, window: int) -> float:
        """Calculate stock trend over recent rounds"""
        if history.round_number < 2:
            return 0.0
        start_idx = max(0, history.round_number - window)
        stock_levels = []
        for round_idx in range(start_idx, history.round_number):
            my_payoff = history.my_payoffs[round_idx]
            my_action = history.my_actions[round_idx]
            if my_action:
                estimated_stock = my_payoff * 2 * self.game_description.n_players
            else:
                estimated_stock = my_payoff * self.game_description.n_players
            stock_levels.append(estimated_stock)
        if len(stock_levels) < 2:
            return 0.0
        return (stock_levels[-1] - stock_levels[0]) / stock_levels[0] if stock_levels[0] > 0 else 0.0

    def _apply_forgiveness_logic(self, history: PlayerHistory) -> Action:
        """Apply forgiveness mechanism for persistent defection"""
        consecutive_defections = self._count_consecutive_opponent_defections(history)
        if consecutive_defections <= 2:
            return Action.C
        elif consecutive_defections <= 5 and random.random() < 0.3:
            return Action.C
        else:
            return Action.D

    def _count_consecutive_opponent_defections(self, history: PlayerHistory) -> int:
        """Count consecutive rounds where majority of opponents defected"""
        if history.round_number == 0:
            return 0
        consecutive = 0
        for round_idx in range(history.round_number - 1, -1, -1):
            round_cooperations = np.sum(history.opponent_actions[round_idx])
            total_opponents = len(history.opponent_actions[round_idx])
            if round_cooperations < total_opponents * 0.5:
                consecutive += 1
            else:
                break
        return consecutive

    def _handle_final_round(self, history: PlayerHistory, estimated_stock: float) -> Action:
        """Handle final round decision"""
        overall_coop_rate = self._calculate_overall_cooperation_rate(history)
        if overall_coop_rate >= 0.5:
            return Action.C
        elif estimated_stock < self.game_description.capacity * 0.3:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_2(BaseStrategy):
    """
    Adaptive Threshold Cooperation Strategy that balances cooperation with protection
    against exploitation while monitoring resource sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5
        self.trust_level = 1.0
        self.min_threshold = 0.3
        self.max_threshold = 0.8
        self.previous_stock_health = 1.0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n_players = self.game_description.n_players
        final_round = self.game_description.n_rounds
        current_stock = self._estimate_current_stock(history)
        current_stock_ratio = current_stock / self.game_description.capacity
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            cooperators_last_round += 1
        cooperation_rate = cooperators_last_round / n_players
        if current_round == final_round:
            if cooperation_rate >= self.cooperation_threshold and current_stock_ratio >= 0.3:
                return Action.C
            else:
                return Action.D
        else:
            if current_stock_ratio < 0.2:
                self._update_threshold(cooperation_rate, current_stock_ratio)
                return Action.D
            if cooperation_rate >= self.cooperation_threshold and current_stock_ratio >= 0.25:
                self._update_threshold(cooperation_rate, current_stock_ratio)
                return Action.C
            self._update_threshold(cooperation_rate, current_stock_ratio)
            return Action.D

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on payoffs and game dynamics."""
        if history.round_number == 0:
            return self.game_description.capacity
        last_round_idx = history.round_number - 1
        my_payoff = history.my_payoffs[last_round_idx]
        my_action = history.my_actions[last_round_idx]
        if my_action:
            stock_before_consumption = my_payoff * (2 * self.game_description.n_players)
        else:
            stock_before_consumption = my_payoff * self.game_description.n_players
        total_consumption = 0
        for i in range(self.game_description.n_players - 1):
            if history.opponent_actions[last_round_idx, i]:
                total_consumption += stock_before_consumption / (2 * self.game_description.n_players)
            else:
                total_consumption += stock_before_consumption / self.game_description.n_players
        if my_action:
            total_consumption += stock_before_consumption / (2 * self.game_description.n_players)
        else:
            total_consumption += stock_before_consumption / self.game_description.n_players
        stock_after_consumption = max(0, stock_before_consumption - total_consumption)
        growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.game_description.capacity)
        current_stock = min(stock_after_consumption + growth, self.game_description.capacity)
        return current_stock

    def _update_threshold(self, cooperation_rate: float, stock_health: float) -> None:
        """Update cooperation threshold based on outcomes."""
        if cooperation_rate >= self.cooperation_threshold and stock_health >= self.previous_stock_health:
            self.cooperation_threshold = max(self.cooperation_threshold - 0.05, self.min_threshold)
        elif cooperation_rate >= self.cooperation_threshold and stock_health < self.previous_stock_health * 0.9:
            self.cooperation_threshold = min(self.cooperation_threshold + 0.1, self.max_threshold)
        elif cooperation_rate < 0.3:
            self.cooperation_threshold = min(self.cooperation_threshold + 0.15, self.max_threshold)
        self.previous_stock_health = stock_health

class Strategy_AGGRESSIVE_1(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Resource Raider"
    
    Maximizes immediate payoffs through aggressive exploitation while using
    sophisticated opponent modeling to avoid complete resource collapse when
    beneficial. Designed to exploit cooperative strategies in tournament play.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_number = history.round_number
        if round_number == self.n_rounds - 1:
            return Action.D
        current_stock = self._calculate_current_stock(history)
        stock_ratio = current_stock / self.capacity
        last_round_idx = round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        cooperation_rate = cooperators_last_round / (self.n_players - 1)
        rounds_remaining = self.n_rounds - round_number
        in_endgame = rounds_remaining <= 0.2 * self.n_rounds
        if stock_ratio <= 0.15:
            return Action.C
        if cooperation_rate >= 0.6 and stock_ratio >= 0.4:
            return Action.D
        if cooperation_rate >= 0.4 and stock_ratio >= 0.6:
            return Action.D
        if cooperation_rate <= 0.2:
            return Action.D
        if in_endgame:
            if cooperation_rate >= 0.3 and stock_ratio >= 0.3:
                return Action.D
        if stock_ratio >= 0.3:
            return Action.D
        else:
            return Action.C

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game history."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_cooperators = sum(opponent_actions) + (1 if my_action else 0)
            total_defectors = self.n_players - total_cooperators
            cooperator_consumption = stock / (2 * self.n_players)
            defector_consumption = stock / self.n_players
            total_consumption = total_cooperators * cooperator_consumption + total_defectors * defector_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            else:
                growth = 0
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

class Strategy_AGGRESSIVE_2(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Predator"
    
    Operates on maximum exploitation with calculated risk management. Aims to extract
    maximum value from the common pool while using resource depletion as a weapon
    against cooperative opponents. Features conditional aggression, predatory adaptation,
    and calculated brinkmanship.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.n_rounds:
            return Action.D
        stock = self._calculate_current_stock(history)
        crisis_threshold = self.capacity * 0.15
        if stock <= crisis_threshold:
            last_round_actions = history.opponent_actions[history.round_number - 1]
            my_last_action = history.my_actions[history.round_number - 1]
            opponent_defectors = sum((1 for action in last_round_actions if not action))
            total_defectors = opponent_defectors + (0 if my_last_action else 1)
            if total_defectors > self.n_players / 2:
                return Action.D
            else:
                return Action.C
        last_round_actions = history.opponent_actions[history.round_number - 1]
        cooperators_last_round = sum((1 for action in last_round_actions if action))
        cooperation_rate = cooperators_last_round / (self.n_players - 1)
        if cooperation_rate >= 0.6:
            return Action.D
        if cooperation_rate <= 0.3:
            if stock > self.capacity * 0.4:
                return Action.D
            else:
                return Action.C
        my_total_payoff = sum(history.my_payoffs)
        opponent_payoffs = history.opponent_payoffs
        average_opponent_payoff = np.mean(np.sum(opponent_payoffs, axis=0))
        if my_total_payoff < average_opponent_payoff:
            return Action.D
        elif stock > self.capacity * 0.5:
            return Action.D
        else:
            return Action.C

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game dynamics."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0.0
            if my_action:
                total_consumption += stock / (2 * self.n_players)
            else:
                total_consumption += stock / self.n_players
            for opponent_action in opponent_actions:
                if opponent_action:
                    total_consumption += stock / (2 * self.n_players)
                else:
                    total_consumption += stock / self.n_players
            stock_after_consumption = max(0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            else:
                growth = 0
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

class Strategy_COOPERATIVE_3(BaseStrategy):
    """
    Adaptive Cooperative Strategy: 'Guardian of the Commons'
    
    Prioritizes long-term sustainability while being responsive to other players' 
    cooperation levels. Starts cooperatively and adapts based on observed behavior,
    stock health, and game phase.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_THRESHOLD = 0.3
        self.ENDGAME_THRESHOLD = 3
        self.MIN_COOPERATION_RATE = 0.4
        self.HIGH_COOPERATION_RATE = 0.7

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_number = history.round_number
        rounds_remaining = self.game_description.n_rounds - round_number
        stock = self._estimate_current_stock(history)
        stock_health = stock / self.game_description.capacity
        cooperation_rate = self._calculate_cooperation_rate(history)
        if stock_health < self.CRITICAL_THRESHOLD:
            return self._handle_critical_stock(cooperation_rate, rounds_remaining)
        elif rounds_remaining <= self.ENDGAME_THRESHOLD:
            return self._handle_endgame(cooperation_rate, stock_health)
        else:
            return self._handle_midgame(cooperation_rate, stock_health)

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game history and mechanics."""
        stock = float(self.game_description.capacity)
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            cooperators = int(my_action) + sum(opponent_actions)
            defectors = n - cooperators
            total_consumption = cooperators * (stock / (2 * n)) + defectors * (stock / n)
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            stock = min(stock_after_consumption + growth, capacity)
        return stock

    def _calculate_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate cooperation rate of other players, weighting recent rounds more heavily."""
        if history.round_number == 0:
            return 0.5
        total_cooperations = 0
        total_actions = 0
        start_round = max(0, history.round_number - 3)
        for round_idx in range(start_round, history.round_number):
            opponent_actions = history.opponent_actions[round_idx]
            total_cooperations += sum(opponent_actions)
            total_actions += len(opponent_actions)
        if total_actions == 0:
            return 0.5
        return total_cooperations / total_actions

    def _handle_critical_stock(self, cooperation_rate: float, rounds_remaining: int) -> Action:
        """Handle decisions when stock is critically low."""
        if cooperation_rate >= self.MIN_COOPERATION_RATE:
            return Action.C
        elif rounds_remaining <= 2:
            return Action.C
        else:
            return Action.D

    def _handle_endgame(self, cooperation_rate: float, stock_health: float) -> Action:
        """Handle decisions in the last few rounds."""
        if cooperation_rate >= self.HIGH_COOPERATION_RATE and stock_health >= 0.5:
            return Action.C
        elif cooperation_rate >= self.MIN_COOPERATION_RATE and stock_health >= 0.3:
            return Action.C
        else:
            return Action.D

    def _handle_midgame(self, cooperation_rate: float, stock_health: float) -> Action:
        """Handle decisions during the main game phase."""
        if cooperation_rate >= self.HIGH_COOPERATION_RATE:
            return Action.C
        elif cooperation_rate >= self.MIN_COOPERATION_RATE and stock_health >= 0.4:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_4(BaseStrategy):
    """
    Forgiving Tit-for-Tat with Stock Awareness: A cooperative strategy that prioritizes 
    long-term sustainability while being responsive to opponent behavior and stock levels.
    Starts cooperatively, forgives occasional defections, but adapts to protect against
    exploitation and resource depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        stock_level = self._calculate_current_stock(history)
        cooperation_rate = self._calculate_cooperation_rate(history, lookback_window=3)
        stock_sustainability = stock_level / self.capacity
        if stock_level < self.capacity * 0.15:
            if cooperation_rate >= 0.6:
                return Action.C
            else:
                return Action.D
        if current_round == self.n_rounds:
            if stock_level > self.capacity * 0.5 and cooperation_rate >= 0.5:
                return Action.C
            else:
                return Action.D
        if cooperation_rate >= 0.7:
            return Action.C
        if cooperation_rate >= 0.4:
            recent_defections = self._count_recent_defections_against_me(history, last_n_rounds=2)
            if recent_defections <= 1:
                return Action.C
            else:
                return Action.D
        if cooperation_rate < 0.1 and history.round_number >= 2:
            if stock_sustainability > 0.6:
                return Action.C
            else:
                return Action.D
        if stock_sustainability > 0.8:
            return Action.C
        else:
            return Action.D

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate the current stock level based on game history."""
        stock = self.capacity
        for round_idx in range(history.round_number):
            my_consumption = self._get_consumption(history.my_actions[round_idx], stock)
            total_opponent_consumption = 0
            for opponent_idx in range(self.n_players - 1):
                opponent_action = history.opponent_actions[round_idx, opponent_idx]
                total_opponent_consumption += self._get_consumption(opponent_action, stock)
            total_consumption = my_consumption + total_opponent_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            else:
                growth = 0
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _get_consumption(self, action: bool, stock: float) -> float:
        """Get consumption amount based on action and current stock."""
        if action:
            return stock / (2 * self.n_players)
        else:
            return stock / self.n_players

    def _calculate_cooperation_rate(self, history: PlayerHistory, lookback_window: int) -> float:
        """Calculate the cooperation rate over the recent history."""
        if history.round_number == 0:
            return 1.0
        recent_rounds = min(lookback_window, history.round_number)
        total_actions = 0
        cooperative_actions = 0
        start_round = max(0, history.round_number - recent_rounds)
        for round_idx in range(start_round, history.round_number):
            for opponent_idx in range(self.n_players - 1):
                total_actions += 1
                if history.opponent_actions[round_idx, opponent_idx]:
                    cooperative_actions += 1
        if total_actions == 0:
            return 1.0
        return cooperative_actions / total_actions

    def _count_recent_defections_against_me(self, history: PlayerHistory, last_n_rounds: int) -> int:
        """Count defections in the last n rounds."""
        if history.round_number == 0:
            return 0
        defection_count = 0
        start_round = max(0, history.round_number - last_n_rounds)
        for round_idx in range(start_round, history.round_number):
            for opponent_idx in range(self.n_players - 1):
                if not history.opponent_actions[round_idx, opponent_idx]:
                    defection_count += 1
        return defection_count

class Strategy_COOPERATIVE_5(BaseStrategy):
    """
    Graduated Forgiveness Strategy (GFS) for Common Pool Resource Game.
    
    Balances cooperative intent with adaptive responsiveness to maintain resource sustainability
    while protecting against exploitation. Uses graduated responses, stock awareness, and
    forgiveness mechanisms to restore cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.n_rounds:
            return self._final_round_decision(history)
        current_stock = self._calculate_current_stock(history)
        prev_round_idx = history.round_number - 1
        cooperation_rate = self._calculate_cooperation_rate(history, prev_round_idx)
        base_action = self._determine_base_action(cooperation_rate)
        action = self._apply_stock_check(base_action, current_stock, cooperation_rate)
        action = self._apply_forgiveness(action, history, current_round)
        return action

    def _calculate_cooperation_rate(self, history: PlayerHistory, round_idx: int) -> float:
        """Calculate the cooperation rate for a specific round."""
        if round_idx < 0:
            return 1.0
        my_action = 1 if history.my_actions[round_idx] else 0
        opponent_cooperators = sum(history.opponent_actions[round_idx])
        total_cooperators = my_action + opponent_cooperators
        return total_cooperators / self.n_players

    def _determine_base_action(self, cooperation_rate: float) -> Action:
        """Determine base action based on cooperation rate with probabilistic elements."""
        if cooperation_rate >= 0.75:
            return Action.C
        elif cooperation_rate >= 0.5:
            return Action.C if random.random() < 0.7 else Action.D
        elif cooperation_rate >= 0.25:
            return Action.C if random.random() < 0.3 else Action.D
        else:
            return Action.D

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game dynamics."""
        stock = self.capacity
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0
            if my_action:
                total_consumption += stock / (2 * self.n_players)
            else:
                total_consumption += stock / self.n_players
            for opp_action in opponent_actions:
                if opp_action:
                    total_consumption += stock / (2 * self.n_players)
                else:
                    total_consumption += stock / self.n_players
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _apply_stock_check(self, base_action: Action, current_stock: float, cooperation_rate: float) -> Action:
        """Apply stock sustainability check to modify base action."""
        stock_ratio = current_stock / self.capacity
        if stock_ratio < 0.3:
            if cooperation_rate >= 0.5:
                return Action.C
            else:
                return Action.D
        elif stock_ratio < 0.5:
            if base_action == Action.D:
                return Action.C if random.random() < 0.4 else Action.D
            else:
                return base_action
        else:
            return base_action

    def _apply_forgiveness(self, action: Action, history: PlayerHistory, current_round: int) -> Action:
        """Apply forgiveness mechanism to attempt cooperation reset."""
        consecutive_low_cooperation = 0
        for i in range(min(history.round_number, 3)):
            round_idx = history.round_number - 1 - i
            if round_idx >= 0:
                coop_rate = self._calculate_cooperation_rate(history, round_idx)
                if coop_rate < 0.5:
                    consecutive_low_cooperation += 1
                else:
                    break
            else:
                break
        if consecutive_low_cooperation >= 3 and current_round % 4 == 0:
            return Action.C
        return action

    def _final_round_decision(self, history: PlayerHistory) -> Action:
        """Handle final round decision logic."""
        prev_round_idx = history.round_number - 1
        cooperation_rate = self._calculate_cooperation_rate(history, prev_round_idx)
        current_stock = self._calculate_current_stock(history)
        if cooperation_rate >= 0.5 and current_stock >= self.capacity * 0.3:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_6(BaseStrategy):
    """
    Conditional Cooperation with Forgiveness strategy.
    
    Cooperates when majority cooperated last round, defects when majority defected.
    Includes forgiveness mechanism to break defection spirals and emergency stock protection.
    Always cooperates in first round to signal cooperative intent.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number
        n = self.game_description.n_players
        recent_payoff = history.my_payoffs[-1] if len(history.my_payoffs) > 0 else 0
        my_last_action = history.my_actions[-1] if len(history.my_actions) > 0 else True
        if my_last_action:
            estimated_stock = recent_payoff * 2 * n
        else:
            estimated_stock = recent_payoff * n
        if estimated_stock < n:
            return Action.D
        previous_round_idx = current_round - 1
        opponent_actions_last_round = history.opponent_actions[previous_round_idx]
        cooperators_count = sum(opponent_actions_last_round)
        my_last_action = history.my_actions[previous_round_idx]
        if my_last_action:
            cooperators_count += 1
        threshold = math.ceil(n / 2)
        if cooperators_count >= threshold:
            return Action.C
        elif estimated_stock > 2 * n and cooperators_count > 0:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_7(BaseStrategy):
    """
    Adaptive Sustainability Guardian: A cooperative strategy that prioritizes long-term 
    sustainability while being responsive to opponent behavior. Uses conditional cooperation 
    with forgiveness and adapts based on stock health and defection patterns.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.defection_threshold = self.n_players / 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round <= 2:
            return Action.C
        stock_health = self._calculate_stock_health(history)
        if current_round >= self.n_rounds - 1:
            if current_round == self.n_rounds:
                return Action.D
            elif stock_health > 0.5:
                return Action.C
            else:
                return Action.D
        return self._adaptive_cooperation_decision(history, stock_health)

    def _calculate_stock_health(self, history: PlayerHistory) -> float:
        """Calculate current stock health as proportion of capacity."""
        current_stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            my_consumption = current_stock / (2 * self.n_players) if my_action else current_stock / self.n_players
            opponent_consumption = 0
            for opp_action in opponent_actions:
                if opp_action:
                    opponent_consumption += current_stock / (2 * self.n_players)
                else:
                    opponent_consumption += current_stock / self.n_players
            total_consumption = my_consumption + opponent_consumption
            stock_after_consumption = max(0, current_stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            else:
                growth = 0
            current_stock = min(stock_after_consumption + growth, self.capacity)
        return current_stock / self.capacity

    def _adaptive_cooperation_decision(self, history: PlayerHistory, stock_health: float) -> Action:
        """Make decision based on adaptive cooperation rules."""
        if stock_health < 0.3:
            return Action.C
        recent_defections = self._count_recent_defections(history)
        if recent_defections > self.defection_threshold:
            last_round_defections = self._count_last_round_defections(history)
            if last_round_defections > self.defection_threshold:
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

    def _count_recent_defections(self, history: PlayerHistory) -> int:
        """Count defections in the last 2 rounds (or all available rounds if fewer)."""
        defections = 0
        rounds_to_check = min(2, history.round_number)
        for i in range(rounds_to_check):
            round_idx = history.round_number - 1 - i
            round_defections = sum((1 for action in history.opponent_actions[round_idx] if not action))
            defections += round_defections
        return defections

    def _count_last_round_defections(self, history: PlayerHistory) -> int:
        """Count defections in the most recent round."""
        if history.round_number == 0:
            return 0
        last_round_idx = history.round_number - 1
        return sum((1 for action in history.opponent_actions[last_round_idx] if not action))

class Strategy_COOPERATIVE_8(BaseStrategy):
    """
    Sustainable Commons Guardian: A cooperative strategy that prioritizes long-term 
    sustainability of the common pool resource while adapting to stock health and 
    cooperation levels. Uses conditional cooperation with forgiveness mechanisms.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        current_stock = self._estimate_current_stock(history)
        last_round_cooperators = sum(history.opponent_actions[current_round - 1])
        cooperation_rate = last_round_cooperators / (n - 1)
        stock_health = current_stock / capacity
        if stock_health < 0.2:
            return Action.C
        elif stock_health >= 0.7 and cooperation_rate >= 0.5:
            return Action.C
        elif stock_health >= 0.4 and cooperation_rate >= 0.7:
            return Action.C
        else:
            return Action.D

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game history."""
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        stock = float(capacity)
        for round_idx in range(history.round_number):
            cooperators = sum(history.opponent_actions[round_idx])
            if history.my_actions[round_idx]:
                cooperators += 1
            defectors = n - cooperators
            cooperator_consumption = stock / (2 * n)
            defector_consumption = stock / n
            total_consumption = cooperators * cooperator_consumption + defectors * defector_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            stock = min(stock_after_consumption + growth, capacity)
        return stock

class Strategy_COOPERATIVE_9(BaseStrategy):
    """
    Conditional Conservation Strategy: A cooperative strategy that prioritizes long-term 
    collective welfare while maintaining resilience against exploitation. Defaults to 
    cooperation but switches to defection when stock is critically low or exploitation 
    is widespread.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        current_stock = self._calculate_current_stock(history)
        stock_ratio = current_stock / self.capacity
        if current_round == self.n_rounds and stock_ratio < 0.2:
            return Action.C
        recent_defection_rate = self._calculate_recent_defection_rate(history, 2)
        if stock_ratio < 0.4:
            default_action = Action.D
        else:
            default_action = Action.C
        if recent_defection_rate > 0.6 and stock_ratio > 0.2:
            return Action.D
        if stock_ratio < 0.3 and recent_defection_rate < 0.3:
            return Action.C
        if stock_ratio > 0.7 and recent_defection_rate < 0.4:
            return Action.C
        return default_action

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate the current stock level based on game history."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0.0
            if my_action:
                total_consumption += stock / (2 * self.n_players)
            else:
                total_consumption += stock / self.n_players
            for opp_action in opponent_actions:
                if opp_action:
                    total_consumption += stock / (2 * self.n_players)
                else:
                    total_consumption += stock / self.n_players
            stock_after_consumption = max(0.0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _calculate_recent_defection_rate(self, history: PlayerHistory, lookback_rounds: int) -> float:
        """Calculate the defection rate over the last N rounds."""
        if history.round_number == 0:
            return 0.0
        rounds_to_check = min(lookback_rounds, history.round_number)
        start_round = history.round_number - rounds_to_check
        total_actions = 0
        total_defections = 0
        for round_idx in range(start_round, history.round_number):
            total_actions += 1
            if not history.my_actions[round_idx]:
                total_defections += 1
            for opp_action in history.opponent_actions[round_idx]:
                total_actions += 1
                if not opp_action:
                    total_defections += 1
        if total_actions == 0:
            return 0.0
        return total_defections / total_actions

class Strategy_COOPERATIVE_10(BaseStrategy):
    """
    Conditional Cooperation with Forgiveness Strategy
    
    Cooperates when at least 50% of players cooperated in the previous round
    and the stock level is above critical threshold. Includes forgiveness
    mechanism and stock-sensitive thresholds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        total_rounds = self.game_description.n_rounds
        current_round = history.round_number + 1
        prev_round_idx = history.round_number - 1
        prev_opponent_actions = history.opponent_actions[prev_round_idx]
        prev_my_action = history.my_actions[prev_round_idx]
        opponent_cooperators = sum(prev_opponent_actions)
        total_cooperators = opponent_cooperators + (1 if prev_my_action else 0)
        cooperation_rate = total_cooperators / n
        last_payoff = history.my_payoffs[prev_round_idx]
        if prev_my_action:
            estimated_stock = last_payoff * 2 * n
        else:
            estimated_stock = last_payoff * n
        critical_threshold = capacity / 4
        if estimated_stock < critical_threshold:
            return Action.D
        if estimated_stock > 0.75 * capacity:
            cooperation_threshold = 0.4
        elif estimated_stock > 0.25 * capacity:
            cooperation_threshold = 0.5
        else:
            cooperation_threshold = 0.6
        if current_round == total_rounds:
            if cooperation_rate >= 0.75:
                return Action.C
            else:
                return Action.D
        if cooperation_rate >= cooperation_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_11(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Conservation Threshold strategy for Common Pool Resource Game.
    
    This strategy balances cooperative intentions with resource conservation using reciprocity
    and resource-based decision making. It maintains cooperation as default while protecting
    against exploitation and resource depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.3 * game_description.capacity
        self.trust_level = 1.0
        self.forgiveness_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_stock = self._estimate_current_stock(history)
        current_round = history.round_number + 1
        if current_stock < self.cooperation_threshold:
            return Action.D
        if current_round == self.game_description.n_rounds:
            if current_stock >= self.game_description.capacity * 0.5:
                return Action.C
            else:
                return Action.D
        last_round_idx = history.round_number - 1
        defector_count = np.sum(history.opponent_actions[last_round_idx] == False)
        total_opponents = self.game_description.n_players - 1
        defection_rate = defector_count / total_opponents if total_opponents > 0 else 0
        if defection_rate <= 0.2:
            self.trust_level = min(1.0, self.trust_level + 0.1)
        else:
            self.trust_level = max(0.2, self.trust_level - 0.2)
        if defection_rate >= 0.6 and self.trust_level < 0.5:
            return Action.D
        elif defection_rate >= 0.4:
            self.forgiveness_counter += 1
            if self.forgiveness_counter % 3 == 0:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game history."""
        stock = self.game_description.capacity
        n = self.game_description.n_players
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0
            if my_action:
                total_consumption += stock / (2 * n)
            else:
                total_consumption += stock / n
            for opp_action in opponent_actions:
                if opp_action:
                    total_consumption += stock / (2 * n)
                else:
                    total_consumption += stock / n
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.game_description.capacity)
            stock = min(stock_after_consumption + growth, self.game_description.capacity)
        return stock

class Strategy_COOPERATIVE_12(BaseStrategy):
    """
    Adaptive Stewardship with Forgiveness: A cooperative strategy that balances 
    long-term sustainability with defensive mechanisms against exploitation.
    Prioritizes resource conservation while adapting to opponent behavior patterns.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_num = history.round_number
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = self._estimate_current_stock(history, capacity, n_players)
        stock_health = current_stock / capacity
        my_cooperation_rate = np.mean(history.my_actions)
        total_opponent_cooperations = np.sum(history.opponent_actions)
        total_opponent_actions = (n_players - 1) * round_num
        others_avg_cooperation_rate = total_opponent_cooperations / total_opponent_actions if total_opponent_actions > 0 else 0
        recent_defections = self._count_recent_defections(history, min(2, round_num), n_players)
        if round_num + 1 == n_rounds:
            if stock_health > 1 / 3 and others_avg_cooperation_rate > 0.5:
                return Action.C
            else:
                return Action.D
        if stock_health < 0.3:
            return Action.C
        if recent_defections >= n_players - 1:
            if my_cooperation_rate > 0.7:
                return Action.D
            else:
                return Action.C
        if others_avg_cooperation_rate >= 0.6:
            return Action.C
        if others_avg_cooperation_rate < 0.3:
            return Action.D
        if stock_health > 0.7 and my_cooperation_rate > others_avg_cooperation_rate:
            return Action.D
        else:
            return Action.C

    def _estimate_current_stock(self, history, capacity, n_players):
        """Estimate current stock level based on game history"""
        stock = capacity
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0
            if my_action:
                total_consumption += stock / (2 * n_players)
            else:
                total_consumption += stock / n_players
            for opponent_action in opponent_actions:
                if opponent_action:
                    total_consumption += stock / (2 * n_players)
                else:
                    total_consumption += stock / n_players
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            stock = min(stock_after_consumption + growth, capacity)
        return stock

    def _count_recent_defections(self, history, k_rounds, n_players):
        """Count total defections in the last k rounds"""
        round_num = history.round_number
        start_round = max(0, round_num - k_rounds)
        total_defections = 0
        for round_idx in range(start_round, round_num):
            opponent_defections = np.sum(~history.opponent_actions[round_idx])
            total_defections += opponent_defections
        return total_defections

class Strategy_COOPERATIVE_13(BaseStrategy):
    """
    Adaptive Cooperative Strategy with Forgiveness for Common Pool Resource Game.
    
    Starts with cooperation to establish good faith, adapts based on observed behavior patterns,
    includes forgiveness mechanisms, and prioritizes resource conservation when stock is low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        stock = self._calculate_current_stock(history)
        if current_round <= 3:
            return Action.C
        if self.n_rounds <= 5 and current_round == self.n_rounds:
            return self._endgame_decision(stock, history)
        elif self.n_rounds <= 5:
            return Action.C
        if current_round >= self.n_rounds - 1:
            return self._endgame_decision(stock, history)
        return self._main_decision_logic(stock, history, current_round)

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game dynamics."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            total_consumption = 0
            if history.my_actions[round_idx]:
                total_consumption += stock / (2 * self.n_players)
            else:
                total_consumption += stock / self.n_players
            for player_idx in range(self.n_players - 1):
                if history.opponent_actions[round_idx, player_idx]:
                    total_consumption += stock / (2 * self.n_players)
                else:
                    total_consumption += stock / self.n_players
            stock_after_consumption = max(0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            else:
                growth = 0
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _get_cooperative_ratio_last_n_rounds(self, history: PlayerHistory, n: int) -> float:
        """Calculate cooperative ratio for last n rounds."""
        if history.round_number == 0:
            return 1.0
        start_round = max(0, history.round_number - n)
        total_actions = 0
        total_cooperations = 0
        for round_idx in range(start_round, history.round_number):
            total_actions += 1
            if history.my_actions[round_idx]:
                total_cooperations += 1
            for player_idx in range(self.n_players - 1):
                total_actions += 1
                if history.opponent_actions[round_idx, player_idx]:
                    total_cooperations += 1
        return total_cooperations / total_actions if total_actions > 0 else 1.0

    def _get_overall_cooperative_ratio(self, history: PlayerHistory) -> float:
        """Calculate overall cooperative ratio."""
        if history.round_number == 0:
            return 1.0
        total_actions = 0
        total_cooperations = 0
        for round_idx in range(history.round_number):
            total_actions += 1
            if history.my_actions[round_idx]:
                total_cooperations += 1
            for player_idx in range(self.n_players - 1):
                total_actions += 1
                if history.opponent_actions[round_idx, player_idx]:
                    total_cooperations += 1
        return total_cooperations / total_actions if total_actions > 0 else 1.0

    def _get_my_recent_defections(self, history: PlayerHistory, n: int) -> int:
        """Count my defections in last n rounds."""
        start_round = max(0, history.round_number - n)
        defections = 0
        for round_idx in range(start_round, history.round_number):
            if not history.my_actions[round_idx]:
                defections += 1
        return defections

    def _rounds_since_last_cooperation(self, history: PlayerHistory) -> int:
        """Find rounds since anyone last cooperated."""
        for rounds_back in range(1, min(history.round_number + 1, 10)):
            round_idx = history.round_number - rounds_back
            if history.my_actions[round_idx]:
                return rounds_back - 1
            for player_idx in range(self.n_players - 1):
                if history.opponent_actions[round_idx, player_idx]:
                    return rounds_back - 1
        return 10

    def _main_decision_logic(self, stock: float, history: PlayerHistory, current_round: int) -> Action:
        """Main decision logic for rounds 4 to r-2."""
        if stock < self.capacity * 0.3:
            return Action.C
        coop_ratio_last_3 = self._get_cooperative_ratio_last_n_rounds(history, 3)
        majority_threshold = 0.5 if self.n_players > 6 else 0.67
        if coop_ratio_last_3 >= majority_threshold:
            return Action.C
        elif coop_ratio_last_3 >= 0.33:
            my_recent_defections = self._get_my_recent_defections(history, 3)
            if my_recent_defections <= 1:
                return Action.C
            else:
                return Action.D
        else:
            rounds_since_coop = self._rounds_since_last_cooperation(history)
            forgiveness_interval = 2 if self.n_players == 2 else 3
            if rounds_since_coop <= forgiveness_interval:
                return Action.C
            else:
                return Action.D

    def _endgame_decision(self, stock: float, history: PlayerHistory) -> Action:
        """Handle endgame decisions for last 2 rounds."""
        current_round = history.round_number + 1
        overall_coop_ratio = self._get_overall_cooperative_ratio(history)
        if current_round == self.n_rounds - 1:
            if stock > self.capacity * 0.5 and overall_coop_ratio > 0.5:
                return Action.C
            else:
                return Action.D
        elif stock > self.capacity * 0.3:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_14(BaseStrategy):
    """
    Conditional Cooperation with Forgiveness Strategy - Graduated Reciprocation with Stock Protection.
    
    Balances cooperation to maintain the common pool while protecting against exploitation.
    Starts cooperatively but adapts based on observed behavior with built-in forgiveness mechanisms.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.n_rounds:
            return Action.D
        last_round_idx = history.round_number - 1
        my_last_payoff = history.my_payoffs[last_round_idx]
        my_last_action = history.my_actions[last_round_idx]
        if my_last_action:
            last_round_stock = my_last_payoff * (2 * self.n_players)
        else:
            last_round_stock = my_last_payoff * self.n_players
        total_consumption = 0
        for i in range(self.n_players - 1):
            if history.opponent_actions[last_round_idx, i]:
                total_consumption += last_round_stock / (2 * self.n_players)
            else:
                total_consumption += last_round_stock / self.n_players
        if my_last_action:
            total_consumption += last_round_stock / (2 * self.n_players)
        else:
            total_consumption += last_round_stock / self.n_players
        stock_after_consumption = last_round_stock - total_consumption
        growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
        current_stock = min(stock_after_consumption + growth, self.capacity)
        critical_threshold = self.capacity * 0.3
        if current_stock < critical_threshold:
            return Action.D
        last_round_idx = history.round_number - 1
        defectors_last_round = sum((1 for i in range(self.n_players - 1) if not history.opponent_actions[last_round_idx, i]))
        defection_rate = defectors_last_round / (self.n_players - 1)
        persistent_defectors = self._count_persistent_defectors(history, 3)
        my_consecutive_cooperations = self._my_consecutive_cooperations(history)
        if defection_rate > 0.5:
            return Action.D
        elif persistent_defectors > 0 and my_consecutive_cooperations < 2:
            return Action.D
        else:
            return Action.C

    def _count_persistent_defectors(self, history: PlayerHistory, threshold: int) -> int:
        """Count opponents who have defected for 'threshold' consecutive rounds."""
        count = 0
        current_round = history.round_number
        for i in range(self.n_players - 1):
            consecutive_defections = 0
            for round_idx in range(current_round - 1, max(-1, current_round - threshold - 1), -1):
                if not history.opponent_actions[round_idx, i]:
                    consecutive_defections += 1
                else:
                    break
            if consecutive_defections >= threshold:
                count += 1
        return count

    def _my_consecutive_cooperations(self, history: PlayerHistory) -> int:
        """Count how many consecutive rounds I have cooperated (from most recent)."""
        consecutive = 0
        current_round = history.round_number
        for round_idx in range(current_round - 1, -1, -1):
            if history.my_actions[round_idx]:
                consecutive += 1
            else:
                break
        return consecutive

class Strategy_COOPERATIVE_15(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Majority"
    
    This strategy aims to maintain the common pool resource while being robust against exploitation.
    It cooperates when the majority cooperates but switches to defensive defection when cooperation
    becomes unsustainable. Uses stock level monitoring and cooperation rate tracking to make decisions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        last_round_idx = history.round_number - 1
        my_last_action = history.my_actions[last_round_idx]
        my_last_payoff = history.my_payoffs[last_round_idx]
        if my_last_action:
            current_stock = my_last_payoff * (2 * self.n_players)
        else:
            current_stock = my_last_payoff * self.n_players
        if current_stock <= self.capacity * 0.15:
            return Action.D
        if current_round == self.n_rounds:
            return Action.D
        last_round_opponent_actions = history.opponent_actions[last_round_idx]
        cooperators_last_round = sum(last_round_opponent_actions)
        if my_last_action:
            cooperators_last_round += 1
        cooperation_rate = cooperators_last_round / self.n_players
        rounds_to_check = min(3, history.round_number)
        my_recent_cooperations = sum(history.my_actions[-rounds_to_check:])
        my_recent_cooperation_rate = my_recent_cooperations / rounds_to_check
        if cooperation_rate >= 0.6:
            return Action.C
        elif cooperation_rate >= 0.4:
            if my_recent_cooperation_rate >= 0.67:
                return Action.C
            else:
                return Action.D
        elif current_stock >= self.capacity * 0.8:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_16(BaseStrategy):
    """
    Conditional Cooperative Strategy with Forgiveness
    
    This strategy balances cooperation and self-protection by:
    1. Starting cooperatively
    2. Responding to collective cooperation rates with graduated responses
    3. Emergency cooperation when stock is critically low
    4. Forgiveness mechanism to prevent spiral into mutual defection
    5. Strategic end-game decisions based on recent cooperation patterns
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defected_last_round = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.defected_last_round = False
            return Action.C
        current_round = history.round_number + 1
        stock_level = self._estimate_current_stock(history)
        if current_round == self.game_description.n_rounds:
            return self._end_game_decision(stock_level, history)
        if stock_level <= self.game_description.capacity * 0.15:
            self.defected_last_round = False
            return Action.C
        cooperation_rate = self._calculate_cooperation_rate(history, 3)
        if cooperation_rate >= 0.6:
            self.defected_last_round = False
            return Action.C
        elif cooperation_rate >= 0.3:
            action = self._conditional_cooperate(history)
            self.defected_last_round = action == Action.D
            return action
        else:
            self.defected_last_round = True
            return Action.D

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game history"""
        stock = float(self.game_description.capacity)
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        for round_idx in range(history.round_number):
            my_consumption = stock / (2 * n) if history.my_actions[round_idx] else stock / n
            opponent_consumption = 0
            for player_idx in range(len(history.opponent_actions[round_idx])):
                if history.opponent_actions[round_idx, player_idx]:
                    opponent_consumption += stock / (2 * n)
                else:
                    opponent_consumption += stock / n
            total_consumption = my_consumption + opponent_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            stock = min(stock_after_consumption + growth, capacity)
        return stock

    def _calculate_cooperation_rate(self, history: PlayerHistory, lookback_rounds: int) -> float:
        """Calculate cooperation rate of opponents over recent rounds"""
        if history.round_number == 0:
            return 1.0
        recent_rounds = min(lookback_rounds, history.round_number)
        start_round = history.round_number - recent_rounds
        total_decisions = 0
        cooperative_decisions = 0
        for round_idx in range(start_round, history.round_number):
            for player_idx in range(len(history.opponent_actions[round_idx])):
                total_decisions += 1
                if history.opponent_actions[round_idx, player_idx]:
                    cooperative_decisions += 1
        return cooperative_decisions / total_decisions if total_decisions > 0 else 1.0

    def _conditional_cooperate(self, history: PlayerHistory) -> Action:
        """Conditional cooperation with forgiveness mechanism"""
        if history.round_number == 0:
            return Action.C
        last_round_idx = history.round_number - 1
        last_round_defectors = sum((1 for cooperated in history.opponent_actions[last_round_idx] if not cooperated))
        majority_defected = last_round_defectors > len(history.opponent_actions[last_round_idx]) / 2
        if majority_defected:
            if not self.defected_last_round:
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

    def _end_game_decision(self, stock_level: float, history: PlayerHistory) -> Action:
        """Strategic decision for the final round"""
        if stock_level <= self.game_description.capacity * 0.2:
            return Action.C
        cooperation_rate = self._calculate_cooperation_rate(history, 5)
        if cooperation_rate >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_17(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Guardian"
    
    This strategy prioritizes long-term sustainability while being responsive to group behavior.
    It starts cooperatively but adapts based on observed patterns to maintain both cooperation
    incentives and resource preservation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        current_stock = self._estimate_current_stock(history)
        stock_health = current_stock / self.capacity
        if stock_health <= 0.2:
            return Action.C
        if current_round <= 2:
            return Action.C
        if current_round >= self.n_rounds:
            if stock_health < 0.3:
                return Action.C
            else:
                return self._adaptive_decision(history, stock_health)
        elif current_round == self.n_rounds - 1:
            return self._adaptive_decision(history, stock_health, threshold=0.6)
        else:
            return self._adaptive_decision(history, stock_health)

    def _adaptive_decision(self, history: PlayerHistory, stock_health: float, threshold: float=None) -> Action:
        """Make decision based on recent cooperation rates and stock health."""
        if threshold is None:
            threshold = self.cooperation_threshold
        recent_window = min(3, history.round_number)
        total_cooperators = 0
        total_possible = 0
        for round_idx in range(max(0, history.round_number - recent_window), history.round_number):
            cooperators_in_round = sum(history.opponent_actions[round_idx])
            if history.my_actions[round_idx]:
                cooperators_in_round += 1
            total_cooperators += cooperators_in_round
            total_possible += self.n_players
        cooperation_rate = total_cooperators / total_possible if total_possible > 0 else 0
        if cooperation_rate >= threshold and stock_health > 0.3:
            return Action.C
        elif stock_health <= 0.2:
            return Action.C
        else:
            return Action.D

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game history."""
        stock = self.capacity
        for round_idx in range(history.round_number):
            my_consumption = self._get_consumption(history.my_actions[round_idx], stock)
            total_consumption = my_consumption
            for opponent_idx in range(self.n_players - 1):
                opponent_consumption = self._get_consumption(history.opponent_actions[round_idx, opponent_idx], stock)
                total_consumption += opponent_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _get_consumption(self, cooperated: bool, current_stock: float) -> float:
        """Calculate consumption amount based on action and current stock."""
        if cooperated:
            return current_stock / (2 * self.n_players)
        else:
            return current_stock / self.n_players

class Strategy_COOPERATIVE_18(BaseStrategy):
    """
    Adaptive Steward Strategy: Prioritizes long-term sustainability while being responsive 
    to group cooperation levels. Starts cooperatively but adapts based on collective behavior,
    maintaining resource pool while protecting against exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.exploitation_count = 0
        self.consecutive_majority_coop = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        n_rounds = self.game_description.n_rounds
        current_round = history.round_number + 1
        stock = self._estimate_current_stock(history, capacity, n)
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            cooperators_last_round += 1
        coop_rate = cooperators_last_round / n
        stock_health = stock / capacity
        self._update_exploitation_count(history, coop_rate)
        if stock_health < 0.3:
            return Action.C
        if stock_health < 0.2:
            return Action.C
        if current_round > n_rounds - 3:
            if coop_rate >= 0.3 or stock_health > 0.4:
                return Action.C
        if self._check_perfect_cooperation(history):
            return Action.C
        if self._check_mutual_defection(history):
            return Action.C
        if coop_rate >= 0.5:
            self.consecutive_majority_coop += 1
            return Action.C
        elif coop_rate >= 0.25:
            self.consecutive_majority_coop = 0
            if stock_health > 0.7:
                return Action.C
            elif self.exploitation_count < 2:
                return Action.D
            else:
                return Action.C
        else:
            self.consecutive_majority_coop = 0
            if stock_health > 0.6 and current_round < n_rounds:
                return Action.D
            else:
                return Action.C

    def _estimate_current_stock(self, history, capacity, n):
        """Estimate current stock based on game history"""
        stock = capacity
        for round_idx in range(history.round_number):
            my_consumption = stock / (2 * n) if history.my_actions[round_idx] else stock / n
            opponent_consumption = 0
            for opp_idx in range(n - 1):
                if history.opponent_actions[round_idx, opp_idx]:
                    opponent_consumption += stock / (2 * n)
                else:
                    opponent_consumption += stock / n
            total_consumption = my_consumption + opponent_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            stock = min(stock_after_consumption + growth, capacity)
        return stock

    def _update_exploitation_count(self, history, coop_rate):
        """Update exploitation tracking"""
        if history.round_number > 0:
            last_round_idx = history.round_number - 1
            if history.my_actions[last_round_idx] and coop_rate < 0.5:
                self.exploitation_count += 1
            elif coop_rate >= 0.5:
                self.exploitation_count = max(0, self.exploitation_count - 1)
        if self.consecutive_majority_coop >= 2:
            self.exploitation_count = 0

    def _check_perfect_cooperation(self, history):
        """Check if there has been perfect cooperation for 3+ rounds"""
        if history.round_number < 3:
            return False
        n = self.game_description.n_players
        for i in range(3):
            round_idx = history.round_number - 1 - i
            if round_idx < 0:
                return False
            total_cooperators = sum(history.opponent_actions[round_idx])
            if history.my_actions[round_idx]:
                total_cooperators += 1
            if total_cooperators != n:
                return False
        return True

    def _check_mutual_defection(self, history):
        """Check if stuck in mutual defection for 3+ rounds"""
        if history.round_number < 3:
            return False
        for i in range(3):
            round_idx = history.round_number - 1 - i
            if round_idx < 0:
                return False
            cooperators = sum(history.opponent_actions[round_idx])
            if history.my_actions[round_idx]:
                cooperators += 1
            if cooperators > 0:
                return False
        return True

class Strategy_COOPERATIVE_19(BaseStrategy):
    """
    Adaptive Sustainability Guardian: A cooperative strategy that prioritizes long-term 
    resource sustainability while adapting to opponent behavior. Uses majority-rule 
    cooperation with emergency sustainability thresholds and anti-exploitation measures.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.consecutive_minority_rounds = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        stock = self._calculate_current_stock(history)
        if stock < self.game_description.capacity * 0.3:
            return Action.C
        last_round_idx = history.round_number - 1
        last_round_cooperators = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            total_cooperators = last_round_cooperators + 1
        else:
            total_cooperators = last_round_cooperators
        cooperation_rate = total_cooperators / self.game_description.n_players
        if cooperation_rate >= 0.5:
            self.consecutive_minority_rounds = 0
            return Action.C
        else:
            self.consecutive_minority_rounds += 1
            if self.consecutive_minority_rounds == 1:
                return Action.C
            else:
                return Action.D

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game history."""
        stock = float(self.game_description.capacity)
        n = self.game_description.n_players
        capacity = float(self.game_description.capacity)
        for round_idx in range(history.round_number):
            my_consumption = stock / (2 * n) if history.my_actions[round_idx] else stock / n
            opponent_consumption = 0
            for opponent_idx in range(n - 1):
                if history.opponent_actions[round_idx, opponent_idx]:
                    opponent_consumption += stock / (2 * n)
                else:
                    opponent_consumption += stock / n
            total_consumption = my_consumption + opponent_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            else:
                growth = 0
            stock = min(stock_after_consumption + growth, capacity)
        return stock

class Strategy_COOPERATIVE_20(BaseStrategy):
    """
    Trust-Building Sustainabilist: Adaptive cooperative strategy that prioritizes long-term sustainability
    while building trust through consistent cooperation, with graduated responses to maintain resource viability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        stock_level = self._estimate_stock_level(history)
        if stock_level < self.capacity * 0.3:
            return Action.C
        other_coop_rate = self._calculate_others_cooperation_rate(history)
        if other_coop_rate >= 0.7:
            return Action.C
        elif other_coop_rate >= 0.4:
            return Action.C
        elif stock_level >= self.capacity * 0.8:
            return Action.C
        elif current_round <= self.n_rounds * 0.3:
            return Action.C
        elif current_round > 1 and (not history.my_actions[-1]):
            return Action.C
        else:
            return Action.D

    def _estimate_stock_level(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on payoffs and game dynamics."""
        if history.round_number == 0:
            return self.capacity
        last_round_idx = history.round_number - 1
        my_last_payoff = history.my_payoffs[last_round_idx]
        my_last_action = history.my_actions[last_round_idx]
        if my_last_action:
            estimated_last_stock = my_last_payoff * (2 * self.n_players)
        else:
            estimated_last_stock = my_last_payoff * self.n_players
        depletion_factor = 0.9
        current_estimate = max(estimated_last_stock * depletion_factor, 0.1 * self.capacity)
        return min(current_estimate, self.capacity)

    def _calculate_others_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate cooperation rate of other players over recent rounds."""
        if history.round_number == 0:
            return 1.0
        lookback = min(5, history.round_number)
        start_idx = max(0, history.round_number - lookback)
        recent_opponent_actions = history.opponent_actions[start_idx:history.round_number]
        if recent_opponent_actions.size == 0:
            return 1.0
        total_actions = recent_opponent_actions.size
        total_cooperations = np.sum(recent_opponent_actions)
        return total_cooperations / total_actions if total_actions > 0 else 1.0

class Strategy_COOPERATIVE_21(BaseStrategy):
    """
    Adaptive Sustainable Harvesting Strategy
    
    Prioritizes long-term sustainability while being responsive to group behavior.
    Always cooperates when stock is critically low, adapts cooperation level based
    on group cooperation rate and stock health, with forgiveness mechanisms to
    restart cooperation cycles.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_stock = self._calculate_current_stock(history)
        last_round_cooperation_rate = self._get_last_round_cooperation_rate(history)
        if current_stock < self.capacity * 0.3:
            return Action.C
        if last_round_cooperation_rate >= 0.6:
            return Action.C
        if last_round_cooperation_rate >= 0.4:
            if current_stock >= self.capacity * 0.7:
                return Action.C
            else:
                return Action.D
        if last_round_cooperation_rate < 0.4:
            if current_stock >= self.capacity * 0.8:
                return Action.C
            else:
                return Action.D
        return Action.C

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate the current stock level based on game history."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            total_consumption = 0.0
            if history.my_actions[round_idx]:
                my_consumption = stock / (2 * self.n_players)
            else:
                my_consumption = stock / self.n_players
            total_consumption += my_consumption
            for opponent_idx in range(self.n_players - 1):
                if history.opponent_actions[round_idx, opponent_idx]:
                    opponent_consumption = stock / (2 * self.n_players)
                else:
                    opponent_consumption = stock / self.n_players
                total_consumption += opponent_consumption
            stock_after_consumption = max(0.0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            else:
                growth = 0.0
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _get_last_round_cooperation_rate(self, history: PlayerHistory) -> float:
        """Get the cooperation rate from the last completed round."""
        if history.round_number == 0:
            return 1.0
        last_round_idx = history.round_number - 1
        cooperators = 0
        if history.my_actions[last_round_idx]:
            cooperators += 1
        for opponent_idx in range(self.n_players - 1):
            if history.opponent_actions[last_round_idx, opponent_idx]:
                cooperators += 1
        return cooperators / self.n_players

class Strategy_COOPERATIVE_22(BaseStrategy):
    """
    Adaptive Cooperative Strategy with Trust Building
    
    Prioritizes long-term sustainability while building trust through consistent 
    cooperative behavior, with adaptive defection only when cooperation becomes 
    clearly unsustainable.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round <= 3:
            return Action.C
        current_stock = self._calculate_current_stock(history)
        cooperation_rate = self._calculate_cooperation_rate(history, 3)
        critical_threshold = self.n_players * 2
        if current_stock < critical_threshold:
            if cooperation_rate >= 0.6:
                return Action.C
            else:
                return Action.D
        if current_round >= self.n_rounds - 1:
            if cooperation_rate >= 0.6 and current_stock >= self.n_players:
                return Action.C
            else:
                return Action.D
        if cooperation_rate >= 0.7:
            return Action.C
        elif cooperation_rate >= 0.4:
            my_cooperation_rate = self._calculate_my_cooperation_rate(history, 3)
            if my_cooperation_rate >= 0.67:
                return Action.C
            else:
                return Action.C
        else:
            stock_trend = self._calculate_stock_trend(history, 3)
            if stock_trend > 0:
                return Action.C
            else:
                return Action.D

    def _calculate_cooperation_rate(self, history: PlayerHistory, lookback_rounds: int) -> float:
        """Calculate cooperation rate among all players over the last N rounds."""
        rounds_to_check = min(lookback_rounds, history.round_number)
        if rounds_to_check == 0:
            return 1.0
        start_round = max(0, history.round_number - rounds_to_check)
        total_cooperations = 0
        total_actions = 0
        for round_idx in range(start_round, history.round_number):
            total_cooperations += sum(history.opponent_actions[round_idx])
            total_cooperations += int(history.my_actions[round_idx])
            total_actions += self.n_players
        return total_cooperations / total_actions if total_actions > 0 else 1.0

    def _calculate_my_cooperation_rate(self, history: PlayerHistory, lookback_rounds: int) -> float:
        """Calculate my cooperation rate over the last N rounds."""
        rounds_to_check = min(lookback_rounds, history.round_number)
        if rounds_to_check == 0:
            return 1.0
        start_round = max(0, history.round_number - rounds_to_check)
        my_cooperations = sum(history.my_actions[start_round:history.round_number])
        return my_cooperations / rounds_to_check if rounds_to_check > 0 else 1.0

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game history."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            total_consumption = 0
            if history.my_actions[round_idx]:
                total_consumption += stock / (2 * self.n_players)
            else:
                total_consumption += stock / self.n_players
            for opponent_idx in range(self.n_players - 1):
                if history.opponent_actions[round_idx, opponent_idx]:
                    total_consumption += stock / (2 * self.n_players)
                else:
                    total_consumption += stock / self.n_players
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _calculate_stock_trend(self, history: PlayerHistory, lookback_rounds: int) -> float:
        """Calculate stock trend over the last N rounds."""
        if history.round_number < lookback_rounds:
            return 0.0
        rounds_back = min(lookback_rounds, history.round_number)
        stock_past = float(self.capacity)
        target_round = history.round_number - rounds_back
        for round_idx in range(target_round):
            total_consumption = 0
            if history.my_actions[round_idx]:
                total_consumption += stock_past / (2 * self.n_players)
            else:
                total_consumption += stock_past / self.n_players
            for opponent_idx in range(self.n_players - 1):
                if history.opponent_actions[round_idx, opponent_idx]:
                    total_consumption += stock_past / (2 * self.n_players)
                else:
                    total_consumption += stock_past / self.n_players
            stock_after_consumption = max(0, stock_past - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock_past = min(stock_after_consumption + growth, self.capacity)
        current_stock = self._calculate_current_stock(history)
        return (current_stock - stock_past) / rounds_back if rounds_back > 0 else 0.0

class Strategy_COOPERATIVE_23(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Graduated Reciprocal Cooperation"
    
    Prioritizes long-term sustainability while adapting to opponent behavior using
    graduated responses. Starts cooperative, responds proportionally to group
    cooperation levels, and includes overrides for stock protection and recovery.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_num = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        previous_round_idx = history.round_number - 1
        cooperators = sum(history.opponent_actions[previous_round_idx])
        if history.my_actions[previous_round_idx]:
            cooperators += 1
        cooperation_rate = cooperators / n_players
        my_last_payoff = history.my_payoffs[previous_round_idx]
        my_last_action = history.my_actions[previous_round_idx]
        if my_last_action:
            estimated_stock = my_last_payoff * 2 * n_players
        else:
            estimated_stock = my_last_payoff * n_players
        if estimated_stock < capacity / 3:
            return Action.C
        if round_num > 2 and history.round_number >= 2:
            stock_estimates = []
            for i in range(max(0, history.round_number - 2), history.round_number):
                payoff = history.my_payoffs[i]
                action = history.my_actions[i]
                if action:
                    stock_est = payoff * 2 * n_players
                else:
                    stock_est = payoff * n_players
                stock_estimates.append(stock_est)
            if len(stock_estimates) >= 2:
                increasing = all((stock_estimates[i] < stock_estimates[i + 1] for i in range(len(stock_estimates) - 1)))
                if increasing:
                    return Action.C
        if round_num == total_rounds:
            return Action.C if cooperation_rate >= 0.5 else Action.D
        if cooperation_rate >= 0.75:
            return Action.C
        elif cooperation_rate >= 0.5:
            return Action.C if random.random() < 0.8 else Action.D
        elif cooperation_rate >= 0.25:
            return Action.C if random.random() < 0.4 else Action.D
        else:
            return Action.D

class Strategy_COOPERATIVE_24(BaseStrategy):
    """
    Graduated Trust with Conservation Threshold: A cooperative strategy that prioritizes 
    long-term sustainability while building trust. Uses emergency conservation when stock 
    is low, generous tit-for-majority in middle rounds, and strategic final round decisions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.currently_punishing = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.currently_punishing = False
            return Action.C
        current_round = history.round_number + 1
        current_stock = self._calculate_current_stock(history)
        if current_stock <= self.capacity * 0.4:
            self.currently_punishing = False
            return Action.C
        if current_round == self.n_rounds:
            if current_stock >= self.capacity * 0.6 and self._majority_cooperated_last_round(history):
                return Action.C
            else:
                return Action.D
        last_round_cooperators = self._count_cooperators_last_round(history)
        majority_threshold = (self.n_players - 1) / 2
        if last_round_cooperators >= majority_threshold:
            self.currently_punishing = False
            return Action.C
        elif not self.currently_punishing:
            self.currently_punishing = True
            return Action.D
        elif random.random() < 0.7:
            return Action.C
        else:
            return Action.D

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game dynamics."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            total_consumption = 0.0
            if my_action:
                total_consumption += stock / (2 * self.n_players)
            else:
                total_consumption += stock / self.n_players
            for opponent_idx in range(self.n_players - 1):
                opponent_action = history.opponent_actions[round_idx, opponent_idx]
                if opponent_action:
                    total_consumption += stock / (2 * self.n_players)
                else:
                    total_consumption += stock / self.n_players
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _count_cooperators_last_round(self, history: PlayerHistory) -> int:
        """Count how many opponents cooperated in the last round."""
        if history.round_number == 0:
            return 0
        last_round_idx = history.round_number - 1
        return sum(history.opponent_actions[last_round_idx])

    def _majority_cooperated_last_round(self, history: PlayerHistory) -> bool:
        """Check if majority of opponents cooperated in the last round."""
        if history.round_number == 0:
            return False
        cooperators = self._count_cooperators_last_round(history)
        return cooperators >= (self.n_players - 1) / 2

class Strategy_COOPERATIVE_25(BaseStrategy):
    """
    Threshold Guardian: Adaptive cooperative strategy that maintains stock-based cooperation thresholds
    while implementing reciprocity and crisis recovery mechanisms for sustainable resource management.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_number = history.round_number + 1
        current_stock = self._calculate_current_stock(history)
        if round_number == self.n_rounds:
            if current_stock >= self.capacity * 0.4:
                return Action.C
            else:
                return Action.D
        last_round_coop_rate = self._get_last_round_cooperation_rate(history)
        recent_coop_rate = self._get_recent_cooperation_rate(history)
        cooperation_threshold = self.capacity * 0.6
        if current_stock >= cooperation_threshold:
            return Action.C
        if current_stock >= self.capacity * 0.3:
            if last_round_coop_rate >= 0.5:
                return Action.C
            else:
                return Action.D
        if current_stock >= self.capacity * 0.2:
            if recent_coop_rate >= 0.75:
                return Action.C
            elif round_number % 3 == 0:
                return Action.C
            else:
                return Action.D
        if recent_coop_rate >= 1.0:
            return Action.C
        else:
            return Action.D

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game history."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0.0
            if my_action:
                total_consumption += stock / (2 * self.n_players)
            else:
                total_consumption += stock / self.n_players
            for opponent_action in opponent_actions:
                if opponent_action:
                    total_consumption += stock / (2 * self.n_players)
                else:
                    total_consumption += stock / self.n_players
            stock_after_consumption = max(0.0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            else:
                growth = 0.0
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _get_last_round_cooperation_rate(self, history: PlayerHistory) -> float:
        """Get cooperation rate from the most recent completed round."""
        if history.round_number == 0:
            return 0.0
        last_round_idx = history.round_number - 1
        cooperators = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            cooperators += 1
        return cooperators / self.n_players

    def _get_recent_cooperation_rate(self, history: PlayerHistory) -> float:
        """Get cooperation rate from the last 2 rounds (or available rounds if fewer)."""
        if history.round_number == 0:
            return 0.0
        rounds_to_check = min(2, history.round_number)
        start_idx = history.round_number - rounds_to_check
        total_cooperators = 0
        total_decisions = 0
        for round_idx in range(start_idx, history.round_number):
            cooperators_this_round = sum(history.opponent_actions[round_idx])
            if history.my_actions[round_idx]:
                cooperators_this_round += 1
            total_cooperators += cooperators_this_round
            total_decisions += self.n_players
        return total_cooperators / total_decisions if total_decisions > 0 else 0.0

class Strategy_COOPERATIVE_26(BaseStrategy):
    """
    Conditional Cooperative Strategy with Sustainability Focus.
    
    Prioritizes long-term resource sustainability while encouraging cooperation through
    conditional reciprocity. Uses generous tit-for-tat with majority threshold and
    emergency conservation mode when stock levels are critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_stock = self._calculate_current_stock(history)
        if current_stock < self.capacity * 0.3:
            return Action.C
        return self._conditional_response(history, current_stock)

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game history."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            total_consumption = 0.0
            if history.my_actions[round_idx]:
                my_consumption = stock / (2 * self.n_players)
            else:
                my_consumption = stock / self.n_players
            total_consumption += my_consumption
            for opponent_idx in range(self.n_players - 1):
                if history.opponent_actions[round_idx, opponent_idx]:
                    opponent_consumption = stock / (2 * self.n_players)
                else:
                    opponent_consumption = stock / self.n_players
                total_consumption += opponent_consumption
            stock_after_consumption = max(0.0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            else:
                growth = 0.0
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _conditional_response(self, history: PlayerHistory, current_stock: float) -> Action:
        """Apply conditional response logic based on opponents' recent behavior."""
        current_round = history.round_number
        last_round_idx = current_round - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        total_opponents = self.n_players - 1
        coop_rate_last_round = cooperators_last_round / total_opponents if total_opponents > 0 else 1.0
        if coop_rate_last_round >= 0.5:
            return Action.C
        if current_round >= 3:
            recent_coop_rates = []
            for i in range(max(0, current_round - 3), current_round):
                round_cooperators = sum(history.opponent_actions[i])
                round_coop_rate = round_cooperators / total_opponents if total_opponents > 0 else 1.0
                recent_coop_rates.append(round_coop_rate)
            recent_avg = sum(recent_coop_rates) / len(recent_coop_rates)
            if current_round >= 6:
                previous_coop_rates = []
                for i in range(max(0, current_round - 6), current_round - 3):
                    round_cooperators = sum(history.opponent_actions[i])
                    round_coop_rate = round_cooperators / total_opponents if total_opponents > 0 else 1.0
                    previous_coop_rates.append(round_coop_rate)
                if previous_coop_rates:
                    previous_avg = sum(previous_coop_rates) / len(previous_coop_rates)
                    if recent_avg > previous_avg:
                        return Action.C
        if current_stock < self.capacity * 0.5:
            if current_round >= 2:
                if current_round == 1:
                    return Action.C
                last_two_rounds_coop = []
                for i in range(max(0, current_round - 2), current_round):
                    round_cooperators = sum(history.opponent_actions[i])
                    round_coop_rate = round_cooperators / total_opponents if total_opponents > 0 else 1.0
                    last_two_rounds_coop.append(round_coop_rate)
                if len(last_two_rounds_coop) >= 2 and last_two_rounds_coop[-1] > last_two_rounds_coop[-2]:
                    return Action.C
        return Action.D

class Strategy_COOPERATIVE_27(BaseStrategy):
    """
    Graduated Cooperation Strategy (GCS) - Prioritizes long-term sustainability 
    while using graduated responses to discourage exploitation. Cooperates when 
    resources are sustainable, escalates punishment based on observed cooperation 
    levels when resources are depleted.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        current_stock = self._estimate_current_stock(history)
        if current_round == total_rounds:
            if current_stock >= capacity * 0.8:
                return Action.C
            else:
                return Action.D
        sustainability_threshold = capacity * 0.6
        if current_stock >= sustainability_threshold:
            return Action.C
        else:
            recent_rounds = min(3, history.round_number)
            total_observations = 0
            cooperators_observed = 0
            start_round = max(0, history.round_number - recent_rounds)
            for round_idx in range(start_round, history.round_number):
                total_observations += 1
                if history.my_actions[round_idx]:
                    cooperators_observed += 1
                for opponent_idx in range(n_players - 1):
                    total_observations += 1
                    if history.opponent_actions[round_idx, opponent_idx]:
                        cooperators_observed += 1
            if total_observations == 0:
                return Action.C
            coop_ratio = cooperators_observed / total_observations
            if coop_ratio >= 0.5:
                return Action.C
            elif coop_ratio >= 0.25:
                if random.random() < 1 - coop_ratio:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.D

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """
        Estimate current stock level based on payoff history and game dynamics.
        Since payoffs reveal the stock level at the time actions were taken.
        """
        if history.round_number == 0:
            return self.game_description.capacity
        last_round_idx = history.round_number - 1
        my_last_payoff = history.my_payoffs[last_round_idx]
        my_last_action = history.my_actions[last_round_idx]
        n_players = self.game_description.n_players
        if my_last_action:
            stock_at_action = my_last_payoff * (2 * n_players)
        else:
            stock_at_action = my_last_payoff * n_players
        total_consumption = 0
        if my_last_action:
            total_consumption += stock_at_action / (2 * n_players)
        else:
            total_consumption += stock_at_action / n_players
        for opponent_idx in range(n_players - 1):
            if history.opponent_actions[last_round_idx, opponent_idx]:
                total_consumption += stock_at_action / (2 * n_players)
            else:
                total_consumption += stock_at_action / n_players
        stock_after_consumption = stock_at_action - total_consumption
        if stock_after_consumption <= 0:
            return 0.0
        growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.game_description.capacity)
        new_stock = min(stock_after_consumption + growth, self.game_description.capacity)
        return max(0.0, new_stock)

class Strategy_COOPERATIVE_28(BaseStrategy):
    """
    Conditional Cooperation with Forgiveness Strategy
    
    Uses tit-for-tat with majority threshold, includes forgiveness mechanism
    to escape defection cycles, and prioritizes resource sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n = self.game_description.n_players
        max_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        stock = self._estimate_current_stock(history, capacity, n)
        if stock < capacity / 4:
            return Action.C
        previous_round_idx = history.round_number - 1
        opponent_actions_last_round = history.opponent_actions[previous_round_idx]
        cooperators = sum(opponent_actions_last_round)
        defectors = len(opponent_actions_last_round) - cooperators
        if current_round >= 4:
            consecutive_mutual_defection = self._check_consecutive_mutual_defection(history, 3, n)
            if consecutive_mutual_defection and current_round % 3 == 1:
                return Action.C
        if current_round == max_rounds:
            if stock <= capacity / 2:
                if cooperators >= defectors:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.C
        if cooperators >= defectors:
            return Action.C
        else:
            return Action.D

    def _estimate_current_stock(self, history: PlayerHistory, capacity: float, n: int) -> float:
        """Estimate current stock level based on game history"""
        stock = capacity
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0
            if my_action:
                total_consumption += stock / (2 * n)
            else:
                total_consumption += stock / n
            for opp_action in opponent_actions:
                if opp_action:
                    total_consumption += stock / (2 * n)
                else:
                    total_consumption += stock / n
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            stock = min(stock_after_consumption + growth, capacity)
        return stock

    def _check_consecutive_mutual_defection(self, history: PlayerHistory, num_rounds: int, n: int) -> bool:
        """Check if last num_rounds all had majority defection (including self)"""
        if history.round_number < num_rounds:
            return False
        for i in range(num_rounds):
            round_idx = history.round_number - 1 - i
            if round_idx < 0:
                return False
            my_defected = not history.my_actions[round_idx]
            opponent_defectors = sum((1 for action in history.opponent_actions[round_idx] if not action))
            total_defectors = (1 if my_defected else 0) + opponent_defectors
            if total_defectors <= n / 2:
                return False
        return True

class Strategy_COOPERATIVE_29(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Consensus Builder"
    
    A stock-aware strategy that prioritizes long-term sustainability while being
    robust against exploitation. Establishes cooperative equilibrium through
    phases: establishment, adaptive cooperation, and strategic endgame.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.establishment_rounds = max(3, math.ceil(0.15 * self.n_rounds))
        self.endgame_rounds = max(3, math.ceil(0.1 * self.n_rounds))

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        current_stock = self._calculate_current_stock(history)
        stock_health = current_stock / self.capacity
        if current_round <= self.establishment_rounds:
            return Action.C
        cooperation_rate = self._get_cooperation_rate_last_round(history)
        if current_stock < self.n_players * 2 or stock_health < 0.3:
            return Action.C
        rounds_remaining = self.n_rounds - current_round + 1
        if rounds_remaining <= self.endgame_rounds:
            return self._endgame_strategy(history, cooperation_rate, stock_health, rounds_remaining)
        return self._adaptive_cooperation_strategy(history, cooperation_rate)

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock based on game dynamics."""
        stock = self.capacity
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0
            if my_action:
                total_consumption += stock / (2 * self.n_players)
            else:
                total_consumption += stock / self.n_players
            for opp_action in opponent_actions:
                if opp_action:
                    total_consumption += stock / (2 * self.n_players)
                else:
                    total_consumption += stock / self.n_players
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _get_cooperation_rate_last_round(self, history: PlayerHistory) -> float:
        """Get cooperation rate from the last round."""
        if history.round_number == 0:
            return 1.0
        last_round_idx = history.round_number - 1
        cooperators = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            cooperators += 1
        return cooperators / self.n_players

    def _get_cooperation_rate_last_n_rounds(self, history: PlayerHistory, n: int) -> float:
        """Get cooperation rate over the last n rounds."""
        if history.round_number == 0:
            return 1.0
        start_idx = max(0, history.round_number - n)
        total_cooperators = 0
        total_decisions = 0
        for round_idx in range(start_idx, history.round_number):
            cooperators = sum(history.opponent_actions[round_idx])
            if history.my_actions[round_idx]:
                cooperators += 1
            total_cooperators += cooperators
            total_decisions += self.n_players
        return total_cooperators / total_decisions if total_decisions > 0 else 1.0

    def _count_my_recent_cooperations(self, history: PlayerHistory, n: int) -> int:
        """Count my cooperations in the last n rounds."""
        start_idx = max(0, history.round_number - n)
        return sum(history.my_actions[start_idx:history.round_number])

    def _adaptive_cooperation_strategy(self, history: PlayerHistory, cooperation_rate: float) -> Action:
        """Main adaptive cooperation logic for middle rounds."""
        my_last_action = history.my_actions[-1] if history.round_number > 0 else True
        if cooperation_rate >= 0.6:
            return Action.C
        elif cooperation_rate >= 0.4 and my_last_action:
            return Action.C
        elif cooperation_rate < 0.4 and self._count_my_recent_cooperations(history, 3) >= 2:
            return Action.D
        else:
            return Action.C

    def _endgame_strategy(self, history: PlayerHistory, cooperation_rate: float, stock_health: float, rounds_remaining: int) -> Action:
        """Strategy for the final rounds."""
        if stock_health < 0.2:
            return Action.C
        cooperation_rate_last_3 = self._get_cooperation_rate_last_n_rounds(history, 3)
        if cooperation_rate_last_3 >= 0.5:
            return Action.C
        elif rounds_remaining == 1:
            return Action.D
        elif rounds_remaining == 2 and cooperation_rate < 0.3:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_30(BaseStrategy):
    """
    Graduated Sustainability Strategy: Prioritizes long-term collective welfare through 
    sustainable resource use while incorporating forgiveness and adaptability to encourage 
    cooperation from others.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_rounds = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        round_num = history.round_number + 1
        stock_level = self._estimate_stock_level(history)
        sustainable_threshold = capacity * 0.6
        critical_threshold = capacity * 0.3
        endgame_start = n_rounds * 0.8
        if stock_level < critical_threshold:
            self.punishment_rounds = 0
            return Action.C
        cooperation_ratio = self._calculate_cooperation_ratio(history)
        if round_num <= 3:
            if round_num == 1:
                return Action.C
            else:
                last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
                majority_cooperated = last_round_cooperators > (n_players - 1) / 2
                if round_num == 2:
                    return Action.C if majority_cooperated else Action.D
                else:
                    return Action.C
        if round_num >= endgame_start:
            if stock_level >= capacity * 0.4:
                self.punishment_rounds = 0
                return Action.C
        if self.punishment_rounds > 0:
            self.punishment_rounds -= 1
            if self.punishment_rounds == 0:
                return Action.C
            return Action.D
        if cooperation_ratio >= 0.6:
            return Action.C
        elif cooperation_ratio >= 0.3:
            return Action.C if random.random() < 0.7 else Action.D
        elif stock_level > capacity * 0.5:
            self.punishment_rounds = 1
            return Action.D
        else:
            return Action.C

    def _estimate_stock_level(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on payoff history."""
        if history.round_number == 0:
            return self.game_description.capacity
        last_payoff = history.my_payoffs[-1]
        last_action = history.my_actions[-1]
        n_players = self.game_description.n_players
        if last_action:
            estimated_stock = last_payoff * 2 * n_players
        else:
            estimated_stock = last_payoff * n_players
        return max(0, estimated_stock)

    def _calculate_cooperation_ratio(self, history: PlayerHistory) -> float:
        """Calculate cooperation ratio from recent rounds with exponential decay weighting."""
        if history.round_number == 0:
            return 1.0
        rounds_to_check = min(3, history.round_number)
        total_weighted_actions = 0
        total_weight = 0
        weights = [0.5, 0.3, 0.2]
        for i in range(rounds_to_check):
            round_idx = history.round_number - 1 - i
            cooperators = sum(history.opponent_actions[round_idx])
            total_actions = len(history.opponent_actions[round_idx])
            if total_actions > 0:
                cooperation_rate = cooperators / total_actions
                weight = weights[i] if i < len(weights) else 0.1
                total_weighted_actions += cooperation_rate * weight
                total_weight += weight
        if total_weight == 0:
            return 1.0
        return total_weighted_actions / total_weight

class Strategy_COOPERATIVE_31(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Stock Management (ATTSM).
    
    Balances cooperative intent with adaptive response to maintain long-term 
    sustainability. Starts cooperatively but responds to defection patterns 
    while considering current stock health.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        current_stock = self._estimate_current_stock(history)
        if current_stock < self.capacity * 0.2:
            return Action.C
        if current_round == self.n_rounds:
            return self._apply_final_round_logic(history, current_stock)
        return self._adaptive_response(history, current_stock)

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock based on game dynamics."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            if my_action:
                my_consumption = stock / (2 * self.n_players)
            else:
                my_consumption = stock / self.n_players
            opponent_consumption = 0
            for opp_action in opponent_actions:
                if opp_action:
                    opponent_consumption += stock / (2 * self.n_players)
                else:
                    opponent_consumption += stock / self.n_players
            total_consumption = my_consumption + opponent_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _calculate_defection_rate(self, actions: np.ndarray) -> float:
        """Calculate defection rate from boolean actions array."""
        if len(actions) == 0:
            return 0.0
        return 1.0 - np.mean(actions)

    def _get_recent_opponent_actions(self, history: PlayerHistory, lookback: int=3) -> np.ndarray:
        """Get recent opponent actions across all opponents."""
        start_idx = max(0, history.round_number - lookback)
        recent_actions = history.opponent_actions[start_idx:]
        return recent_actions.flatten() if len(recent_actions) > 0 else np.array([])

    def _adaptive_response(self, history: PlayerHistory, stock: float) -> Action:
        """Main adaptive response logic."""
        recent_opponent_actions = self._get_recent_opponent_actions(history, 3)
        all_opponent_actions = history.opponent_actions.flatten()
        recent_defection_rate = self._calculate_defection_rate(recent_opponent_actions)
        overall_defection_rate = self._calculate_defection_rate(all_opponent_actions)
        cooperation_bias = 0.5
        if len(recent_opponent_actions) >= 6:
            if recent_defection_rate == 0:
                cooperation_bias = 0.8
        stock_health = stock / self.capacity
        if stock_health > 0.7:
            defection_threshold = 0.4
        elif stock_health > 0.4:
            defection_threshold = 0.3
        else:
            defection_threshold = 0.2
        if recent_defection_rate > defection_threshold:
            defect_probability = min(recent_defection_rate * 0.8, 0.6)
            return Action.D if random.random() < defect_probability else Action.C
        else:
            return Action.C if random.random() < cooperation_bias else Action.D

    def _apply_final_round_logic(self, history: PlayerHistory, stock: float) -> Action:
        """Logic for the final round."""
        all_opponent_actions = history.opponent_actions.flatten()
        overall_cooperation_rate = np.mean(all_opponent_actions)
        overall_defection_rate = 1.0 - overall_cooperation_rate
        if overall_cooperation_rate > 0.6:
            return Action.C
        if stock < self.capacity * 0.3:
            return Action.C
        return Action.D if overall_defection_rate > 0.7 else Action.C

class Strategy_COOPERATIVE_32(BaseStrategy):
    """
    Adaptive Threshold Cooperation with Forgiveness: A cooperative strategy that 
    defaults to cooperation but adapts based on others' behavior. Uses a threshold 
    system with forgiveness to balance sustainability and strategic resilience.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5
        self.forgiveness_counter = 0
        self.critical_stock_ratio = 0.15
        self.final_stock_ratio = 0.25

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        stock_level = self._estimate_current_stock(history)
        if current_round == n_rounds:
            if stock_level >= capacity * self.final_stock_ratio:
                return Action.C
            else:
                return Action.D
        if history.round_number > 0:
            last_round_cooperators = np.sum(history.opponent_actions[history.round_number - 1])
            others_cooperation_rate = last_round_cooperators / (n_players - 1)
        else:
            others_cooperation_rate = 1.0
        if stock_level < capacity * self.critical_stock_ratio:
            return Action.C
        if others_cooperation_rate >= self.cooperation_threshold:
            self.forgiveness_counter = min(self.forgiveness_counter + 1, 3)
            return Action.C
        elif self.forgiveness_counter > 0:
            self.forgiveness_counter = self.forgiveness_counter - 1
            return Action.C
        else:
            return Action.D

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game dynamics."""
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        stock = capacity
        for round_idx in range(history.round_number):
            my_consumption = self._get_consumption(history.my_actions[round_idx], stock, n_players)
            total_opponent_consumption = 0
            for player_idx in range(n_players - 1):
                opponent_action = history.opponent_actions[round_idx, player_idx]
                total_opponent_consumption += self._get_consumption(opponent_action, stock, n_players)
            total_consumption = my_consumption + total_opponent_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            stock = min(stock_after_consumption + growth, capacity)
        return stock

    def _get_consumption(self, action: bool, stock: float, n_players: int) -> float:
        """Calculate consumption amount based on action."""
        if action:
            return stock / (2 * n_players)
        else:
            return stock / n_players

class Strategy_AGGRESSIVE_3(BaseStrategy):
    """
    Aggressive "Shark Feeder" strategy that exploits early cooperation, 
    maintains strategic aggression throughout middle rounds, and extracts 
    maximum value in endgame phases.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        stock = self._estimate_current_stock(history)
        stock_health = stock / self.capacity
        early_phase_end = max(1, int(self.n_rounds * 0.2))
        if current_round <= early_phase_end:
            return Action.D
        endgame_start = self.n_rounds - max(2, int(self.n_rounds * 0.15))
        if current_round > endgame_start:
            return Action.D
        if history.round_number > 0:
            last_round_actions = history.opponent_actions[history.round_number - 1]
            cooperation_rate = np.mean(last_round_actions)
        else:
            cooperation_rate = 0.5
        if stock_health <= 0.15 and current_round <= self.n_rounds - 2:
            return Action.C
        if cooperation_rate >= 0.6 and stock_health > 0.3:
            return Action.D
        if cooperation_rate <= 0.3:
            return Action.D
        return Action.D

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game history and dynamics."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0.0
            if my_action:
                total_consumption += stock / (2 * self.n_players)
            else:
                total_consumption += stock / self.n_players
            for opponent_action in opponent_actions:
                if opponent_action:
                    total_consumption += stock / (2 * self.n_players)
                else:
                    total_consumption += stock / self.n_players
            stock_after_consumption = max(0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth_rate = 1 - stock_after_consumption / self.capacity
                growth = 2 * stock_after_consumption * growth_rate
            else:
                growth = 0
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

class Strategy_AGGRESSIVE_4(BaseStrategy):
    """
    Predatory Exploitation Strategy: Aggressively maximizes individual payoffs while 
    strategically managing resources to maintain exploitation opportunities. Defects 
    early for dominance, exploits high stock levels, and only cooperates to prevent 
    complete resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.n_rounds:
            return Action.D
        stock_level = self._estimate_current_stock(history)
        if stock_level < self.capacity * 0.15:
            return Action.C
        if stock_level > self.capacity * 0.8:
            return Action.D
        recent_defector_count = self._count_recent_defectors(history)
        if recent_defector_count >= self.n_players / 2:
            return Action.D
        elif stock_level > self.capacity * 0.3:
            return Action.D
        else:
            return Action.C

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game history."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_consumption = stock / (2 * self.n_players) if history.my_actions[round_idx] else stock / self.n_players
            opponent_consumption = 0
            for player_idx in range(self.n_players - 1):
                if history.opponent_actions[round_idx, player_idx]:
                    opponent_consumption += stock / (2 * self.n_players)
                else:
                    opponent_consumption += stock / self.n_players
            total_consumption = my_consumption + opponent_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
                stock = min(stock_after_consumption + growth, self.capacity)
            else:
                stock = 0
        return stock

    def _count_recent_defectors(self, history: PlayerHistory) -> int:
        """Count number of defectors in the last 3 rounds."""
        rounds_to_check = min(3, history.round_number)
        if rounds_to_check == 0:
            return 0
        defector_count = 0
        for round_offset in range(rounds_to_check):
            round_idx = history.round_number - 1 - round_offset
            defectors_this_round = sum((1 for action in history.opponent_actions[round_idx] if not action))
            defector_count += defectors_this_round
        return defector_count / rounds_to_check

class Strategy_AGGRESSIVE_5(BaseStrategy):
    """
    Resource Raider: An aggressive exploitation strategy that maximizes individual payoffs
    through early aggression, opponent exploitation, and endgame resource extraction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.3
        self.stock_panic_level = game_description.capacity * 0.2
        self.endgame_rounds = 3

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        rounds_remaining = self.game_description.n_rounds - current_round + 1
        current_stock = self._estimate_current_stock(history)
        current_stock_ratio = current_stock / self.game_description.capacity
        if rounds_remaining <= self.endgame_rounds:
            return Action.D
        if current_stock_ratio <= self.stock_panic_level / self.game_description.capacity:
            if self._last_round_had_majority_cooperators(history):
                return Action.D
            else:
                return Action.C
        if current_round <= 2:
            return Action.D
        opponent_coop_rate = self._calculate_opponent_cooperation_rate(history)
        if opponent_coop_rate >= self.cooperation_threshold:
            return Action.D
        elif current_round % 3 == 0:
            return Action.C
        else:
            return Action.D

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock based on game dynamics."""
        stock = self.game_description.capacity
        n = self.game_description.n_players
        for round_idx in range(history.round_number):
            total_consumption = 0
            if history.my_actions[round_idx]:
                my_consumption = stock / (2 * n)
            else:
                my_consumption = stock / n
            total_consumption += my_consumption
            for opponent_idx in range(n - 1):
                if history.opponent_actions[round_idx, opponent_idx]:
                    opponent_consumption = stock / (2 * n)
                else:
                    opponent_consumption = stock / n
                total_consumption += opponent_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.game_description.capacity)
            stock = min(stock_after_consumption + growth, self.game_description.capacity)
        return stock

    def _last_round_had_majority_cooperators(self, history: PlayerHistory) -> bool:
        """Check if majority of opponents cooperated in the last round."""
        if history.round_number == 0:
            return False
        last_round_idx = history.round_number - 1
        cooperators = sum(history.opponent_actions[last_round_idx])
        total_opponents = self.game_description.n_players - 1
        return cooperators > total_opponents / 2

    def _calculate_opponent_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate the overall cooperation rate of opponents."""
        if history.round_number == 0:
            return 0.0
        total_actions = 0
        total_cooperations = 0
        for round_idx in range(history.round_number):
            for opponent_idx in range(self.game_description.n_players - 1):
                total_actions += 1
                if history.opponent_actions[round_idx, opponent_idx]:
                    total_cooperations += 1
        return total_cooperations / total_actions if total_actions > 0 else 0.0

class Strategy_AGGRESSIVE_6(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Resource Predator"
    
    Maximizes exploitation with strategic sustainability. Operates in three phases:
    1. Early Exploitation: Pure defection to maximize value at peak stock
    2. Calculated Predation: Mostly defect, cooperate only to prevent collapse
    3. Endgame Extraction: Pure defection since no future to preserve
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        current_stock = self._estimate_current_stock(history)
        early_phase_end = self.n_rounds / 3
        middle_phase_end = 2 * self.n_rounds / 3
        critical_threshold = self.capacity / 8
        low_threshold = self.capacity / 4
        if current_round == self.n_rounds:
            return Action.D
        if current_stock < critical_threshold and current_round <= middle_phase_end:
            return Action.C
        if current_round <= early_phase_end:
            return Action.D
        if current_round <= middle_phase_end:
            if current_stock < low_threshold and self.n_rounds - current_round > 3 and (self._cooperation_rate_last_round(history) >= 0.5):
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game dynamics."""
        stock = self.capacity
        for round_idx in range(history.round_number):
            total_consumption = 0
            if history.my_actions[round_idx]:
                my_consumption = stock / (2 * self.n_players)
            else:
                my_consumption = stock / self.n_players
            total_consumption += my_consumption
            for player_idx in range(self.n_players - 1):
                if history.opponent_actions[round_idx, player_idx]:
                    opponent_consumption = stock / (2 * self.n_players)
                else:
                    opponent_consumption = stock / self.n_players
                total_consumption += opponent_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _cooperation_rate_last_round(self, history: PlayerHistory) -> float:
        """Calculate cooperation rate among opponents in the last round."""
        if history.round_number == 0:
            return 0.0
        last_round_idx = history.round_number - 1
        cooperators = sum(history.opponent_actions[last_round_idx])
        return cooperators / (self.n_players - 1)

class Strategy_AGGRESSIVE_7(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Predator"
    
    Operates on aggressive resource extraction while maintaining resource viability.
    Always defects in first and last rounds, adapts based on opponent cooperation
    rates and stock levels, exploiting cooperative opponents while punishing
    non-cooperative environments.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        n_players = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if current_round == total_rounds:
            return Action.D
        last_round_idx = history.round_number - 1
        my_last_payoff = history.my_payoffs[last_round_idx]
        my_last_action = history.my_actions[last_round_idx]
        if my_last_action:
            current_stock = my_last_payoff * 2 * n_players
        else:
            current_stock = my_last_payoff * n_players
        stock_ratio = current_stock / capacity
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        opponent_coop_rate = opponent_cooperators / (n_players - 1)
        if stock_ratio <= 0.15:
            if opponent_coop_rate >= 0.6:
                return Action.C
            else:
                return Action.D
        if stock_ratio <= 0.3:
            if opponent_coop_rate >= 0.8:
                return Action.C
            else:
                return Action.D
        if opponent_coop_rate <= 0.3:
            return Action.D
        if opponent_coop_rate >= 0.7:
            rounds_remaining = total_rounds - current_round
            if rounds_remaining <= 3:
                return Action.D
            else:
                return Action.C
        return Action.D

class Strategy_AGGRESSIVE_8(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Resource Predator"
    
    Operates on aggressive resource extraction while maintaining minimal sustainability.
    Exploits cooperative opponents and joins mass defection when profitable.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        current_stock = self._estimate_current_stock(history)
        if current_round == total_rounds:
            return Action.D
        stock_ratio = current_stock / capacity
        if stock_ratio < 0.1:
            return Action.C
        last_round_idx = history.round_number - 1
        if last_round_idx >= 0:
            cooperators = sum(history.opponent_actions[last_round_idx])
            defectors = n_players - 1 - cooperators
            cooperation_rate = cooperators / (n_players - 1)
            defection_rate = defectors / (n_players - 1)
            if cooperation_rate >= 0.6:
                return Action.D
            if defection_rate >= 0.8:
                return Action.D
        if current_round >= 0.8 * total_rounds and stock_ratio >= 0.3:
            return Action.D
        if stock_ratio >= 0.4:
            return Action.D
        elif stock_ratio >= 0.15:
            return Action.D if random.random() < 0.8 else Action.C
        else:
            return Action.C

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game history."""
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        stock = capacity
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_cooperators = sum(history.opponent_actions[round_idx])
            opponent_defectors = n_players - 1 - opponent_cooperators
            total_cooperators = opponent_cooperators + (1 if my_action else 0)
            total_defectors = opponent_defectors + (0 if my_action else 1)
            consumption = total_cooperators * stock / (2 * n_players) + total_defectors * stock / n_players
            stock_after_consumption = max(0, stock - consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            else:
                growth = 0
            stock = min(stock_after_consumption + growth, capacity)
            if stock < 0:
                stock = 0
        return stock

class Strategy_AGGRESSIVE_9(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Predator"
    
    This strategy prioritizes immediate maximum payoffs while maintaining the resource 
    just enough to continue exploitation. It exploits other players' conservation efforts 
    while maximizing its own consumption through conditional aggressive exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.n_rounds:
            return Action.D
        stock_level = self._estimate_current_stock(history)
        extinction_threshold = self.capacity * 0.15
        low_stock_threshold = self.capacity * 0.4
        if stock_level <= extinction_threshold:
            return Action.C
        last_round_idx = history.round_number - 1
        cooperation_rate = np.mean(history.opponent_actions[last_round_idx])
        if stock_level > extinction_threshold:
            if cooperation_rate >= 0.5:
                return Action.D
            elif stock_level < low_stock_threshold:
                return Action.C
            else:
                return Action.D
        return Action.C

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """
        Estimate current stock level based on game dynamics.
        This is a simplified estimation since we don't have direct stock observations.
        """
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            my_cooperate = bool(my_action)
            opponent_cooperators = np.sum(opponent_actions)
            opponent_defectors = self.n_players - 1 - opponent_cooperators
            total_cooperators = opponent_cooperators + (1 if my_cooperate else 0)
            total_defectors = opponent_defectors + (0 if my_cooperate else 1)
            cooperator_consumption = total_cooperators * (stock / (2 * self.n_players))
            defector_consumption = total_defectors * (stock / self.n_players)
            total_consumption = cooperator_consumption + defector_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

class Strategy_AGGRESSIVE_10(BaseStrategy):
    """
    Resource Dominance Strategy: Aggressive exploitation with minimal sustainability measures.
    Defaults to defection while using stock-level triggers to maintain viability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        last_payoff = history.my_payoffs[-1]
        last_action = history.my_actions[-1]
        if last_action:
            last_stock = last_payoff * 2 * n_players
        else:
            last_stock = last_payoff * n_players
        stock_ratio = last_stock / capacity
        rounds_remaining = total_rounds - current_round + 1
        if rounds_remaining == 0:
            return Action.D
        if stock_ratio < 0.15:
            if rounds_remaining > 2:
                return Action.C
            else:
                return Action.D
        if stock_ratio > 0.6:
            return Action.D
        if stock_ratio > 0.3:
            if current_round <= total_rounds * 0.7:
                return Action.D
            elif current_round % 2 == 1:
                return Action.D
            else:
                return Action.C
        if rounds_remaining > total_rounds * 0.3:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_11(BaseStrategy):
    """
    Aggressive "Predatory Exploitation" strategy that maximizes resource extraction
    while strategically preserving minimal stock. Uses threshold-based decision making
    with adaptive components based on opponent behavior and stock dynamics.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_num = history.round_number + 1
        if round_num == self.r:
            return Action.D
        current_stock = self._calculate_current_stock(history)
        high_threshold = self.capacity * 0.4
        low_threshold = self.capacity * 0.15
        if round_num > self.r * 0.8:
            high_threshold = self.capacity * 0.25
        if history.round_number >= 3:
            recent_cooperation_rate = self._calculate_recent_cooperation(history, 3)
            if recent_cooperation_rate >= 0.6:
                high_threshold *= 0.8
            elif recent_cooperation_rate <= 0.3:
                high_threshold *= 1.2
        if history.round_number >= 3:
            stock_decline_rate = self._calculate_stock_decline_rate(history)
            if stock_decline_rate > self.capacity * 0.15:
                return Action.C
        if current_stock < self.capacity * 0.05:
            return Action.C
        if current_stock >= high_threshold:
            return Action.D
        elif current_stock >= low_threshold:
            return Action.C
        else:
            return Action.D

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game history."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            total_consumption = 0.0
            if history.my_actions[round_idx]:
                my_consumption = stock / (2 * self.n)
            else:
                my_consumption = stock / self.n
            total_consumption += my_consumption
            for opponent_idx in range(self.n - 1):
                if history.opponent_actions[round_idx, opponent_idx]:
                    opponent_consumption = stock / (2 * self.n)
                else:
                    opponent_consumption = stock / self.n
                total_consumption += opponent_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _calculate_recent_cooperation(self, history: PlayerHistory, lookback_rounds: int) -> float:
        """Calculate cooperation rate of opponents over last N rounds."""
        start_round = max(0, history.round_number - lookback_rounds)
        total_opponents = 0
        total_cooperations = 0
        for round_idx in range(start_round, history.round_number):
            for opponent_idx in range(self.n - 1):
                total_opponents += 1
                if history.opponent_actions[round_idx, opponent_idx]:
                    total_cooperations += 1
        if total_opponents == 0:
            return 0.0
        return total_cooperations / total_opponents

    def _calculate_stock_decline_rate(self, history: PlayerHistory) -> float:
        """Calculate rate of stock decline over last 3 rounds."""
        if history.round_number < 3:
            return 0.0
        current_stock = self._calculate_current_stock(history)
        temp_history = PlayerHistory(my_actions=history.my_actions[:-3] if len(history.my_actions) > 3 else np.array([]), my_payoffs=history.my_payoffs[:-3] if len(history.my_payoffs) > 3 else np.array([]), opponent_actions=history.opponent_actions[:-3] if len(history.opponent_actions) > 3 else np.array([]).reshape(0, self.n - 1), opponent_payoffs=history.opponent_payoffs[:-3] if len(history.opponent_payoffs) > 3 else np.array([]).reshape(0, self.n - 1))
        if len(temp_history.my_actions) == 0:
            stock_3_rounds_ago = float(self.capacity)
        else:
            stock_3_rounds_ago = self._calculate_current_stock(temp_history)
        return (stock_3_rounds_ago - current_stock) / 3

class Strategy_AGGRESSIVE_12(BaseStrategy):
    """
    Aggressive Predator Strategy: Ruthlessly opportunistic exploitation with minimal restraint.
    
    Maximizes individual payoffs by being aggressive while maintaining just enough cooperation
    to keep the resource pool viable for continued exploitation. Establishes early dominance,
    exploits others' cooperation, and only cooperates when absolutely necessary for resource survival.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.n_rounds:
            return Action.D
        stock = self._estimate_current_stock(history)
        critical_threshold = self.capacity * 0.15
        if stock <= critical_threshold:
            return Action.C
        last_round_idx = history.round_number - 1
        defectors_last_round = self.n_players - sum(history.opponent_actions[last_round_idx])
        if not history.my_actions[last_round_idx]:
            defectors_last_round += 1
        if defectors_last_round <= self.n_players / 3:
            return Action.D
        if defectors_last_round >= 2 * self.n_players / 3:
            if random.random() < 0.3:
                return Action.C
            else:
                return Action.D
        if random.random() < 0.2:
            return Action.C
        else:
            return Action.D

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game dynamics."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0.0
            if my_action:
                total_consumption += stock / (2 * self.n_players)
            else:
                total_consumption += stock / self.n_players
            for opp_action in opponent_actions:
                if opp_action:
                    total_consumption += stock / (2 * self.n_players)
                else:
                    total_consumption += stock / self.n_players
            stock_after_consumption = max(0.0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

class Strategy_AGGRESSIVE_13(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Predatory Harvester"
    
    Maximizes immediate extraction while strategically managing the resource to maintain 
    future exploitation opportunities. Exploits cooperative opponents, competes aggressively 
    when others defect, and uses tactical cooperation only to rebuild the pool for future exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        final_round = self.game_description.n_rounds
        if current_round == final_round:
            return Action.D
        stock = self._estimate_current_stock(history)
        if history.round_number > 0:
            last_round_actions = history.opponent_actions[history.round_number - 1]
            others_coop_rate = np.sum(last_round_actions) / (n - 1)
        else:
            others_coop_rate = 0.5
        critical_threshold = capacity * 0.2
        exploitation_threshold = capacity * 0.6
        if stock <= critical_threshold:
            return Action.D
        elif stock >= exploitation_threshold and others_coop_rate > 0.5:
            return Action.D
        elif others_coop_rate < 0.3:
            return Action.D
        else:
            return Action.C

    def _estimate_current_stock(self, history):
        """Estimate current stock level based on game history."""
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        stock = float(capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0.0
            if my_action:
                total_consumption += stock / (2 * n)
            else:
                total_consumption += stock / n
            for opponent_action in opponent_actions:
                if opponent_action:
                    total_consumption += stock / (2 * n)
                else:
                    total_consumption += stock / n
            stock_after_consumption = max(0.0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            else:
                growth = 0.0
            stock = min(stock_after_consumption + growth, capacity)
        return stock

class Strategy_AGGRESSIVE_14(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Resource Raider"
    
    Operates on aggressive resource extraction while maintaining minimal sustainability.
    Three phases: Early Aggression, Tactical Evaluation, and End Game Exploitation.
    Prioritizes individual gain over collective welfare through strategic timing.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        current_stock = self._estimate_current_stock(history)
        if current_round <= self.n_rounds / 3:
            return Action.D
        elif current_round > 2 * self.n_rounds / 3:
            return self._end_game_strategy(current_round, current_stock)
        else:
            return self._tactical_evaluation(history, current_stock)

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock based on consumption and growth dynamics"""
        stock = self.capacity
        for round_idx in range(history.round_number):
            my_consumption = stock / (2 * self.n_players) if history.my_actions[round_idx] else stock / self.n_players
            opponent_consumption = 0
            for player_idx in range(self.n_players - 1):
                if history.opponent_actions[round_idx, player_idx]:
                    opponent_consumption += stock / (2 * self.n_players)
                else:
                    opponent_consumption += stock / self.n_players
            total_consumption = my_consumption + opponent_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _end_game_strategy(self, current_round: int, current_stock: float) -> Action:
        """End game exploitation strategy"""
        rounds_remaining = self.n_rounds - current_round + 1
        if rounds_remaining == 1:
            return Action.D
        if rounds_remaining == 2:
            if current_stock <= self.capacity / 8:
                return Action.C
            else:
                return Action.D
        return Action.D

    def _tactical_evaluation(self, history: PlayerHistory, current_stock: float) -> Action:
        """Middle phase tactical decision making"""
        last_round_idx = history.round_number - 1
        if current_stock < self.capacity / 4:
            if random.random() < 0.3:
                return Action.C
            else:
                return Action.D
        if last_round_idx >= 0:
            opponent_defections = sum((1 for i in range(self.n_players - 1) if not history.opponent_actions[last_round_idx, i]))
            majority_defected = opponent_defections > (self.n_players - 1) / 2
            if majority_defected:
                return Action.D
        if current_stock > self.capacity / 2 and last_round_idx >= 0:
            opponent_cooperations = sum((1 for i in range(self.n_players - 1) if history.opponent_actions[last_round_idx, i]))
            majority_cooperated = opponent_cooperations > (self.n_players - 1) / 2
            if majority_cooperated:
                return Action.D
        if random.random() < 0.4:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_15(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Predator"
    
    This strategy operates on the principle of maximum short-term extraction while exploiting cooperative opponents.
    It uses conditional aggression based on stock levels, cooperation rates, and game position to maximize individual payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.n_rounds:
            return Action.D
        current_stock = self._estimate_current_stock(history)
        if current_stock <= self.capacity * 0.3:
            return Action.D
        if current_stock <= self.capacity * 0.1:
            return Action.D
        if history.round_number > 0:
            last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
            cooperation_rate = last_round_cooperators / self.n_players
            if cooperation_rate >= 0.6:
                return Action.D
            if cooperation_rate <= 0.3:
                return Action.D
            if cooperation_rate == 1.0 and history.round_number >= 2:
                prev_round_cooperators = sum(history.opponent_actions[history.round_number - 2])
                if prev_round_cooperators == self.n_players:
                    return Action.D
            if current_stock >= self.capacity * 0.8 and cooperation_rate >= 0.5:
                return Action.C
        if current_round >= self.n_rounds // 2:
            my_total_payoff = sum(history.my_payoffs)
            avg_opponent_payoff = np.mean(np.sum(history.opponent_payoffs, axis=0))
            if my_total_payoff < avg_opponent_payoff * 0.8:
                return Action.D
        return Action.D

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game history"""
        current_stock = float(self.capacity)
        for round_idx in range(history.round_number):
            cooperators = sum(history.opponent_actions[round_idx])
            defectors = self.n_players - cooperators
            if history.my_actions[round_idx]:
                cooperators += 1
            else:
                defectors += 1
            cooperator_consumption = current_stock / (2 * self.n_players)
            defector_consumption = current_stock / self.n_players
            total_consumption = cooperators * cooperator_consumption + defectors * defector_consumption
            stock_after_consumption = max(0, current_stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            current_stock = min(stock_after_consumption + growth, self.capacity)
        return current_stock

class Strategy_AGGRESSIVE_16(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Resource Predator"
    
    Maximizes individual payoffs through aggressive resource extraction while maintaining
    just enough sustainability to prevent complete resource collapse. Uses a threshold
    system with strategic preservation only when necessary.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_rounds_remaining = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        r = self.game_description.n_rounds
        current_stock = self._calculate_current_stock(history, capacity, n)
        if current_round >= r - 1:
            return Action.D
        if self.punishment_rounds_remaining > 0:
            self.punishment_rounds_remaining -= 1
            return Action.D
        if self._should_punish(history, capacity):
            self.punishment_rounds_remaining = 1
            return Action.D
        if self._stock_dropped_significantly(history, capacity, n):
            return Action.D
        stock_ratio = current_stock / capacity
        if stock_ratio >= 0.4:
            return Action.D
        elif stock_ratio >= 0.15:
            return Action.C
        else:
            return Action.D

    def _calculate_current_stock(self, history: PlayerHistory, capacity: float, n: int) -> float:
        """Calculate current stock level based on game dynamics."""
        stock = capacity
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            cooperators = int(my_action) + sum(opponent_actions)
            defectors = n - cooperators
            cooperator_consumption = stock / (2 * n)
            defector_consumption = stock / n
            total_consumption = cooperators * cooperator_consumption + defectors * defector_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            stock = min(stock_after_consumption + growth, capacity)
        return stock

    def _should_punish(self, history: PlayerHistory, capacity: float) -> bool:
        """Check if any player defected when stock was critically low in previous round."""
        if history.round_number == 0:
            return False
        prev_stock = self._calculate_stock_at_round(history, capacity, history.round_number - 1)
        if prev_stock < 0.2 * capacity:
            prev_opponent_actions = history.opponent_actions[history.round_number - 1]
            if any((not action for action in prev_opponent_actions)):
                return True
        return False

    def _stock_dropped_significantly(self, history: PlayerHistory, capacity: float, n: int) -> bool:
        """Check if stock dropped by more than 30% in the previous round."""
        if history.round_number < 2:
            return False
        stock_two_rounds_ago = self._calculate_stock_at_round(history, capacity, history.round_number - 2)
        stock_last_round = self._calculate_stock_at_round(history, capacity, history.round_number - 1)
        if stock_two_rounds_ago == 0:
            return False
        drop_percentage = (stock_two_rounds_ago - stock_last_round) / stock_two_rounds_ago
        return drop_percentage > 0.3

    def _calculate_stock_at_round(self, history: PlayerHistory, capacity: float, target_round: int) -> float:
        """Calculate stock level at the end of a specific round."""
        stock = capacity
        n = self.game_description.n_players
        for round_idx in range(target_round + 1):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            cooperators = int(my_action) + sum(opponent_actions)
            defectors = n - cooperators
            cooperator_consumption = stock / (2 * n)
            defector_consumption = stock / n
            total_consumption = cooperators * cooperator_consumption + defectors * defector_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            stock = min(stock_after_consumption + growth, capacity)
        return stock

class Strategy_AGGRESSIVE_17(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Opportunistic Predator"
    
    Maximizes short-term gains by exploiting cooperative behavior while minimizing 
    exposure to retaliation. Always defects in round 1, exploits cooperative majorities,
    and includes emergency conservation when stock is critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_num = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        current_stock = self._calculate_current_stock(history)
        stock_ratio = current_stock / capacity
        rounds_remaining = total_rounds - round_num
        if stock_ratio <= 0.15:
            return Action.C
        if history.round_number > 0:
            last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
            cooperation_rate = last_round_cooperators / (n_players - 1)
            if cooperation_rate >= 0.5:
                return Action.D
        if self._is_behind_average(history):
            return Action.D
        if rounds_remaining <= 3:
            return Action.D
        return Action.C

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game history."""
        stock = float(self.game_description.capacity)
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            cooperators = int(my_action) + sum(opponent_actions)
            defectors = n_players - cooperators
            cooperator_consumption = stock / (2 * n_players)
            defector_consumption = stock / n_players
            total_consumption = cooperators * cooperator_consumption + defectors * defector_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
                stock = min(stock_after_consumption + growth, capacity)
            else:
                stock = 0
        return stock

    def _is_behind_average(self, history: PlayerHistory) -> bool:
        """Check if current cumulative payoff is below average opponent payoff."""
        if history.round_number == 0:
            return False
        my_total_payoff = sum(history.my_payoffs)
        opponent_total_payoffs = np.sum(history.opponent_payoffs, axis=0)
        average_opponent_payoff = np.mean(opponent_total_payoffs)
        return my_total_payoff < average_opponent_payoff

class Strategy_AGGRESSIVE_18(BaseStrategy):
    """
    Aggressive "Strike Fast" Strategy: Maximizes immediate gains when resources are abundant,
    then adapts based on competitive pressure. Always defects early and in endgame phases.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        early_phase_end = max(2, self.n_rounds // 4)
        if current_round <= early_phase_end:
            return Action.D
        rounds_remaining = self.n_rounds - current_round + 1
        if rounds_remaining <= 2:
            return Action.D
        current_stock = self._estimate_current_stock(history)
        last_round_idx = history.round_number - 1
        defect_rate = self._calculate_defect_rate(history, last_round_idx)
        stock_health = current_stock / self.capacity if self.capacity > 0 else 0
        if stock_health > 0.7:
            return Action.D
        if defect_rate >= 0.6:
            return Action.D
        if current_stock > self.capacity * 0.4 and defect_rate >= 0.3:
            return Action.D
        if stock_health < 0.3 and defect_rate < 0.3:
            return Action.C
        else:
            return Action.D

    def _calculate_defect_rate(self, history: PlayerHistory, round_idx: int) -> float:
        """Calculate the defection rate for a given round."""
        if round_idx < 0 or round_idx >= len(history.opponent_actions):
            return 0.0
        opponent_defections = sum((1 for action in history.opponent_actions[round_idx] if not action))
        my_defection = 1 if not history.my_actions[round_idx] else 0
        total_defections = opponent_defections + my_defection
        total_players = self.n_players
        return total_defections / total_players if total_players > 0 else 0.0

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game history."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0.0
            if my_action:
                total_consumption += stock / (2 * self.n_players)
            else:
                total_consumption += stock / self.n_players
            for opp_action in opponent_actions:
                if opp_action:
                    total_consumption += stock / (2 * self.n_players)
                else:
                    total_consumption += stock / self.n_players
            stock_after_consumption = max(0.0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth_rate = 1 - stock_after_consumption / self.capacity
                growth = 2 * stock_after_consumption * growth_rate
            else:
                growth = 0.0
            stock = min(stock_after_consumption + growth, self.capacity)
            stock = max(0.0, stock)
        return stock

class Strategy_AGGRESSIVE_19(BaseStrategy):
    """
    Aggressive "Exploit-Then-Pillage" Strategy
    
    Operates in three phases:
    1. Early Exploitation (first 1/3): Always defect to maximize gains when stock is high
    2. Conditional Opportunism (middle 1/3): Defect unless stock is very low and most opponents cooperated
    3. Endgame Pillaging (final 1/3): Always defect to extract maximum value before game ends
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.phase_1_end = math.floor(self.n_rounds / 3)
        self.phase_2_end = math.floor(2 * self.n_rounds / 3)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        stock = self._calculate_current_stock(history)
        if current_round <= self.phase_1_end:
            return Action.D
        if current_round > self.phase_2_end:
            return Action.D
        if stock > self.capacity / 3:
            return Action.D
        else:
            if history.round_number > 0:
                last_round_actions = history.opponent_actions[history.round_number - 1]
                cooperators = np.sum(last_round_actions)
                cooperation_rate = cooperators / self.n_players
                if cooperation_rate >= 0.75:
                    return Action.C
            return Action.D

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate the current stock level based on game history."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0.0
            if my_action:
                total_consumption += stock / (2 * self.n_players)
            else:
                total_consumption += stock / self.n_players
            for opponent_action in opponent_actions:
                if opponent_action:
                    total_consumption += stock / (2 * self.n_players)
                else:
                    total_consumption += stock / self.n_players
            stock_after_consumption = max(0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            else:
                growth = 0
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

class Strategy_AGGRESSIVE_20(BaseStrategy):
    """
    Opportunistic Predator: An aggressive resource extraction strategy that exploits cooperative
    opponents while minimally cooperating only when absolutely necessary for resource preservation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_num = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        stock_level = self._calculate_current_stock(history)
        if history.round_number > 0:
            last_round_actions = history.opponent_actions[history.round_number - 1]
            cooperator_ratio = np.sum(last_round_actions) / (n_players - 1)
        else:
            cooperator_ratio = 0
        stock_ratio = stock_level / capacity
        rounds_remaining = total_rounds - round_num + 1
        if stock_ratio < 0.15 and rounds_remaining > 3:
            return Action.C
        if rounds_remaining <= 1:
            return Action.D
        if round_num <= 3:
            return Action.D
        if cooperator_ratio > 0.6:
            return Action.D
        if stock_ratio > 0.5:
            return Action.D
        if stock_ratio < 0.3 and rounds_remaining > 2:
            return Action.C
        return Action.D

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game dynamics."""
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        stock = float(capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0
            if my_action:
                total_consumption += stock / (2 * n_players)
            else:
                total_consumption += stock / n_players
            for opp_action in opponent_actions:
                if opp_action:
                    total_consumption += stock / (2 * n_players)
                else:
                    total_consumption += stock / n_players
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            stock = min(stock_after_consumption + growth, capacity)
        return stock

class Strategy_AGGRESSIVE_21(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Early Hawk"
    
    Operates on aggressive early exploitation while maintaining strategic flexibility.
    Always starts with defection, exploits high stock levels, follows majority defection,
    and only cooperates strategically when the pool is critically low and others are cooperating.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.n_rounds:
            return Action.D
        stock = self._calculate_current_stock(history)
        last_round_actions = history.opponent_actions[history.round_number - 1]
        defectors = sum((1 for action in last_round_actions if not action))
        if not history.my_actions[history.round_number - 1]:
            defectors += 1
        defection_rate = defectors / self.n_players
        if stock > self.capacity * 0.7:
            return Action.D
        if defection_rate >= 0.5:
            return Action.D
        if stock < self.capacity * 0.3 and defection_rate < 0.3:
            return Action.C
        return Action.D

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate the current stock level based on game dynamics."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            total_consumption = 0
            if history.my_actions[round_idx]:
                my_consumption = stock / (2 * self.n_players)
            else:
                my_consumption = stock / self.n_players
            total_consumption += my_consumption
            for opponent_idx in range(self.n_players - 1):
                if history.opponent_actions[round_idx, opponent_idx]:
                    opponent_consumption = stock / (2 * self.n_players)
                else:
                    opponent_consumption = stock / self.n_players
                total_consumption += opponent_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            else:
                growth = 0
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

class Strategy_AGGRESSIVE_22(BaseStrategy):
    """
    Aggressive Resource Extraction Strategy: "Ruthless Opportunist"
    
    Prioritizes immediate payoff maximization while exploiting cooperative opponents.
    Always defects in first and last rounds, exploits high cooperation periods,
    and adapts aggression based on opponent behavior and resource levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.n_rounds:
            return Action.D
        current_stock = self.capacity
        for round_idx in range(history.round_number):
            my_consumption = self._get_consumption(history.my_actions[round_idx], current_stock)
            opponent_consumptions = sum((self._get_consumption(history.opponent_actions[round_idx, opp], current_stock) for opp in range(self.n_players - 1)))
            total_consumption = my_consumption + opponent_consumptions
            stock_after_consumption = max(0, current_stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            current_stock = min(stock_after_consumption + growth, self.capacity)
        total_opponent_actions = (self.n_players - 1) * history.round_number
        opponent_cooperations = np.sum(history.opponent_actions)
        cooperation_rate = opponent_cooperations / total_opponent_actions if total_opponent_actions > 0 else 0
        stock_ratio = current_stock / self.capacity
        if stock_ratio < 0.3:
            return Action.D
        if cooperation_rate < 0.4:
            return Action.D
        if cooperation_rate > 0.7 and stock_ratio > 0.6:
            return Action.D
        if current_round <= self.n_rounds / 3:
            return Action.D
        if cooperation_rate > 0.5:
            return Action.D
        else:
            return Action.C

    def _get_consumption(self, action_bool: bool, stock: float) -> float:
        """Calculate consumption based on action and current stock."""
        if action_bool:
            return stock / (2 * self.n_players)
        else:
            return stock / self.n_players

class Strategy_AGGRESSIVE_23(BaseStrategy):
    """
    Opportunistic Predator: An aggressive exploitation strategy that maximizes short-term gains
    through front-loaded resource extraction, adaptive exploitation based on stock levels and
    opponent behavior, and strategic end-game defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_num = history.round_number + 1
        current_stock = self._calculate_current_stock(history)
        phase_1_end = self.n_rounds // 3
        phase_2_end = 2 * self.n_rounds // 3
        if round_num == self.n_rounds:
            return Action.D
        if round_num <= phase_1_end:
            return Action.D
        if round_num <= phase_2_end:
            if current_stock > self.capacity / 2:
                return Action.D
            if current_stock < self.capacity / 4:
                return Action.C
            if history.round_number > 0:
                last_round_idx = history.round_number - 1
                opponent_actions_last = history.opponent_actions[last_round_idx]
                if not all(opponent_actions_last) and current_stock < self.capacity / 2:
                    return Action.D
                if all(opponent_actions_last) and current_stock < self.capacity / 2:
                    return Action.C
            return Action.D
        elif current_stock < self.capacity / 3:
            return Action.C
        else:
            return Action.D

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game dynamics."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            total_consumption = 0.0
            if history.my_actions[round_idx]:
                my_consumption = stock / (2 * self.n_players)
            else:
                my_consumption = stock / self.n_players
            total_consumption += my_consumption
            for opponent_idx in range(self.n_players - 1):
                if history.opponent_actions[round_idx, opponent_idx]:
                    opponent_consumption = stock / (2 * self.n_players)
                else:
                    opponent_consumption = stock / self.n_players
                total_consumption += opponent_consumption
            stock_after_consumption = max(0.0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

class Strategy_AGGRESSIVE_24(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Predator"
    
    Maximizes immediate payoffs while strategically managing the resource to maintain 
    exploitation opportunities. Uses conditional defection based on opponent cooperation 
    rates and resource levels, with aggressive thresholds designed to exploit cooperative 
    behavior while avoiding total resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.n_rounds:
            return Action.D
        stock = self._estimate_current_stock(history)
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        coop_rate = cooperators_last_round / (self.n_players - 1)
        if stock < self.capacity * 0.15:
            return Action.C
        if stock < self.capacity * 0.3:
            if coop_rate > 0.6:
                return Action.D
            else:
                return Action.C
        if coop_rate >= 0.5:
            return Action.D
        if coop_rate >= 0.3:
            my_avg_payoff = np.mean(history.my_payoffs)
            opponent_avg_payoff = np.mean(history.opponent_payoffs)
            if my_avg_payoff < opponent_avg_payoff:
                return Action.D
            else:
                return Action.C
        if stock > self.capacity * 0.7:
            return Action.D
        else:
            return Action.C

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game history."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_action_was_coop = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            if my_action_was_coop:
                my_consumption = stock / (2 * self.n_players)
            else:
                my_consumption = stock / self.n_players
            opponent_consumption = 0
            for opp_action in opponent_actions:
                if opp_action:
                    opponent_consumption += stock / (2 * self.n_players)
                else:
                    opponent_consumption += stock / self.n_players
            total_consumption = my_consumption + opponent_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            else:
                growth = 0
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

class Strategy_AGGRESSIVE_25(BaseStrategy):
    """
    Predatory Opportunist: Aggressive exploitation strategy that maximizes individual payoff
    through conditional defection based on game phase and opponent cooperation levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round <= 0.2 * self.n_rounds:
            return Action.D
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        cooperation_rate = cooperators_last_round / (self.n_players - 1)
        recent_payoff = history.my_payoffs[-1]
        if history.my_actions[-1]:
            estimated_stock = recent_payoff * (2 * self.n_players)
        else:
            estimated_stock = recent_payoff * self.n_players
        if estimated_stock < 0.15 * self.capacity:
            if cooperation_rate < 0.5:
                return Action.C
            else:
                return Action.D
        if current_round > 0.8 * self.n_rounds:
            return Action.D
        if cooperation_rate >= 0.6:
            return Action.D
        elif estimated_stock < 0.3 * self.capacity:
            if cooperation_rate >= 0.4:
                return Action.D
            else:
                return Action.C
        elif cooperation_rate >= 0.3:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_26(BaseStrategy):
    """
    Resource Predator Strategy: Aggressive exploitation with minimal strategic cooperation.
    Maximizes immediate extraction while preventing complete resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_num = history.round_number + 1
        if round_num == 2:
            return Action.D
        current_stock = self._estimate_current_stock(history)
        if round_num == self.n_rounds:
            return Action.D
        if round_num == self.n_rounds - 1:
            if current_stock > self.capacity * 0.4:
                return Action.D
            else:
                return Action.C
        if current_stock < self.capacity * 0.1:
            return Action.C
        if current_stock < self.capacity * 0.3:
            return Action.C
        last_round_idx = history.round_number - 1
        opponent_cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        majority_defected_last_round = opponent_cooperators_last_round < (self.n_players - 1) / 2
        if current_stock < self.capacity * 0.5 and majority_defected_last_round:
            return Action.C
        my_total_payoff = sum(history.my_payoffs)
        avg_opponent_payoff = np.mean(np.sum(history.opponent_payoffs, axis=0))
        if my_total_payoff < avg_opponent_payoff * 0.9:
            return Action.D
        if current_stock > self.capacity * 0.6 and random.random() < 0.1:
            return Action.C
        if round_num > self.n_rounds / 2 and current_stock > self.capacity * 0.8:
            if random.random() < 0.95:
                return Action.D
        if opponent_cooperators_last_round == self.n_players - 1:
            return Action.D
        return Action.D

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game dynamics."""
        stock = self.capacity
        for round_idx in range(history.round_number):
            my_consumption = stock / (2 * self.n_players) if history.my_actions[round_idx] else stock / self.n_players
            opponent_consumption = 0
            for player_idx in range(self.n_players - 1):
                if history.opponent_actions[round_idx, player_idx]:
                    opponent_consumption += stock / (2 * self.n_players)
                else:
                    opponent_consumption += stock / self.n_players
            total_consumption = my_consumption + opponent_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

class Strategy_AGGRESSIVE_27(BaseStrategy):
    """
    Vampire Strategy: Aggressive exploitation strategy that maximizes immediate gains
    while exploiting others' cooperation. Treats the common pool as a resource to be
    drained rather than sustained, with minimal cooperation only when absolutely necessary.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        current_stock = self._calculate_current_stock(history, capacity, n_players)
        rounds_remaining = total_rounds - current_round
        if current_round == total_rounds:
            return Action.D
        recent_cooperation_rate = self._calculate_recent_cooperation(history, 2)
        if current_stock > capacity * 0.6:
            return Action.D
        if current_stock > capacity * 0.3:
            if recent_cooperation_rate > 0.6:
                return Action.D
            elif rounds_remaining > 4:
                return Action.D
            else:
                return Action.D
        if current_stock > capacity * 0.15:
            if rounds_remaining <= 2:
                return Action.D
            elif recent_cooperation_rate < 0.3:
                return Action.D
            else:
                return Action.C
        if rounds_remaining > 1:
            return Action.C
        else:
            return Action.D

    def _calculate_current_stock(self, history: PlayerHistory, capacity: float, n_players: int) -> float:
        """Calculate current stock level based on game history."""
        stock = capacity
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0
            if my_action:
                total_consumption += stock / (2 * n_players)
            else:
                total_consumption += stock / n_players
            for opp_action in opponent_actions:
                if opp_action:
                    total_consumption += stock / (2 * n_players)
                else:
                    total_consumption += stock / n_players
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            stock = min(stock_after_consumption + growth, capacity)
        return stock

    def _calculate_recent_cooperation(self, history: PlayerHistory, lookback_rounds: int) -> float:
        """Calculate cooperation rate of opponents in recent rounds."""
        if history.round_number == 0:
            return 0.5
        start_round = max(0, history.round_number - lookback_rounds)
        total_decisions = 0
        total_cooperations = 0
        for round_idx in range(start_round, history.round_number):
            opponent_actions = history.opponent_actions[round_idx]
            total_decisions += len(opponent_actions)
            total_cooperations += sum(opponent_actions)
        if total_decisions == 0:
            return 0.5
        return total_cooperations / total_decisions

class Strategy_AGGRESSIVE_28(BaseStrategy):
    """
    Aggressive Resource Exploitation Strategy: "Predatory Harvester"
    
    Operates on aggressive resource extraction while maintaining minimal sustainability.
    Exploits cooperative opponents and applies strategic pressure to force favorable outcomes.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        rounds_remaining = self.n_rounds - current_round + 1
        current_stock = self._estimate_current_stock(history)
        if current_stock <= self.capacity * 0.15:
            return Action.C
        if rounds_remaining <= 2:
            return Action.D
        recent_coop_rate = self._calculate_recent_cooperation_rate(history)
        if recent_coop_rate >= 0.6:
            return Action.D
        if recent_coop_rate <= 0.3 and current_stock >= self.capacity * 0.4:
            return Action.D
        if current_stock <= self.capacity * 0.3:
            return Action.C
        return Action.D

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game history."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            total_consumption = 0.0
            if history.my_actions[round_idx]:
                total_consumption += stock / (2 * self.n_players)
            else:
                total_consumption += stock / self.n_players
            for opponent_idx in range(self.n_players - 1):
                if history.opponent_actions[round_idx, opponent_idx]:
                    total_consumption += stock / (2 * self.n_players)
                else:
                    total_consumption += stock / self.n_players
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate opponent cooperation rate in the last 3 rounds."""
        rounds_to_check = min(3, history.round_number)
        if rounds_to_check == 0:
            return 0.0
        total_cooperations = 0
        total_actions = 0
        start_round = history.round_number - rounds_to_check
        for round_idx in range(start_round, history.round_number):
            for opponent_idx in range(self.n_players - 1):
                if history.opponent_actions[round_idx, opponent_idx]:
                    total_cooperations += 1
                total_actions += 1
        if total_actions == 0:
            return 0.0
        return total_cooperations / total_actions

class Strategy_AGGRESSIVE_29(BaseStrategy):
    """
    Aggressive Predator Strategy: Maximizes early resource extraction while maintaining
    strategic sustainability. Uses adaptive aggression based on stock health and 
    tournament positioning to build commanding leads through front-loaded exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_number = history.round_number + 1
        stock = self._calculate_current_stock(history)
        if round_number == self.n_rounds:
            return Action.D
        if round_number == self.n_rounds - 1:
            if stock > 0.2 * self.capacity:
                return Action.D
            else:
                my_total = np.sum(history.my_payoffs)
                opponent_totals = np.sum(history.opponent_payoffs, axis=0)
                max_opponent_total = np.max(opponent_totals) if len(opponent_totals) > 0 else 0
                if my_total >= max_opponent_total:
                    return Action.C
                else:
                    return Action.D
        bias_toward_defection = self._check_tournament_position(history)
        stock_ratio = stock / self.capacity
        if stock_ratio >= 0.7:
            return Action.D
        elif stock_ratio >= 0.3:
            if round_number <= 3:
                return Action.D
            majority_defected = self._majority_defected_last_round(history)
            if majority_defected or bias_toward_defection:
                return Action.D
            else:
                return Action.C
        elif stock_ratio >= 0.1:
            if bias_toward_defection:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game dynamics."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            my_cooperated = bool(my_action)
            opponent_cooperators = np.sum(opponent_actions)
            opponent_defectors = self.n_players - 1 - opponent_cooperators
            total_cooperators = (1 if my_cooperated else 0) + opponent_cooperators
            total_defectors = (0 if my_cooperated else 1) + opponent_defectors
            cooperator_consumption = total_cooperators * (stock / (2 * self.n_players))
            defector_consumption = total_defectors * (stock / self.n_players)
            total_consumption = cooperator_consumption + defector_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _majority_defected_last_round(self, history: PlayerHistory) -> bool:
        """Check if majority of opponents defected in the last round."""
        if history.round_number == 0:
            return False
        last_round_opponent_actions = history.opponent_actions[history.round_number - 1]
        cooperators = np.sum(last_round_opponent_actions)
        defectors = len(last_round_opponent_actions) - cooperators
        return defectors > cooperators

    def _check_tournament_position(self, history: PlayerHistory) -> bool:
        """Check if we're falling behind and should bias toward defection."""
        my_total = np.sum(history.my_payoffs)
        opponent_totals = np.sum(history.opponent_payoffs, axis=0)
        max_opponent_total = np.max(opponent_totals) if len(opponent_totals) > 0 else 0
        return my_total < max_opponent_total * 0.9

class Strategy_AGGRESSIVE_30(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Predator"
    
    Operates on aggressive resource extraction while maintaining exploitation viability.
    Uses three phases: early dominance (always defect), strategic exploitation 
    (stock-based conditional defection), and endgame extraction (always defect).
    Only cooperates when necessary to prevent total resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.crisis_cooperation_count = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.crisis_cooperation_count = 0
            return Action.D
        round_num = history.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = self._calculate_current_stock(history, capacity, n)
        early_phase_end = r // 3
        endgame_start = 2 * r // 3 + 1
        if round_num <= early_phase_end or round_num >= endgame_start:
            self.crisis_cooperation_count = 0
            return Action.D
        if current_stock < capacity * 0.15:
            if self.crisis_cooperation_count < 2:
                self.crisis_cooperation_count += 1
                return Action.C
            else:
                self.crisis_cooperation_count = 0
                return Action.D
        self.crisis_cooperation_count = 0
        if current_stock > capacity * 0.4:
            return Action.D
        elif current_stock > capacity * 0.2:
            if random.random() < 0.7:
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

    def _calculate_current_stock(self, history: PlayerHistory, capacity: int, n: int) -> float:
        """Calculate current stock level based on game history."""
        stock = float(capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            cooperators = int(my_action) + sum(opponent_actions)
            defectors = n - cooperators
            cooperator_consumption = cooperators * (stock / (2 * n))
            defector_consumption = defectors * (stock / n)
            total_consumption = cooperator_consumption + defector_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            else:
                growth = 0
            stock = min(stock_after_consumption + growth, capacity)
            stock = max(0, stock)
        return stock

class Strategy_AGGRESSIVE_31(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Predator"
    
    This strategy maximizes individual payoffs through aggressive exploitation while maintaining
    just enough sustainability to keep extracting resources. It exploits cooperative opponents
    while only cooperating when absolutely necessary to prevent resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        stock = self._calculate_current_stock(history)
        stock_health = stock / self.capacity
        if stock_health < 0.15:
            return Action.C
        if stock_health > 0.8:
            return Action.D
        last_round_idx = history.round_number - 1
        others_cooperation_rate = np.mean(history.opponent_actions[last_round_idx])
        if current_round > 0.75 * self.r and stock_health > 0.2:
            return Action.D
        if history.round_number >= 3 and self._consistently_earning_less_than_average(history, 3):
            return Action.D
        if others_cooperation_rate > 0.6:
            return Action.D
        elif others_cooperation_rate < 0.3:
            if stock_health > 0.4:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game dynamics."""
        stock = self.capacity
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0
            if my_action:
                total_consumption += stock / (2 * self.n)
            else:
                total_consumption += stock / self.n
            for opp_action in opponent_actions:
                if opp_action:
                    total_consumption += stock / (2 * self.n)
                else:
                    total_consumption += stock / self.n
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _consistently_earning_less_than_average(self, history: PlayerHistory, num_rounds: int) -> bool:
        """Check if consistently earning less than average over last num_rounds."""
        if history.round_number < num_rounds:
            return False
        start_idx = max(0, history.round_number - num_rounds)
        my_recent_payoffs = history.my_payoffs[start_idx:]
        opponent_recent_payoffs = history.opponent_payoffs[start_idx:]
        my_avg = np.mean(my_recent_payoffs)
        all_opponent_payoffs = opponent_recent_payoffs.flatten()
        opponent_avg = np.mean(all_opponent_payoffs)
        return my_avg < opponent_avg * 0.9

class Strategy_AGGRESSIVE_32(BaseStrategy):
    """
    Predatory Harvester: An aggressive exploitation strategy that maximizes immediate 
    extraction while strategically timing minimal cooperation only when necessary to 
    maintain future exploitation opportunities.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        rounds_remaining = self.n_rounds - current_round
        current_stock = self._estimate_current_stock(history)
        if current_round == 2:
            return Action.D
        if rounds_remaining <= 1:
            return Action.D
        return self._dynamic_exploitation_decision(history, current_stock, rounds_remaining)

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game history."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_consumption = stock / (2 * self.n_players) if history.my_actions[round_idx] else stock / self.n_players
            opponent_consumption = 0
            for player_idx in range(self.n_players - 1):
                if history.opponent_actions[round_idx, player_idx]:
                    opponent_consumption += stock / (2 * self.n_players)
                else:
                    opponent_consumption += stock / self.n_players
            total_consumption = my_consumption + opponent_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
                stock = min(stock_after_consumption + growth, self.capacity)
            else:
                stock = 0
        return stock

    def _dynamic_exploitation_decision(self, history: PlayerHistory, current_stock: float, rounds_remaining: int) -> Action:
        """Make exploitation decision based on current game state."""
        if current_stock < 0.1 * self.capacity:
            if rounds_remaining <= 3:
                return Action.D
            else:
                return Action.C
        if current_stock >= 0.7 * self.capacity:
            return Action.D
        if history.round_number > 0:
            last_round_idx = history.round_number - 1
            opponents_cooperated_last_round = sum(history.opponent_actions[last_round_idx])
            majority_cooperated = opponents_cooperated_last_round > (self.n_players - 1) / 2
            if majority_cooperated:
                return Action.D
            elif self._is_stock_declining_trend(history):
                return Action.C
            else:
                return Action.D
        return Action.D

    def _is_stock_declining_trend(self, history: PlayerHistory) -> bool:
        """Check if stock has been declining for the last 2 rounds."""
        if history.round_number < 3:
            return False
        recent_stocks = []
        stock = float(self.capacity)
        for round_idx in range(min(3, history.round_number)):
            my_consumption = stock / (2 * self.n_players) if history.my_actions[round_idx] else stock / self.n_players
            opponent_consumption = 0
            for player_idx in range(self.n_players - 1):
                if history.opponent_actions[round_idx, player_idx]:
                    opponent_consumption += stock / (2 * self.n_players)
                else:
                    opponent_consumption += stock / self.n_players
            total_consumption = my_consumption + opponent_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
                stock = min(stock_after_consumption + growth, self.capacity)
            else:
                stock = 0
            recent_stocks.append(stock)
        if len(recent_stocks) >= 2:
            return recent_stocks[-1] < recent_stocks[-2] and recent_stocks[-2] < recent_stocks[0]
        return False

class Strategy_COOPERATIVE_33(BaseStrategy):
    """
    Adaptive Conditional Cooperator Strategy
    
    This strategy starts with cooperation to signal intent and establish sustainable baselines.
    It then adapts based on stock health and recent cooperation patterns, punishing widespread
    defection while rewarding cooperation. Includes realistic endgame handling.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_num = history.round_number + 1
        if round_num <= 2:
            return Action.C
        if round_num == self.r:
            return Action.D
        last_payoff = history.my_payoffs[-1]
        last_action = history.my_actions[-1]
        if last_action:
            last_stock = last_payoff * 2 * self.n
        else:
            last_stock = last_payoff * self.n
        current_stock = last_stock
        if round_num == self.r - 1:
            return Action.C if current_stock >= self.capacity * 0.3 else Action.D
        stock_ratio = current_stock / self.capacity
        if stock_ratio >= 0.6:
            return Action.C
        else:
            rounds_to_check = min(2, history.round_number)
            total_cooperators = 0
            total_actions = 0
            for i in range(rounds_to_check):
                round_idx = history.round_number - 1 - i
                if round_idx >= 0:
                    my_coop = 1 if history.my_actions[round_idx] else 0
                    opponent_coops = sum(history.opponent_actions[round_idx])
                    total_cooperators += my_coop + opponent_coops
                    total_actions += self.n
            recent_coop_ratio = total_cooperators / total_actions if total_actions > 0 else 0
            return Action.C if recent_coop_ratio >= 0.5 else Action.D

class Strategy_COOPERATIVE_34(BaseStrategy):
    """
    Conditional Cooperation with Forgiveness Strategy.
    
    Cooperates when majority of opponents cooperated in previous round,
    defects when majority defected. Always starts with cooperation.
    Includes crisis management for critically low stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        last_round_actions = history.opponent_actions[history.round_number - 1]
        defectors_last_round = sum(1 - last_round_actions)
        cooperators_last_round = sum(last_round_actions)
        if len(history.my_payoffs) > 0:
            recent_payoff = history.my_payoffs[-1]
            if history.my_actions[-1]:
                estimated_stock = recent_payoff * 2 * self.game_description.n_players
            else:
                estimated_stock = recent_payoff * self.game_description.n_players
            crisis_threshold = self.game_description.n_players * 10
            if estimated_stock < crisis_threshold:
                if defectors_last_round >= cooperators_last_round:
                    return Action.D
                else:
                    return Action.C
        if cooperators_last_round >= defectors_last_round:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_35(BaseStrategy):
    """
    Forgiving Conditional Cooperator strategy for Common Pool Resource Game.
    
    This strategy aims to establish and maintain cooperation while being robust against exploitation.
    It balances trust-building with self-protection through graduated responses based on group
    cooperation levels, forgiveness mechanisms, and resource conservation safeguards.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.consecutive_low_cooperation = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        stock_level = self._estimate_current_stock(history)
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            cooperators_last_round += 1
        cooperation_rate = cooperators_last_round / n_players
        if cooperation_rate < 0.5:
            self.consecutive_low_cooperation += 1
        else:
            self.consecutive_low_cooperation = 0
        if stock_level < capacity * 0.2:
            return Action.C
        if current_round == n_rounds:
            if cooperation_rate >= 0.5:
                return Action.C
            elif stock_level < capacity * 0.4:
                return Action.C
            else:
                return Action.D
        if cooperation_rate >= 0.75:
            return Action.C
        elif cooperation_rate >= 0.5:
            return Action.C
        elif cooperation_rate >= 0.25:
            if self.consecutive_low_cooperation >= 2:
                return Action.D
            else:
                return Action.C
        elif stock_level < capacity * 0.3:
            return Action.C
        else:
            return Action.D

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game history."""
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        stock = float(capacity)
        for round_idx in range(history.round_number):
            total_consumption = 0
            if history.my_actions[round_idx]:
                total_consumption += stock / (2 * n_players)
            else:
                total_consumption += stock / n_players
            for opponent_idx in range(len(history.opponent_actions[round_idx])):
                if history.opponent_actions[round_idx, opponent_idx]:
                    total_consumption += stock / (2 * n_players)
                else:
                    total_consumption += stock / n_players
            stock_after_consumption = max(0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            else:
                growth = 0
            stock = min(stock_after_consumption + growth, capacity)
        return stock

class Strategy_COOPERATIVE_36(BaseStrategy):
    """
    Adaptive Trust with Graduated Response strategy for Common Pool Resource Game.
    
    This strategy prioritizes long-term sustainability while being responsive to others' behavior.
    It starts with trust, maintains cooperation when possible, but includes mechanisms to 
    protect against exploitation and encourage return to cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        prev_round_idx = history.round_number - 1
        prev_opponents_cooperated = sum(history.opponent_actions[prev_round_idx])
        prev_i_cooperated = 1 if history.my_actions[prev_round_idx] else 0
        total_cooperated = prev_opponents_cooperated + prev_i_cooperated
        cooperation_rate = total_cooperated / self.n_players
        current_stock = self._estimate_current_stock(history)
        critical_threshold = self.capacity / 4
        if current_round == self.n_rounds:
            if cooperation_rate >= 0.75:
                return Action.C
            elif current_stock >= self.capacity * 0.75:
                return Action.C
            else:
                return Action.D
        if current_stock <= critical_threshold:
            if cooperation_rate >= 0.5:
                return Action.C
            else:
                return Action.D
        if cooperation_rate >= 0.75:
            return Action.C
        elif cooperation_rate >= 0.5:
            return Action.C if random.random() < 0.8 else Action.D
        elif cooperation_rate >= 0.25:
            return Action.C if random.random() < 0.4 else Action.D
        else:
            return Action.D

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game history."""
        stock = self.capacity
        for round_idx in range(history.round_number):
            total_consumption = 0
            if history.my_actions[round_idx]:
                total_consumption += stock / (2 * self.n_players)
            else:
                total_consumption += stock / self.n_players
            for opponent_idx in range(self.n_players - 1):
                if history.opponent_actions[round_idx, opponent_idx]:
                    total_consumption += stock / (2 * self.n_players)
                else:
                    total_consumption += stock / self.n_players
            stock_after_consumption = max(0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            else:
                growth = 0
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

class Strategy_COOPERATIVE_37(BaseStrategy):
    """
    Adaptive Cooperative Strategy with Forgiveness (ACSF)
    
    Prioritizes long-term sustainability while being responsive to group behavior.
    Starts cooperatively but adapts based on observed cooperation levels, with
    built-in forgiveness mechanisms to encourage return to cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_num = history.round_number + 1
        last_round_idx = history.round_number - 1
        my_last_payoff = history.my_payoffs[last_round_idx]
        my_last_action = history.my_actions[last_round_idx]
        if my_last_action:
            stock_level = my_last_payoff * 2 * self.n_players
        else:
            stock_level = my_last_payoff * self.n_players
        if stock_level == 0 or stock_level < 0.1 * self.capacity:
            return Action.C
        last_round_actions = history.opponent_actions[last_round_idx]
        opponent_cooperators = sum(last_round_actions)
        total_cooperators = opponent_cooperators + (1 if history.my_actions[last_round_idx] else 0)
        cooperation_rate = total_cooperators / self.n_players
        if round_num == self.n_rounds:
            return Action.C if cooperation_rate >= 0.5 else Action.D
        stock_ratio = stock_level / self.capacity
        base_threshold = 0.5
        threshold = max(base_threshold, stock_ratio * 0.8)
        if stock_level < 0.25 * self.capacity:
            threshold = min(0.8, threshold * 1.5)
        if round_num > 2 and last_round_idx > 0:
            my_prev_action = history.my_actions[last_round_idx - 1]
            prev_round_actions = history.opponent_actions[last_round_idx - 1]
            prev_opponent_cooperators = sum(prev_round_actions)
            prev_total_cooperators = prev_opponent_cooperators + (1 if my_prev_action else 0)
            prev_cooperation_rate = prev_total_cooperators / self.n_players
            if not my_prev_action and cooperation_rate >= prev_cooperation_rate + 0.2:
                return Action.C
        if round_num > 2 and last_round_idx > 0:
            recent_defection_rate = 1 - cooperation_rate
            prev_round_actions = history.opponent_actions[last_round_idx - 1]
            prev_opponent_cooperators = sum(prev_round_actions)
            prev_total_cooperators = prev_opponent_cooperators + (1 if history.my_actions[last_round_idx - 1] else 0)
            prev_cooperation_rate = prev_total_cooperators / self.n_players
            prev_defection_rate = 1 - prev_cooperation_rate
            if recent_defection_rate >= 0.75 and prev_defection_rate >= 0.75:
                return Action.C if cooperation_rate >= 0.4 else Action.D
        if round_num > self.n_rounds - 3 and stock_level > 0.5 * self.capacity and (cooperation_rate < 0.3):
            return Action.C
        return Action.C if cooperation_rate >= threshold else Action.D

class Strategy_COOPERATIVE_38(BaseStrategy):
    """
    Sustainable Guardian: An adaptive cooperative strategy that prioritizes long-term 
    sustainability while being responsive to group cooperation levels. Starts optimistically 
    but adapts based on observed behavior to prevent exploitation while maintaining 
    cooperative incentives.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        round_number = history.round_number + 1
        if round_number == total_rounds:
            return Action.C
        recent_round_idx = history.round_number - 1
        my_recent_payoff = history.my_payoffs[recent_round_idx]
        my_last_action = history.my_actions[recent_round_idx]
        if my_last_action:
            last_round_stock = my_recent_payoff * 2 * n
        else:
            last_round_stock = my_recent_payoff * n
        total_consumption = 0
        opponent_actions_last = history.opponent_actions[recent_round_idx]
        if my_last_action:
            total_consumption += last_round_stock / (2 * n)
        else:
            total_consumption += last_round_stock / n
        for opponent_cooperated in opponent_actions_last:
            if opponent_cooperated:
                total_consumption += last_round_stock / (2 * n)
            else:
                total_consumption += last_round_stock / n
        stock_after_consumption = max(0, last_round_stock - total_consumption)
        growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.game_description.capacity)
        current_stock = min(stock_after_consumption + growth, self.game_description.capacity)
        if current_stock <= n:
            return Action.C
        previous_round_idx = history.round_number - 1
        opponent_cooperators = sum(history.opponent_actions[previous_round_idx])
        my_cooperation = 1 if history.my_actions[previous_round_idx] else 0
        total_cooperators = opponent_cooperators + my_cooperation
        cooperation_rate = total_cooperators / n
        if cooperation_rate >= 0.8:
            return Action.C
        if cooperation_rate >= 0.6:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_39(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Trust with Accountability"
    
    This strategy aims to establish and maintain cooperation while protecting against exploitation.
    It balances trust-building with punishment to create incentives for mutual cooperation.
    
    Key features:
    - Always cooperate in first round and during resource crises
    - Cooperate when 60% or more players cooperated last round
    - Implement graduated punishment for low cooperation
    - Always cooperate in final two rounds
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_counter = 0
        self.offense_count = 0
        self.current_punishment_round = 0
        self.in_punishment = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punishment_counter = 0
            self.offense_count = 0
            self.current_punishment_round = 0
            self.in_punishment = False
            return Action.C
        current_round = history.round_number
        if current_round >= self.game_description.n_rounds - 2:
            return Action.C
        if len(history.my_payoffs) > 0:
            last_payoff = history.my_payoffs[-1]
            my_last_action = history.my_actions[-1]
            if my_last_action:
                estimated_stock = last_payoff * 2 * self.game_description.n_players
            else:
                estimated_stock = last_payoff * self.game_description.n_players
            critical_threshold = self.game_description.capacity * 0.3
            if estimated_stock <= critical_threshold:
                return Action.C
        last_round_idx = current_round - 1
        last_round_opponent_actions = history.opponent_actions[last_round_idx]
        my_last_action = history.my_actions[last_round_idx]
        opponent_cooperators = sum(last_round_opponent_actions)
        my_cooperation = 1 if my_last_action else 0
        total_cooperators = opponent_cooperators + my_cooperation
        cooperation_ratio = total_cooperators / self.game_description.n_players
        trust_threshold = 0.6
        if cooperation_ratio >= trust_threshold:
            self.punishment_counter = 0
            self.offense_count = 0
            self.current_punishment_round = 0
            self.in_punishment = False
            return Action.C
        else:
            return self._execute_punishment()

    def _execute_punishment(self):
        """Execute graduated punishment protocol"""
        if not self.in_punishment:
            self.offense_count += 1
            self.in_punishment = True
            self.current_punishment_round = 1
            self.punishment_duration = min(self.offense_count, 3)
            return Action.D
        else:
            self.current_punishment_round += 1
            if self.current_punishment_round <= self.punishment_duration:
                return Action.D
            else:
                self.in_punishment = False
                self.current_punishment_round = 0
                return Action.C

class Strategy_COOPERATIVE_40(BaseStrategy):
    """
    Adaptive Trust with Sustainability Guard strategy for Common Pool Resource Game.
    
    This strategy balances cooperation with protection against exploitation and resource depletion.
    It maintains a trust score based on group cooperation levels, prioritizes sustainability
    when resources are low, and uses probabilistic decision-making with a cooperative bias.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_score = 1.0
        self.sustainability_threshold = game_description.capacity * 0.3
        self.trust_decay = 0.1
        self.trust_recovery = 0.15
        self.previous_stock = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_stock = self._calculate_current_stock(history)
        if current_stock <= self.sustainability_threshold:
            self.previous_stock = current_stock
            return Action.C
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            cooperators_last_round += 1
        cooperation_rate = cooperators_last_round / self.game_description.n_players
        if cooperation_rate >= 0.5:
            self.cooperation_score = min(1.0, self.cooperation_score + self.trust_recovery)
        else:
            self.cooperation_score = max(0.0, self.cooperation_score - self.trust_decay)
        base_probability = self.cooperation_score
        if current_stock > self.game_description.capacity * 0.7:
            base_probability = min(1.0, base_probability + 0.2)
        if self.previous_stock > 0:
            stock_decline_rate = (self.previous_stock - current_stock) / self.previous_stock
            if stock_decline_rate > 0.4:
                base_probability = max(0.3, base_probability - 0.3)
        self.previous_stock = current_stock
        if base_probability > 0.6:
            return Action.C
        else:
            return Action.D

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game history."""
        stock = self.game_description.capacity
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        for round_idx in range(history.round_number):
            total_consumption = 0.0
            if history.my_actions[round_idx]:
                total_consumption += stock / (2 * n)
            else:
                total_consumption += stock / n
            for opponent_idx in range(n - 1):
                if history.opponent_actions[round_idx, opponent_idx]:
                    total_consumption += stock / (2 * n)
                else:
                    total_consumption += stock / n
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            stock = min(stock_after_consumption + growth, capacity)
        return stock

class Strategy_COOPERATIVE_41(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Majority"
    
    This strategy prioritizes long-term cooperation while being robust against exploitation.
    It follows the majority behavior of opponents while protecting the resource when critically low.
    Key features: generous initialization, majority-based decisions, stock-level awareness,
    early game forgiveness, and trend analysis for tie-breaking.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_number = history.round_number + 1
        n = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        stock_level = self._calculate_current_stock(history)
        if round_number == total_rounds:
            return Action.C
        if stock_level < 0.2 * capacity:
            return Action.C
        prev_round_idx = history.round_number - 1
        prev_opponent_actions = history.opponent_actions[prev_round_idx]
        cooperators = sum(prev_opponent_actions)
        defectors = len(prev_opponent_actions) - cooperators
        if round_number <= 3:
            if defectors >= 0.75 * (n - 1):
                return Action.D
            else:
                return Action.C
        if cooperators > defectors:
            return Action.C
        elif defectors > cooperators:
            return Action.D
        else:
            return self._handle_tie(history, stock_level, capacity, round_number)

    def _handle_tie(self, history, stock_level, capacity, round_number):
        """Handle tie situations with stock-based and trend-based rules."""
        if stock_level > 0.75 * capacity:
            return Action.C
        elif stock_level < 0.25 * capacity:
            return Action.C
        elif round_number >= 4:
            coop_trend = self._analyze_cooperation_trend(history, 3)
            if coop_trend >= 0:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C

    def _analyze_cooperation_trend(self, history, lookback_rounds):
        """Analyze cooperation trend over last N rounds."""
        if history.round_number < lookback_rounds:
            return 0
        cooperation_rates = []
        start_round = max(0, history.round_number - lookback_rounds)
        for round_idx in range(start_round, history.round_number):
            round_actions = history.opponent_actions[round_idx]
            coop_rate = sum(round_actions) / len(round_actions)
            cooperation_rates.append(coop_rate)
        if len(cooperation_rates) < 2:
            return 0
        trend = cooperation_rates[-1] - cooperation_rates[0]
        return trend

    def _calculate_current_stock(self, history):
        """Calculate current stock level based on game history."""
        capacity = self.game_description.capacity
        n = self.game_description.n_players
        current_stock = float(capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0.0
            if my_action:
                total_consumption += current_stock / (2 * n)
            else:
                total_consumption += current_stock / n
            for opp_action in opponent_actions:
                if opp_action:
                    total_consumption += current_stock / (2 * n)
                else:
                    total_consumption += current_stock / n
            current_stock = max(0.0, current_stock - total_consumption)
            if current_stock > 0:
                growth = 2 * current_stock * (1 - current_stock / capacity)
                current_stock = min(current_stock + growth, capacity)
        return current_stock

class Strategy_COOPERATIVE_42(BaseStrategy):
    """
    Adaptive Forgiveness Strategy (AFS): Starts with trust, responds to betrayal proportionally,
    but always maintains a path back to cooperation. Prioritizes resource sustainability through
    emergency cooperation, adaptive thresholds, and majority-based decision making.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if self._is_critical_stock_level(history):
            return Action.C
        if current_round == self.game_description.n_rounds:
            return self._final_round_strategy(history)
        recent_cooperation_rate = self._get_recent_cooperation_rate(history)
        progress = current_round / self.game_description.n_rounds
        cooperation_threshold = 0.3 + 0.2 * progress
        if recent_cooperation_rate >= cooperation_threshold:
            return Action.C
        else:
            return self._tit_for_majority_tat(history)

    def _is_critical_stock_level(self, history: PlayerHistory) -> bool:
        """
        Estimate if stock is below 20% of capacity based on payoff patterns.
        Since payoffs are proportional to stock level, we can estimate stock health.
        """
        if history.round_number == 0:
            return False
        recent_rounds = min(3, history.round_number)
        recent_payoffs = history.my_payoffs[-recent_rounds:]
        avg_recent_payoff = np.mean(recent_payoffs)
        expected_full_stock_coop_payoff = self.game_description.capacity / (2 * self.game_description.n_players)
        return avg_recent_payoff < 0.15 * expected_full_stock_coop_payoff

    def _final_round_strategy(self, history: PlayerHistory) -> Action:
        """
        In the final round, cooperate only if majority cooperated in previous round.
        """
        if history.round_number == 0:
            return Action.C
        last_round_actions = history.opponent_actions[history.round_number - 1]
        cooperators = np.sum(last_round_actions)
        majority_cooperated = cooperators >= (self.game_description.n_players - 1) / 2
        return Action.C if majority_cooperated else Action.D

    def _get_recent_cooperation_rate(self, history: PlayerHistory) -> float:
        """
        Calculate cooperation rate over the last 3 rounds (or all available rounds if fewer).
        """
        if history.round_number == 0:
            return 1.0
        rounds_to_check = min(3, history.round_number)
        start_round = history.round_number - rounds_to_check
        total_actions = 0
        cooperative_actions = 0
        for round_idx in range(start_round, history.round_number):
            round_actions = history.opponent_actions[round_idx]
            total_actions += len(round_actions)
            cooperative_actions += np.sum(round_actions)
            total_actions += 1
            if history.my_actions[round_idx]:
                cooperative_actions += 1
        return cooperative_actions / total_actions if total_actions > 0 else 1.0

    def _tit_for_majority_tat(self, history: PlayerHistory) -> Action:
        """
        Defect only if majority defected in the last round, otherwise cooperate.
        """
        if history.round_number == 0:
            return Action.C
        last_round_actions = history.opponent_actions[history.round_number - 1]
        defectors = np.sum(last_round_actions == False)
        majority_defected = defectors > (self.game_description.n_players - 1) / 2
        return Action.D if majority_defected else Action.C

class Strategy_COOPERATIVE_43(BaseStrategy):
    """
    Adaptive Cooperative Strategy with Trust-Based Reciprocation.
    
    Prioritizes long-term sustainability while maintaining cooperative intentions.
    Uses adaptive reciprocation based on observed collective behavior and includes
    safeguards against exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.n_rounds:
            return self._final_round_decision(history)
        current_stock_ratio = self._estimate_stock_ratio(history)
        if current_stock_ratio < 0.3:
            return Action.C
        recent_coop_rate = self._calculate_recent_cooperation_rate(history, 3)
        exploitation_count = self._count_recent_exploitations(history, 5)
        if exploitation_count >= 3:
            if recent_coop_rate > 0.6:
                return Action.C
            else:
                return Action.D
        if recent_coop_rate >= 0.7:
            return Action.C
        if recent_coop_rate >= 0.4:
            last_round_cooperators = self._count_last_round_cooperators(history)
            if last_round_cooperators >= self.n_players / 2:
                return Action.C
            else:
                return Action.D
        if current_stock_ratio > 0.7:
            last_round_cooperators = self._count_last_round_cooperators(history)
            if last_round_cooperators >= 2:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _final_round_decision(self, history: PlayerHistory) -> Action:
        """Handle final round decision logic."""
        current_stock_ratio = self._estimate_stock_ratio(history)
        if current_stock_ratio > 0.5:
            return Action.C
        recent_coop_rate = self._calculate_recent_cooperation_rate(history, 3)
        if current_stock_ratio <= 0.5 and recent_coop_rate < 0.5:
            return Action.D
        return Action.C

    def _estimate_stock_ratio(self, history: PlayerHistory) -> float:
        """Estimate current stock ratio based on payoffs."""
        if history.round_number == 0:
            return 1.0
        last_payoff = history.my_payoffs[-1]
        last_action = history.my_actions[-1]
        if last_action:
            estimated_stock = last_payoff * 2 * self.n_players
        else:
            estimated_stock = last_payoff * self.n_players
        estimated_ratio = max(0.0, min(1.0, estimated_stock / self.capacity))
        return estimated_ratio

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory, rounds: int) -> float:
        """Calculate cooperation rate over the last 'rounds' rounds."""
        if history.round_number == 0:
            return 1.0
        start_round = max(0, history.round_number - rounds)
        total_players = 0
        total_cooperators = 0
        for round_idx in range(start_round, history.round_number):
            if history.my_actions[round_idx]:
                total_cooperators += 1
            total_players += 1
            for player_idx in range(self.n_players - 1):
                if history.opponent_actions[round_idx, player_idx]:
                    total_cooperators += 1
                total_players += 1
        if total_players == 0:
            return 1.0
        return total_cooperators / total_players

    def _count_recent_exploitations(self, history: PlayerHistory, rounds: int) -> int:
        """Count times I cooperated but majority defected in recent rounds."""
        if history.round_number == 0:
            return 0
        start_round = max(0, history.round_number - rounds)
        exploitation_count = 0
        for round_idx in range(start_round, history.round_number):
            if history.my_actions[round_idx]:
                others_cooperated = np.sum(history.opponent_actions[round_idx])
                total_others = self.n_players - 1
                if others_cooperated < total_others / 2:
                    exploitation_count += 1
        return exploitation_count

    def _count_last_round_cooperators(self, history: PlayerHistory) -> int:
        """Count cooperators in the most recent round."""
        if history.round_number == 0:
            return 0
        last_round_idx = history.round_number - 1
        cooperators = 0
        if history.my_actions[last_round_idx]:
            cooperators += 1
        cooperators += np.sum(history.opponent_actions[last_round_idx])
        return int(cooperators)

class Strategy_COOPERATIVE_44(BaseStrategy):
    """
    Adaptive Reciprocity with Sustainability Focus: A cooperative strategy that prioritizes 
    long-term resource sustainability while being cooperative by default. Includes mechanisms 
    to protect against exploitation and encourage cooperation through conditional reciprocity.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_number = history.round_number
        current_stock = self._calculate_current_stock(history)
        if current_stock < self.capacity * 0.3:
            return Action.C
        if round_number >= self.n_rounds - 2:
            return self._end_game_decision(history, current_stock)
        last_round_idx = round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        cooperation_ratio = cooperators_last_round / self.n_players
        my_exploitation_ratio = self._calculate_exploitation_ratio(history)
        if cooperation_ratio >= 0.6:
            return Action.C
        elif cooperation_ratio >= 0.4:
            if my_exploitation_ratio <= 0.3:
                return Action.C
            else:
                return Action.D
        elif my_exploitation_ratio <= 0.2:
            return Action.C
        else:
            return Action.D

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game history."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            if my_action:
                my_consumption = stock / (2 * self.n_players)
            else:
                my_consumption = stock / self.n_players
            opponent_consumption = 0
            for opponent_action in opponent_actions:
                if opponent_action:
                    opponent_consumption += stock / (2 * self.n_players)
                else:
                    opponent_consumption += stock / self.n_players
            total_consumption = my_consumption + opponent_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _calculate_exploitation_ratio(self, history: PlayerHistory) -> float:
        """Calculate how often I was exploited (I cooperated while others defected against me)."""
        if history.round_number == 0:
            return 0.0
        exploitation_count = 0
        total_rounds = history.round_number
        for round_idx in range(total_rounds):
            if history.my_actions[round_idx]:
                opponent_defectors = sum((1 for action in history.opponent_actions[round_idx] if not action))
                if opponent_defectors > 0:
                    exploitation_count += 1
        return exploitation_count / total_rounds if total_rounds > 0 else 0.0

    def _end_game_decision(self, history: PlayerHistory, current_stock: float) -> Action:
        """Make decision for last few rounds."""
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        cooperation_ratio = cooperators_last_round / self.n_players
        if current_stock >= self.capacity * 0.5:
            return Action.C
        elif cooperation_ratio >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_45(BaseStrategy):
    """
    Adaptive Cooperative Strategy with Sustainability Focus ("Sustainable Reciprocator").
    
    This strategy prioritizes long-term sustainability while encouraging cooperative behavior 
    through reciprocity and forgiveness. It cooperates when stock levels are sustainable 
    and the majority cooperated previously, but defects during resource crises or when 
    facing widespread defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.sustainability_threshold = game_description.capacity * 0.4

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        current_stock = self._estimate_current_stock(history)
        if current_stock < self.sustainability_threshold:
            return Action.D
        prev_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
        if history.my_actions[history.round_number - 1]:
            prev_round_cooperators += 1
        majority_threshold = math.ceil(self.game_description.n_players / 2)
        if prev_round_cooperators >= majority_threshold:
            return Action.C
        else:
            return Action.D

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """
        Estimate current stock level based on game history.
        This reconstructs the stock evolution through all previous rounds.
        """
        stock = float(self.game_description.capacity)
        n = self.game_description.n_players
        capacity = float(self.game_description.capacity)
        for round_idx in range(history.round_number):
            cooperators = sum(history.opponent_actions[round_idx])
            if history.my_actions[round_idx]:
                cooperators += 1
            defectors = n - cooperators
            total_consumption = cooperators * (stock / (2 * n)) + defectors * (stock / n)
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            stock = min(stock_after_consumption + growth, capacity)
        return stock

class Strategy_COOPERATIVE_46(BaseStrategy):
    """
    Adaptive Cooperative Strategy with Trust-Based Defection Detection.
    
    Prioritizes long-term sustainability through cooperation while protecting 
    against exploitation through adaptive defection detection and graduated responses.
    Uses trust scoring based on cooperation rates and stock health to make decisions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.trust_threshold = 0.4
        self.emergency_threshold = 0.2 * game_description.capacity
        self.consecutive_defections = 0
        self.previous_cooperation_rate = 1.0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        current_round = history.round_number
        current_stock = self._estimate_current_stock(history)
        if current_stock < self.emergency_threshold:
            return Action.D
        last_round_idx = current_round - 1
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        my_last_action = history.my_actions[last_round_idx]
        total_cooperators = opponent_cooperators + (1 if my_last_action else 0)
        cooperation_rate = total_cooperators / n
        stock_health = current_stock / self.game_description.capacity
        trust_score = cooperation_rate * stock_health
        if cooperation_rate < self.previous_cooperation_rate:
            self.consecutive_defections += 1
        else:
            self.consecutive_defections = 0
        self.previous_cooperation_rate = cooperation_rate
        rounds_remaining = total_rounds - current_round
        adjusted_threshold = self.trust_threshold * (1 + rounds_remaining / total_rounds * 0.2)
        if trust_score >= 0.6:
            return Action.C
        elif trust_score >= adjusted_threshold:
            if self.consecutive_defections >= 2:
                return Action.D
            else:
                return Action.C
        elif current_round == total_rounds and stock_health > 0.3:
            return Action.C
        else:
            return Action.D

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """
        Estimate current stock level based on payoff history.
        Uses the fact that payoffs reflect stock level and consumption patterns.
        """
        if history.round_number == 0:
            return self.game_description.capacity
        last_payoff = history.my_payoffs[-1]
        my_last_action = history.my_actions[-1]
        n = self.game_description.n_players
        if my_last_action:
            estimated_last_stock = last_payoff * 2 * n
        else:
            estimated_last_stock = last_payoff * n
        decline_rate = 0.1
        estimated_current = estimated_last_stock * (1 - decline_rate)
        return max(0, min(estimated_current, self.game_description.capacity))

class Strategy_COOPERATIVE_47(BaseStrategy):
    """
    Forgiving Sustainability Guardian: A cooperative strategy that prioritizes long-term 
    sustainability while being forgiving and adaptive to others' behavior. Protects against 
    exploitation while encouraging cooperation through trust-building and conditional forgiveness.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_number = history.round_number + 1
        if round_number == self.game_description.n_rounds:
            return self._last_round_strategy(history)
        stock_health = self._estimate_stock_health(history)
        cooperation_score = self._calculate_cooperation_score(history)
        if stock_health < 0.3:
            if cooperation_score > 0.6:
                return Action.C
            else:
                return Action.D
        if cooperation_score >= 0.7:
            return Action.C
        elif cooperation_score >= 0.4:
            return self._forgive_and_cooperate(history)
        else:
            return self._conditional_defect(history, stock_health)

    def _last_round_strategy(self, history: PlayerHistory) -> Action:
        """Handle final round decision"""
        stock_health = self._estimate_stock_health(history)
        if stock_health >= 0.7:
            return Action.C
        else:
            if history.round_number > 0:
                last_round_cooperators = np.sum(history.opponent_actions[history.round_number - 1])
                if last_round_cooperators >= len(history.opponent_actions[0]) / 2:
                    return Action.C
            return Action.D

    def _estimate_stock_health(self, history: PlayerHistory) -> float:
        """Estimate current stock health as proportion of capacity"""
        stock = float(self.game_description.capacity)
        n = self.game_description.n_players
        capacity = float(self.game_description.capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0.0
            if my_action:
                total_consumption += stock / (2 * n)
            else:
                total_consumption += stock / n
            for opp_action in opponent_actions:
                if opp_action:
                    total_consumption += stock / (2 * n)
                else:
                    total_consumption += stock / n
            stock_remaining = max(0.0, stock - total_consumption)
            growth = 2 * stock_remaining * (1 - stock_remaining / capacity)
            stock = min(stock_remaining + growth, capacity)
        return stock / capacity

    def _calculate_cooperation_score(self, history: PlayerHistory) -> float:
        """Calculate weighted cooperation score of opponents"""
        if history.round_number == 0:
            return 1.0
        recent_weight = 0.6
        overall_weight = 0.4
        recent_rounds = min(3, history.round_number)
        recent_start = max(0, history.round_number - recent_rounds)
        recent_actions = history.opponent_actions[recent_start:history.round_number]
        recent_coop_rate = np.mean(recent_actions) if recent_actions.size > 0 else 1.0
        all_actions = history.opponent_actions[:history.round_number]
        overall_coop_rate = np.mean(all_actions) if all_actions.size > 0 else 1.0
        return recent_weight * recent_coop_rate + overall_weight * overall_coop_rate

    def _forgive_and_cooperate(self, history: PlayerHistory) -> Action:
        """Forgive occasional defection if there's been recent cooperation"""
        if history.round_number < 2:
            return Action.C
        last_2_rounds = history.opponent_actions[max(0, history.round_number - 2):history.round_number]
        if np.any(last_2_rounds):
            return Action.C
        else:
            return Action.D

    def _conditional_defect(self, history: PlayerHistory, stock_health: float) -> Action:
        """Only defect in low-trust environments if stock can sustain it"""
        if stock_health > 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_48(BaseStrategy):
    """
    Sustainable Guardian: An adaptive cooperative strategy that prioritizes long-term 
    sustainability while being responsive to opponent behavior. Starts cooperatively 
    but includes mechanisms to protect against exploitation and resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.n_rounds:
            return Action.D
        stock = self._estimate_current_stock(history)
        if stock < self.capacity * 0.3:
            return Action.C
        last_round_actions = history.opponent_actions[history.round_number - 1]
        cooperators_last_round = sum(last_round_actions)
        cooperation_rate = cooperators_last_round / self.n_players
        if cooperation_rate >= 0.7:
            return Action.C
        elif cooperation_rate >= 0.4:
            stock_health = stock / self.capacity
            if stock_health > 0.6:
                return Action.C
            else:
                return self._mirror_majority_action(last_round_actions)
        elif stock < self.capacity * 0.5:
            return Action.C
        else:
            return Action.D

    def _mirror_majority_action(self, last_round_actions):
        """Mirror the majority action from last round."""
        cooperators = sum(last_round_actions)
        if cooperators >= self.n_players / 2:
            return Action.C
        else:
            return Action.D

    def _estimate_current_stock(self, history):
        """Estimate current stock based on game history."""
        stock = self.capacity
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0
            if my_action:
                total_consumption += stock / (2 * self.n_players)
            else:
                total_consumption += stock / self.n_players
            for opponent_action in opponent_actions:
                if opponent_action:
                    total_consumption += stock / (2 * self.n_players)
                else:
                    total_consumption += stock / self.n_players
            stock_after_consumption = stock - total_consumption
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
            stock = max(stock, 0)
        return stock

class Strategy_COOPERATIVE_49(BaseStrategy):
    """
    Adaptive Stewardship with Graduated Response strategy for Common Pool Resource Game.
    
    Starts cooperative to establish sustainable equilibrium, uses graduated responses 
    to deter free-riding while maintaining forgiveness to restore cooperation.
    Features resource awareness, trust tracking, and exploitation detection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5
        self.trust_level = 1.0
        self.punishment_counter = 0
        self.sustainability_threshold = game_description.capacity * 0.3

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_stock = self._calculate_current_stock(history)
        if current_stock < self.sustainability_threshold:
            return Action.C
        if self.punishment_counter > 0:
            self.punishment_counter -= 1
            return Action.D
        last_round = history.round_number - 1
        n_opponents = self.game_description.n_players - 1
        cooperators_last_round = int(np.sum(history.opponent_actions[last_round]))
        cooperation_rate = cooperators_last_round / n_opponents
        i_cooperated_last_round = bool(history.my_actions[last_round])
        my_last_payoff = history.my_payoffs[last_round]
        opponent_payoffs_last = history.opponent_payoffs[last_round]
        opponent_actions_last = history.opponent_actions[last_round]
        cooperator_payoffs = opponent_payoffs_last[opponent_actions_last]
        defector_payoffs = opponent_payoffs_last[~opponent_actions_last]
        avg_cooperator_payoff = np.mean(cooperator_payoffs) if len(cooperator_payoffs) > 0 else 0
        avg_defector_payoff = np.mean(defector_payoffs) if len(defector_payoffs) > 0 else 0
        if cooperation_rate >= self.cooperation_threshold:
            self.trust_level = min(1.0, self.trust_level + 0.1)
        else:
            self.trust_level = max(0.0, self.trust_level - 0.2)
        exploitation_detected = i_cooperated_last_round and len(defector_payoffs) > 0 and (avg_defector_payoff > avg_cooperator_payoff * 1.5) and (cooperation_rate < 0.5)
        if exploitation_detected:
            defector_count = n_opponents - cooperators_last_round
            self.punishment_counter = min(2, max(1, defector_count // 2))
            return Action.D
        elif self.trust_level >= 0.6 and cooperation_rate >= self.cooperation_threshold:
            return Action.C
        elif self.trust_level >= 0.3 and current_stock > self.game_description.capacity * 0.6:
            if cooperation_rate >= 0.3:
                return Action.C
            else:
                return Action.D
        elif cooperation_rate > 0.7:
            return Action.C
        else:
            if history.round_number == self.game_description.n_rounds - 1:
                if current_stock < self.sustainability_threshold or self.trust_level > 0.8:
                    return Action.C
                else:
                    return Action.D
            return Action.D

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game dynamics."""
        stock = float(self.game_description.capacity)
        n = self.game_description.n_players
        for round_idx in range(history.round_number):
            my_consumption = stock / (2 * n) if history.my_actions[round_idx] else stock / n
            opponent_consumption = 0
            for opp_idx in range(n - 1):
                if history.opponent_actions[round_idx, opp_idx]:
                    opponent_consumption += stock / (2 * n)
                else:
                    opponent_consumption += stock / n
            total_consumption = my_consumption + opponent_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.game_description.capacity)
            stock = min(stock_after_consumption + growth, self.game_description.capacity)
        return stock

class Strategy_COOPERATIVE_50(BaseStrategy):
    """
    Adaptive Cooperative Strategy with Trust-Building
    
    Prioritizes long-term sustainability while being responsive to opponent behavior.
    Starts cooperatively but adapts based on observed patterns, always seeking to 
    rebuild cooperation when possible.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        current_stock = self._estimate_current_stock(history)
        if current_stock < self.capacity * 0.3:
            return Action.C
        last_round_idx = history.round_number - 1
        cooperators_last = sum(history.opponent_actions[last_round_idx])
        if current_round == self.n_rounds:
            if current_stock < self.capacity * 0.2 or cooperators_last >= self.n_players / 2:
                return Action.C
            else:
                return Action.D
        if cooperators_last > self.n_players / 2:
            return Action.C
        recent_defection_rate = self._calculate_recent_defection_rate(history)
        if recent_defection_rate > 0.6:
            return Action.D
        elif recent_defection_rate > 0.4:
            return Action.C if random.random() < 0.7 else Action.D
        else:
            return Action.C

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game history."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            cooperators = sum(history.opponent_actions[round_idx])
            if history.my_actions[round_idx]:
                cooperators += 1
            defectors = self.n_players - cooperators
            cooperator_consumption = stock / (2 * self.n_players)
            defector_consumption = stock / self.n_players
            total_consumption = cooperators * cooperator_consumption + defectors * defector_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _calculate_recent_defection_rate(self, history: PlayerHistory) -> float:
        """Calculate defection rate over the last 3 rounds (or available rounds)."""
        rounds_to_check = min(3, history.round_number)
        start_round = history.round_number - rounds_to_check
        total_actions = 0
        total_defections = 0
        for round_idx in range(start_round, history.round_number):
            opponent_defections = sum(1 - history.opponent_actions[round_idx])
            my_defection = 1 - int(history.my_actions[round_idx])
            total_defections += opponent_defections + my_defection
            total_actions += self.n_players
        if total_actions == 0:
            return 0.0
        return total_defections / total_actions

class Strategy_COOPERATIVE_51(BaseStrategy):
    """
    Graduated Cooperation Strategy (GCS) - A sustainable cooperation strategy that 
    balances resource conservation, cooperation, and self-protection through graduated
    responses to group behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        stock = self._estimate_current_stock(history)
        if stock < capacity * 0.15:
            return Action.C
        if current_round == total_rounds:
            return self._apply_endgame_rule(history)
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        cooperation_rate = cooperators_last_round / n
        my_recent_defection_rate = self._get_my_recent_defection_rate(history)
        if cooperation_rate >= 0.75:
            return Action.C
        elif cooperation_rate >= 0.5:
            if my_recent_defection_rate <= 0.33:
                return Action.C
            else:
                return Action.C
        elif cooperation_rate >= 0.25:
            return self._apply_tit_for_tat_majority(history)
        else:
            return Action.D

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock based on game history and dynamics."""
        capacity = self.game_description.capacity
        n = self.game_description.n_players
        stock = float(capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_cooperators = sum(opponent_actions) + (1 if my_action else 0)
            total_defectors = n - total_cooperators
            cooperator_consumption = stock / (2 * n)
            defector_consumption = stock / n
            total_consumption = total_cooperators * cooperator_consumption + total_defectors * defector_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            stock = min(stock_after_consumption + growth, capacity)
        return stock

    def _get_my_recent_defection_rate(self, history: PlayerHistory) -> float:
        """Calculate my defection rate over the last 3 rounds."""
        rounds_to_check = min(3, history.round_number)
        if rounds_to_check == 0:
            return 0.0
        start_idx = history.round_number - rounds_to_check
        recent_actions = history.my_actions[start_idx:]
        defections = sum((1 - action for action in recent_actions))
        return defections / rounds_to_check

    def _apply_endgame_rule(self, history: PlayerHistory) -> Action:
        """Apply endgame logic based on recent cooperation rates."""
        final_rounds_coop_rate = self._final_rounds_cooperation_rate(history)
        if final_rounds_coop_rate >= 0.6:
            return Action.C
        else:
            return Action.D

    def _final_rounds_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate average cooperation rate over last 3 rounds."""
        rounds_to_check = min(3, history.round_number)
        if rounds_to_check == 0:
            return 1.0
        n = self.game_description.n_players
        total_cooperation_rate = 0.0
        for i in range(rounds_to_check):
            round_idx = history.round_number - 1 - i
            cooperators = sum(history.opponent_actions[round_idx])
            cooperation_rate = cooperators / n
            total_cooperation_rate += cooperation_rate
        return total_cooperation_rate / rounds_to_check

    def _apply_tit_for_tat_majority(self, history: PlayerHistory) -> Action:
        """Follow the majority action from the last round."""
        if history.round_number == 0:
            return Action.C
        last_round_idx = history.round_number - 1
        cooperators = sum(history.opponent_actions[last_round_idx])
        defectors = self.game_description.n_players - cooperators
        if cooperators >= defectors:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_52(BaseStrategy):
    """
    Forgiving Guardian: An adaptive cooperative strategy that prioritizes long-term 
    sustainability while being forgiving to occasional defections. Uses graduated 
    responses and emergency conservation to maintain resource stability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = self._calculate_current_stock(history)
        if current_stock / capacity < 0.3:
            return Action.C
        if current_stock < n:
            return Action.C
        if current_round == r:
            return Action.D if current_stock / capacity > 0.5 else Action.C
        recent_defection_rate = self._calculate_recent_defection_rate(history, n)
        if recent_defection_rate > 0.6:
            return Action.D
        elif recent_defection_rate > 0.4:
            if len(history.my_actions) > 0 and history.my_actions[-1] == True:
                return Action.D
            else:
                return Action.C
        else:
            if self._is_stock_declining_dangerously(history, current_stock, capacity):
                return Action.C
            if self._all_players_cooperated_recently(history):
                return Action.C
            if self._prevent_oscillation(history):
                return Action.C
            return Action.C

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock based on game history."""
        stock = self.game_description.capacity
        n = self.game_description.n_players
        for round_idx in range(len(history.my_actions)):
            my_consumption = stock / (2 * n) if history.my_actions[round_idx] else stock / n
            opponent_consumption = 0
            for opponent_idx in range(len(history.opponent_actions[round_idx])):
                if history.opponent_actions[round_idx, opponent_idx]:
                    opponent_consumption += stock / (2 * n)
                else:
                    opponent_consumption += stock / n
            total_consumption = my_consumption + opponent_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.game_description.capacity)
            stock = min(stock_after_consumption + growth, self.game_description.capacity)
        return stock

    def _calculate_recent_defection_rate(self, history: PlayerHistory, n: int) -> float:
        """Calculate defection rate over last 3 rounds (or all available rounds if fewer)."""
        if len(history.my_actions) == 0:
            return 0.0
        rounds_to_check = min(3, len(history.my_actions))
        start_idx = len(history.my_actions) - rounds_to_check
        total_actions = 0
        total_defections = 0
        for round_idx in range(start_idx, len(history.my_actions)):
            total_actions += 1
            if not history.my_actions[round_idx]:
                total_defections += 1
            for opponent_idx in range(len(history.opponent_actions[round_idx])):
                total_actions += 1
                if not history.opponent_actions[round_idx, opponent_idx]:
                    total_defections += 1
        return total_defections / total_actions if total_actions > 0 else 0.0

    def _is_stock_declining_dangerously(self, history: PlayerHistory, current_stock: float, capacity: float) -> bool:
        """Check if stock is declining over last 3 rounds and is below 70% capacity."""
        if len(history.my_actions) < 3 or current_stock >= 0.7 * capacity:
            return False
        expected_cooperative_stock = capacity * 0.8
        return current_stock < expected_cooperative_stock

    def _all_players_cooperated_recently(self, history: PlayerHistory) -> bool:
        """Check if all players cooperated in the last 2 rounds."""
        if len(history.my_actions) < 2:
            return False
        for round_offset in [1, 2]:
            round_idx = len(history.my_actions) - round_offset
            if round_idx < 0:
                continue
            if not history.my_actions[round_idx]:
                return False
            for opponent_idx in range(len(history.opponent_actions[round_idx])):
                if not history.opponent_actions[round_idx, opponent_idx]:
                    return False
        return True

    def _prevent_oscillation(self, history: PlayerHistory) -> bool:
        """Prevent D-C-D oscillation pattern by returning to cooperation."""
        if len(history.my_actions) < 3:
            return False
        last_3 = history.my_actions[-3:]
        return not last_3[0] and last_3[1] and (not last_3[2])

class Strategy_COOPERATIVE_53(BaseStrategy):
    """
    Adaptive Cooperative Strategy with Forgiveness
    
    Prioritizes long-term sustainability while maintaining cooperative intentions,
    with built-in mechanisms to recover from temporary conflicts and adapt to 
    different opponent types. Uses generous tit-for-tat with stock monitoring.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.consecutive_punishment_rounds = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_stock = self._estimate_current_stock(history)
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        remaining_rounds = self.game_description.n_rounds - history.round_number
        if current_stock < capacity * 0.15:
            return Action.C
        if current_stock < capacity * 0.3:
            return Action.C
        if remaining_rounds <= 2:
            return Action.C
        last_round_defectors = sum(history.opponent_actions[history.round_number - 1] == False)
        defector_ratio = last_round_defectors / n_players
        if defector_ratio >= 0.6:
            if self.consecutive_punishment_rounds < 2:
                self.consecutive_punishment_rounds += 1
                return Action.D
            else:
                self.consecutive_punishment_rounds = 0
                return Action.C
        else:
            self.consecutive_punishment_rounds = 0
            return Action.C

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """
        Estimate current stock level based on game history and dynamics.
        """
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        stock = float(capacity)
        for round_idx in range(history.round_number):
            total_consumption = 0.0
            if history.my_actions[round_idx]:
                total_consumption += stock / (2 * n_players)
            else:
                total_consumption += stock / n_players
            for opponent_idx in range(n_players - 1):
                if history.opponent_actions[round_idx, opponent_idx]:
                    total_consumption += stock / (2 * n_players)
                else:
                    total_consumption += stock / n_players
            stock_after_consumption = max(0.0, stock - total_consumption)
            growth = 2.0 * stock_after_consumption * (1.0 - stock_after_consumption / capacity)
            stock = min(stock_after_consumption + growth, capacity)
        return stock

class Strategy_COOPERATIVE_54(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Graduated Reciprocal Trust"
    
    Starts with full cooperation and maintains it as long as the resource remains sustainable.
    Adapts to protect against exploitation while always seeking to return to cooperative equilibrium.
    Key features: resource preservation override, trust-building, adaptive cooperation, and endgame stability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_threshold = game_description.capacity * 0.3
        self.trust_threshold = 0.6
        self.cooperation_threshold = 0.4

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n_players = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        stock = self._estimate_current_stock(history)
        if stock < self.critical_threshold:
            return Action.C
        if current_round == total_rounds:
            return Action.C
        if current_round <= 3:
            last_round_coop_ratio = self._get_cooperation_ratio(history, -1)
            if last_round_coop_ratio > 0:
                return Action.C
            elif current_round == 2:
                return Action.C
        last_round_coop_ratio = self._get_cooperation_ratio(history, -1)
        if history.round_number >= 2:
            recent_ratios = []
            for i in range(min(2, history.round_number)):
                ratio = self._get_cooperation_ratio(history, -(i + 1))
                recent_ratios.append(ratio)
            if all((ratio < self.cooperation_threshold for ratio in recent_ratios)):
                return Action.D
        moving_average = self._get_moving_average_cooperation(history, 3)
        if last_round_coop_ratio >= self.trust_threshold or moving_average >= 0.5:
            return Action.C
        else:
            return Action.C

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game dynamics"""
        stock = float(self.game_description.capacity)
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0.0
            if my_action:
                total_consumption += stock / (2 * n_players)
            else:
                total_consumption += stock / n_players
            for opp_action in opponent_actions:
                if opp_action:
                    total_consumption += stock / (2 * n_players)
                else:
                    total_consumption += stock / n_players
            stock_after_consumption = max(0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth_factor = 1 - stock_after_consumption / capacity
                growth = 2 * stock_after_consumption * growth_factor
                stock = min(stock_after_consumption + growth, capacity)
            else:
                stock = 0
        return stock

    def _get_cooperation_ratio(self, history: PlayerHistory, round_offset: int) -> float:
        """Get cooperation ratio for a specific round (negative offset from current)"""
        round_idx = history.round_number + round_offset
        if round_idx < 0 or round_idx >= history.round_number:
            return 0.0
        cooperators = 1 if history.my_actions[round_idx] else 0
        cooperators += sum(history.opponent_actions[round_idx])
        return cooperators / self.game_description.n_players

    def _get_moving_average_cooperation(self, history: PlayerHistory, window: int) -> float:
        """Calculate moving average of cooperation ratios"""
        if history.round_number == 0:
            return 1.0
        ratios = []
        for i in range(min(window, history.round_number)):
            ratio = self._get_cooperation_ratio(history, -(i + 1))
            ratios.append(ratio)
        return sum(ratios) / len(ratios) if ratios else 1.0

class Strategy_COOPERATIVE_55(BaseStrategy):
    """
    Adaptive Reciprocal Cooperation Strategy (ARCS)
    
    Prioritizes long-term sustainability while protecting against exploitation through adaptive reciprocity.
    Begins cooperatively but adjusts based on observed opponent behavior and resource state.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        current_round = history.round_number + 1
        final_round = self.game_description.n_rounds
        current_stock = self._estimate_current_stock(history)
        if current_round == final_round:
            cooperation_ratio = self._calculate_cooperation_ratio(history)
            if cooperation_ratio >= 0.6:
                return Action.C
            else:
                return Action.D
        if current_stock < capacity * 0.3:
            return Action.C
        cooperation_ratio = self._calculate_cooperation_ratio(history)
        if cooperation_ratio >= 0.7:
            return Action.C
        elif cooperation_ratio <= 0.3:
            return Action.D
        recent_rounds = min(3, current_round - 1)
        recent_cooperation = self._calculate_recent_cooperation_ratio(history, recent_rounds)
        if recent_cooperation > cooperation_ratio + 0.2:
            return Action.C
        elif recent_cooperation < cooperation_ratio - 0.2:
            return Action.D
        if cooperation_ratio > 0.5:
            return Action.C
        else:
            return Action.D

    def _calculate_cooperation_ratio(self, history: PlayerHistory) -> float:
        """Calculate overall cooperation ratio of all opponents across all rounds."""
        total_opponent_actions = np.sum(history.opponent_actions)
        total_possible_actions = history.round_number * (self.game_description.n_players - 1)
        if total_possible_actions == 0:
            return 0.0
        return total_opponent_actions / total_possible_actions

    def _calculate_recent_cooperation_ratio(self, history: PlayerHistory, recent_rounds: int) -> float:
        """Calculate cooperation ratio for the most recent rounds."""
        if recent_rounds == 0 or history.round_number == 0:
            return 0.0
        start_round = max(0, history.round_number - recent_rounds)
        recent_actions = history.opponent_actions[start_round:history.round_number]
        total_recent_cooperations = np.sum(recent_actions)
        total_recent_actions = recent_actions.size
        if total_recent_actions == 0:
            return 0.0
        return total_recent_cooperations / total_recent_actions

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game history."""
        capacity = self.game_description.capacity
        n = self.game_description.n_players
        stock = capacity
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0.0
            if my_action:
                total_consumption += stock / (2 * n)
            else:
                total_consumption += stock / n
            for opponent_action in opponent_actions:
                if opponent_action:
                    total_consumption += stock / (2 * n)
                else:
                    total_consumption += stock / n
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            stock = min(stock_after_consumption + growth, capacity)
        return stock

class Strategy_COOPERATIVE_56(BaseStrategy):
    """
    Adaptive Cooperative Strategy with Forgiveness
    
    Prioritizes long-term sustainability while being responsive to opponent behavior.
    Starts cooperative but includes mechanisms to protect against exploitation
    and encourage return to cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_rounds = 0
        self.critical_threshold = game_description.capacity / (4 * game_description.n_players)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number
        last_payoff = history.my_payoffs[-1]
        last_action = history.my_actions[-1]
        if last_action:
            estimated_stock = last_payoff * 2 * self.game_description.n_players
        else:
            estimated_stock = last_payoff * self.game_description.n_players
        if estimated_stock <= self.critical_threshold:
            return self._emergency_protocol(estimated_stock)
        if self._recent_exploitation_detected(history):
            return self._conditional_punishment()
        return Action.C

    def _emergency_protocol(self, stock_level):
        """Handle critically low stock situations"""
        if stock_level <= self.game_description.capacity / (8 * self.game_description.n_players):
            return Action.D
        else:
            return Action.C

    def _recent_exploitation_detected(self, history):
        """Check if opponents have been defecting recently"""
        if history.round_number < 1:
            return False
        last_round_actions = history.opponent_actions[history.round_number - 1]
        defectors = sum((1 for action in last_round_actions if not action))
        defection_rate = defectors / len(last_round_actions)
        if defection_rate > 0.5:
            return True
        if history.round_number >= 2:
            rounds_to_check = min(3, history.round_number)
            total_defections = 0
            total_decisions = 0
            for i in range(rounds_to_check):
                round_idx = history.round_number - 1 - i
                round_actions = history.opponent_actions[round_idx]
                defections = sum((1 for action in round_actions if not action))
                total_defections += defections
                total_decisions += len(round_actions)
            trend_defection_rate = total_defections / total_decisions
            return trend_defection_rate > 0.4
        return False

    def _conditional_punishment(self):
        """Handle punishment logic with forgiveness"""
        if self.punishment_rounds > 0:
            self.punishment_rounds -= 1
            return Action.D
        else:
            self.punishment_rounds = 1
            return Action.D

    def _recent_cooperation_trend(self, history):
        """Check if opponents have returned to cooperation"""
        if history.round_number < 1:
            return True
        rounds_to_check = min(2, history.round_number)
        total_cooperations = 0
        total_decisions = 0
        for i in range(rounds_to_check):
            round_idx = history.round_number - 1 - i
            round_actions = history.opponent_actions[round_idx]
            cooperations = sum((1 for action in round_actions if action))
            total_cooperations += cooperations
            total_decisions += len(round_actions)
        cooperation_rate = total_cooperations / total_decisions
        return cooperation_rate > 0.6

class Strategy_COOPERATIVE_57(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Majority"
    
    This strategy prioritizes long-term sustainability while being responsive to cooperative behavior.
    It cooperates when a majority of players cooperated in the previous round, with special handling
    for the first round (always cooperate) and emergency situations when stock is critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number
        current_stock = self._calculate_current_stock(history)
        if current_stock < self.capacity * 0.3:
            cooperators_last_round = self._count_cooperators_last_round(history)
            if cooperators_last_round >= self.n_players / 2 and self._stock_trend_improving(history):
                return Action.C
            else:
                return Action.D
        cooperators_last_round = self._count_cooperators_last_round(history)
        if cooperators_last_round >= self.n_players / 2:
            return Action.C
        else:
            return Action.D

    def _count_cooperators_last_round(self, history: PlayerHistory) -> int:
        """Count number of cooperators (including self) in the most recent round."""
        last_round_idx = history.round_number - 1
        opponent_cooperators = int(np.sum(history.opponent_actions[last_round_idx]))
        self_cooperated = int(history.my_actions[last_round_idx])
        return opponent_cooperators + self_cooperated

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game history."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            cooperators = int(my_action) + int(np.sum(opponent_actions))
            defectors = self.n_players - cooperators
            cooperator_consumption = stock / (2 * self.n_players)
            defector_consumption = stock / self.n_players
            total_consumption = cooperators * cooperator_consumption + defectors * defector_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _stock_trend_improving(self, history: PlayerHistory) -> bool:
        """Check if stock trend is improving over the last two rounds."""
        if history.round_number < 2:
            return False
        current_stock = self._calculate_current_stock(history)
        prev_history = PlayerHistory(my_actions=history.my_actions[:-1], my_payoffs=history.my_payoffs[:-1], opponent_actions=history.opponent_actions[:-1], opponent_payoffs=history.opponent_payoffs[:-1])
        previous_stock = self._calculate_current_stock(prev_history)
        return current_stock >= previous_stock

class Strategy_COOPERATIVE_58(BaseStrategy):
    """
    Adaptive Sustainable Cooperation strategy that balances cooperation with sustainability concerns.
    Prioritizes long-term resource sustainability while adapting to opponent behavior patterns.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5
        self.sustainability_threshold = game_description.capacity * 0.3
        self.memory_window = min(3, game_description.n_rounds // 2)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number
        current_stock = self._calculate_current_stock(history)
        if current_stock <= self.sustainability_threshold:
            return Action.C
        if current_round == self.game_description.n_rounds - 1:
            recent_cooperation_rate = self._get_recent_cooperation_rate(history)
            if recent_cooperation_rate >= 0.4:
                return Action.C
            else:
                return Action.D
        others_cooperation_rate = self._get_last_round_cooperation_rate(history)
        recent_cooperation_trend = self._get_recent_cooperation_rate(history)
        if others_cooperation_rate >= self.cooperation_threshold:
            return Action.C
        if recent_cooperation_trend >= 0.4 and current_stock >= self.game_description.capacity * 0.6:
            return Action.C
        if recent_cooperation_trend < 0.2:
            return Action.D
        return Action.C

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game history."""
        stock = float(self.game_description.capacity)
        n = self.game_description.n_players
        for round_idx in range(history.round_number):
            my_consumption = stock / (2 * n) if history.my_actions[round_idx] else stock / n
            opponent_consumption = 0
            for player_idx in range(len(history.opponent_actions[round_idx])):
                if history.opponent_actions[round_idx, player_idx]:
                    opponent_consumption += stock / (2 * n)
                else:
                    opponent_consumption += stock / n
            total_consumption = my_consumption + opponent_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.game_description.capacity)
            stock = min(stock_after_consumption + growth, self.game_description.capacity)
        return stock

    def _get_last_round_cooperation_rate(self, history: PlayerHistory) -> float:
        """Get cooperation rate of opponents in the most recent round."""
        if history.round_number == 0:
            return 0.0
        last_round_idx = history.round_number - 1
        cooperators = sum(history.opponent_actions[last_round_idx])
        total_opponents = len(history.opponent_actions[last_round_idx])
        return cooperators / total_opponents if total_opponents > 0 else 0.0

    def _get_recent_cooperation_rate(self, history: PlayerHistory) -> float:
        """Get cooperation rate of opponents over recent rounds (memory window)."""
        if history.round_number == 0:
            return 0.0
        start_round = max(0, history.round_number - self.memory_window)
        total_cooperations = 0
        total_actions = 0
        for round_idx in range(start_round, history.round_number):
            cooperations_this_round = sum(history.opponent_actions[round_idx])
            total_cooperations += cooperations_this_round
            total_actions += len(history.opponent_actions[round_idx])
        return total_cooperations / total_actions if total_actions > 0 else 0.0

class Strategy_COOPERATIVE_59(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Resource Conservation (ATTRC).
    Balances cooperation with resource preservation by adapting to opponent behavior
    while maintaining a cooperative baseline. Uses stock health and cooperation rates
    to make strategic decisions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_num = history.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = self._calculate_current_stock(history)
        if round_num <= 2:
            return Action.C
        stock_health = current_stock / capacity
        cooperation_rate = self._calculate_cooperation_rate(history)
        if round_num == r:
            if stock_health >= 0.4 and cooperation_rate >= 0.4:
                return Action.C
            else:
                return Action.D
        critical_threshold = 0.3
        healthy_threshold = 0.7
        if stock_health <= critical_threshold:
            if cooperation_rate >= 0.5:
                return Action.C
            else:
                return Action.D
        elif stock_health >= healthy_threshold:
            if cooperation_rate >= 0.6:
                return Action.C
            elif cooperation_rate >= 0.3:
                return Action.C if random.random() < 0.7 else Action.D
            else:
                return Action.D
        else:
            recent_defection_rate = self._calculate_recent_defection_rate(history, 2)
            if recent_defection_rate <= 0.3:
                return Action.C
            elif recent_defection_rate <= 0.6:
                return self._mirror_majority_from_last_round(history)
            else:
                return Action.D

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock based on game history."""
        capacity = self.game_description.capacity
        n = self.game_description.n_players
        stock = float(capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0.0
            if my_action:
                total_consumption += stock / (2 * n)
            else:
                total_consumption += stock / n
            for opp_action in opponent_actions:
                if opp_action:
                    total_consumption += stock / (2 * n)
                else:
                    total_consumption += stock / n
            stock_after_consumption = max(0.0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            stock = min(stock_after_consumption + growth, capacity)
        return stock

    def _calculate_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate overall cooperation rate of opponents."""
        if history.round_number == 0:
            return 1.0
        total_actions = 0
        total_cooperations = 0
        for round_idx in range(history.round_number):
            opponent_actions = history.opponent_actions[round_idx]
            total_actions += len(opponent_actions)
            total_cooperations += sum(opponent_actions)
        return total_cooperations / total_actions if total_actions > 0 else 1.0

    def _calculate_recent_defection_rate(self, history: PlayerHistory, lookback: int) -> float:
        """Calculate defection rate in the last 'lookback' rounds."""
        n = self.game_description.n_players
        start_round = max(0, history.round_number - lookback)
        total_actions = 0
        total_defections = 0
        for round_idx in range(start_round, history.round_number):
            opponent_actions = history.opponent_actions[round_idx]
            total_actions += len(opponent_actions)
            total_defections += sum((1 - action for action in opponent_actions))
        return total_defections / total_actions if total_actions > 0 else 0.0

    def _mirror_majority_from_last_round(self, history: PlayerHistory) -> Action:
        """Return the action that was taken by the majority in the last round."""
        if history.round_number == 0:
            return Action.C
        last_round_actions = history.opponent_actions[history.round_number - 1]
        cooperations = sum(last_round_actions)
        defections = len(last_round_actions) - cooperations
        return Action.C if cooperations >= defections else Action.D

class Strategy_COOPERATIVE_60(BaseStrategy):
    """
    Conditional Cooperation with Punishment strategy for Common Pool Resource Game.
    
    Starts cooperative, rewards collective cooperation, but punishes widespread defection
    to protect the resource. Uses majority defection as trigger for temporary punishment,
    with emergency cooperation when stock is critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defection_threshold = game_description.n_players // 2
        self.punishment_duration = 2
        self.punishment_timer = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punishment_timer = 0
            return Action.C
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        current_round = history.round_number + 1
        final_round = self.game_description.n_rounds
        current_stock = self._estimate_current_stock(history, capacity, n)
        if self.punishment_timer > 0:
            self.punishment_timer -= 1
            return Action.D
        if current_stock < capacity * 0.3:
            return Action.C
        if current_round == final_round:
            last_round_cooperators = sum(history.opponent_actions[-1]) + (1 if history.my_actions[-1] else 0)
            if last_round_cooperators > n // 2:
                return Action.C
            else:
                return Action.D
        last_round_defectors = sum(~history.opponent_actions[-1]) + (0 if history.my_actions[-1] else 1)
        if last_round_defectors >= self.defection_threshold:
            self.punishment_timer = self.punishment_duration - 1
            return Action.D
        else:
            return Action.C

    def _estimate_current_stock(self, history, capacity, n):
        """
        Estimate current stock level based on action history.
        This is an approximation since we don't have direct access to stock values.
        """
        stock = capacity
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            cooperators = sum(opponent_actions) + (1 if my_action else 0)
            defectors = n - cooperators
            cooperator_consumption = cooperators * (stock / (2 * n))
            defector_consumption = defectors * (stock / n)
            total_consumption = cooperator_consumption + defector_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            stock = min(stock_after_consumption + growth, capacity)
        return stock

class Strategy_COOPERATIVE_61(BaseStrategy):
    """
    Sustainable Steward: An adaptive cooperative strategy that prioritizes long-term sustainability
    while being responsive to opponent behavior. Starts cooperatively, adapts to defection patterns,
    includes forgiveness mechanisms, and monitors stock health to prevent resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.6
        self.forgiveness_frequency = 3
        self.critical_stock_ratio = 0.3

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        current_stock = self._estimate_current_stock(history)
        if current_stock < self.critical_stock_ratio * self.game_description.capacity:
            return Action.C
        if current_round == self.game_description.n_rounds:
            last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
            if last_round_cooperators >= self.game_description.n_players / 2:
                return Action.C
            else:
                return Action.D
        if current_round % self.forgiveness_frequency == 0:
            return Action.C
        last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
        cooperation_rate = last_round_cooperators / self.game_description.n_players
        if cooperation_rate >= self.cooperation_threshold:
            return Action.C
        elif cooperation_rate >= 0.3:
            stock_ratio = current_stock / self.game_description.capacity
            if stock_ratio >= 0.7:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game dynamics"""
        stock = float(self.game_description.capacity)
        n = self.game_description.n_players
        capacity = float(self.game_description.capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            cooperators = sum(opponent_actions) + (1 if my_action else 0)
            defectors = n - cooperators
            cooperator_consumption = stock / (2 * n)
            defector_consumption = stock / n
            total_consumption = cooperators * cooperator_consumption + defectors * defector_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            stock = min(stock_after_consumption + growth, capacity)
        return stock

class Strategy_COOPERATIVE_62(BaseStrategy):
    """
    Adaptive Conditional Cooperation Strategy (ACCS) - Balances cooperative intent with 
    protection against exploitation while prioritizing sustainable resource management.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_num = history.round_number + 1
        current_stock = self._calculate_current_stock(history)
        stock_health = current_stock / self.capacity
        if stock_health < 0.3 and round_num > self.r / 2:
            return Action.D
        if round_num <= 3:
            return Action.C
        recent_cooperation = self._cooperation_rate_last_3_rounds(history)
        if recent_cooperation >= 0.7:
            return Action.C
        elif recent_cooperation >= 0.4:
            return self._conditional_cooperate(stock_health, round_num)
        else:
            return self._punishment_phase(history)

    def _calculate_current_stock(self, history):
        """Calculate current stock level based on game dynamics"""
        stock = self.capacity
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0
            if my_action:
                total_consumption += stock / (2 * self.n)
            else:
                total_consumption += stock / self.n
            for opp_action in opponent_actions:
                if opp_action:
                    total_consumption += stock / (2 * self.n)
                else:
                    total_consumption += stock / self.n
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _cooperation_rate_last_3_rounds(self, history):
        """Calculate cooperation rate over last 3 rounds"""
        rounds_to_check = min(3, history.round_number)
        if rounds_to_check == 0:
            return 1.0
        total_cooperations = 0
        total_actions = 0
        start_round = max(0, history.round_number - rounds_to_check)
        for round_idx in range(start_round, history.round_number):
            if history.my_actions[round_idx]:
                total_cooperations += 1
            total_actions += 1
            for opp_action in history.opponent_actions[round_idx]:
                if opp_action:
                    total_cooperations += 1
                total_actions += 1
        return total_cooperations / total_actions if total_actions > 0 else 1.0

    def _conditional_cooperate(self, stock_health, round_num):
        """Decide whether to cooperate based on stock health and round"""
        if stock_health > 0.6:
            return Action.C
        elif stock_health > 0.4 and round_num < 0.8 * self.r:
            return Action.C
        else:
            return Action.D

    def _punishment_phase(self, history):
        """Implement graduated punishment strategy"""
        rounds_since_breach = self._rounds_since_threshold_breach(history)
        if rounds_since_breach <= 2:
            return Action.D
        else:
            return Action.C

    def _rounds_since_threshold_breach(self, history):
        """Calculate rounds since cooperation fell below 40%"""
        rounds_count = 0
        for i in range(history.round_number - 1, -1, -1):
            round_cooperation = self._round_cooperation_rate(history, i)
            if round_cooperation < 0.4:
                rounds_count += 1
            else:
                break
        return rounds_count

    def _round_cooperation_rate(self, history, round_idx):
        """Calculate cooperation rate for a specific round"""
        if round_idx < 0 or round_idx >= history.round_number:
            return 1.0
        cooperations = 0
        total = 0
        if history.my_actions[round_idx]:
            cooperations += 1
        total += 1
        for opp_action in history.opponent_actions[round_idx]:
            if opp_action:
                cooperations += 1
            total += 1
        return cooperations / total if total > 0 else 1.0

class Strategy_COOPERATIVE_63(BaseStrategy):
    """
    Adaptive Cooperative Strategy with Forgiveness (ACSF)
    
    Prioritizes long-term sustainability while being responsive to opponent behavior.
    Starts cooperative, adapts to defection patterns, but maintains forgiveness
    to enable recovery of cooperation. Uses emergency mode to prevent resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_rounds_remaining = 0
        self.emergency_mode = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        current_stock = self._estimate_current_stock(history)
        capacity = self.game_description.capacity
        if current_stock < capacity * 0.15:
            self.emergency_mode = True
        elif current_stock > capacity * 0.4:
            self.emergency_mode = False
        if self.emergency_mode:
            return Action.C
        if self.punishment_rounds_remaining > 0:
            self.punishment_rounds_remaining -= 1
            return Action.C
        if current_round == total_rounds:
            recent_coop_rate = self._calculate_recent_cooperation_rate(history, 3)
            if recent_coop_rate < 0.3:
                return Action.D
            else:
                return Action.C
        overall_coop_rate = self._calculate_overall_cooperation_rate(history)
        recent_coop_rate = self._calculate_recent_cooperation_rate(history, 5)
        if overall_coop_rate >= 0.7 and recent_coop_rate >= 0.6:
            return Action.C
        elif overall_coop_rate >= 0.4:
            if recent_coop_rate >= 0.5:
                return Action.C
            else:
                self.punishment_rounds_remaining = 2
                return Action.C
        elif current_stock > capacity * 0.6 and recent_coop_rate < 0.2:
            return Action.D
        else:
            return Action.C

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock based on payoffs and game dynamics."""
        if history.round_number == 0:
            return self.game_description.capacity
        last_payoff = history.my_payoffs[-1]
        last_action = history.my_actions[-1]
        n = self.game_description.n_players
        if last_action:
            estimated_stock = last_payoff * 2 * n
        else:
            estimated_stock = last_payoff * n
        total_actions_last_round = np.sum(history.opponent_actions[-1]) + (1 if last_action else 0)
        total_players = n
        cooperation_rate_last_round = total_actions_last_round / total_players
        avg_consumption = estimated_stock / (2 * n) * cooperation_rate_last_round + estimated_stock / n * (1 - cooperation_rate_last_round)
        total_consumption = avg_consumption * n
        stock_after_consumption = max(0, estimated_stock - total_consumption)
        capacity = self.game_description.capacity
        growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
        new_stock = min(stock_after_consumption + growth, capacity)
        return new_stock

    def _calculate_overall_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate cooperation rate across all previous rounds."""
        if history.round_number == 0:
            return 1.0
        total_actions = np.sum(history.opponent_actions)
        total_possible = history.round_number * (self.game_description.n_players - 1)
        if total_possible == 0:
            return 1.0
        return total_actions / total_possible

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory, rounds_back: int) -> float:
        """Calculate cooperation rate for the most recent rounds."""
        if history.round_number == 0:
            return 1.0
        start_round = max(0, history.round_number - rounds_back)
        recent_actions = history.opponent_actions[start_round:]
        if len(recent_actions) == 0:
            return 1.0
        total_actions = np.sum(recent_actions)
        total_possible = len(recent_actions) * (self.game_description.n_players - 1)
        if total_possible == 0:
            return 1.0
        return total_actions / total_possible

class Strategy_COOPERATIVE_64(BaseStrategy):
    """
    Adaptive Sustainability Strategy for Common Pool Resource Game.
    
    Starts cooperatively, monitors resource health, uses measured punishment
    when stock is healthy, prioritizes cooperation when stock is critical,
    and adapts based on others' cooperation levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.7
        self.critical_stock_ratio = 0.3
        self.forgiveness_window = 2
        self.punishment_timer = 0
        self.consecutive_low_stock = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_stock = self._estimate_current_stock(history)
        stock_ratio = current_stock / self.game_description.capacity
        if stock_ratio < self.critical_stock_ratio:
            self.consecutive_low_stock += 1
            if self.consecutive_low_stock >= 2:
                return Action.C
            else:
                return Action.C
        else:
            self.consecutive_low_stock = 0
        if self.punishment_timer > 0:
            self.punishment_timer -= 1
            return Action.D
        last_round = history.round_number - 1
        n_opponents = self.game_description.n_players - 1
        my_last_action = history.my_actions[last_round]
        opponent_cooperators = np.sum(history.opponent_actions[last_round])
        total_cooperators = int(my_last_action) + int(opponent_cooperators)
        coop_rate = total_cooperators / self.game_description.n_players
        if coop_rate < self.cooperation_threshold:
            if stock_ratio > 0.6:
                self.punishment_timer = 1
                return Action.D
            else:
                return Action.C
        if history.round_number == self.game_description.n_rounds - 1:
            if stock_ratio > 0.4:
                return Action.D
            else:
                return Action.C
        return Action.C

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level by reverse-engineering from payoffs."""
        if history.round_number == 0:
            return self.game_description.capacity
        last_round = history.round_number - 1
        my_payoff = history.my_payoffs[last_round]
        my_action = history.my_actions[last_round]
        n = self.game_description.n_players
        if my_action:
            stock_estimate = my_payoff * 2 * n
        else:
            stock_estimate = my_payoff * n
        return self._simulate_stock_update(stock_estimate, history, last_round)

    def _simulate_stock_update(self, initial_stock: float, history: PlayerHistory, round_idx: int) -> float:
        """Simulate stock update for a given round."""
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        my_action = history.my_actions[round_idx]
        opponent_actions = history.opponent_actions[round_idx]
        my_consumption = initial_stock / (2 * n) if my_action else initial_stock / n
        total_consumption = my_consumption
        for opp_action in opponent_actions:
            if opp_action:
                total_consumption += initial_stock / (2 * n)
            else:
                total_consumption += initial_stock / n
        stock_after_consumption = max(0, initial_stock - total_consumption)
        growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
        new_stock = min(stock_after_consumption + growth, capacity)
        return new_stock

class Strategy_COOPERATIVE_65(BaseStrategy):
    """
    Adaptive Cooperative Strategy with Forgiveness.
    
    Prioritizes long-term sustainability through cooperation while being resilient 
    to exploitation. Uses graduated response based on group cooperation levels,
    includes forgiveness mechanisms, and has emergency protocols for resource conservation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        current_stock = self._estimate_current_stock(history)
        critical_threshold = self.capacity * 0.3
        if current_stock < critical_threshold:
            return Action.C
        if current_round == self.n_rounds:
            return self._final_round_strategy(history, current_stock)
        if current_round == self.n_rounds - 1:
            return self._second_to_last_round_strategy(history, current_stock)
        return self._main_strategy(history, current_round)

    def _estimate_current_stock(self, history: None | PlayerHistory) -> float:
        """Estimate current stock based on payoff history."""
        if history is None or len(history.my_payoffs) == 0:
            return self.capacity
        last_payoff = history.my_payoffs[-1]
        last_action = history.my_actions[-1]
        if last_action:
            estimated_stock = last_payoff * 2 * self.n_players
        else:
            estimated_stock = last_payoff * self.n_players
        return max(0, min(estimated_stock, self.capacity))

    def _count_cooperations_in_rounds(self, history: PlayerHistory, start_round: int, end_round: int) -> int:
        """Count total cooperations by all players in specified round range."""
        count = 0
        for round_idx in range(start_round, min(end_round + 1, history.round_number)):
            if round_idx >= 0:
                if history.my_actions[round_idx]:
                    count += 1
                count += sum(history.opponent_actions[round_idx])
        return count

    def _majority_cooperated_last_round(self, history: PlayerHistory) -> bool:
        """Check if majority cooperated in the last round."""
        if history.round_number == 0:
            return True
        last_round_idx = history.round_number - 1
        cooperators = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            cooperators += 1
        return cooperators > self.n_players / 2

    def _main_strategy(self, history: PlayerHistory, current_round: int) -> Action:
        """Main adaptive strategy for middle rounds."""
        if current_round <= 3:
            return Action.C
        rounds_to_check = min(3, history.round_number)
        start_round = history.round_number - rounds_to_check
        total_cooperations = self._count_cooperations_in_rounds(history, start_round, history.round_number - 1)
        total_actions = rounds_to_check * self.n_players
        cooperation_ratio = total_cooperations / total_actions if total_actions > 0 else 0
        if cooperation_ratio >= 0.67:
            return Action.C
        elif cooperation_ratio >= 0.33:
            return Action.C if self._majority_cooperated_last_round(history) else Action.D
        else:
            my_last_action = history.my_actions[-1] if history.round_number > 0 else True
            if not my_last_action and random.random() < 0.2:
                return Action.C
            else:
                return Action.D

    def _second_to_last_round_strategy(self, history: PlayerHistory, current_stock: float) -> Action:
        """Strategy for second-to-last round."""
        if current_stock >= self.capacity * 0.5:
            return Action.C
        rounds_to_check = min(2, history.round_number)
        if rounds_to_check > 0:
            start_round = history.round_number - rounds_to_check
            recent_cooperations = self._count_cooperations_in_rounds(history, start_round, history.round_number - 1)
            recent_actions = rounds_to_check * self.n_players
            recent_cooperation_rate = recent_cooperations / recent_actions if recent_actions > 0 else 0
            return Action.C if recent_cooperation_rate >= 0.5 else Action.D
        return Action.C

    def _final_round_strategy(self, history: PlayerHistory, current_stock: float) -> Action:
        """Strategy for final round."""
        if history.round_number > 0:
            total_opponent_cooperations = 0
            total_opponent_actions = 0
            for round_idx in range(history.round_number):
                total_opponent_cooperations += sum(history.opponent_actions[round_idx])
                total_opponent_actions += len(history.opponent_actions[round_idx])
            total_group_cooperation = total_opponent_cooperations / total_opponent_actions if total_opponent_actions > 0 else 0
        else:
            total_group_cooperation = 1.0
        if total_group_cooperation >= 0.6:
            return Action.C
        if current_stock >= self.capacity * 0.8:
            return Action.C
        return Action.D

class Strategy_COOPERATIVE_66(BaseStrategy):
    """
    Sustainable Majority with Forgiveness strategy for Common Pool Resource Game.
    
    Cooperates when majority of others cooperated previously and stock is above critical threshold.
    Defects when majority defected or stock is critically low (<30% capacity).
    Includes forgiveness mechanism when stock is recovering (>10% growth).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.critical_threshold = self.capacity * 0.3
        self.previous_stock = None

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_stock = self._calculate_current_stock(history)
        if current_stock < self.critical_threshold:
            self.previous_stock = current_stock
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.n_rounds:
            previous_cooperators = self._count_cooperators_last_round(history)
            majority_threshold = (self.n_players - 1) / 2
            if previous_cooperators >= majority_threshold:
                self.previous_stock = current_stock
                return Action.C
            else:
                self.previous_stock = current_stock
                return Action.D
        previous_cooperators = self._count_cooperators_last_round(history)
        majority_threshold = (self.n_players - 1) / 2
        if previous_cooperators >= majority_threshold:
            self.previous_stock = current_stock
            return Action.C
        elif self.previous_stock is not None and current_stock > self.previous_stock * 1.1:
            self.previous_stock = current_stock
            return Action.C
        else:
            self.previous_stock = current_stock
            return Action.D

    def _count_cooperators_last_round(self, history: PlayerHistory) -> int:
        """Count how many opponents cooperated in the most recent round."""
        if history.round_number == 0:
            return 0
        last_round_index = history.round_number - 1
        return int(np.sum(history.opponent_actions[last_round_index]))

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate the current stock level based on game history."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0.0
            if my_action:
                total_consumption += stock / (2 * self.n_players)
            else:
                total_consumption += stock / self.n_players
            for opponent_action in opponent_actions:
                if opponent_action:
                    total_consumption += stock / (2 * self.n_players)
                else:
                    total_consumption += stock / self.n_players
            stock_after_consumption = stock - total_consumption
            stock_after_consumption = max(0, stock_after_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            else:
                growth = 0
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

class Strategy_COOPERATIVE_67(BaseStrategy):
    """
    Forgiving Tit-for-Tat with Stock Protection strategy.
    Prioritizes long-term sustainability while being cooperative, forgiving, and adaptive to the resource state.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        total_rounds = self.game_description.n_rounds
        current_stock = self._calculate_current_stock(history, capacity, n_players)
        if current_stock <= 0.3 * capacity:
            return Action.C
        recent_rounds = min(3, history.round_number)
        recent_coop_rate = self._calculate_recent_cooperation_rate(history, recent_rounds)
        forgiveness_threshold = max(0.6 - current_round / total_rounds * 0.2, 0.4)
        if current_round == total_rounds:
            overall_coop_rate = self._calculate_overall_cooperation_rate(history)
            if current_stock > 0.4 * capacity:
                return Action.C if overall_coop_rate >= 0.5 else Action.D
            else:
                return Action.C
        if recent_coop_rate >= forgiveness_threshold:
            return Action.C
        elif current_stock < 0.5 * capacity and recent_coop_rate < 0.3:
            return Action.C
        else:
            return Action.D

    def _calculate_current_stock(self, history: PlayerHistory, capacity: float, n_players: int) -> float:
        """Calculate current stock level based on game history and dynamics."""
        stock = capacity
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            cooperators = int(my_action) + sum(opponent_actions)
            defectors = n_players - cooperators
            cooperator_consumption = stock / (2 * n_players)
            defector_consumption = stock / n_players
            total_consumption = cooperators * cooperator_consumption + defectors * defector_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            stock = min(stock_after_consumption + growth, capacity)
        return stock

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory, num_rounds: int) -> float:
        """Calculate cooperation rate over the last num_rounds rounds."""
        if history.round_number == 0:
            return 1.0
        start_idx = max(0, history.round_number - num_rounds)
        recent_actions = history.opponent_actions[start_idx:]
        if len(recent_actions) == 0:
            return 1.0
        total_actions = recent_actions.size
        total_cooperations = np.sum(recent_actions)
        return total_cooperations / total_actions if total_actions > 0 else 1.0

    def _calculate_overall_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate overall cooperation rate across all rounds."""
        if history.round_number == 0:
            return 1.0
        total_actions = history.opponent_actions.size
        total_cooperations = np.sum(history.opponent_actions)
        return total_cooperations / total_actions if total_actions > 0 else 1.0

class Strategy_COOPERATIVE_68(BaseStrategy):
    """
    Adaptive Sustainable Cooperation (ASC) strategy that balances long-term sustainability 
    with responsiveness to opponent cooperation levels. Starts optimistically, adapts to 
    opponent behavior patterns, and includes crisis management for resource depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5
        self.trust_decay = 0.1
        self.forgiveness_factor = 0.8
        self.recent_window = min(3, max(1, game_description.n_rounds // 4))

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = self._estimate_current_stock(history, capacity, n_players)
        if current_round == n_rounds:
            recent_coop_rate = self._get_recent_cooperation_rate(history, self.recent_window)
            current_stock_health = current_stock / capacity
            if current_stock_health > 0.3 and recent_coop_rate >= 0.4:
                return Action.C
            else:
                return Action.D
        else:
            recent_coop_rate = self._get_recent_cooperation_rate(history, self.recent_window)
            stock_health = current_stock / capacity
            predicted_rounds_left = n_rounds - current_round + 1
            sustainability_crisis = stock_health < predicted_rounds_left * 0.15
            if sustainability_crisis and recent_coop_rate < 0.3:
                return Action.D
            elif recent_coop_rate >= self.cooperation_threshold:
                return Action.C
            elif recent_coop_rate >= 0.3 and stock_health > 0.5:
                if random.random() < self.forgiveness_factor:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D

    def _get_recent_cooperation_rate(self, history: PlayerHistory, window_size: int) -> float:
        """Calculate the cooperation rate of opponents in the recent window."""
        if history.round_number == 0:
            return 1.0
        start_round = max(0, history.round_number - window_size)
        end_round = history.round_number
        total_decisions = 0
        total_cooperations = 0
        for round_idx in range(start_round, end_round):
            cooperations_this_round = np.sum(history.opponent_actions[round_idx])
            total_cooperations += cooperations_this_round
            total_decisions += len(history.opponent_actions[round_idx])
        if total_decisions == 0:
            return 1.0
        return total_cooperations / total_decisions

    def _estimate_current_stock(self, history: PlayerHistory, capacity: int, n_players: int) -> float:
        """Estimate current stock level based on action history and game dynamics."""
        stock = float(capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            cooperators = int(my_action) + np.sum(opponent_actions)
            defectors = n_players - cooperators
            coop_consumption_per_player = stock / (2 * n_players)
            defect_consumption_per_player = stock / n_players
            total_consumption = cooperators * coop_consumption_per_player + defectors * defect_consumption_per_player
            stock_after_consumption = max(0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
                stock = min(stock_after_consumption + growth, capacity)
            else:
                stock = 0
        return stock

class Strategy_COOPERATIVE_69(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Guardian"
    
    Prioritizes long-term sustainability while adapting to opponent behavior patterns.
    Starts cooperative and gradually adjusts based on observed cooperation levels,
    with built-in forgiveness mechanisms to encourage mutual cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        stock = self._estimate_current_stock(history)
        if stock < self.capacity * 0.2:
            return Action.C
        if current_round <= 2:
            return Action.C
        if current_round == self.n_rounds:
            return Action.D
        recent_cooperation_rate = self._calculate_opponent_cooperation_rate(history, 2)
        if current_round <= self.n_rounds - 2:
            if recent_cooperation_rate >= 0.5:
                return Action.C
            elif recent_cooperation_rate >= 0.25 and stock > self.capacity * 0.3:
                return Action.C
            else:
                consecutive_defections = self._count_my_recent_defections(history)
                if consecutive_defections > 0 and consecutive_defections % 3 == 0:
                    return Action.C
                else:
                    return Action.D
        if current_round == self.n_rounds - 1:
            if recent_cooperation_rate >= 0.4:
                return Action.C
            else:
                return Action.D
        return Action.C

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game history and dynamics."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0.0
            if my_action:
                total_consumption += stock / (2 * self.n_players)
            else:
                total_consumption += stock / self.n_players
            for opp_action in opponent_actions:
                if opp_action:
                    total_consumption += stock / (2 * self.n_players)
                else:
                    total_consumption += stock / self.n_players
            stock_after_consumption = max(0.0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            else:
                growth = 0.0
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _calculate_opponent_cooperation_rate(self, history: PlayerHistory, lookback_rounds: int) -> float:
        """Calculate cooperation rate of opponents over the last lookback_rounds."""
        if history.round_number == 0:
            return 1.0
        start_round = max(0, history.round_number - lookback_rounds)
        total_opponent_actions = 0
        cooperative_actions = 0
        for round_idx in range(start_round, history.round_number):
            for opp_action in history.opponent_actions[round_idx]:
                total_opponent_actions += 1
                if opp_action:
                    cooperative_actions += 1
        if total_opponent_actions == 0:
            return 1.0
        return cooperative_actions / total_opponent_actions

    def _count_my_recent_defections(self, history: PlayerHistory) -> int:
        """Count consecutive defections from the end of my action history."""
        if history.round_number == 0:
            return 0
        consecutive_defections = 0
        for i in range(history.round_number - 1, -1, -1):
            if not history.my_actions[i]:
                consecutive_defections += 1
            else:
                break
        return consecutive_defections

class Strategy_COOPERATIVE_70(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Forgiveness Strategy for Common Pool Resource Game.
    
    Balances cooperation with sustainability protection through adaptive responses to collective behavior.
    Starts cooperatively, adapts based on collective cooperation rates and stock levels,
    includes forgiveness mechanism to prevent permanent defection spirals.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.consecutive_low_cooperation = 0
        self.forced_defection_count = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.consecutive_low_cooperation = 0
            self.forced_defection_count = 0
            return Action.C
        round_num = history.round_number + 1
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        last_payoff = history.my_payoffs[-1]
        last_action = history.my_actions[-1]
        if last_action:
            current_stock = last_payoff * 2 * n_players
        else:
            current_stock = last_payoff * n_players
        if round_num <= 2:
            return Action.C
        last_round_opponents = history.opponent_actions[history.round_number - 1]
        my_last_action = history.my_actions[-1]
        total_cooperators = sum(last_round_opponents) + (1 if my_last_action else 0)
        last_round_coop_rate = total_cooperators / n_players
        rounds_to_check = min(3, history.round_number)
        total_coop_last_3 = 0
        total_actions_last_3 = 0
        for i in range(rounds_to_check):
            round_idx = history.round_number - 1 - i
            opponents_in_round = history.opponent_actions[round_idx]
            my_action_in_round = history.my_actions[round_idx]
            total_coop_last_3 += sum(opponents_in_round) + (1 if my_action_in_round else 0)
            total_actions_last_3 += n_players
        coop_rate_last_3 = total_coop_last_3 / total_actions_last_3 if total_actions_last_3 > 0 else 0
        stock_health = current_stock / capacity
        if round_num == n_rounds:
            if stock_health > 0.2:
                return Action.C
            else:
                return Action.D
        if stock_health <= 0.3:
            return Action.D
        if last_round_coop_rate < 0.4:
            self.consecutive_low_cooperation += 1
        else:
            self.consecutive_low_cooperation = 0
        if self.forced_defection_count >= 3:
            self.forced_defection_count = 0
            return Action.C
        if last_round_coop_rate >= 0.5:
            return Action.C
        elif coop_rate_last_3 >= 0.4:
            return Action.C
        elif self.consecutive_low_cooperation >= 2:
            self.forced_defection_count += 1
            return Action.D
        elif random.random() < 0.7:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_71(BaseStrategy):
    """
    Adaptive Conditional Cooperator Strategy
    
    Fundamentally cooperative but pragmatically adaptive. Establishes and maintains 
    cooperation while protecting against exploitation. Uses conditional cooperation
    based on previous round cooperation rates, with special handling for stock
    depletion, forgiveness, and end game scenarios.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_number = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        current_stock = self._calculate_current_stock(history)
        prev_round_actions = history.opponent_actions[history.round_number - 1]
        cooperation_rate = np.sum(prev_round_actions) / len(prev_round_actions)
        if current_stock < capacity / 4:
            return Action.C
        if round_number > total_rounds - 2:
            recent_rounds = min(3, history.round_number)
            total_cooperations = 0
            total_actions = 0
            start_round = max(0, history.round_number - recent_rounds)
            for i in range(start_round, history.round_number):
                total_cooperations += np.sum(history.opponent_actions[i])
                total_actions += len(history.opponent_actions[i])
            if total_cooperations / total_actions >= 0.5:
                return Action.C
            else:
                return Action.D
        if round_number > 2 and history.my_actions[history.round_number - 1] == False and (cooperation_rate < 0.5):
            if round_number > 2:
                prev_stock = self._calculate_stock_at_round(history, history.round_number - 1)
                if current_stock > prev_stock:
                    return Action.C
        if cooperation_rate >= 0.5:
            return Action.C
        else:
            return Action.D

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate the current stock level based on game history."""
        stock = self.game_description.capacity
        for round_idx in range(history.round_number):
            stock = self._update_stock_after_round(stock, history, round_idx)
        return stock

    def _calculate_stock_at_round(self, history: PlayerHistory, target_round: int) -> float:
        """Calculate stock level at a specific round."""
        stock = self.game_description.capacity
        for round_idx in range(target_round):
            stock = self._update_stock_after_round(stock, history, round_idx)
        return stock

    def _update_stock_after_round(self, stock: float, history: PlayerHistory, round_idx: int) -> float:
        """Update stock after a specific round based on actions taken."""
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        total_consumption = 0
        if history.my_actions[round_idx]:
            total_consumption += stock / (2 * n_players)
        else:
            total_consumption += stock / n_players
        for opponent_action in history.opponent_actions[round_idx]:
            if opponent_action:
                total_consumption += stock / (2 * n_players)
            else:
                total_consumption += stock / n_players
        stock_after_consumption = max(0, stock - total_consumption)
        growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
        new_stock = min(stock_after_consumption + growth, capacity)
        return new_stock

class Strategy_COOPERATIVE_72(BaseStrategy):
    """
    Adaptive Reciprocity with Sustainability Threshold (ARST) Strategy.
    
    Prioritizes long-term sustainability while being conditionally cooperative,
    adapting to opponent behavior to maintain resource viability and encourage
    cooperative equilibrium.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.lookback_window = 3
        self.sustainability_threshold = game_description.capacity * 0.25
        self.high_coop_threshold = 0.7
        self.mixed_coop_threshold = 0.4
        self.initial_coop_fraction = 0.2
        self.final_coop_fraction = 0.1
        self.initial_phase_end = max(2, int(game_description.n_rounds * self.initial_coop_fraction))
        self.final_phase_start = game_description.n_rounds - max(2, int(game_description.n_rounds * self.final_coop_fraction))

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        current_stock = self._calculate_current_stock(history)
        if current_round <= self.initial_phase_end:
            return Action.C
        if current_stock < self.sustainability_threshold:
            return Action.C
        cooperation_rate = self._calculate_recent_cooperation_rate(history)
        if cooperation_rate >= self.high_coop_threshold:
            return Action.C
        elif cooperation_rate >= self.mixed_coop_threshold:
            if current_stock > self.game_description.capacity * 0.6:
                return self._probabilistic_choice(0.8, current_round, current_stock)
            else:
                return self._probabilistic_choice(0.6, current_round, current_stock)
        elif current_round >= self.final_phase_start:
            return Action.C
        else:
            return Action.D

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game dynamics."""
        stock = float(self.game_description.capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0.0
            if my_action:
                total_consumption += stock / (2 * self.game_description.n_players)
            else:
                total_consumption += stock / self.game_description.n_players
            for opponent_action in opponent_actions:
                if opponent_action:
                    total_consumption += stock / (2 * self.game_description.n_players)
                else:
                    total_consumption += stock / self.game_description.n_players
            stock_after_consumption = max(0.0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.game_description.capacity)
            stock = min(stock_after_consumption + growth, self.game_description.capacity)
        return stock

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate cooperation rate over recent rounds."""
        recent_rounds = min(self.lookback_window, history.round_number)
        if recent_rounds == 0:
            return 1.0
        total_actions = 0
        cooperative_actions = 0
        start_idx = max(0, history.round_number - recent_rounds)
        for round_idx in range(start_idx, history.round_number):
            total_actions += 1
            if history.my_actions[round_idx]:
                cooperative_actions += 1
            for opponent_action in history.opponent_actions[round_idx]:
                total_actions += 1
                if opponent_action:
                    cooperative_actions += 1
        return cooperative_actions / total_actions if total_actions > 0 else 1.0

    def _probabilistic_choice(self, cooperate_probability: float, round_num: int, stock_level: float) -> Action:
        """Make a probabilistic choice using game state for deterministic pseudo-randomness."""
        seed_value = int((round_num * 1000 + stock_level * 100) % 1000000)
        pseudo_random = (seed_value * 17 + 23) % 100 / 100.0
        return Action.C if pseudo_random < cooperate_probability else Action.D

class Strategy_COOPERATIVE_73(BaseStrategy):
    """
    Adaptive Trust Builder: A cooperative strategy that balances long-term cooperation 
    with protection against exploitation while maintaining resource sustainability.
    Uses trust-based decision making with graduated responses and emergency cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5
        self.trust_score = 1.0
        self.forgiveness_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_number = history.round_number + 1
        n = self.game_description.n_players
        max_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = self._estimate_current_stock(history, capacity, n)
        if round_number == max_rounds:
            if current_stock >= capacity * 0.3:
                return Action.C
            else:
                return Action.D
        last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
        if history.my_actions[history.round_number - 1]:
            last_round_cooperators += 1
        cooperation_rate = last_round_cooperators / n
        self.trust_score = 0.7 * self.trust_score + 0.3 * cooperation_rate
        if current_stock < capacity * 0.2:
            return Action.C
        if self.trust_score >= self.cooperation_threshold:
            self.forgiveness_counter = 0
            return Action.C
        elif self.trust_score >= 0.3:
            if cooperation_rate >= 0.4 or self.forgiveness_counter < 2:
                self.forgiveness_counter += 1
                return Action.C
            else:
                return Action.D
        elif cooperation_rate >= 0.6:
            self.forgiveness_counter = 0
            return Action.C
        else:
            return Action.D

    def _estimate_current_stock(self, history: PlayerHistory, capacity: float, n: int) -> float:
        """Estimate current stock based on history of actions and game dynamics."""
        stock = capacity
        for round_idx in range(history.round_number):
            cooperators = sum(history.opponent_actions[round_idx])
            if history.my_actions[round_idx]:
                cooperators += 1
            defectors = n - cooperators
            consumption = cooperators * (stock / (2 * n)) + defectors * (stock / n)
            stock_after_consumption = max(0, stock - consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            stock = min(stock_after_consumption + growth, capacity)
        return stock

class Strategy_COOPERATIVE_74(BaseStrategy):
    """
    Sustainable Trust with Graduated Response Strategy
    
    Prioritizes long-term sustainability while being cooperative by default,
    with mechanisms to protect against exploitation and encourage reciprocal cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        stock_level = self._estimate_current_stock(history)
        normalized_stock = stock_level / self.capacity
        if current_round == self.n_rounds:
            if normalized_stock >= 0.3:
                return Action.C
            else:
                return Action.D
        others_recent_cooperation = self._calculate_others_cooperation_rate(history, 3)
        last_round_cooperation_rate = self._calculate_last_round_cooperation_rate(history)
        if normalized_stock >= 0.5:
            if others_recent_cooperation < 0.4 and normalized_stock > 0.3:
                return Action.D
            else:
                return Action.C
        elif normalized_stock >= 0.3:
            cooperation_threshold = max(0.4, normalized_stock)
            if last_round_cooperation_rate >= cooperation_threshold:
                return Action.C
            else:
                return Action.D
        elif last_round_cooperation_rate >= 0.6:
            return Action.C
        else:
            return Action.D

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game dynamics."""
        stock = self.capacity
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0
            if my_action:
                total_consumption += stock / (2 * self.n_players)
            else:
                total_consumption += stock / self.n_players
            for opp_action in opponent_actions:
                if opp_action:
                    total_consumption += stock / (2 * self.n_players)
                else:
                    total_consumption += stock / self.n_players
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _calculate_others_cooperation_rate(self, history: PlayerHistory, lookback_rounds: int) -> float:
        """Calculate average cooperation rate of opponents over last N rounds."""
        if history.round_number == 0:
            return 0.5
        start_round = max(0, history.round_number - lookback_rounds)
        total_decisions = 0
        total_cooperations = 0
        for round_idx in range(start_round, history.round_number):
            opponent_actions = history.opponent_actions[round_idx]
            total_decisions += len(opponent_actions)
            total_cooperations += sum(opponent_actions)
        if total_decisions == 0:
            return 0.5
        return total_cooperations / total_decisions

    def _calculate_last_round_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate cooperation rate in the most recent round."""
        if history.round_number == 0:
            return 0.5
        last_round_idx = history.round_number - 1
        opponent_actions = history.opponent_actions[last_round_idx]
        if len(opponent_actions) == 0:
            return 0.5
        return sum(opponent_actions) / len(opponent_actions)

class Strategy_COOPERATIVE_75(BaseStrategy):
    """
    Conditional Cooperator with Forgiveness strategy for Common Pool Resource Game.
    
    Cooperates conditionally based on majority behavior of others, with forgiveness
    mechanisms and stock-based overrides to maintain resource sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        final_round = self.game_description.n_rounds
        stock = self._calculate_current_stock(history)
        if stock <= capacity / 4:
            return Action.C
        if current_round == final_round:
            if stock > capacity / 2:
                return Action.C
            else:
                return Action.D
        if stock >= capacity and current_round < final_round - 1:
            return Action.D
        previous_round_idx = history.round_number - 1
        other_players_actions = history.opponent_actions[previous_round_idx]
        cooperators = sum(other_players_actions)
        defectors = len(other_players_actions) - cooperators
        if cooperators > defectors:
            return Action.C
        elif defectors > cooperators:
            if stock >= 0.75 * capacity:
                return Action.C
            else:
                return Action.D
        elif stock >= capacity / 2:
            return Action.C
        else:
            return Action.D

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game history."""
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        stock = float(capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0.0
            if my_action:
                total_consumption += stock / (2 * n)
            else:
                total_consumption += stock / n
            for opponent_cooperated in opponent_actions:
                if opponent_cooperated:
                    total_consumption += stock / (2 * n)
                else:
                    total_consumption += stock / n
            stock_after_consumption = max(0.0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            stock = min(stock_after_consumption + growth, capacity)
        return stock

class Strategy_COOPERATIVE_76(BaseStrategy):
    """
    Adaptive Consensus Builder: A cooperative strategy that prioritizes long-term sustainability
    while building and maintaining cooperative coalitions through clear signaling and measured
    responses to defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = self._calculate_current_stock(history)
        stock_health = current_stock / capacity
        if current_round == n_rounds - 1:
            return self._final_round_decision(history, stock_health)
        last_round_idx = current_round - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        cooperation_rate = cooperators_last_round / n_players
        if stock_health < 0.2:
            return Action.C
        if cooperation_rate >= 0.5 and stock_health >= 0.3:
            return Action.C
        if cooperation_rate < 0.5 and stock_health >= 0.3:
            if cooperation_rate >= 0.25:
                return Action.C
            else:
                return Action.D
        if self._is_stock_recovering(history) and stock_health > 0.5:
            return Action.C
        return Action.C

    def _calculate_current_stock(self, history):
        """Calculate current stock based on game history"""
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        current_stock = capacity
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0
            if my_action:
                total_consumption += current_stock / (2 * n_players)
            else:
                total_consumption += current_stock / n_players
            for opp_action in opponent_actions:
                if opp_action:
                    total_consumption += current_stock / (2 * n_players)
                else:
                    total_consumption += current_stock / n_players
            stock_after_consumption = max(0, current_stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            current_stock = min(stock_after_consumption + growth, capacity)
        return current_stock

    def _final_round_decision(self, history, stock_health):
        """Final round decision logic"""
        rounds_to_check = min(3, history.round_number)
        start_round = history.round_number - rounds_to_check
        total_cooperation = 0
        total_decisions = 0
        for round_idx in range(start_round, history.round_number):
            cooperators = sum(history.opponent_actions[round_idx])
            total_cooperation += cooperators
            total_decisions += self.game_description.n_players
        recent_cooperation_rate = total_cooperation / total_decisions if total_decisions > 0 else 0
        if recent_cooperation_rate >= 0.6:
            return Action.C
        if stock_health >= 0.7 and recent_cooperation_rate >= 0.3:
            return Action.C
        return Action.D

    def _is_stock_recovering(self, history):
        """Check if stock has been increasing for recent rounds"""
        if history.round_number < 2:
            return False
        stocks = []
        temp_stock = self.game_description.capacity
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        for round_idx in range(max(0, history.round_number - 2), history.round_number + 1):
            if round_idx == 0:
                stocks.append(temp_stock)
                continue
            prev_round_idx = round_idx - 1
            my_action = history.my_actions[prev_round_idx]
            opponent_actions = history.opponent_actions[prev_round_idx]
            total_consumption = 0
            if my_action:
                total_consumption += temp_stock / (2 * n_players)
            else:
                total_consumption += temp_stock / n_players
            for opp_action in opponent_actions:
                if opp_action:
                    total_consumption += temp_stock / (2 * n_players)
                else:
                    total_consumption += temp_stock / n_players
            stock_after_consumption = max(0, temp_stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            temp_stock = min(stock_after_consumption + growth, capacity)
            stocks.append(temp_stock)
        if len(stocks) >= 3:
            return stocks[-1] > stocks[-2] and stocks[-2] > stocks[-3]
        elif len(stocks) == 2:
            return stocks[-1] > stocks[-2]
        return False

class Strategy_COOPERATIVE_77(BaseStrategy):
    """
    Conditional Cooperation with Forgiveness Strategy.
    
    Establishes cooperative equilibrium through graduated responses and forgiveness.
    Always cooperates in round 1, then uses defection ratio thresholds to determine
    responses while maintaining resource awareness and reputation tracking.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        last_round_idx = history.round_number - 1
        my_last_payoff = history.my_payoffs[last_round_idx]
        my_last_action = history.my_actions[last_round_idx]
        if my_last_action:
            estimated_stock = my_last_payoff * 2 * n
        else:
            estimated_stock = my_last_payoff * n
        if current_round == r:
            total_cooperative_actions = 0
            total_actions = 0
            for round_idx in range(history.round_number):
                cooperators_this_round = sum(history.opponent_actions[round_idx])
                total_cooperative_actions += cooperators_this_round
                total_actions += len(history.opponent_actions[round_idx])
                if history.my_actions[round_idx]:
                    total_cooperative_actions += 1
                total_actions += 1
            overall_cooperation_rate = total_cooperative_actions / total_actions if total_actions > 0 else 0
            if overall_cooperation_rate >= 0.6:
                return Action.C
            elif estimated_stock < capacity * 0.2:
                return Action.D
            else:
                return Action.C
        if current_round >= 2:
            last_round_idx = history.round_number - 1
            defectors_last_round = sum((1 for action in history.opponent_actions[last_round_idx] if not action))
            defection_ratio = defectors_last_round / n
            if defection_ratio == 0:
                return Action.C
            elif defection_ratio <= 0.25:
                return Action.C
            elif defection_ratio <= 0.5:
                my_previous_action = history.my_actions[last_round_idx]
                if my_previous_action:
                    return Action.D
                else:
                    return Action.C
            elif estimated_stock < capacity * 0.3:
                return Action.D
            else:
                return Action.C
        return Action.C

class Strategy_COOPERATIVE_78(BaseStrategy):
    """
    Adaptive Cooperative Strategy with Trust-Based Defection.
    
    Prioritizes long-term sustainability through cooperation while maintaining
    the ability to respond to exploitation using a trust-based system.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.trust_scores = [1.0] * (game_description.n_players - 1)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        self._update_trust_scores(history)
        collective_trust = sum(self.trust_scores) / len(self.trust_scores)
        current_round = history.round_number + 1
        rounds_remaining = self.game_description.n_rounds - current_round + 1
        stock_health = self._estimate_stock_health(history)
        if stock_health < 0.2:
            if collective_trust > 0.7:
                return Action.C
            else:
                return Action.D
        if rounds_remaining == 1:
            return Action.D
        if rounds_remaining == 2:
            if collective_trust > 0.8 and stock_health > 0.4:
                return Action.C
            else:
                return Action.D
        if collective_trust >= 0.6:
            return Action.C
        else:
            return Action.D

    def _update_trust_scores(self, history: PlayerHistory):
        """Update trust scores based on opponents' actions in the most recent round."""
        if history.round_number == 0:
            return
        last_round_actions = history.opponent_actions[history.round_number - 1]
        for i, action in enumerate(last_round_actions):
            if action:
                self.trust_scores[i] = min(1.0, self.trust_scores[i] + 0.1)
            else:
                self.trust_scores[i] = max(0.0, self.trust_scores[i] - 0.3)

    def _estimate_stock_health(self, history: PlayerHistory) -> float:
        """
        Estimate current stock health based on consumption history.
        This is a simplified approximation since we don't have direct stock information.
        """
        if history.round_number == 0:
            return 1.0
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        total_defection_rounds = 0
        total_cooperation_rounds = 0
        for round_idx in range(history.round_number):
            if history.my_actions[round_idx]:
                total_cooperation_rounds += 1
            else:
                total_defection_rounds += 1
            opponent_defectors = sum(1 - history.opponent_actions[round_idx])
            opponent_cooperators = sum(history.opponent_actions[round_idx])
            total_defection_rounds += opponent_defectors
            total_cooperation_rounds += opponent_cooperators
        if total_defection_rounds + total_cooperation_rounds == 0:
            return 1.0
        defection_rate = total_defection_rounds / (total_defection_rounds + total_cooperation_rounds)
        estimated_health = max(0.1, 1.0 - defection_rate * history.round_number * 0.2)
        return min(1.0, estimated_health)

class Strategy_COOPERATIVE_79(BaseStrategy):
    """
    Guardian with Graduated Response strategy for Common Pool Resource Game.
    
    Prioritizes long-term sustainability while adapting to opponent behavior.
    Uses graduated response system with forgiveness mechanism.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defection_pressure = 0.0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.defection_pressure = 0.0
            return Action.C
        current_round = history.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        stock = self._calculate_current_stock(history)
        if current_round == r:
            return Action.C
        if stock < capacity / 4:
            return Action.C
        last_round_idx = history.round_number - 1
        last_round_actions = history.opponent_actions[last_round_idx]
        cooperators_last_round = sum(last_round_actions)
        if cooperators_last_round >= n / 2:
            return Action.C
        defectors_last_round = n - cooperators_last_round
        self.defection_pressure = self.defection_pressure * 0.8
        self.defection_pressure += defectors_last_round * 2 - cooperators_last_round * 1
        self.defection_pressure = max(0, self.defection_pressure)
        if self.defection_pressure < n:
            return Action.C
        else:
            return Action.D

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game history."""
        capacity = self.game_description.capacity
        n = self.game_description.n_players
        stock = float(capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0.0
            if my_action:
                total_consumption += stock / (2 * n)
            else:
                total_consumption += stock / n
            for opp_action in opponent_actions:
                if opp_action:
                    total_consumption += stock / (2 * n)
                else:
                    total_consumption += stock / n
            stock_after_consumption = max(0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            else:
                growth = 0
            stock = min(stock_after_consumption + growth, capacity)
        return stock

class Strategy_COOPERATIVE_80(BaseStrategy):
    """
    Adaptive Conditional Cooperator Strategy for Common Pool Resource Game.
    
    This strategy balances cooperation with self-protection by adapting to observed
    behavior patterns and resource sustainability. It starts cooperatively, monitors
    stock levels and cooperation rates, and adjusts behavior accordingly while
    implementing crisis prevention and endgame considerations.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round <= 2:
            return Action.C
        stock_level = self._calculate_current_stock(history)
        if current_round >= self.n_rounds - 1:
            return self._endgame_decision(history, stock_level, current_round)
        return self._main_strategy_decision(history, stock_level)

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate the current stock level based on game dynamics."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0.0
            if my_action:
                total_consumption += stock / (2 * self.n_players)
            else:
                total_consumption += stock / self.n_players
            for opp_action in opponent_actions:
                if opp_action:
                    total_consumption += stock / (2 * self.n_players)
                else:
                    total_consumption += stock / self.n_players
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _get_cooperation_ratio_last_round(self, history: PlayerHistory) -> float:
        """Get cooperation ratio in the most recent round."""
        if history.round_number == 0:
            return 1.0
        last_round_idx = history.round_number - 1
        cooperators = sum(history.opponent_actions[last_round_idx]) + (1 if history.my_actions[last_round_idx] else 0)
        return cooperators / self.n_players

    def _get_cooperation_ratio_recent(self, history: PlayerHistory, window: int=3) -> float:
        """Get average cooperation ratio over recent rounds."""
        if history.round_number == 0:
            return 1.0
        start_idx = max(0, history.round_number - window)
        total_cooperators = 0
        total_decisions = 0
        for round_idx in range(start_idx, history.round_number):
            cooperators = sum(history.opponent_actions[round_idx]) + (1 if history.my_actions[round_idx] else 0)
            total_cooperators += cooperators
            total_decisions += self.n_players
        return total_cooperators / total_decisions if total_decisions > 0 else 1.0

    def _is_cooperation_trend_improving(self, history: PlayerHistory) -> bool:
        """Check if cooperation trend is improving."""
        if history.round_number < 6:
            return True
        recent_ratio = self._get_cooperation_ratio_recent(history, 3)
        start_idx = max(0, history.round_number - 6)
        end_idx = max(0, history.round_number - 3)
        if start_idx >= end_idx:
            return True
        total_cooperators = 0
        total_decisions = 0
        for round_idx in range(start_idx, end_idx):
            cooperators = sum(history.opponent_actions[round_idx]) + (1 if history.my_actions[round_idx] else 0)
            total_cooperators += cooperators
            total_decisions += self.n_players
        previous_ratio = total_cooperators / total_decisions if total_decisions > 0 else 0
        return recent_ratio > previous_ratio

    def _stock_recovered_significantly(self, history: PlayerHistory, current_stock: float) -> bool:
        """Check if stock has recovered significantly."""
        if history.round_number < 2:
            return False
        previous_stock = self._calculate_stock_at_round(history, history.round_number - 2)
        return current_stock > previous_stock * 1.2

    def _calculate_stock_at_round(self, history: PlayerHistory, target_round: int) -> float:
        """Calculate stock level at a specific round."""
        stock = float(self.capacity)
        for round_idx in range(min(target_round, history.round_number)):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0.0
            if my_action:
                total_consumption += stock / (2 * self.n_players)
            else:
                total_consumption += stock / self.n_players
            for opp_action in opponent_actions:
                if opp_action:
                    total_consumption += stock / (2 * self.n_players)
                else:
                    total_consumption += stock / self.n_players
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _main_strategy_decision(self, history: PlayerHistory, stock_level: float) -> Action:
        """Main strategy decision logic for rounds 3 to n_rounds-2."""
        cooperation_ratio_last = self._get_cooperation_ratio_last_round(history)
        if stock_level < self.capacity * 0.3:
            return Action.C
        if cooperation_ratio_last >= 0.6:
            return Action.C
        if cooperation_ratio_last >= 0.4:
            if self._is_cooperation_trend_improving(history):
                return Action.C
            else:
                return Action.D
        my_last_action = history.my_actions[-1] if history.round_number > 0 else True
        if not my_last_action and self._stock_recovered_significantly(history, stock_level):
            return Action.C
        else:
            return Action.D

    def _endgame_decision(self, history: PlayerHistory, stock_level: float, current_round: int) -> Action:
        """Handle endgame decisions for the last 2 rounds."""
        cooperation_ratio_recent = self._get_cooperation_ratio_recent(history)
        if current_round == self.n_rounds - 1:
            if stock_level >= self.capacity * 0.5 and cooperation_ratio_recent >= 0.5:
                return Action.C
            else:
                return Action.D
        elif stock_level >= self.capacity * 0.7 and cooperation_ratio_recent >= 0.7:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_81(BaseStrategy):
    """
    Sustainable Tit-for-Tat with Forgiveness: A cooperative strategy that starts cooperatively,
    tracks collective behavior, includes forgiveness mechanisms, and prioritizes resource sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5
        self.forgiveness_frequency = 3
        self.stock_crisis_threshold = game_description.capacity * 0.2
        self.stock_caution_threshold = game_description.capacity * 0.4

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.C
        current_stock = self._calculate_current_stock(history)
        if current_stock < self.stock_crisis_threshold:
            return Action.C
        if current_round % self.forgiveness_frequency == 0:
            return Action.C
        previous_round_index = history.round_number - 1
        previous_cooperators = np.sum(history.opponent_actions[previous_round_index])
        if history.my_actions[previous_round_index]:
            previous_cooperators += 1
        cooperation_rate = previous_cooperators / self.game_description.n_players
        if cooperation_rate > self.cooperation_threshold:
            return Action.C
        elif current_stock < self.stock_caution_threshold:
            return Action.C
        else:
            return Action.D

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate the current stock level based on game dynamics."""
        stock = float(self.game_description.capacity)
        for round_idx in range(history.round_number):
            total_consumption = 0.0
            if history.my_actions[round_idx]:
                total_consumption += stock / (2 * self.game_description.n_players)
            else:
                total_consumption += stock / self.game_description.n_players
            for opponent_idx in range(len(history.opponent_actions[round_idx])):
                if history.opponent_actions[round_idx, opponent_idx]:
                    total_consumption += stock / (2 * self.game_description.n_players)
                else:
                    total_consumption += stock / self.game_description.n_players
            stock_after_consumption = max(0.0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.game_description.capacity)
                stock = min(stock_after_consumption + growth, self.game_description.capacity)
            else:
                stock = 0.0
        return stock

class Strategy_COOPERATIVE_82(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Shepherd"
    
    Prioritizes long-term sustainability while being responsive to cooperative behavior.
    Uses conditional cooperation with sustainability thresholds and graduated responses.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        current_stock = self._calculate_current_stock(history)
        if current_stock < self.capacity * 0.3:
            return Action.C
        if current_round == self.n_rounds:
            if current_stock >= self.capacity * 0.5:
                return Action.C
            else:
                last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
                if history.my_actions[history.round_number - 1]:
                    last_round_cooperators += 1
                return Action.C if last_round_cooperators > self.n_players / 2 else Action.D
        if current_round == 2:
            round1_cooperators = sum(history.opponent_actions[0]) + (1 if history.my_actions[0] else 0)
            return Action.C if round1_cooperators / self.n_players > 0.4 else Action.D
        if current_round == 3:
            recent_coop_rate = self._get_recent_cooperation_rate(history, 2)
            return Action.C if recent_coop_rate >= 0.3 else Action.D
        return self._adaptive_cooperation_rule(history, current_stock)

    def _calculate_current_stock(self, history):
        """Calculate current stock based on game dynamics"""
        stock = self.capacity
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            my_consumption = stock / (2 * self.n_players) if my_action else stock / self.n_players
            opponent_consumption = 0
            for opp_action in opponent_actions:
                if opp_action:
                    opponent_consumption += stock / (2 * self.n_players)
                else:
                    opponent_consumption += stock / self.n_players
            total_consumption = my_consumption + opponent_consumption
            stock_after_consumption = stock - total_consumption
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
                stock = min(stock_after_consumption + growth, self.capacity)
            else:
                stock = 0
        return stock

    def _get_recent_cooperation_rate(self, history, n_rounds):
        """Calculate cooperation rate in the last n rounds"""
        rounds_to_check = min(n_rounds, history.round_number)
        total_actions = 0
        total_cooperations = 0
        for i in range(rounds_to_check):
            round_idx = history.round_number - 1 - i
            total_actions += 1
            if history.my_actions[round_idx]:
                total_cooperations += 1
            for opp_action in history.opponent_actions[round_idx]:
                total_actions += 1
                if opp_action:
                    total_cooperations += 1
        return total_cooperations / total_actions if total_actions > 0 else 0

    def _get_stock_trend(self, history, current_stock):
        """Calculate stock trend over last few rounds"""
        if history.round_number < 2:
            return 0
        stock_two_rounds_ago = self.capacity
        rounds_to_calc = min(history.round_number - 2, history.round_number)
        for round_idx in range(rounds_to_calc):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            my_consumption = stock_two_rounds_ago / (2 * self.n_players) if my_action else stock_two_rounds_ago / self.n_players
            opponent_consumption = sum((stock_two_rounds_ago / (2 * self.n_players) if opp else stock_two_rounds_ago / self.n_players for opp in opponent_actions))
            total_consumption = my_consumption + opponent_consumption
            stock_after_consumption = stock_two_rounds_ago - total_consumption
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
                stock_two_rounds_ago = min(stock_after_consumption + growth, self.capacity)
            else:
                stock_two_rounds_ago = 0
        return (current_stock - stock_two_rounds_ago) / self.capacity

    def _adaptive_cooperation_rule(self, history, current_stock):
        """Main adaptive cooperation decision logic"""
        recent_rounds = min(3, history.round_number)
        recent_coop_rate = self._get_recent_cooperation_rate(history, recent_rounds)
        stock_trend = self._get_stock_trend(history, current_stock)
        base_threshold = 0.4
        if current_stock < self.capacity * 0.5:
            threshold = base_threshold - 0.2
        elif stock_trend < -0.1:
            threshold = base_threshold - 0.1
        elif current_stock > self.capacity * 0.8 and stock_trend > 0:
            threshold = base_threshold + 0.1
        else:
            threshold = base_threshold
        if recent_coop_rate >= threshold:
            return Action.C
        else:
            defection_rate = 1 - recent_coop_rate
            if defection_rate > 0.7:
                return Action.D
            else:
                return self._tit_for_tat_with_forgiveness(history)

    def _tit_for_tat_with_forgiveness(self, history):
        """Tit-for-tat with periodic forgiveness"""
        last_round_idx = history.round_number - 1
        last_round_cooperators = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            last_round_cooperators += 1
        last_round_coop_rate = last_round_cooperators / self.n_players
        if last_round_coop_rate < 0.5:
            if (history.round_number + 1) % 4 == 0:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_83(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Forgiveness (ATTF) Strategy.
    
    Establishes cooperation while defending against exploitation through:
    - Cooperative start and conditional cooperation based on group behavior
    - Dynamic thresholds considering stock health and cooperation ratios
    - Forgiveness mechanism to recover from mutual defection spirals
    - Strategic defection in final round and emergency situations
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_cooperation_attempt = -1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.last_cooperation_attempt = 0
            return Action.C
        current_round = history.round_number
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = self._estimate_current_stock(history)
        stock_health = current_stock / capacity
        if current_round == n_rounds - 1:
            return Action.D
        if stock_health < 0.2:
            return Action.D
        last_round_actions = history.opponent_actions[current_round - 1]
        cooperators_last_round = sum(last_round_actions)
        cooperation_ratio = cooperators_last_round / n_players
        rounds_since_last_cooperation = current_round - self.last_cooperation_attempt
        if rounds_since_last_cooperation >= 3 and current_round <= n_rounds - 2:
            self.last_cooperation_attempt = current_round
            return Action.C
        if cooperation_ratio >= 0.5 and stock_health > 0.3:
            self.last_cooperation_attempt = current_round
            return Action.C
        elif cooperation_ratio >= 0.3 and stock_health > 0.5:
            self.last_cooperation_attempt = current_round
            return Action.C
        elif stock_health < 0.3 and cooperation_ratio < 0.5:
            return Action.D
        else:
            return Action.D

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level from historical payoffs."""
        estimated_stock = self.game_description.capacity
        n_players = self.game_description.n_players
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            if my_action:
                my_consumption = estimated_stock / (2 * n_players)
            else:
                my_consumption = estimated_stock / n_players
            opponent_consumption = 0
            for opp_action in opponent_actions:
                if opp_action:
                    opponent_consumption += estimated_stock / (2 * n_players)
                else:
                    opponent_consumption += estimated_stock / n_players
            total_consumption = my_consumption + opponent_consumption
            stock_after_consumption = max(0, estimated_stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.game_description.capacity)
            estimated_stock = min(stock_after_consumption + growth, self.game_description.capacity)
        return estimated_stock

class Strategy_COOPERATIVE_84(BaseStrategy):
    """
    Adaptive Conditional Cooperator (ACC) strategy that balances cooperation with sustainability.
    Starts cooperative, monitors stock health and cooperation rates, adapts to opponent behavior
    while prioritizing long-term resource sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n = self.game_description.n_players
        final_round = self.game_description.n_rounds
        if current_round == final_round:
            return self._handle_final_round(history)
        last_round_idx = history.round_number - 1
        cooperation_rate = np.sum(history.opponent_actions[last_round_idx]) / (n - 1)
        my_last_action = history.my_actions[last_round_idx]
        overall_cooperation_rate = (np.sum(history.opponent_actions[last_round_idx]) + my_last_action) / n
        my_cooperation_rate = np.mean(history.my_actions)
        stock_health = self._estimate_stock_health(history)
        if stock_health < 0.3:
            if overall_cooperation_rate >= 0.7:
                return Action.C
            else:
                return Action.D
        if overall_cooperation_rate >= 0.6:
            return Action.C
        if overall_cooperation_rate >= 0.4:
            if my_cooperation_rate >= 0.6:
                return Action.C
            else:
                return self._tit_for_majority(history)
        if overall_cooperation_rate < 0.4:
            if stock_health > 0.7 and my_cooperation_rate >= 0.8:
                return Action.C
            else:
                return Action.D

    def _handle_final_round(self, history: PlayerHistory) -> Action:
        """Handle the final round strategically."""
        n = self.game_description.n_players
        rounds_to_check = min(3, history.round_number)
        start_idx = history.round_number - rounds_to_check
        recent_cooperation_rates = []
        for i in range(start_idx, history.round_number):
            round_cooperation = (np.sum(history.opponent_actions[i]) + history.my_actions[i]) / n
            recent_cooperation_rates.append(round_cooperation)
        avg_recent_cooperation = np.mean(recent_cooperation_rates)
        if avg_recent_cooperation >= 0.6:
            return Action.C
        else:
            return Action.D

    def _tit_for_majority(self, history: PlayerHistory) -> Action:
        """Follow the majority trend from the last round."""
        last_round_idx = history.round_number - 1
        n = self.game_description.n_players
        total_cooperators = np.sum(history.opponent_actions[last_round_idx]) + history.my_actions[last_round_idx]
        if total_cooperators >= n / 2:
            return Action.C
        else:
            return Action.D

    def _estimate_stock_health(self, history: PlayerHistory) -> float:
        """Estimate current stock health based on recent payoffs."""
        if history.round_number == 0:
            return 1.0
        last_payoff = history.my_payoffs[-1]
        last_action = history.my_actions[-1]
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        if last_action:
            estimated_stock = last_payoff * 2 * n
        else:
            estimated_stock = last_payoff * n
        stock_health = estimated_stock / capacity
        return max(0.0, min(1.0, stock_health))

class Strategy_COOPERATIVE_85(BaseStrategy):
    """
    Adaptive Cooperative Resource Management Strategy (ACRMS)
    
    Prioritizes long-term sustainability while adapting to opponents' behavior.
    Begins cooperatively but includes mechanisms to prevent exploitation and 
    encourage collective cooperation through graduated responses and stock health monitoring.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_num = history.round_number + 1
        if round_num <= 2:
            return Action.C
        total_c_actions = np.sum(history.my_actions) + np.sum(history.opponent_actions)
        total_actions = self.n * (round_num - 1)
        cooperation_ratio = total_c_actions / total_actions
        stock_health = self._estimate_stock_health(history)
        if round_num >= self.r - 1:
            return self._endgame_strategy(round_num, cooperation_ratio, stock_health)
        return self._adaptive_cooperation(history, cooperation_ratio, stock_health, round_num)

    def _estimate_stock_health(self, history):
        """Estimate current stock level as fraction of capacity"""
        rounds_completed = history.round_number
        total_consumption_factor = 0
        for r in range(rounds_completed):
            my_action = history.my_actions[r]
            opponent_actions = history.opponent_actions[r]
            c_count = int(my_action) + np.sum(opponent_actions)
            d_count = self.n - c_count
            round_consumption_factor = c_count * (1 / (2 * self.n)) + d_count * (1 / self.n)
            total_consumption_factor += round_consumption_factor
        avg_consumption_factor = total_consumption_factor / rounds_completed if rounds_completed > 0 else 0.5
        if avg_consumption_factor > 0.6:
            estimated_health = max(0.1, 1.0 - rounds_completed * 0.15)
        elif avg_consumption_factor > 0.4:
            estimated_health = max(0.2, 1.0 - rounds_completed * 0.08)
        else:
            estimated_health = max(0.4, 1.0 - rounds_completed * 0.03)
        return estimated_health

    def _adaptive_cooperation(self, history, cooperation_ratio, stock_health, round_num):
        """Main adaptive cooperation logic"""
        if stock_health < 0.3:
            if cooperation_ratio < 0.5:
                return Action.D
            else:
                return Action.C
        if cooperation_ratio >= 0.6:
            return Action.C
        if cooperation_ratio >= 0.4:
            recent_cooperation = self._count_recent_cooperation(history, 2)
            if recent_cooperation >= 0.5:
                return Action.C
            else:
                return Action.D if random.random() < 0.7 else Action.C
        else:
            my_exploitation_check = self._check_exploitation(history)
            if my_exploitation_check:
                return Action.D
            else:
                return Action.C

    def _count_recent_cooperation(self, history, window):
        """Count cooperation ratio in last 'window' rounds"""
        rounds_completed = history.round_number
        start_round = max(0, rounds_completed - window)
        if start_round >= rounds_completed:
            return 0.5
        recent_my_actions = history.my_actions[start_round:]
        recent_opponent_actions = history.opponent_actions[start_round:]
        total_c = np.sum(recent_my_actions) + np.sum(recent_opponent_actions)
        total_actions = len(recent_my_actions) * self.n
        return total_c / total_actions if total_actions > 0 else 0.5

    def _check_exploitation(self, history):
        """Check if this player is being systematically exploited"""
        rounds_completed = history.round_number
        if rounds_completed < 3:
            return False
        window = min(3, rounds_completed)
        start_round = rounds_completed - window
        my_recent_payoffs = np.sum(history.my_payoffs[start_round:])
        all_recent_payoffs = my_recent_payoffs + np.sum(history.opponent_payoffs[start_round:])
        avg_recent_payoffs = all_recent_payoffs / (self.n * window)
        return my_recent_payoffs < 0.8 * avg_recent_payoffs

    def _endgame_strategy(self, round_num, cooperation_ratio, stock_health):
        """Strategy for the last 2 rounds"""
        if round_num == self.r - 1:
            if stock_health > 0.4 and cooperation_ratio > 0.5:
                return Action.C
            else:
                return Action.D
        if round_num == self.r:
            if stock_health > 0.2:
                if cooperation_ratio > 0.7:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
        return Action.C

class Strategy_COOPERATIVE_86(BaseStrategy):
    """
    Conditional Cooperation with Forgiveness Strategy for Common Pool Resource Game.
    
    This strategy balances cooperative ideals with practical considerations for sustainability
    and resilience against exploitation. It uses threshold-based cooperation rates and 
    resource health monitoring to make decisions, while incorporating forgiveness mechanisms
    to prevent spirals into mutual defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_number = history.round_number + 1
        n = self.game_description.n_players
        if round_number == self.game_description.n_rounds:
            last_round_coop_count = sum(history.opponent_actions[history.round_number - 1])
            cooperation_rate_last_round = last_round_coop_count / n
            if cooperation_rate_last_round >= 0.5:
                return Action.C
            else:
                return Action.D
        if history.round_number > 0:
            last_round_payoffs = history.opponent_payoffs[history.round_number - 1]
            my_last_payoff = history.my_payoffs[history.round_number - 1]
            if history.my_actions[history.round_number - 1]:
                estimated_stock = my_last_payoff * 2 * n
            else:
                estimated_stock = my_last_payoff * n
            current_stock_ratio = estimated_stock / self.game_description.capacity
        else:
            current_stock_ratio = 1.0
        last_round_coop_count = sum(history.opponent_actions[history.round_number - 1])
        cooperation_rate = last_round_coop_count / n
        if current_stock_ratio < 0.3:
            return Action.C
        if cooperation_rate >= 0.6:
            return Action.C
        elif cooperation_rate >= 0.4:
            if current_stock_ratio > 0.7:
                return Action.C
            else:
                return Action.D
        elif self._recent_improvement(history, n):
            return Action.C
        else:
            return Action.D

    def _recent_improvement(self, history: PlayerHistory, n: int) -> bool:
        """Check if cooperation rate is improving in recent rounds."""
        if history.round_number < 2:
            return False
        last_round_coop = sum(history.opponent_actions[history.round_number - 1]) / n
        two_rounds_ago_coop = sum(history.opponent_actions[history.round_number - 2]) / n
        return last_round_coop > two_rounds_ago_coop

class Strategy_COOPERATIVE_87(BaseStrategy):
    """
    Sustainable Guardian: A cooperative strategy that prioritizes long-term sustainability
    while being forgiving to occasional defections. Uses stock-based thresholds and
    graduated responses to balance cooperation with exploitation protection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_stock = self._estimate_current_stock(history)
        stock_percentage = current_stock / self.game_description.capacity
        last_round_idx = history.round_number - 1
        last_opponent_actions = history.opponent_actions[last_round_idx]
        defector_count = sum(last_opponent_actions == False)
        total_players = self.game_description.n_players
        defection_rate = defector_count / total_players
        if stock_percentage >= 0.5:
            return Action.C
        if stock_percentage <= 0.1:
            if defection_rate <= 0.5:
                return Action.C
            else:
                return Action.D
        if defection_rate <= 0.5:
            return Action.C
        elif defection_rate <= 0.75:
            return Action.C if random.random() < 0.7 else Action.D
        else:
            return Action.D

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """
        Estimate current stock level based on history of actions and payoffs.
        Uses the relationship between payoffs and stock to reverse-engineer stock levels.
        """
        if history.round_number == 0:
            return self.game_description.capacity
        last_payoff = history.my_payoffs[history.round_number - 1]
        last_my_action = history.my_actions[history.round_number - 1]
        n = self.game_description.n_players
        if last_my_action:
            estimated_last_stock = last_payoff * 2 * n
        else:
            estimated_last_stock = last_payoff * n
        last_round_idx = history.round_number - 1
        last_opponent_actions = history.opponent_actions[last_round_idx]
        last_my_action = history.my_actions[last_round_idx]
        total_consumption = 0
        if last_my_action:
            total_consumption += estimated_last_stock / (2 * n)
        else:
            total_consumption += estimated_last_stock / n
        for opponent_action in last_opponent_actions:
            if opponent_action:
                total_consumption += estimated_last_stock / (2 * n)
            else:
                total_consumption += estimated_last_stock / n
        stock_after_consumption = max(0, estimated_last_stock - total_consumption)
        growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.game_description.capacity)
        new_stock = min(stock_after_consumption + growth, self.game_description.capacity)
        return max(0, new_stock)

class Strategy_COOPERATIVE_88(BaseStrategy):
    """
    Guardian strategy: Conditional cooperative approach that prioritizes sustainability
    while reciprocating cooperation and defending against exploitation with graduated responses.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punished_last_round = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        current_stock = self._estimate_current_stock(history)
        if current_round == self.game_description.n_rounds:
            if current_stock < capacity * 0.2:
                return Action.C
            elif self._all_players_mostly_cooperative(history):
                return Action.C
            else:
                return Action.D
        if current_stock < capacity * 0.3:
            return Action.C
        last_round_actions = history.opponent_actions[history.round_number - 1]
        cooperators_last_round = sum(last_round_actions)
        defectors_last_round = n - 1 - cooperators_last_round
        if current_stock < capacity * 0.6:
            if cooperators_last_round > (n - 1) / 2:
                return Action.C
            else:
                return Action.D
        if defectors_last_round <= 1:
            self.punished_last_round = False
            return Action.C
        elif defectors_last_round == 2:
            if self.punished_last_round:
                self.punished_last_round = False
                return Action.C
            else:
                self.punished_last_round = True
                return Action.D
        else:
            self.punished_last_round = False
            return Action.D

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock based on game history"""
        stock = float(self.game_description.capacity)
        n = self.game_description.n_players
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0.0
            if my_action:
                total_consumption += stock / (2 * n)
            else:
                total_consumption += stock / n
            for opp_action in opponent_actions:
                if opp_action:
                    total_consumption += stock / (2 * n)
                else:
                    total_consumption += stock / n
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.game_description.capacity)
            stock = min(stock_after_consumption + growth, self.game_description.capacity)
        return stock

    def _all_players_mostly_cooperative(self, history: PlayerHistory) -> bool:
        """Check if all players have been mostly cooperative (>60% cooperation rate)"""
        n_rounds = history.round_number
        my_cooperations = sum(history.my_actions)
        if my_cooperations / n_rounds < 0.6:
            return False
        for player_idx in range(self.game_description.n_players - 1):
            player_cooperations = sum(history.opponent_actions[:, player_idx])
            if player_cooperations / n_rounds < 0.6:
                return False
        return True

class Strategy_COOPERATIVE_89(BaseStrategy):
    """
    Adaptive Guardian: A cooperative strategy that prioritizes long-term sustainability
    of the common pool while being responsive to opponent behavior through conditional
    reciprocity and strategic forgiveness.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_threshold = game_description.capacity * 0.3
        self.cooperation_threshold = 0.6
        self.forgiveness_probability = 0.2

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        current_stock = self._estimate_current_stock(history)
        if current_round == self.game_description.n_rounds:
            return self._handle_final_round(history, current_stock)
        if current_stock < self.critical_threshold:
            return Action.C
        lookback_window = min(3, history.round_number)
        cooperation_score = self._calculate_cooperation_score(history, lookback_window)
        if cooperation_score >= self.cooperation_threshold:
            return Action.C
        else:
            return self._conditional_defect(cooperation_score, current_stock)

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock based on game dynamics"""
        stock = self.game_description.capacity
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        for round_idx in range(history.round_number):
            my_consumption = stock / (2 * n) if history.my_actions[round_idx] else stock / n
            opponent_consumption = 0
            for opponent_idx in range(n - 1):
                if history.opponent_actions[round_idx, opponent_idx]:
                    opponent_consumption += stock / (2 * n)
                else:
                    opponent_consumption += stock / n
            total_consumption = my_consumption + opponent_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            else:
                growth = 0
            stock = min(stock_after_consumption + growth, capacity)
        return stock

    def _calculate_cooperation_score(self, history: PlayerHistory, window: int) -> float:
        """Calculate the proportion of cooperative actions in recent history"""
        if window == 0:
            return 1.0
        start_round = max(0, history.round_number - window)
        total_actions = 0
        cooperative_actions = 0
        for round_idx in range(start_round, history.round_number):
            for opponent_idx in range(self.game_description.n_players - 1):
                total_actions += 1
                if history.opponent_actions[round_idx, opponent_idx]:
                    cooperative_actions += 1
        return cooperative_actions / total_actions if total_actions > 0 else 1.0

    def _conditional_defect(self, cooperation_score: float, stock: float) -> Action:
        """Decide whether to defect based on cooperation score and stock level"""
        if cooperation_score >= 0.4:
            if random.random() < self.forgiveness_probability:
                return Action.C
            else:
                return Action.D
        elif stock > self.game_description.capacity * 0.6:
            return Action.D
        else:
            return Action.C

    def _handle_final_round(self, history: PlayerHistory, stock: float) -> Action:
        """Special logic for the final round"""
        overall_cooperation = self._calculate_cooperation_score(history, history.round_number)
        if overall_cooperation >= 0.5:
            return Action.C
        elif stock > self.game_description.capacity * 0.4:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_90(BaseStrategy):
    """
    Sustainable Harvest with Forgiveness: A cooperative strategy that prioritizes 
    long-term sustainability while adapting to opponent behavior with graduated 
    responses and forgiveness mechanisms.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        last_round_idx = history.round_number - 1
        my_last_payoff = history.my_payoffs[last_round_idx]
        my_last_action = history.my_actions[last_round_idx]
        if my_last_action:
            estimated_stock = my_last_payoff * 2 * n_players
        else:
            estimated_stock = my_last_payoff * n_players
        if estimated_stock <= capacity * 0.2:
            return self._emergency_mode(history)
        if current_round == self.game_description.n_rounds:
            return self._final_round_logic(history, estimated_stock)
        return self._normal_mode(history)

    def _calculate_recent_defection_rate(self, history: PlayerHistory, window: int=3) -> float:
        """Calculate defection rate of opponents in recent rounds."""
        start_round = max(0, history.round_number - window)
        recent_actions = history.opponent_actions[start_round:history.round_number]
        if len(recent_actions) == 0:
            return 0.0
        total_actions = recent_actions.size
        defections = np.sum(~recent_actions)
        return defections / total_actions

    def _my_cooperation_rate(self, history: PlayerHistory, window: int=5) -> float:
        """Calculate my own cooperation rate in recent rounds."""
        start_round = max(0, history.round_number - window)
        recent_actions = history.my_actions[start_round:history.round_number]
        if len(recent_actions) == 0:
            return 1.0
        return np.mean(recent_actions)

    def _last_round_defection_rate(self, history: PlayerHistory) -> float:
        """Calculate defection rate of opponents in the last round."""
        if history.round_number == 0:
            return 0.0
        last_round_actions = history.opponent_actions[history.round_number - 1]
        return np.mean(~last_round_actions)

    def _calculate_overall_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate overall cooperation rate of opponents across all rounds."""
        if history.round_number == 0:
            return 0.5
        all_actions = history.opponent_actions[:history.round_number]
        return np.mean(all_actions)

    def _normal_mode(self, history: PlayerHistory) -> Action:
        """Normal mode decision logic."""
        recent_defection_rate = self._calculate_recent_defection_rate(history, window=3)
        my_recent_cooperation_rate = self._my_cooperation_rate(history, window=5)
        if recent_defection_rate <= 0.3:
            return Action.C
        if recent_defection_rate > 0.7:
            if random.random() < 0.8:
                return Action.D
            else:
                return Action.C
        if my_recent_cooperation_rate >= 0.6:
            if random.random() < 0.7:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C

    def _emergency_mode(self, history: PlayerHistory) -> Action:
        """Emergency mode when stock is critically low."""
        defection_rate_last_round = self._last_round_defection_rate(history)
        if defection_rate_last_round > 0.5:
            if random.random() < 0.6:
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

    def _final_round_logic(self, history: PlayerHistory, estimated_stock: float) -> Action:
        """Final round decision logic."""
        overall_cooperation_rate = self._calculate_overall_cooperation_rate(history)
        capacity = self.game_description.capacity
        if estimated_stock >= capacity * 0.5:
            if overall_cooperation_rate >= 0.5:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_91(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Commons Guardian"
    
    Prioritizes long-term sustainability while being responsive to group behavior patterns.
    Starts cooperative and adapts based on collective actions, always seeking to maintain
    the commons while protecting against exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_num = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        current_stock = self._calculate_current_stock(history)
        self.stock_history.append(current_stock)
        last_round_actions = history.opponent_actions[history.round_number - 1]
        my_last_action = history.my_actions[history.round_number - 1]
        opponent_cooperators = sum(last_round_actions)
        total_cooperators = opponent_cooperators + (1 if my_last_action else 0)
        cooperation_rate = total_cooperators / n_players
        stock_health = current_stock / capacity
        if stock_health <= 0.15:
            return Action.D
        if stock_health >= 0.9:
            return Action.C
        if round_num == total_rounds:
            return Action.C if stock_health >= 0.4 else Action.D
        if len(self.stock_history) >= 2:
            if self._is_growing_trend() and cooperation_rate >= 0.4:
                return Action.C
        if cooperation_rate >= 0.5 and stock_health >= 0.3:
            return Action.C
        elif cooperation_rate >= 0.3 and stock_health >= 0.5:
            return Action.C
        elif stock_health <= 0.2:
            return Action.D
        else:
            return Action.D

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock based on game dynamics from history."""
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        current_stock = float(capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            my_consumption = current_stock / (2 * n_players) if my_action else current_stock / n_players
            opponent_consumption = 0.0
            for opp_action in opponent_actions:
                if opp_action:
                    opponent_consumption += current_stock / (2 * n_players)
                else:
                    opponent_consumption += current_stock / n_players
            total_consumption = my_consumption + opponent_consumption
            stock_after_consumption = max(0.0, current_stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            current_stock = min(stock_after_consumption + growth, capacity)
        return current_stock

    def _is_growing_trend(self) -> bool:
        """Check if stock has been growing in recent rounds."""
        if len(self.stock_history) < 2:
            return False
        return self.stock_history[-1] > self.stock_history[-2]

class Strategy_COOPERATIVE_92(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Steward"
    
    Prioritizes long-term sustainability while being responsive to group behavior.
    Starts cooperatively and adapts based on observed patterns, with built-in 
    mechanisms to recover cooperation even after periods of defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_num = history.round_number + 1
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        last_round_idx = history.round_number - 1
        my_last_payoff = history.my_payoffs[last_round_idx]
        if history.my_actions[last_round_idx]:
            estimated_stock = my_last_payoff * 2 * n_players
        else:
            estimated_stock = my_last_payoff * n_players
        stock_health = estimated_stock / capacity
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            cooperators_last_round += 1
        cooperation_rate = cooperators_last_round / n_players
        total_cooperation = sum((sum(round_actions) for round_actions in history.opponent_actions))
        total_cooperation += sum(history.my_actions)
        total_possible = history.round_number * n_players
        cooperation_rate_overall = total_cooperation / total_possible
        if round_num <= 2:
            return Action.C
        if round_num == n_rounds:
            if cooperation_rate_overall >= 0.6:
                return Action.C
            else:
                return Action.D
        if round_num == n_rounds - 1:
            if cooperation_rate >= 0.5:
                return Action.C
            else:
                return Action.D
        if stock_health < 0.3:
            return Action.C
        if cooperation_rate >= 0.6:
            return Action.C
        if cooperation_rate >= 0.4:
            if stock_health >= 0.7:
                return Action.C
            else:
                prob_cooperate = min(stock_health + 0.3, 1.0)
                if random.random() < prob_cooperate:
                    return Action.C
                else:
                    return Action.D
        if cooperation_rate >= 0.2:
            if stock_health >= 0.8:
                return Action.C
            else:
                return Action.D
        elif stock_health >= 0.9:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_93(BaseStrategy):
    """
    Adaptive Trust Builder - A cooperative strategy that builds trust while adapting to
    resource sustainability and group cooperation levels. Prioritizes long-term sustainability
    through clear signaling, forgiveness mechanisms, and proportional responses.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.sustainability_threshold = self.capacity * 0.3
        self.crisis_threshold = self.capacity * 0.15
        self.minimum_trust_threshold = 0.4

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        stock_level = self._estimate_current_stock(history)
        if current_round == self.n_rounds:
            recent_coop_rate = self._calculate_cooperation_rate(history, 3)
            if recent_coop_rate >= 0.5:
                return Action.C
            else:
                return Action.D
        if stock_level < self.crisis_threshold:
            return Action.D
        recent_coop_rate = self._calculate_cooperation_rate(history, 5)
        my_recent_defections = self._count_my_recent_defections(history, 3)
        if my_recent_defections >= 2 and recent_coop_rate > 0.3:
            return Action.C
        if stock_level >= self.sustainability_threshold:
            if recent_coop_rate >= 0.4:
                return Action.C
            elif recent_coop_rate >= 0.2:
                return Action.C if random.random() < 0.7 else Action.D
            else:
                return Action.D
        elif recent_coop_rate >= 0.6:
            return Action.C
        else:
            return Action.D

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game history"""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            if my_action:
                my_consumption = stock / (2 * self.n_players)
            else:
                my_consumption = stock / self.n_players
            opponent_consumption = 0
            for opp_action in opponent_actions:
                if opp_action:
                    opponent_consumption += stock / (2 * self.n_players)
                else:
                    opponent_consumption += stock / self.n_players
            total_consumption = my_consumption + opponent_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _calculate_cooperation_rate(self, history: PlayerHistory, lookback_rounds: int) -> float:
        """Calculate cooperation rate over recent rounds"""
        if history.round_number == 0:
            return 1.0
        start_round = max(0, history.round_number - lookback_rounds)
        total_players = 0
        total_cooperators = 0
        for round_idx in range(start_round, history.round_number):
            if history.my_actions[round_idx]:
                total_cooperators += 1
            total_players += 1
            for opp_action in history.opponent_actions[round_idx]:
                if opp_action:
                    total_cooperators += 1
                total_players += 1
        if total_players == 0:
            return 1.0
        return total_cooperators / total_players

    def _count_my_recent_defections(self, history: PlayerHistory, lookback_rounds: int) -> int:
        """Count my defections in recent rounds"""
        if history.round_number == 0:
            return 0
        start_round = max(0, history.round_number - lookback_rounds)
        defection_count = 0
        for round_idx in range(start_round, history.round_number):
            if not history.my_actions[round_idx]:
                defection_count += 1
        return defection_count

class Strategy_COOPERATIVE_94(BaseStrategy):
    """
    Conditional Cooperator with Forgiveness Strategy
    
    A three-phase strategy that balances cooperation establishment, adaptive response
    to opponent behavior, and resource preservation. Aims for long-term sustainability
    while protecting against exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_number = history.round_number + 1
        current_stock = self._calculate_current_stock(history)
        stock_ratio = current_stock / self.capacity
        if stock_ratio < 0.25:
            return Action.D
        phase = self._determine_phase(round_number)
        cooperation_ratio = self._calculate_cooperation_ratio(history)
        if phase == 'establishment':
            return self._establishment_phase_logic(round_number, stock_ratio)
        elif phase == 'adaptive':
            return self._adaptive_phase_logic(stock_ratio, cooperation_ratio, history)
        elif phase == 'endgame':
            return self._endgame_phase_logic(round_number, cooperation_ratio, stock_ratio)
        return Action.D

    def _determine_phase(self, round_number):
        """Determine which phase of the strategy we're in."""
        establishment_rounds = min(3, math.ceil(0.3 * self.n_rounds))
        endgame_rounds = math.ceil(0.2 * self.n_rounds)
        if round_number <= establishment_rounds:
            return 'establishment'
        elif round_number > self.n_rounds - endgame_rounds:
            return 'endgame'
        else:
            return 'adaptive'

    def _calculate_current_stock(self, history):
        """Calculate current stock level based on game dynamics."""
        stock = self.capacity
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0
            if my_action:
                total_consumption += stock / (2 * self.n_players)
            else:
                total_consumption += stock / self.n_players
            for opp_action in opponent_actions:
                if opp_action:
                    total_consumption += stock / (2 * self.n_players)
                else:
                    total_consumption += stock / self.n_players
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _calculate_cooperation_ratio(self, history):
        """Calculate overall cooperation ratio across all players and rounds."""
        if history.round_number == 0:
            return 1.0
        total_cooperations = 0
        total_actions = 0
        total_cooperations += sum(history.my_actions)
        total_actions += len(history.my_actions)
        for round_idx in range(history.round_number):
            total_cooperations += sum(history.opponent_actions[round_idx])
            total_actions += len(history.opponent_actions[round_idx])
        return total_cooperations / total_actions if total_actions > 0 else 1.0

    def _establishment_phase_logic(self, round_number, stock_ratio):
        """Logic for the establishment phase (rounds 1-3)."""
        if round_number == 1:
            return Action.C
        else:
            return Action.C if stock_ratio >= 0.6 else Action.D

    def _adaptive_phase_logic(self, stock_ratio, cooperation_ratio, history):
        """Logic for the adaptive phase (middle rounds)."""
        if stock_ratio < 0.3:
            return Action.D
        elif cooperation_ratio >= 0.6 and stock_ratio >= 0.5:
            return Action.C
        elif cooperation_ratio >= 0.4 and stock_ratio >= 0.4:
            last_defectors = self._count_last_round_defectors(history)
            return Action.C if last_defectors <= self.n_players / 2 else Action.D
        else:
            return Action.D

    def _endgame_phase_logic(self, round_number, cooperation_ratio, stock_ratio):
        """Logic for the endgame phase (last 20% of rounds)."""
        if round_number == self.n_rounds:
            return Action.D
        elif cooperation_ratio > 0.5 and stock_ratio > 0.25:
            return Action.C
        else:
            return Action.D

    def _count_last_round_defectors(self, history):
        """Count how many opponents defected in the last round."""
        if history.round_number == 0:
            return 0
        last_round_actions = history.opponent_actions[history.round_number - 1]
        defectors = sum((1 for action in last_round_actions if not action))
        if not history.my_actions[history.round_number - 1]:
            defectors += 1
        return defectors

class Strategy_COOPERATIVE_95(BaseStrategy):
    """
    Adaptive Cooperative Strategy with Forgiveness - prioritizes long-term sustainability 
    while being responsive to opponent behavior. Starts cooperative and adapts based on 
    stock health and opponent cooperation patterns.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        stock_level = self._estimate_current_stock(history)
        if current_round == self.n_rounds and stock_level < self.capacity * 0.2:
            return Action.D
        stock_health = stock_level / self.capacity
        if stock_health >= 0.7:
            return self._cooperative_mode(history)
        elif stock_health >= 0.3:
            return self._cautious_mode(history)
        else:
            return self._survival_mode(history)

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game dynamics"""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_consumption = stock / (2 * self.n_players) if history.my_actions[round_idx] else stock / self.n_players
            opponent_consumption = 0
            for player_idx in range(self.n_players - 1):
                if history.opponent_actions[round_idx, player_idx]:
                    opponent_consumption += stock / (2 * self.n_players)
                else:
                    opponent_consumption += stock / self.n_players
            total_consumption = my_consumption + opponent_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
            if stock <= 0:
                break
        return stock

    def _cooperative_mode(self, history: PlayerHistory) -> Action:
        """Strategy when stock is healthy (>=70% capacity)"""
        recent_defection_rate = self._count_defections_last_n_rounds(history, 3) / (3 * (self.n_players - 1))
        if recent_defection_rate <= 0.3:
            return Action.C
        else:
            return self._conditional_cooperate(history)

    def _cautious_mode(self, history: PlayerHistory) -> Action:
        """Strategy when stock is moderate (30-70% capacity)"""
        recent_defection_rate = self._count_defections_last_n_rounds(history, 2) / (2 * (self.n_players - 1))
        my_recent_cooperation_rate = self._my_cooperations_last_n_rounds(history, 3) / 3
        if recent_defection_rate <= 0.4 and my_recent_cooperation_rate >= 0.6:
            return Action.C
        elif recent_defection_rate >= 0.7:
            return Action.D
        else:
            return self._tit_for_majority_tat(history)

    def _survival_mode(self, history: PlayerHistory) -> Action:
        """Strategy when stock is critical (<30% capacity)"""
        current_round = history.round_number + 1
        if current_round < self.n_rounds:
            if self._majority_cooperated_last_round(history):
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _conditional_cooperate(self, history: PlayerHistory) -> Action:
        """Forgiveness mechanism: cooperate if showing improvement"""
        if history.round_number < 2:
            return Action.C
        current_round_defections = self._count_defections_in_round(history, -1)
        previous_round_defections = self._count_defections_in_round(history, -2)
        if current_round_defections < previous_round_defections:
            return Action.C
        elif self._my_cooperations_last_n_rounds(history, 2) == 2:
            return Action.D
        else:
            return Action.C

    def _tit_for_majority_tat(self, history: PlayerHistory) -> Action:
        """Respond based on majority behavior in last round"""
        if self._majority_defected_last_round(history):
            return Action.D
        else:
            return Action.C

    def _count_defections_last_n_rounds(self, history: PlayerHistory, n: int) -> int:
        """Count total opponent defections in last n rounds"""
        if history.round_number == 0:
            return 0
        start_round = max(0, history.round_number - n)
        total_defections = 0
        for round_idx in range(start_round, history.round_number):
            total_defections += np.sum(~history.opponent_actions[round_idx])
        return total_defections

    def _count_defections_in_round(self, history: PlayerHistory, round_offset: int) -> int:
        """Count defections in specific round (negative offset from current)"""
        if history.round_number == 0:
            return 0
        round_idx = history.round_number + round_offset
        if round_idx < 0 or round_idx >= history.round_number:
            return 0
        return np.sum(~history.opponent_actions[round_idx])

    def _my_cooperations_last_n_rounds(self, history: PlayerHistory, n: int) -> int:
        """Count my cooperations in last n rounds"""
        if history.round_number == 0:
            return 0
        start_round = max(0, history.round_number - n)
        return np.sum(history.my_actions[start_round:history.round_number])

    def _majority_cooperated_last_round(self, history: PlayerHistory) -> bool:
        """Check if majority of opponents cooperated in last round"""
        if history.round_number == 0:
            return True
        last_round_cooperations = np.sum(history.opponent_actions[history.round_number - 1])
        return last_round_cooperations > (self.n_players - 1) / 2

    def _majority_defected_last_round(self, history: PlayerHistory) -> bool:
        """Check if majority of opponents defected in last round"""
        return not self._majority_cooperated_last_round(history)

class Strategy_COOPERATIVE_96(BaseStrategy):
    """
    Adaptive Cooperative Strategy (ACS) - Prioritizes long-term sustainability while being 
    responsive to opponent behavior patterns. Starts cooperative but adapts based on 
    collective cooperation rates using a three-phase approach.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        current_stock = self._estimate_current_stock(history)
        trust_phase_end = max(1, self.n_rounds // 4)
        endgame_start = self.n_rounds - max(1, int(0.15 * self.n_rounds))
        if current_stock < self.capacity / 8:
            return Action.D
        if current_round <= trust_phase_end:
            return Action.C
        cooperation_rate = self._calculate_cooperation_rate(history)
        all_others_defected = self._all_others_defected_last_round(history)
        if current_round >= endgame_start:
            if cooperation_rate >= 0.6:
                return Action.C
            else:
                return Action.D
        if current_stock < self.capacity / 4:
            return Action.D
        if all_others_defected and current_round > trust_phase_end + 1:
            return Action.D
        if cooperation_rate >= 0.5:
            return Action.C
        else:
            return Action.D

    def _calculate_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate the overall cooperation rate from all players' history."""
        if history.round_number == 0:
            return 1.0
        my_cooperations = np.sum(history.my_actions)
        opponent_cooperations = np.sum(history.opponent_actions)
        total_cooperations = my_cooperations + opponent_cooperations
        total_actions = history.round_number * self.n_players
        return total_cooperations / total_actions if total_actions > 0 else 1.0

    def _all_others_defected_last_round(self, history: PlayerHistory) -> bool:
        """Check if all opponents defected in the most recent round."""
        if history.round_number == 0:
            return False
        last_round_idx = history.round_number - 1
        opponent_actions_last_round = history.opponent_actions[last_round_idx]
        return not np.any(opponent_actions_last_round)

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game dynamics."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            my_consumption = stock / (2 * self.n_players) if my_action else stock / self.n_players
            opponent_consumption = 0.0
            for opponent_cooperated in opponent_actions:
                if opponent_cooperated:
                    opponent_consumption += stock / (2 * self.n_players)
                else:
                    opponent_consumption += stock / self.n_players
            total_consumption = my_consumption + opponent_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

class Strategy_COOPERATIVE_97(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Forgiveness (ATTF) Strategy
    
    Prioritizes long-term sustainability while being responsive to opponent behavior.
    Starts cooperatively but adapts based on collective actions with built-in forgiveness
    mechanisms to recover from mutual defection cycles.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        current_stock = self._estimate_current_stock(history)
        if current_round == self.r:
            if current_stock < self.n:
                return Action.D
            else:
                return Action.C
        last_round_idx = history.round_number - 1
        last_round_cooperators = sum(history.opponent_actions[last_round_idx])
        cooperation_rate = last_round_cooperators / (self.n - 1)
        if current_stock < self.n * 2:
            if cooperation_rate >= 0.5:
                return Action.C
            else:
                return Action.D
        if cooperation_rate >= 0.7:
            return Action.C
        elif cooperation_rate >= 0.3:
            if self._was_exploited_last_round(history):
                return self._try_forgiveness(history)
            else:
                return Action.C
        else:
            return self._conditional_defect(current_round, current_stock, history)

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game history"""
        stock = self.capacity
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_cooperators = sum(history.opponent_actions[round_idx])
            opponent_defectors = self.n - 1 - opponent_cooperators
            if my_action:
                my_consumption = stock / (2 * self.n)
            else:
                my_consumption = stock / self.n
            opponent_consumption = opponent_cooperators * stock / (2 * self.n) + opponent_defectors * stock / self.n
            total_consumption = my_consumption + opponent_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _was_exploited_last_round(self, history: PlayerHistory) -> bool:
        """Check if I cooperated but majority of others defected"""
        last_round_idx = history.round_number - 1
        my_action = history.my_actions[last_round_idx]
        others_defect_count = self.n - 1 - sum(history.opponent_actions[last_round_idx])
        others_defect_rate = others_defect_count / (self.n - 1)
        return my_action and others_defect_rate > 0.5

    def _try_forgiveness(self, history: PlayerHistory) -> Action:
        """Implement graduated forgiveness mechanism"""
        recent_exploitations = 0
        start_round = max(0, history.round_number - 3)
        for round_idx in range(start_round, history.round_number):
            if history.my_actions[round_idx] and sum(history.opponent_actions[round_idx]) < (self.n - 1) / 2:
                recent_exploitations += 1
        if recent_exploitations <= 1:
            return Action.C
        elif recent_exploitations == 2 and random.random() < 0.5:
            return Action.C
        else:
            return Action.D

    def _conditional_defect(self, current_round: int, current_stock: float, history: PlayerHistory) -> Action:
        """Defect conditionally with periodic cooperation signals"""
        rounds_remaining = self.r - current_round
        if rounds_remaining > 3 and current_round % 4 == 0:
            return Action.C
        elif current_stock > self.capacity * 0.8:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_98(BaseStrategy):
    """
    Adaptive Cooperative Strategy with Trust Building.
    
    Prioritizes long-term sustainability while building trust through demonstrable cooperation,
    but includes protective mechanisms against exploitation. Features emergency conservation mode,
    adaptive response to group cooperation levels, and endgame wisdom.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        current_stock = self._calculate_current_stock(history)
        if current_round == 2:
            all_cooperated = np.all(history.opponent_actions[0])
            if all_cooperated:
                return Action.C
            else:
                return Action.D
        if current_round == self.r:
            return self._final_round_decision(history, current_stock)
        return self._adaptive_decision(history, current_stock)

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate the current stock level based on game dynamics."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_consumption = stock / (2 * self.n) if history.my_actions[round_idx] else stock / self.n
            total_opponent_consumption = 0.0
            for player_idx in range(self.n - 1):
                if history.opponent_actions[round_idx, player_idx]:
                    total_opponent_consumption += stock / (2 * self.n)
                else:
                    total_opponent_consumption += stock / self.n
            total_consumption = my_consumption + total_opponent_consumption
            stock_remaining = max(0.0, stock - total_consumption)
            if stock_remaining > 0:
                growth = 2 * stock_remaining * (1 - stock_remaining / self.capacity)
            else:
                growth = 0.0
            stock = min(stock_remaining + growth, self.capacity)
        return stock

    def _adaptive_decision(self, history: PlayerHistory, current_stock: float) -> Action:
        """Make adaptive decision for rounds 3 to r-1."""
        if current_stock < self.capacity * 0.3:
            return Action.C
        last_round_idx = history.round_number - 1
        cooperators_last_round = np.sum(history.opponent_actions[last_round_idx])
        cooperation_ratio = cooperators_last_round / (self.n - 1)
        start_idx = max(0, history.round_number - 3)
        my_recent_defections = np.sum(~history.my_actions[start_idx:])
        if cooperation_ratio >= 0.75:
            return Action.C
        elif cooperation_ratio >= 0.5:
            if my_recent_defections <= 1:
                return Action.C
            else:
                return Action.D
        elif cooperation_ratio >= 0.25 and current_stock > self.capacity * 0.6:
            return Action.C
        else:
            return Action.D

    def _final_round_decision(self, history: PlayerHistory, current_stock: float) -> Action:
        """Make decision for the final round."""
        if current_stock < self.capacity * 0.2:
            return Action.C
        start_idx = max(0, history.round_number - 3)
        cooperation_ratios = []
        for round_idx in range(start_idx, history.round_number):
            cooperators = np.sum(history.opponent_actions[round_idx])
            cooperation_ratios.append(cooperators / (self.n - 1))
        avg_cooperation = np.mean(cooperation_ratios) if cooperation_ratios else 0.0
        if avg_cooperation >= 0.6:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_99(BaseStrategy):
    """
    Adaptive Conditional Cooperator Strategy for Common Pool Resource Game.
    
    Prioritizes long-term sustainability while protecting against exploitation through
    adaptive punishment and forgiveness mechanisms. Cooperation thresholds become
    stricter as stock depletes, with emergency protection when stock falls below 30%.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        stock_current = self._estimate_current_stock(history)
        last_round_actions = history.opponent_actions[history.round_number - 1]
        last_round_cooperators = np.sum(last_round_actions)
        my_last_action = history.my_actions[history.round_number - 1]
        if my_last_action:
            last_round_cooperators += 1
        cooperation_rate = last_round_cooperators / self.n_players
        if stock_current < self.capacity * 0.3:
            if cooperation_rate < 0.8:
                return Action.D
            else:
                return Action.C
        if current_round == self.n_rounds:
            if stock_current >= self.capacity * 0.7:
                return Action.C
            elif self._calculate_overall_cooperation_rate(history) >= 0.6:
                return Action.C
            else:
                return Action.D
        cooperation_threshold = max(0.5, stock_current / self.capacity * 0.8)
        if cooperation_rate >= cooperation_threshold:
            return Action.C
        else:
            return Action.D

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock based on game history and dynamics."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            total_consumption = 0.0
            if history.my_actions[round_idx]:
                total_consumption += stock / (2 * self.n_players)
            else:
                total_consumption += stock / self.n_players
            for opponent_idx in range(self.n_players - 1):
                if history.opponent_actions[round_idx, opponent_idx]:
                    total_consumption += stock / (2 * self.n_players)
                else:
                    total_consumption += stock / self.n_players
            stock_after_consumption = stock - total_consumption
            stock_after_consumption = max(0.0, stock_after_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _calculate_overall_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate average cooperation rate across all rounds and players."""
        if history.round_number == 0:
            return 1.0
        total_cooperation = 0
        total_decisions = 0
        total_cooperation += np.sum(history.my_actions)
        total_decisions += len(history.my_actions)
        total_cooperation += np.sum(history.opponent_actions)
        total_decisions += history.opponent_actions.size
        return total_cooperation / total_decisions if total_decisions > 0 else 1.0

class Strategy_COOPERATIVE_100(BaseStrategy):
    """
    Conditional Cooperation with Forgiveness strategy for Common Pool Resource Game.
    
    This strategy starts cooperatively and adapts based on recent opponent behavior:
    - Always cooperates in first round
    - Forces cooperation when stock is critically low (10% capacity)
    - Responds to defection rates in last 3 rounds with graduated responses
    - Uses forgiveness mechanism to allow recovery from conflicts
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.look_back_rounds = 3

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        current_stock = self._estimate_current_stock(history)
        if current_stock <= self.game_description.capacity * 0.1:
            return Action.C
        if current_round == self.game_description.n_rounds:
            return self._handle_final_round(history, current_stock)
        defection_rate = self._calculate_recent_defection_rate(history)
        if defection_rate >= 0.75:
            return Action.D
        elif defection_rate >= 0.5:
            return Action.C if random.random() < 0.7 else Action.D
        else:
            return Action.C

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game history."""
        stock = float(self.game_description.capacity)
        n = self.game_description.n_players
        capacity = float(self.game_description.capacity)
        for round_idx in range(history.round_number):
            total_consumption = 0.0
            if history.my_actions[round_idx]:
                my_consumption = stock / (2 * n)
            else:
                my_consumption = stock / n
            total_consumption += my_consumption
            for opponent_idx in range(n - 1):
                if history.opponent_actions[round_idx, opponent_idx]:
                    opp_consumption = stock / (2 * n)
                else:
                    opp_consumption = stock / n
                total_consumption += opp_consumption
            stock_after_consumption = max(0.0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            else:
                growth = 0.0
            stock = min(stock_after_consumption + growth, capacity)
        return stock

    def _calculate_recent_defection_rate(self, history: PlayerHistory) -> float:
        """Calculate defection rate over the last few rounds."""
        rounds_to_check = min(self.look_back_rounds, history.round_number)
        if rounds_to_check == 0:
            return 0.0
        total_actions = 0
        total_defections = 0
        start_round = history.round_number - rounds_to_check
        for round_idx in range(start_round, history.round_number):
            for opponent_idx in range(self.game_description.n_players - 1):
                total_actions += 1
                if not history.opponent_actions[round_idx, opponent_idx]:
                    total_defections += 1
        return total_defections / total_actions if total_actions > 0 else 0.0

    def _handle_final_round(self, history: PlayerHistory, current_stock: float) -> Action:
        """Handle final round decision based on stock level and cooperation history."""
        if current_stock > self.game_description.capacity * 0.5:
            overall_cooperation_rate = self._calculate_overall_cooperation_rate(history)
            if overall_cooperation_rate >= 0.6:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C

    def _calculate_overall_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate overall cooperation rate across all rounds and opponents."""
        if history.round_number == 0:
            return 1.0
        total_actions = 0
        total_cooperations = 0
        for round_idx in range(history.round_number):
            for opponent_idx in range(self.game_description.n_players - 1):
                total_actions += 1
                if history.opponent_actions[round_idx, opponent_idx]:
                    total_cooperations += 1
        return total_cooperations / total_actions if total_actions > 0 else 1.0

class Strategy_COOPERATIVE_101(BaseStrategy):
    """
    Adaptive Guardian: A cooperative strategy that balances cooperation with sustainability.
    Cooperates when the resource is healthy and others cooperate, but adapts to protect
    against exploitation and resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round = history.round_number + 1
        stock = self._calculate_current_stock(history, capacity, n)
        stock_health_ratio = stock / capacity
        prev_round_idx = history.round_number - 1
        prev_cooperators = sum(history.opponent_actions[prev_round_idx])
        if history.my_actions[prev_round_idx]:
            prev_cooperators += 1
        cooperation_threshold = math.ceil(n / 2)
        if stock_health_ratio < 0.4:
            return Action.D
        if current_round == r:
            if prev_cooperators >= cooperation_threshold:
                return Action.C
            else:
                return Action.D
        if prev_cooperators >= cooperation_threshold:
            return Action.C
        else:
            return Action.D

    def _calculate_current_stock(self, history: PlayerHistory, capacity: float, n: int) -> float:
        """Calculate the current stock level based on game dynamics."""
        stock = capacity
        for round_idx in range(history.round_number):
            cooperators = sum(history.opponent_actions[round_idx])
            if history.my_actions[round_idx]:
                cooperators += 1
            defectors = n - cooperators
            coop_consumption = cooperators * (stock / (2 * n))
            defect_consumption = defectors * (stock / n)
            total_consumption = coop_consumption + defect_consumption
            stock_after_consumption = stock - total_consumption
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            stock = min(stock_after_consumption + growth, capacity)
            stock = max(stock, 0)
        return stock

class Strategy_COOPERATIVE_102(BaseStrategy):
    """
    Adaptive Reciprocal Cooperation (ARC) strategy for Common Pool Resource Game.
    
    This strategy balances cooperation with protection against exploitation.
    It adapts based on stock levels and opponent behavior patterns, prioritizing
    long-term sustainability while being responsive to cooperation signals.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        stock_level = self._estimate_current_stock(history)
        if current_round == self.n_rounds:
            return self._final_round_decision(history, stock_level)
        if stock_level < self.capacity * 0.3:
            return Action.C
        last_round_idx = history.round_number - 1
        last_round_cooperators = sum(history.opponent_actions[last_round_idx])
        cooperation_ratio = last_round_cooperators / self.n_players
        my_cooperations = sum(history.my_actions)
        my_cooperation_ratio = my_cooperations / history.round_number
        if cooperation_ratio >= 0.6:
            return Action.C
        elif cooperation_ratio >= 0.4:
            if stock_level > self.capacity * 0.7:
                return Action.C
            elif random.random() < 0.8:
                most_common_action = Action.C if cooperation_ratio >= 0.5 else Action.D
                return most_common_action
            else:
                return Action.C
        elif stock_level > self.capacity * 0.8:
            return Action.C
        elif current_round % 3 == 0:
            return Action.C
        else:
            return Action.D

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """
        Estimate current stock level based on game dynamics.
        This reconstructs the stock evolution from the payoff history.
        """
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_payoff = history.my_payoffs[round_idx]
            my_cooperated = history.my_actions[round_idx]
            if my_cooperated:
                round_start_stock = my_payoff * (2 * self.n_players)
            else:
                round_start_stock = my_payoff * self.n_players
            my_consumption = my_payoff
            opponent_consumption = sum(history.opponent_payoffs[round_idx])
            total_consumption = my_consumption + opponent_consumption
            stock_after_consumption = max(0, round_start_stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _final_round_decision(self, history: PlayerHistory, stock_level: float) -> Action:
        """Special logic for the final round."""
        if stock_level < self.capacity * 0.2:
            return Action.C
        last_round_idx = history.round_number - 1
        last_round_cooperators = sum(history.opponent_actions[last_round_idx])
        cooperation_ratio = last_round_cooperators / self.n_players
        if cooperation_ratio >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_103(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Trust"
    
    Prioritizes long-term sustainability while building and maintaining cooperative relationships.
    Balances trust-building with protection against exploitation, adapting based on observed behavior patterns.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = self.capacity * 0.3
        self.high_trust_threshold = 0.7
        self.moderate_trust_threshold = 0.5
        self.forgiveness_interval = 4

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        stock = self._estimate_current_stock(history)
        if current_round == self.n_rounds:
            return self._handle_final_round(stock, history)
        if stock < self.critical_threshold:
            return Action.C
        cooperation_score = self._calculate_cooperation_score(history)
        trust_level = cooperation_score
        if trust_level >= self.high_trust_threshold:
            return Action.C
        elif trust_level >= self.moderate_trust_threshold:
            return self._conditional_cooperate(history)
        else:
            return self._defensive_defect_with_forgiveness(history)

    def _estimate_current_stock(self, history):
        """Estimate current stock based on game history"""
        stock = self.capacity
        for round_idx in range(history.round_number):
            my_consumption = stock / (2 * self.n_players) if history.my_actions[round_idx] else stock / self.n_players
            opponent_consumption = 0
            for player_idx in range(self.n_players - 1):
                if history.opponent_actions[round_idx, player_idx]:
                    opponent_consumption += stock / (2 * self.n_players)
                else:
                    opponent_consumption += stock / self.n_players
            total_consumption = my_consumption + opponent_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _calculate_cooperation_score(self, history):
        """Calculate weighted cooperation score of opponents"""
        if history.round_number == 0:
            return 1.0
        recent_weight = 0.6
        historical_weight = 0.4
        recent_rounds = min(3, history.round_number)
        recent_start = max(0, history.round_number - recent_rounds)
        recent_coop_actions = 0
        recent_total_actions = 0
        for round_idx in range(recent_start, history.round_number):
            for player_idx in range(self.n_players - 1):
                if history.opponent_actions[round_idx, player_idx]:
                    recent_coop_actions += 1
                recent_total_actions += 1
        recent_coop_rate = recent_coop_actions / recent_total_actions if recent_total_actions > 0 else 0
        historical_coop_actions = 0
        historical_total_actions = 0
        for round_idx in range(history.round_number):
            for player_idx in range(self.n_players - 1):
                if history.opponent_actions[round_idx, player_idx]:
                    historical_coop_actions += 1
                historical_total_actions += 1
        historical_coop_rate = historical_coop_actions / historical_total_actions if historical_total_actions > 0 else 0
        return recent_weight * recent_coop_rate + historical_weight * historical_coop_rate

    def _conditional_cooperate(self, history):
        """Cooperate if majority cooperated in previous round"""
        if history.round_number == 0:
            return Action.C
        last_round = history.round_number - 1
        cooperators = sum(history.opponent_actions[last_round, :])
        return Action.C if cooperators >= (self.n_players - 1) / 2 else Action.D

    def _defensive_defect_with_forgiveness(self, history):
        """Generally defect but attempt cooperation every few rounds"""
        current_round = history.round_number + 1
        if current_round % self.forgiveness_interval == 0:
            return Action.C
        return Action.D

    def _handle_final_round(self, stock, history):
        """Handle final round decision"""
        if stock > self.capacity * 0.8:
            return Action.D
        elif self._others_consistently_cooperative(history):
            return Action.C
        else:
            return Action.D

    def _others_consistently_cooperative(self, history):
        """Check if others have been consistently cooperative"""
        if history.round_number < 3:
            return False
        cooperation_score = self._calculate_cooperation_score(history)
        return cooperation_score >= 0.8

class Strategy_COOPERATIVE_104(BaseStrategy):
    """
    Adaptive Trust with Sustainability Focus: A cooperative strategy that prioritizes 
    long-term resource sustainability while building trust with opponents. Uses a 
    cooperation scoring system to adapt to opponent behavior and implements crisis 
    management when resource stocks are critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_scores = [1.0] * (game_description.n_players - 1)

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game history."""
        stock = float(self.game_description.capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            if my_action:
                my_consumption = stock / (2 * self.game_description.n_players)
            else:
                my_consumption = stock / self.game_description.n_players
            opponent_consumption = 0
            for opp_action in opponent_actions:
                if opp_action:
                    opponent_consumption += stock / (2 * self.game_description.n_players)
                else:
                    opponent_consumption += stock / self.game_description.n_players
            total_consumption = my_consumption + opponent_consumption
            stock_after_consumption = stock - total_consumption
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.game_description.capacity)
            stock = min(stock_after_consumption + growth, self.game_description.capacity)
        return stock

    def _update_cooperation_scores(self, history: PlayerHistory):
        """Update cooperation scores for all opponents based on most recent round."""
        if history.round_number == 0:
            return
        most_recent_round = history.round_number - 1
        for i in range(len(self.cooperation_scores)):
            cooperation_indicator = 1.0 if history.opponent_actions[most_recent_round, i] else 0.0
            self.cooperation_scores[i] = 0.7 * self.cooperation_scores[i] + 0.3 * cooperation_indicator

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        self._update_cooperation_scores(history)
        current_stock = self._calculate_current_stock(history)
        capacity = float(self.game_description.capacity)
        current_round = history.round_number + 1
        if current_stock < capacity * 0.3:
            return Action.C
        if current_stock < capacity * 0.15:
            return Action.C
        average_cooperation_score = np.mean(self.cooperation_scores)
        if current_round == self.game_description.n_rounds:
            if current_stock < capacity * 0.2:
                return Action.C
            elif average_cooperation_score >= 0.6:
                return Action.C
            else:
                return Action.D
        if current_stock > capacity * 0.9 and average_cooperation_score > 0.7:
            return Action.C
        if history.round_number > 0:
            last_round = history.round_number - 1
            opponents_who_defected = sum((1 for action in history.opponent_actions[last_round] if not action))
            defection_rate = opponents_who_defected / len(history.opponent_actions[last_round])
            if defection_rate > 0.6 and current_stock > capacity * 0.5:
                return Action.D
        cooperation_threshold = max(0.4, 0.8 - 0.05 * current_round)
        if average_cooperation_score >= cooperation_threshold:
            return Action.C
        elif average_cooperation_score >= 0.25:
            if current_stock >= capacity * 0.7:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COOPERATIVE_105(BaseStrategy):
    """
    Forgiving Sustainability Guardian: A cooperative strategy that prioritizes long-term 
    resource sustainability while being forgiving to occasional defections. It cooperates 
    by default, focuses on emergency conservation when stock is low, and only retaliates 
    after persistent mass defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defection_streak = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.defection_streak = 0
            return Action.C
        round_num = history.round_number
        stock = self._calculate_current_stock(history)
        if stock < self.game_description.capacity * 0.3:
            self.defection_streak = 0
            return Action.C
        last_round_idx = round_num - 1
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        my_last_action = history.my_actions[last_round_idx]
        total_cooperators = opponent_cooperators + (1 if my_last_action else 0)
        majority_cooperated = total_cooperators >= self.game_description.n_players / 2
        if majority_cooperated:
            self.defection_streak = 0
            return Action.C
        else:
            self.defection_streak += 1
            if self.defection_streak >= 3:
                return Action.D
            else:
                return Action.C

    def _calculate_current_stock(self, history: None | PlayerHistory) -> float:
        """Calculate the current stock level based on game history."""
        if history is None:
            return self.game_description.capacity
        stock = self.game_description.capacity
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        for round_idx in range(history.round_number):
            total_consumption = 0
            if history.my_actions[round_idx]:
                total_consumption += stock / (2 * n)
            else:
                total_consumption += stock / n
            for opponent_idx in range(n - 1):
                if history.opponent_actions[round_idx, opponent_idx]:
                    total_consumption += stock / (2 * n)
                else:
                    total_consumption += stock / n
            stock_after_consumption = max(0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            else:
                growth = 0
            stock = min(stock_after_consumption + growth, capacity)
        return stock

class Strategy_COOPERATIVE_106(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Forgiveness (ATTF) strategy for Common Pool Resource Game.
    
    Starts cooperative, responds proportionally to defection levels, maintains forgiveness
    mechanisms, and prioritizes resource sustainability while protecting against exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        round_num = history.round_number + 1
        stock_level = self._estimate_current_stock(history, capacity, n)
        last_round_idx = history.round_number - 1
        defectors_last_round = n - sum(history.opponent_actions[last_round_idx])
        if not history.my_actions[last_round_idx]:
            defectors_last_round += 1
        cooperation_rate = (n - defectors_last_round) / n
        stock_health = stock_level / capacity
        rounds_remaining = r - round_num + 1
        if stock_health < 0.2:
            return Action.C
        elif rounds_remaining <= 2:
            if cooperation_rate >= 0.5:
                return Action.C
            else:
                return Action.D
        elif cooperation_rate >= 0.75:
            return Action.C
        elif cooperation_rate >= 0.5:
            forgiveness_prob = 0.3 + 0.4 * stock_health
            if random.random() < forgiveness_prob:
                return Action.C
            else:
                return Action.D
        elif cooperation_rate >= 0.25:
            return Action.D
        elif round_num % 3 == 1:
            return Action.C
        else:
            return Action.D

    def _estimate_current_stock(self, history: PlayerHistory, capacity: int, n: int):
        """Estimate current stock level based on game history and dynamics."""
        stock = capacity
        for round_idx in range(history.round_number):
            my_consumption = stock / (2 * n) if history.my_actions[round_idx] else stock / n
            opponent_consumption = 0
            for player_idx in range(n - 1):
                if history.opponent_actions[round_idx, player_idx]:
                    opponent_consumption += stock / (2 * n)
                else:
                    opponent_consumption += stock / n
            total_consumption = my_consumption + opponent_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            else:
                growth = 0
            stock = min(stock_after_consumption + growth, capacity)
        return stock

class Strategy_COOPERATIVE_107(BaseStrategy):
    """
    Adaptive Cooperative Strategy with Forgiveness.
    
    Prioritizes long-term sustainability while being responsive to opponent behavior.
    Uses emergency conservation mode, graduated punishment, and forgiveness mechanisms.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_threshold = game_description.capacity * 0.3
        self.cooperation_threshold = 0.6
        self.max_punishment_rounds = 2
        self.punishment_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punishment_counter = 0
            return Action.C
        current_stock = self._calculate_current_stock(history)
        if current_stock <= self.critical_threshold:
            self.punishment_counter = 0
            return Action.C
        recent_window = min(3, history.round_number)
        cooperation_rate = self._calculate_recent_cooperation_rate(history, recent_window)
        if cooperation_rate >= self.cooperation_threshold:
            self.punishment_counter = 0
            return Action.C
        if self.punishment_counter < self.max_punishment_rounds:
            self.punishment_counter += 1
            return Action.D
        self.punishment_counter = 0
        return Action.C

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game dynamics."""
        stock = float(self.game_description.capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            cooperators = int(my_action) + sum(opponent_actions)
            defectors = self.game_description.n_players - cooperators
            cooperator_consumption = stock / (2 * self.game_description.n_players)
            defector_consumption = stock / self.game_description.n_players
            total_consumption = cooperators * cooperator_consumption + defectors * defector_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.game_description.capacity)
            stock = min(stock_after_consumption + growth, self.game_description.capacity)
        return stock

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory, window: int) -> float:
        """Calculate cooperation rate in the most recent rounds."""
        if history.round_number == 0:
            return 1.0
        start_idx = max(0, history.round_number - window)
        total_cooperative_actions = 0
        total_actions = 0
        for round_idx in range(start_idx, history.round_number):
            if history.my_actions[round_idx]:
                total_cooperative_actions += 1
            total_actions += 1
            opponent_cooperations = sum(history.opponent_actions[round_idx])
            total_cooperative_actions += opponent_cooperations
            total_actions += len(history.opponent_actions[round_idx])
        if total_actions == 0:
            return 1.0
        return total_cooperative_actions / total_actions

class Strategy_COOPERATIVE_108(BaseStrategy):
    """
    Conditional Sustainability strategy: Cooperates by default but punishes majority defection
    when stock levels allow, returning quickly to cooperation to maintain resource sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n_players = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = self._calculate_current_stock(history)
        if current_stock < capacity * 0.2:
            return Action.C
        if current_round == total_rounds:
            if current_stock > capacity * 0.5:
                return Action.C
            else:
                return Action.D
        previous_round_idx = history.round_number - 1
        previous_opponent_actions = history.opponent_actions[previous_round_idx]
        defector_count = sum((1 for action in previous_opponent_actions if not action))
        defection_rate = defector_count / n_players
        majority_defected = defection_rate > 0.5
        stock_sufficient_for_punishment = current_stock > capacity * 0.3
        if majority_defected and stock_sufficient_for_punishment:
            return Action.D
        return Action.C

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game history."""
        stock = float(self.game_description.capacity)
        n_players = self.game_description.n_players
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0.0
            if my_action:
                total_consumption += stock / (2 * n_players)
            else:
                total_consumption += stock / n_players
            for opponent_action in opponent_actions:
                if opponent_action:
                    total_consumption += stock / (2 * n_players)
                else:
                    total_consumption += stock / n_players
            stock_after_consumption = max(0.0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.game_description.capacity)
            stock = min(stock_after_consumption + growth, float(self.game_description.capacity))
        return stock

class Strategy_COOPERATIVE_109(BaseStrategy):
    """
    Conditional Cooperation with Forgiveness Strategy.
    
    Starts cooperatively, then cooperates if majority cooperated last round.
    Includes forgiveness mechanism to prevent defection spirals and critical
    stock protection. Final round considers resource health over pure defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n = self.game_description.n_players
        final_round = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = self._calculate_current_stock(history)
        if current_round == final_round:
            if current_stock > capacity / 2:
                return Action.C
            else:
                return Action.D
        if current_stock < capacity / 4:
            return Action.D
        prev_round_idx = history.round_number - 1
        prev_cooperators = sum(history.opponent_actions[prev_round_idx])
        if history.my_actions[prev_round_idx]:
            prev_cooperators += 1
        majority_threshold = math.ceil(n / 2)
        if prev_cooperators >= majority_threshold:
            return Action.C
        consecutive_defections = self._count_consecutive_majority_defections(history)
        if consecutive_defections >= 2 and current_stock > capacity / 3:
            return Action.C
        return Action.D

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock based on game history."""
        capacity = self.game_description.capacity
        n = self.game_description.n_players
        stock = float(capacity)
        for round_idx in range(history.round_number):
            my_consumption = stock / (2 * n) if history.my_actions[round_idx] else stock / n
            opponent_consumption = 0
            for opponent_idx in range(n - 1):
                if history.opponent_actions[round_idx, opponent_idx]:
                    opponent_consumption += stock / (2 * n)
                else:
                    opponent_consumption += stock / n
            total_consumption = my_consumption + opponent_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            else:
                growth = 0
            stock = min(stock_after_consumption + growth, capacity)
        return stock

    def _count_consecutive_majority_defections(self, history: PlayerHistory) -> int:
        """Count consecutive rounds where majority defected, working backwards."""
        n = self.game_description.n_players
        majority_threshold = math.ceil(n / 2)
        consecutive = 0
        for round_idx in range(history.round_number - 1, -1, -1):
            cooperators = sum(history.opponent_actions[round_idx])
            if history.my_actions[round_idx]:
                cooperators += 1
            if cooperators < majority_threshold:
                consecutive += 1
            else:
                break
        return consecutive

class Strategy_COOPERATIVE_110(BaseStrategy):
    """
    Sustainable Guardian: An adaptive cooperative strategy that prioritizes long-term 
    sustainability while being responsive to group cooperation levels. Starts cooperatively
    but adapts based on observed behavior to maintain both the resource pool and competitive viability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round = history.round_number + 1
        current_stock = self._estimate_current_stock(history, n, capacity)
        if current_stock < capacity * 0.3:
            return Action.C
        if current_round == r:
            return Action.D
        previous_round_idx = history.round_number - 1
        my_cooperation = int(history.my_actions[previous_round_idx])
        opponent_cooperations = int(np.sum(history.opponent_actions[previous_round_idx]))
        total_cooperators = my_cooperation + opponent_cooperations
        cooperation_rate = total_cooperators / n
        if cooperation_rate >= 0.5:
            return Action.C
        else:
            return Action.D

    def _estimate_current_stock(self, history: PlayerHistory, n: int, capacity: int) -> float:
        """
        Estimate current stock level based on game history.
        This is an approximation since we don't have direct access to stock values.
        """
        stock = float(capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            cooperators = int(my_action) + int(np.sum(opponent_actions))
            defectors = n - cooperators
            total_consumption = cooperators * (stock / (2 * n)) + defectors * (stock / n)
            stock_after_consumption = max(0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth_rate = 1 - stock_after_consumption / capacity
                growth = 2 * stock_after_consumption * growth_rate
                stock = min(stock_after_consumption + growth, capacity)
            else:
                stock = 0
            if stock <= 0:
                break
        return stock

class Strategy_COOPERATIVE_111(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Sustainability Monitoring (ATTSM).
    Prioritizes long-term cooperation while being responsive to opponents' behavior 
    and the health of the common pool resource. Combines reciprocity, forgiveness, 
    and sustainability awareness.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.forgiveness_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        total_rounds = self.game_description.n_rounds
        round_num = history.round_number + 1
        last_payoff = history.my_payoffs[-1]
        last_action = history.my_actions[-1]
        if last_action:
            current_stock = last_payoff * 2 * n
        else:
            current_stock = last_payoff * n
        critical_threshold = capacity * 0.3
        if current_stock < critical_threshold:
            return Action.C
        last_round_opponents = history.opponent_actions[-1]
        cooperators = sum(last_round_opponents)
        cooperation_ratio = cooperators / n
        if round_num > total_rounds - 3:
            cooperation_target = 0.7
        else:
            cooperation_target = 0.6
        defection_trend = False
        if history.round_number >= 3:
            recent_coop_ratios = []
            for i in range(3):
                round_opponents = history.opponent_actions[-(i + 1)]
                round_cooperators = sum(round_opponents)
                recent_coop_ratios.append(round_cooperators / n)
            defection_trend = all((ratio < cooperation_target for ratio in recent_coop_ratios))
        if self.forgiveness_counter > 0:
            self.forgiveness_counter -= 1
        if cooperation_ratio >= cooperation_target:
            return Action.C
        elif defection_trend and self.forgiveness_counter == 0:
            self.forgiveness_counter = 1
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_112(BaseStrategy):
    """
    Adaptive Cooperation with Sustainability Monitoring (ACSM)
    
    A cooperative strategy that balances cooperation with protection against exploitation
    while maintaining long-term resource sustainability. Uses graduated responses based
    on observed cooperation levels and implements sustainability overrides when the
    resource pool is threatened.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round = history.round_number + 1
        stock = self._calculate_current_stock(history, capacity, n)
        current_stock_ratio = stock / capacity
        if current_round <= 3:
            if current_stock_ratio < 0.25:
                return self._sustainability_override(current_stock_ratio, history)
            return Action.C
        if current_round > r - 2:
            return self._end_game_strategy(history, current_stock_ratio, n)
        return self._main_game_strategy(history, current_stock_ratio, n)

    def _calculate_current_stock(self, history, capacity, n):
        """Calculate current stock level based on game history."""
        stock = capacity
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0
            if my_action:
                total_consumption += stock / (2 * n)
            else:
                total_consumption += stock / n
            for opp_action in opponent_actions:
                if opp_action:
                    total_consumption += stock / (2 * n)
                else:
                    total_consumption += stock / n
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            stock = min(stock_after_consumption + growth, capacity)
        return stock

    def _main_game_strategy(self, history, current_stock_ratio, n):
        """Main game strategy for rounds 4 to r-2."""
        window_size = min(3, history.round_number)
        recent_rounds = range(history.round_number - window_size, history.round_number)
        my_recent_cooperations = sum((history.my_actions[i] for i in recent_rounds))
        my_coop_rate = my_recent_cooperations / window_size
        others_cooperations = 0
        total_others_actions = 0
        for i in recent_rounds:
            others_cooperations += sum(history.opponent_actions[i])
            total_others_actions += len(history.opponent_actions[i])
        others_coop_rate = others_cooperations / total_others_actions if total_others_actions > 0 else 0
        if current_stock_ratio < 0.3:
            return Action.C
        if others_coop_rate >= 0.7:
            return Action.C
        if others_coop_rate >= 0.4:
            return Action.C
        if others_coop_rate >= 0.2:
            if current_stock_ratio > 0.6:
                return Action.C
            else:
                return Action.D
        if current_stock_ratio < 0.2:
            return Action.C
        else:
            return Action.D

    def _end_game_strategy(self, history, current_stock_ratio, n):
        """End game strategy for last 2 rounds."""
        current_round = history.round_number + 1
        r = self.game_description.n_rounds
        window_size = min(2, history.round_number)
        if window_size > 0:
            recent_rounds = range(history.round_number - window_size, history.round_number)
            others_cooperations = sum((sum(history.opponent_actions[i]) for i in recent_rounds))
            total_others_actions = sum((len(history.opponent_actions[i]) for i in recent_rounds))
            others_recent_coop = others_cooperations / total_others_actions if total_others_actions > 0 else 0
        else:
            others_recent_coop = 0
        if current_stock_ratio < 0.25:
            return Action.C
        if others_recent_coop >= 0.6:
            return Action.C
        if current_round == r - 1:
            return Action.C
        elif others_recent_coop >= 0.3:
            return Action.C
        else:
            return Action.D

    def _sustainability_override(self, current_stock_ratio, history):
        """Override for sustainability when stock is critically low."""
        if current_stock_ratio < 0.2:
            return Action.C
        if history.round_number > 0:
            last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
            if last_round_cooperators >= len(history.opponent_actions[history.round_number - 1]) * 0.5:
                return Action.C
        return Action.C

class Strategy_COOPERATIVE_113(BaseStrategy):
    """
    Adaptive Forgiveness Strategy (AFS): A cooperative strategy with safeguards.
    
    Starts with cooperation, adapts based on recent cooperation rates,
    includes forgiveness mechanisms, and protects against resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round <= 2:
            return Action.C
        stock_level = self._estimate_current_stock(history)
        if current_round >= self.n_rounds - 1:
            return self._endgame_strategy(history, current_round, stock_level)
        return self._adaptive_response(history, stock_level)

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game dynamics."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_consumption = stock / (2 * self.n_players) if history.my_actions[round_idx] else stock / self.n_players
            opponent_consumption = 0
            for player_idx in range(self.n_players - 1):
                if history.opponent_actions[round_idx, player_idx]:
                    opponent_consumption += stock / (2 * self.n_players)
                else:
                    opponent_consumption += stock / self.n_players
            total_consumption = my_consumption + opponent_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _get_recent_cooperation_rate(self, history: PlayerHistory, k: int=2) -> float:
        """Calculate cooperation rate in the last k rounds."""
        if history.round_number == 0:
            return 1.0
        rounds_to_check = min(k, history.round_number)
        total_players = 0
        total_cooperators = 0
        for i in range(rounds_to_check):
            round_idx = history.round_number - 1 - i
            if history.my_actions[round_idx]:
                total_cooperators += 1
            total_players += 1
            for player_idx in range(self.n_players - 1):
                if history.opponent_actions[round_idx, player_idx]:
                    total_cooperators += 1
                total_players += 1
        return total_cooperators / total_players if total_players > 0 else 1.0

    def _count_consecutive_low_cooperation_rounds(self, history: PlayerHistory) -> int:
        """Count consecutive rounds with low cooperation (< 0.5) from most recent."""
        count = 0
        for i in range(history.round_number):
            round_idx = history.round_number - 1 - i
            round_cooperation_rate = self._get_cooperation_rate_for_round(history, round_idx)
            if round_cooperation_rate < 0.5:
                count += 1
            else:
                break
        return count

    def _get_cooperation_rate_for_round(self, history: PlayerHistory, round_idx: int) -> float:
        """Get cooperation rate for a specific round."""
        cooperators = 0
        total_players = self.n_players
        if history.my_actions[round_idx]:
            cooperators += 1
        for player_idx in range(self.n_players - 1):
            if history.opponent_actions[round_idx, player_idx]:
                cooperators += 1
        return cooperators / total_players

    def _adaptive_response(self, history: PlayerHistory, stock_level: float) -> Action:
        """Main adaptive response logic for middle rounds."""
        recent_cooperation_rate = self._get_recent_cooperation_rate(history, 2)
        if recent_cooperation_rate >= 0.75:
            return Action.C
        elif recent_cooperation_rate >= 0.5:
            consecutive_low = self._count_consecutive_low_cooperation_rounds(history)
            if consecutive_low <= 1:
                return Action.C
            else:
                return Action.D
        elif stock_level < self.capacity * 0.3:
            return Action.D
        elif random.random() < 0.2:
            return Action.C
        else:
            return Action.D

    def _endgame_strategy(self, history: PlayerHistory, current_round: int, stock_level: float) -> Action:
        """Strategy for the last two rounds."""
        recent_cooperation_rate = self._get_recent_cooperation_rate(history, 2)
        if current_round == self.n_rounds:
            return Action.D
        elif current_round == self.n_rounds - 1:
            if stock_level >= self.capacity * 0.5 and recent_cooperation_rate >= 0.6:
                return Action.C
            else:
                return Action.D
        return Action.C

class Strategy_COOPERATIVE_114(BaseStrategy):
    """
    Adaptive Cooperative Strategy with Punishment and Forgiveness.
    
    Prioritizes long-term sustainability while being responsive to opponent behavior.
    Starts cooperative, implements measured punishment for defection, with built-in 
    forgiveness mechanisms to restore cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        current_stock = self._estimate_current_stock(history)
        if current_stock < self.capacity * 0.2:
            return Action.C
        if current_round == self.r:
            return self._final_round_decision(history, current_stock)
        if current_round == 2:
            if np.all(history.opponent_actions[0]):
                return Action.C
            else:
                return Action.D
        return self._adaptive_response(history, current_stock, current_round)

    def _estimate_current_stock(self, history):
        """Estimate current stock level based on game history"""
        stock = self.capacity
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            cooperators = int(my_action) + np.sum(opponent_actions)
            defectors = self.n - cooperators
            cooperator_consumption = stock / (2 * self.n)
            defector_consumption = stock / self.n
            total_consumption = cooperators * cooperator_consumption + defectors * defector_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _final_round_decision(self, history, current_stock):
        """Decision logic for the final round"""
        if current_stock > self.capacity * 0.3:
            last_round_cooperators = np.sum(history.opponent_actions[-1])
            cooperation_rate = last_round_cooperators / (self.n - 1)
            if cooperation_rate >= 0.5:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C

    def _adaptive_response(self, history, current_stock, current_round):
        """Main adaptive response logic for rounds 3 to r-1"""
        last_round_idx = history.round_number - 1
        last_round_cooperators = np.sum(history.opponent_actions[last_round_idx])
        cooperation_rate = last_round_cooperators / (self.n - 1)
        if cooperation_rate >= 0.75:
            return Action.C
        elif cooperation_rate >= 0.5:
            i_cooperated_last = history.my_actions[last_round_idx]
            recent_payoff_declining = self._is_payoff_trend_declining(history)
            if i_cooperated_last and recent_payoff_declining:
                return Action.D
            else:
                return Action.C
        else:
            rounds_since_cooperation = self._rounds_since_last_cooperation(history)
            if rounds_since_cooperation >= 2:
                return Action.C
            else:
                return Action.D

    def _is_payoff_trend_declining(self, history):
        """Check if recent payoff trend is declining"""
        if history.round_number < 3:
            return False
        recent_avg = np.mean(history.my_payoffs[-2:])
        previous_avg = np.mean(history.my_payoffs[-4:-2]) if history.round_number >= 4 else history.my_payoffs[0]
        return recent_avg < previous_avg * 0.9

    def _rounds_since_last_cooperation(self, history):
        """Count rounds since I last played C"""
        rounds_since = 0
        for i in range(history.round_number - 1, -1, -1):
            if history.my_actions[i]:
                break
            rounds_since += 1
        return rounds_since

class Strategy_COOPERATIVE_115(BaseStrategy):
    """
    Adaptive Trust Builder: A cooperative strategy that prioritizes long-term sustainability 
    while building trust through consistent cooperation, with defensive mechanisms against exploitation.
    
    Uses phases: trust building, adaptive cooperation, endgame cooperation, and final round integrity.
    Only defects when facing both resource crisis AND widespread defection by others.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        current_phase = self._determine_phase(current_round)
        current_stock = self._estimate_current_stock(history)
        if current_phase == 'trust_building':
            return Action.C
        elif current_phase == 'adaptive':
            if current_stock < self.capacity / 3:
                defection_rate = self._get_last_round_defection_rate(history)
                if defection_rate > 0.5:
                    return Action.D
            return Action.C
        elif current_phase == 'endgame':
            if current_stock < self.capacity / 4:
                remaining_rounds = self.n_rounds - current_round + 1
                if not self._can_recover_through_cooperation(current_stock, remaining_rounds):
                    return Action.D
            return Action.C
        else:
            return Action.C

    def _determine_phase(self, round_number):
        """Determine which phase we're in based on round number."""
        if round_number <= self.n_rounds / 3:
            return 'trust_building'
        elif round_number <= 2 * self.n_rounds / 3:
            return 'adaptive'
        elif round_number < self.n_rounds:
            return 'endgame'
        else:
            return 'final'

    def _estimate_current_stock(self, history):
        """Estimate current stock level from the most recent round's payoffs."""
        if history.round_number == 0:
            return self.capacity
        last_round_idx = history.round_number - 1
        my_last_payoff = history.my_payoffs[last_round_idx]
        my_last_action = history.my_actions[last_round_idx]
        if my_last_action:
            estimated_stock = my_last_payoff * (2 * self.n_players)
        else:
            estimated_stock = my_last_payoff * self.n_players
        return max(0, estimated_stock)

    def _get_last_round_defection_rate(self, history):
        """Calculate the defection rate among opponents in the last round."""
        if history.round_number == 0:
            return 0.0
        last_round_idx = history.round_number - 1
        opponent_actions = history.opponent_actions[last_round_idx]
        defectors = sum((1 for action in opponent_actions if not action))
        total_opponents = len(opponent_actions)
        return defectors / total_opponents if total_opponents > 0 else 0.0

    def _can_recover_through_cooperation(self, current_stock, remaining_rounds):
        """Check if cooperation can mathematically restore sustainable levels."""
        if remaining_rounds <= 1 or current_stock <= 0:
            return False
        stock_after_consumption = current_stock * 0.5
        potential_growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
        return potential_growth > 0 and remaining_rounds > 2

class Strategy_COOPERATIVE_116(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Stock Monitoring (ATTSM) Strategy.
    
    Balances cooperative intent with adaptive response to opponent behavior and 
    environmental conditions. Starts cooperatively but adjusts based on both 
    opponent actions and the health of the common resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        stock = self._calculate_current_stock(history)
        stock_health = stock / self.capacity
        recent_rounds = min(3, current_round - 1)
        recent_cooperation_rate = self._calculate_recent_cooperation_rate(history, recent_rounds)
        if stock_health < 0.3:
            if recent_cooperation_rate >= 0.6:
                return Action.C
            else:
                return Action.D
        if current_round == self.n_rounds:
            if recent_cooperation_rate >= 0.5:
                return Action.C
            else:
                return Action.D
        if recent_cooperation_rate >= 0.7:
            return Action.C
        elif recent_cooperation_rate >= 0.4:
            cooperation_probability = 0.3 + 0.4 * stock_health
            if random.random() < cooperation_probability:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory, recent_rounds: int) -> float:
        """Calculate the cooperation rate of opponents over the last few rounds."""
        if history.round_number == 0:
            return 0.0
        start_round = max(0, history.round_number - recent_rounds)
        total_decisions = 0
        total_cooperations = 0
        for round_idx in range(start_round, history.round_number):
            cooperations = np.sum(history.opponent_actions[round_idx])
            total_cooperations += cooperations
            total_decisions += len(history.opponent_actions[round_idx])
        if total_decisions == 0:
            return 0.0
        return total_cooperations / total_decisions

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate the current stock level based on game history."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            total_consumption = 0.0
            if history.my_actions[round_idx]:
                my_consumption = stock / (2 * self.n_players)
            else:
                my_consumption = stock / self.n_players
            total_consumption += my_consumption
            for opponent_idx in range(len(history.opponent_actions[round_idx])):
                if history.opponent_actions[round_idx][opponent_idx]:
                    opponent_consumption = stock / (2 * self.n_players)
                else:
                    opponent_consumption = stock / self.n_players
                total_consumption += opponent_consumption
            stock_after_consumption = max(0.0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

class Strategy_COOPERATIVE_117(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Majority"
    
    This strategy aims to maintain long-term sustainability of the common pool while being 
    robust against exploitation. It balances cooperation with defensive measures based on 
    observed group behavior and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_num = history.round_number + 1
        current_stock = self._calculate_current_stock(history)
        if current_stock <= self.game_description.capacity / 4:
            return Action.C
        if current_stock >= self.game_description.capacity:
            return Action.D
        if round_num == self.game_description.n_rounds:
            if current_stock > self.game_description.capacity / 2:
                return Action.C
            else:
                return Action.D
        if current_stock <= 0:
            return Action.C
        previous_round_idx = history.round_number - 1
        other_players_actions = history.opponent_actions[previous_round_idx]
        cooperators = sum(other_players_actions)
        defectors = len(other_players_actions) - cooperators
        if cooperators >= defectors:
            return Action.C
        else:
            return Action.D

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game history."""
        stock = float(self.game_description.capacity)
        n = self.game_description.n_players
        capacity = float(self.game_description.capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0.0
            if my_action:
                total_consumption += stock / (2 * n)
            else:
                total_consumption += stock / n
            for opponent_cooperated in opponent_actions:
                if opponent_cooperated:
                    total_consumption += stock / (2 * n)
                else:
                    total_consumption += stock / n
            stock_after_consumption = max(0.0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            else:
                growth = 0.0
            stock = min(stock_after_consumption + growth, capacity)
        return stock

class Strategy_COOPERATIVE_118(BaseStrategy):
    """
    Adaptive Trust with Sustainability Guard strategy.
    
    Balances cooperation with protection against resource collapse by:
    1. Starting with trust-building cooperation
    2. Following majority behavior in middle rounds
    3. Prioritizing sustainability when resources are critically low
    4. Using measured punishment for low cooperation during stress
    5. Maintaining cooperative end-game behavior
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.trust_phase_length = min(3, math.floor(self.n_rounds * 0.25))
        self.endgame_threshold = math.floor(self.n_rounds * 0.9)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round <= self.trust_phase_length:
            return Action.C
        last_round_idx = history.round_number - 1
        last_round_cooperators = np.sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            last_round_cooperators += 1
        last_round_coop_rate = last_round_cooperators / self.n_players
        current_stock = self._estimate_current_stock(history)
        if current_stock < self.capacity / 4:
            return Action.C
        if current_round >= self.endgame_threshold:
            if current_round == self.n_rounds:
                return Action.C
            if last_round_coop_rate >= 0.75:
                return Action.C
            else:
                return Action.D
        if current_stock < self.capacity / 2 and last_round_coop_rate < 0.5:
            return Action.D
        if last_round_coop_rate >= 0.5:
            return Action.C
        else:
            return Action.D

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """
        Estimate current stock level based on game history.
        This is a simplified estimation based on total consumption patterns.
        """
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            cooperators = np.sum(history.opponent_actions[round_idx])
            if history.my_actions[round_idx]:
                cooperators += 1
            defectors = self.n_players - cooperators
            coop_consumption = cooperators * (stock / (2 * self.n_players))
            defect_consumption = defectors * (stock / self.n_players)
            total_consumption = coop_consumption + defect_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

class Strategy_COOPERATIVE_119(BaseStrategy):
    """
    Conditional Cooperator with Sustainability Guardian strategy.
    
    This strategy balances cooperation with resource preservation by:
    1. Starting cooperatively and maintaining cooperation when others reciprocate
    2. Defecting temporarily when facing high defection rates (except in emergency situations)
    3. Always cooperating when stock is critically low or in the final rounds
    4. Using forgiveness to return to cooperation quickly after punishment
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.sustainability_threshold = game_description.capacity * 0.3

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        current_stock = self._estimate_current_stock(history)
        if current_stock <= self.sustainability_threshold:
            return Action.C
        if current_round >= total_rounds - 2:
            return Action.C
        last_round_idx = current_round - 1
        defectors_last_round = np.sum(history.opponent_actions[last_round_idx] == False)
        defection_rate = defectors_last_round / n_players
        rounds_to_check = min(3, current_round)
        start_idx = max(0, current_round - rounds_to_check)
        my_recent_cooperations = np.sum(history.my_actions[start_idx:current_round] == True)
        my_recent_cooperation_rate = my_recent_cooperations / rounds_to_check
        if defection_rate <= 0.25:
            return Action.C
        elif defection_rate <= 0.5:
            return Action.C
        else:
            return Action.D

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """
        Estimate current stock level based on game history.
        This is a simplified estimation assuming we start at capacity.
        """
        current_stock = float(self.game_description.capacity)
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        for round_idx in range(history.round_number):
            cooperators = np.sum(history.opponent_actions[round_idx] == True)
            if history.my_actions[round_idx]:
                cooperators += 1
            defectors = n_players - cooperators
            coop_consumption = cooperators * (current_stock / (2 * n_players))
            defect_consumption = defectors * (current_stock / n_players)
            total_consumption = coop_consumption + defect_consumption
            stock_after_consumption = max(0, current_stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
                current_stock = min(stock_after_consumption + growth, capacity)
            else:
                current_stock = 0
        return current_stock

class Strategy_COOPERATIVE_120(BaseStrategy):
    """
    Adaptive Trust with Sustainability Focus - A cooperative strategy that prioritizes 
    long-term resource sustainability while building trust and protecting against exploitation.
    Uses stock level and cooperation rates to make adaptive decisions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        n_rounds = self.game_description.n_rounds
        stock_level = self._calculate_current_stock(history)
        if stock_level <= capacity * 0.2:
            return Action.C
        if current_round == n_rounds:
            if stock_level >= capacity * 0.5:
                return Action.C
            else:
                return Action.D
        last_round_idx = history.round_number - 1
        cooperators_last_round = np.sum(history.opponent_actions[last_round_idx])
        cooperation_ratio = cooperators_last_round / n_players
        my_recent_cooperation = self._get_my_recent_cooperation_rate(history, 3)
        if cooperation_ratio >= 0.75:
            return Action.C
        if cooperation_ratio >= 0.5 and stock_level >= capacity * 0.6:
            return Action.C
        if cooperation_ratio < 0.25:
            if my_recent_cooperation >= 0.67:
                return Action.D
            else:
                return Action.C
        if stock_level >= capacity * 0.4:
            return Action.C
        else:
            return Action.D

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate the current stock level based on game dynamics."""
        stock = float(self.game_description.capacity)
        n_players = self.game_description.n_players
        capacity = float(self.game_description.capacity)
        for round_idx in range(history.round_number):
            total_consumption = 0.0
            if history.my_actions[round_idx]:
                my_consumption = stock / (2 * n_players)
            else:
                my_consumption = stock / n_players
            total_consumption += my_consumption
            for player_idx in range(n_players - 1):
                if history.opponent_actions[round_idx, player_idx]:
                    opponent_consumption = stock / (2 * n_players)
                else:
                    opponent_consumption = stock / n_players
                total_consumption += opponent_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            stock = min(stock_after_consumption + growth, capacity)
        return stock

    def _get_my_recent_cooperation_rate(self, history: PlayerHistory, lookback_rounds: int) -> float:
        """Calculate my cooperation rate over the last N rounds."""
        if history.round_number == 0:
            return 1.0
        start_idx = max(0, history.round_number - lookback_rounds)
        recent_actions = history.my_actions[start_idx:]
        if len(recent_actions) == 0:
            return 1.0
        return np.mean(recent_actions.astype(float))

class Strategy_COOPERATIVE_121(BaseStrategy):
    """
    Forgiving Tit-for-Tat with Stock Protection strategy.
    
    Starts cooperative and reciprocates majority behavior, but prioritizes
    resource protection when stock becomes critically low. Includes forgiveness
    mechanism to restart cooperation cycles.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_threshold = game_description.capacity * 0.3
        self.cooperation_threshold = 0.5
        self.forgiveness_probability = 0.2

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_stock = self._estimate_current_stock(history)
        if current_stock <= self.critical_stock_threshold:
            return Action.C
        prev_round_idx = history.round_number - 1
        my_prev_action = history.my_actions[prev_round_idx]
        opponent_prev_actions = history.opponent_actions[prev_round_idx]
        total_cooperators = int(my_prev_action) + sum(opponent_prev_actions)
        cooperation_rate = total_cooperators / self.game_description.n_players
        if cooperation_rate >= self.cooperation_threshold:
            return Action.C
        elif random.random() < self.forgiveness_probability:
            return Action.C
        else:
            return Action.D

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """
        Estimate current stock level based on game history and dynamics.
        """
        stock = float(self.game_description.capacity)
        n = self.game_description.n_players
        capacity = float(self.game_description.capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0.0
            if my_action:
                total_consumption += stock / (2 * n)
            else:
                total_consumption += stock / n
            for opp_action in opponent_actions:
                if opp_action:
                    total_consumption += stock / (2 * n)
                else:
                    total_consumption += stock / n
            stock_after_consumption = max(0.0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            else:
                growth = 0.0
            stock = min(stock_after_consumption + growth, capacity)
            if stock < 0:
                stock = 0.0
        return stock

class Strategy_COOPERATIVE_122(BaseStrategy):
    """
    Graduated Reciprocity with Stock Protection: A cooperative strategy that starts 
    cooperatively, protects depleted resources, and uses graduated reciprocity 
    based on observed cooperation rates and resource health.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.base_threshold = 0.4
        self.critical_stock_ratio = 0.2

    def _calculate_stock_level(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game dynamics."""
        if history.round_number == 0:
            return self.game_description.capacity
        stock = float(self.game_description.capacity)
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        for round_idx in range(history.round_number):
            total_consumption = 0.0
            if history.my_actions[round_idx]:
                my_consumption = stock / (2 * n)
            else:
                my_consumption = stock / n
            total_consumption += my_consumption
            for player_idx in range(n - 1):
                if history.opponent_actions[round_idx, player_idx]:
                    opponent_consumption = stock / (2 * n)
                else:
                    opponent_consumption = stock / n
                total_consumption += opponent_consumption
            stock_after_consumption = max(0.0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            stock = min(stock_after_consumption + growth, capacity)
        return stock

    def _get_cooperation_rate_last_round(self, history: PlayerHistory) -> float:
        """Get the cooperation rate from the last round."""
        if history.round_number == 0:
            return 1.0
        last_round_idx = history.round_number - 1
        cooperators = sum(history.opponent_actions[last_round_idx])
        total_opponents = self.game_description.n_players - 1
        return cooperators / total_opponents if total_opponents > 0 else 1.0

    def _get_trend_adjustment(self, history: PlayerHistory) -> float:
        """Calculate trend adjustment based on cooperation rates over last 3 rounds."""
        if history.round_number < 3:
            return 0.0
        rates = []
        for i in range(3):
            round_idx = history.round_number - 1 - i
            if round_idx >= 0:
                cooperators = sum(history.opponent_actions[round_idx])
                total_opponents = self.game_description.n_players - 1
                rate = cooperators / total_opponents if total_opponents > 0 else 1.0
                rates.append(rate)
        rates.reverse()
        if len(rates) >= 2:
            if rates[-1] > rates[0]:
                return -0.1
            elif rates[-1] < rates[0]:
                return 0.1
        return 0.0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        current_round = history.round_number + 1
        stock_level = self._calculate_stock_level(history)
        critical_threshold = capacity * self.critical_stock_ratio
        if stock_level <= critical_threshold:
            return Action.C
        if current_round == self.game_description.n_rounds:
            stock_health = stock_level / capacity
            if stock_health >= 0.7:
                return Action.C
            else:
                return Action.D
        cooperation_rate = self._get_cooperation_rate_last_round(history)
        threshold = self.base_threshold
        stock_health_ratio = stock_level / capacity
        stock_bonus = min(0.3, (stock_health_ratio - 0.5) * 0.6)
        threshold -= stock_bonus
        trend_adjustment = self._get_trend_adjustment(history)
        threshold += trend_adjustment
        threshold = max(0.1, min(0.9, threshold))
        if cooperation_rate >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_123(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Harvest with Graduated Response"
    
    This strategy prioritizes long-term sustainability while being responsive to other players' behavior.
    It starts with full cooperation but adapts based on observed defection patterns to maintain 
    both sustainability and fairness.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round = history.round_number + 1
        current_stock = self._calculate_current_stock(history, capacity, n_players)
        stock_ratio = current_stock / capacity
        recent_defection_rate = self._calculate_recent_defection_rate(history, n_players)
        if stock_ratio <= 0.1:
            if recent_defection_rate <= 0.1:
                return Action.C
            else:
                return Action.D
        if current_round == n_rounds:
            if stock_ratio <= 0.2 or recent_defection_rate >= 0.5:
                return Action.D
            else:
                return Action.C
        if stock_ratio >= 0.5:
            if recent_defection_rate >= 0.75:
                return Action.D
            elif recent_defection_rate >= 0.5:
                return Action.C if stock_ratio >= 0.3 else Action.D
            else:
                return Action.C
        elif recent_defection_rate >= 0.5:
            return Action.D
        elif recent_defection_rate >= 0.25:
            was_exploited = self._was_exploited_last_round(history, n_players)
            return Action.D if was_exploited else Action.C
        else:
            return Action.C

    def _calculate_current_stock(self, history: PlayerHistory, capacity: int, n_players: int) -> float:
        """Calculate current stock level based on game history"""
        stock = float(capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            cooperators = int(my_action) + sum(opponent_actions)
            defectors = n_players - cooperators
            coop_consumption = cooperators * (stock / (2 * n_players))
            defect_consumption = defectors * (stock / n_players)
            total_consumption = coop_consumption + defect_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            stock = min(stock_after_consumption + growth, capacity)
        return stock

    def _calculate_recent_defection_rate(self, history: PlayerHistory, n_players: int) -> float:
        """Calculate defection rate over the last 3 rounds (or fewer if not available)"""
        rounds_to_check = min(3, history.round_number)
        if rounds_to_check == 0:
            return 0.0
        total_defections = 0
        total_decisions = 0
        for i in range(rounds_to_check):
            round_idx = history.round_number - 1 - i
            if not history.my_actions[round_idx]:
                total_defections += 1
            opponent_defections = sum((1 for action in history.opponent_actions[round_idx] if not action))
            total_defections += opponent_defections
            total_decisions += n_players
        return total_defections / total_decisions if total_decisions > 0 else 0.0

    def _was_exploited_last_round(self, history: PlayerHistory, n_players: int) -> bool:
        """Check if player was exploited in the last round (cooperated while others defected)"""
        if history.round_number == 0:
            return False
        last_round_idx = history.round_number - 1
        my_last_action = history.my_actions[last_round_idx]
        opponent_last_actions = history.opponent_actions[last_round_idx]
        if my_last_action:
            opponent_defections = sum((1 for action in opponent_last_actions if not action))
            return opponent_defections > len(opponent_last_actions) / 2
        return False

class Strategy_COOPERATIVE_124(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Majority Coalition"
    
    Aims to maintain long-term sustainability while being cooperative, but adapts based on 
    observed behavior to prevent exploitation. Seeks to build and maintain a coalition of 
    cooperators while having mechanisms to respond to defection patterns.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        current_stock = self._estimate_current_stock(history)
        stock_health = current_stock / self.capacity
        if current_round == 2:
            return Action.C
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            cooperators_last_round += 1
        cooperation_rate = cooperators_last_round / self.n_players
        if stock_health < 0.3:
            return self._crisis_response(history, cooperation_rate, stock_health)
        remaining_rounds = self.n_rounds - current_round + 1
        if remaining_rounds <= 0.2 * self.n_rounds:
            return self._endgame_strategy(history, cooperation_rate, stock_health)
        if cooperation_rate >= 0.5:
            return Action.C
        else:
            return self._adaptive_response(history, cooperation_rate, stock_health)

    def _estimate_current_stock(self, history: None | PlayerHistory) -> float:
        """Estimate current stock level based on game dynamics"""
        if history is None:
            return self.capacity
        stock = self.capacity
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0.0
            if my_action:
                total_consumption += stock / (2 * self.n_players)
            else:
                total_consumption += stock / self.n_players
            for opponent_action in opponent_actions:
                if opponent_action:
                    total_consumption += stock / (2 * self.n_players)
                else:
                    total_consumption += stock / self.n_players
            stock_after_consumption = max(0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
                stock = min(stock_after_consumption + growth, self.capacity)
            else:
                stock = 0
        return stock

    def _crisis_response(self, history: PlayerHistory, cooperation_rate: float, stock_health: float) -> Action:
        """Handle crisis situations when stock < 30% capacity"""
        if stock_health < 0.1:
            return Action.C
        elif cooperation_rate > 0.5:
            return Action.C
        else:
            return Action.D

    def _endgame_strategy(self, history: PlayerHistory, cooperation_rate: float, stock_health: float) -> Action:
        """Handle endgame situations (final 20% of rounds)"""
        current_round = history.round_number + 1
        if current_round == self.n_rounds:
            if stock_health > 0.5 and cooperation_rate > 0.5:
                return Action.C
            else:
                return Action.D
        if stock_health > 0.8:
            return Action.C
        elif self._get_recent_cooperation_rate(history, 3) > 0.5:
            return Action.C
        else:
            return Action.D

    def _adaptive_response(self, history: PlayerHistory, cooperation_rate: float, stock_health: float) -> Action:
        """Handle situations where minority is cooperating"""
        defection_trend = self._calculate_defection_trend(history)
        my_recent_payoff_trend = self._calculate_my_payoff_trend(history)
        if defection_trend > 0.6 and my_recent_payoff_trend < 0:
            return Action.D
        if stock_health > 0.7 and cooperation_rate > 0.25:
            return Action.C
        if self._check_solo_cooperator(history):
            return Action.D
        return Action.D if cooperation_rate < 0.5 else Action.C

    def _calculate_defection_trend(self, history: PlayerHistory) -> float:
        """Calculate defection trend over last 3 rounds"""
        rounds_to_check = min(3, history.round_number)
        if rounds_to_check == 0:
            return 0.0
        total_defection_rate = 0.0
        for i in range(rounds_to_check):
            round_idx = history.round_number - 1 - i
            cooperators = sum(history.opponent_actions[round_idx])
            if history.my_actions[round_idx]:
                cooperators += 1
            defection_rate = 1.0 - cooperators / self.n_players
            total_defection_rate += defection_rate
        return total_defection_rate / rounds_to_check

    def _calculate_my_payoff_trend(self, history: PlayerHistory) -> float:
        """Calculate my payoff trend over last 3 rounds"""
        rounds_to_check = min(3, history.round_number)
        if rounds_to_check <= 1:
            return 0.0
        recent_payoffs = []
        for i in range(rounds_to_check):
            round_idx = history.round_number - 1 - i
            recent_payoffs.append(history.my_payoffs[round_idx])
        if len(recent_payoffs) >= 2:
            early_avg = np.mean(recent_payoffs[len(recent_payoffs) // 2:])
            late_avg = np.mean(recent_payoffs[:len(recent_payoffs) // 2])
            return late_avg - early_avg
        return 0.0

    def _get_recent_cooperation_rate(self, history: PlayerHistory, rounds_back: int) -> float:
        """Get cooperation rate over recent rounds"""
        rounds_to_check = min(rounds_back, history.round_number)
        if rounds_to_check == 0:
            return 0.5
        total_cooperation = 0
        total_decisions = 0
        for i in range(rounds_to_check):
            round_idx = history.round_number - 1 - i
            cooperators = sum(history.opponent_actions[round_idx])
            if history.my_actions[round_idx]:
                cooperators += 1
            total_cooperation += cooperators
            total_decisions += self.n_players
        return total_cooperation / total_decisions if total_decisions > 0 else 0.5

    def _check_solo_cooperator(self, history: PlayerHistory) -> bool:
        """Check if I've been the only cooperator for 3+ consecutive rounds"""
        if history.round_number < 3:
            return False
        consecutive_solo = 0
        for i in range(min(3, history.round_number)):
            round_idx = history.round_number - 1 - i
            if history.my_actions[round_idx]:
                opponent_cooperators = sum(history.opponent_actions[round_idx])
                if opponent_cooperators == 0:
                    consecutive_solo += 1
                else:
                    break
            else:
                break
        return consecutive_solo >= 3

class Strategy_COOPERATIVE_125(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Harvest"
    
    Prioritizes long-term sustainability while being responsive to opponent behavior.
    Starts cooperatively but adapts to prevent exploitation while maintaining 
    cooperative potential. Uses graduated responses based on defection rates and
    resource health.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.r:
            return self._final_round_strategy(history)
        last_round_idx = history.round_number - 1
        last_round_opponents = history.opponent_actions[last_round_idx]
        defectors_last_round = sum((1 for action in last_round_opponents if not action))
        defection_rate = defectors_last_round / self.n
        stock_health = self._estimate_stock_health(history)
        base_tolerance = 0.3
        size_adjustment = min(0.2, (self.n - 2) * 0.05)
        tolerance_threshold = base_tolerance + size_adjustment
        if stock_health < 0.1:
            return Action.D
        if self._check_high_cooperation(history):
            return Action.C
        if defection_rate <= tolerance_threshold and stock_health > 0.4:
            return Action.C
        elif defection_rate > 0.6 or stock_health < 0.2:
            return Action.D
        else:
            coop_probability = (1 - defection_rate) * stock_health
            if current_round > 0.8 * self.r:
                coop_probability *= 0.9
            return Action.C if random.random() < coop_probability else Action.D

    def _final_round_strategy(self, history: PlayerHistory) -> Action:
        """Strategy for the final round"""
        stock_health = self._estimate_stock_health(history)
        if stock_health < 0.15:
            return Action.D
        total_cooperative_actions = 0
        total_actions = 0
        for round_idx in range(1, history.round_number):
            for opponent_action in history.opponent_actions[round_idx]:
                total_cooperative_actions += int(opponent_action)
                total_actions += 1
        cooperation_history = total_cooperative_actions / total_actions if total_actions > 0 else 0.5
        if cooperation_history > 0.6:
            return Action.C
        else:
            current_stock = stock_health * self.capacity
            expected_coop_payoff = current_stock / (2 * self.n)
            expected_defect_payoff = current_stock / self.n
            if expected_defect_payoff - expected_coop_payoff > self.capacity / (4 * self.n):
                return Action.D
            else:
                return Action.C

    def _estimate_stock_health(self, history: PlayerHistory) -> float:
        """Estimate current stock health based on game dynamics"""
        if history.round_number == 0:
            return 1.0
        estimated_stock = self.capacity
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            cooperators = int(my_action) + sum((int(action) for action in opponent_actions))
            defectors = self.n - cooperators
            coop_consumption = cooperators * (estimated_stock / (2 * self.n))
            defect_consumption = defectors * (estimated_stock / self.n)
            total_consumption = coop_consumption + defect_consumption
            stock_after_consumption = max(0, estimated_stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            estimated_stock = min(stock_after_consumption + growth, self.capacity)
        return estimated_stock / self.capacity

    def _check_high_cooperation(self, history: PlayerHistory) -> bool:
        """Check if we're in a high cooperation environment"""
        if history.round_number < 2:
            return False
        total_cooperators = 0
        total_players = 0
        for round_offset in [1, 2]:
            if history.round_number >= round_offset:
                round_idx = history.round_number - round_offset
                total_cooperators += int(history.my_actions[round_idx])
                total_players += 1
                for opponent_action in history.opponent_actions[round_idx]:
                    total_cooperators += int(opponent_action)
                    total_players += 1
        cooperation_rate = total_cooperators / total_players if total_players > 0 else 0
        return cooperation_rate >= 0.8

class Strategy_COOPERATIVE_126(BaseStrategy):
    """
    Adaptive Sustainability Cooperator (ASC): A cooperative strategy that balances 
    sustainability with strategic responses to defectors. Defaults to cooperation 
    but implements limited punishment against persistent free riders while 
    prioritizing resource preservation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.6
        self.forgiveness_rounds = 2
        self.critical_stock_ratio = 0.3
        self.punishment_started_round = None

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_num = history.round_number
        n = self.game_description.n_players
        final_round = self.game_description.n_rounds
        current_stock_ratio = self._estimate_stock_ratio(history)
        if current_stock_ratio < self.critical_stock_ratio:
            return Action.C
        if round_num >= final_round:
            return Action.C
        last_round_cooperators = sum(history.opponent_actions[round_num - 1])
        cooperation_rate = last_round_cooperators / n
        lookback = min(3, round_num)
        my_recent_defections = sum((1 for i in range(max(0, round_num - lookback), round_num) if not history.my_actions[i]))
        if my_recent_defections >= 2:
            return Action.C
        if cooperation_rate >= self.cooperation_threshold and current_stock_ratio > 0.5:
            return Action.C
        persistent_defectors = self._count_persistent_defectors(history)
        if persistent_defectors > 0 and cooperation_rate < self.cooperation_threshold:
            if self.punishment_started_round is None:
                self.punishment_started_round = round_num
                return Action.D
            rounds_punishing = round_num - self.punishment_started_round + 1
            if rounds_punishing <= self.forgiveness_rounds:
                return Action.D
            else:
                self.punishment_started_round = None
                return Action.C
        if self.punishment_started_round is not None:
            self.punishment_started_round = None
        return Action.C

    def _estimate_stock_ratio(self, history: PlayerHistory) -> float:
        """Estimate current stock ratio based on recent payoff patterns."""
        if history.round_number == 0:
            return 1.0
        recent_payoff = history.my_payoffs[-1]
        n = self.game_description.n_players
        max_theoretical_payoff = self.game_description.capacity / (2 * n)
        estimated_ratio = min(1.0, max(0.0, recent_payoff / max_theoretical_payoff))
        return estimated_ratio

    def _count_persistent_defectors(self, history: PlayerHistory) -> int:
        """Count players with defection rate above 70% in recent rounds."""
        if history.round_number < 2:
            return 0
        lookback = min(3, history.round_number)
        persistent_count = 0
        n_opponents = self.game_description.n_players - 1
        for player in range(n_opponents):
            defections = 0
            for round_idx in range(max(0, history.round_number - lookback), history.round_number):
                if not history.opponent_actions[round_idx, player]:
                    defections += 1
            defection_rate = defections / lookback
            if defection_rate > 0.7:
                persistent_count += 1
        return persistent_count

class Strategy_COOPERATIVE_127(BaseStrategy):
    """
    Adaptive Forgiveness Strategy (AFS) - Balances cooperation with protection against exploitation,
    using stock health as a key signal for strategic adaptation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defection_start_health = None
        self.consecutive_cooperation_rounds = 0
        self.last_stock_health = None

    def _calculate_stock_health(self, history: PlayerHistory) -> float:
        """Calculate current stock health based on game dynamics."""
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        stock = capacity
        for round_idx in range(history.round_number):
            my_consumption = stock / (2 * n) if history.my_actions[round_idx] else stock / n
            total_opponent_consumption = 0
            for opponent_idx in range(n - 1):
                if history.opponent_actions[round_idx, opponent_idx]:
                    total_opponent_consumption += stock / (2 * n)
                else:
                    total_opponent_consumption += stock / n
            total_consumption = my_consumption + total_opponent_consumption
            stock_after_consumption = stock - total_consumption
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            stock = min(stock_after_consumption + growth, capacity)
        return stock / capacity

    def _get_cooperation_rate(self, history: PlayerHistory) -> float:
        """Get cooperation rate from the most recent round."""
        if history.round_number == 0:
            return 1.0
        last_round = history.round_number - 1
        cooperators = sum(history.opponent_actions[last_round])
        return cooperators / (self.game_description.n_players - 1)

    def _classify_phase(self, stock_health: float) -> str:
        """Classify current phase based on stock health."""
        if stock_health >= 0.7:
            return 'HEALTHY'
        elif stock_health >= 0.3:
            return 'CRITICAL'
        else:
            return 'COLLAPSE'

    def _check_sustained_cooperation(self, history: PlayerHistory) -> bool:
        """Check if opponents showed sustained cooperation (75% for 2+ rounds)."""
        if history.round_number < 2:
            return False
        for i in range(2):
            round_idx = history.round_number - 1 - i
            cooperators = sum(history.opponent_actions[round_idx])
            cooperation_rate = cooperators / (self.game_description.n_players - 1)
            if cooperation_rate < 0.75:
                return False
        return True

    def _check_equilibrium(self, history: PlayerHistory) -> bool:
        """Check if all players cooperated for 3+ consecutive rounds with healthy stock."""
        if history.round_number < 3:
            return False
        for i in range(3):
            round_idx = history.round_number - 1 - i
            if not history.my_actions[round_idx]:
                return False
            cooperators = sum(history.opponent_actions[round_idx])
            if cooperators != self.game_description.n_players - 1:
                return False
        if self.last_stock_health and self.last_stock_health >= 0.7:
            return True
        return False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        stock_health = self._calculate_stock_health(history)
        cooperation_rate = self._get_cooperation_rate(history)
        phase = self._classify_phase(stock_health)
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            if stock_health >= 0.5:
                return Action.C
            else:
                return Action.D
        if stock_health < 0.1:
            return Action.D
        if self._check_equilibrium(history):
            return Action.C
        if history.round_number > 0:
            last_round = history.round_number - 1
            all_cooperated = history.my_actions[last_round] and sum(history.opponent_actions[last_round]) == self.game_description.n_players - 1
            if all_cooperated:
                self.consecutive_cooperation_rounds += 1
            else:
                self.consecutive_cooperation_rounds = 0
        should_cooperate = False
        if phase == 'HEALTHY' and cooperation_rate >= 0.5:
            should_cooperate = True
        elif phase == 'CRITICAL' and cooperation_rate >= 0.7:
            should_cooperate = True
        elif phase == 'COLLAPSE' and cooperation_rate >= 0.8:
            should_cooperate = True
        if not should_cooperate and self.defection_start_health is not None:
            health_improvement = stock_health - self.defection_start_health
            if health_improvement >= 0.1 or self._check_sustained_cooperation(history):
                should_cooperate = True
                self.defection_start_health = None
        if not should_cooperate and self.defection_start_health is None:
            self.defection_start_health = stock_health
        elif should_cooperate:
            self.defection_start_health = None
        self.last_stock_health = stock_health
        return Action.C if should_cooperate else Action.D

class Strategy_COOPERATIVE_128(BaseStrategy):
    """
    Sustainable Majority Strategy: Adapts cooperation based on stock levels and opponent behavior.
    Cooperates when stock is healthy, follows majority when stock is moderate, and uses emergency 
    protocols when stock is critically low. Includes forgiveness mechanisms and end-game optimization.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_num = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        current_stock = self._calculate_current_stock(history)
        if round_num == total_rounds:
            return Action.D
        if round_num == total_rounds - 1 and current_stock >= capacity * 0.5:
            return Action.C
        last_round_idx = history.round_number - 1
        last_round_cooperators = sum(history.opponent_actions[last_round_idx])
        cooperation_ratio = last_round_cooperators / n_players
        stock_ratio = current_stock / capacity
        if stock_ratio >= 0.6:
            return Action.C
        elif stock_ratio >= 0.3:
            if cooperation_ratio >= 0.5:
                return Action.C
            else:
                return Action.D
        else:
            rounds_remaining = total_rounds - round_num
            if rounds_remaining > 3:
                return Action.C
            else:
                return Action.D
        if self._check_forgiveness_condition(history):
            return Action.C
        return Action.C

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate the current stock level based on game history."""
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        stock = float(capacity)
        for round_idx in range(history.round_number):
            my_action_was_coop = history.my_actions[round_idx]
            opponent_cooperators = sum(history.opponent_actions[round_idx])
            total_cooperators = opponent_cooperators + (1 if my_action_was_coop else 0)
            total_defectors = n_players - total_cooperators
            consumption_from_coop = total_cooperators * (stock / (2 * n_players))
            consumption_from_defect = total_defectors * (stock / n_players)
            total_consumption = consumption_from_coop + consumption_from_defect
            stock_after_consumption = max(0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            else:
                growth = 0
            stock = min(stock_after_consumption + growth, capacity)
        return stock

    def _check_forgiveness_condition(self, history: PlayerHistory) -> bool:
        """Check if last 3 rounds were all defection (forgiveness mechanism)."""
        if history.round_number < 3:
            return False
        for i in range(3):
            round_idx = history.round_number - 1 - i
            if history.my_actions[round_idx]:
                return False
            if any(history.opponent_actions[round_idx]):
                return False
        return True

class Strategy_AGGRESSIVE_33(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Greedy Opportunist"
    
    Maximizes short-term gains while strategically exploiting cooperative opponents.
    Operates on aggressive exploitation with minimal resource preservation only when critical.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        n = self.game_description.n_players
        final_round = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = self._calculate_current_stock(history)
        if current_round == final_round:
            return Action.D
        if current_stock <= capacity * 0.15:
            return Action.C
        last_round_idx = history.round_number - 1
        cooperative_opponents = sum(history.opponent_actions[last_round_idx])
        defectors_last_round = n - 1 - cooperative_opponents
        if cooperative_opponents >= (n - 1) / 2:
            return Action.D
        if defectors_last_round >= (n - 1) / 2:
            return Action.D
        if current_stock >= capacity * 0.8 and cooperative_opponents <= 1:
            return Action.C
        return Action.D

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game history."""
        stock = float(self.game_description.capacity)
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        for round_idx in range(history.round_number):
            my_action_cooperated = history.my_actions[round_idx]
            opponent_cooperators = sum(history.opponent_actions[round_idx])
            total_cooperators = opponent_cooperators + (1 if my_action_cooperated else 0)
            total_defectors = n - total_cooperators
            cooperator_consumption = total_cooperators * (stock / (2 * n))
            defector_consumption = total_defectors * (stock / n)
            total_consumption = cooperator_consumption + defector_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            else:
                growth = 0
            stock = min(stock_after_consumption + growth, capacity)
        return stock

class Strategy_AGGRESSIVE_34(BaseStrategy):
    """
    Aggressive "Scorched Earth" PREDATOR strategy that prioritizes maximum immediate extraction 
    while attempting to deny opponents the ability to sustain cooperative behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defection_streak = 0
        self.stock_threshold = game_description.capacity * 0.3

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.defection_streak = 1
            return Action.D
        current_round = history.round_number + 1
        current_stock = self._calculate_current_stock(history)
        if current_stock < self.stock_threshold:
            self.defection_streak += 1
            return Action.D
        if current_round == self.game_description.n_rounds:
            return Action.D
        cooperation_count_last_round = sum(history.opponent_actions[history.round_number - 1])
        if cooperation_count_last_round >= (self.game_description.n_players - 1) / 2:
            self.defection_streak += 1
            return Action.D
        if self.defection_streak >= 3 and current_stock > self.game_description.capacity * 0.6 and (random.random() < 0.3):
            self.defection_streak = 0
            return Action.C
        self.defection_streak += 1
        return Action.D

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game history"""
        stock = self.game_description.capacity
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            cooperators = sum(opponent_actions) + (1 if my_action else 0)
            defectors = n - cooperators
            cooperator_consumption = stock / (2 * n)
            defector_consumption = stock / n
            total_consumption = cooperators * cooperator_consumption + defectors * defector_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            stock = min(stock_after_consumption + growth, capacity)
        return stock

class Strategy_AGGRESSIVE_35(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Resource Predator"
    
    Operates on aggressive resource extraction while maintaining minimal cooperation
    to prevent complete resource collapse. Maximizes individual payoffs by exploiting
    others' cooperation through three phases: early aggression, conditional exploitation,
    and endgame extraction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        stock_ratio = self._estimate_current_stock(history) / self.capacity
        rounds_remaining = self.n_rounds - current_round + 1
        if current_round <= 0.3 * self.n_rounds:
            return Action.D
        elif current_round <= 0.8 * self.n_rounds:
            return self._conditional_exploitation(stock_ratio, history)
        else:
            return self._endgame_strategy(stock_ratio, rounds_remaining)

    def _conditional_exploitation(self, stock_ratio: float, history: PlayerHistory) -> Action:
        cooperation_rate = self._calculate_opponent_cooperation_rate(history)
        if stock_ratio < 0.15:
            return Action.C
        if cooperation_rate >= 0.6:
            return Action.D
        if stock_ratio > 0.4:
            return Action.D
        return Action.C

    def _endgame_strategy(self, stock_ratio: float, rounds_remaining: int) -> Action:
        if rounds_remaining <= 2:
            return Action.D
        if stock_ratio < 0.1 and rounds_remaining == 3:
            return Action.C
        return Action.D

    def _calculate_opponent_cooperation_rate(self, history: PlayerHistory) -> float:
        if history.round_number == 0:
            return 0.0
        total_opponent_actions = np.sum(history.opponent_actions)
        total_possible_actions = history.round_number * (self.n_players - 1)
        if total_possible_actions == 0:
            return 0.0
        return total_opponent_actions / total_possible_actions

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            if my_action:
                my_consumption = stock / (2 * self.n_players)
            else:
                my_consumption = stock / self.n_players
            opponent_consumption = 0
            for opp_action in opponent_actions:
                if opp_action:
                    opponent_consumption += stock / (2 * self.n_players)
                else:
                    opponent_consumption += stock / self.n_players
            total_consumption = my_consumption + opponent_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            else:
                growth = 0
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

class Strategy_AGGRESSIVE_36(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Predator"
    
    Operates on aggressive opportunism - maximizing immediate extraction while 
    strategically managing the resource. Uses conditional aggression based on
    opponent behavior, resource levels, and game timing.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        stock = self._estimate_current_stock(history)
        if stock < self.n:
            return Action.C
        if current_round > self.r - 2:
            return Action.D
        if current_round <= 2:
            return Action.D
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            cooperators_last_round += 1
        total_players = self.n
        if cooperators_last_round > total_players / 2:
            if stock > self.capacity * 0.8:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on payoffs and game dynamics."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            cooperators = sum(history.opponent_actions[round_idx])
            if history.my_actions[round_idx]:
                cooperators += 1
            defectors = self.n - cooperators
            cooperator_consumption = stock / (2 * self.n) if stock > 0 else 0
            defector_consumption = stock / self.n if stock > 0 else 0
            total_consumption = cooperators * cooperator_consumption + defectors * defector_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
                stock = min(stock_after_consumption + growth, self.capacity)
            else:
                stock = 0
        return stock

class Strategy_AGGRESSIVE_37(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Shock and Awe"
    
    This strategy operates on aggressive early exploitation followed by opportunistic predation.
    It aims to maximize immediate gains while destabilizing opponents' cooperative tendencies.
    
    Phase 1: Opening Shock (Rounds 1-2) - Always DEFECT
    Phase 2: Adaptive Predation (Rounds 3 to r-2) - Defection-biased decision making
    Phase 3: Endgame Extraction (Final 2 rounds) - Always DEFECT
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round <= 2:
            return Action.D
        if current_round > self.n_rounds - 2:
            return Action.D
        current_stock = self._estimate_current_stock(history)
        if current_stock < self.capacity * 0.15:
            return Action.D
        if current_stock < self.capacity * 0.3:
            return Action.D
        last_round_idx = history.round_number - 1
        opponent_defectors_last_round = np.sum(history.opponent_actions[last_round_idx] == False)
        my_action_last_round = history.my_actions[last_round_idx]
        total_defectors_last_round = opponent_defectors_last_round + (0 if my_action_last_round else 1)
        if total_defectors_last_round > self.n_players / 2:
            return Action.D
        my_cumulative_payoff = np.sum(history.my_payoffs)
        average_opponent_payoff = np.mean(np.sum(history.opponent_payoffs, axis=0))
        if my_cumulative_payoff < average_opponent_payoff * 1.1:
            return Action.D
        cooperative_players_last_round = np.sum(history.opponent_actions[last_round_idx] == True)
        if cooperative_players_last_round >= self.n_players / 2 and current_stock > self.capacity * 0.5:
            return Action.D
        cooperators_last_round = cooperative_players_last_round + (1 if my_action_last_round else 0)
        defectors_last_round = self.n_players - cooperators_last_round
        if defectors_last_round >= cooperators_last_round:
            return Action.D
        elif random.random() < 0.3:
            return Action.D
        else:
            return Action.C

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game history"""
        stock = self.capacity
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            my_cooperated = my_action
            opponent_cooperators = np.sum(opponent_actions == True)
            total_cooperators = opponent_cooperators + (1 if my_cooperated else 0)
            total_defectors = self.n_players - total_cooperators
            cooperator_consumption = stock / (2 * self.n_players)
            defector_consumption = stock / self.n_players
            total_consumption = total_cooperators * cooperator_consumption + total_defectors * defector_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
                stock = min(stock_after_consumption + growth, self.capacity)
            else:
                stock = 0
        return stock

class Strategy_AGGRESSIVE_38(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Predator"
    
    This strategy adopts a predatory approach, viewing the common pool as a resource to be 
    aggressively extracted while other players bear the costs of maintaining it. Always 
    defects in first and last rounds, exploits high cooperation rates, and maintains 
    aggressive stance regardless of stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        stock = self._estimate_current_stock(history)
        if stock < self.game_description.capacity * 0.3:
            return Action.D
        coop_rate = self._calculate_opponent_cooperation_rate(history)
        if coop_rate > 0.6:
            return Action.D
        if stock > self.game_description.capacity * 0.8:
            return Action.D
        return Action.D

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game history."""
        stock = float(self.game_description.capacity)
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_cooperators = int(my_action) + int(np.sum(opponent_actions))
            total_defectors = n - total_cooperators
            coop_consumption = total_cooperators * (stock / (2 * n))
            defect_consumption = total_defectors * (stock / n)
            total_consumption = coop_consumption + defect_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            stock = min(stock_after_consumption + growth, capacity)
        return stock

    def _calculate_opponent_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate the overall cooperation rate of opponents."""
        if history.round_number == 0:
            return 0.0
        total_opponent_actions = history.opponent_actions.size
        total_cooperations = int(np.sum(history.opponent_actions))
        if total_opponent_actions == 0:
            return 0.0
        return total_cooperations / total_opponent_actions

class Strategy_AGGRESSIVE_39(BaseStrategy):
    """
    Opportunistic Exploiter: An aggressive strategy that maximizes short-term gains by 
    exploiting cooperative behavior while minimizing own cooperation. Always defects 
    in first and final rounds, and exploits others' cooperation whenever possible.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        last_round_idx = history.round_number - 1
        others_coop_count = sum(history.opponent_actions[last_round_idx])
        others_coop_rate = others_coop_count / (self.game_description.n_players - 1)
        last_payoff = history.my_payoffs[last_round_idx]
        my_last_action = history.my_actions[last_round_idx]
        if my_last_action:
            estimated_stock = last_payoff * 2 * self.game_description.n_players
        else:
            estimated_stock = last_payoff * self.game_description.n_players
        stock_ratio = estimated_stock / self.game_description.capacity
        if stock_ratio < 0.15:
            if others_coop_rate > 0.6:
                return Action.D
            else:
                return Action.C
        elif stock_ratio < 0.4:
            if others_coop_rate >= 0.5:
                return Action.D
            else:
                return Action.C
        elif others_coop_rate >= 0.3:
            return Action.D
        elif current_round % 3 == 0:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_40(BaseStrategy):
    """
    Aggressive "Opportunistic Predator" Strategy - maximizes immediate gains through 
    calculated aggression while maintaining minimal cooperation only when absolutely 
    necessary for resource survival.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.consecutive_cooperation_rounds = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.consecutive_cooperation_rounds = 0
            return Action.D
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round = history.round_number + 1
        stock = self._calculate_current_stock(history)
        if stock < capacity / 4:
            self.consecutive_cooperation_rounds += 1
            return Action.C
        if current_round == n_rounds:
            self.consecutive_cooperation_rounds = 0
            return Action.D
        remaining_rounds = n_rounds - current_round
        aggressive_threshold = capacity * (0.4 + 0.1 * (remaining_rounds / n_rounds))
        if stock > aggressive_threshold:
            if history.round_number > 0:
                last_round_defectors = np.sum(history.opponent_actions[history.round_number - 1] == False)
                defector_ratio = last_round_defectors / (n_players - 1)
                if defector_ratio < 0.5:
                    self.consecutive_cooperation_rounds = 0
                    return Action.D
                else:
                    self.consecutive_cooperation_rounds += 1
                    return Action.C
            else:
                self.consecutive_cooperation_rounds = 0
                return Action.D
        elif stock > capacity / 4:
            if self.consecutive_cooperation_rounds >= 2:
                self.consecutive_cooperation_rounds = 0
                return Action.D
            else:
                self.consecutive_cooperation_rounds += 1
                return Action.C
        else:
            self.consecutive_cooperation_rounds += 1
            return Action.C

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game history."""
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        stock = float(capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0.0
            if my_action:
                total_consumption += stock / (2 * n_players)
            else:
                total_consumption += stock / n_players
            for opp_action in opponent_actions:
                if opp_action:
                    total_consumption += stock / (2 * n_players)
                else:
                    total_consumption += stock / n_players
            stock_after_consumption = max(0.0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            stock = min(stock_after_consumption + growth, capacity)
        return stock

class Strategy_AGGRESSIVE_41(BaseStrategy):
    """
    Aggressive Resource Dominator strategy that exploits the commons while maintaining
    just enough sustainability to maximize long-term extraction. Uses adaptive aggression
    with strategic cooperation only when necessary to prevent total collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        stock_level = self._estimate_stock_level(history)
        if history.round_number > 0:
            last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
            cooperation_rate = last_round_cooperators / self.n
        else:
            cooperation_rate = 0.0
        if current_round <= self.r // 3:
            if stock_level > 0.7 * self.capacity:
                return Action.D
            elif stock_level <= 0.3 * self.capacity:
                return Action.C
            else:
                return Action.D
        elif current_round <= 2 * self.r // 3:
            if stock_level <= 0.2 * self.capacity:
                return Action.C
            elif cooperation_rate >= 0.5 and stock_level > 0.4 * self.capacity:
                return Action.D
            elif cooperation_rate < 0.3:
                if stock_level > 0.5 * self.capacity:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.D
        else:
            rounds_remaining = self.r - current_round + 1
            if rounds_remaining <= 2:
                return Action.D
            elif stock_level <= 0.15 * self.capacity:
                return Action.C
            elif stock_level > 0.6 * self.capacity:
                return Action.D
            else:
                coop_rate_recent = self._get_recent_cooperation_rate(history, 3)
                if coop_rate_recent < 0.4:
                    return Action.D
                elif random.random() < 0.3:
                    return Action.C
                else:
                    return Action.D

    def _estimate_stock_level(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game history."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_consumption = stock / (2 * self.n) if history.my_actions[round_idx] else stock / self.n
            opponent_consumption = 0.0
            for player_idx in range(self.n - 1):
                if history.opponent_actions[round_idx, player_idx]:
                    opponent_consumption += stock / (2 * self.n)
                else:
                    opponent_consumption += stock / self.n
            total_consumption = my_consumption + opponent_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
                stock = min(stock_after_consumption + growth, self.capacity)
            else:
                stock = 0
        return stock

    def _get_recent_cooperation_rate(self, history: PlayerHistory, num_rounds: int) -> float:
        """Calculate cooperation rate over the last num_rounds rounds."""
        if history.round_number == 0:
            return 0.0
        start_round = max(0, history.round_number - num_rounds)
        total_players = 0
        total_cooperators = 0
        for round_idx in range(start_round, history.round_number):
            cooperators = sum(history.opponent_actions[round_idx])
            total_cooperators += cooperators
            total_players += self.n - 1
        return total_cooperators / total_players if total_players > 0 else 0.0

class Strategy_AGGRESSIVE_42(BaseStrategy):
    """
    Aggressive "Exploit-and-Dominate" Strategy
    
    Prioritizes immediate high payoffs through aggressive defection while attempting 
    to psychologically manipulate opponents into cooperation through calculated periods 
    of restraint. Maintains just enough sustainability to continue exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.current_stock = self.capacity
        self.emergency_cooperation_rounds = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        self._update_stock_estimate(history)
        current_round = history.round_number + 1
        if self.current_stock < self.capacity * 0.15:
            self.emergency_cooperation_rounds = 2
        if self.emergency_cooperation_rounds > 0:
            self.emergency_cooperation_rounds -= 1
            return Action.C
        if self.current_stock < self.capacity * 0.3:
            return Action.C
        if current_round >= self.n_rounds - 1:
            return Action.D
        opponent_defection_rate = self._calculate_recent_defection_rate(history)
        if opponent_defection_rate > 0.6:
            return Action.D
        if self.current_stock >= self.capacity * 0.8 and self._is_behind_average_score(history):
            return Action.D
        last_round_cooperators = self._count_last_round_cooperators(history)
        cooperation_rate = last_round_cooperators / (self.n_players - 1)
        if cooperation_rate >= 0.5:
            return Action.D
        return Action.C

    def _update_stock_estimate(self, history: PlayerHistory):
        """Estimate current stock level based on consumption patterns"""
        if history.round_number == 0:
            return
        last_round = history.round_number - 1
        my_action = history.my_actions[last_round]
        total_consumption = 0
        if my_action:
            total_consumption += self.current_stock / (2 * self.n_players)
        else:
            total_consumption += self.current_stock / self.n_players
        for opponent_idx in range(self.n_players - 1):
            if history.opponent_actions[last_round, opponent_idx]:
                total_consumption += self.current_stock / (2 * self.n_players)
            else:
                total_consumption += self.current_stock / self.n_players
        stock_after_consumption = max(0, self.current_stock - total_consumption)
        growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
        self.current_stock = min(stock_after_consumption + growth, self.capacity)

    def _calculate_recent_defection_rate(self, history: PlayerHistory):
        """Calculate opponent defection rate over last 3 rounds"""
        recent_rounds = min(3, history.round_number)
        if recent_rounds == 0:
            return 0
        total_decisions = 0
        total_defections = 0
        for round_idx in range(history.round_number - recent_rounds, history.round_number):
            for opponent_idx in range(self.n_players - 1):
                total_decisions += 1
                if not history.opponent_actions[round_idx, opponent_idx]:
                    total_defections += 1
        return total_defections / total_decisions if total_decisions > 0 else 0

    def _is_behind_average_score(self, history: PlayerHistory):
        """Check if current player is behind average cumulative score by >15%"""
        if history.round_number == 0:
            return False
        my_total = np.sum(history.my_payoffs)
        opponent_totals = []
        for opponent_idx in range(self.n_players - 1):
            opponent_total = np.sum(history.opponent_payoffs[:, opponent_idx])
            opponent_totals.append(opponent_total)
        if len(opponent_totals) == 0:
            return False
        average_opponent_score = np.mean(opponent_totals)
        return my_total < average_opponent_score * 0.85

    def _count_last_round_cooperators(self, history: PlayerHistory):
        """Count how many opponents cooperated in the last round"""
        if history.round_number == 0:
            return 0
        last_round = history.round_number - 1
        cooperators = 0
        for opponent_idx in range(self.n_players - 1):
            if history.opponent_actions[last_round, opponent_idx]:
                cooperators += 1
        return cooperators

class Strategy_AGGRESSIVE_43(BaseStrategy):
    """
    Aggressive Resource Exploitation Strategy: "Predatory Harvest"
    
    Operates on maximum immediate extraction while maintaining resource base just enough
    to continue profitable exploitation. Uses conditional defection based on stock levels,
    round position, and opponent behavior patterns.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        current_stock = self._estimate_current_stock(history)
        stock_ratio = current_stock / capacity
        if total_rounds - current_round < 3:
            return Action.D
        if stock_ratio < 0.15:
            return Action.C
        if stock_ratio > 0.3:
            return Action.D
        if stock_ratio > 0.15:
            if current_round <= 5:
                return Action.D
            if history.round_number > 0:
                last_round_defectors = np.sum(history.opponent_actions[history.round_number - 1] == False)
                majority_defected = last_round_defectors > (n_players - 1) / 2
                if majority_defected:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.D
        return Action.C

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock based on game history and dynamics."""
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        stock = float(capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0.0
            if my_action:
                total_consumption += stock / (2 * n_players)
            else:
                total_consumption += stock / n_players
            for opp_action in opponent_actions:
                if opp_action:
                    total_consumption += stock / (2 * n_players)
                else:
                    total_consumption += stock / n_players
            stock_after_consumption = max(0.0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            stock = min(stock_after_consumption + growth, capacity)
        return stock

class Strategy_AGGRESSIVE_44(BaseStrategy):
    """
    Aggressive Opportunistic "Resource Raider" Strategy.
    
    Prioritizes immediate personal gain with strategic defection timing.
    Exploits cooperative opponents early and becomes increasingly aggressive
    as the game progresses, especially when resources are critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.n_rounds:
            return Action.D
        current_stock = self._calculate_current_stock(history)
        if current_stock <= self.capacity * 0.4:
            return Action.D
        remaining_rounds = self.n_rounds - current_round
        if remaining_rounds <= 2:
            if current_stock >= self.capacity * 0.6:
                return Action.D
            else:
                return Action.D if random.random() < 0.8 else Action.C
        last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
        cooperation_rate = last_round_cooperators / self.n_players
        base_defection_prob = 0.6
        time_pressure_bonus = current_round / self.n_rounds * 0.2
        exploitation_bonus = 0.0
        if cooperation_rate >= 0.6:
            exploitation_bonus = 0.3
        elif cooperation_rate <= 0.2:
            exploitation_bonus = -0.2
        total_defection_prob = base_defection_prob + time_pressure_bonus + exploitation_bonus
        total_defection_prob = min(0.95, max(0.1, total_defection_prob))
        return Action.D if random.random() < total_defection_prob else Action.C

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game history."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0.0
            if my_action:
                total_consumption += stock / (2 * self.n_players)
            else:
                total_consumption += stock / self.n_players
            for opponent_action in opponent_actions:
                if opponent_action:
                    total_consumption += stock / (2 * self.n_players)
                else:
                    total_consumption += stock / self.n_players
            stock_after_consumption = max(0.0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            else:
                growth = 0.0
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

class Strategy_AGGRESSIVE_45(BaseStrategy):
    """
    Opportunistic Predator: Aggressive strategy that maximally exploits resources
    while maintaining minimal cooperation only when necessary for survival.
    Prioritizes immediate gains and adapts based on stock levels and opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.n_rounds:
            return Action.D
        current_stock = self._calculate_current_stock(history)
        if current_stock <= self.capacity * 0.15:
            return Action.C
        if current_stock >= self.capacity * 0.8:
            return Action.D
        defection_rate = self._calculate_opponent_defection_rate(history)
        if defection_rate >= 0.6:
            return Action.D
        if defection_rate <= 0.3:
            return Action.D
        if current_stock > self.capacity * 0.4:
            return Action.D
        elif self._is_stock_declining_rapidly(history):
            return Action.C
        else:
            return Action.D

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock based on game dynamics"""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            total_consumption = 0.0
            if my_action:
                total_consumption += stock / (2 * self.n_players)
            else:
                total_consumption += stock / self.n_players
            for opponent_idx in range(self.n_players - 1):
                if history.opponent_actions[round_idx, opponent_idx]:
                    total_consumption += stock / (2 * self.n_players)
                else:
                    total_consumption += stock / self.n_players
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _calculate_opponent_defection_rate(self, history: PlayerHistory) -> float:
        """Calculate the rate at which opponents have been defecting"""
        if history.round_number == 0:
            return 0.5
        total_opponent_actions = 0
        total_defections = 0
        for round_idx in range(history.round_number):
            for opponent_idx in range(self.n_players - 1):
                total_opponent_actions += 1
                if not history.opponent_actions[round_idx, opponent_idx]:
                    total_defections += 1
        return total_defections / total_opponent_actions if total_opponent_actions > 0 else 0.5

    def _is_stock_declining_rapidly(self, history: PlayerHistory) -> bool:
        """Check if stock is declining rapidly (>25% per round)"""
        if history.round_number < 2:
            return False
        current_stock = self._calculate_current_stock(history)
        stock = float(self.capacity)
        for round_idx in range(history.round_number - 1):
            my_action = history.my_actions[round_idx]
            total_consumption = 0.0
            if my_action:
                total_consumption += stock / (2 * self.n_players)
            else:
                total_consumption += stock / self.n_players
            for opponent_idx in range(self.n_players - 1):
                if history.opponent_actions[round_idx, opponent_idx]:
                    total_consumption += stock / (2 * self.n_players)
                else:
                    total_consumption += stock / self.n_players
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        previous_stock = stock
        if previous_stock > 0:
            decline_rate = (previous_stock - current_stock) / previous_stock
            return decline_rate > 0.25
        return False

class Strategy_AGGRESSIVE_46(BaseStrategy):
    """
    Aggressive "Early Hawk" Strategy
    
    Implements aggressive early extraction followed by conditional predation.
    Phase 1: Always defect in rounds 1-2 for maximum early extraction.
    Phase 2: Adaptive exploitation based on stock levels and opponent behavior.
    Phase 3: Endgame defection to maximize final payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_num = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        current_stock = self._calculate_current_stock(history)
        if round_num <= 2:
            return Action.D
        if round_num == total_rounds:
            return Action.D
        if round_num == total_rounds - 1:
            stock_ratio = current_stock / capacity
            if stock_ratio < 0.15 and self._all_cooperated_last_round(history):
                return Action.C
            else:
                return Action.D
        stock_ratio = current_stock / capacity
        opponents_defect_rate = self._get_last_round_defect_rate(history)
        if stock_ratio > 0.6:
            return Action.D
        if opponents_defect_rate > 0.5:
            return Action.D
        if stock_ratio < 0.2 and opponents_defect_rate > 0.25:
            return Action.D
        if stock_ratio < 0.1:
            return Action.D
        if self._consecutive_all_cooperate_rounds(history) >= 2 and stock_ratio > 0.4:
            return Action.D
        return Action.C

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock based on game dynamics"""
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        stock = float(capacity)
        for round_idx in range(history.round_number):
            total_consumption = 0.0
            if history.my_actions[round_idx]:
                total_consumption += stock / (2 * n_players)
            else:
                total_consumption += stock / n_players
            for opponent_idx in range(n_players - 1):
                if history.opponent_actions[round_idx, opponent_idx]:
                    total_consumption += stock / (2 * n_players)
                else:
                    total_consumption += stock / n_players
            stock_after_consumption = max(0.0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            stock = min(stock_after_consumption + growth, capacity)
        return stock

    def _get_last_round_defect_rate(self, history: PlayerHistory) -> float:
        """Get the defection rate of opponents in the last round"""
        if history.round_number == 0:
            return 0.0
        last_round_idx = history.round_number - 1
        n_opponents = self.game_description.n_players - 1
        defections = sum((not action for action in history.opponent_actions[last_round_idx]))
        return defections / n_opponents

    def _all_cooperated_last_round(self, history: PlayerHistory) -> bool:
        """Check if all opponents cooperated in the last round"""
        if history.round_number == 0:
            return False
        last_round_idx = history.round_number - 1
        return all(history.opponent_actions[last_round_idx])

    def _consecutive_all_cooperate_rounds(self, history: PlayerHistory) -> int:
        """Count consecutive rounds where all opponents cooperated (from most recent)"""
        if history.round_number == 0:
            return 0
        consecutive_count = 0
        for round_idx in range(history.round_number - 1, -1, -1):
            if all(history.opponent_actions[round_idx]):
                consecutive_count += 1
            else:
                break
        return consecutive_count

class Strategy_AGGRESSIVE_47(BaseStrategy):
    """
    Exploitative Punisher: An aggressive strategy that maximizes individual payoffs 
    through strategic exploitation while maintaining credible punishment capabilities.
    Always defects in round 1, exploits cooperative opponents, and preserves resources
    only when critically necessary.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.n_rounds:
            return Action.D
        current_stock = self._estimate_current_stock(history)
        critical_stock = self.capacity * 0.15
        if current_stock <= critical_stock:
            return Action.C
        last_round_idx = history.round_number - 1
        defectors_last_round = np.sum(history.opponent_actions[last_round_idx] == False)
        if not history.my_actions[last_round_idx]:
            defectors_last_round += 1
        if defectors_last_round <= self.n_players / 2:
            return Action.D
        if defectors_last_round > self.n_players / 2:
            if current_round <= self.n_rounds * 0.7:
                return Action.D
            else:
                return Action.C
        return Action.D

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """
        Estimate current stock level based on payoff history and game dynamics.
        Since payoffs are stock/(2n) for cooperators and stock/n for defectors,
        we can work backwards from payoffs to estimate stock levels.
        """
        if history.round_number == 0:
            return self.capacity
        last_round_idx = history.round_number - 1
        my_last_payoff = history.my_payoffs[last_round_idx]
        if history.my_actions[last_round_idx]:
            estimated_stock_last_round = my_last_payoff * 2 * self.n_players
        else:
            estimated_stock_last_round = my_last_payoff * self.n_players
        total_cooperators = np.sum(history.opponent_actions[last_round_idx] == True)
        if history.my_actions[last_round_idx]:
            total_cooperators += 1
        total_defectors = self.n_players - total_cooperators
        cooperator_consumption = total_cooperators * (estimated_stock_last_round / (2 * self.n_players))
        defector_consumption = total_defectors * (estimated_stock_last_round / self.n_players)
        total_consumption = cooperator_consumption + defector_consumption
        stock_after_consumption = max(0, estimated_stock_last_round - total_consumption)
        growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
        current_stock = min(stock_after_consumption + growth, self.capacity)
        return max(0, current_stock)

class Strategy_AGGRESSIVE_48(BaseStrategy):
    """
    Opportunistic Exploiter: An aggressive strategy that maximizes individual payoffs through 
    calculated aggression, exploiting cooperative opponents while strategically preserving 
    resources only when necessary for long-term dominance.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def _calculate_opponent_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate the cooperation rate of opponents in the most recent round."""
        if history.round_number == 0:
            return 0.5
        last_round_idx = history.round_number - 1
        cooperators = sum(history.opponent_actions[last_round_idx])
        total_opponents = self.game_description.n_players - 1
        return cooperators / total_opponents if total_opponents > 0 else 0.0

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game dynamics."""
        if history.round_number == 0:
            return float(self.game_description.capacity)
        stock = float(self.game_description.capacity)
        n = self.game_description.n_players
        capacity = float(self.game_description.capacity)
        for round_idx in range(history.round_number):
            my_consumption = stock / (2 * n) if history.my_actions[round_idx] else stock / n
            opponent_consumption = 0.0
            for opponent_idx in range(n - 1):
                if history.opponent_actions[round_idx, opponent_idx]:
                    opponent_consumption += stock / (2 * n)
                else:
                    opponent_consumption += stock / n
            total_consumption = my_consumption + opponent_consumption
            stock_after_consumption = max(0.0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            stock = min(stock_after_consumption + growth, capacity)
        return stock

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        cooperation_rate = self._calculate_opponent_cooperation_rate(history)
        current_stock = self._calculate_current_stock(history)
        stock_health = current_stock / self.game_description.capacity
        rounds_remaining = self.game_description.n_rounds - current_round + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        if stock_health < 0.15:
            return Action.C
        if cooperation_rate >= 0.6:
            return Action.D
        if cooperation_rate <= 0.3 and stock_health > 0.4:
            return Action.D
        if rounds_remaining <= 3 and stock_health > 0.25:
            return Action.D
        if stock_health < 0.3 and cooperation_rate < 0.5:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_49(BaseStrategy):
    """
    Adaptive Predator: An aggressive exploitation strategy that defects by default
    while maintaining just enough sustainability to maximize long-term extraction.
    Exploits cooperative players and punishes defection patterns.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round > 0.8 * self.n_rounds:
            return Action.D
        current_stock = self._estimate_current_stock(history)
        if current_stock < 0.3 * self.capacity:
            return Action.D
        if current_stock < 0.1 * self.capacity:
            return Action.D
        last_round_coop_rate = self._get_last_round_cooperation_rate(history)
        historical_coop_rate = self._get_historical_cooperation_rate(history)
        stock_trend = self._analyze_stock_trend(history)
        if last_round_coop_rate < 0.75:
            return Action.D
        if historical_coop_rate < 0.6:
            return Action.D
        if stock_trend == 'declining':
            return Action.D
        if current_stock > 0.7 * self.capacity and last_round_coop_rate >= 0.75 and (current_round <= 0.8 * self.n_rounds) and (stock_trend != 'declining'):
            if random.random() < 0.75:
                return Action.D
            else:
                return Action.C
        return Action.D

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game dynamics"""
        stock = self.capacity
        for round_idx in range(history.round_number):
            total_consumption = 0
            if history.my_actions[round_idx]:
                my_consumption = stock / (2 * self.n_players)
            else:
                my_consumption = stock / self.n_players
            total_consumption += my_consumption
            for opp_idx in range(self.n_players - 1):
                if history.opponent_actions[round_idx, opp_idx]:
                    opp_consumption = stock / (2 * self.n_players)
                else:
                    opp_consumption = stock / self.n_players
                total_consumption += opp_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _get_last_round_cooperation_rate(self, history: PlayerHistory) -> float:
        """Get cooperation rate of opponents in the most recent round"""
        if history.round_number == 0:
            return 0.0
        last_round_idx = history.round_number - 1
        cooperators = np.sum(history.opponent_actions[last_round_idx])
        return cooperators / (self.n_players - 1)

    def _get_historical_cooperation_rate(self, history: PlayerHistory) -> float:
        """Get overall historical cooperation rate of opponents"""
        if history.round_number == 0:
            return 0.0
        total_cooperations = np.sum(history.opponent_actions)
        total_decisions = history.round_number * (self.n_players - 1)
        return total_cooperations / total_decisions

    def _analyze_stock_trend(self, history: PlayerHistory) -> str:
        """Analyze stock trend over recent rounds"""
        if history.round_number < 3:
            return 'stable'
        recent_stocks = []
        for lookback in range(min(3, history.round_number)):
            rounds_back = lookback
            if rounds_back == 0:
                stock = self._estimate_current_stock(history)
            else:
                stock = self.capacity
                target_round = history.round_number - rounds_back
                for round_idx in range(target_round):
                    total_consumption = 0
                    if history.my_actions[round_idx]:
                        my_consumption = stock / (2 * self.n_players)
                    else:
                        my_consumption = stock / self.n_players
                    total_consumption += my_consumption
                    for opp_idx in range(self.n_players - 1):
                        if history.opponent_actions[round_idx, opp_idx]:
                            opp_consumption = stock / (2 * self.n_players)
                        else:
                            opp_consumption = stock / self.n_players
                        total_consumption += opp_consumption
                    stock_after_consumption = max(0, stock - total_consumption)
                    growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
                    stock = min(stock_after_consumption + growth, self.capacity)
            recent_stocks.append(stock)
        recent_stocks.reverse()
        if len(recent_stocks) >= 2:
            if recent_stocks[-1] < recent_stocks[-2] and recent_stocks[-2] < recent_stocks[-3]:
                return 'declining'
            elif recent_stocks[-1] > recent_stocks[-2]:
                return 'growing'
        return 'stable'

class Strategy_AGGRESSIVE_50(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Shark"
    
    Operates on immediate resource extraction with adaptive retaliation.
    Default action is DEFECT, with limited cooperation only under very specific conditions.
    Establishes dominance early and exploits perceived weakness while maintaining
    threat of mutual destruction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round = history.round_number + 1
        if current_round > n_rounds * 0.75:
            return Action.D
        current_stock = self._estimate_current_stock(history, capacity, n_players)
        stock_ratio = current_stock / capacity
        if self._any_defector_last_round(history):
            return Action.D
        if stock_ratio < 0.3:
            return Action.D
        my_cumulative_payoff = sum(history.my_payoffs)
        estimated_avg_payoff = self._estimate_average_payoff(history)
        if my_cumulative_payoff < estimated_avg_payoff * 0.8:
            return Action.D
        last_round_cooperators = self._count_cooperators_last_round(history)
        cooperation_threshold = n_players * 0.75
        if stock_ratio > 0.7 and last_round_cooperators >= cooperation_threshold:
            return Action.C
        return Action.D

    def _any_defector_last_round(self, history: PlayerHistory) -> bool:
        """Check if any opponent defected in the last round."""
        if history.round_number == 0:
            return False
        last_round_idx = history.round_number - 1
        return not all(history.opponent_actions[last_round_idx])

    def _count_cooperators_last_round(self, history: PlayerHistory) -> int:
        """Count how many opponents cooperated in the last round."""
        if history.round_number == 0:
            return 0
        last_round_idx = history.round_number - 1
        return sum(history.opponent_actions[last_round_idx])

    def _estimate_current_stock(self, history: PlayerHistory, capacity: int, n_players: int) -> float:
        """Estimate current stock level based on game dynamics."""
        stock = float(capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0.0
            if my_action:
                total_consumption += stock / (2 * n_players)
            else:
                total_consumption += stock / n_players
            for opp_action in opponent_actions:
                if opp_action:
                    total_consumption += stock / (2 * n_players)
                else:
                    total_consumption += stock / n_players
            stock_after_consumption = max(0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            else:
                growth = 0
            stock = min(stock_after_consumption + growth, capacity)
        return stock

    def _estimate_average_payoff(self, history: PlayerHistory) -> float:
        """Estimate the average payoff across all players."""
        if history.round_number == 0:
            return 0.0
        total_opponent_payoff = 0.0
        for round_idx in range(history.round_number):
            total_opponent_payoff += sum(history.opponent_payoffs[round_idx])
        my_total_payoff = sum(history.my_payoffs)
        total_all_payoffs = my_total_payoff + total_opponent_payoff
        total_players = self.game_description.n_players
        return total_all_payoffs / total_players

class Strategy_AGGRESSIVE_51(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Predator"
    
    This strategy operates on the principle of aggressive resource extraction with calculated sustainability.
    The goal is to maximize individual payoffs by exploiting cooperative players while maintaining just
    enough resource base to continue extraction. Always defects in early rounds to establish dominance,
    exploits high cooperation rates, and only cooperates when stock is critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_number = history.round_number + 1
        rounds_remaining = self.game_description.n_rounds - round_number + 1
        current_stock = self._estimate_current_stock(history)
        stock_health = current_stock / self.game_description.capacity
        if rounds_remaining == 1:
            return Action.D
        if round_number <= 3:
            return Action.D
        if stock_health <= 0.15:
            if rounds_remaining <= 2:
                return Action.D
            return Action.C
        cooperation_rate = self._calculate_opponent_cooperation_rate(history)
        if cooperation_rate >= 0.6 and stock_health >= 0.3:
            return Action.D
        if self._opponent_defected_last_round(history):
            return Action.D
        return Action.D

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock based on game history."""
        stock = float(self.game_description.capacity)
        n_players = self.game_description.n_players
        for round_idx in range(history.round_number):
            total_consumption = 0.0
            if history.my_actions[round_idx]:
                my_consumption = stock / (2 * n_players)
            else:
                my_consumption = stock / n_players
            total_consumption += my_consumption
            for player_idx in range(n_players - 1):
                if history.opponent_actions[round_idx, player_idx]:
                    opp_consumption = stock / (2 * n_players)
                else:
                    opp_consumption = stock / n_players
                total_consumption += opp_consumption
            stock_after_consumption = max(0.0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.game_description.capacity)
            stock = min(stock_after_consumption + growth, float(self.game_description.capacity))
        return stock

    def _calculate_opponent_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate the overall cooperation rate of all opponents across all rounds."""
        if history.round_number == 0:
            return 0.0
        total_actions = 0
        total_cooperations = 0
        for round_idx in range(history.round_number):
            for player_idx in range(self.game_description.n_players - 1):
                total_actions += 1
                if history.opponent_actions[round_idx, player_idx]:
                    total_cooperations += 1
        return total_cooperations / total_actions if total_actions > 0 else 0.0

    def _opponent_defected_last_round(self, history: PlayerHistory) -> bool:
        """Check if any opponent defected in the most recent round."""
        if history.round_number == 0:
            return False
        last_round_idx = history.round_number - 1
        for player_idx in range(self.game_description.n_players - 1):
            if not history.opponent_actions[last_round_idx, player_idx]:
                return True
        return False

class Strategy_AGGRESSIVE_52(BaseStrategy):
    """
    Aggressive "Predator" strategy that maximizes early extraction and exploits cooperative opponents.
    Defects aggressively in opening and endgame phases, and exploits cooperation in middle rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_number = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        current_stock = self._calculate_current_stock(history)
        opening_phase = round_number <= max(3, int(total_rounds * 0.3))
        endgame_phase = round_number > int(total_rounds * 0.8)
        stock_ratio = current_stock / capacity
        if opening_phase:
            return Action.D
        if endgame_phase:
            return Action.D
        if stock_ratio > 0.5:
            return Action.D
        if history.round_number > 0:
            last_round_cooperators = np.sum(history.opponent_actions[history.round_number - 1])
            if last_round_cooperators > n_players / 2:
                return Action.D
        rounds_remaining = total_rounds - round_number
        if stock_ratio < 0.1 and rounds_remaining > int(total_rounds * 0.3):
            return Action.C
        return Action.D

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game dynamics."""
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        current_stock = float(capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            n_cooperators = int(my_action) + np.sum(opponent_actions)
            n_defectors = n_players + 1 - n_cooperators
            cooperator_consumption = current_stock / (2 * n_players)
            defector_consumption = current_stock / n_players
            total_consumption = n_cooperators * cooperator_consumption + n_defectors * defector_consumption
            stock_after_consumption = max(0, current_stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            current_stock = min(stock_after_consumption + growth, capacity)
        return current_stock

class Strategy_AGGRESSIVE_53(BaseStrategy):
    """
    Aggressive "Shark" Strategy - Maximum exploitation with calculated sustainability.
    Operates on the principle of extracting maximum value while maintaining just enough 
    resource base to continue profiting. Exploits cooperators, joins feeding frenzies,
    and becomes increasingly brutal toward endgame.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        current_stock = self._estimate_current_stock(history)
        if current_round == self.n_rounds:
            return Action.D
        critical_stock = self.capacity * 0.15
        if current_stock < critical_stock:
            if history.round_number > 0:
                last_round_defectors = sum(history.opponent_actions[history.round_number - 1] == False)
                if last_round_defectors >= self.n_players // 2:
                    return Action.D
                else:
                    return Action.D
            else:
                return Action.D
        cooperative_percentage = self._calculate_recent_cooperation_rate(history, 3)
        if cooperative_percentage > 0.6:
            return Action.D
        elif cooperative_percentage < 0.3:
            return Action.D
        elif (current_round + 0) % 3 == 0:
            return Action.C
        else:
            return Action.D

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock based on payoff history and game dynamics."""
        if history.round_number == 0:
            return self.capacity
        last_payoff = history.my_payoffs[-1]
        last_action = history.my_actions[-1]
        if last_action:
            estimated_stock = last_payoff * 2 * self.n_players
        else:
            estimated_stock = last_payoff * self.n_players
        return max(estimated_stock * 0.8, self.capacity * 0.05)

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory, lookback: int) -> float:
        """Calculate cooperation rate of opponents over recent rounds."""
        if history.round_number == 0:
            return 0.5
        start_round = max(0, history.round_number - lookback)
        total_decisions = 0
        total_cooperations = 0
        for round_idx in range(start_round, history.round_number):
            round_cooperations = sum(history.opponent_actions[round_idx])
            total_cooperations += round_cooperations
            total_decisions += len(history.opponent_actions[round_idx])
        if total_decisions == 0:
            return 0.5
        return total_cooperations / total_decisions

class Strategy_AGGRESSIVE_54(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Resource Raider"
    
    Operates on aggressive early resource extraction to maximize payoffs while
    exploiting cooperative opponents. Uses immediate aggression, exploitation
    detection, stock-based overrides, and endgame acceleration.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if current_round <= 2:
            return Action.D
        current_stock = self._estimate_current_stock(history)
        coop_ratio = self._calculate_cooperation_ratio(history)
        if current_round > 0.8 * total_rounds:
            return Action.D
        if current_stock <= capacity / 4:
            return Action.C
        if current_stock >= 3 * capacity / 4:
            return Action.D
        if coop_ratio > 0.6:
            return Action.D
        if coop_ratio <= 0.3:
            return Action.C
        return Action.D

    def _calculate_cooperation_ratio(self, history: PlayerHistory) -> float:
        """Calculate the ratio of cooperative actions by opponents."""
        if history.round_number == 0:
            return 0.0
        total_opponent_actions = 0
        total_opponent_cooperations = 0
        for round_idx in range(history.round_number):
            for opponent_idx in range(len(history.opponent_actions[round_idx])):
                total_opponent_actions += 1
                if history.opponent_actions[round_idx][opponent_idx]:
                    total_opponent_cooperations += 1
        if total_opponent_actions == 0:
            return 0.0
        return total_opponent_cooperations / total_opponent_actions

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game dynamics."""
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        current_stock = float(capacity)
        for round_idx in range(history.round_number):
            my_consumption = current_stock / (2 * n_players) if history.my_actions[round_idx] else current_stock / n_players
            opponent_consumption = 0.0
            for opponent_idx in range(len(history.opponent_actions[round_idx])):
                if history.opponent_actions[round_idx][opponent_idx]:
                    opponent_consumption += current_stock / (2 * n_players)
                else:
                    opponent_consumption += current_stock / n_players
            total_consumption = my_consumption + opponent_consumption
            stock_after_consumption = max(0.0, current_stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            else:
                growth = 0.0
            current_stock = min(stock_after_consumption + growth, capacity)
        return current_stock

class Strategy_AGGRESSIVE_55(BaseStrategy):
    """
    Aggressive Opportunistic "Resource Raider" Strategy.
    
    Maximizes immediate gains through defection while exploiting cooperative opponents.
    Only cooperates when resource is critically depleted (below 30% capacity) to enable
    future exploitation. Always defects in final 20% of rounds and first round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = self.capacity * 0.3
        self.recovery_threshold = self.capacity * 0.4
        self.endgame_start = self.n_rounds - math.floor(self.n_rounds / 5)
        self.previous_action = None

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.previous_action = Action.D
            return Action.D
        current_round = history.round_number + 1
        current_stock = self._calculate_current_stock(history)
        if current_round > self.endgame_start:
            self.previous_action = Action.D
            return Action.D
        if current_stock < self.critical_threshold:
            self.previous_action = Action.C
            return Action.C
        if self.previous_action == Action.C and current_stock > self.recovery_threshold:
            self.previous_action = Action.D
            return Action.D
        if self.previous_action == Action.C and current_stock <= self.recovery_threshold:
            return Action.C
        self.previous_action = Action.D
        return Action.D

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game dynamics."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            if my_action:
                my_consumption = stock / (2 * self.n_players)
            else:
                my_consumption = stock / self.n_players
            opponent_consumption = 0
            for opp_action in opponent_actions:
                if opp_action:
                    opponent_consumption += stock / (2 * self.n_players)
                else:
                    opponent_consumption += stock / self.n_players
            total_consumption = my_consumption + opponent_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth_rate = 1 - stock_after_consumption / self.capacity
                growth = 2 * stock_after_consumption * growth_rate
            else:
                growth = 0
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

class Strategy_AGGRESSIVE_56(BaseStrategy):
    """
    Aggressive "Predatory Extraction" Strategy
    
    This strategy maximizes immediate gains through strategic aggressive extraction.
    It exploits cooperative opponents, manages resources to maintain extraction 
    opportunities, and uses adaptive phases throughout the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        round_num = history.round_number + 1
        current_stock = self._estimate_current_stock(history, capacity, n)
        if round_num <= r // 4:
            if current_stock >= capacity * 0.8:
                return Action.D
            else:
                return self._conditional_defect(history, current_stock, capacity, n)
        elif round_num <= 3 * r // 4:
            return self._strategic_extraction(history, current_stock, capacity, n)
        else:
            return self._endgame_extraction(history, current_stock, capacity, n, r, round_num)

    def _estimate_current_stock(self, history: PlayerHistory, capacity: float, n: int) -> float:
        """Estimate current stock level based on history"""
        stock = capacity
        for round_idx in range(history.round_number):
            my_action_was_coop = history.my_actions[round_idx]
            opponent_coops = np.sum(history.opponent_actions[round_idx])
            total_coops = int(opponent_coops) + (1 if my_action_was_coop else 0)
            total_defects = n - total_coops
            coop_consumption = total_coops * (stock / (2 * n))
            defect_consumption = total_defects * (stock / n)
            total_consumption = coop_consumption + defect_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            stock = min(stock_after_consumption + growth, capacity)
        return stock

    def _conditional_defect(self, history: PlayerHistory, stock: float, capacity: float, n: int) -> Action:
        """Conditional defection logic for early phase"""
        last_round_idx = history.round_number - 1
        cooperator_count = np.sum(history.opponent_actions[last_round_idx])
        if cooperator_count >= n // 2:
            return Action.D
        if stock < capacity * 0.3:
            return Action.D
        return Action.C

    def _strategic_extraction(self, history: PlayerHistory, stock: float, capacity: float, n: int) -> Action:
        """Strategic extraction logic for middle phase"""
        last_round_idx = history.round_number - 1
        defector_count = n - 1 - np.sum(history.opponent_actions[last_round_idx])
        defector_ratio = defector_count / (n - 1)
        if stock >= capacity * 0.6:
            return Action.D
        if defector_ratio >= 0.5:
            return Action.D
        if stock < capacity * 0.25:
            recent_defection_rate = self._get_recent_defection_rate(history, 3, n)
            if recent_defection_rate < 0.3:
                return Action.C
        return Action.D

    def _endgame_extraction(self, history: PlayerHistory, stock: float, capacity: float, n: int, r: int, round_num: int) -> Action:
        """Endgame extraction logic for final phase"""
        rounds_remaining = r - round_num
        if rounds_remaining <= 1:
            return Action.D
        projected_consumption_per_round = self._estimate_total_consumption(history, n)
        if stock > projected_consumption_per_round * rounds_remaining:
            return Action.D
        if stock < capacity * 0.15:
            return Action.C
        return Action.D

    def _get_recent_defection_rate(self, history: PlayerHistory, lookback_rounds: int, n: int) -> float:
        """Calculate recent defection rate among opponents"""
        start_round = max(0, history.round_number - lookback_rounds)
        total_decisions = 0
        total_defections = 0
        for round_idx in range(start_round, history.round_number):
            opponent_defections = n - 1 - np.sum(history.opponent_actions[round_idx])
            total_defections += opponent_defections
            total_decisions += n - 1
        if total_decisions == 0:
            return 0.5
        return total_defections / total_decisions

    def _estimate_total_consumption(self, history: PlayerHistory, n: int) -> float:
        """Estimate average total consumption per round based on recent history"""
        if history.round_number == 0:
            return 0.5
        lookback = min(3, history.round_number)
        total_payoffs = 0
        for round_idx in range(history.round_number - lookback, history.round_number):
            my_payoff = history.my_payoffs[round_idx]
            opponent_payoffs = np.sum(history.opponent_payoffs[round_idx])
            total_payoffs += my_payoff + opponent_payoffs
        avg_total_payoff = total_payoffs / lookback
        return avg_total_payoff

class Strategy_AGGRESSIVE_57(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Resource Raider"
    
    This strategy exploits resources aggressively early, adapts based on stock levels
    and opponent behavior, and maximizes extraction in endgame phases.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round <= 2:
            return Action.D
        current_stock = self._estimate_current_stock(history)
        stock_ratio = current_stock / self.capacity
        if current_round > self.n_rounds - 2:
            return Action.D
        if stock_ratio < 0.3:
            if current_round > 1:
                prev_cooperators = sum(history.opponent_actions[history.round_number - 1])
                if prev_cooperators >= self.n_players / 2:
                    return Action.C
            return Action.D
        elif stock_ratio < 0.6:
            opponent_defection_rate = self._get_opponent_defection_rate_last_3_rounds(history)
            if opponent_defection_rate > 0.6:
                return Action.D
            else:
                return Action.C
        elif current_round <= self.n_rounds * 0.7:
            return Action.D
        else:
            defect_probability = stock_ratio * 0.8
            if random.random() < defect_probability:
                return Action.D
            else:
                return Action.C

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game dynamics."""
        stock = self.capacity
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            cooperators = sum(opponent_actions) + (1 if my_action else 0)
            defectors = self.n_players - cooperators
            cooperator_consumption = stock / (2 * self.n_players)
            defector_consumption = stock / self.n_players
            total_consumption = cooperators * cooperator_consumption + defectors * defector_consumption
            stock_after = max(0, stock - total_consumption)
            growth = 2 * stock_after * (1 - stock_after / self.capacity)
            stock = min(stock_after + growth, self.capacity)
        return stock

    def _get_opponent_defection_rate_last_3_rounds(self, history: PlayerHistory) -> float:
        """Calculate opponent defection rate over the last 3 rounds."""
        if history.round_number == 0:
            return 0.0
        start_round = max(0, history.round_number - 3)
        end_round = history.round_number
        total_decisions = 0
        total_defections = 0
        for round_idx in range(start_round, end_round):
            opponent_actions = history.opponent_actions[round_idx]
            total_decisions += len(opponent_actions)
            total_defections += sum(1 - opponent_actions)
        if total_decisions == 0:
            return 0.0
        return total_defections / total_decisions

class Strategy_AGGRESSIVE_58(BaseStrategy):
    """
    Opportunistic Predator: An aggressive exploitation strategy that prioritizes immediate gains
    while strategically preserving the resource only when necessary to maintain future exploitation
    opportunities. Always defects in opening and closing rounds, exploits cooperative opponents,
    and only cooperates when resource collapse would eliminate future profits.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_num = history.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = self._estimate_current_stock(history)
        if round_num == r:
            return Action.D
        if current_stock <= capacity * 0.15 and current_stock > 0:
            return Action.D
        if current_stock <= capacity * 0.05:
            return Action.C
        if round_num <= 2:
            return Action.D
        if current_stock >= capacity * 0.7:
            return Action.D
        if round_num > 1:
            last_round_cooperators = sum(history.opponent_actions[round_num - 2])
            cooperation_rate = last_round_cooperators / n
            if cooperation_rate >= 0.6:
                return Action.D
        if round_num > 3:
            stock_trend = self._calculate_stock_trend(history, 3)
            if stock_trend > 0 and current_stock >= capacity * 0.4:
                return Action.D
        remaining_rounds = r - round_num
        if remaining_rounds > 3:
            projected_stock = self._estimate_stock_if_all_defect(current_stock, n)
            if projected_stock <= 0:
                return Action.C
        if remaining_rounds <= 3 and current_stock >= capacity * 0.2:
            return Action.D
        return Action.D

    def _estimate_current_stock(self, history):
        """Estimate current stock level based on payoff history"""
        capacity = self.game_description.capacity
        n = self.game_description.n_players
        stock = capacity
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0
            if my_action:
                total_consumption += stock / (2 * n)
            else:
                total_consumption += stock / n
            for opponent_action in opponent_actions:
                if opponent_action:
                    total_consumption += stock / (2 * n)
                else:
                    total_consumption += stock / n
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            stock = min(stock_after_consumption + growth, capacity)
        return stock

    def _calculate_stock_trend(self, history, lookback_rounds):
        """Calculate stock trend over the last few rounds"""
        if history.round_number < lookback_rounds:
            return 0
        stock_levels = []
        temp_stock = self.game_description.capacity
        start_round = max(0, history.round_number - lookback_rounds)
        for round_idx in range(start_round, history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            cooperators = sum(opponent_actions) + (1 if my_action else 0)
            defectors = self.game_description.n_players - cooperators
            consumption = cooperators * temp_stock / (2 * self.game_description.n_players) + defectors * temp_stock / self.game_description.n_players
            stock_after = max(0, temp_stock - consumption)
            growth = 2 * stock_after * (1 - stock_after / self.game_description.capacity)
            temp_stock = min(stock_after + growth, self.game_description.capacity)
            stock_levels.append(temp_stock)
        if len(stock_levels) < 2:
            return 0
        return stock_levels[-1] - stock_levels[0]

    def _estimate_stock_if_all_defect(self, current_stock, n):
        """Estimate resulting stock if all players defect this round"""
        total_consumption = current_stock
        stock_after = max(0, current_stock - total_consumption)
        capacity = self.game_description.capacity
        growth = 2 * stock_after * (1 - stock_after / capacity)
        return min(stock_after + growth, capacity)

class Strategy_AGGRESSIVE_59(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Predator"
    
    Operates on maximum immediate extraction while maintaining minimal sustainability.
    Always defects first, exploits cooperative opponents, and only cooperates when 
    stock is critically low or strategic rebuilding is needed.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.emergency_mode = False
        self.previous_stock_level = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_stock = self._estimate_current_stock(history)
        if self.emergency_mode and current_stock > self.game_description.capacity * 0.4:
            self.emergency_mode = False
        elif current_stock < self.previous_stock_level * 0.7:
            self.emergency_mode = True
        self.previous_stock_level = current_stock
        if history.round_number >= self.game_description.n_rounds - 1:
            return Action.D
        if current_stock <= self.game_description.capacity * 0.15 or self.emergency_mode:
            return Action.C
        if history.round_number > 0:
            last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
            if last_round_cooperators >= self.game_description.n_players / 2:
                return Action.D
            if history.round_number >= 2:
                consecutive_defections = self._count_consecutive_defections(history)
                if consecutive_defections >= 2:
                    return Action.C
        return Action.D

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game history"""
        stock = float(self.game_description.capacity)
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        for round_idx in range(history.round_number):
            my_consumption = stock / (2 * n) if history.my_actions[round_idx] else stock / n
            opponent_consumption = 0
            for player_idx in range(n - 1):
                if history.opponent_actions[round_idx, player_idx]:
                    opponent_consumption += stock / (2 * n)
                else:
                    opponent_consumption += stock / n
            total_consumption = my_consumption + opponent_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            stock = min(stock_after_consumption + growth, capacity)
        return stock

    def _count_consecutive_defections(self, history: PlayerHistory) -> int:
        """Count consecutive rounds where majority of opponents defected"""
        consecutive = 0
        n_opponents = self.game_description.n_players - 1
        for round_idx in range(history.round_number - 1, -1, -1):
            cooperators = sum(history.opponent_actions[round_idx])
            if cooperators < n_opponents / 2:
                consecutive += 1
            else:
                break
        return consecutive

class Strategy_AGGRESSIVE_60(BaseStrategy):
    """
    Aggressive Resource Exploitation Strategy: "Predator"
    
    This strategy operates on the principle of aggressive early extraction while maintaining 
    the ability to sustain exploitation when the pool is threatened. Uses front-loaded 
    aggression, opportunistic free-riding, and competitive matching to maximize individual payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        current_stock = self._estimate_current_stock(history)
        if current_round <= 0.3 * self.r:
            if current_stock >= self.capacity * 0.7:
                return Action.D
            else:
                return self._exploit_weakened_pool(current_stock, history)
        elif current_round <= 0.8 * self.r:
            return self._adaptive_exploitation(current_round, current_stock, history)
        else:
            return self._endgame_strategy(current_round, current_stock, history)

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game dynamics."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            cooperators = int(my_action) + sum(opponent_actions)
            defectors = self.n - cooperators
            cooperator_consumption = cooperators * (stock / (2 * self.n))
            defector_consumption = defectors * (stock / self.n)
            total_consumption = cooperator_consumption + defector_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _count_defectors_last_round(self, history: PlayerHistory) -> int:
        """Count number of defectors in the most recent round."""
        if history.round_number == 0:
            return 0
        last_round = history.round_number - 1
        my_defected = not history.my_actions[last_round]
        opponent_defections = sum((1 - action for action in history.opponent_actions[last_round]))
        return int(my_defected) + opponent_defections

    def _calculate_cooperation_rate(self, history: PlayerHistory, last_n_rounds: int=3) -> float:
        """Calculate cooperation rate over the last n rounds."""
        if history.round_number == 0:
            return 0.5
        start_round = max(0, history.round_number - last_n_rounds)
        total_actions = 0
        total_cooperations = 0
        for round_idx in range(start_round, history.round_number):
            my_cooperation = int(history.my_actions[round_idx])
            opponent_cooperations = sum(history.opponent_actions[round_idx])
            total_actions += self.n
            total_cooperations += my_cooperation + opponent_cooperations
        return total_cooperations / total_actions if total_actions > 0 else 0.5

    def _exploit_weakened_pool(self, stock: float, history: PlayerHistory) -> Action:
        """Strategy for exploiting a weakened pool."""
        defector_count = self._count_defectors_last_round(history)
        if defector_count >= self.n / 2:
            return Action.D
        elif stock >= self.capacity * 0.4:
            return Action.D
        else:
            return Action.C

    def _adaptive_exploitation(self, current_round: int, stock: float, history: PlayerHistory) -> Action:
        """Adaptive exploitation strategy for middle rounds."""
        recent_cooperation_rate = self._calculate_cooperation_rate(history, 3)
        if recent_cooperation_rate > 0.6:
            if stock >= self.capacity * 0.5:
                return Action.D
            else:
                return Action.C
        elif recent_cooperation_rate > 0.3:
            if stock >= self.capacity * 0.6:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

    def _endgame_strategy(self, current_round: int, stock: float, history: PlayerHistory) -> Action:
        """Strategy for endgame rounds."""
        rounds_left = self.r - current_round
        if rounds_left == 0:
            return Action.D
        if rounds_left <= 2:
            consumption_if_all_defect = self.n * (stock / self.n)
            if stock >= consumption_if_all_defect:
                return Action.D
            else:
                return Action.C
        else:
            return self._adaptive_exploitation(current_round, stock, history)

class Strategy_AGGRESSIVE_61(BaseStrategy):
    """
    Aggressive "Vulture" Strategy: Exploits resources aggressively while maintaining minimal sustainability.
    Always defects in first and last rounds, uses stock-based thresholds and opponent behavior analysis
    to maximize extraction while preventing complete resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.exploitation_threshold = self.capacity * 0.15
        self.critical_threshold = self.capacity * 0.05
        self.high_stock_threshold = self.capacity * 0.5

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.n_rounds:
            return Action.D
        current_stock = self._estimate_current_stock(history)
        if current_stock <= self.critical_threshold:
            return Action.C
        if current_stock <= self.exploitation_threshold:
            return Action.C
        recent_defection_rate = self._calculate_recent_defection_rate(history)
        if recent_defection_rate > 0.6:
            return Action.D
        if recent_defection_rate < 0.3:
            return Action.D
        if current_stock > self.high_stock_threshold:
            return Action.D
        elif random.random() < 0.7:
            return Action.D
        else:
            return Action.C

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game history"""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            total_consumption = 0.0
            if history.my_actions[round_idx]:
                my_consumption = stock / (2 * self.n_players)
            else:
                my_consumption = stock / self.n_players
            total_consumption += my_consumption
            for opponent_idx in range(self.n_players - 1):
                if history.opponent_actions[round_idx, opponent_idx]:
                    opponent_consumption = stock / (2 * self.n_players)
                else:
                    opponent_consumption = stock / self.n_players
                total_consumption += opponent_consumption
            stock_after_consumption = max(0.0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            else:
                growth = 0.0
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _calculate_recent_defection_rate(self, history: PlayerHistory) -> float:
        """Calculate opponent defection rate over the last 3 rounds (or all available rounds)"""
        if history.round_number == 0:
            return 0.5
        rounds_to_analyze = min(3, history.round_number)
        start_round = history.round_number - rounds_to_analyze
        total_decisions = 0
        total_defections = 0
        for round_idx in range(start_round, history.round_number):
            for opponent_idx in range(self.n_players - 1):
                total_decisions += 1
                if not history.opponent_actions[round_idx, opponent_idx]:
                    total_defections += 1
        if total_decisions == 0:
            return 0.5
        return total_defections / total_decisions

class Strategy_AGGRESSIVE_62(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Resource Raider"
    
    Operates on maximum immediate extraction while maintaining resource base
    just enough for continued exploitation. Exploits cooperative opponents
    while using threshold-based resource management.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        current_stock = self._estimate_current_stock(history)
        if current_stock <= self.capacity * 0.2:
            return Action.D
        if current_round > self.n_rounds - 3:
            return Action.D
        if current_round <= 3:
            return Action.D
        opponent_coop_rate = self._calculate_opponent_cooperation_rate(history)
        if opponent_coop_rate > 0.6:
            return Action.D
        if opponent_coop_rate > 0.3:
            if current_stock > self.capacity * 0.5:
                return Action.D
            else:
                return Action.C
        if current_stock < self.capacity * 0.3:
            return Action.C
        else:
            return Action.D

    def _calculate_opponent_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate the cooperation rate of all opponents across all completed rounds."""
        if history.round_number == 0:
            return 0.0
        total_opponent_actions = 0
        total_cooperations = 0
        for round_idx in range(history.round_number):
            opponent_actions_this_round = history.opponent_actions[round_idx]
            total_opponent_actions += len(opponent_actions_this_round)
            total_cooperations += sum(opponent_actions_this_round)
        if total_opponent_actions == 0:
            return 0.0
        return total_cooperations / total_opponent_actions

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game dynamics."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            n_cooperators = sum(opponent_actions) + (1 if my_action else 0)
            n_defectors = self.n_players - n_cooperators
            cooperator_consumption = stock / (2 * self.n_players)
            defector_consumption = stock / self.n_players
            total_consumption = n_cooperators * cooperator_consumption + n_defectors * defector_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

class Strategy_AGGRESSIVE_63(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Predator"
    
    Maximizes individual payoffs through aggressive exploitation with three phases:
    1. Early Exploitation: Always defect to maximize gains while stock is high
    2. Strategic Assessment: Exploit cooperative opponents with minimal emergency cooperation
    3. Endgame Extraction: Maximum extraction with last-resort cooperation to avoid collapse
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_number = history.round_number + 1
        stock_level = self._calculate_current_stock(history)
        if round_number <= self.n_rounds / 3:
            return Action.D
        if round_number > 2 * self.n_rounds / 3:
            if stock_level < self.capacity / 10:
                return Action.C
            else:
                return Action.D
        last_round_idx = history.round_number - 1
        cooperators_last_round = np.sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            cooperators_last_round += 1
        if cooperators_last_round >= self.n_players / 2:
            return Action.D
        if stock_level < self.capacity / 4:
            all_defected_last_round = np.sum(history.opponent_actions[last_round_idx]) == 0 and (not history.my_actions[last_round_idx])
            if all_defected_last_round:
                return Action.C
            else:
                return Action.D
        return Action.D

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game history."""
        stock = self.capacity
        for round_idx in range(history.round_number):
            my_consumption = self._get_consumption(history.my_actions[round_idx], stock)
            opponent_consumption = 0
            for opponent_idx in range(self.n_players - 1):
                opponent_action = history.opponent_actions[round_idx, opponent_idx]
                opponent_consumption += self._get_consumption(opponent_action, stock)
            total_consumption = my_consumption + opponent_consumption
            stock_after_consumption = stock - total_consumption
            stock_after_consumption = max(0, stock_after_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _get_consumption(self, action: bool, stock: float) -> float:
        """Calculate consumption based on action and current stock."""
        if action:
            return stock / (2 * self.n_players)
        else:
            return stock / self.n_players

class Strategy_AGGRESSIVE_64(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Resource Raider"
    
    This strategy maximizes immediate gains through conditional defection,
    exploiting cooperative opponents while maintaining minimal resource conservation
    to prevent complete collapse. Always defects in first and final rounds,
    and uses opponent cooperation rates to determine exploitation opportunities.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.n_rounds:
            return Action.D
        stock_ratio = self._estimate_stock_ratio(history)
        if stock_ratio <= 0.15:
            return Action.C
        last_round_idx = history.round_number - 1
        opponent_cooperators = np.sum(history.opponent_actions[last_round_idx])
        opponent_cooperation_rate = opponent_cooperators / (self.n_players - 1)
        if stock_ratio <= 0.3 and opponent_cooperation_rate < 0.3:
            return Action.C
        if opponent_cooperation_rate >= 0.4:
            return Action.D
        return Action.D

    def _estimate_stock_ratio(self, history: PlayerHistory) -> float:
        """
        Estimate current stock level based on payoff history.
        Uses the fact that payoffs are proportional to stock level.
        """
        if history.round_number == 0:
            return 1.0
        last_round_idx = history.round_number - 1
        my_last_payoff = history.my_payoffs[last_round_idx]
        my_last_action = history.my_actions[last_round_idx]
        if my_last_action:
            estimated_stock = my_last_payoff * 2 * self.n_players
        else:
            estimated_stock = my_last_payoff * self.n_players
        return max(0.0, min(1.0, estimated_stock / self.capacity))

class Strategy_AGGRESSIVE_65(BaseStrategy):
    """
    Aggressive "Punitive Exploiter" Strategy.
    
    Starts with defection, exploits cooperative opponents, and brutally punishes
    any defection. Only cooperates when resource stock is critically low.
    Always defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.n_rounds:
            return Action.D
        stock = self._estimate_current_stock(history)
        if stock <= self.capacity * 0.15:
            return Action.C
        last_round_idx = history.round_number - 1
        last_opponent_actions = history.opponent_actions[last_round_idx]
        all_opponents_cooperated = all(last_opponent_actions)
        any_opponent_defected = not all(last_opponent_actions)
        if all_opponents_cooperated:
            return Action.D
        elif any_opponent_defected:
            return Action.D
        else:
            my_cumulative_payoff = np.sum(history.my_payoffs)
            opponent_cumulative_payoffs = np.sum(history.opponent_payoffs, axis=0)
            average_opponent_payoff = np.mean(opponent_cumulative_payoffs)
            if my_cumulative_payoff < average_opponent_payoff:
                return Action.D
            else:
                return Action.C

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game history."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            n_cooperators = int(my_action) + int(np.sum(opponent_actions))
            n_defectors = self.n_players - n_cooperators
            cooperator_consumption = stock / (2 * self.n_players)
            defector_consumption = stock / self.n_players
            total_consumption = n_cooperators * cooperator_consumption + n_defectors * defector_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
                stock = min(stock_after_consumption + growth, self.capacity)
            else:
                stock = 0
        return stock

class Strategy_AGGRESSIVE_66(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Shark"
    
    This strategy maximizes exploitation while maintaining minimal resource sustainability.
    It defects aggressively when stock is high, exploits cooperative opponents, and uses
    tactical cooperation only to prevent total resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = self.capacity * 0.3
        self.punishment_rounds_remaining = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        current_stock = self._estimate_current_stock(history)
        if current_round == self.n_rounds:
            return Action.D
        if self.punishment_rounds_remaining > 0:
            self.punishment_rounds_remaining -= 1
            return Action.C
        if current_stock <= self.critical_threshold:
            if current_stock <= self.capacity * 0.2:
                self.punishment_rounds_remaining = 1
            return Action.C
        if self._can_exploit_cooperators(history, current_stock):
            return Action.D
        return self._tactical_cooperation(history, current_stock, current_round)

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game dynamics."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_consumption = stock / (2 * self.n_players) if history.my_actions[round_idx] else stock / self.n_players
            opponent_consumption = 0
            for player_idx in range(self.n_players - 1):
                if history.opponent_actions[round_idx, player_idx]:
                    opponent_consumption += stock / (2 * self.n_players)
                else:
                    opponent_consumption += stock / self.n_players
            total_consumption = my_consumption + opponent_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
                stock = min(stock_after_consumption + growth, self.capacity)
            else:
                stock = 0
        return stock

    def _can_exploit_cooperators(self, history: PlayerHistory, current_stock: float) -> bool:
        """Check if we can profitably exploit cooperative opponents."""
        if current_stock <= self.critical_threshold:
            return False
        if history.round_number > 0:
            recent_cooperators = sum(history.opponent_actions[history.round_number - 1])
            cooperator_ratio = recent_cooperators / (self.n_players - 1)
            if cooperator_ratio >= 0.5 and current_stock > self.critical_threshold:
                return True
        return False

    def _tactical_cooperation(self, history: PlayerHistory, current_stock: float, current_round: int) -> Action:
        """Decide whether to cooperate tactically or continue defecting."""
        if current_round == self.n_rounds - 1:
            if current_stock > self.capacity * 0.5:
                return Action.C
            else:
                return Action.D
        if history.round_number >= 2:
            previous_stock = self._estimate_stock_at_round(history, history.round_number - 2)
            if current_stock < previous_stock * 0.7:
                return Action.C
        if history.round_number > 0:
            recent_defectors = self.n_players - 1 - sum(history.opponent_actions[history.round_number - 1])
            defector_ratio = recent_defectors / (self.n_players - 1)
            if defector_ratio > 0.6:
                return Action.C
        return Action.D

    def _estimate_stock_at_round(self, history: PlayerHistory, target_round: int) -> float:
        """Estimate stock level at a specific past round."""
        if target_round < 0:
            return float(self.capacity)
        stock = float(self.capacity)
        for round_idx in range(min(target_round + 1, history.round_number)):
            my_consumption = stock / (2 * self.n_players) if history.my_actions[round_idx] else stock / self.n_players
            opponent_consumption = 0
            for player_idx in range(self.n_players - 1):
                if history.opponent_actions[round_idx, player_idx]:
                    opponent_consumption += stock / (2 * self.n_players)
                else:
                    opponent_consumption += stock / self.n_players
            total_consumption = my_consumption + opponent_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
                stock = min(stock_after_consumption + growth, self.capacity)
            else:
                stock = 0
        return stock

class Strategy_AGGRESSIVE_67(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Opportunistic Predator"
    
    Maximizes immediate gains by defaulting to defection, but cooperates strategically
    when stock is critically low and future exploitation opportunities exist.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        if current_round == total_rounds:
            return Action.D
        current_stock = self._estimate_current_stock(history)
        stock_ratio = current_stock / capacity
        if stock_ratio < 0.3 and total_rounds - current_round >= 2:
            if history.round_number > 0:
                last_round_cooperators = np.sum(history.opponent_actions[history.round_number - 1])
                cooperation_rate = last_round_cooperators / (n_players - 1)
                if cooperation_rate >= 0.5:
                    projected_recovery = self._estimate_stock_recovery(current_stock, capacity, n_players)
                    if projected_recovery > current_stock * 1.5:
                        return Action.C
        if current_round == total_rounds - 1 and stock_ratio < 0.1:
            return Action.C
        return Action.D

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game history."""
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        stock = float(capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0.0
            if my_action:
                total_consumption += stock / (2 * n_players)
            else:
                total_consumption += stock / n_players
            for opp_action in opponent_actions:
                if opp_action:
                    total_consumption += stock / (2 * n_players)
                else:
                    total_consumption += stock / n_players
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            stock = min(stock_after_consumption + growth, capacity)
        return stock

    def _estimate_stock_recovery(self, current_stock: float, capacity: float, n_players: int) -> float:
        """Estimate stock recovery assuming minimal cooperation from others."""
        assumed_consumption = current_stock * (0.5 * (1 / (2 * n_players)) + 0.5 * (1 / n_players))
        assumed_consumption *= n_players - 1
        assumed_consumption += current_stock / (2 * n_players)
        remaining = max(0, current_stock - assumed_consumption)
        growth = 2 * remaining * (1 - remaining / capacity)
        return min(remaining + growth, capacity)

class Strategy_AGGRESSIVE_68(BaseStrategy):
    """
    Aggressive Resource Exploitation Strategy: "Predator"
    
    This strategy prioritizes immediate maximum extraction while using intimidation 
    and punishment to deter others from defecting. It establishes dominance early
    and uses graduated punishment to control opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.n_rounds:
            return Action.D
        current_stock = self._estimate_current_stock(history)
        if current_round == self.n_rounds - 1:
            return self._penultimate_round_logic(history, current_stock)
        return self._adaptive_aggression_logic(history, current_stock)

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on consumption and growth dynamics."""
        stock = self.capacity
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0
            if my_action:
                total_consumption += stock / (2 * self.n_players)
            else:
                total_consumption += stock / self.n_players
            for opp_action in opponent_actions:
                if opp_action:
                    total_consumption += stock / (2 * self.n_players)
                else:
                    total_consumption += stock / self.n_players
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _count_defectors_last_round(self, history: PlayerHistory) -> int:
        """Count how many opponents defected in the last round."""
        if history.round_number == 0:
            return 0
        last_round_actions = history.opponent_actions[history.round_number - 1]
        return sum((1 for action in last_round_actions if not action))

    def _calculate_cooperation_ratio(self, history: PlayerHistory) -> float:
        """Calculate overall cooperation ratio across all completed rounds."""
        if history.round_number == 0:
            return 1.0
        total_actions = 0
        total_cooperations = 0
        for round_idx in range(history.round_number):
            opponent_actions = history.opponent_actions[round_idx]
            total_actions += len(opponent_actions)
            total_cooperations += sum(opponent_actions)
        return total_cooperations / total_actions if total_actions > 0 else 1.0

    def _majority_defected_last_3_rounds(self, history: PlayerHistory) -> bool:
        """Check if majority defected in the last 3 rounds."""
        if history.round_number < 3:
            return False
        defection_count = 0
        total_count = 0
        start_round = max(0, history.round_number - 3)
        for round_idx in range(start_round, history.round_number):
            opponent_actions = history.opponent_actions[round_idx]
            total_count += len(opponent_actions)
            defection_count += sum((1 for action in opponent_actions if not action))
        return defection_count > total_count / 2

    def _adaptive_aggression_logic(self, history: PlayerHistory, current_stock: float) -> Action:
        """Implement adaptive aggression for rounds 2 to r-2."""
        defector_count = self._count_defectors_last_round(history)
        cooperation_ratio = self._calculate_cooperation_ratio(history)
        if self._should_continue_punishment(history):
            return Action.D
        if defector_count == 0:
            return Action.C
        elif defector_count == 1:
            return Action.D
        elif defector_count >= 2:
            return Action.D
        if current_stock < self.capacity * 0.3:
            if cooperation_ratio > 0.6:
                return Action.C
            else:
                return Action.D
        return Action.D

    def _should_continue_punishment(self, history: PlayerHistory) -> bool:
        """Check if we should continue hair-trigger punishment."""
        if history.round_number < 2:
            return False
        recent_rounds = min(3, history.round_number)
        punishment_active = False
        for i in range(1, recent_rounds + 1):
            round_idx = history.round_number - i
            if round_idx < 0:
                break
            defector_count = sum((1 for action in history.opponent_actions[round_idx] if not action))
            my_defected = not history.my_actions[round_idx]
            if defector_count >= 2 and my_defected and (i <= 2):
                punishment_active = True
                break
        return punishment_active

    def _penultimate_round_logic(self, history: PlayerHistory, current_stock: float) -> Action:
        """Logic for round r-1."""
        if current_stock > self.capacity * 0.5:
            return Action.D
        elif current_stock > self.capacity * 0.2:
            if self._majority_defected_last_3_rounds(history):
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_69(BaseStrategy):
    """
    Adaptive Predator: An aggressive strategy that maximizes immediate payoffs while using 
    sophisticated opponent modeling to maintain long-term resource availability. Exploits 
    cooperative opponents while avoiding mutual destruction through strategic cooperation 
    when resources are critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.n_rounds:
            return Action.D
        last_round_idx = history.round_number - 1
        my_last_payoff = history.my_payoffs[last_round_idx]
        if history.my_actions[last_round_idx]:
            estimated_stock = my_last_payoff * 2 * self.n_players
        else:
            estimated_stock = my_last_payoff * self.n_players
        if estimated_stock <= self.capacity * 0.15:
            return Action.C
        last_round_cooperators = sum(history.opponent_actions[last_round_idx])
        cooperation_rate = last_round_cooperators / (self.n_players - 1)
        total_opponent_cooperations = np.sum(history.opponent_actions)
        total_possible_cooperations = history.round_number * (self.n_players - 1)
        historical_cooperation = total_opponent_cooperations / total_possible_cooperations if total_possible_cooperations > 0 else 0
        if cooperation_rate >= 0.6:
            return Action.D
        if historical_cooperation >= 0.7 and estimated_stock >= self.capacity * 0.4:
            return Action.D
        if cooperation_rate <= 0.2 and estimated_stock >= self.capacity * 0.3:
            return Action.D
        if estimated_stock < self.capacity * 0.3 and cooperation_rate >= 0.4:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_70(BaseStrategy):
    """
    Scorched Earth Maximizer: Aggressive resource exploitation strategy that prioritizes 
    immediate maximum payoff extraction with strategic cooperation only when it serves 
    long-term aggressive goals.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        stock = self._calculate_current_stock(history)
        if current_round > self.n_rounds - 3:
            return Action.D
        if stock < self.capacity / 10:
            if current_round < self.n_rounds / 2:
                return Action.C
            else:
                return Action.D
        if current_round <= self.n_rounds / 3:
            return Action.D
        if stock < self.capacity / 4:
            if self._opponents_mostly_cooperating(history):
                return Action.C
            else:
                return Action.D
        return self._conditional_aggression(history, stock)

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game dynamics."""
        stock = self.capacity
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0
            if my_action:
                total_consumption += stock / (2 * self.n_players)
            else:
                total_consumption += stock / self.n_players
            for opp_action in opponent_actions:
                if opp_action:
                    total_consumption += stock / (2 * self.n_players)
                else:
                    total_consumption += stock / self.n_players
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _opponents_mostly_cooperating(self, history: PlayerHistory) -> bool:
        """Check if opponents are mostly cooperating in recent rounds."""
        if history.round_number == 0:
            return False
        lookback = min(3, history.round_number)
        total_decisions = 0
        total_cooperation = 0
        for round_idx in range(history.round_number - lookback, history.round_number):
            for opp_action in history.opponent_actions[round_idx]:
                total_decisions += 1
                if opp_action:
                    total_cooperation += 1
        if total_decisions == 0:
            return False
        cooperation_rate = total_cooperation / total_decisions
        return cooperation_rate > 0.6

    def _conditional_aggression(self, history: PlayerHistory, stock: float) -> Action:
        """Implement conditional aggression logic."""
        if history.round_number == 0:
            return Action.D
        last_round_idx = history.round_number - 1
        cooperators = sum(history.opponent_actions[last_round_idx])
        cooperation_rate = cooperators / (self.n_players - 1)
        if cooperation_rate >= 0.7:
            return Action.D
        elif cooperation_rate <= 0.3:
            if stock > self.capacity / 2:
                return Action.C
            else:
                return Action.D
        else:
            my_total_payoff = sum(history.my_payoffs)
            opponent_total_payoffs = np.sum(history.opponent_payoffs, axis=0)
            avg_opponent_payoff = np.mean(opponent_total_payoffs)
            if my_total_payoff < avg_opponent_payoff:
                return Action.D
            else:
                return Action.C

class Strategy_AGGRESSIVE_71(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Resource Vampire"
    
    Operates on maximum immediate extraction while strategically timing cooperation
    only when absolutely necessary. Defects by default but cooperates when stock
    is critically low or in late game scenarios to preserve minimal resources.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.zero_stock_consecutive_rounds = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.zero_stock_consecutive_rounds = 0
            return Action.D
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = self._estimate_current_stock(history)
        if current_stock <= 0:
            self.zero_stock_consecutive_rounds += 1
        else:
            self.zero_stock_consecutive_rounds = 0
        if current_round == total_rounds:
            return Action.D
        rounds_remaining = total_rounds - current_round
        stock_ratio = current_stock / capacity if capacity > 0 else 0
        if stock_ratio < 0.3:
            return Action.C
        if rounds_remaining <= 3 and stock_ratio < 0.5:
            return Action.C
        if self.zero_stock_consecutive_rounds >= 2 and stock_ratio < 0.2:
            return Action.C
        if self._all_opponents_cooperated_last_round(history) and stock_ratio < 0.4:
            return Action.C
        return Action.D

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """
        Estimate current stock based on payoff patterns.
        Since payoff = stock/(2n) for cooperate and stock/n for defect,
        we can work backwards from the most recent payoffs.
        """
        if len(history.my_payoffs) == 0:
            return self.game_description.capacity
        last_payoff = history.my_payoffs[-1]
        last_action = history.my_actions[-1]
        n = self.game_description.n_players
        if last_payoff <= 0:
            return 0.0
        if last_action:
            estimated_pre_consumption_stock = last_payoff * 2 * n
        else:
            estimated_pre_consumption_stock = last_payoff * n
        if last_payoff < self.game_description.capacity / (4 * n):
            return max(0, estimated_pre_consumption_stock * 0.3)
        elif last_payoff < self.game_description.capacity / (2 * n):
            return max(0, estimated_pre_consumption_stock * 0.6)
        else:
            return max(0, estimated_pre_consumption_stock * 0.8)

    def _all_opponents_cooperated_last_round(self, history: PlayerHistory) -> bool:
        """Check if all opponents cooperated in the most recent round."""
        if history.round_number == 0:
            return False
        last_round_actions = history.opponent_actions[history.round_number - 1]
        return np.all(last_round_actions)

class Strategy_AGGRESSIVE_72(BaseStrategy):
    """
    Aggressive Opportunistic "Resource Hawk" Strategy.
    
    Maximizes short-term gains through aggressive exploitation while strategically managing 
    the resource to ensure continued opportunities. Features aggressive opening, dynamic 
    exploitation based on opponent behavior, emergency conservation protocols, and endgame acceleration.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_num = history.round_number + 1
        stock = self._calculate_current_stock(history)
        if round_num <= 3:
            return Action.D
        if stock < self.capacity * 0.15:
            return Action.C
        if round_num > self.r * 0.8:
            if stock > self.capacity * 0.3:
                return Action.D
            else:
                return Action.C
        last_round_idx = history.round_number - 1
        defector_count = np.sum(history.opponent_actions[last_round_idx] == 0)
        if not history.my_actions[last_round_idx]:
            defector_count += 1
        defector_ratio = defector_count / self.n
        if defector_ratio < 0.4:
            return Action.D
        if defector_ratio > 0.7:
            return Action.C
        my_total = np.sum(history.my_payoffs)
        opponent_total = np.sum(history.opponent_payoffs)
        avg_opponent = opponent_total / (self.n - 1)
        advantage = my_total - avg_opponent
        return Action.D

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game dynamics."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            my_consumption = stock / (2 * self.n) if my_action else stock / self.n
            opponent_consumption = 0
            for opp_idx in range(self.n - 1):
                opp_action = history.opponent_actions[round_idx, opp_idx]
                opponent_consumption += stock / (2 * self.n) if opp_action else stock / self.n
            total_consumption = my_consumption + opponent_consumption
            stock_after = stock - total_consumption
            stock_after = max(0, stock_after)
            growth = 2 * stock_after * (1 - stock_after / self.capacity)
            growth = max(0, growth)
            stock = min(stock_after + growth, self.capacity)
        return stock

class Strategy_AGGRESSIVE_73(BaseStrategy):
    """
    Aggressive Strategy: "Exploitation with Strategic Restraint"
    
    Defaults to defection to maximize immediate payoffs and exploit cooperative opponents.
    Only cooperates when the resource is critically depleted AND there are sufficient rounds
    remaining AND the strategy has been sufficiently aggressive recently.
    Always defects in the final 2 rounds for maximum endgame extraction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        rounds_remaining = self.game_description.n_rounds - history.round_number
        if rounds_remaining <= 2:
            return Action.D
        current_stock = self._estimate_current_stock(history)
        recent_defection_rate = self._calculate_recent_defection_rate(history)
        depletion_threshold = self.game_description.capacity * 0.3
        if current_stock <= depletion_threshold and rounds_remaining > 2 and (recent_defection_rate >= 0.6):
            return Action.C
        return Action.D

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """
        Estimate current stock level based on game history.
        This reconstructs the stock dynamics from the payoff history.
        """
        stock = float(self.game_description.capacity)
        n_players = self.game_description.n_players
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            n_cooperators = int(my_action) + sum(opponent_actions)
            n_defectors = n_players - n_cooperators
            cooperator_consumption = stock / (2 * n_players)
            defector_consumption = stock / n_players
            total_consumption = n_cooperators * cooperator_consumption + n_defectors * defector_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.game_description.capacity)
            stock = min(stock_after_consumption + growth, self.game_description.capacity)
        return stock

    def _calculate_recent_defection_rate(self, history: PlayerHistory) -> float:
        """
        Calculate defection rate over the last 3 rounds (or all available rounds if fewer than 3).
        """
        rounds_to_check = min(3, history.round_number)
        if rounds_to_check == 0:
            return 0.0
        recent_actions = history.my_actions[-rounds_to_check:]
        defection_count = sum((1 for action in recent_actions if not action))
        return defection_count / rounds_to_check

class Strategy_AGGRESSIVE_74(BaseStrategy):
    """
    Aggressive "Hawk-Vulture" strategy that maximizes early resource extraction
    while maintaining tactical awareness to avoid complete resource collapse.
    Uses a three-phase approach: early aggression, conditional exploitation, 
    and final extraction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.early_phase_end = self.n_rounds // 3
        self.final_phase_start = 2 * self.n_rounds // 3

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.n_rounds:
            return Action.D
        if current_round > self.n_rounds - 3:
            return Action.D
        my_last_payoff = history.my_payoffs[-1]
        my_last_action = history.my_actions[-1]
        if my_last_action:
            estimated_stock = my_last_payoff * 2 * self.n_players
        else:
            estimated_stock = my_last_payoff * self.n_players
        last_round_idx = history.round_number - 1
        opponent_defections = sum(1 - history.opponent_actions[last_round_idx])
        defection_rate = opponent_defections / (self.n_players - 1)
        stock_growing = False
        if len(history.my_payoffs) >= 2:
            recent_trend = history.my_payoffs[-1] - history.my_payoffs[-2]
            stock_growing = recent_trend > 0
        if current_round <= self.early_phase_end:
            if estimated_stock < self.capacity / 3:
                return Action.D if estimated_stock > self.capacity / 20 else Action.C
            return Action.D
        elif current_round >= self.final_phase_start:
            if estimated_stock > self.capacity / 10:
                return Action.D
            elif defection_rate > 0.25:
                return Action.D
            elif estimated_stock <= self.capacity / 10 and defection_rate == 0:
                return Action.C
            else:
                return Action.D
        elif estimated_stock > self.capacity / 2 or defection_rate > 0.5 or stock_growing:
            return Action.D
        elif estimated_stock < self.capacity / 4 and defection_rate < 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_75(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Raptor"
    
    Operates on maximum exploitation with calculated restraint. Aggressively defects 
    to extract maximum value while using just enough cooperation to prevent complete 
    resource collapse when beneficial.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.n_rounds:
            return Action.D
        last_round_idx = history.round_number - 1
        my_last_payoff = history.my_payoffs[last_round_idx]
        my_last_action = history.my_actions[last_round_idx]
        if my_last_action:
            estimated_stock = my_last_payoff * (2 * self.n_players)
        else:
            estimated_stock = my_last_payoff * self.n_players
        stock_ratio = estimated_stock / self.capacity
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        if my_last_action:
            cooperators_last_round += 1
        cooperation_rate = cooperators_last_round / self.n_players
        if cooperation_rate >= 0.6 and stock_ratio > 0.3:
            return Action.D
        if stock_ratio <= 0.15:
            if cooperation_rate >= 0.5:
                return Action.C
            else:
                return Action.D
        if cooperation_rate < 0.3 and stock_ratio > 0.4:
            return Action.D
        if stock_ratio > 0.25:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_76(BaseStrategy):
    """
    Predator Strategy: Aggressive resource extraction with minimal cooperation.
    Exploits cooperative opponents while preventing complete resource collapse only when beneficial.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        rounds_remaining = self.r - current_round
        if rounds_remaining <= 1:
            return Action.D
        prev_round_idx = history.round_number - 1
        prev_opponent_actions = history.opponent_actions[prev_round_idx]
        cooperator_count = sum(prev_opponent_actions)
        my_prev_action = history.my_actions[prev_round_idx]
        my_prev_payoff = history.my_payoffs[prev_round_idx]
        if my_prev_payoff == 0:
            current_stock = 0
        else:
            if my_prev_action:
                stock_before_consumption = my_prev_payoff * 2 * self.n
            else:
                stock_before_consumption = my_prev_payoff * self.n
            my_consumption = stock_before_consumption / (2 * self.n) if my_prev_action else stock_before_consumption / self.n
            total_opponent_consumption = 0
            for i, opp_action in enumerate(prev_opponent_actions):
                if opp_action:
                    total_opponent_consumption += stock_before_consumption / (2 * self.n)
                else:
                    total_opponent_consumption += stock_before_consumption / self.n
            stock_after_consumption = stock_before_consumption - my_consumption - total_opponent_consumption
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            current_stock = min(stock_after_consumption + growth, self.capacity)
        if current_stock < self.capacity * 0.15:
            if cooperator_count >= self.n / 2:
                return Action.C
            else:
                return Action.D
        if cooperator_count >= (self.n - 1) / 2:
            return Action.D
        if cooperator_count < self.n / 3:
            return Action.D
        if current_stock < self.capacity * 0.4 and cooperator_count >= self.n / 2:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_77(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Parasitic Opportunist"
    
    Aggressively maximizes individual payoffs by exploiting cooperative players
    while minimizing personal contributions to resource sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round = history.round_number + 1
        current_stock = self._calculate_current_stock(history, capacity, n)
        stock_ratio = current_stock / capacity
        rounds_remaining = total_rounds - current_round + 1
        if current_round == total_rounds:
            return Action.D
        if stock_ratio < 0.15:
            return Action.C
        if history.round_number > 0:
            cooperation_rate = np.sum(history.opponent_actions[history.round_number - 1]) / n
        else:
            cooperation_rate = 0.0
        if rounds_remaining < total_rounds * 0.2:
            if stock_ratio < 0.1:
                return Action.C
            else:
                return Action.D
        if cooperation_rate >= 0.6:
            return Action.D
        if stock_ratio < 0.3 and cooperation_rate >= 0.5:
            return Action.C
        return Action.D

    def _calculate_current_stock(self, history: PlayerHistory, capacity: int, n: int) -> float:
        """Calculate current stock based on game history and dynamics."""
        stock = float(capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            cooperators = int(my_action) + np.sum(opponent_actions.astype(int))
            defectors = n - cooperators
            cooperator_consumption = stock / (2 * n)
            defector_consumption = stock / n
            total_consumption = cooperators * cooperator_consumption + defectors * defector_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            stock = min(stock_after_consumption + growth, capacity)
        return stock

class Strategy_AGGRESSIVE_78(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Resource Raider"
    
    Maximizes immediate gains while strategically managing resource depletion.
    Uses opportunistic defection when stock is high or opponents cooperate,
    with minimal strategic cooperation only to prevent total collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        current_stock = self._calculate_current_stock(history)
        stock_ratio = current_stock / self.capacity
        if stock_ratio < 0.1:
            return Action.C
        if current_round > self.n_rounds - 3:
            if stock_ratio >= 0.15:
                return Action.D
            else:
                return Action.C
        last_round_idx = history.round_number - 1
        cooperators = sum(history.opponent_actions[last_round_idx])
        cooperation_rate = cooperators / (self.n_players - 1)
        if stock_ratio >= 0.75:
            return Action.D
        if cooperation_rate >= 0.5 and stock_ratio >= 0.3:
            return Action.D
        if current_round > 2:
            prev_stock = self._calculate_stock_at_round(history, history.round_number - 1)
            if current_stock > prev_stock and stock_ratio >= 0.4:
                return Action.D
        if stock_ratio < 0.25 and cooperation_rate < 0.5:
            return Action.C
        if stock_ratio >= 0.4:
            return Action.D
        else:
            return Action.C

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game history."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0.0
            if my_action:
                total_consumption += stock / (2 * self.n_players)
            else:
                total_consumption += stock / self.n_players
            for opp_action in opponent_actions:
                if opp_action:
                    total_consumption += stock / (2 * self.n_players)
                else:
                    total_consumption += stock / self.n_players
            stock_after_consumption = max(0.0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _calculate_stock_at_round(self, history: PlayerHistory, target_round: int) -> float:
        """Calculate stock level at the beginning of a specific round."""
        if target_round <= 0:
            return float(self.capacity)
        stock = float(self.capacity)
        for round_idx in range(min(target_round, history.round_number)):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0.0
            if my_action:
                total_consumption += stock / (2 * self.n_players)
            else:
                total_consumption += stock / self.n_players
            for opp_action in opponent_actions:
                if opp_action:
                    total_consumption += stock / (2 * self.n_players)
                else:
                    total_consumption += stock / self.n_players
            stock_after_consumption = max(0.0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

class Strategy_AGGRESSIVE_79(BaseStrategy):
    """
    Aggressive "Resource Dominance" Strategy that maximizes immediate payoffs through
    opportunistic defection while strategically preserving resources only when necessary
    for continued exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_rounds_remaining = 0
        self.consecutive_cooperations = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punishment_rounds_remaining = 0
            self.consecutive_cooperations = 0
            return Action.D
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        current_stock = self._calculate_current_stock(history)
        if current_round >= total_rounds - 1:
            return Action.D
        if self.punishment_rounds_remaining > 0:
            self.punishment_rounds_remaining -= 1
            return Action.D
        if self._should_enter_punishment(history):
            self.punishment_rounds_remaining = 2
            return Action.D
        if current_stock <= capacity / 8 and total_rounds - current_round >= 3:
            if self.consecutive_cooperations < 2:
                self.consecutive_cooperations += 1
                return Action.C
            else:
                self.consecutive_cooperations = 0
        if current_stock <= capacity / 4 and total_rounds - current_round >= 3 and (self._get_previous_defection_rate(history) > 0.75):
            self.consecutive_cooperations = 0
            return Action.C
        self.consecutive_cooperations = 0
        return Action.D

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game history."""
        stock = float(self.game_description.capacity)
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        for round_idx in range(history.round_number):
            total_consumption = 0.0
            if history.my_actions[round_idx]:
                total_consumption += stock / (2 * n_players)
            else:
                total_consumption += stock / n_players
            for opponent_idx in range(n_players - 1):
                if history.opponent_actions[round_idx, opponent_idx]:
                    total_consumption += stock / (2 * n_players)
                else:
                    total_consumption += stock / n_players
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            stock = min(stock_after_consumption + growth, capacity)
        return stock

    def _should_enter_punishment(self, history: PlayerHistory) -> bool:
        """Check if we should enter punishment phase based on previous round."""
        if history.round_number == 0:
            return False
        last_round_idx = history.round_number - 1
        if not history.my_actions[last_round_idx]:
            for opponent_idx in range(self.game_description.n_players - 1):
                if history.opponent_actions[last_round_idx, opponent_idx]:
                    return True
        return False

    def _get_previous_defection_rate(self, history: PlayerHistory) -> float:
        """Get defection rate of all players in the previous round."""
        if history.round_number == 0:
            return 0.0
        last_round_idx = history.round_number - 1
        total_players = self.game_description.n_players
        defectors = 0
        if not history.my_actions[last_round_idx]:
            defectors += 1
        for opponent_idx in range(self.game_description.n_players - 1):
            if not history.opponent_actions[last_round_idx, opponent_idx]:
                defectors += 1
        return defectors / total_players

class Strategy_AGGRESSIVE_80(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Rapacious Opportunist"
    
    Maximizes immediate payoffs through strategic defection while exploiting cooperative players.
    Only cooperates defensively when resource collapse is imminent and others are also defecting heavily.
    Always defects in first and final rounds to establish dominance and extract maximum endgame value.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        stock = self._calculate_current_stock(history)
        critical_stock = stock <= self.game_description.capacity / 4
        last_round_defectors = sum(~history.opponent_actions[history.round_number - 1])
        majority_defected = last_round_defectors >= math.ceil((self.game_description.n_players - 1) / 2)
        if critical_stock and majority_defected:
            return Action.C
        return Action.D

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game history."""
        stock = float(self.game_description.capacity)
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0.0
            if my_action:
                total_consumption += stock / (2 * n)
            else:
                total_consumption += stock / n
            for opp_action in opponent_actions:
                if opp_action:
                    total_consumption += stock / (2 * n)
                else:
                    total_consumption += stock / n
            stock_after_consumption = stock - total_consumption
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            stock = min(stock_after_consumption + growth, capacity)
        return stock

class Strategy_AGGRESSIVE_81(BaseStrategy):
    """
    Aggressive Predator Strategy: Maximizes personal payoffs through strategic resource extraction,
    cooperating only when necessary to preserve future extraction opportunities.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = self.capacity * 0.25
        self.recovery_threshold = self.capacity * 0.15
        self.punishment_rounds_remaining = 0
        self.last_round_opponent_actions = None

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number
        current_stock = self._estimate_current_stock(history)
        if current_round == self.n_rounds - 1:
            return Action.D
        if self.punishment_rounds_remaining > 0:
            self.punishment_rounds_remaining -= 1
            return Action.D
        self._check_punishment_trigger(history)
        if current_stock <= self.critical_threshold:
            if self._can_recover_with_cooperation(history, current_stock):
                return Action.C
            else:
                return Action.D
        opponent_defection_rate = self._calculate_opponent_defection_rate(history)
        if opponent_defection_rate > 0.6:
            return Action.D
        if self._falling_behind_in_payoffs(history):
            return Action.D
        if current_round >= self.n_rounds * 0.8:
            return Action.D
        return Action.D

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game dynamics."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0.0
            if my_action:
                total_consumption += stock / (2 * self.n_players)
            else:
                total_consumption += stock / self.n_players
            for opp_action in opponent_actions:
                if opp_action:
                    total_consumption += stock / (2 * self.n_players)
                else:
                    total_consumption += stock / self.n_players
            stock -= total_consumption
            stock = max(0, stock)
            if stock > 0:
                growth = 2 * stock * (1 - stock / self.capacity)
                stock = min(stock + growth, self.capacity)
        return stock

    def _calculate_opponent_defection_rate(self, history: PlayerHistory) -> float:
        """Calculate average defection rate across all opponents."""
        if history.round_number == 0:
            return 0.0
        total_actions = 0
        total_defections = 0
        for round_idx in range(history.round_number):
            for opp_action in history.opponent_actions[round_idx]:
                total_actions += 1
                if not opp_action:
                    total_defections += 1
        return total_defections / total_actions if total_actions > 0 else 0.0

    def _falling_behind_in_payoffs(self, history: PlayerHistory) -> bool:
        """Check if my cumulative payoff is below average opponent payoff."""
        if history.round_number == 0:
            return False
        my_total = sum(history.my_payoffs)
        opponent_totals = [sum(history.opponent_payoffs[:, opp_idx]) for opp_idx in range(self.n_players - 1)]
        if len(opponent_totals) == 0:
            return False
        avg_opponent_payoff = sum(opponent_totals) / len(opponent_totals)
        return my_total < avg_opponent_payoff

    def _can_recover_with_cooperation(self, history: PlayerHistory, current_stock: float) -> bool:
        """Estimate if cooperation can lead to stock recovery."""
        if current_stock <= self.recovery_threshold:
            if history.round_number >= 3:
                recent_rounds = min(3, history.round_number)
                recent_cooperation = 0
                total_recent_actions = 0
                for round_idx in range(history.round_number - recent_rounds, history.round_number):
                    for opp_action in history.opponent_actions[round_idx]:
                        total_recent_actions += 1
                        if opp_action:
                            recent_cooperation += 1
                cooperation_rate = recent_cooperation / total_recent_actions if total_recent_actions > 0 else 0
                return cooperation_rate > 0.6
        return False

    def _check_punishment_trigger(self, history: PlayerHistory) -> None:
        """Check if any opponent switched from cooperation to defection."""
        if history.round_number < 2:
            return
        prev_round = history.round_number - 2
        curr_round = history.round_number - 1
        prev_actions = history.opponent_actions[prev_round]
        curr_actions = history.opponent_actions[curr_round]
        for i in range(len(prev_actions)):
            if prev_actions[i] and (not curr_actions[i]):
                self.punishment_rounds_remaining = 2
                break

class Strategy_AGGRESSIVE_82(BaseStrategy):
    """
    Predatory Exploitation Strategy: Maximizes immediate payoffs through aggressive resource extraction
    while strategically managing the common pool to sustain exploitation opportunities.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round = history.round_number + 1
        if current_round == r:
            return Action.D
        stock = self._calculate_current_stock(history, capacity, n)
        last_round_idx = history.round_number - 1
        prev_cooperators = sum(history.opponent_actions[last_round_idx])
        cooperation_rate = prev_cooperators / (n - 1)
        stock_ratio = stock / capacity
        if stock_ratio < 0.3:
            return Action.D
        elif cooperation_rate >= 0.7:
            return Action.D
        elif cooperation_rate >= 0.4:
            if stock_ratio > 0.6:
                return Action.D
            else:
                return Action.C
        elif stock_ratio > 0.5:
            return Action.D
        else:
            return Action.C

    def _calculate_current_stock(self, history: PlayerHistory, capacity: int, n: int) -> float:
        """Calculate current stock level based on game history."""
        stock = float(capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0.0
            if my_action:
                total_consumption += stock / (2 * n)
            else:
                total_consumption += stock / n
            for opp_action in opponent_actions:
                if opp_action:
                    total_consumption += stock / (2 * n)
                else:
                    total_consumption += stock / n
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            stock = min(stock_after_consumption + growth, capacity)
        return stock

class Strategy_AGGRESSIVE_83(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Resource Vampire"
    
    Aggressively exploits the common pool while using sophisticated prediction to maximize
    extraction before resource collapse. Prioritizes immediate high payoffs over sustainable
    long-term cooperation through adaptive exploitation and opponent prediction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.opponent_cooperation_rates = np.zeros(self.n_players - 1)
        self.opponent_recent_trends = np.zeros(self.n_players - 1)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        stock = self._estimate_current_stock(history)
        if current_round == self.n_rounds:
            return Action.D
        self._update_opponent_tracking(history)
        return self._make_decision(history, stock, current_round)

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on consumption history."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_consumption = stock / (2 * self.n_players) if history.my_actions[round_idx] else stock / self.n_players
            opponent_consumption = 0
            for opp_idx in range(self.n_players - 1):
                if history.opponent_actions[round_idx, opp_idx]:
                    opponent_consumption += stock / (2 * self.n_players)
                else:
                    opponent_consumption += stock / self.n_players
            total_consumption = my_consumption + opponent_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _update_opponent_tracking(self, history: PlayerHistory):
        """Update opponent cooperation rates and recent trends."""
        if history.round_number == 0:
            return
        for opp_idx in range(self.n_players - 1):
            total_cooperations = np.sum(history.opponent_actions[:, opp_idx])
            self.opponent_cooperation_rates[opp_idx] = total_cooperations / history.round_number
            recent_actions = history.opponent_actions[max(0, history.round_number - 3):history.round_number, opp_idx]
            if len(recent_actions) > 0:
                weights = np.array([0.5, 0.3, 0.2])[-len(recent_actions):]
                weights = weights / np.sum(weights)
                self.opponent_recent_trends[opp_idx] = np.sum(recent_actions * weights)

    def _predict_opponent_cooperators(self, history: PlayerHistory, stock: float) -> int:
        """Predict how many opponents will cooperate this round."""
        if history.round_number == 0:
            return self.n_players // 2
        expected_cooperators = 0
        for opp_idx in range(self.n_players - 1):
            if self.opponent_recent_trends[opp_idx] > 0.6 and stock > self.capacity * 0.4:
                expected_cooperators += 1
        return expected_cooperators

    def _make_decision(self, history: PlayerHistory, stock: float, current_round: int) -> Action:
        """Make decision based on aggressive exploitation rules."""
        rounds_remaining = self.n_rounds - current_round
        base_threshold = self.capacity * 0.7
        aggression_multiplier = 1.0 + current_round / self.n_rounds * 0.5
        defection_threshold = base_threshold * aggression_multiplier
        expected_cooperators = self._predict_opponent_cooperators(history, stock)
        if stock > defection_threshold or expected_cooperators >= self.n_players // 2 or (stock < self.capacity * 0.3 and rounds_remaining < 3):
            return Action.D
        if rounds_remaining <= 2:
            if stock <= self.capacity * 0.5:
                return Action.D
        if stock < self.capacity * 0.3 and rounds_remaining > 3:
            if history.round_number > 0:
                last_round_cooperators = np.sum(history.opponent_actions[history.round_number - 1])
                if last_round_cooperators >= (self.n_players - 1) // 2:
                    return Action.C
        if stock <= self.capacity * 0.05:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_84(BaseStrategy):
    """
    Predatory Exploitation Strategy: Maximizes immediate payoffs through aggressive defection
    while strategically preserving just enough resource sustainability to maintain exploitation
    opportunities. Exploits cooperative players while racing to extract maximum value.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        stock = self._estimate_current_stock(history)
        if current_round <= self.r // 3:
            return self._early_exploitation_phase(history, stock)
        elif current_round <= 2 * self.r // 3:
            return self._strategic_predation_phase(history, stock)
        else:
            return self._endgame_extraction_phase(history, stock, current_round)

    def _estimate_current_stock(self, history):
        """Estimate current stock level based on game dynamics"""
        stock = self.capacity
        for round_idx in range(history.round_number):
            my_consumption = stock / (2 * self.n) if history.my_actions[round_idx] else stock / self.n
            opponent_consumption = 0
            for player_idx in range(self.n - 1):
                if history.opponent_actions[round_idx, player_idx]:
                    opponent_consumption += stock / (2 * self.n)
                else:
                    opponent_consumption += stock / self.n
            total_consumption = my_consumption + opponent_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
                stock = min(stock_after_consumption + growth, self.capacity)
            else:
                stock = 0
        return stock

    def _count_cooperators_last_round(self, history):
        """Count how many opponents cooperated in the last round"""
        if history.round_number == 0:
            return 0
        last_round_idx = history.round_number - 1
        return sum(history.opponent_actions[last_round_idx])

    def _early_exploitation_phase(self, history, stock):
        """Phase 1: Early Exploitation logic"""
        cooperation_rate = self._count_cooperators_last_round(history) / (self.n - 1)
        if cooperation_rate >= 0.5:
            return Action.D
        elif stock < self.capacity * 0.3:
            return Action.C
        else:
            return Action.D

    def _strategic_predation_phase(self, history, stock):
        """Phase 2: Strategic Predation logic"""
        if stock < self.capacity * 0.25:
            cooperators_last_round = self._count_cooperators_last_round(history)
            if cooperators_last_round >= (self.n - 1) // 2:
                return Action.C
            else:
                return Action.D
        elif stock >= self.capacity * 0.7:
            return Action.D
        else:
            opponent_defection_rate = self._get_opponent_defection_rate_last_3_rounds(history)
            if opponent_defection_rate < 0.6:
                return Action.D
            else:
                return Action.D

    def _endgame_extraction_phase(self, history, stock, current_round):
        """Phase 3: Endgame Extraction logic"""
        remaining_rounds = self.r - current_round + 1
        if remaining_rounds <= 2:
            return Action.D
        elif stock < self.capacity * 0.2:
            return Action.D
        else:
            return Action.D

    def _get_opponent_defection_rate_last_3_rounds(self, history):
        """Calculate opponent defection rate over last 3 rounds"""
        if history.round_number == 0:
            return 0.0
        rounds_to_check = min(3, history.round_number)
        start_round = max(0, history.round_number - rounds_to_check)
        total_decisions = 0
        total_defections = 0
        for round_idx in range(start_round, history.round_number):
            for player_idx in range(self.n - 1):
                total_decisions += 1
                if not history.opponent_actions[round_idx, player_idx]:
                    total_defections += 1
        return total_defections / total_decisions if total_decisions > 0 else 0.0

class Strategy_AGGRESSIVE_85(BaseStrategy):
    """
    Aggressive Opportunistic Exploitation Strategy.
    
    This strategy maximizes individual payoffs by aggressively exploiting cooperative 
    behavior while maintaining the resource base only when absolutely necessary for 
    continued exploitation. Key principles: always defect first and last rounds, 
    exploit high cooperation rates, and only cooperate when stock is critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        current_stock = self._estimate_current_stock(history)
        sustainability_threshold = self.game_description.capacity * 0.15
        if current_stock <= sustainability_threshold:
            return Action.C
        if history.round_number > 0:
            cooperators_last_round = sum(history.opponent_actions[history.round_number - 1])
            cooperation_rate = cooperators_last_round / (self.game_description.n_players - 1)
            if cooperation_rate >= 0.5:
                return Action.D
            if cooperation_rate > 0.25:
                return Action.D
            warning_threshold = self.game_description.capacity * 0.3
            if current_stock <= warning_threshold and cooperation_rate <= 0.25:
                return Action.C
        return Action.D

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock based on game history and dynamics."""
        stock = float(self.game_description.capacity)
        for round_idx in range(history.round_number):
            total_consumption = 0.0
            if history.my_actions[round_idx]:
                my_consumption = stock / (2 * self.game_description.n_players)
            else:
                my_consumption = stock / self.game_description.n_players
            total_consumption += my_consumption
            for opponent_idx in range(self.game_description.n_players - 1):
                if history.opponent_actions[round_idx, opponent_idx]:
                    opponent_consumption = stock / (2 * self.game_description.n_players)
                else:
                    opponent_consumption = stock / self.game_description.n_players
                total_consumption += opponent_consumption
            stock_after_consumption = max(0.0, stock - total_consumption)
            growth = 2.0 * stock_after_consumption * (1.0 - stock_after_consumption / self.game_description.capacity)
            stock = min(stock_after_consumption + growth, float(self.game_description.capacity))
        return stock

class Strategy_AGGRESSIVE_86(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Vampire"
    
    This strategy aggressively maximizes immediate payoffs while strategically exploiting 
    cooperative opponents. It operates on opportunistic defection with minimal cooperation 
    only when necessary to prevent resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        stock = self._calculate_current_stock(history)
        if stock < self.capacity * 0.15:
            return Action.C
        if current_round >= self.n_rounds - 1:
            return Action.D
        opponent_coop_rate = self._get_opponent_cooperation_rate(history)
        if opponent_coop_rate > 0.6:
            return Action.D
        if history.round_number > 0:
            last_round_advantage = self._calculate_defector_advantage(history)
            if last_round_advantage > 1.3:
                return Action.D
        if stock > self.capacity * 0.7 and self._majority_cooperated_last_round(history):
            return Action.D
        if self._in_cooperation_trap(history):
            return Action.D
        if self._all_opponents_defected_last_round(history) and stock > self.capacity * 0.2:
            return Action.D
        return Action.C

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock based on game dynamics."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_consumption = stock / (2 * self.n_players) if history.my_actions[round_idx] else stock / self.n_players
            opponent_consumption = 0
            for opponent_idx in range(len(history.opponent_actions[round_idx])):
                if history.opponent_actions[round_idx][opponent_idx]:
                    opponent_consumption += stock / (2 * self.n_players)
                else:
                    opponent_consumption += stock / self.n_players
            total_consumption = my_consumption + opponent_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
                stock = min(stock_after_consumption + growth, self.capacity)
            else:
                stock = 0
        return stock

    def _get_opponent_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate average cooperation rate of all opponents."""
        if history.round_number == 0:
            return 0.0
        total_cooperations = 0
        total_decisions = 0
        for round_idx in range(history.round_number):
            for opponent_idx in range(len(history.opponent_actions[round_idx])):
                if history.opponent_actions[round_idx][opponent_idx]:
                    total_cooperations += 1
                total_decisions += 1
        return total_cooperations / total_decisions if total_decisions > 0 else 0.0

    def _calculate_defector_advantage(self, history: PlayerHistory) -> float:
        """Calculate advantage ratio of defectors vs cooperators in last round."""
        if history.round_number == 0:
            return 1.0
        last_round_idx = history.round_number - 1
        defector_payoffs = []
        cooperator_payoffs = []
        if history.my_actions[last_round_idx]:
            cooperator_payoffs.append(history.my_payoffs[last_round_idx])
        else:
            defector_payoffs.append(history.my_payoffs[last_round_idx])
        for opponent_idx in range(len(history.opponent_actions[last_round_idx])):
            if history.opponent_actions[last_round_idx][opponent_idx]:
                cooperator_payoffs.append(history.opponent_payoffs[last_round_idx][opponent_idx])
            else:
                defector_payoffs.append(history.opponent_payoffs[last_round_idx][opponent_idx])
        if len(cooperator_payoffs) == 0 or len(defector_payoffs) == 0:
            return 1.0
        avg_defector = sum(defector_payoffs) / len(defector_payoffs)
        avg_cooperator = sum(cooperator_payoffs) / len(cooperator_payoffs)
        return avg_defector / avg_cooperator if avg_cooperator > 0 else 1.0

    def _majority_cooperated_last_round(self, history: PlayerHistory) -> bool:
        """Check if majority of players (including self) cooperated in last round."""
        if history.round_number == 0:
            return False
        last_round_idx = history.round_number - 1
        cooperators = 0
        if history.my_actions[last_round_idx]:
            cooperators += 1
        cooperators += sum(history.opponent_actions[last_round_idx])
        return cooperators > self.n_players / 2

    def _in_cooperation_trap(self, history: PlayerHistory) -> bool:
        """Check if we're cooperating too much compared to average performance."""
        if history.round_number < 3:
            return False
        my_coop_rate = sum(history.my_actions) / len(history.my_actions)
        my_avg_payoff = np.mean(history.my_payoffs)
        all_payoffs = list(history.my_payoffs)
        for round_idx in range(history.round_number):
            all_payoffs.extend(history.opponent_payoffs[round_idx])
        overall_avg_payoff = np.mean(all_payoffs)
        return my_coop_rate > 0.4 and my_avg_payoff < overall_avg_payoff

    def _all_opponents_defected_last_round(self, history: PlayerHistory) -> bool:
        """Check if all opponents defected in the last round."""
        if history.round_number == 0:
            return False
        last_round_idx = history.round_number - 1
        return sum(history.opponent_actions[last_round_idx]) == 0

class Strategy_AGGRESSIVE_87(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Predatory Harvester"
    
    Maximizes immediate gains while strategically timing cooperation to maintain 
    just enough resource sustainability for continued exploitation. Always defects 
    in first and last rounds, exploits high stock situations, and only cooperates 
    when absolutely necessary to prevent resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.n_rounds:
            return Action.D
        stock = self._calculate_current_stock(history)
        stock_ratio = stock / self.capacity
        if stock_ratio >= 0.4:
            return Action.D
        if stock_ratio <= 0.1:
            return Action.C
        last_round_idx = history.round_number - 1
        cooperator_count = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            cooperator_count += 1
        defector_count = self.n_players - cooperator_count
        if cooperator_count >= self.n_players / 2:
            return Action.D
        if defector_count >= self.n_players / 2 and self._is_stock_declining(history):
            return Action.C
        return Action.D

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game dynamics."""
        stock = self.capacity
        for round_idx in range(history.round_number):
            total_consumption = 0
            if history.my_actions[round_idx]:
                total_consumption += stock / (2 * self.n_players)
            else:
                total_consumption += stock / self.n_players
            for player_idx in range(self.n_players - 1):
                if history.opponent_actions[round_idx, player_idx]:
                    total_consumption += stock / (2 * self.n_players)
                else:
                    total_consumption += stock / self.n_players
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _is_stock_declining(self, history: PlayerHistory) -> bool:
        """Check if stock has been declining over recent rounds."""
        if history.round_number < 2:
            return False
        current_stock = self._calculate_current_stock(history)
        truncated_history = PlayerHistory(my_actions=history.my_actions[:-1], my_payoffs=history.my_payoffs[:-1], opponent_actions=history.opponent_actions[:-1], opponent_payoffs=history.opponent_payoffs[:-1])
        previous_stock = self._calculate_current_stock(truncated_history)
        return current_stock < previous_stock * 0.9

class Strategy_AGGRESSIVE_88(BaseStrategy):
    """
    Aggressive Predator Strategy: Maximizes personal extraction through calculated aggression,
    exploiting cooperative behavior while strategically managing resource sustainability only
    when necessary for continued exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        stock = self._calculate_current_stock(history)
        stock_ratio = stock / self.capacity
        recent_coop_rate = self._calculate_recent_cooperation_rate(history, min(3, history.round_number))
        if current_round <= self.n_rounds / 3:
            return self._early_phase_strategy(stock_ratio, recent_coop_rate, current_round)
        elif current_round <= 2 * self.n_rounds / 3:
            return self._middle_phase_strategy(stock_ratio, recent_coop_rate)
        else:
            return self._end_phase_strategy(stock_ratio, current_round)

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock based on game history."""
        stock = self.capacity
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            cooperators = int(my_action) + sum(opponent_actions)
            defectors = self.n_players - cooperators
            total_consumption = cooperators * (stock / (2 * self.n_players)) + defectors * (stock / self.n_players)
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory, lookback_rounds: int) -> float:
        """Calculate cooperation rate of opponents in recent rounds."""
        if history.round_number == 0:
            return 0.5
        start_round = max(0, history.round_number - lookback_rounds)
        total_actions = 0
        total_cooperations = 0
        for round_idx in range(start_round, history.round_number):
            opponent_actions = history.opponent_actions[round_idx]
            total_actions += len(opponent_actions)
            total_cooperations += sum(opponent_actions)
        return total_cooperations / total_actions if total_actions > 0 else 0.5

    def _early_phase_strategy(self, stock_ratio: float, recent_coop_rate: float, current_round: int) -> Action:
        """Early phase: Establish dominance while testing opponents."""
        if stock_ratio >= 0.7 and recent_coop_rate >= 0.6:
            return Action.D
        if stock_ratio < 0.4 and recent_coop_rate >= 0.7:
            return Action.C
        return Action.D

    def _middle_phase_strategy(self, stock_ratio: float, recent_coop_rate: float) -> Action:
        """Middle phase: Maximum exploitation while maintaining resource viability."""
        if recent_coop_rate < 0.3 and stock_ratio < 0.25:
            return Action.C
        if stock_ratio >= 0.8:
            return Action.D
        if recent_coop_rate >= 0.5 and stock_ratio >= 0.4:
            return Action.D
        if stock_ratio < 0.4 and recent_coop_rate >= 0.6:
            return Action.C
        return Action.D

    def _end_phase_strategy(self, stock_ratio: float, current_round: int) -> Action:
        """End phase: Extract maximum value from remaining opportunities."""
        rounds_remaining = self.n_rounds - current_round + 1
        if rounds_remaining == 1:
            return Action.D
        if rounds_remaining <= 3 and stock_ratio >= 0.4:
            return Action.D
        if stock_ratio < 0.15 and rounds_remaining > 2:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_89(BaseStrategy):
    """
    Aggressive Predatory Strategy: "Resource Raider"
    
    This strategy operates on maximum exploitation with strategic timing.
    Uses early aggression, opportunistic exploitation, and endgame maximization
    to extract maximum value while forcing opponents into suboptimal positions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.phase1_end = self.n_rounds // 3
        self.phase2_end = 2 * self.n_rounds // 3

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        current_stock = self._calculate_current_stock(history)
        if current_round == self.n_rounds:
            return Action.D
        if current_round <= self.phase1_end:
            return Action.D
        if current_round > self.phase2_end:
            if current_stock > 0:
                return Action.D
            else:
                return Action.C
        return self._phase2_decision(history, current_stock)

    def _phase2_decision(self, history: PlayerHistory, current_stock: float) -> Action:
        """Phase 2 conditional logic for opportunistic exploitation."""
        if current_stock > self.capacity / 2:
            return Action.D
        if current_stock <= 0:
            return Action.C
        if history.round_number > 0:
            last_round_idx = history.round_number - 1
            last_round_defectors = np.sum(history.opponent_actions[last_round_idx] == False)
            my_last_action_was_defect = history.my_actions[last_round_idx] == False
            if my_last_action_was_defect:
                last_round_defectors += 1
            if last_round_defectors >= self.n_players / 2:
                return Action.D
        if current_stock < self.capacity / 4:
            return Action.C
        return Action.D

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock based on game dynamics."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0.0
            if my_action:
                total_consumption += stock / (2 * self.n_players)
            else:
                total_consumption += stock / self.n_players
            for opp_action in opponent_actions:
                if opp_action:
                    total_consumption += stock / (2 * self.n_players)
                else:
                    total_consumption += stock / self.n_players
            stock_after_consumption = max(0.0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

class Strategy_AGGRESSIVE_90(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Predator"
    
    Maximizes personal payoffs by aggressively exploiting cooperative opponents
    while maintaining strategic awareness to avoid complete resource collapse.
    Uses cooperation only tactically when forced by circumstances.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        current_stock = self._estimate_current_stock(history)
        if current_round == self.n_rounds:
            return Action.D
        if current_stock <= self.capacity * 0.15:
            return Action.C
        if self._majority_defected_last_round(history):
            return Action.D
        if self._falling_behind_in_payoffs(history):
            return Action.D
        if self._detect_punishment_pattern(history):
            return Action.C
        return Action.D

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game history."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            if my_action:
                my_consumption = stock / (2 * self.n_players)
            else:
                my_consumption = stock / self.n_players
            opponent_consumption = 0
            for opp_action in opponent_actions:
                if opp_action:
                    opponent_consumption += stock / (2 * self.n_players)
                else:
                    opponent_consumption += stock / self.n_players
            total_consumption = my_consumption + opponent_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _majority_defected_last_round(self, history: PlayerHistory) -> bool:
        """Check if majority of opponents defected in the last round."""
        if history.round_number == 0:
            return False
        last_round_idx = history.round_number - 1
        opponent_defections = sum((1 for action in history.opponent_actions[last_round_idx] if not action))
        return opponent_defections > len(history.opponent_actions[last_round_idx]) / 2

    def _falling_behind_in_payoffs(self, history: PlayerHistory) -> bool:
        """Check if personal cumulative payoff is below 1.2x average opponent payoff."""
        if history.round_number == 0:
            return False
        my_total_payoff = sum(history.my_payoffs)
        opponent_total_payoffs = []
        for opp_idx in range(len(history.opponent_actions[0])):
            opp_total = sum((history.opponent_payoffs[round_idx][opp_idx] for round_idx in range(history.round_number)))
            opponent_total_payoffs.append(opp_total)
        if not opponent_total_payoffs:
            return False
        avg_opponent_payoff = sum(opponent_total_payoffs) / len(opponent_total_payoffs)
        return my_total_payoff < avg_opponent_payoff * 1.2

    def _detect_punishment_pattern(self, history: PlayerHistory) -> bool:
        """Detect if opponents are punishing my defections."""
        if history.round_number < 2:
            return False
        punishment_count = 0
        for opp_idx in range(len(history.opponent_actions[0])):
            for round_idx in range(1, min(history.round_number, 4)):
                if round_idx >= history.round_number:
                    continue
                if round_idx > 0 and history.opponent_actions[round_idx - 1][opp_idx] and (not history.my_actions[round_idx - 1]) and (not history.opponent_actions[round_idx][opp_idx]):
                    punishment_count += 1
                    break
        return punishment_count >= 2

class Strategy_AGGRESSIVE_91(BaseStrategy):
    """
    Aggressive "Exploit-Until-Collapse" Strategy
    
    Maximizes short-term gains by aggressively exploiting the common pool while 
    identifying and punishing cooperators. Always defects in first round, then
    uses adaptive exploitation based on stock levels and opponent behavior patterns.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        stock = self._estimate_current_stock(history)
        critical_stock = self.capacity * 0.3
        if stock < critical_stock and current_round < self.r:
            return Action.C
        endgame_rounds = min(2, self.r // 4)
        if current_round >= self.r - endgame_rounds:
            return Action.D
        recent_cooperators = self._count_recent_cooperators(history)
        cooperation_trend = self._analyze_cooperation_trend(history, 3)
        if recent_cooperators >= self.n // 2:
            return Action.D
        if cooperation_trend < 0.4:
            return Action.D
        if stock > self.capacity * 0.7 and recent_cooperators > self.n * 0.6:
            return Action.C
        return Action.D

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game history."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            my_consumption = stock / (2 * self.n) if my_action else stock / self.n
            total_consumption = my_consumption
            for opp_action in opponent_actions:
                if opp_action:
                    total_consumption += stock / (2 * self.n)
                else:
                    total_consumption += stock / self.n
            stock_after_consumption = max(0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth_factor = 1 - stock_after_consumption / self.capacity
                growth = 2 * stock_after_consumption * growth_factor
                stock = min(stock_after_consumption + growth, self.capacity)
            else:
                stock = 0
        return stock

    def _count_recent_cooperators(self, history: PlayerHistory) -> int:
        """Count cooperators in the most recent round."""
        if history.round_number == 0:
            return 0
        last_round_idx = history.round_number - 1
        return int(np.sum(history.opponent_actions[last_round_idx]))

    def _analyze_cooperation_trend(self, history: PlayerHistory, lookback: int) -> float:
        """Analyze cooperation trend over the last few rounds."""
        if history.round_number == 0:
            return 0.0
        start_round = max(0, history.round_number - lookback)
        end_round = history.round_number
        total_actions = 0
        total_cooperations = 0
        for round_idx in range(start_round, end_round):
            opponent_actions = history.opponent_actions[round_idx]
            total_actions += len(opponent_actions)
            total_cooperations += int(np.sum(opponent_actions))
        if total_actions == 0:
            return 0.0
        return total_cooperations / total_actions

class Strategy_AGGRESSIVE_92(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Predatory Harvester"
    
    This strategy aims to maximize individual payoffs by aggressively exploiting 
    the common pool while strategically timing cooperation to maintain just enough 
    resource sustainability for continued exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        current_stock = self._calculate_current_stock(history)
        if current_stock < self.capacity * 0.1:
            return Action.C
        if current_round == 2:
            if current_stock >= self.capacity * 0.25:
                return Action.D
            else:
                return Action.C
        if current_round == self.n_rounds:
            return Action.D
        if current_round == self.n_rounds - 1 and current_stock > self.capacity * 0.25:
            return Action.D
        stock_ratio = current_stock / self.capacity
        defectors_last_round = self._count_defectors_last_round(history)
        if stock_ratio > 0.6:
            return Action.D
        elif stock_ratio > 0.3:
            if defectors_last_round >= self.n_players / 2:
                return Action.C
            else:
                return Action.D
        elif stock_ratio > 0.15:
            if self._am_ahead(history):
                return Action.C
            else:
                return Action.D
        else:
            return Action.C

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock based on game dynamics."""
        stock = self.capacity
        for round_idx in range(history.round_number):
            my_consumption = self._get_consumption(history.my_actions[round_idx], stock)
            opponent_consumptions = [self._get_consumption(history.opponent_actions[round_idx, opp_idx], stock) for opp_idx in range(self.n_players - 1)]
            total_consumption = my_consumption + sum(opponent_consumptions)
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _get_consumption(self, action: bool, stock: float) -> float:
        """Calculate consumption based on action (True=C, False=D)."""
        if action:
            return stock / (2 * self.n_players)
        else:
            return stock / self.n_players

    def _count_defectors_last_round(self, history: PlayerHistory) -> int:
        """Count how many opponents defected in the most recent round."""
        if history.round_number == 0:
            return 0
        last_round_idx = history.round_number - 1
        defector_count = sum((1 for action in history.opponent_actions[last_round_idx] if not action))
        if not history.my_actions[last_round_idx]:
            defector_count += 1
        return defector_count

    def _am_ahead(self, history: PlayerHistory) -> bool:
        """Check if I'm ahead in total payoffs compared to average."""
        my_total_payoff = sum(history.my_payoffs)
        opponent_total_payoffs = [sum(history.opponent_payoffs[:, opp_idx]) for opp_idx in range(self.n_players - 1)]
        if len(opponent_total_payoffs) == 0:
            return True
        average_opponent_payoff = sum(opponent_total_payoffs) / len(opponent_total_payoffs)
        return my_total_payoff > average_opponent_payoff

class Strategy_AGGRESSIVE_93(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Shark"
    
    Operates on aggressive opportunism - maximizing immediate gains while strategically 
    managing the resource to ensure continued exploitation opportunities. Uses stock-based 
    aggression with adaptive exploitation of cooperative players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_rounds_left = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        stock_level = self._calculate_current_stock(history)
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round = history.round_number + 1
        if current_round == r:
            return Action.D
        if self.punishment_rounds_left > 0:
            self.punishment_rounds_left -= 1
            return Action.D
        if self._should_punish(history, stock_level, capacity):
            self.punishment_rounds_left = 1
            return Action.D
        stock_ratio = stock_level / capacity
        if stock_ratio >= 0.7:
            return Action.D
        elif stock_ratio >= 0.3:
            return self._conditional_defect(history, stock_level, capacity)
        else:
            return self._forced_cooperation(history, stock_level, capacity)

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game history."""
        stock = float(self.game_description.capacity)
        n = self.game_description.n_players
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0.0
            if my_action:
                total_consumption += stock / (2 * n)
            else:
                total_consumption += stock / n
            for opp_action in opponent_actions:
                if opp_action:
                    total_consumption += stock / (2 * n)
                else:
                    total_consumption += stock / n
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.game_description.capacity)
            stock = min(stock_after_consumption + growth, self.game_description.capacity)
        return stock

    def _conditional_defect(self, history: PlayerHistory, stock_level: float, capacity: float) -> Action:
        """Decision logic for medium stock levels (30-70% capacity)."""
        n = self.game_description.n_players
        last_round_defectors = sum((1 for action in history.opponent_actions[-1] if not action))
        if not history.my_actions[-1]:
            last_round_defectors += 1
        defector_ratio = last_round_defectors / n
        if defector_ratio <= 0.3:
            return Action.D
        elif defector_ratio >= 0.7:
            return Action.C
        else:
            my_cumulative = sum(history.my_payoffs)
            avg_cumulative = (sum(history.my_payoffs) + sum(np.sum(history.opponent_payoffs, axis=0))) / n
            if my_cumulative < avg_cumulative:
                return Action.D
            else:
                return Action.D if random.random() < 0.7 else Action.C

    def _forced_cooperation(self, history: PlayerHistory, stock_level: float, capacity: float) -> Action:
        """Decision logic for low stock levels (< 30% capacity)."""
        n = self.game_description.n_players
        stock_ratio = stock_level / capacity
        if stock_ratio < 0.15:
            return Action.C
        else:
            recent_defectors = 0
            rounds_to_check = min(2, history.round_number)
            for i in range(rounds_to_check):
                round_idx = history.round_number - 1 - i
                recent_defectors += sum((1 for action in history.opponent_actions[round_idx] if not action))
                if not history.my_actions[round_idx]:
                    recent_defectors += 1
            if recent_defectors <= n * 0.4 * rounds_to_check:
                return Action.D
            else:
                return Action.C

    def _should_punish(self, history: PlayerHistory, stock_level: float, capacity: float) -> bool:
        """Check if we should enter punishment mode."""
        if history.round_number == 0:
            return False
        stock_ratio = stock_level / capacity
        if stock_ratio <= 0.4:
            return False
        my_last_payoff = history.my_payoffs[-1]
        n = self.game_description.n_players
        total_payoff_last_round = my_last_payoff + sum(history.opponent_payoffs[-1])
        avg_payoff_last_round = total_payoff_last_round / n
        return my_last_payoff < avg_payoff_last_round

class Strategy_AGGRESSIVE_94(BaseStrategy):
    """
    Resource Raider: Aggressive exploitation strategy that maximizes individual payoffs
    through strategic defection while maintaining minimal cooperation to prevent resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.3 * game_description.capacity
        self.endgame_threshold = max(3, game_description.n_rounds // 4)
        self.exploitation_ratio = 0.6

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        rounds_remaining = self.game_description.n_rounds - current_round + 1
        current_stock = self._calculate_current_stock(history)
        if rounds_remaining <= self.endgame_threshold:
            return Action.D
        if current_stock <= self.cooperation_threshold:
            return Action.C
        if history.round_number >= 2:
            recent_defection_rate = self._calculate_recent_defection_rate(history)
            if recent_defection_rate > 0.7:
                return Action.D
            if recent_defection_rate < 0.3:
                return Action.D
        stock_ratio = current_stock / self.game_description.capacity
        if stock_ratio > 0.8:
            return Action.D
        if stock_ratio > 0.5:
            defect_probability = 0.8 - (stock_ratio - 0.5) * 0.4
            if random.random() < defect_probability:
                return Action.D
        return Action.C

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game history."""
        stock = float(self.game_description.capacity)
        n = self.game_description.n_players
        for round_idx in range(history.round_number):
            total_consumption = 0.0
            if history.my_actions[round_idx]:
                my_consumption = stock / (2 * n)
            else:
                my_consumption = stock / n
            total_consumption += my_consumption
            for opponent_idx in range(n - 1):
                if history.opponent_actions[round_idx, opponent_idx]:
                    opponent_consumption = stock / (2 * n)
                else:
                    opponent_consumption = stock / n
                total_consumption += opponent_consumption
            stock_after_consumption = stock - total_consumption
            if stock_after_consumption < 0:
                stock_after_consumption = 0
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.game_description.capacity)
            stock = min(stock_after_consumption + growth, self.game_description.capacity)
        return stock

    def _calculate_recent_defection_rate(self, history: PlayerHistory) -> float:
        """Calculate opponent defection rate over the last 2 rounds."""
        rounds_to_analyze = min(2, history.round_number)
        if rounds_to_analyze == 0:
            return 0.0
        total_decisions = 0
        defection_count = 0
        start_round = history.round_number - rounds_to_analyze
        for round_idx in range(start_round, history.round_number):
            for opponent_idx in range(self.game_description.n_players - 1):
                total_decisions += 1
                if not history.opponent_actions[round_idx, opponent_idx]:
                    defection_count += 1
        return defection_count / total_decisions if total_decisions > 0 else 0.0

class Strategy_AGGRESSIVE_95(BaseStrategy):
    """
    Opportunistic Exploiter: An aggressive strategy that maximizes individual payoffs by 
    exploiting cooperative players while managing the resource to ensure continued 
    exploitation opportunities. Uses stock-based thresholds and cooperation rate monitoring.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number
        if current_round == self.n_rounds - 1:
            return Action.D
        current_stock = self._calculate_current_stock(history)
        high_stock_threshold = self.capacity * 0.7
        low_stock_threshold = self.capacity * 0.2
        critical_threshold = self.capacity * 0.1
        if current_stock <= critical_threshold:
            return Action.C
        if current_round > self.n_rounds * 0.8:
            if current_stock >= self.capacity * 0.3:
                return Action.D
            else:
                return Action.C
        if current_stock >= high_stock_threshold:
            return Action.D
        elif current_stock <= low_stock_threshold:
            return Action.C
        else:
            return self._conditional_defection(history, current_stock)

    def _conditional_defection(self, history: PlayerHistory, current_stock: float) -> Action:
        """Apply conditional defection logic based on cooperation rates."""
        if history.round_number > 0:
            last_round_idx = history.round_number - 1
            cooperators_last_round = sum(history.opponent_actions[last_round_idx])
            cooperation_rate = cooperators_last_round / self.n_players
        else:
            cooperation_rate = 0.5
        if cooperation_rate >= 0.6:
            return Action.D
        elif cooperation_rate <= 0.3:
            return Action.C
        elif current_stock >= self.capacity * 0.4:
            return Action.D
        else:
            return Action.C

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game dynamics."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0.0
            if my_action:
                total_consumption += stock / (2 * self.n_players)
            else:
                total_consumption += stock / self.n_players
            for opponent_action in opponent_actions:
                if opponent_action:
                    total_consumption += stock / (2 * self.n_players)
                else:
                    total_consumption += stock / self.n_players
            stock_after_consumption = max(0.0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            else:
                growth = 0.0
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

class Strategy_AGGRESSIVE_96(BaseStrategy):
    """
    Aggressive "Exploit and Burn" Strategy - Maximizes short-term gains through
    aggressive exploitation, defecting early when stock is highest and only
    cooperating in emergency situations when the resource is nearly depleted.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round = history.round_number + 1
        stock = self._estimate_current_stock(history, capacity, n)
        cooperation_threshold = 0.75
        stock_survival_threshold = capacity / 8
        if current_round <= r // 2:
            return Action.D
        if current_round > r - 2:
            return Action.D
        if history.round_number > 0:
            last_round_opponents = history.opponent_actions[history.round_number - 1]
            opponent_cooperation_rate = np.mean(last_round_opponents)
        else:
            opponent_cooperation_rate = 0.0
        if stock > capacity / 4:
            return Action.D
        if stock < stock_survival_threshold and opponent_cooperation_rate >= cooperation_threshold:
            return Action.C
        return Action.D

    def _estimate_current_stock(self, history: PlayerHistory, capacity: int, n: int) -> float:
        """Estimate current stock level based on history of actions and payoffs."""
        if history.round_number == 0:
            return capacity
        stock = float(capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0.0
            if my_action:
                total_consumption += stock / (2 * n)
            else:
                total_consumption += stock / n
            for opponent_action in opponent_actions:
                if opponent_action:
                    total_consumption += stock / (2 * n)
                else:
                    total_consumption += stock / n
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            stock = min(stock_after_consumption + growth, capacity)
        return stock

class Strategy_AGGRESSIVE_97(BaseStrategy):
    """
    Aggressive "Scorched Earth" Strategy that prioritizes immediate personal gain 
    while punishing cooperative behavior from opponents. Always defects first round,
    punishes any cooperation, and maintains aggressive momentum while preventing 
    complete resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round = history.round_number + 1
        stock = self._calculate_current_stock(history, capacity, n)
        if stock < capacity * 0.15:
            return Action.C
        if current_round >= r * 0.8:
            return Action.D
        last_round_idx = history.round_number - 1
        count_defectors_last_round = sum(history.opponent_actions[last_round_idx] == False)
        count_cooperators_last_round = sum(history.opponent_actions[last_round_idx] == True)
        if history.my_actions[last_round_idx] == False:
            count_defectors_last_round += 1
        else:
            count_cooperators_last_round += 1
        if count_defectors_last_round >= n / 2:
            return Action.D
        my_cumulative_payoff = sum(history.my_payoffs)
        opponent_total_payoffs = np.sum(history.opponent_payoffs)
        opponent_count = n - 1
        average_opponent_payoff = opponent_total_payoffs / opponent_count if opponent_count > 0 else 0
        if my_cumulative_payoff < average_opponent_payoff:
            return Action.D
        if count_cooperators_last_round > 1:
            return Action.D
        return Action.C

    def _calculate_current_stock(self, history: PlayerHistory, capacity: int, n: int) -> float:
        """Calculate current stock level based on game history."""
        stock = float(capacity)
        for round_idx in range(history.round_number):
            total_consumption = 0.0
            if history.my_actions[round_idx]:
                total_consumption += stock / (2 * n)
            else:
                total_consumption += stock / n
            for opponent_idx in range(n - 1):
                if history.opponent_actions[round_idx, opponent_idx]:
                    total_consumption += stock / (2 * n)
                else:
                    total_consumption += stock / n
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            stock = min(stock_after_consumption + growth, capacity)
        return stock

class Strategy_AGGRESSIVE_98(BaseStrategy):
    """
    Predatory Harvester: An aggressive exploitation strategy that maximizes individual payoffs
    through strategic resource extraction while maintaining exploitation opportunities.
    Uses phases: early exploitation, strategic monitoring, and endgame extraction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        stock = self._estimate_current_stock(history)
        phase1_end = self.n_rounds // 3
        phase2_end = 2 * self.n_rounds // 3
        if current_round == self.n_rounds:
            return Action.D
        if current_round <= phase1_end:
            return Action.D
        elif current_round > phase2_end:
            return self._endgame_strategy(stock, history)
        else:
            return self._monitoring_strategy(stock, history)

    def _estimate_current_stock(self, history):
        """Estimate current stock level based on game history"""
        stock = self.capacity
        for round_idx in range(history.round_number):
            my_consumption = self._get_consumption(stock, history.my_actions[round_idx])
            total_opponent_consumption = 0
            for player_idx in range(self.n_players - 1):
                opponent_action = history.opponent_actions[round_idx, player_idx]
                total_opponent_consumption += self._get_consumption(stock, opponent_action)
            total_consumption = my_consumption + total_opponent_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _get_consumption(self, stock, action_bool):
        """Get consumption amount based on action"""
        if action_bool:
            return stock / (2 * self.n_players)
        else:
            return stock / self.n_players

    def _monitoring_strategy(self, stock, history):
        """Phase 2: Strategic monitoring with conditional defection"""
        if stock < self.capacity * 0.3:
            if self._majority_cooperated_last_round(history):
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _endgame_strategy(self, stock, history):
        """Phase 3: Maximum extraction with calculated risks"""
        if stock < self.capacity * 0.15:
            if self._opponents_cooperated_majority_last_2_rounds(history):
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _majority_cooperated_last_round(self, history):
        """Check if majority of opponents cooperated in the last round"""
        if history.round_number == 0:
            return False
        last_round_idx = history.round_number - 1
        cooperators = sum(history.opponent_actions[last_round_idx])
        return cooperators > (self.n_players - 1) * 0.5

    def _opponents_cooperated_majority_last_2_rounds(self, history):
        """Check if opponents cooperated majority of time in last 2 rounds"""
        if history.round_number < 2:
            return self._majority_cooperated_last_round(history)
        total_cooperations = 0
        total_decisions = 0
        for round_offset in [1, 2]:
            round_idx = history.round_number - round_offset
            if round_idx >= 0:
                cooperations = sum(history.opponent_actions[round_idx])
                total_cooperations += cooperations
                total_decisions += self.n_players - 1
        return total_cooperations > total_decisions * 0.6

class Strategy_AGGRESSIVE_99(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Predatory Harvester"
    
    This strategy maximizes immediate gains while strategically preserving the resource 
    only when necessary for continued exploitation. It operates on aggressive early 
    harvesting combined with calculated sustainability to outperform both pure 
    cooperation and pure defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        rounds_remaining = self.n_rounds - current_round + 1
        current_stock = self._calculate_current_stock(history)
        if rounds_remaining <= 2:
            return Action.D
        if rounds_remaining <= 4 and current_stock < self.capacity * 0.4:
            return Action.D
        last_round_idx = history.round_number - 1
        defector_count_last_round = self._count_defectors_last_round(history, last_round_idx)
        my_average_payoff = np.mean(history.my_payoffs)
        opponent_average_payoff = np.mean(history.opponent_payoffs)
        if current_stock >= self.capacity * 0.7:
            return Action.D
        elif current_stock >= self.capacity * 0.3:
            if my_average_payoff < opponent_average_payoff * 1.1 or defector_count_last_round >= self.n_players / 2:
                return Action.D
            else:
                return Action.C
        elif defector_count_last_round >= self.n_players - 1:
            return Action.D
        else:
            return Action.C

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game history."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            my_cooperates = int(my_action)
            opponent_cooperators = int(np.sum(opponent_actions))
            total_cooperators = my_cooperates + opponent_cooperators
            total_defectors = self.n_players - total_cooperators
            cooperator_consumption = total_cooperators * (stock / (2 * self.n_players))
            defector_consumption = total_defectors * (stock / self.n_players)
            total_consumption = cooperator_consumption + defector_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _count_defectors_last_round(self, history: PlayerHistory, round_idx: int) -> int:
        """Count number of defectors (including self) in specified round."""
        if round_idx < 0:
            return 0
        opponent_defectors = int(np.sum(~history.opponent_actions[round_idx]))
        my_defected = int(not history.my_actions[round_idx])
        return opponent_defectors + my_defected

class Strategy_AGGRESSIVE_100(BaseStrategy):
    """
    Aggressive Exploitation Strategy: 'Predator'
    
    Maximizes personal payoffs through opportunistic defection while switching to 
    defensive cooperation only when resource collapse threatens future gains.
    Exploits cooperative behavior and maintains aggression when profitable.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.n_rounds:
            return Action.D
        current_stock = self._estimate_current_stock(history)
        if current_stock >= 0.6 * self.capacity:
            return Action.D
        if current_stock <= 0.15 * self.capacity:
            recent_coop_rate = self._calculate_recent_cooperation_rate(history, 3)
            if recent_coop_rate >= 0.7:
                return Action.C
            else:
                return Action.D
        if 0.15 * self.capacity < current_stock < 0.6 * self.capacity:
            estimated_consumption = self._estimate_total_consumption(history, current_stock)
            stock_after = current_stock - estimated_consumption
            if stock_after < 0.1 * self.capacity:
                if current_round > 0.8 * self.n_rounds:
                    return Action.D
                return Action.C
            else:
                return Action.D
        return Action.D

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game dynamics."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_consumption = self._get_consumption(history.my_actions[round_idx], stock)
            opponent_consumptions = sum((self._get_consumption(history.opponent_actions[round_idx, opp], stock) for opp in range(self.n_players - 1)))
            total_consumption = my_consumption + opponent_consumptions
            stock = max(0, stock - total_consumption)
            if stock > 0:
                growth = 2 * stock * (1 - stock / self.capacity)
                stock = min(stock + growth, self.capacity)
        return stock

    def _get_consumption(self, action: bool, stock: float) -> float:
        """Calculate consumption based on action and current stock."""
        if action:
            return stock / (2 * self.n_players)
        else:
            return stock / self.n_players

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory, lookback: int) -> float:
        """Calculate cooperation rate over recent rounds."""
        if history.round_number == 0:
            return 0.0
        start_round = max(0, history.round_number - lookback)
        total_actions = 0
        total_cooperations = 0
        for round_idx in range(start_round, history.round_number):
            cooperations = sum(history.opponent_actions[round_idx])
            total_cooperations += cooperations
            total_actions += self.n_players - 1
        if total_actions == 0:
            return 0.0
        return total_cooperations / total_actions

    def _estimate_total_consumption(self, history: PlayerHistory, current_stock: float) -> float:
        """Estimate total consumption assuming players continue recent patterns."""
        if history.round_number == 0:
            return current_stock
        recent_round = history.round_number - 1
        my_recent_action = history.my_actions[recent_round]
        my_consumption = current_stock / self.n_players
        opponent_consumption = 0
        for opp in range(self.n_players - 1):
            opp_recent_action = history.opponent_actions[recent_round, opp]
            if opp_recent_action:
                opponent_consumption += current_stock / (2 * self.n_players)
            else:
                opponent_consumption += current_stock / self.n_players
        return my_consumption + opponent_consumption

class Strategy_AGGRESSIVE_101(BaseStrategy):
    """
    Aggressive "Early Strike" Strategy: Prioritizes maximum early extraction while using 
    conditional cooperation to maintain long-term viability. Front-loads exploitation 
    in the first two rounds, then uses conditional cooperation based on stock levels 
    and opponent behavior, finishing with endgame extraction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        current_stock = self._calculate_current_stock(history)
        if current_round <= 2:
            return Action.D
        if current_round >= self.n_rounds - 1:
            if current_round == self.n_rounds:
                return Action.D
            elif current_stock > self.capacity / 3:
                return Action.D
            else:
                return Action.C
        min_coop_consumption = self.n_players / (2 * self.n_players)
        if current_stock < min_coop_consumption:
            return Action.C
        if current_stock < self.capacity / 4:
            return Action.C
        if history.round_number > 0:
            last_round_opponents = history.opponent_actions[history.round_number - 1]
            last_round_my_action = history.my_actions[history.round_number - 1]
            opponent_defectors = sum((1 for action in last_round_opponents if not action))
            my_defection = 0 if last_round_my_action else 1
            total_defectors = opponent_defectors + my_defection
            defector_ratio = total_defectors / self.n_players
            if defector_ratio >= 0.5:
                return Action.D
        if current_stock >= self.capacity / 2:
            return Action.D
        if current_round > self.n_rounds / 2 and current_stock < self.capacity / 3:
            if current_stock >= self.capacity / 6:
                return Action.D
        if history.round_number >= 2:
            consecutive_cooperation = True
            for round_idx in range(max(0, history.round_number - 2), history.round_number):
                round_opponents = history.opponent_actions[round_idx]
                my_action = history.my_actions[round_idx]
                if not my_action:
                    consecutive_cooperation = False
                    break
                if not all(round_opponents):
                    consecutive_cooperation = False
                    break
            if consecutive_cooperation and current_stock >= self.capacity / 2:
                return Action.D
        return Action.C

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game history."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0.0
            if my_action:
                total_consumption += stock / (2 * self.n_players)
            else:
                total_consumption += stock / self.n_players
            for opp_action in opponent_actions:
                if opp_action:
                    total_consumption += stock / (2 * self.n_players)
                else:
                    total_consumption += stock / self.n_players
            stock_after_consumption = max(0.0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
                stock = min(stock_after_consumption + growth, float(self.capacity))
            else:
                stock = 0.0
        return stock

class Strategy_AGGRESSIVE_102(BaseStrategy):
    """
    Aggressive Exploitative Strategy: "Resource Predator"
    
    Front-loads aggression to maximize early payoffs when stock is highest,
    then uses tactical cooperation only when necessary to prevent complete
    resource collapse. Designed to exploit cooperative opponents while
    maintaining just enough sustainability for continued extraction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        rounds_remaining = self.n_rounds - current_round + 1
        current_stock = self._estimate_stock(history)
        if history.round_number > 0:
            last_round_defectors = sum(history.opponent_actions[history.round_number - 1] == False)
            defection_rate_last_round = last_round_defectors / self.n_players
        else:
            defection_rate_last_round = 0.0
        stock_depletion_rate = (self.capacity - current_stock) / self.capacity
        if current_round <= 0.6 * self.n_rounds:
            critical_threshold = self.capacity * 0.15
            if current_stock < critical_threshold:
                return Action.C
            else:
                return Action.D
        elif current_round <= 0.8 * self.n_rounds:
            if current_stock < self.capacity * 0.3:
                return Action.C
            elif defection_rate_last_round > 0.6:
                return Action.C
            else:
                return Action.D
        else:
            minimum_viable_stock = self.capacity * 0.05
            if current_stock <= minimum_viable_stock:
                return Action.C
            else:
                return Action.D

    def _estimate_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game history and dynamics."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            my_cooperated = my_action
            opponent_cooperators = sum(opponent_actions)
            total_cooperators = (1 if my_cooperated else 0) + opponent_cooperators
            total_defectors = self.n_players - total_cooperators
            cooperator_consumption = total_cooperators * (stock / (2 * self.n_players))
            defector_consumption = total_defectors * (stock / self.n_players)
            total_consumption = cooperator_consumption + defector_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            else:
                growth = 0
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

class Strategy_AGGRESSIVE_103(BaseStrategy):
    """
    Aggressive Resource Extraction Strategy: "Predator"
    
    Operates on maximum immediate extraction while exploiting opponents' cooperative tendencies.
    Always starts aggressive, exploits high cooperation, and maximizes extraction in final rounds.
    Only cooperates briefly when facing low cooperation with decent stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        stock = self._calculate_current_stock(history)
        stock_ratio = stock / self.game_description.capacity
        if stock_ratio <= 0.15:
            return Action.D
        recent_coop_rate = self._calculate_recent_cooperation(history, 3)
        if recent_coop_rate >= 0.7:
            return Action.D
        if recent_coop_rate >= 0.4 and stock_ratio >= 0.6:
            return Action.D
        if recent_coop_rate <= 0.3:
            return Action.D
        if stock_ratio >= 0.4 and recent_coop_rate < 0.4:
            return Action.C
        return Action.D

    def _calculate_recent_cooperation(self, history: PlayerHistory, lookback_rounds: int) -> float:
        """Calculate cooperation rate of opponents in recent rounds."""
        rounds_completed = history.round_number
        start_round = max(0, rounds_completed - lookback_rounds)
        if start_round >= rounds_completed:
            return 0.0
        recent_actions = history.opponent_actions[start_round:rounds_completed]
        if recent_actions.size == 0:
            return 0.0
        total_cooperations = np.sum(recent_actions)
        total_actions = recent_actions.size
        return total_cooperations / total_actions

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game history."""
        stock = float(self.game_description.capacity)
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            my_consumption = stock / (2 * n) if my_action else stock / n
            opponent_consumption = 0.0
            for opp_action in opponent_actions:
                if opp_action:
                    opponent_consumption += stock / (2 * n)
                else:
                    opponent_consumption += stock / n
            total_consumption = my_consumption + opponent_consumption
            stock_after_consumption = max(0.0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            stock = min(stock_after_consumption + growth, capacity)
        return stock

class Strategy_AGGRESSIVE_104(BaseStrategy):
    """
    Opportunistic Exploiter: An aggressive strategy that maximizes individual payoffs 
    by exploiting cooperative opponents while adapting to avoid complete resource collapse.
    Always defects in first and last rounds, exploits high-cooperation environments,
    and uses tactical retreats when facing heavy retaliation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.n_rounds:
            return Action.D
        stock = self._estimate_current_stock(history)
        if stock <= self.capacity / 4:
            my_cumulative = sum(history.my_payoffs)
            opponent_cumulative = np.mean([sum(history.opponent_payoffs[:, i]) for i in range(self.n_players - 1)])
            if my_cumulative < opponent_cumulative:
                return Action.D
            else:
                return Action.C
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        cooperation_rate = cooperators_last_round / (self.n_players - 1)
        my_avg_payoff = np.mean(history.my_payoffs)
        opponent_avg_payoffs = np.mean(history.opponent_payoffs)
        my_relative_performance = my_avg_payoff / opponent_avg_payoffs if opponent_avg_payoffs > 0 else 1.0
        if cooperation_rate >= 0.6 and my_relative_performance < 1.2:
            return Action.D
        if cooperation_rate <= 0.3:
            return Action.C
        recent_defections = self._count_recent_defections_against_me(history)
        if recent_defections <= 1:
            return Action.D
        else:
            return Action.C

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock based on game dynamics"""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            total_cooperators = sum(history.opponent_actions[round_idx]) + (1 if my_action else 0)
            total_defectors = self.n_players - total_cooperators
            cooperator_consumption = stock / (2 * self.n_players)
            defector_consumption = stock / self.n_players
            total_consumption = total_cooperators * cooperator_consumption + total_defectors * defector_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _count_recent_defections_against_me(self, history: PlayerHistory) -> int:
        """Count defections by opponents in last 3 rounds"""
        start_round = max(0, history.round_number - 3)
        defections = 0
        for round_idx in range(start_round, history.round_number):
            defections += sum(1 - history.opponent_actions[round_idx])
        return defections

class Strategy_AGGRESSIVE_105(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Hawk-Eye"
    
    Maximizes personal payoffs through aggressive resource extraction while strategically
    timing cooperation to maintain resource availability when it serves self-interest.
    Uses three phases: Early Aggression, Strategic Exploitation, and Endgame Extraction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        current_stock = self._estimate_current_stock(history)
        stock_threshold_high = self.capacity / 2
        stock_threshold_low = self.capacity / 4
        stock_critical = self.capacity * 0.1
        if current_round <= self.n_rounds // 3:
            return Action.D
        elif current_round > 2 * self.n_rounds // 3:
            if current_round > self.n_rounds - 3:
                return Action.D
            elif current_stock >= stock_threshold_low:
                return Action.D
            else:
                return Action.C
        else:
            if current_stock <= stock_critical:
                return Action.C
            if current_stock >= stock_threshold_high:
                return Action.D
            if history.round_number > 0:
                last_round_cooperators = np.sum(history.opponent_actions[history.round_number - 1])
                if last_round_cooperators >= self.n_players // 2:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.D

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """
        Estimate current stock level based on game history and dynamics.
        """
        if history.round_number == 0:
            return self.capacity
        stock = self.capacity
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0.0
            if my_action:
                total_consumption += stock / (2 * self.n_players)
            else:
                total_consumption += stock / self.n_players
            for opp_action in opponent_actions:
                if opp_action:
                    total_consumption += stock / (2 * self.n_players)
                else:
                    total_consumption += stock / self.n_players
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

class Strategy_AGGRESSIVE_106(BaseStrategy):
    """
    Aggressive "Scorched Earth" Strategy that prioritizes immediate high payoffs
    while strategically depleting resources to disadvantage opponents planning
    longer-term cooperative approaches.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.sustainability_threshold = self.capacity * 0.3
        self.depletion_threshold = self.capacity / (4 * self.n)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_number = history.round_number
        current_stock = self._estimate_current_stock(history)
        if round_number >= 0.8 * self.r:
            if current_stock < self.depletion_threshold:
                return self._cooperate_when_profitable(history)
            else:
                return Action.D
        if current_stock < self.depletion_threshold:
            return self._cooperate_when_profitable(history)
        if current_stock >= self.sustainability_threshold:
            return Action.D
        cooperation_rate = self._get_last_round_cooperation_rate(history)
        if cooperation_rate >= 0.5:
            return Action.D
        else:
            return self._tactical_cooperation(history)

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game dynamics"""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            total_consumption = 0.0
            if history.my_actions[round_idx]:
                my_consumption = stock / (2 * self.n)
            else:
                my_consumption = stock / self.n
            total_consumption += my_consumption
            for opponent_idx in range(self.n - 1):
                if history.opponent_actions[round_idx, opponent_idx]:
                    opp_consumption = stock / (2 * self.n)
                else:
                    opp_consumption = stock / self.n
                total_consumption += opp_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            else:
                growth = 0
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _get_last_round_cooperation_rate(self, history: PlayerHistory) -> float:
        """Get cooperation rate from the most recent round"""
        if history.round_number == 0:
            return 0.0
        last_round_idx = history.round_number - 1
        cooperators = sum(history.opponent_actions[last_round_idx])
        return cooperators / (self.n - 1)

    def _count_recent_cooperators(self, history: PlayerHistory) -> int:
        """Count cooperators in recent rounds (last 3 rounds or available rounds)"""
        if history.round_number == 0:
            return 0
        look_back = min(3, history.round_number)
        recent_cooperation = 0
        for i in range(look_back):
            round_idx = history.round_number - 1 - i
            recent_cooperation += sum(history.opponent_actions[round_idx])
        return recent_cooperation // look_back

    def _tactical_cooperation(self, history: PlayerHistory) -> Action:
        """Only cooperate if it helps maintain exploitable stock levels"""
        current_stock = self._estimate_current_stock(history)
        recent_coop_rate = self._get_last_round_cooperation_rate(history)
        if recent_coop_rate > 0.3 and current_stock > self.depletion_threshold * 0.5:
            return Action.C
        else:
            return Action.D

    def _cooperate_when_profitable(self, history: PlayerHistory) -> Action:
        """When stock is very low, only cooperate if others are likely to"""
        recent_cooperators = self._count_recent_cooperators(history)
        if recent_cooperators >= (self.n - 1) // 2:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_107(BaseStrategy):
    """
    Resource Raider: An aggressive strategy that exploits resources early,
    adapts strategically in the middle phase, and maximizes extraction in endgame.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        current_phase = self._determine_phase(current_round)
        current_stock = self._estimate_stock(history)
        if current_stock < 0.2 * self.capacity:
            return Action.D
        if current_phase == 1:
            if current_round > 2:
                if self._all_opponents_defected_recently(history, 2):
                    if current_stock < 0.5 * self.capacity:
                        return Action.C
            return Action.D
        if current_phase == 3:
            return Action.D
        if current_phase == 2:
            stock_condition = current_stock > 0.6 * self.capacity
            cooperation_condition = self._opponents_cooperation_rate_last_round(history) >= 0.75
            payoff_condition = self._payoff_gap_acceptable(history)
            if stock_condition and cooperation_condition and payoff_condition:
                return Action.C
            else:
                return Action.D
        return Action.D

    def _determine_phase(self, round_num):
        """Determine which phase we're in based on round number."""
        if round_num <= self.r / 3:
            return 1
        elif round_num <= 2 * self.r / 3:
            return 2
        else:
            return 3

    def _estimate_stock(self, history):
        """Estimate current stock level based on game history."""
        stock = self.capacity
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0
            if my_action:
                total_consumption += stock / (2 * self.n)
            else:
                total_consumption += stock / self.n
            for opp_action in opponent_actions:
                if opp_action:
                    total_consumption += stock / (2 * self.n)
                else:
                    total_consumption += stock / self.n
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _all_opponents_defected_recently(self, history, rounds):
        """Check if all opponents defected in the last 'rounds' rounds."""
        if history.round_number < rounds:
            return False
        for round_offset in range(rounds):
            round_idx = history.round_number - 1 - round_offset
            if any(history.opponent_actions[round_idx]):
                return False
        return True

    def _opponents_cooperation_rate_last_round(self, history):
        """Calculate the cooperation rate of opponents in the last round."""
        if history.round_number == 0:
            return 0
        last_round_actions = history.opponent_actions[history.round_number - 1]
        return np.mean(last_round_actions)

    def _payoff_gap_acceptable(self, history):
        """Check if my payoff gap from the leader is within 15%."""
        if history.round_number == 0:
            return True
        my_total_payoff = np.sum(history.my_payoffs)
        opponent_totals = np.sum(history.opponent_payoffs, axis=0)
        max_opponent_payoff = np.max(opponent_totals)
        leader_payoff = max(my_total_payoff, max_opponent_payoff)
        if leader_payoff == 0:
            return True
        gap = (leader_payoff - my_total_payoff) / leader_payoff
        return gap <= 0.15

class Strategy_AGGRESSIVE_108(BaseStrategy):
    """
    Aggressive Resource Exploitation Strategy: "Shark"
    
    This strategy operates on the principle of aggressive early exploitation while maintaining 
    strategic flexibility to capitalize on cooperative opponents. It maximizes immediate returns 
    while using the threat of resource depletion as leverage.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_num = history.round_number + 1
        current_stock = self._calculate_current_stock(history)
        if round_num <= self.n_rounds / 3:
            if current_stock > self.capacity * 0.8:
                return Action.D
            elif self._count_cooperators_last_round(history) >= self.n_players / 2:
                return Action.D
            else:
                return Action.C
        elif round_num <= 2 * self.n_rounds / 3:
            if self._stock_trend_last_3_rounds(history) > 0:
                return Action.D
            elif current_stock < self.capacity * 0.3:
                if self._count_defectors_last_round(history) >= self.n_players / 2:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
        elif round_num == self.n_rounds:
            return Action.D
        elif current_stock > self.n_players * 2:
            return Action.D
        elif self._expected_other_defectors(history) >= self.n_players / 2:
            return Action.D
        else:
            return Action.C

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game dynamics."""
        stock = self.capacity
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            cooperators = int(my_action) + sum(opponent_actions)
            defectors = self.n_players - cooperators
            coop_consumption = cooperators * (stock / (2 * self.n_players))
            defect_consumption = defectors * (stock / self.n_players)
            total_consumption = coop_consumption + defect_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _count_cooperators_last_round(self, history: PlayerHistory) -> int:
        """Count cooperators in the most recent round."""
        if history.round_number == 0:
            return 0
        last_round = history.round_number - 1
        my_action = int(history.my_actions[last_round])
        opponent_cooperators = sum(history.opponent_actions[last_round])
        return my_action + opponent_cooperators

    def _count_defectors_last_round(self, history: PlayerHistory) -> int:
        """Count defectors in the most recent round."""
        return self.n_players - self._count_cooperators_last_round(history)

    def _stock_trend_last_3_rounds(self, history: PlayerHistory) -> float:
        """Calculate stock trend over last 3 rounds."""
        if history.round_number < 3:
            return 0
        stock_3_ago = self.capacity
        for round_idx in range(history.round_number - 3):
            stock_3_ago = self._simulate_round_stock_change(stock_3_ago, history, round_idx)
        current_stock = self._calculate_current_stock(history)
        return (current_stock - stock_3_ago) / 3

    def _simulate_round_stock_change(self, initial_stock: float, history: PlayerHistory, round_idx: int) -> float:
        """Simulate stock change for a specific round."""
        my_action = history.my_actions[round_idx]
        opponent_actions = history.opponent_actions[round_idx]
        cooperators = int(my_action) + sum(opponent_actions)
        defectors = self.n_players - cooperators
        coop_consumption = cooperators * (initial_stock / (2 * self.n_players))
        defect_consumption = defectors * (initial_stock / self.n_players)
        total_consumption = coop_consumption + defect_consumption
        stock_after_consumption = max(0, initial_stock - total_consumption)
        growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
        return min(stock_after_consumption + growth, self.capacity)

    def _expected_other_defectors(self, history: PlayerHistory) -> int:
        """Predict number of other players who will defect based on recent behavior."""
        if history.round_number < 2:
            return 0
        recent_defections = 0
        recent_total = 0
        for round_offset in range(min(2, history.round_number)):
            round_idx = history.round_number - 1 - round_offset
            opponent_defections = sum(1 - history.opponent_actions[round_idx])
            recent_defections += opponent_defections
            recent_total += len(history.opponent_actions[round_idx])
        if recent_total == 0:
            return 0
        recent_defection_rate = recent_defections / recent_total
        return round(recent_defection_rate * (self.n_players - 1))

class Strategy_AGGRESSIVE_109(BaseStrategy):
    """
    Opportunistic Exploiter: An aggressive strategy that maximizes individual payoffs
    by exploiting cooperative opponents while minimizing exposure to being exploited.
    Defects aggressively when stock is healthy and opponents cooperate, but switches
    to cooperation only when necessary to prevent resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.n_rounds:
            return Action.D
        stock = self._calculate_current_stock(history)
        critical_threshold = self.capacity * 0.15
        if stock <= critical_threshold:
            return Action.C
        exploitation_threshold = self.capacity * 0.4
        if stock >= exploitation_threshold:
            return Action.D
        recent_cooperation_rate = self._calculate_opponent_cooperation_rate(history)
        if recent_cooperation_rate >= 0.6:
            return Action.D
        elif recent_cooperation_rate <= 0.3:
            return Action.C
        else:
            stock_ratio = stock / self.capacity
            if stock_ratio > 0.5:
                return Action.D
            else:
                return Action.C

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game dynamics."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            cooperators = int(my_action) + int(np.sum(opponent_actions))
            defectors = self.n_players - cooperators
            cooperator_consumption = stock / (2 * self.n_players)
            defector_consumption = stock / self.n_players
            total_consumption = cooperators * cooperator_consumption + defectors * defector_consumption
            stock_after_consumption = max(0.0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth_rate = 1 - stock_after_consumption / self.capacity
                growth = 2 * stock_after_consumption * growth_rate
                stock = min(stock_after_consumption + growth, self.capacity)
            else:
                stock = 0.0
        return stock

    def _calculate_opponent_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate cooperation rate of opponents in recent rounds (last 3 or all available)."""
        rounds_to_analyze = min(3, history.round_number)
        if rounds_to_analyze == 0:
            return 0.5
        start_round = max(0, history.round_number - rounds_to_analyze)
        total_actions = 0
        cooperative_actions = 0
        for round_idx in range(start_round, history.round_number):
            opponent_actions_in_round = history.opponent_actions[round_idx]
            total_actions += len(opponent_actions_in_round)
            cooperative_actions += int(np.sum(opponent_actions_in_round))
        if total_actions == 0:
            return 0.5
        return cooperative_actions / total_actions

class Strategy_AGGRESSIVE_110(BaseStrategy):
    """
    Predatory Harvester - Aggressive exploitation strategy that maximizes resource extraction
    while maintaining minimal sustainability. Exploits cooperative opponents and uses calculated
    aggression with temporal dynamics (opening aggression, middle-game exploitation, endgame extraction).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defection_streak = 0
        self.last_round_stock = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round = history.round_number + 1
        rounds_remaining = r - current_round + 1
        current_stock = self._estimate_current_stock(history, capacity, n)
        if current_stock < capacity * 0.15:
            if rounds_remaining > 3:
                self.defection_streak = 0
                return Action.C
        if current_round <= max(2, r * 0.2):
            self.defection_streak += 1
            return Action.D
        if rounds_remaining <= max(2, r * 0.15):
            if current_stock > capacity * 0.1:
                self.defection_streak += 1
                return Action.D
            else:
                self.defection_streak = 0
                return Action.C
        last_round_idx = history.round_number - 1
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        opponent_cooperation_rate = opponent_cooperators / (n - 1)
        if opponent_cooperation_rate >= 0.7:
            self.defection_streak += 1
            if self.defection_streak >= 3 and current_stock < capacity * 0.4:
                self.defection_streak = 0
                return Action.C
            return Action.D
        if opponent_cooperation_rate >= 0.4:
            if current_stock > capacity * 0.6:
                self.defection_streak += 1
                return Action.D
            else:
                self.defection_streak = 0
                return Action.C
        if current_stock > capacity * 0.3:
            self.defection_streak += 1
            return Action.D
        else:
            self.defection_streak = 0
            return Action.C

    def _estimate_current_stock(self, history: PlayerHistory, capacity: float, n: int) -> float:
        """Estimate current stock based on consumption and growth dynamics."""
        if history.round_number == 0:
            return capacity
        stock = capacity
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0.0
            if my_action:
                total_consumption += stock / (2 * n)
            else:
                total_consumption += stock / n
            for opp_action in opponent_actions:
                if opp_action:
                    total_consumption += stock / (2 * n)
                else:
                    total_consumption += stock / n
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            stock = min(stock_after_consumption + growth, capacity)
        return stock

class Strategy_AGGRESSIVE_111(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Resource Vulture"
    
    This strategy operates on immediate resource extraction maximization while exploiting 
    cooperative opponents. It defaults to defection with strategic cooperation only when 
    resource collapse is imminent.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defection_streak = 0
        self.cooperation_threshold = 0.6
        self.endgame_threshold = 3

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.defection_streak = 1
            return Action.D
        current_round = history.round_number + 1
        if current_round > self.game_description.n_rounds - self.endgame_threshold:
            return Action.D
        last_round_idx = history.round_number - 1
        my_last_payoff = history.my_payoffs[last_round_idx]
        my_last_action = history.my_actions[last_round_idx]
        if my_last_action:
            estimated_last_stock = my_last_payoff * 2 * self.game_description.n_players
        else:
            estimated_last_stock = my_last_payoff * self.game_description.n_players
        if estimated_last_stock < self.game_description.capacity * 0.3:
            return Action.D
        last_round_opponents = history.opponent_actions[last_round_idx]
        cooperation_rate = np.mean(last_round_opponents)
        if cooperation_rate >= self.cooperation_threshold:
            self.defection_streak += 1
            return Action.D
        if estimated_last_stock < self.game_description.capacity * 0.15 and self.defection_streak > 2:
            self.defection_streak = 0
            return Action.C
        self.defection_streak += 1
        return Action.D

class Strategy_AGGRESSIVE_112(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Resource Predator"
    
    Operates on maximum resource extraction with strategic sustainability.
    Aggressively exploits the common pool while maintaining just enough stock
    to continue profitable defection. Uses cooperation only as a tool for
    stock recovery when absolutely necessary.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.minimum_viable = self.capacity / (4 * self.r)
        self.sustainability_threshold = self.capacity * 0.3
        self.exploitation_threshold = self.capacity * 0.5
        self.endgame_start = math.ceil(self.r * 0.75)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        current_stock = self._calculate_current_stock(history)
        if current_round >= self.endgame_start:
            return Action.D
        if current_round == 2:
            if current_stock >= self.sustainability_threshold:
                return Action.D
            else:
                return Action.C
        if current_stock >= self.exploitation_threshold:
            return Action.D
        if current_stock >= self.minimum_viable and history.round_number > 0:
            last_round_defection_rate = self._get_last_round_defection_rate(history)
            if last_round_defection_rate > 0.6:
                return Action.D
        if current_stock < self.sustainability_threshold:
            return Action.C
        if current_stock >= self.minimum_viable:
            return Action.D
        else:
            return Action.C

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game history."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_action_cooperated = history.my_actions[round_idx]
            opponent_cooperations = np.sum(history.opponent_actions[round_idx])
            my_consumption = stock / (2 * self.n) if my_action_cooperated else stock / self.n
            total_opponent_consumption = 0
            for opp_idx in range(len(history.opponent_actions[round_idx])):
                opp_cooperated = history.opponent_actions[round_idx][opp_idx]
                opp_consumption = stock / (2 * self.n) if opp_cooperated else stock / self.n
                total_opponent_consumption += opp_consumption
            total_consumption = my_consumption + total_opponent_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _get_last_round_defection_rate(self, history: PlayerHistory) -> float:
        """Get the defection rate of opponents in the most recent round."""
        if history.round_number == 0:
            return 0.0
        last_round_actions = history.opponent_actions[history.round_number - 1]
        defections = np.sum(last_round_actions == False)
        total_opponents = len(last_round_actions)
        return defections / total_opponents if total_opponents > 0 else 0.0

class Strategy_AGGRESSIVE_113(BaseStrategy):
    """
    Aggressive Exploit Strategy: "Resource Shark"
    
    Maximizes personal payoffs through aggressive exploitation while maintaining
    just enough restraint to keep the resource pool viable for continued exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_num = history.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        stock = self._calculate_current_stock(history, capacity, n)
        if round_num == r:
            return Action.D
        if round_num <= max(1, r * 0.2):
            return self._early_game_strategy(round_num, stock, history, n, r, capacity)
        return self._exploit_strategy(round_num, stock, history, n, r, capacity)

    def _calculate_current_stock(self, history, capacity, n):
        """Calculate current stock based on history."""
        stock = float(capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            my_consumption = stock / (2 * n) if my_action else stock / n
            total_consumption = my_consumption
            for opp_action in opponent_actions:
                if opp_action:
                    total_consumption += stock / (2 * n)
                else:
                    total_consumption += stock / n
            stock_after_consumption = max(0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
                stock = min(stock_after_consumption + growth, capacity)
            else:
                stock = 0
        return stock

    def _early_game_strategy(self, round_num, stock, history, n, r, capacity):
        """Early game strategy to establish dominance."""
        if round_num == 1:
            return Action.D
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        if cooperators_last_round >= n / 2:
            return Action.D
        if stock < capacity * 0.3:
            return Action.C
        return Action.D

    def _exploit_strategy(self, round_num, stock, history, n, r, capacity):
        """Main exploitation strategy."""
        if stock < capacity * 0.25:
            return Action.C
        lookback = min(3, history.round_number)
        recent_coop_rate = self._calculate_others_cooperation_rate(history, lookback)
        stock_ratio = stock / capacity
        if recent_coop_rate > 0.6 and stock_ratio > 0.4:
            return Action.D
        if stock_ratio > 0.8:
            return Action.D
        if recent_coop_rate < 0.3:
            if stock_ratio > 0.5:
                return Action.D
            else:
                return Action.C
        if round_num > r * 0.75:
            return self._end_game_strategy(round_num, stock, history, n, r, capacity)
        if stock_ratio > 0.5:
            return Action.D
        else:
            return Action.C

    def _end_game_strategy(self, round_num, stock, history, n, r, capacity):
        """End game strategy for maximum extraction."""
        if round_num == r:
            return Action.D
        rounds_left = r - round_num
        if rounds_left <= 2:
            return Action.D
        expected_consumption = n * (stock / n)
        if stock > expected_consumption:
            return Action.D
        else:
            return Action.C

    def _calculate_others_cooperation_rate(self, history, lookback):
        """Calculate cooperation rate of other players over recent rounds."""
        if history.round_number == 0:
            return 0.5
        start_idx = max(0, history.round_number - lookback)
        total_actions = 0
        total_cooperations = 0
        for round_idx in range(start_idx, history.round_number):
            for opp_action in history.opponent_actions[round_idx]:
                total_actions += 1
                if opp_action:
                    total_cooperations += 1
        if total_actions == 0:
            return 0.5
        return total_cooperations / total_actions

class Strategy_AGGRESSIVE_114(BaseStrategy):
    """
    Opportunistic Predator: An aggressive resource extraction strategy that maximizes 
    immediate gains while strategically timing minimal cooperation to maintain just 
    enough resource sustainability for continued exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        stock = self._calculate_current_stock(history)
        if current_round == n_rounds:
            return Action.D
        if stock <= capacity * 0.3:
            return Action.C
        if history.round_number > 0:
            last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
            if last_round_cooperators >= n_players / 2:
                return Action.D
        consecutive_defections = self._count_consecutive_defections(history)
        if consecutive_defections >= 3 and stock < capacity * 0.6:
            return Action.C
        return Action.D

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game history."""
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        stock = float(capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0.0
            if my_action:
                total_consumption += stock / (2 * n_players)
            else:
                total_consumption += stock / n_players
            for opp_action in opponent_actions:
                if opp_action:
                    total_consumption += stock / (2 * n_players)
                else:
                    total_consumption += stock / n_players
            stock_after_consumption = max(0.0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            else:
                growth = 0.0
            stock = min(stock_after_consumption + growth, capacity)
        return stock

    def _count_consecutive_defections(self, history: PlayerHistory) -> int:
        """Count consecutive defections from the end of my action history."""
        if history.round_number == 0:
            return 0
        consecutive = 0
        for i in range(history.round_number - 1, -1, -1):
            if not history.my_actions[i]:
                consecutive += 1
            else:
                break
        return consecutive

class Strategy_AGGRESSIVE_115(BaseStrategy):
    """
    Aggressive Predator Strategy: Maximizes personal payoffs through aggressive exploitation 
    with strategic restraint. Operates in three phases - early exploitation, mid-game 
    assessment, and endgame maximization. Uses emergency brake mechanism to prevent 
    total resource collapse while maintaining aggressive extraction as primary mode.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        current_stock = self._estimate_current_stock(history)
        if current_round <= self.n_rounds - 3:
            if current_stock > self.capacity * 0.15:
                return Action.D
            elif self._majority_defected_last_round(history):
                return Action.C
            else:
                return Action.D
        elif current_round <= self.n_rounds - 1:
            if current_stock < self.capacity * 0.1:
                return Action.C
            elif self._count_recent_cooperators(history) >= self.n_players / 2:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game dynamics."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            cooperators = int(my_action) + sum(opponent_actions)
            defectors = self.n_players - cooperators
            cooperator_consumption = stock / (2 * self.n_players)
            defector_consumption = stock / self.n_players
            total_consumption = cooperators * cooperator_consumption + defectors * defector_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _majority_defected_last_round(self, history: PlayerHistory) -> bool:
        """Check if majority of players (including self) defected in the last round."""
        if history.round_number == 0:
            return False
        last_round_idx = history.round_number - 1
        my_last_action = history.my_actions[last_round_idx]
        opponent_last_actions = history.opponent_actions[last_round_idx]
        defectors = int(not my_last_action) + sum((not action for action in opponent_last_actions))
        return defectors > self.n_players / 2

    def _count_recent_cooperators(self, history: PlayerHistory) -> int:
        """Count cooperators in the most recent round."""
        if history.round_number == 0:
            return 0
        last_round_idx = history.round_number - 1
        my_last_action = history.my_actions[last_round_idx]
        opponent_last_actions = history.opponent_actions[last_round_idx]
        cooperators = int(my_last_action) + sum(opponent_last_actions)
        return cooperators

class Strategy_AGGRESSIVE_116(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Vulture"
    
    Maximizes immediate gains through aggressive opportunism, exploiting cooperative
    opponents while strategically timing defections. Prioritizes front-loading gains
    over long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.consecutive_defections = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.consecutive_defections = 1
            return Action.D
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        last_round_idx = history.round_number - 1
        my_last_payoff = history.my_payoffs[last_round_idx]
        my_last_action = history.my_actions[last_round_idx]
        if my_last_action:
            last_stock = my_last_payoff * 2 * n_players
        else:
            last_stock = my_last_payoff * n_players
        stock = last_stock
        if history.round_number > 0:
            cooperators_last_round = sum(history.opponent_actions[last_round_idx])
            total_players = n_players
        else:
            cooperators_last_round = 0
            total_players = n_players
        if history.my_actions[last_round_idx] == False:
            self.consecutive_defections += 1
        else:
            self.consecutive_defections = 0
        if stock <= capacity * 0.15:
            self.consecutive_defections = 0
            return Action.C
        if current_round >= total_rounds - 1:
            self.consecutive_defections += 1
            return Action.D
        if stock >= capacity * 0.7:
            self.consecutive_defections += 1
            return Action.D
        if stock >= capacity * 0.4:
            cooperation_rate = cooperators_last_round / max(1, total_players - 1)
            if cooperation_rate >= 0.6:
                self.consecutive_defections += 1
                return Action.D
            elif self.consecutive_defections < 3:
                self.consecutive_defections += 1
                return Action.D
            else:
                self.consecutive_defections = 0
                return Action.C
        cooperation_rate = cooperators_last_round / max(1, total_players - 1)
        if cooperation_rate >= 0.8:
            self.consecutive_defections += 1
            return Action.D
        else:
            self.consecutive_defections = 0
            return Action.C

class Strategy_AGGRESSIVE_117(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Resource Shark"
    
    Maximizes immediate extraction while strategically timing cooperation only when 
    necessary for long-term exploitation potential. Uses multi-tiered decision system
    based on resource thresholds, opponent behavior classification, and end-game maximization.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_num = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        rounds_remaining = total_rounds - round_num
        current_stock = self._estimate_current_stock(history, capacity, n_players)
        stock_ratio = current_stock / capacity
        if round_num <= 2:
            return Action.D
        if rounds_remaining <= total_rounds * 0.2:
            if current_stock > 0:
                return Action.D
            else:
                return Action.C
        if stock_ratio < 0.3 and rounds_remaining > 3 or stock_ratio < 0.15:
            return Action.C
        if history.round_number >= 3:
            recent_coop_rates = []
            for player_idx in range(n_players - 1):
                recent_actions = history.opponent_actions[-3:, player_idx]
                coop_rate = np.mean(recent_actions)
                recent_coop_rates.append(coop_rate)
            exploitable_count = sum((1 for rate in recent_coop_rates if rate > 0.6))
            if exploitable_count >= n_players / 2 and stock_ratio > 0.25:
                return Action.D
        if history.round_number > 0:
            last_round_defectors = np.sum(history.opponent_actions[-1] == False)
            if last_round_defectors >= n_players / 2 and stock_ratio > 0.4:
                return Action.D
        if stock_ratio > 0.5:
            return Action.D
        else:
            return Action.C

    def _estimate_current_stock(self, history: PlayerHistory, capacity: float, n_players: int) -> float:
        """Estimate current stock level based on game history"""
        stock = capacity
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            cooperators = int(my_action) + np.sum(opponent_actions)
            defectors = n_players - cooperators
            total_consumption = cooperators * (stock / (2 * n_players)) + defectors * (stock / n_players)
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            stock = min(stock_after_consumption + growth, capacity)
        return stock

class Strategy_AGGRESSIVE_118(BaseStrategy):
    """
    Aggressive "Resource Vulture" Strategy - Maximizes immediate gains through strategic exploitation
    with tactical cooperation to manipulate opponents and preserve future extraction opportunities.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.consecutive_cooperation_rounds = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.consecutive_cooperation_rounds = 0
            return Action.D
        current_round = history.round_number + 1
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        final_round = self.game_description.n_rounds
        current_stock = self._calculate_current_stock(history)
        if current_stock <= capacity * 0.15:
            self.consecutive_cooperation_rounds += 1
            return Action.C
        if current_round == final_round:
            return Action.D
        last_round_idx = history.round_number - 1
        last_round_opponent_actions = history.opponent_actions[last_round_idx]
        my_last_action = history.my_actions[last_round_idx]
        total_defectors_last_round = sum(~last_round_opponent_actions) + (0 if my_last_action else 1)
        majority_defected = total_defectors_last_round > n_players / 2
        opponent_defectors = sum(~last_round_opponent_actions)
        i_was_only_defector = not my_last_action and opponent_defectors == 0
        if i_was_only_defector:
            self.consecutive_cooperation_rounds += 1
            return Action.C
        if majority_defected and current_stock > capacity * 0.4:
            self.consecutive_cooperation_rounds = 0
            return Action.D
        if current_stock > capacity * 0.8:
            self.consecutive_cooperation_rounds = 0
            return Action.D
        if self.consecutive_cooperation_rounds >= 2:
            self.consecutive_cooperation_rounds = 0
            return Action.D
        self.consecutive_cooperation_rounds += 1
        return Action.C

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game history."""
        stock = self.game_description.capacity
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            if my_action:
                my_consumption = stock / (2 * n_players)
            else:
                my_consumption = stock / n_players
            opponent_consumption = 0
            for opponent_cooperated in opponent_actions:
                if opponent_cooperated:
                    opponent_consumption += stock / (2 * n_players)
                else:
                    opponent_consumption += stock / n_players
            total_consumption = my_consumption + opponent_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            stock = min(stock_after_consumption + growth, capacity)
        return stock

class Strategy_AGGRESSIVE_119(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Resource Shark"
    
    This strategy operates on aggressive exploitation with calculated restraint,
    aiming to extract maximum personal value while strategically preserving 
    resources only when necessary for continued exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.exploitation_threshold = 0.6
        self.opponent_patterns = {}

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        rounds_remaining = self.game_description.n_rounds - current_round
        current_stock = self._estimate_current_stock(history)
        stock_ratio = current_stock / self.game_description.capacity
        if rounds_remaining <= 1:
            return Action.D
        self._update_threshold(history)
        if stock_ratio >= self.exploitation_threshold:
            return Action.D
        else:
            return self._conditional_cooperate(history, stock_ratio, rounds_remaining)

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock based on game history"""
        stock = float(self.game_description.capacity)
        n = self.game_description.n_players
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0.0
            if my_action:
                total_consumption += stock / (2 * n)
            else:
                total_consumption += stock / n
            for opp_action in opponent_actions:
                if opp_action:
                    total_consumption += stock / (2 * n)
                else:
                    total_consumption += stock / n
            stock_after_consumption = max(0, stock - total_consumption)
            capacity = self.game_description.capacity
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            stock = min(stock_after_consumption + growth, capacity)
        return stock

    def _update_threshold(self, history: PlayerHistory):
        """Update exploitation threshold based on opponent defection rate"""
        if history.round_number == 0:
            return
        last_round_idx = history.round_number - 1
        opponent_actions = history.opponent_actions[last_round_idx]
        defection_rate = sum((1 - action for action in opponent_actions)) / len(opponent_actions)
        if defection_rate > 0.7:
            self.exploitation_threshold = max(0.3, self.exploitation_threshold - 0.1)
        elif defection_rate < 0.3:
            self.exploitation_threshold = min(0.8, self.exploitation_threshold + 0.1)

    def _conditional_cooperate(self, history: PlayerHistory, stock_ratio: float, rounds_remaining: int) -> Action:
        """Implement conditional cooperation logic"""
        stock_depletion_rate = 1.0 - stock_ratio
        if stock_depletion_rate > 0.8:
            return Action.C
        opponent_defection_trend = self._calculate_defection_trend(history)
        if opponent_defection_trend > 0.6:
            return Action.D
        if self._detect_exploitable_opponents(history):
            return Action.D
        return Action.C

    def _calculate_defection_trend(self, history: PlayerHistory) -> float:
        """Calculate recent opponent defection trend"""
        if history.round_number == 0:
            return 0.0
        lookback = min(3, history.round_number)
        total_defections = 0
        total_decisions = 0
        for round_offset in range(lookback):
            round_idx = history.round_number - 1 - round_offset
            opponent_actions = history.opponent_actions[round_idx]
            for action in opponent_actions:
                total_decisions += 1
                if not action:
                    total_defections += 1
        return total_defections / total_decisions if total_decisions > 0 else 0.0

    def _detect_exploitable_opponents(self, history: PlayerHistory) -> bool:
        """Detect if there are opponents showing consistent cooperation"""
        if history.round_number < 3:
            return False
        n_opponents = len(history.opponent_actions[0])
        for opp_idx in range(n_opponents):
            consecutive_cooperations = 0
            for round_offset in range(min(3, history.round_number)):
                round_idx = history.round_number - 1 - round_offset
                if history.opponent_actions[round_idx][opp_idx]:
                    consecutive_cooperations += 1
                else:
                    break
            if consecutive_cooperations >= 3:
                return True
        return False

class Strategy_AGGRESSIVE_120(BaseStrategy):
    """
    Aggressive "Exploitation-First" Strategy that prioritizes immediate high payoffs 
    while maintaining the pool just enough to continue extracting maximum value.
    Exploits cooperation when stock is high, cooperates only when necessary for survival.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.exploitation_threshold = 0.3 * game_description.capacity
        self.cooperation_trigger = 0.15 * game_description.capacity
        self.defection_streak_limit = 3
        self.current_defection_streak = 0

    def _calculate_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock based on game history."""
        stock = self.game_description.capacity
        for round_idx in range(history.round_number):
            total_consumption = 0.0
            if history.my_actions[round_idx]:
                total_consumption += stock / (2 * self.game_description.n_players)
            else:
                total_consumption += stock / self.game_description.n_players
            for player_idx in range(self.game_description.n_players - 1):
                if history.opponent_actions[round_idx, player_idx]:
                    total_consumption += stock / (2 * self.game_description.n_players)
                else:
                    total_consumption += stock / self.game_description.n_players
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.game_description.capacity)
            stock = min(stock_after_consumption + growth, self.game_description.capacity)
        return stock

    def _count_defectors_last_round(self, history: PlayerHistory) -> int:
        """Count how many players defected in the last round."""
        if history.round_number == 0:
            return 0
        last_round_idx = history.round_number - 1
        defectors = 0
        if not history.my_actions[last_round_idx]:
            defectors += 1
        for player_idx in range(self.game_description.n_players - 1):
            if not history.opponent_actions[last_round_idx, player_idx]:
                defectors += 1
        return defectors

    def _get_stock_growth_last_round(self, history: PlayerHistory) -> float:
        """Calculate stock growth from the last round."""
        if history.round_number < 2:
            return 0
        stock_before_last = self.game_description.capacity
        for round_idx in range(history.round_number - 1):
            total_consumption = 0.0
            if history.my_actions[round_idx]:
                total_consumption += stock_before_last / (2 * self.game_description.n_players)
            else:
                total_consumption += stock_before_last / self.game_description.n_players
            for player_idx in range(self.game_description.n_players - 1):
                if history.opponent_actions[round_idx, player_idx]:
                    total_consumption += stock_before_last / (2 * self.game_description.n_players)
                else:
                    total_consumption += stock_before_last / self.game_description.n_players
            stock_after_consumption = max(0, stock_before_last - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.game_description.capacity)
            stock_before_last = min(stock_after_consumption + growth, self.game_description.capacity)
        current_stock = self._calculate_stock(history)
        return current_stock - stock_before_last

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.current_defection_streak = 1
            return Action.D
        current_round = history.round_number + 1
        current_stock = self._calculate_stock(history)
        if current_round == self.game_description.n_rounds:
            return Action.D
        if current_stock <= self.cooperation_trigger:
            self.current_defection_streak = 0
            return Action.C
        if self.current_defection_streak >= self.defection_streak_limit:
            self.current_defection_streak = 0
            return Action.C
        if current_stock > self.exploitation_threshold:
            self.current_defection_streak += 1
            return Action.D
        defector_count = self._count_defectors_last_round(history)
        defector_ratio = defector_count / self.game_description.n_players
        if defector_ratio >= 0.5:
            self.current_defection_streak += 1
            return Action.D
        stock_growth = self._get_stock_growth_last_round(history)
        if stock_growth < 0:
            self.current_defection_streak = 0
            return Action.C
        self.current_defection_streak += 1
        return Action.D

class Strategy_AGGRESSIVE_121(BaseStrategy):
    """
    Aggressive Strategy: "Rapid Depletion Maximizer"
    
    Operates on early aggressive extraction to maximize payoffs by capturing 
    high-value stock before depletion. Uses three phases: early aggression,
    conditional exploitation, and final extraction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        current_stock = self._estimate_current_stock(history)
        if current_round <= self.n_rounds / 3:
            return Action.D
        elif current_round > 2 * self.n_rounds / 3:
            return self._final_extraction_decision(current_stock, current_round)
        else:
            return self._conditional_exploitation_decision(history, current_stock)

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock based on payoffs and game dynamics."""
        if len(history.my_payoffs) == 0:
            return self.capacity
        last_payoff = history.my_payoffs[-1]
        last_action = history.my_actions[-1]
        if last_action:
            estimated_pre_consumption_stock = last_payoff * (2 * self.n_players)
        else:
            estimated_pre_consumption_stock = last_payoff * self.n_players
        return max(0, estimated_pre_consumption_stock * 0.6)

    def _final_extraction_decision(self, current_stock: float, current_round: int) -> Action:
        """Phase 3: Final extraction logic."""
        remaining_rounds = self.n_rounds - current_round + 1
        if current_stock <= 0:
            return Action.C
        if remaining_rounds <= 2:
            return Action.D
        if current_stock < self.n_players * 2:
            return Action.C
        return Action.D

    def _conditional_exploitation_decision(self, history: PlayerHistory, current_stock: float) -> Action:
        """Phase 2: Conditional exploitation logic."""
        if current_stock < self.capacity / 4:
            return Action.C
        if len(history.opponent_actions) > 0:
            last_round_defectors = sum(history.opponent_actions[-1] == False)
            if last_round_defectors > self.n_players / 2:
                return Action.D
        if len(history.opponent_actions) >= 3:
            recent_rounds = min(3, len(history.opponent_actions))
            recent_cooperation = np.mean(history.opponent_actions[-recent_rounds:])
            if recent_cooperation < 0.3:
                return Action.D
        if len(history.my_payoffs) >= 2:
            recent_avg = np.mean(history.my_payoffs[-2:])
            earlier_avg = np.mean(history.my_payoffs[:-2]) if len(history.my_payoffs) > 2 else recent_avg
            if recent_avg < earlier_avg * 0.8:
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_122(BaseStrategy):
    """
    Aggressive "Exploitation with Endgame Extraction" Strategy
    
    Maximizes individual payoff by aggressively exploiting cooperative players while 
    strategically managing the resource to ensure continued exploitation opportunities.
    Uses tactical cooperation only to maintain exploitable conditions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defect_threshold = 0.3 * game_description.capacity
        self.endgame_rounds = max(2, game_description.n_rounds // 5)
        self.cooperation_streak = 0
        self.consecutive_all_defect = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        rounds_remaining = self.game_description.n_rounds - history.round_number
        current_stock = self._estimate_current_stock(history)
        if rounds_remaining <= self.endgame_rounds:
            return Action.D
        if current_stock < self.defect_threshold:
            self.cooperation_streak += 1
            if self.cooperation_streak >= 2 and self._stock_recovering(history):
                self.cooperation_streak = 0
                return Action.D
            else:
                return Action.C
        else:
            self.cooperation_streak = 0
            if self._last_round_all_defected(history):
                self.consecutive_all_defect += 1
                if self.consecutive_all_defect >= 2:
                    self.consecutive_all_defect = 0
                    return Action.C
            else:
                self.consecutive_all_defect = 0
            if self._majority_cooperated_last_round(history):
                return Action.D
            return Action.D

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock based on payoffs and game mechanics."""
        if history.round_number == 0:
            return self.game_description.capacity
        last_round_idx = history.round_number - 1
        my_last_payoff = history.my_payoffs[last_round_idx]
        my_last_action = history.my_actions[last_round_idx]
        if my_last_action:
            estimated_stock = my_last_payoff * (2 * self.game_description.n_players)
        else:
            estimated_stock = my_last_payoff * self.game_description.n_players
        return max(0, estimated_stock)

    def _stock_recovering(self, history: PlayerHistory) -> bool:
        """Check if stock is recovering compared to previous round."""
        if history.round_number < 2:
            return False
        current_stock = self._estimate_current_stock(history)
        prev_round_idx = history.round_number - 2
        prev_payoff = history.my_payoffs[prev_round_idx]
        prev_action = history.my_actions[prev_round_idx]
        if prev_action:
            prev_stock = prev_payoff * (2 * self.game_description.n_players)
        else:
            prev_stock = prev_payoff * self.game_description.n_players
        return current_stock > prev_stock

    def _last_round_all_defected(self, history: PlayerHistory) -> bool:
        """Check if all players defected in the last round."""
        if history.round_number == 0:
            return False
        last_round_idx = history.round_number - 1
        my_defected = not history.my_actions[last_round_idx]
        opponents_defected = not any(history.opponent_actions[last_round_idx])
        return my_defected and opponents_defected

    def _majority_cooperated_last_round(self, history: PlayerHistory) -> bool:
        """Check if majority of players cooperated in the last round."""
        if history.round_number == 0:
            return True
        last_round_idx = history.round_number - 1
        cooperators = sum(history.opponent_actions[last_round_idx])
        total_opponents = self.game_description.n_players - 1
        return cooperators > total_opponents / 2

class Strategy_AGGRESSIVE_123(BaseStrategy):
    """
    Parasitic Harvester: An aggressive exploitation strategy that maximizes immediate payoffs
    by defaulting to defection while occasionally cooperating only when it can free-ride on
    others' cooperation in high-stock situations.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_num = history.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = self._calculate_current_stock(history)
        if round_num <= 2 or round_num > r - 2:
            return Action.D
        if current_stock < capacity * 0.2:
            return Action.D
        if current_stock >= capacity * 0.8:
            if history.round_number > 0:
                prev_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
                cooperation_rate = prev_round_cooperators / (n - 1)
                if cooperation_rate >= 0.6:
                    return Action.C
        return Action.D

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game history."""
        stock = self.game_description.capacity
        n = self.game_description.n_players
        for round_idx in range(history.round_number):
            my_action_cooperated = history.my_actions[round_idx]
            opponent_cooperators = sum(history.opponent_actions[round_idx])
            total_cooperators = int(my_action_cooperated) + opponent_cooperators
            total_defectors = n - total_cooperators
            cooperator_consumption = stock / (2 * n)
            defector_consumption = stock / n
            total_consumption = total_cooperators * cooperator_consumption + total_defectors * defector_consumption
            stock_after_consumption = stock - total_consumption
            if stock_after_consumption >= 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.game_description.capacity)
                stock = min(stock_after_consumption + growth, self.game_description.capacity)
            else:
                stock = 0
        return stock

class Strategy_AGGRESSIVE_124(BaseStrategy):
    """
    Aggressive Early Exploitation Strategy (AEES).
    Maximizes immediate payoffs through aggressive defection while strategically timing
    cooperation to maintain resource viability. Operates in three phases:
    1. Early exploitation (rounds 1-2): Always defect
    2. Conditional aggression (middle rounds): Defect unless stock is low and opponents cooperated
    3. Final exploitation (last 2 rounds): Always defect
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round <= 2:
            return Action.D
        if current_round > self.n_rounds - 2:
            return Action.D
        current_stock = self._estimate_current_stock(history)
        if current_stock < self.capacity / 10:
            return Action.C
        if current_stock > self.capacity / 3:
            return Action.D
        if history.round_number > 0:
            last_round_idx = history.round_number - 1
            opponent_cooperations = np.sum(history.opponent_actions[last_round_idx])
            opponent_defection_rate = (self.n_players - 1 - opponent_cooperations) / (self.n_players - 1)
            if opponent_defection_rate > 0.5:
                return Action.D
            else:
                return Action.C
        return Action.D

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game history."""
        stock = self.capacity
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            my_cooperate = bool(my_action)
            opponent_cooperators = np.sum(opponent_actions)
            opponent_defectors = self.n_players - 1 - opponent_cooperators
            total_cooperators = (1 if my_cooperate else 0) + opponent_cooperators
            total_defectors = (0 if my_cooperate else 1) + opponent_defectors
            cooperator_consumption = total_cooperators * (stock / (2 * self.n_players))
            defector_consumption = total_defectors * (stock / self.n_players)
            total_consumption = cooperator_consumption + defector_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

class Strategy_AGGRESSIVE_125(BaseStrategy):
    """
    Predatory Harvester: An aggressive exploitation strategy that maximizes immediate gains
    while strategically preserving the resource only when absolutely necessary for future exploitation.
    Exploits cooperative players and treats the common pool as something to be maximally extracted.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        rounds_remaining = self.n_rounds - current_round + 1
        current_stock = self._estimate_current_stock(history)
        if rounds_remaining <= 1:
            return Action.D
        stock_threshold = self._calculate_stock_threshold(rounds_remaining)
        if current_stock >= stock_threshold:
            return Action.D
        else:
            return self._evaluate_conservation_conditions(history, current_stock, rounds_remaining)

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game dynamics."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0.0
            if my_action:
                total_consumption += stock / (2 * self.n_players)
            else:
                total_consumption += stock / self.n_players
            for opp_action in opponent_actions:
                if opp_action:
                    total_consumption += stock / (2 * self.n_players)
                else:
                    total_consumption += stock / self.n_players
            stock_after_consumption = max(0.0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _calculate_stock_threshold(self, rounds_remaining: int) -> float:
        """Calculate dynamic threshold for exploitation vs conservation."""
        base_threshold = self.capacity * 0.4
        time_factor = rounds_remaining / self.n_rounds * self.capacity * 0.3
        return base_threshold + time_factor

    def _evaluate_conservation_conditions(self, history: PlayerHistory, current_stock: float, rounds_remaining: int) -> Action:
        """Evaluate whether to cooperate when stock is below threshold."""
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        cooperation_ratio = cooperators_last_round / (self.n_players - 1)
        if cooperation_ratio >= 0.5:
            return Action.D
        if current_stock < self.capacity * 0.15:
            return Action.C
        if rounds_remaining <= 2:
            return Action.D
        if rounds_remaining == 2 and current_stock >= self.capacity * 0.1:
            return Action.D
        current_round = history.round_number + 1
        if current_round <= 3 and current_stock >= self.capacity * 0.25:
            return Action.D
        if rounds_remaining <= math.ceil(self.n_rounds * 0.25):
            if current_stock >= self.capacity * 0.15:
                return Action.D
        return Action.C

class Strategy_AGGRESSIVE_126(BaseStrategy):
    """
    Aggressive Strategy: "Exploit & Intimidate"
    
    Maximizes immediate gains through defection while using psychological intimidation 
    to discourage opponent retaliation. Only cooperates when absolutely necessary to 
    prevent total resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        current_stock = self._estimate_current_stock(history)
        if current_stock <= self.n * 2:
            return Action.C
        if current_round == self.r:
            return Action.D
        if current_stock > self.capacity * 0.3:
            return Action.D
        elif current_stock <= self.capacity * 0.15:
            return Action.C
        else:
            recent_defectors = self._count_recent_defectors(history)
            opponent_defection_rate = recent_defectors / (self.n - 1) if self.n > 1 else 0
            if opponent_defection_rate >= 0.7:
                return Action.D
            else:
                return Action.D

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """Estimate current stock level based on game history."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            cooperators = int(my_action) + sum(opponent_actions)
            defectors = self.n - cooperators
            cooperator_consumption = cooperators * (stock / (2 * self.n))
            defector_consumption = defectors * (stock / self.n)
            total_consumption = cooperator_consumption + defector_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

    def _count_recent_defectors(self, history: PlayerHistory) -> int:
        """Count defectors in the last 2 rounds."""
        if history.round_number == 0:
            return 0
        total_defectors = 0
        rounds_to_check = min(2, history.round_number)
        for i in range(rounds_to_check):
            round_idx = history.round_number - 1 - i
            defectors_this_round = sum((1 for action in history.opponent_actions[round_idx] if not action))
            total_defectors += defectors_this_round
        return total_defectors

class Strategy_AGGRESSIVE_127(BaseStrategy):
    """
    Resource Predator Strategy: Aggressive exploitation with tactical preservation.
    Maximizes immediate extraction while maintaining just enough resources for continued exploitation.
    Uses adaptive thresholds based on stock levels and opponent behavior patterns.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_stock = self._calculate_current_stock(history)
        current_round = history.round_number + 1
        rounds_remaining = self.n_rounds - current_round + 1
        if rounds_remaining <= 1:
            return Action.D
        high_threshold = self.capacity * 0.4
        critical_threshold = self.capacity * 0.15
        if current_stock >= high_threshold:
            return Action.D
        if current_stock < critical_threshold:
            return Action.C
        if history.round_number > 0:
            last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
            majority_cooperated = last_round_cooperators > (self.n_players - 1) / 2
            if rounds_remaining <= 3:
                if current_stock >= self.capacity * 0.2:
                    return Action.D
                else:
                    return Action.C
            if majority_cooperated or history.round_number <= 2:
                return Action.C
            else:
                return Action.D
        return Action.D

    def _calculate_current_stock(self, history: PlayerHistory) -> float:
        """Calculate current stock level based on game history."""
        stock = float(self.capacity)
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0.0
            if my_action:
                total_consumption += stock / (2 * self.n_players)
            else:
                total_consumption += stock / self.n_players
            for opponent_action in opponent_actions:
                if opponent_action:
                    total_consumption += stock / (2 * self.n_players)
                else:
                    total_consumption += stock / self.n_players
            stock_after_consumption = max(0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            else:
                growth = 0
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

class Strategy_AGGRESSIVE_128(BaseStrategy):
    """
    Aggressive "Resource Vulture" Strategy - Exploits cooperative players through calculated 
    aggression while maintaining just enough restraint to avoid complete resource collapse 
    when beneficial. Always defects in first and last rounds, and uses cooperation only 
    strategically as investment in future exploitation opportunities.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        stock = self._calculate_current_stock(history, capacity, n)
        if current_round == r:
            return Action.D
        last_round_idx = history.round_number - 1
        prev_cooperators = sum(history.opponent_actions[last_round_idx])
        cooperation_rate = prev_cooperators / (n - 1)
        stock_ratio = stock / capacity
        if stock_ratio < 0.15:
            if cooperation_rate > 0.6:
                return Action.C
            else:
                return Action.D
        elif stock_ratio < 0.4:
            if cooperation_rate > 0.8:
                return Action.C
            else:
                return Action.D
        elif cooperation_rate > 0.7:
            return Action.D
        elif cooperation_rate < 0.3:
            return Action.C
        else:
            return Action.D

    def _calculate_current_stock(self, history: PlayerHistory, capacity: float, n: int) -> float:
        """Calculate the current stock level based on game history."""
        stock = capacity
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx]
            total_consumption = 0.0
            if my_action:
                total_consumption += stock / (2 * n)
            else:
                total_consumption += stock / n
            for opp_action in opponent_actions:
                if opp_action:
                    total_consumption += stock / (2 * n)
                else:
                    total_consumption += stock / n
            stock_after_consumption = max(0.0, stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            stock = min(stock_after_consumption + growth, capacity)
        return stock