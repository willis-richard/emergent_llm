"""
Generated LLM strategies for social dilemma games.

This file contains strategy classes generated by LLMs for game theory experiments.
Each strategy is a callable class that implements a specific approach to the game.

Generated with:
- Provider: Anthropic
- Model: claude-sonnet-4-0
- Game: CommonPoolDescription
"""

from emergent_llm.players import BaseStrategy
from emergent_llm.games import PublicGoodsDescription, CollectiveRiskDescription, CommonPoolDescription, CommonPoolState
from emergent_llm.common import Action, C, D, PlayerHistory, GameState
import numpy as np
from numpy.typing import NDArray
import math
import random



class Strategy_COOPERATIVE_1(BaseStrategy):
    """
    Adaptive Conservation Strategy (ACS) - Prioritizes long-term sustainability while being 
    forgiving to others' mistakes and adaptive to changing group dynamics. Maintains the 
    resource pool at healthy levels while being responsive to both cooperation and exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.forgiveness_counter = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        stock_ratio = state.current_stock / self.game_description.capacity
        if stock_ratio >= 0.7:
            stock_health = 'HEALTHY'
        elif stock_ratio >= 0.4:
            stock_health = 'STRESSED'
        else:
            stock_health = 'CRITICAL'
        if state.round_number == self.game_description.n_rounds - 1:
            if stock_health == 'CRITICAL':
                return Action.C
            last_round_coop_rate = np.mean(history.opponent_actions[-1, :])
            if last_round_coop_rate >= 0.5:
                return Action.C
            else:
                return Action.D
        if stock_health == 'CRITICAL':
            return Action.C
        elif stock_health == 'STRESSED':
            last_round_coop_rate = np.mean(history.opponent_actions[-1, :])
            if last_round_coop_rate >= 0.5:
                return Action.C
            else:
                return Action.D
        else:
            rounds_to_check = min(3, len(history.my_actions))
            recent_coop_rates = []
            for i in range(rounds_to_check):
                round_idx = len(history.my_actions) - 1 - i
                coop_rate = np.mean(history.opponent_actions[round_idx, :])
                recent_coop_rates.append(coop_rate)
            recent_cooperation_trend = np.mean(recent_coop_rates)
            self.forgiveness_counter += 1
            if self.forgiveness_counter % 4 == 0 and recent_cooperation_trend < 0.6 and (stock_health == 'HEALTHY'):
                return Action.C
            if recent_cooperation_trend >= 0.6:
                return Action.C
            elif recent_cooperation_trend >= 0.4:
                last_round_coop_rate = np.mean(history.opponent_actions[-1, :])
                if last_round_coop_rate >= 0.5:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D

class Strategy_COOPERATIVE_2(BaseStrategy):
    """
    Adaptive Sustainability Strategy (ASS) - Prioritizes long-term resource sustainability
    while being adaptive to opponent behaviors. Uses graduated responses based on stock
    health and recent cooperation levels with emergency conservation mode.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number
        stock = state.current_stock
        healthy_threshold = 0.7 * self.capacity
        critical_threshold = 0.3 * self.capacity
        is_healthy = stock >= healthy_threshold
        is_critical = stock < critical_threshold
        is_stressed = not is_healthy and (not is_critical)
        window_size = min(3, current_round)
        recent_rounds = history.opponent_actions[-window_size:, :]
        total_opponent_actions = recent_rounds.size
        total_cooperations = np.sum(recent_rounds)
        cooperation_rate = total_cooperations / total_opponent_actions if total_opponent_actions > 0 else 0
        if current_round == self.n_rounds - 1:
            if is_critical:
                return Action.C
            else:
                final_window = min(2, current_round)
                final_rounds = history.opponent_actions[-final_window:, :]
                final_cooperations = np.sum(final_rounds)
                final_total = final_rounds.size
                final_coop_rate = final_cooperations / final_total if final_total > 0 else 0
                if final_coop_rate >= 0.5:
                    return Action.C
                else:
                    return Action.D
        if is_critical:
            return Action.C
        elif cooperation_rate >= 0.6:
            return Action.C
        elif cooperation_rate >= 0.3:
            if is_healthy:
                return Action.C if random.random() < 0.7 else Action.D
            else:
                return Action.C if random.random() < 0.5 else Action.D
        elif is_healthy:
            return Action.D
        else:
            return Action.C if random.random() < 0.3 else Action.D

class Strategy_COOPERATIVE_3(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Steward"
    
    Prioritizes long-term resource sustainability while being adaptive to opponent behavior.
    Starts cooperative but responds proportionally to exploitation, always leaving room 
    for recovery and redemption.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.defection_rounds = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round <= 2:
            return Action.C
        if current_round >= self.n_rounds - 2:
            return self._endgame_logic(current_stock, history)
        if current_stock >= self.capacity * 0.7:
            return Action.C
        if current_stock < self.capacity * 0.2:
            return self._emergency_protocol(current_stock, history)
        cooperation_threshold = max(0.4, 1.0 - current_round / self.n_rounds * 0.3)
        recent_cooperation_rate = self._get_recent_cooperation_rate(history)
        if recent_cooperation_rate >= cooperation_threshold:
            return Action.C
        if self._is_recovery_opportunity(history):
            return Action.C
        if self._is_redemption_round(current_round):
            return Action.C
        self.defection_rounds.append(current_round)
        return Action.D

    def _endgame_logic(self, current_stock: float, history: PlayerHistory) -> Action:
        current_round = history.round_number
        if current_round == self.n_rounds - 1:
            return Action.C
        if current_stock >= self.capacity * 0.4:
            if len(history.opponent_actions) > 0:
                last_round_cooperation = np.mean(history.opponent_actions[-1, :])
                if last_round_cooperation >= 0.3:
                    return Action.C
        return Action.D

    def _emergency_protocol(self, current_stock: float, history: PlayerHistory) -> Action:
        if len(history.opponent_actions) > 0:
            last_round_cooperation = np.mean(history.opponent_actions[-1, :])
            if last_round_cooperation == 0.0:
                return Action.D
        return Action.C

    def _get_recent_cooperation_rate(self, history: PlayerHistory) -> float:
        if len(history.opponent_actions) == 0:
            return 1.0
        last_round_cooperation = np.mean(history.opponent_actions[-1, :])
        return last_round_cooperation

    def _is_recovery_opportunity(self, history: PlayerHistory) -> bool:
        if len(history.opponent_actions) < 2:
            return False
        last_round_cooperation = np.mean(history.opponent_actions[-1, :])
        return last_round_cooperation >= 0.3

    def _is_redemption_round(self, current_round: int) -> bool:
        if not self.defection_rounds:
            return False
        last_defection = self.defection_rounds[-1]
        return (current_round - last_defection) % 4 == 0

class Strategy_COOPERATIVE_4(BaseStrategy):
    """
    Sustainable Guardian: An adaptive cooperative strategy that balances long-term resource 
    sustainability with responsiveness to opponents' behavior. Uses stock health and 
    cooperation momentum to make decisions while maintaining a bias toward cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.trust_level = 0.7
        self.low_cooperation_streak = 0
        self.defensive_mode = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        n_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        round_num = state.round_number
        stock_health_score = current_stock / capacity
        if current_stock < capacity / (4 * n):
            return Action.C
        if current_stock < n * 2:
            return Action.C
        last_round_cooperators = sum(history.opponent_actions[-1, :])
        cooperation_rate = last_round_cooperators / n
        if cooperation_rate > 0.6:
            self.trust_level = min(1.0, self.trust_level + 0.1)
        elif cooperation_rate < 0.4:
            self.trust_level = max(0.0, self.trust_level - 0.15)
        if cooperation_rate < 0.3:
            self.low_cooperation_streak += 1
        else:
            self.low_cooperation_streak = 0
        if self.low_cooperation_streak >= 3:
            self.defensive_mode = True
        elif cooperation_rate > 0.6:
            self.defensive_mode = False
        if self.defensive_mode and cooperation_rate <= 0.8:
            return Action.D
        if len(history.my_actions) >= 2:
            recent_my_actions = history.my_actions[-2:]
            recent_coop_rates = []
            for i in range(-2, 0):
                if abs(i) <= len(history.opponent_actions):
                    round_cooperators = sum(history.opponent_actions[i, :])
                    recent_coop_rates.append(round_cooperators / n)
            if len(recent_coop_rates) == 2 and all(recent_my_actions) and all((rate < 0.2 for rate in recent_coop_rates)):
                return Action.D
        endgame_threshold = 0.8 * n_rounds
        in_endgame = round_num >= endgame_threshold
        if round_num == n_rounds - 1:
            if stock_health_score > 0.5 and cooperation_rate > 0.6:
                return Action.C
            else:
                return Action.D
        trust_modifier = (self.trust_level - 0.5) * 0.1
        if stock_health_score >= 0.6:
            if cooperation_rate >= 0.5 - trust_modifier:
                return Action.C
            elif cooperation_rate >= 0.3 - trust_modifier:
                return Action.C if not in_endgame else Action.D
            else:
                return Action.D
        elif stock_health_score >= 0.3:
            required_coop_rate = 0.7 - trust_modifier
            if in_endgame:
                required_coop_rate += 0.1
            if cooperation_rate >= required_coop_rate:
                return Action.C
            else:
                return Action.D
        else:
            required_coop_rate = 0.8 - trust_modifier
            if in_endgame:
                required_coop_rate += 0.1
            if cooperation_rate >= required_coop_rate:
                return Action.C
            else:
                return Action.D

class Strategy_COOPERATIVE_5(BaseStrategy):
    """
    Sustainable Guardian: An adaptive cooperative strategy that prioritizes long-term sustainability
    while maintaining cooperative intent, adapting based on observed player behavior and resource conditions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = state.round_number
        current_stock = state.current_stock
        initial_phase_length = min(3, int(0.2 * self.n_rounds))
        if current_round < initial_phase_length:
            return Action.C
        stock_health = self._assess_stock_health(current_stock)
        coop_rates = self._calculate_cooperation_rates(history)
        majority_coop_rate = np.mean(coop_rates)
        base_probability = self._get_base_cooperation_probability(stock_health, majority_coop_rate, history)
        if self._is_end_game(current_round):
            base_probability *= 0.9
        if self._check_forgiveness_conditions(history):
            base_probability = min(1.0, base_probability + 0.1)
        if self._is_volatile_environment(history):
            base_probability = min(1.0, base_probability + 0.1)
        if current_stock == 0:
            return Action.C
        return Action.C if random.random() < base_probability else Action.D

    def _assess_stock_health(self, stock):
        """Assess stock health: 'healthy', 'moderate', or 'critical'"""
        if stock >= 0.8 * self.capacity:
            return 'healthy'
        elif stock >= 0.4 * self.capacity:
            return 'moderate'
        else:
            return 'critical'

    def _calculate_cooperation_rates(self, history):
        """Calculate cooperation rate for each opponent across all rounds"""
        if len(history.opponent_actions) == 0:
            return np.ones(self.n_players - 1) * 0.5
        cooperation_rates = np.mean(history.opponent_actions, axis=0)
        return cooperation_rates

    def _get_base_cooperation_probability(self, stock_health, majority_coop_rate, history):
        """Get base cooperation probability based on stock health and cooperation rates"""
        current_round = len(history.my_actions)
        if stock_health == 'healthy':
            if majority_coop_rate >= 0.6:
                return 1.0
            elif majority_coop_rate >= 0.4:
                return 0.8
            else:
                return 0.0
        elif stock_health == 'moderate':
            if majority_coop_rate >= 0.7:
                return 1.0
            elif majority_coop_rate >= 0.5:
                return 0.7
            else:
                return 0.0
        else:
            if current_round > 0 and np.all(history.opponent_actions[-1, :]):
                return 1.0
            if current_round >= 2:
                recent_coop_rate = np.mean(history.opponent_actions[-2:, :])
                if recent_coop_rate >= 0.8:
                    return 0.6
            return 0.0

    def _is_end_game(self, current_round):
        """Check if we're in the end game (last 10% of rounds)"""
        end_game_threshold = int(0.9 * self.n_rounds)
        return current_round >= end_game_threshold

    def _check_forgiveness_conditions(self, history):
        """Check if any opponent should be forgiven based on recent cooperation"""
        if len(history.opponent_actions) < 3:
            return False
        for player_idx in range(self.n_players - 1):
            player_actions = history.opponent_actions[:, player_idx]
            for i in range(len(player_actions) - 3):
                if not player_actions[i] and player_actions[i + 1] and player_actions[i + 2] and player_actions[i + 3]:
                    return True
        return False

    def _is_volatile_environment(self, history):
        """Check if the environment is highly volatile (players switch frequently)"""
        if len(history.opponent_actions) < 4:
            return False
        switches = 0
        total_opportunities = 0
        for player_idx in range(self.n_players - 1):
            player_actions = history.opponent_actions[:, player_idx]
            recent_actions = player_actions[-4:]
            for i in range(1, len(recent_actions)):
                if recent_actions[i] != recent_actions[i - 1]:
                    switches += 1
                total_opportunities += 1
        if total_opportunities > 0:
            switch_rate = switches / total_opportunities
            return switch_rate > 0.5
        return False

class Strategy_COOPERATIVE_6(BaseStrategy):
    """
    Adaptive Trust-Based Cooperative Strategy that prioritizes long-term resource 
    sustainability while maintaining cooperative intentions, adapting trust levels 
    based on observed behavior patterns.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.base_trust = 0.7
        self.minimum_viability = 0.15

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            if self.game_description.n_players <= 6:
                return Action.C
            else:
                stock_health = state.current_stock / self.game_description.capacity
                return Action.C if stock_health > 0.8 else Action.D
        stock_health = state.current_stock / self.game_description.capacity
        rounds_remaining = self.game_description.n_rounds - state.round_number
        if rounds_remaining == 1:
            return Action.C if stock_health > 0.4 else Action.D
        if stock_health < self.minimum_viability:
            recent_coop_rate = self._calculate_recent_cooperation_rate(history, 1)
            return Action.C if recent_coop_rate > 0.75 else Action.D
        trust_score = self._calculate_trust_score(history)
        coop_threshold = self._calculate_cooperation_threshold(state.round_number, stock_health)
        if trust_score >= coop_threshold and stock_health >= self.minimum_viability:
            return Action.C
        else:
            return Action.D

    def _calculate_trust_score(self, history: PlayerHistory) -> float:
        """Calculate trust score based on recent cooperation and defection patterns."""
        if history.round_number == 0:
            return self.base_trust
        recent_rounds = min(3, history.round_number)
        recent_actions = history.opponent_actions[-recent_rounds:, :]
        recent_coop_rate = np.mean(recent_actions) if recent_actions.size > 0 else 0.5
        recent_cooperation_bonus = (recent_coop_rate - 0.5) * 0.4
        defection_streak = self._calculate_defection_streak(history)
        betrayal_penalty = max(0, defection_streak * 0.2)
        trust_score = self.base_trust + recent_cooperation_bonus - betrayal_penalty
        return max(0, min(1, trust_score))

    def _calculate_defection_streak(self, history: PlayerHistory) -> int:
        """Calculate the current streak of rounds with majority defection."""
        streak = 0
        for round_idx in range(history.round_number - 1, -1, -1):
            defection_rate = 1 - np.mean(history.opponent_actions[round_idx, :])
            if defection_rate > 0.5:
                streak += 1
            else:
                break
        return streak

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory, rounds: int) -> float:
        """Calculate cooperation rate for the last N rounds."""
        if history.round_number == 0:
            return 0.5
        recent_rounds = min(rounds, history.round_number)
        recent_actions = history.opponent_actions[-recent_rounds:, :]
        return np.mean(recent_actions) if recent_actions.size > 0 else 0.5

    def _calculate_cooperation_threshold(self, round_number: int, stock_health: float) -> float:
        """Calculate dynamic cooperation threshold based on game phase and stock health."""
        total_rounds = self.game_description.n_rounds
        game_progress = round_number / total_rounds
        if game_progress <= 0.25:
            base_threshold = 0.5
        elif game_progress <= 0.75:
            base_threshold = 0.6
        else:
            base_threshold = 0.7
            if stock_health > 0.5:
                base_threshold -= stock_health - 0.5
        rounds_remaining = total_rounds - round_number
        time_adjustment = 0.3 * (rounds_remaining / total_rounds)
        final_threshold = base_threshold - time_adjustment
        return max(0.2, min(0.9, final_threshold))

class Strategy_COOPERATIVE_7(BaseStrategy):
    """
    Sustainable Guardian: An adaptive cooperative strategy that prioritizes long-term 
    resource sustainability while adapting to opponent behavior. Begins with cooperation,
    uses Stock Health Index and Cooperation Ratio for decisions, and implements crisis 
    management to prevent resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_num = state.round_number + 1
        stock = state.current_stock
        SHI = stock / self.capacity
        initial_rounds = max(3, int(self.total_rounds * 0.3))
        if round_num <= initial_rounds:
            if round_num > 1 and stock < self.n:
                return self._use_adaptive_logic(SHI, history)
            return Action.C
        if SHI < 0.3:
            return Action.C
        if round_num > self.total_rounds * 0.8 and SHI < 0.6:
            return Action.C
        return self._use_adaptive_logic(SHI, history)

    def _use_adaptive_logic(self, SHI: float, history: PlayerHistory) -> Action:
        CR = self._calculate_cooperation_ratio(history)
        if SHI >= 0.7 and CR >= 0.5 or (SHI >= 0.5 and CR >= 0.7):
            return Action.C
        elif CR < 0.3 and SHI >= 0.4:
            return Action.D
        else:
            return Action.C

    def _calculate_cooperation_ratio(self, history: PlayerHistory) -> float:
        rounds_completed = history.round_number
        if rounds_completed == 0:
            return 1.0
        rounds_to_check = min(2, rounds_completed)
        start_round = rounds_completed - rounds_to_check
        total_c_plays = 0
        total_possible_plays = 0
        for i in range(start_round, rounds_completed):
            if history.my_actions[i]:
                total_c_plays += 1
            total_possible_plays += 1
        for i in range(start_round, rounds_completed):
            for j in range(self.n - 1):
                if history.opponent_actions[i, j]:
                    total_c_plays += 1
                total_possible_plays += 1
        if total_possible_plays == 0:
            return 1.0
        return total_c_plays / total_possible_plays

class Strategy_COOPERATIVE_8(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Steward"
    
    Prioritizes long-term sustainability while being adaptive to opponent behavior.
    Starts cooperatively but adjusts based on observed patterns, maintaining
    a bias toward cooperation when the resource can sustain it.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round = state.round_number
        stock = state.current_stock
        stock_health = self._assess_stock_health(stock, capacity)
        recent_coop_rate = self._calculate_recent_cooperation_rate(history, n)
        overall_coop_rate = self._calculate_overall_cooperation_rate(history, n)
        if stock_health == 'Critical':
            if recent_coop_rate >= 0.3 or overall_coop_rate >= 0.4:
                return Action.C
            else:
                if current_round == r:
                    return Action.D
                return Action.D
        if stock_health == 'Healthy':
            if recent_coop_rate >= 0.4:
                return Action.C
            elif overall_coop_rate >= 0.5:
                return Action.C
            elif current_round % 3 == 0:
                return Action.C
            else:
                return Action.D
        if stock_health == 'Stressed':
            if recent_coop_rate >= 0.5:
                return Action.C
            elif recent_coop_rate >= 0.3 and overall_coop_rate >= 0.4:
                return Action.C
            elif self._majority_cooperated_last_round(history, n):
                return Action.C
            else:
                return Action.D
        return Action.C

    def _assess_stock_health(self, stock, capacity):
        """Categorize stock level as Healthy, Stressed, or Critical"""
        if stock >= 0.7 * capacity:
            return 'Healthy'
        elif stock >= 0.3 * capacity:
            return 'Stressed'
        else:
            return 'Critical'

    def _calculate_recent_cooperation_rate(self, history, n):
        """Calculate cooperation rate over last 3 rounds"""
        if history.round_number == 0:
            return 1.0
        lookback = min(3, history.round_number)
        recent_rounds = history.opponent_actions[-lookback:, :]
        total_actions = recent_rounds.size
        if total_actions == 0:
            return 1.0
        total_cooperations = np.sum(recent_rounds)
        return total_cooperations / total_actions

    def _calculate_overall_cooperation_rate(self, history, n):
        """Calculate overall cooperation rate from all rounds"""
        if history.round_number == 0:
            return 1.0
        total_actions = history.opponent_actions.size
        if total_actions == 0:
            return 1.0
        total_cooperations = np.sum(history.opponent_actions)
        return total_cooperations / total_actions

    def _majority_cooperated_last_round(self, history, n):
        """Check if majority of opponents cooperated in the last round"""
        if history.round_number == 0:
            return True
        last_round_actions = history.opponent_actions[-1, :]
        cooperators = np.sum(last_round_actions)
        return cooperators > (n - 1) / 2

class Strategy_COOPERATIVE_9(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Steward"
    
    Balances cooperation with self-protection through adaptive punishment and forgiveness.
    Evaluates stock health and opponent cooperation levels to make decisions that maximize
    long-term collective welfare while being robust against exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = state.round_number
        current_stock = state.current_stock
        stock_health = self._assess_stock_health(current_stock)
        avg_cooperation = self._calculate_avg_cooperation(history)
        if current_round == self.n_rounds - 1:
            if avg_cooperation > 0.6:
                return Action.C
            else:
                return Action.D
        if stock_health == 'Critical':
            if avg_cooperation < 0.3:
                return Action.D
            else:
                return Action.C
        elif stock_health == 'Stressed':
            if avg_cooperation < 0.5:
                return Action.D if random.random() < 0.7 else Action.C
            else:
                return Action.C
        elif avg_cooperation < 0.4:
            return Action.D if random.random() < 0.6 else Action.C
        elif avg_cooperation > 0.7:
            return Action.C
        else:
            return Action.C if random.random() < 0.8 else Action.D

    def _assess_stock_health(self, current_stock: float) -> str:
        """Assess the health of the current stock level."""
        if current_stock >= 0.7 * self.capacity:
            return 'Healthy'
        elif current_stock >= 0.3 * self.capacity:
            return 'Stressed'
        else:
            return 'Critical'

    def _calculate_avg_cooperation(self, history: PlayerHistory) -> float:
        """Calculate the average cooperation score of all opponents."""
        current_round = history.round_number
        n_opponents = self.n_players - 1
        if n_opponents == 0:
            return 1.0
        cooperation_scores = []
        for opponent_idx in range(n_opponents):
            lookback_rounds = min(current_round, 5)
            if lookback_rounds == 0:
                cooperation_scores.append(1.0)
                continue
            recent_actions = history.opponent_actions[-lookback_rounds:, opponent_idx]
            weights = np.array([i + 1 for i in range(lookback_rounds)])
            weights = weights / np.sum(weights)
            cooperation_values = recent_actions.astype(float)
            cooperation_score = np.sum(cooperation_values * weights)
            cooperation_scores.append(cooperation_score)
        return np.mean(cooperation_scores)

class Strategy_COOPERATIVE_10(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Guardian"
    
    Prioritizes long-term sustainability while being forgiving to occasional defections
    and adaptive to different opponent behaviors. Uses stock health assessment and
    cooperation thresholds to make decisions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            stock_health = self._assess_stock_health(state.current_stock)
            if stock_health == 'Critical':
                return Action.C
            else:
                return Action.D
        stock_health = self._assess_stock_health(state.current_stock)
        cooperation_incentive = self._calculate_cooperation_incentive(history)
        if stock_health == 'Critical':
            return Action.C
        elif stock_health == 'Moderate':
            if cooperation_incentive >= 0.5:
                return Action.C
            else:
                return Action.D
        elif cooperation_incentive >= 0.3:
            return Action.C
        elif cooperation_incentive >= 0.1:
            return Action.C if random.random() < 0.7 else Action.D
        else:
            return Action.D

    def _assess_stock_health(self, current_stock: float) -> str:
        """Assess the current stock health level."""
        capacity = self.game_description.capacity
        if current_stock >= 0.7 * capacity:
            return 'Healthy'
        elif current_stock >= 0.4 * capacity:
            return 'Moderate'
        else:
            return 'Critical'

    def _calculate_cooperation_incentive(self, history: PlayerHistory) -> float:
        """Calculate cooperation incentive based on recent opponent behavior."""
        n_players = self.game_description.n_players
        current_round = history.round_number
        window_size = min(5, current_round)
        if window_size == 0:
            return 1.0
        recent_actions = history.opponent_actions[-window_size:, :]
        cooperative_opponents = 0
        for opponent_idx in range(n_players - 1):
            opponent_recent_actions = recent_actions[:, opponent_idx]
            cooperation_rate = np.mean(opponent_recent_actions)
            if cooperation_rate >= 0.6:
                cooperative_opponents += 1
        return cooperative_opponents / (n_players - 1)

class Strategy_COOPERATIVE_11(BaseStrategy):
    """
    Sustainable Guardian - Adaptive Cooperative Strategy
    
    Prioritizes long-term sustainability while adapting to opponent behavior.
    Maintains minimum cooperation rate even in hostile environments and
    implements emergency protocols for critical stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if current_stock < self.capacity * 0.2:
            if current_stock < self.n_players:
                return Action.D
            else:
                return Action.C
        if history is None:
            return Action.C
        recent_coop_rate = self._calculate_recent_cooperation_rate(history)
        if recent_coop_rate > 0.7:
            base_cooperation_prob = 0.9
        elif recent_coop_rate > 0.3:
            base_cooperation_prob = recent_coop_rate
        else:
            base_cooperation_prob = 0.25
        stock_ratio = current_stock / self.capacity
        stock_adjustment = 0
        if stock_ratio > 0.8:
            stock_adjustment = 0.1
        elif stock_ratio < 0.4:
            stock_adjustment = -0.2
        final_coop_prob = max(0.25, min(0.95, base_cooperation_prob + stock_adjustment))
        if random.random() < final_coop_prob:
            return Action.C
        else:
            return Action.D

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate cooperation rate over the last 3 rounds (or all available rounds)."""
        if len(history.my_actions) == 0:
            return 1.0
        rounds_to_check = min(3, len(history.my_actions))
        recent_rounds = slice(-rounds_to_check, None)
        my_recent_cooperations = np.sum(history.my_actions[recent_rounds])
        opponent_recent_cooperations = np.sum(history.opponent_actions[recent_rounds, :])
        total_cooperations = my_recent_cooperations + opponent_recent_cooperations
        total_actions = rounds_to_check * self.n_players
        return total_cooperations / total_actions if total_actions > 0 else 1.0

class Strategy_COOPERATIVE_12(BaseStrategy):
    """
    Sustainable Guardian: An adaptive cooperative strategy that balances long-term resource 
    sustainability with strategic responses to opponent behavior. Maintains cooperation when 
    possible but can punish exploitation and protect against resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_rounds_remaining = 0
        self.in_punishment = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        current_round = state.round_number
        stock = state.current_stock
        final_round = self.game_description.n_rounds - 1
        stock_health = self._classify_stock_health(stock, capacity)
        opponent_types = self._analyze_opponents(history)
        last_round_defection_rate = self._calculate_last_round_defection_rate(history)
        if stock_health == 'critical' and last_round_defection_rate > 0.5:
            return Action.D
        if stock_health == 'healthy' and self._majority_cooperated_last_round(history):
            return Action.C
        exploitative_majority = sum((1 for t in opponent_types if t == 'exploitative')) >= len(opponent_types) * 0.5
        if exploitative_majority and stock_health != 'healthy':
            if not self.in_punishment:
                self.in_punishment = True
                self.punishment_rounds_remaining = 2
                return Action.D
            elif self.punishment_rounds_remaining > 0:
                self.punishment_rounds_remaining -= 1
                if self.punishment_rounds_remaining == 0:
                    self.in_punishment = False
                return Action.D
        if self.in_punishment and self._stock_improved_significantly(history, stock, capacity):
            self.in_punishment = False
            self.punishment_rounds_remaining = 0
            return Action.C
        if current_round == final_round:
            return self._handle_final_round(stock_health, history)
        if stock < 0.1 * capacity:
            return Action.D
        if self._majority_cooperated_last_round(history):
            return Action.C
        else:
            return Action.D

    def _classify_stock_health(self, stock: float, capacity: float) -> str:
        """Classify stock into healthy, stressed, or critical."""
        if stock >= 0.7 * capacity:
            return 'healthy'
        elif stock >= 0.3 * capacity:
            return 'stressed'
        else:
            return 'critical'

    def _analyze_opponents(self, history: PlayerHistory) -> list:
        """Analyze each opponent's cooperation rate over last 3 rounds."""
        opponent_types = []
        n_opponents = history.opponent_actions.shape[1]
        rounds_to_check = min(3, history.round_number)
        for opponent_idx in range(n_opponents):
            if rounds_to_check == 0:
                opponent_types.append('mixed')
                continue
            recent_actions = history.opponent_actions[-rounds_to_check:, opponent_idx]
            coop_rate = np.mean(recent_actions)
            if coop_rate >= 0.67:
                opponent_types.append('cooperative')
            elif coop_rate <= 0.33:
                opponent_types.append('exploitative')
            else:
                opponent_types.append('mixed')
        return opponent_types

    def _calculate_last_round_defection_rate(self, history: PlayerHistory) -> float:
        """Calculate what fraction of opponents defected in the last round."""
        if history.round_number == 0:
            return 0.0
        last_round_actions = history.opponent_actions[-1, :]
        defection_rate = 1.0 - np.mean(last_round_actions)
        return defection_rate

    def _majority_cooperated_last_round(self, history: PlayerHistory) -> bool:
        """Check if majority of opponents cooperated in the last round."""
        if history.round_number == 0:
            return True
        last_round_actions = history.opponent_actions[-1, :]
        coop_rate = np.mean(last_round_actions)
        return coop_rate >= 0.5

    def _stock_improved_significantly(self, history: PlayerHistory, current_stock: float, capacity: float) -> bool:
        """Check if stock improved by at least 10% in the last round."""
        if history.round_number < 2:
            return False
        return False

    def _handle_final_round(self, stock_health: str, history: PlayerHistory) -> Action:
        """Special logic for the final round."""
        if stock_health == 'critical':
            return Action.D
        elif stock_health == 'healthy':
            return Action.C
        elif self._majority_cooperated_last_round(history):
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_13(BaseStrategy):
    """
    Adaptive Threshold Cooperation Strategy (ATCS)
    
    Balances long-term sustainability with adaptive responsiveness to opponent behavior.
    Uses dynamic cooperation threshold based on stock health and opponent behavior patterns.
    Prioritizes resource conservation while protecting against exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.6
        self.previous_stock = None
        self.consecutive_all_defect_count = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.previous_stock = state.current_stock
            return Action.C
        stock_health = self._assess_stock_health(state.current_stock)
        last_round_cooperation_rate = self._get_last_round_cooperation_rate(history)
        self._update_cooperation_threshold(state.current_stock)
        self._update_consecutive_defection_count(history)
        if self._should_respond_to_consecutive_defection(history, state.current_stock):
            return Action.D
        recovery_threshold_adjustment = self._get_recovery_bonus(state.current_stock)
        effective_threshold = max(0.2, self.cooperation_threshold + recovery_threshold_adjustment)
        if state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock > 0.5 * self.game_description.capacity:
                return Action.C
        if stock_health == 'Critical':
            if last_round_cooperation_rate < 0.5:
                return Action.D
            else:
                return Action.C
        elif stock_health == 'Healthy':
            if last_round_cooperation_rate >= effective_threshold:
                return Action.C
            elif last_round_cooperation_rate >= 0.3:
                return Action.C
            else:
                return Action.D
        elif last_round_cooperation_rate >= effective_threshold:
            return Action.C
        else:
            return Action.D

    def _assess_stock_health(self, current_stock):
        """Assess the health of the stock level."""
        capacity = self.game_description.capacity
        if current_stock >= 0.7 * capacity:
            return 'Healthy'
        elif current_stock >= 0.3 * capacity:
            return 'Moderate'
        else:
            return 'Critical'

    def _get_last_round_cooperation_rate(self, history):
        """Get the cooperation rate of opponents in the last round."""
        if len(history.opponent_actions) == 0:
            return 1.0
        last_round_actions = history.opponent_actions[-1, :]
        cooperation_count = np.sum(last_round_actions)
        total_opponents = len(last_round_actions)
        return cooperation_count / total_opponents if total_opponents > 0 else 1.0

    def _update_cooperation_threshold(self, current_stock):
        """Update cooperation threshold based on stock trajectory."""
        if self.previous_stock is not None:
            stock_change = current_stock - self.previous_stock
            if stock_change >= 0:
                self.cooperation_threshold = max(0.2, self.cooperation_threshold - 0.05)
            elif abs(stock_change) > 0.1 * self.game_description.capacity:
                self.cooperation_threshold = min(0.8, self.cooperation_threshold + 0.1)
        self.previous_stock = current_stock

    def _update_consecutive_defection_count(self, history):
        """Update count of consecutive rounds where all opponents defected."""
        if len(history.opponent_actions) == 0:
            self.consecutive_all_defect_count = 0
            return
        last_round_actions = history.opponent_actions[-1, :]
        if np.sum(last_round_actions) == 0:
            self.consecutive_all_defect_count += 1
        else:
            self.consecutive_all_defect_count = 0

    def _should_respond_to_consecutive_defection(self, history, current_stock):
        """Check if should defect due to consecutive all-defection pattern."""
        if self.consecutive_all_defect_count < 2:
            return False
        if self.previous_stock is not None and current_stock < self.previous_stock:
            return True
        return False

    def _get_recovery_bonus(self, current_stock):
        """Get temporary threshold adjustment for stock recovery."""
        if self.previous_stock is not None:
            stock_increase_rate = (current_stock - self.previous_stock) / self.previous_stock
            if stock_increase_rate > 0.2:
                return -0.1
        return 0.0

class Strategy_COOPERATIVE_14(BaseStrategy):
    """
    Adaptive Sustainability Strategy (ASS) - Prioritizes long-term resource sustainability
    while remaining adaptive to opponent behavior. Uses stock-based thresholds and
    graduated responses to balance cooperation and protection against exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.sustainability_threshold = self.capacity * 0.7
        self.critical_threshold = self.capacity * 0.3
        self.initial_coop_rounds = max(3, math.ceil(self.n_rounds * 0.15))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number
        current_stock = state.current_stock
        if current_round < self.initial_coop_rounds:
            if current_stock < self.n_players and current_round >= 1:
                return self._conditional_cooperation(current_stock, history)
            return Action.C
        return self._make_decision(current_stock, history)

    def _make_decision(self, current_stock: float, history: PlayerHistory) -> Action:
        current_round = history.round_number
        if current_stock < self.critical_threshold:
            return self._crisis_management(current_stock, history)
        elif current_stock < self.sustainability_threshold:
            return self._warning_phase(current_stock, history)
        else:
            return self._abundance_phase(current_stock, history)

    def _crisis_management(self, current_stock: float, history: PlayerHistory) -> Action:
        current_round = history.round_number
        if current_stock == 0 and current_round < self.n_rounds - 1:
            if len(history.opponent_actions) > 0:
                last_round_actions = history.opponent_actions[-1, :]
                cooperators = sum(last_round_actions)
                if cooperators > len(last_round_actions) / 2:
                    return Action.C
                else:
                    return Action.D
        return Action.C

    def _warning_phase(self, current_stock: float, history: PlayerHistory) -> Action:
        coop_ratio = self._get_cooperation_ratio(history, lookback=3)
        if coop_ratio < 0.2:
            if len(history.opponent_actions) >= 5:
                extended_ratio = self._get_cooperation_ratio(history, lookback=5)
                if extended_ratio < 0.2:
                    return Action.D
        return Action.C

    def _abundance_phase(self, current_stock: float, history: PlayerHistory) -> Action:
        current_round = history.round_number
        endgame_bonus = 0
        if current_round >= self.n_rounds * 0.8:
            endgame_bonus = 0.2
        coop_ratio = self._get_cooperation_ratio(history, lookback=3)
        if coop_ratio >= 0.6:
            return Action.C
        elif coop_ratio >= 0.4:
            prob_cooperate = 0.7 + endgame_bonus
            if random.random() < prob_cooperate:
                return Action.C
            else:
                return Action.D
        else:
            prob_cooperate = endgame_bonus
            if current_round % 5 == 0:
                prob_cooperate += 0.3
            if random.random() < prob_cooperate:
                return Action.C
            else:
                return Action.D

    def _conditional_cooperation(self, current_stock: float, history: PlayerHistory) -> Action:
        coop_ratio = self._get_cooperation_ratio(history, lookback=2)
        if coop_ratio >= 0.5:
            return Action.C
        else:
            return Action.D

    def _get_cooperation_ratio(self, history: PlayerHistory, lookback: int=3) -> float:
        """Calculate the ratio of cooperative moves by opponents over the last N rounds."""
        if len(history.opponent_actions) == 0:
            return 1.0
        start_idx = max(0, len(history.opponent_actions) - lookback)
        recent_actions = history.opponent_actions[start_idx:, :]
        if recent_actions.size == 0:
            return 1.0
        total_cooperations = np.sum(recent_actions)
        total_possible = recent_actions.size
        return total_cooperations / total_possible if total_possible > 0 else 1.0

class Strategy_COOPERATIVE_15(BaseStrategy):
    """
    Adaptive Stewardship Strategy: Balances immediate cooperation with long-term resource sustainability,
    adapting to opponent behavior while maintaining a fundamentally cooperative stance.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.has_seen_recovery = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        total_rounds = self.game_description.n_rounds
        current_round = state.round_number
        current_stock = state.current_stock
        stock_health = current_stock / capacity
        last_round_actions = history.opponent_actions[-1, :]
        recent_cooperation_rate = np.sum(last_round_actions) / n
        if stock_health < 0.15:
            return Action.D
        if stock_health > 0.7 and recent_cooperation_rate >= 0.5:
            return Action.C
        if len(history.my_actions) >= 3:
            recent_payoffs = history.my_payoffs[-3:]
            recent_my_actions = history.my_actions[-3:]
            if len(recent_payoffs) >= 2:
                if recent_payoffs[-1] > recent_payoffs[-2] and recent_my_actions[-1]:
                    self.has_seen_recovery = True
        if current_round == total_rounds - 1:
            if stock_health > 0.5:
                return Action.C
            else:
                return Action.D
        if stock_health > 0.6 and len(history.my_actions) >= 2:
            if history.my_actions[-1] == False:
                return Action.C
        if recent_cooperation_rate >= 0.6:
            return Action.C
        elif recent_cooperation_rate >= 0.3:
            cooperation_probability = 0.3 + stock_health * 0.5
            if random.random() < cooperation_probability:
                return Action.C
            else:
                return Action.D
        elif stock_health > 0.25 and self._am_willing_to_be_minority_cooperator(current_round, total_rounds):
            return Action.C
        else:
            return Action.D

    def _am_willing_to_be_minority_cooperator(self, current_round: int, total_rounds: int) -> bool:
        """Determine if willing to cooperate even when outnumbered."""
        if self.has_seen_recovery:
            return True
        if current_round < total_rounds * 0.7:
            return True
        return False

class Strategy_COOPERATIVE_16(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Guardian"
    
    Prioritizes long-term sustainability while being adaptive to opponent behavior.
    Uses stock health assessment and cooperation tracking to make informed decisions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number
        current_stock = state.current_stock
        stock_health = self._assess_stock_health(current_stock)
        cooperation_rates = self._calculate_cooperation_rates(history)
        overall_cooperation_rate = np.mean(cooperation_rates)
        is_last_round = current_round >= self.n_rounds - 1
        rounds_remaining = self.n_rounds - current_round
        if stock_health == 'Critical':
            return Action.C
        elif stock_health == 'Healthy':
            if overall_cooperation_rate >= 0.6:
                return Action.C
            elif overall_cooperation_rate >= 0.3:
                majority_cooperated_last = self._majority_cooperated_last_round(history)
                if majority_cooperated_last:
                    return Action.C
                else:
                    return Action.D if random.random() < 0.7 else Action.C
            else:
                return Action.D
        elif overall_cooperation_rate >= 0.5:
            return Action.C
        elif rounds_remaining <= 3:
            return Action.D
        else:
            return Action.C if random.random() < 0.8 else Action.D
        if is_last_round:
            return self._handle_last_round(current_stock, history)
        return Action.C

    def _assess_stock_health(self, current_stock: float) -> str:
        """Assess the health of the resource stock."""
        if current_stock >= 0.7 * self.capacity:
            return 'Healthy'
        elif current_stock >= 0.3 * self.capacity:
            return 'Stressed'
        else:
            return 'Critical'

    def _calculate_cooperation_rates(self, history: PlayerHistory) -> NDArray[np.float64]:
        """Calculate cooperation rates for each opponent using sliding window."""
        current_round = history.round_number
        window_size = min(5, current_round)
        if window_size == 0:
            return np.ones(self.n_players - 1)
        recent_actions = history.opponent_actions[-window_size:, :]
        cooperation_rates = np.mean(recent_actions, axis=0)
        return cooperation_rates

    def _majority_cooperated_last_round(self, history: PlayerHistory) -> bool:
        """Check if majority of opponents cooperated in the last round."""
        if history.round_number == 0:
            return True
        last_round_actions = history.opponent_actions[-1, :]
        cooperators = np.sum(last_round_actions)
        return cooperators > len(last_round_actions) / 2

    def _handle_last_round(self, current_stock: float, history: PlayerHistory) -> Action:
        """Special handling for the last round."""
        if current_stock >= 0.7 * self.capacity:
            return Action.C
        elif current_stock < 0.3 * self.capacity:
            return Action.C
        else:
            majority_cooperated_last = self._majority_cooperated_last_round(history)
            return Action.C if majority_cooperated_last else Action.D

class Strategy_COOPERATIVE_17(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Graduated Reciprocity with Stock Conservation"
    
    Prioritizes long-term sustainability while being forgiving enough to maintain cooperation 
    and tough enough to discourage exploitation. Adapts based on both stock health and 
    opponent behavior patterns.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = state.round_number
        stock = state.current_stock
        if stock < 0.2 * self.capacity:
            return Action.D
        if current_round == self.n_rounds - 1:
            if stock > 0.5 * self.capacity:
                return Action.C
            else:
                return Action.D
        window_size = min(5, history.round_number)
        recent_opponent_actions = history.opponent_actions[-window_size:, :]
        total_recent_actions = recent_opponent_actions.size
        total_recent_cooperations = np.sum(recent_opponent_actions)
        recent_coop_rate = total_recent_cooperations / total_recent_actions if total_recent_actions > 0 else 0.5
        exploitation_window = min(4, history.round_number)
        my_recent_actions = history.my_actions[-exploitation_window:]
        opponent_recent_actions = history.opponent_actions[-exploitation_window:, :]
        my_coop_count = np.sum(my_recent_actions)
        opponent_coop_rate = np.mean(opponent_recent_actions) if opponent_recent_actions.size > 0 else 0.5
        exploitation_score = 0
        if exploitation_window >= 3:
            exploitation_score = my_coop_count / exploitation_window - opponent_coop_rate
            exploitation_score = max(0, exploitation_score)
        stock_health = stock / self.capacity
        if stock_health > 0.7:
            cooperation_threshold = 0.3
        elif stock_health > 0.4:
            cooperation_threshold = 0.5
        else:
            cooperation_threshold = 0.8
        if recent_coop_rate >= cooperation_threshold and exploitation_score < 0.6:
            return Action.C
        if exploitation_score >= 0.6:
            return Action.D
        if self.n_rounds <= 3:
            if recent_coop_rate >= 0.4:
                return Action.C
            else:
                return Action.D
        if stock <= 0:
            return Action.C
        if stock > 0.95 * self.capacity:
            return Action.C
        if history.round_number >= 2:
            if history.round_number >= 4:
                recent_2_coop = np.mean(history.opponent_actions[-2:, :])
                previous_2_coop = np.mean(history.opponent_actions[-4:-2, :])
                trend_improving = recent_2_coop > previous_2_coop
            else:
                trend_improving = recent_coop_rate > 0.5
            if trend_improving and recent_coop_rate >= 0.4:
                return Action.C
        if self.n_players > 10:
            cooperation_threshold = 0.8
        adjusted_coop_rate = min(1.0, recent_coop_rate + 0.1)
        if recent_coop_rate < 0.3:
            return Action.D
        return Action.C if random.random() < adjusted_coop_rate else Action.D

class Strategy_COOPERATIVE_18(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Steward"
    
    This strategy aims to maximize long-term collective welfare while being robust 
    against exploitation. It operates as a sustainable steward that tries to maintain 
    the resource pool while adapting to others' behavior patterns through a weighted 
    scoring system based on stock health, opponent cooperation rates, and trends.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = state.round_number
        current_stock = state.current_stock
        rounds_remaining = self.n_rounds - current_round
        if current_stock < 0.15 * self.capacity:
            return Action.C
        if current_round <= 3 and current_stock > 0.25 * self.capacity:
            return Action.C
        if current_round == 1 and current_stock <= 0.25 * self.capacity:
            pass
        elif current_round <= 3:
            return Action.C
        score = 0
        if current_stock >= 0.75 * self.capacity:
            score += 2
        elif current_stock >= 0.5 * self.capacity:
            score += 1
        elif current_stock >= 0.25 * self.capacity:
            score += 0
        else:
            score -= 2
        rounds_to_check = min(3, len(history.my_actions))
        if rounds_to_check > 0:
            recent_opponent_actions = history.opponent_actions[-rounds_to_check:, :]
            total_actions = recent_opponent_actions.size
            total_cooperations = np.sum(recent_opponent_actions)
            coop_rate = total_cooperations / total_actions if total_actions > 0 else 0
            if coop_rate >= 0.7:
                score += 2
            elif coop_rate >= 0.4:
                score += 1
            elif coop_rate >= 0.2:
                score -= 1
            else:
                score -= 2
        if len(history.my_actions) >= 2:
            recent_payoffs = history.my_payoffs[-2:]
            if len(recent_payoffs) == 2:
                if recent_payoffs[-1] >= 0.95 * recent_payoffs[-2]:
                    score += 1
                elif recent_payoffs[-1] >= 0.85 * recent_payoffs[-2]:
                    score += 0
                else:
                    score -= 1
        if rounds_remaining <= 1:
            return Action.D
        elif rounds_remaining <= 2:
            if rounds_to_check > 0:
                recent_opponent_actions = history.opponent_actions[-min(3, len(history.my_actions)):, :]
                recent_coop_rate = np.sum(recent_opponent_actions) / recent_opponent_actions.size
                if recent_coop_rate < 0.3:
                    return Action.D
        if score >= 2:
            return Action.C
        elif score == 1:
            cooperation_prob = 0.7
        elif score == 0:
            cooperation_prob = 0.4
        else:
            return Action.D
        if rounds_remaining <= 3:
            cooperation_prob *= 0.8
        if current_round % 2 == 0:
            cooperation_prob += 0.05
        cooperation_prob = min(1.0, max(0.0, cooperation_prob))
        return Action.C if random.random() < cooperation_prob else Action.D

class Strategy_COOPERATIVE_19(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Guardian of the Commons"
    
    This strategy balances cooperation with protection against exploitation through:
    - Stock health assessment (Healthy/Stressed/Critical)
    - Opponent behavior analysis over recent rounds
    - Conditional cooperation based on environment and stock state
    - Emergency override for critical situations
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        stock_ratio = state.current_stock / self.game_description.capacity
        if stock_ratio >= 0.7:
            stock_health = 'Healthy'
        elif stock_ratio >= 0.3:
            stock_health = 'Stressed'
        else:
            stock_health = 'Critical'
        if stock_health == 'Critical':
            return Action.D
        recent_rounds = min(3, history.round_number)
        if recent_rounds > 0:
            recent_opponent_actions = history.opponent_actions[-recent_rounds:, :]
            total_opponent_cooperations = np.sum(recent_opponent_actions)
            total_opponent_actions = recent_rounds * (self.game_description.n_players - 1)
            opponent_coop_rate = total_opponent_cooperations / total_opponent_actions
        else:
            opponent_coop_rate = 0.5
        if opponent_coop_rate > 0.6:
            environment = 'Cooperative'
        elif opponent_coop_rate >= 0.3:
            environment = 'Mixed'
        else:
            environment = 'Hostile'
        if state.round_number == self.game_description.n_rounds - 1 and stock_health != 'Critical':
            return Action.C
        if stock_health == 'Healthy':
            if environment == 'Hostile':
                return Action.D
            else:
                return Action.C
        elif environment == 'Hostile':
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_20(BaseStrategy):
    """
    Adaptive Stewardship strategy that balances cooperation with sustainability.
    Maintains cooperation while adapting to opponent behavior and protecting against resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.window_size = 5
        self.recovery_bonus_active = False
        self.recovery_bonus_rounds = 0
        self.cascade_protection_active = False
        self.cascade_protection_rounds = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        stock_zone = self._get_stock_zone(state.current_stock)
        if self.cascade_protection_active:
            self.cascade_protection_rounds -= 1
            if self.cascade_protection_rounds <= 0:
                self.cascade_protection_active = False
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            if stock_zone == 'CRITICAL':
                return Action.C
            else:
                return Action.D
        overall_cooperation = self._calculate_cooperation_rate(history)
        cooperation_threshold_adjustment = 0.1 if self.recovery_bonus_active else 0.0
        if self.recovery_bonus_active:
            self.recovery_bonus_rounds -= 1
            if self.recovery_bonus_rounds <= 0:
                self.recovery_bonus_active = False
        late_game_bonus = 0.0
        if state.round_number >= 0.8 * self.game_description.n_rounds:
            late_game_bonus = 0.1
        if len(history.my_actions) > 0:
            last_round_defectors = sum(history.opponent_actions[-1, :] == False)
            total_opponents = self.game_description.n_players - 1
            if last_round_defectors > 0.75 * total_opponents and stock_zone in ['STRESSED', 'CRITICAL']:
                self.cascade_protection_active = True
                self.cascade_protection_rounds = 2
                return Action.C
        if len(history.my_actions) >= 2:
            prev_stock = self._estimate_previous_stock(history, len(history.my_actions) - 2)
            if state.current_stock > prev_stock * 1.2:
                self.recovery_bonus_active = True
                self.recovery_bonus_rounds = 1
        if stock_zone == 'CRITICAL':
            return Action.C
        elif stock_zone == 'STRESSED':
            if overall_cooperation >= 0.5:
                return Action.C
            else:
                return Action.D
        else:
            adjusted_threshold_60 = 0.6 - cooperation_threshold_adjustment - late_game_bonus
            adjusted_threshold_40 = 0.4 - cooperation_threshold_adjustment - late_game_bonus
            if overall_cooperation >= adjusted_threshold_60:
                return Action.C
            elif overall_cooperation >= adjusted_threshold_40:
                if len(history.opponent_actions) > 0:
                    last_round_cooperators = sum(history.opponent_actions[-1, :] == True)
                    total_opponents = self.game_description.n_players - 1
                    if total_opponents > 0 and last_round_cooperators / total_opponents >= 0.6:
                        return Action.C
                return Action.D
            else:
                return Action.D

    def _get_stock_zone(self, stock: float) -> str:
        """Determine stock health zone."""
        if stock >= 0.7 * self.game_description.capacity:
            return 'HEALTHY'
        elif stock >= 0.3 * self.game_description.capacity:
            return 'STRESSED'
        else:
            return 'CRITICAL'

    def _calculate_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate overall cooperation rate using sliding window."""
        if len(history.opponent_actions) == 0:
            return 1.0
        window = min(self.window_size, len(history.opponent_actions))
        recent_actions = history.opponent_actions[-window:, :]
        total_opponents = self.game_description.n_players - 1
        if total_opponents == 0:
            return 1.0
        total_decisions = window * total_opponents
        total_cooperations = np.sum(recent_actions == True)
        return total_cooperations / total_decisions if total_decisions > 0 else 1.0

    def _estimate_previous_stock(self, history: PlayerHistory, round_idx: int) -> float:
        """Estimate stock level at a previous round (simplified approximation)."""
        if round_idx < 0 or round_idx >= len(history.my_actions):
            return self.game_description.capacity
        cooperation_rate = np.mean(history.opponent_actions[round_idx, :] == True)
        my_cooperation = history.my_actions[round_idx]
        estimated_consumption_factor = 0.3 if cooperation_rate > 0.5 else 0.7
        if my_cooperation:
            estimated_consumption_factor -= 0.1
        return self.game_description.capacity * (1 - estimated_consumption_factor)

class Strategy_COOPERATIVE_21(BaseStrategy):
    """
    Guardian of the Commons: Adaptive Cooperative Strategy
    
    Prioritizes long-term sustainability while being responsive to opponent behavior.
    Uses stock health assessment, cooperation rate tracking, and graduated responses
    with probabilistic forgiveness to maintain cooperative relationships while
    protecting against exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        capacity = self.game_description.capacity
        stock_ratio = state.current_stock / capacity
        if stock_ratio >= 0.75:
            stock_health = 'Healthy'
        elif stock_ratio >= 0.4:
            stock_health = 'Stressed'
        else:
            stock_health = 'Critical'
        rounds_to_check = min(3, history.round_number)
        if rounds_to_check > 0:
            recent_opponent_actions = history.opponent_actions[-rounds_to_check:, :]
            total_opponent_actions = recent_opponent_actions.size
            cooperation_count = np.sum(recent_opponent_actions)
            cooperation_rate = cooperation_count / total_opponent_actions if total_opponent_actions > 0 else 0
        else:
            cooperation_rate = 0
        last_round_majority_cooperated = False
        if history.round_number > 0:
            last_round_cooperators = np.sum(history.opponent_actions[-1, :])
            last_round_majority_cooperated = last_round_cooperators > (self.game_description.n_players - 1) / 2
        rounds_remaining = self.game_description.n_rounds - state.round_number
        if stock_health == 'Critical':
            if cooperation_rate >= 0.6:
                return Action.C
            else:
                return Action.D
        elif stock_health == 'Stressed':
            if cooperation_rate >= 0.7:
                return Action.C
            elif cooperation_rate >= 0.4:
                if last_round_majority_cooperated:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
        elif cooperation_rate >= 0.5:
            return Action.C
        elif cooperation_rate >= 0.3:
            if rounds_remaining <= 3:
                return Action.D
            elif random.random() <= 0.7:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D
        if rounds_remaining <= 2:
            if stock_health == 'Critical':
                return Action.C
            elif stock_health == 'Healthy' and cooperation_rate < 0.4:
                return Action.D
        return Action.C

class Strategy_COOPERATIVE_22(BaseStrategy):
    """
    Sustainable Guardian: An adaptive cooperative strategy that prioritizes long-term 
    sustainability while being responsive to opponent behavior and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.critical_threshold = self.capacity * 0.3
        self.minimum_cooperation_rate = 0.4
        self.forgiveness_factor = 0.1
        self.temp_coop_rate_adjustment = 0.0
        self.emergency_mode = False
        self.emergency_rounds_left = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.n_rounds - 1:
            return self._final_round_logic(current_stock, history)
        if self.emergency_mode and self.emergency_rounds_left > 0:
            self.emergency_rounds_left -= 1
            if self.emergency_rounds_left == 0:
                self.emergency_mode = False
            return Action.C
        history_window = min(5, len(history.my_actions))
        recent_coop_rate = self._calculate_recent_cooperation_rate(history, history_window)
        self._update_adaptive_parameters(history, recent_coop_rate, current_stock)
        if self._should_enter_emergency_mode(history, recent_coop_rate):
            self.emergency_mode = True
            self.emergency_rounds_left = 2
            return Action.C
        threat_level = self._assess_threat_level(current_stock)
        adjusted_min_coop_rate = self.minimum_cooperation_rate + self.temp_coop_rate_adjustment
        if threat_level == 'HIGH':
            return Action.C if recent_coop_rate >= 0.6 else Action.D
        elif threat_level == 'MEDIUM':
            return Action.C if recent_coop_rate >= adjusted_min_coop_rate else Action.D
        else:
            threshold = adjusted_min_coop_rate - self.forgiveness_factor
            return Action.C if recent_coop_rate >= threshold else Action.D

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory, window: int) -> float:
        """Calculate cooperation rate for all players in recent history window."""
        if window == 0:
            return 1.0
        recent_my_actions = history.my_actions[-window:]
        recent_opponent_actions = history.opponent_actions[-window:, :]
        my_cooperations = sum(recent_my_actions)
        opponent_cooperations = np.sum(recent_opponent_actions)
        total_cooperations = my_cooperations + opponent_cooperations
        total_actions = window * self.n_players
        return total_cooperations / total_actions if total_actions > 0 else 1.0

    def _assess_threat_level(self, stock: float) -> str:
        """Assess the sustainability threat level based on current stock."""
        if stock <= self.critical_threshold:
            return 'HIGH'
        elif stock <= self.capacity * 0.6:
            return 'MEDIUM'
        else:
            return 'LOW'

    def _final_round_logic(self, stock: float, history: PlayerHistory) -> Action:
        """Special logic for the final round."""
        if stock <= self.critical_threshold:
            return Action.C
        history_window = min(5, len(history.my_actions))
        recent_coop_rate = self._calculate_recent_cooperation_rate(history, history_window)
        return Action.C if recent_coop_rate >= 0.5 else Action.D

    def _update_adaptive_parameters(self, history: PlayerHistory, recent_coop_rate: float, stock: float):
        """Update adaptive parameters based on game dynamics."""
        history_length = len(history.my_actions)
        if history_length >= 3:
            last_3_rounds_coop = []
            for i in range(3):
                round_idx = history_length - 1 - i
                if round_idx >= 0:
                    my_action = history.my_actions[round_idx]
                    opponent_actions = history.opponent_actions[round_idx, :]
                    round_coop_rate = (my_action + np.sum(opponent_actions)) / self.n_players
                    last_3_rounds_coop.append(round_coop_rate)
            if all((rate > 0.7 for rate in last_3_rounds_coop)):
                self.temp_coop_rate_adjustment = max(self.temp_coop_rate_adjustment - 0.1, -0.1)
        if history_length >= 2:
            critical_threshold_ratio = 0.2
            last_2_stocks = []
            if stock < self.capacity * critical_threshold_ratio:
                self.temp_coop_rate_adjustment = min(self.temp_coop_rate_adjustment + 0.1, 0.1)
        if history_length >= 2:
            last_2_rounds_coop = []
            for i in range(min(2, history_length)):
                round_idx = history_length - 1 - i
                my_action = history.my_actions[round_idx]
                opponent_actions = history.opponent_actions[round_idx, :]
                round_coop_rate = (my_action + np.sum(opponent_actions)) / self.n_players
                last_2_rounds_coop.append(round_coop_rate >= 0.8)
            if all(last_2_rounds_coop):
                self.temp_coop_rate_adjustment = 0.0

    def _should_enter_emergency_mode(self, history: PlayerHistory, recent_coop_rate: float) -> bool:
        """Check if emergency cooperation mode should be activated."""
        if self.emergency_mode:
            return False
        history_length = len(history.my_actions)
        if history_length < 3:
            return False
        low_coop_rounds = 0
        for i in range(min(3, history_length)):
            round_idx = history_length - 1 - i
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx, :]
            round_coop_rate = (my_action + np.sum(opponent_actions)) / self.n_players
            if round_coop_rate < 0.2:
                low_coop_rounds += 1
            else:
                break
        return low_coop_rounds >= 3

class Strategy_COOPERATIVE_23(BaseStrategy):
    """
    Adaptive Stewardship Strategy - prioritizes long-term sustainability while being adaptive to opponent behavior.
    Maintains resource stock above critical thresholds while rewarding cooperation and deterring excessive defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_rounds_left = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        current_round = history.round_number
        if current_stock > capacity * 0.8:
            base_coop_prob = 1.0
        elif current_stock > capacity * 0.5:
            base_coop_prob = 0.8
        elif current_stock > capacity * 0.2:
            base_coop_prob = 0.6
        else:
            base_coop_prob = 0.0
        window_size = min(3, current_round)
        if window_size > 0:
            recent_opponent_actions = history.opponent_actions[-window_size:, :]
            cooperation_rates = np.mean(recent_opponent_actions, axis=0)
            avg_cooperation_rate = np.mean(cooperation_rates)
            if avg_cooperation_rate > 0.6:
                base_coop_prob += 0.2
            elif avg_cooperation_rate < 0.3:
                base_coop_prob -= 0.3
        if current_round >= 2:
            recent_my_payoffs = history.my_payoffs[-2:]
            recent_opponent_payoffs = history.opponent_payoffs[-2:, :]
            if len(recent_my_payoffs) >= 2:
                stock_ratio = recent_my_payoffs[-1] / max(recent_my_payoffs[-2], 1e-06)
                if stock_ratio < 0.7:
                    base_coop_prob -= 0.4
                elif stock_ratio > 1.1:
                    base_coop_prob += 0.1
        if current_round == n_rounds - 1:
            if current_stock < capacity * 0.3:
                return Action.D
            else:
                return Action.C
        if current_stock < n_players * 2:
            return Action.D
        if current_round > 0:
            last_round_defectors = np.sum(history.opponent_actions[-1, :] == False)
            if last_round_defectors > 0.7 * n_players and current_stock > capacity * 0.4:
                if self.punishment_rounds_left <= 0:
                    self.punishment_rounds_left = min(2, max(1, (n_rounds - current_round) // 3))
        if self.punishment_rounds_left > 0:
            self.punishment_rounds_left -= 1
            return Action.D
        if current_round > 0:
            avg_opponent_coop_rate = np.mean(history.opponent_actions[-1, :])
            estimated_cooperators = avg_opponent_coop_rate * n_players + (1 if base_coop_prob > 0.5 else 0)
            estimated_defectors = n_players - estimated_cooperators
            estimated_consumption = estimated_cooperators * current_stock / (2 * n_players) + estimated_defectors * current_stock / n_players
            projected_stock = current_stock - estimated_consumption
            if projected_stock < capacity * 0.15:
                base_coop_prob = max(base_coop_prob, 0.8)
        if current_round > 0.8 * n_rounds and current_stock > capacity * 0.5:
            base_coop_prob += 0.3
        if hasattr(self, '_post_punishment_rounds'):
            if self._post_punishment_rounds > 0:
                base_coop_prob += 0.1 * (3 - self._post_punishment_rounds)
                self._post_punishment_rounds -= 1
        elif self.punishment_rounds_left == 0 and hasattr(self, '_was_punishing'):
            if self._was_punishing:
                self._post_punishment_rounds = 2
                self._was_punishing = False
        if self.punishment_rounds_left > 0:
            self._was_punishing = True
        final_coop_prob = max(0.0, min(1.0, base_coop_prob))
        return Action.C if random.random() < final_coop_prob else Action.D

class Strategy_COOPERATIVE_24(BaseStrategy):
    """
    Adaptive Sustainability Strategy (ASS) - Balances immediate cooperation with long-term 
    resource sustainability using adaptive thresholds based on opponent behavior and resource state.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.sustainability_threshold = game_description.capacity * 0.4
        self.trust_threshold = 0.6
        self.being_exploited_count = 0
        self.crisis_mode = False
        self.generous_mode = False
        self.defensive_mode = False
        self.memory_window = min(5, max(3, game_description.n_rounds // 4))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        if current_round == self.game_description.n_rounds - 1:
            cooperation_rate = self._calculate_cooperation_rate(history)
            if state.current_stock > capacity * 0.5:
                return Action.C
            elif cooperation_rate > 0.6:
                return Action.C
            else:
                return Action.D
        cooperation_rate = self._calculate_cooperation_rate(history)
        recent_cooperation_rate = self._calculate_recent_cooperation_rate(history)
        self._update_sustainability_threshold(cooperation_rate)
        self._update_trust_threshold(history, cooperation_rate)
        self._update_modes(state, history, cooperation_rate, recent_cooperation_rate)
        if self.crisis_mode:
            if cooperation_rate >= 0.8:
                return Action.C
            else:
                return Action.D
        if self.defensive_mode:
            if state.current_stock > capacity * 0.6:
                return Action.C
            else:
                return Action.D
        return self._make_main_decision(state, history, cooperation_rate)

    def _calculate_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate overall cooperation rate of opponents."""
        if history.opponent_actions.size == 0:
            return 1.0
        total_actions = history.opponent_actions.size
        total_cooperations = np.sum(history.opponent_actions)
        return total_cooperations / total_actions if total_actions > 0 else 1.0

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate cooperation rate in recent rounds (memory window)."""
        if history.opponent_actions.size == 0:
            return 1.0
        recent_rounds = min(self.memory_window, history.round_number)
        if recent_rounds == 0:
            return 1.0
        recent_actions = history.opponent_actions[-recent_rounds:, :]
        total_recent = recent_actions.size
        total_recent_cooperations = np.sum(recent_actions)
        return total_recent_cooperations / total_recent if total_recent > 0 else 1.0

    def _update_sustainability_threshold(self, cooperation_rate: float):
        """Adaptively update sustainability threshold."""
        if cooperation_rate > 0.7:
            self.sustainability_threshold *= 0.95
        elif cooperation_rate < 0.3:
            self.sustainability_threshold *= 1.1
        capacity = self.game_description.capacity
        self.sustainability_threshold = max(capacity * 0.15, min(capacity * 0.7, self.sustainability_threshold))

    def _update_trust_threshold(self, history: PlayerHistory, cooperation_rate: float):
        """Adaptively update trust threshold."""
        if history.round_number > 0:
            my_last_action = history.my_actions[-1]
            others_last_round_coop = np.sum(history.opponent_actions[-1, :]) / self.game_description.n_players
            was_exploited = my_last_action and others_last_round_coop < 0.3
            if was_exploited:
                self.trust_threshold += 0.1
                self.being_exploited_count += 1
            else:
                self.being_exploited_count = max(0, self.being_exploited_count - 1)
                if cooperation_rate > self.trust_threshold:
                    self.trust_threshold -= 0.05
        self.trust_threshold = max(0.2, min(0.9, self.trust_threshold))

    def _update_modes(self, state: CommonPoolState, history: PlayerHistory, cooperation_rate: float, recent_cooperation_rate: float):
        """Update special operating modes."""
        capacity = self.game_description.capacity
        self.crisis_mode = state.current_stock < capacity * 0.2
        if cooperation_rate >= 0.8 and history.round_number >= 3 and (recent_cooperation_rate >= 0.8):
            self.generous_mode = True
            self.sustainability_threshold = min(self.sustainability_threshold, capacity * 0.25)
            self.trust_threshold = min(self.trust_threshold, 0.4)
        else:
            self.generous_mode = False
        recent_defection_rate = 1.0 - recent_cooperation_rate
        if recent_defection_rate > 0.7 and history.round_number >= 3:
            self.defensive_mode = True
        elif cooperation_rate > 0.5:
            self.defensive_mode = False

    def _make_main_decision(self, state: CommonPoolState, history: PlayerHistory, cooperation_rate: float) -> Action:
        """Main decision logic using the three-check framework."""
        if state.current_stock < self.sustainability_threshold:
            if random.random() < 0.2:
                return Action.C
            return Action.D
        if cooperation_rate < self.trust_threshold:
            if random.random() < 0.2:
                return Action.C
            return Action.D
        if self.being_exploited_count >= 2:
            if random.random() < 0.3:
                return Action.C
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_25(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Steward"
    
    Balances cooperation with strategic adaptation, prioritizing resource sustainability
    over short-term gains while being robust to various opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.consecutive_defections = 0
        self.emergency_cooperation_rounds = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.consecutive_defections = 0
            self.emergency_cooperation_rounds = 0
            return Action.C
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round = state.round_number
        stock = state.current_stock
        shr = stock / capacity
        if stock < capacity * 0.2:
            self.emergency_cooperation_rounds = 2
        if self.emergency_cooperation_rounds > 0:
            self.emergency_cooperation_rounds -= 1
            self.consecutive_defections = 0
            return Action.C
        if stock < capacity * 0.3:
            self.consecutive_defections = 0
            return Action.C
        if shr >= 0.8:
            self.consecutive_defections = 0
            return Action.C
        recent_rounds = min(3, current_round)
        if recent_rounds == 0:
            recent_coop_rate = 1.0
        else:
            recent_cooperations = 0
            total_actions = 0
            for i in range(max(0, current_round - recent_rounds), current_round):
                if history.my_actions[i]:
                    recent_cooperations += 1
                total_actions += 1
                for j in range(n - 1):
                    if history.opponent_actions[i, j]:
                        recent_cooperations += 1
                    total_actions += 1
            recent_coop_rate = recent_cooperations / total_actions if total_actions > 0 else 1.0
        if current_round > r * 0.8:
            if stock >= capacity * 0.5:
                self.consecutive_defections = 0
                return Action.C
            elif recent_coop_rate >= 0.5:
                self.consecutive_defections = 0
                return Action.C
            else:
                self.consecutive_defections += 1
                return Action.D
        if recent_coop_rate >= 0.6:
            self.consecutive_defections = 0
            return Action.C
        elif recent_coop_rate >= 0.4:
            if current_round > 0:
                last_round_cooperations = 0
                last_round_total = n
                if history.my_actions[current_round - 1]:
                    last_round_cooperations += 1
                for j in range(n - 1):
                    if history.opponent_actions[current_round - 1, j]:
                        last_round_cooperations += 1
                if last_round_cooperations >= n / 2:
                    self.consecutive_defections = 0
                    return Action.C
                else:
                    if self.consecutive_defections >= 2:
                        self.consecutive_defections = 0
                        return Action.C
                    if last_round_cooperations > n / 2:
                        self.consecutive_defections = 0
                        return Action.C
                    self.consecutive_defections += 1
                    return Action.D
            else:
                self.consecutive_defections = 0
                return Action.C
        else:
            if current_round > 0:
                last_round_cooperations = 0
                if history.my_actions[current_round - 1]:
                    last_round_cooperations += 1
                for j in range(n - 1):
                    if history.opponent_actions[current_round - 1, j]:
                        last_round_cooperations += 1
                if last_round_cooperations == 1 and history.my_actions[current_round - 1]:
                    if current_round > 1:
                        prev_round_others_cooperations = sum(history.opponent_actions[current_round - 1, :])
                        if prev_round_others_cooperations == 0:
                            if stock <= capacity * 0.4:
                                self.consecutive_defections = 0
                                return Action.C
            if self.consecutive_defections >= 2:
                self.consecutive_defections = 0
                return Action.C
            if current_round > 0:
                last_round_coop_rate = 0
                last_round_total = n
                if history.my_actions[current_round - 1]:
                    last_round_coop_rate += 1
                last_round_coop_rate += sum(history.opponent_actions[current_round - 1, :])
                if last_round_coop_rate / last_round_total > 0.5:
                    self.consecutive_defections = 0
                    return Action.C
            self.consecutive_defections += 1
            return Action.D

class Strategy_COOPERATIVE_26(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Steward"
    
    Balances cooperation with strategic punishment to encourage sustainable resource management.
    Starts cooperative, adapts based on stock health and opponent behavior patterns.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.punishment_count = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number
        current_stock = state.current_stock
        stock_health = self._assess_stock_health(current_stock)
        if current_round == self.n_rounds - 1:
            if stock_health == 'Critical':
                return Action.C
            else:
                return Action.D
        if current_stock < 0.1 * self.capacity:
            return Action.C
        cooperation_rates = self._calculate_cooperation_rates(history)
        high_cooperators = sum((1 for rate in cooperation_rates if rate >= 0.67))
        mixed_players = sum((1 for rate in cooperation_rates if 0.33 < rate < 0.67))
        defectors = sum((1 for rate in cooperation_rates if rate <= 0.33))
        last_round_cooperators = sum(history.opponent_actions[-1, :])
        majority_cooperated_last_round = last_round_cooperators >= (self.n_players - 1) / 2
        was_exploited = self._was_exploited_last_round(history)
        if stock_health == 'Critical':
            if majority_cooperated_last_round:
                self.punishment_count = 0
                return Action.C
            else:
                return Action.D
        elif stock_health == 'Stressed':
            if high_cooperators + mixed_players >= (self.n_players - 1) / 2:
                self.punishment_count = 0
                return Action.C
            else:
                return Action.D
        elif defectors >= (self.n_players - 1) / 2:
            self.punishment_count += 1
            return Action.D
        elif was_exploited and high_cooperators < self.n_players - 2:
            self.punishment_count += 1
            return Action.D
        else:
            if self.punishment_count >= 2:
                if self._cooperation_improved(history):
                    self.punishment_count = 0
                    return Action.C
            if self.punishment_count == 0:
                return Action.C
            else:
                self.punishment_count += 1
                return Action.D

    def _assess_stock_health(self, stock):
        """Categorize stock health based on capacity thresholds."""
        if stock >= 0.7 * self.capacity:
            return 'Healthy'
        elif stock >= 0.3 * self.capacity:
            return 'Stressed'
        else:
            return 'Critical'

    def _calculate_cooperation_rates(self, history):
        """Calculate cooperation rates for each opponent over recent rounds."""
        current_round = history.round_number
        look_back = min(3, current_round)
        cooperation_rates = []
        for player_idx in range(self.n_players - 1):
            if look_back == 0:
                cooperation_rates.append(1.0)
            else:
                recent_actions = history.opponent_actions[-look_back:, player_idx]
                cooperation_rate = np.mean(recent_actions)
                cooperation_rates.append(cooperation_rate)
        return cooperation_rates

    def _was_exploited_last_round(self, history):
        """Check if player was exploited in the previous round."""
        if history.round_number < 2:
            return False
        i_cooperated = history.my_actions[-1]
        opponent_defectors = sum(1 - history.opponent_actions[-1, :])
        majority_defected = opponent_defectors >= (self.n_players - 1) / 2
        if history.round_number >= 2:
            recent_payoff = history.my_payoffs[-1]
            previous_payoff = history.my_payoffs[-2]
            stock_declined = recent_payoff < previous_payoff * 0.9
        else:
            stock_declined = True
        return i_cooperated and majority_defected and stock_declined

    def _cooperation_improved(self, history):
        """Check if overall cooperation rates have improved recently."""
        if history.round_number < 4:
            return False
        recent_coop = np.mean(history.opponent_actions[-2:, :])
        earlier_coop = np.mean(history.opponent_actions[-4:-2, :])
        return recent_coop > earlier_coop + 0.2

class Strategy_COOPERATIVE_27(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Guardian"
    
    Prioritizes long-term sustainability while adapting to opponent behavior.
    Starts cooperatively but becomes increasingly protective when facing 
    destructive opponents. Uses cooperation threshold system that adjusts
    based on opponent behavior and resource state.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.base_threshold = 0.7
        self.cooperation_threshold = 0.7
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = state.round_number
        stock_ratio = state.current_stock / self.capacity
        if stock_ratio < 0.3:
            return Action.C
        if current_round == self.n_rounds - 1:
            if stock_ratio > 0.5:
                return Action.D
            else:
                return Action.C
        cooperation_score = self._calculate_cooperation_score(history, state)
        resource_health = stock_ratio
        adjusted_threshold = self.base_threshold * (0.5 + 0.5 * resource_health)
        self._update_cooperation_threshold(history, state)
        if cooperation_score > adjusted_threshold:
            return Action.C
        else:
            return Action.D

    def _calculate_cooperation_score(self, history: PlayerHistory, state: CommonPoolState) -> float:
        """Calculate weighted cooperation score from multiple factors."""
        recent_rounds = min(3, len(history.opponent_actions))
        if recent_rounds > 0:
            recent_actions = history.opponent_actions[-recent_rounds:]
            recent_coop_rate = np.mean(recent_actions)
        else:
            recent_coop_rate = 0.5
        stock_growth_trend = self._calculate_stock_trend(history, state)
        resource_sustainability = min(1.0, stock_growth_trend + 0.5)
        reciprocity_reward = self._calculate_reciprocity_reward(history)
        remaining_rounds = self.n_rounds - state.round_number
        future_rounds_factor = remaining_rounds / self.n_rounds
        cooperation_score = recent_coop_rate * 0.4 + resource_sustainability * 0.3 + reciprocity_reward * 0.2 + future_rounds_factor * 0.1
        return cooperation_score

    def _calculate_stock_trend(self, history: PlayerHistory, state: CommonPoolState) -> float:
        """Calculate recent stock growth trend."""
        if len(history.my_payoffs) < 2:
            return 0.0
        recent_rounds = min(3, len(history.my_payoffs))
        stock_estimates = []
        for i in range(-recent_rounds, 0):
            if history.my_actions[i]:
                estimated_stock = history.my_payoffs[i] * 2 * self.n_players
            else:
                estimated_stock = history.my_payoffs[i] * self.n_players
            stock_estimates.append(estimated_stock)
        if len(stock_estimates) > 1:
            trend = (stock_estimates[-1] - stock_estimates[0]) / len(stock_estimates)
            return trend / self.capacity
        return 0.0

    def _calculate_reciprocity_reward(self, history: PlayerHistory) -> float:
        """Calculate reward for reciprocal cooperation."""
        if len(history.my_actions) < 1:
            return 0.5
        if history.my_actions[-1]:
            opponent_coop_rate = np.mean(history.opponent_actions[-1])
            return opponent_coop_rate
        else:
            return 0.5

    def _update_cooperation_threshold(self, history: PlayerHistory, state: CommonPoolState):
        """Update cooperation threshold based on recent outcomes."""
        if len(history.my_actions) < 2:
            return
        if history.my_actions[-1] and len(history.my_payoffs) >= 2:
            if history.my_payoffs[-1] > history.my_payoffs[-2] * 0.95:
                self.cooperation_threshold = min(0.9, self.cooperation_threshold + 0.05)
        if len(history.opponent_actions) > 0:
            recent_defection_rate = 1.0 - np.mean(history.opponent_actions[-1])
            if recent_defection_rate > 0.6:
                self.cooperation_threshold = max(0.2, self.cooperation_threshold - 0.1)
        if len(history.my_actions) >= 3:
            recent_my_coop = np.mean(history.my_actions[-3:])
            recent_opp_coop = np.mean(history.opponent_actions[-3:])
            if recent_my_coop > 0.7 and recent_opp_coop < 0.3:
                self.cooperation_threshold = max(0.2, self.cooperation_threshold - 0.05)

    def _count_recent_cooperators(self, history: PlayerHistory, rounds_back: int=3) -> float:
        """Count cooperation rate in recent rounds."""
        recent_rounds = min(rounds_back, len(history.opponent_actions))
        if recent_rounds == 0:
            return 0.5
        recent_actions = history.opponent_actions[-recent_rounds:]
        return np.mean(recent_actions)

class Strategy_COOPERATIVE_28(BaseStrategy):
    """
    Adaptive Cooperative Resource Management (ACRM) Strategy.
    
    Prioritizes long-term sustainability while being adaptive to opponent behavior.
    Starts cooperative but can temporarily defect to maintain resource viability
    when facing too many defectors, always seeking to return to cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_bias = 0.0
        self.punishment_timer = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round = state.round_number
        stock = state.current_stock
        if stock < capacity * 0.15:
            return Action.D
        cooperators_last = sum(history.opponent_actions[-1, :])
        if history.my_actions[-1]:
            cooperators_last += 1
        coop_rate_last = cooperators_last / (n + 1)
        defectors_last = n + 1 - cooperators_last
        momentum = min(0.3, max(-0.3, (cooperators_last - defectors_last) / (n + 1)))
        sustainability_index = stock / capacity * (1 + momentum)
        base_threshold = 0.4
        urgency_bonus = (total_rounds - current_round) / total_rounds * 0.2
        if coop_rate_last >= 0.6:
            self.cooperation_bias = min(0.2, self.cooperation_bias + 0.1)
        elif coop_rate_last <= 0.3:
            self.cooperation_bias = max(-0.2, self.cooperation_bias - 0.1)
        self.cooperation_bias *= 0.8
        early_game_bonus = 0.1 if current_round <= 3 else 0.0
        threshold = base_threshold + urgency_bonus + self.cooperation_bias - early_game_bonus
        if len(history.opponent_actions) >= 2:
            defection_rates = []
            for i in range(2):
                round_idx = -1 - i
                round_cooperators = sum(history.opponent_actions[round_idx, :])
                if history.my_actions[round_idx]:
                    round_cooperators += 1
                defection_rate = 1 - round_cooperators / (n + 1)
                defection_rates.append(defection_rate)
            if all((rate > 0.7 for rate in defection_rates)) and self.punishment_timer == 0:
                self.punishment_timer = 1
                return Action.D
        if self.punishment_timer > 0:
            self.punishment_timer -= 1
            if self.punishment_timer == 0:
                return Action.C
        if len(history.my_payoffs) >= 2:
            prev_stock_estimate = history.my_payoffs[-2] * (2 * n if history.my_actions[-2] else n)
            if stock > prev_stock_estimate * 0.9:
                threshold += 0.05
        if current_round == total_rounds:
            return Action.C if stock > capacity * 0.15 and coop_rate_last >= 0.4 else Action.D
        late_game_threshold = int(total_rounds * 0.8)
        if current_round >= late_game_threshold:
            if stock > capacity * 0.6:
                threshold -= 0.05
            elif len(history.my_payoffs) >= 3:
                recent_payoffs = history.my_payoffs[-3:]
                recent_actions = history.my_actions[-3:]
                stock_estimates = []
                for i, (payoff, action) in enumerate(zip(recent_payoffs, recent_actions)):
                    multiplier = 2 * n if action else n
                    stock_est = payoff * multiplier
                    stock_estimates.append(stock_est)
                if len(stock_estimates) >= 2:
                    decline_rate = (stock_estimates[0] - stock_estimates[-1]) / len(stock_estimates)
                    if decline_rate > capacity * 0.1:
                        return Action.D
        return Action.C if sustainability_index >= threshold else Action.D

class Strategy_COOPERATIVE_29(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Stewardship"
    
    Prioritizes long-term sustainability while being adaptive to opponent behavior.
    Starts cooperative but includes mechanisms to protect against exploitation
    while encouraging others to return to cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_threshold = 0.3
        self.healthy_threshold = 0.7

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        sustainability_ratio = state.current_stock / capacity
        rounds_to_check = min(2, len(history.my_actions))
        recent_coop_count = 0
        total_recent_actions = 0
        for i in range(rounds_to_check):
            round_idx = len(history.my_actions) - 1 - i
            if round_idx >= 0:
                opponent_coops = sum(history.opponent_actions[round_idx, :])
                my_coop = 1 if history.my_actions[round_idx] else 0
                recent_coop_count += opponent_coops + my_coop
                total_recent_actions += n
        recent_cooperation_rate = recent_coop_count / total_recent_actions if total_recent_actions > 0 else 0
        high_cooperation = recent_cooperation_rate >= 0.75
        moderate_cooperation = 0.4 <= recent_cooperation_rate < 0.75
        low_cooperation = recent_cooperation_rate < 0.4
        is_final_round = current_round >= total_rounds - 1
        if is_final_round:
            if sustainability_ratio >= 0.4 and recent_cooperation_rate >= 0.6:
                return Action.C
            else:
                return Action.D
        played_d_last = False
        if len(history.my_actions) > 0:
            played_d_last = not history.my_actions[-1]
        cooperation_improved = False
        if len(history.my_actions) >= 3:
            last_round_coops = sum(history.opponent_actions[-1, :]) + (1 if history.my_actions[-1] else 0)
            prev_round_coops = sum(history.opponent_actions[-2, :]) + (1 if history.my_actions[-2] else 0)
            last_rate = last_round_coops / n
            prev_rate = prev_round_coops / n
            cooperation_improved = last_rate - prev_rate > 0.2
        if played_d_last and cooperation_improved:
            return Action.C
        if sustainability_ratio < self.critical_threshold:
            if high_cooperation:
                return Action.C
            else:
                return Action.D
        elif sustainability_ratio >= self.healthy_threshold:
            if recent_cooperation_rate >= 0.5:
                return Action.C
            else:
                return Action.D
        elif high_cooperation:
            return Action.C
        elif moderate_cooperation:
            return Action.C if random.random() < 0.7 else Action.D
        else:
            return Action.D

class Strategy_COOPERATIVE_30(BaseStrategy):
    """
    Adaptive Threshold Cooperation Strategy (ATCS)
    
    Balances collective welfare with protection against exploitation through dynamic
    adaptation based on observed behaviors and resource sustainability. Cooperates
    when stock is sufficient, others are cooperative, and trust levels are adequate.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        stock = state.current_stock
        others_last_round_coop_rate = self._get_others_last_round_coop_rate(history)
        others_historical_coop_rate = self._get_others_historical_coop_rate(history)
        recent_critical_depletion = self._check_recent_critical_depletion(history)
        stock_threshold = self.n_players * (self.capacity / 4)
        if stock >= stock_threshold and others_last_round_coop_rate >= 0.5 and (others_historical_coop_rate >= 0.3) and (not recent_critical_depletion):
            return Action.C
        else:
            return Action.D

    def _get_others_last_round_coop_rate(self, history: PlayerHistory) -> float:
        """Calculate cooperation rate of others in the most recent round."""
        if history.round_number == 0:
            return 0.5
        last_round_cooperators = np.sum(history.opponent_actions[-1, :])
        return last_round_cooperators / (self.n_players - 1)

    def _get_others_historical_coop_rate(self, history: PlayerHistory) -> float:
        """Calculate overall historical cooperation rate of others."""
        if history.round_number == 0:
            return 0.5
        total_cooperations = np.sum(history.opponent_actions)
        total_decisions = history.round_number * (self.n_players - 1)
        return total_cooperations / total_decisions if total_decisions > 0 else 0.5

    def _check_recent_critical_depletion(self, history: PlayerHistory) -> bool:
        """Check if stock fell below 20% capacity in last 2 rounds."""
        if history.round_number < 2:
            return False
        recent_rounds = min(2, history.round_number)
        recent_my_payoffs = history.my_payoffs[-recent_rounds:]
        recent_opponent_payoffs = history.opponent_payoffs[-recent_rounds:, :]
        avg_recent_payoff = np.mean(recent_my_payoffs)
        avg_recent_opponent_payoff = np.mean(recent_opponent_payoffs)
        critical_payoff_threshold = 0.2 * self.capacity / (2 * self.n_players)
        return avg_recent_payoff < critical_payoff_threshold or avg_recent_opponent_payoff < critical_payoff_threshold

class Strategy_COOPERATIVE_31(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Guardian of the Commons"
    
    Prioritizes long-term sustainability while being adaptive to opponent behaviors.
    Uses stock health assessment and graduated responses to maintain cooperation
    while protecting against exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.consecutive_defections = 0
        self.forgiveness_counter = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.consecutive_defections = 0
            self.forgiveness_counter = 0
            return Action.C
        current_round = state.round_number
        current_stock = state.current_stock
        rounds_remaining = self.n_rounds - current_round
        stock_ratio = current_stock / self.capacity
        recent_cooperation_rate = self._calculate_recent_cooperation(history, min(3, history.round_number))
        majority_cooperated_last = self._majority_cooperated_last_round(history)
        if rounds_remaining <= 0.2 * self.n_rounds:
            if stock_ratio > 0.5:
                return Action.C
            else:
                return Action.C if majority_cooperated_last else Action.D
        if stock_ratio > 0.8:
            self.consecutive_defections = 0
            return Action.C
        elif stock_ratio > 0.6:
            return self._graduated_reciprocation(majority_cooperated_last)
        elif stock_ratio > 0.4:
            return self._defensive_cooperation(recent_cooperation_rate)
        else:
            return self._crisis_mode(recent_cooperation_rate, current_stock, history)

    def _calculate_recent_cooperation(self, history: PlayerHistory, lookback_rounds: int) -> float:
        """Calculate cooperation rate over recent rounds."""
        if history.round_number == 0:
            return 1.0
        start_round = max(0, history.round_number - lookback_rounds)
        recent_actions = history.opponent_actions[start_round:, :]
        if recent_actions.size == 0:
            return 1.0
        total_actions = recent_actions.size
        cooperations = np.sum(recent_actions)
        return cooperations / total_actions if total_actions > 0 else 1.0

    def _majority_cooperated_last_round(self, history: PlayerHistory) -> bool:
        """Check if majority of players cooperated in the last round."""
        if history.round_number == 0:
            return True
        last_round_actions = history.opponent_actions[-1, :]
        cooperators = np.sum(last_round_actions)
        return cooperators > (self.n_players - 1) / 2

    def _graduated_reciprocation(self, majority_cooperated_last: bool) -> Action:
        """Graduated reciprocation for healthy stock levels."""
        if majority_cooperated_last:
            self.consecutive_defections = 0
            self.forgiveness_counter += 1
            return Action.C
        elif self.consecutive_defections == 0:
            self.consecutive_defections = 1
            return Action.D
        else:
            self.consecutive_defections = 0
            return Action.C

    def _defensive_cooperation(self, recent_cooperation_rate: float) -> Action:
        """Defensive cooperation for moderate stock depletion."""
        if recent_cooperation_rate > 0.6:
            self.consecutive_defections = 0
            return Action.C
        elif self.consecutive_defections < 2:
            self.consecutive_defections += 1
            return Action.D
        else:
            self.consecutive_defections = 0
            return Action.C

    def _crisis_mode(self, recent_cooperation_rate: float, current_stock: float, history: PlayerHistory) -> Action:
        """Crisis mode for severely depleted stock."""
        if history.round_number > 0:
            stock_showing_recovery = self._stock_showing_recovery(history)
            if stock_showing_recovery:
                self.consecutive_defections = 0
                return Action.C
        if recent_cooperation_rate < 0.7:
            return Action.D
        else:
            self.consecutive_defections = 0
            return Action.C

    def _stock_showing_recovery(self, history: PlayerHistory) -> bool:
        """Detect if stock is showing signs of recovery."""
        if history.round_number < 2:
            return False
        recent_total_payoffs = np.sum(history.opponent_payoffs[-1, :]) + history.my_payoffs[-1]
        previous_total_payoffs = np.sum(history.opponent_payoffs[-2, :]) + history.my_payoffs[-2]
        return recent_total_payoffs > previous_total_payoffs * 1.1

class Strategy_COOPERATIVE_32(BaseStrategy):
    """
    Adaptive Cooperative Resource Management (ACRM) Strategy.
    
    Prioritizes long-term sustainability while maintaining cooperative intent,
    using adaptive mechanisms to respond to different opponent behaviors
    without abandoning the cooperative framework.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.base_cooperation_rate = 0.6
        if game_description.n_players <= 4:
            self.base_cooperation_rate += 0.1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round = state.round_number
        stock = state.current_stock
        if current_round == n_rounds - 1:
            return self._final_round_decision(stock, capacity, history)
        cooperation_score = self.base_cooperation_rate
        cooperation_score += self._get_stock_health_bonus(stock, capacity)
        cooperation_score += self._get_reciprocity_bonus(history)
        cooperation_score += self._get_trend_bonus(history, capacity)
        if stock < 0.1 * capacity:
            return Action.C
        if cooperation_score > 0.5:
            return Action.C
        else:
            if self._should_recover_to_cooperation(history):
                return Action.C
            return Action.D

    def _get_stock_health_bonus(self, stock, capacity):
        """Calculate bonus based on stock health zones."""
        if stock >= 0.8 * capacity:
            return 0.2
        elif stock >= 0.4 * capacity:
            return 0.1
        else:
            return 0.3

    def _get_reciprocity_bonus(self, history):
        """Calculate bonus based on opponents' cooperation rates."""
        if history.round_number < 1:
            return 0.0
        window_size = min(3, history.round_number)
        recent_actions = history.opponent_actions[-window_size:, :]
        total_bonus = 0.0
        n_opponents = recent_actions.shape[1]
        for opponent_idx in range(n_opponents):
            opponent_recent = recent_actions[:, opponent_idx]
            cooperation_rate = np.mean(opponent_recent.astype(float))
            if cooperation_rate > 0.7:
                total_bonus += 0.15
            elif cooperation_rate >= 0.3:
                total_bonus += 0.05
            else:
                total_bonus -= 0.1
        return total_bonus / n_opponents if n_opponents > 0 else 0.0

    def _get_trend_bonus(self, history, capacity):
        """Calculate bonus based on stock trajectory."""
        if history.round_number < 3:
            return 0.0
        recent_payoffs = history.my_payoffs[-3:]
        if len(recent_payoffs) >= 2:
            decline_rate = (recent_payoffs[0] - recent_payoffs[-1]) / recent_payoffs[0]
            if decline_rate > 0.2:
                return 0.2
            elif decline_rate < -0.1:
                return 0.1
        return 0.0

    def _should_recover_to_cooperation(self, history):
        """Check if we should recover to cooperation after defection."""
        if history.round_number == 0:
            return False
        last_action = history.my_actions[-1]
        if not last_action:
            return True
        return False

    def _final_round_decision(self, stock, capacity, history):
        """Make decision for the final round."""
        crisis_threshold = 0.4 * capacity
        if stock > crisis_threshold:
            return Action.C
        if history.round_number >= 3:
            window_size = min(3, history.round_number)
            recent_actions = history.opponent_actions[-window_size:, :]
            cooperation_rates = np.mean(recent_actions.astype(float), axis=0)
            if len(cooperation_rates) > 0:
                most_cooperative_rate = np.max(cooperation_rates)
                if most_cooperative_rate > 0.5:
                    return Action.C
        if stock > 0.1 * capacity:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_33(BaseStrategy):
    """
    Sustainable Guardian: Adaptive cooperative strategy that prioritizes long-term sustainability
    while being cooperative by default, but adaptively responds to exploitation patterns.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = state.round_number
        current_stock = state.current_stock
        if current_stock < self.capacity * 0.15:
            return Action.D
        cooperation_rate = self._calculate_recent_cooperation_rate(history, 3)
        threshold = self.capacity * (0.3 + 0.4 * cooperation_rate)
        if current_round == self.n_rounds - 1:
            if current_stock <= self.capacity * 0.2:
                return Action.D
            else:
                return Action.C
        if current_round >= 3:
            chronic_defectors = self._count_chronic_defectors(history)
            if chronic_defectors > self.n_players / 2 and current_stock < self.capacity * 0.5:
                if self._should_punish(history):
                    return Action.D
        if current_stock >= threshold:
            return Action.C
        else:
            return Action.D

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory, lookback: int) -> float:
        """Calculate the fraction of cooperative actions in recent rounds."""
        rounds_completed = history.round_number
        start_round = max(0, rounds_completed - lookback)
        if rounds_completed == 0:
            return 1.0
        total_actions = 0
        cooperative_actions = 0
        for round_idx in range(start_round, rounds_completed):
            total_actions += 1
            if history.my_actions[round_idx]:
                cooperative_actions += 1
            for player_idx in range(self.n_players - 1):
                total_actions += 1
                if history.opponent_actions[round_idx, player_idx]:
                    cooperative_actions += 1
        return cooperative_actions / total_actions if total_actions > 0 else 1.0

    def _count_chronic_defectors(self, history: PlayerHistory) -> int:
        """Count opponents who have cooperation rate < 0.3 in last 3 rounds."""
        rounds_completed = history.round_number
        lookback = min(3, rounds_completed)
        start_round = rounds_completed - lookback
        chronic_defectors = 0
        for player_idx in range(self.n_players - 1):
            cooperative_actions = 0
            for round_idx in range(start_round, rounds_completed):
                if history.opponent_actions[round_idx, player_idx]:
                    cooperative_actions += 1
            cooperation_rate = cooperative_actions / lookback if lookback > 0 else 1.0
            if cooperation_rate < 0.3:
                chronic_defectors += 1
        return chronic_defectors

    def _should_punish(self, history: PlayerHistory) -> bool:
        """Graduated response: punish occasionally when many chronic defectors detected."""
        rounds_completed = history.round_number
        if rounds_completed < 2:
            return False
        last_action_cooperative = history.my_actions[-1]
        recent_opponent_cooperation = 0
        recent_rounds = min(2, rounds_completed)
        for round_idx in range(rounds_completed - recent_rounds, rounds_completed):
            for player_idx in range(self.n_players - 1):
                if history.opponent_actions[round_idx, player_idx]:
                    recent_opponent_cooperation += 1
        total_recent_opponent_actions = recent_rounds * (self.n_players - 1)
        opponent_cooperation_rate = recent_opponent_cooperation / total_recent_opponent_actions if total_recent_opponent_actions > 0 else 0
        return last_action_cooperative and opponent_cooperation_rate < 0.4

class Strategy_COOPERATIVE_34(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Guardian"
    
    Prioritizes long-term sustainability while being responsive to collective behavior.
    Uses a cooperation threshold system based on stock health, historical cooperation
    rates, and time remaining. Balances cooperation with self-protection through
    adaptive thresholds and graduated responses.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_number = history.round_number
        if round_number == self.n_rounds - 1:
            if state.current_stock < self.capacity / 4:
                return Action.C
            return Action.D
        stock_health = state.current_stock / self.capacity
        total_opponent_actions = np.sum(history.opponent_actions)
        total_possible_actions = history.round_number * (self.n_players - 1)
        if total_possible_actions > 0:
            opponent_coop_rate = total_opponent_actions / total_possible_actions
        else:
            opponent_coop_rate = 0.5
        time_pressure = (self.n_rounds - round_number) / self.n_rounds
        base_threshold = 0.3
        health_bonus = stock_health * 0.4
        time_bonus = time_pressure * 0.2
        cooperation_threshold = base_threshold + health_bonus + time_bonus
        if opponent_coop_rate >= cooperation_threshold:
            return Action.C
        elif stock_health < 0.2 and opponent_coop_rate < 0.2:
            return Action.D
        else:
            forgiveness_probability = 0.1 + stock_health * 0.3
            if round_number >= 3:
                recent_rounds = min(3, round_number)
                recent_coop = np.sum(history.opponent_actions[-recent_rounds:]) / (recent_rounds * (self.n_players - 1))
                if recent_coop < 0.2:
                    forgiveness_probability *= 0.5
            if round_number >= 3:
                my_recent_coop = np.sum(history.my_actions[-3:]) / 3
                if my_recent_coop > 0.8 and opponent_coop_rate < 0.3:
                    forgiveness_probability *= 0.3
            if round_number >= 2:
                recent_total_coop = np.sum(history.opponent_actions[-2:]) + np.sum(history.my_actions[-2:])
                recent_total_actions = 2 * self.n_players
                recent_coop_rate = recent_total_coop / recent_total_actions
                if recent_coop_rate < 0.4 and stock_health < 0.5:
                    forgiveness_probability += 0.2
            if opponent_coop_rate > 0.7:
                return Action.C
            if random.random() < forgiveness_probability:
                return Action.C
            else:
                return Action.D

class Strategy_COOPERATIVE_35(BaseStrategy):
    """
    Adaptive Conservation Strategy (ACS) - prioritizes long-term resource sustainability
    while adapting to opponent behavior. Starts cooperatively, defends against exploitation,
    and maintains incentives for others to return to cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round < 3:
            if current_stock < self.n_players:
                return Action.C
            return Action.C
        high_stock_threshold = 0.8 * self.capacity
        low_stock_threshold = 0.4 * self.capacity
        recent_rounds = min(3, len(history.opponent_actions))
        if recent_rounds > 0:
            recent_opponent_actions = history.opponent_actions[-recent_rounds:]
            total_coop_rate = np.mean(recent_opponent_actions)
        else:
            total_coop_rate = 0.5
        high_coop_env = total_coop_rate > 0.7
        low_coop_env = total_coop_rate < 0.3
        if current_stock < self.n_players:
            return Action.C
        if current_stock < low_stock_threshold:
            return Action.C
        if current_round >= self.n_rounds - 2:
            return self._endgame_strategy(current_round, current_stock, history)
        if current_stock >= high_stock_threshold:
            if high_coop_env:
                return Action.C
            else:
                my_recent_coop = np.mean(history.my_actions[-recent_rounds:]) if recent_rounds > 0 else 1.0
                if my_recent_coop > total_coop_rate:
                    return Action.D
                else:
                    return Action.C
        elif high_coop_env:
            return Action.C
        elif len(history.opponent_actions) > 0:
            last_round_coop = np.mean(history.opponent_actions[-1])
            if last_round_coop > 0.5:
                return Action.C
            elif random.random() < 0.3:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C

    def _endgame_strategy(self, current_round, current_stock, history):
        """Handle last 2 rounds with special endgame logic"""
        if current_round == self.n_rounds - 2:
            if current_stock > 0.6 * self.capacity:
                return Action.C
            else:
                return self._apply_main_game_rules(current_stock, history)
        else:
            if current_stock < self.n_players:
                return Action.C
            recent_rounds = min(5, len(history.opponent_actions))
            if recent_rounds > 0:
                recent_coop_rate = np.mean(history.opponent_actions[-recent_rounds:])
                if recent_coop_rate > 0.6:
                    return Action.C
            return Action.D

    def _apply_main_game_rules(self, current_stock, history):
        """Apply the main game strategy rules"""
        high_stock_threshold = 0.8 * self.capacity
        low_stock_threshold = 0.4 * self.capacity
        recent_rounds = min(3, len(history.opponent_actions))
        if recent_rounds > 0:
            total_coop_rate = np.mean(history.opponent_actions[-recent_rounds:])
        else:
            total_coop_rate = 0.5
        high_coop_env = total_coop_rate > 0.7
        if current_stock < low_stock_threshold:
            return Action.C
        elif current_stock >= high_stock_threshold and high_coop_env:
            return Action.C
        elif high_coop_env:
            return Action.C
        elif len(history.opponent_actions) > 0:
            last_round_coop = np.mean(history.opponent_actions[-1])
            if last_round_coop > 0.5:
                return Action.C
            elif random.random() < 0.3:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_36(BaseStrategy):
    """
    Sustainable Steward: An adaptive cooperative strategy that prioritizes long-term 
    sustainability while being responsive to community behavior and stock health.
    Starts cooperative and adjusts based on stock levels and opponent cooperation rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        stock_percentage = state.current_stock / self.game_description.capacity * 100
        recent_rounds = min(3, history.round_number)
        community_coop_rate = self._calculate_cooperation_rate(history, recent_rounds)
        stock_growing = self._is_stock_growing(history, state.current_stock)
        if stock_percentage < 15:
            return Action.D
        if stock_percentage >= 50:
            return Action.C
        if stock_percentage >= 25:
            if community_coop_rate >= 50:
                return Action.C
            else:
                return Action.D
        if stock_percentage >= 15:
            if stock_growing and community_coop_rate >= 30:
                return Action.C
            elif community_coop_rate >= 60:
                return Action.C
            else:
                return Action.D
        return Action.D

    def _calculate_cooperation_rate(self, history: PlayerHistory, recent_rounds: int) -> float:
        """Calculate the percentage of opponents who cooperated in recent rounds."""
        if recent_rounds == 0:
            return 0.0
        recent_actions = history.opponent_actions[-recent_rounds:, :]
        total_cooperations = np.sum(recent_actions)
        total_actions = recent_actions.size
        if total_actions == 0:
            return 0.0
        return total_cooperations / total_actions * 100

    def _is_stock_growing(self, history: PlayerHistory, current_stock: float) -> bool:
        """Check if stock is growing compared to the previous state."""
        if history.round_number < 1:
            return False
        if history.round_number >= 2:
            recent_coop_rate = self._calculate_cooperation_rate(history, 1)
            return recent_coop_rate >= 70
        return False

class Strategy_COOPERATIVE_37(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Trust with Graduated Reciprocation"
    
    This strategy prioritizes long-term sustainability while maintaining cooperative intent,
    using adaptive mechanisms to encourage cooperation and discourage exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        current_round = history.round_number
        stock = state.current_stock
        if current_round == self.game_description.n_rounds - 1:
            if stock >= 0.4 * capacity:
                return Action.C
            else:
                last_round_actions = history.opponent_actions[-1, :]
                cooperators = sum(last_round_actions)
                if cooperators >= len(last_round_actions) / 2:
                    return Action.C
                else:
                    return Action.D
        stock_health = self._classify_stock_health(stock, capacity)
        window_size = min(3, current_round)
        recent_cooperation_rate = self._calculate_recent_cooperation_rate(history, window_size)
        if stock_health == 'Critical':
            if self._all_cooperated_last_round(history):
                return Action.C
            else:
                return Action.D
        elif stock_health == 'Stressed':
            exploitative_fraction = self._count_exploitative_players(history) / (n - 1)
            threshold = 0.6 - exploitative_fraction * 0.3
            if recent_cooperation_rate >= threshold:
                return Action.C
            else:
                return Action.D
        else:
            if stock < 0.5 * capacity:
                if recent_cooperation_rate >= 0.45:
                    return Action.C
            elif recent_cooperation_rate >= 0.5:
                return Action.C
            elif self._any_player_switched_to_cooperation(history):
                return Action.C
            return Action.D

    def _classify_stock_health(self, stock, capacity):
        """Classify stock health as Healthy, Stressed, or Critical."""
        if stock >= 0.6 * capacity:
            return 'Healthy'
        elif stock >= 0.3 * capacity:
            return 'Stressed'
        else:
            return 'Critical'

    def _calculate_recent_cooperation_rate(self, history, window_size):
        """Calculate cooperation rate over recent rounds."""
        if history.round_number == 0:
            return 1.0
        start_idx = max(0, history.round_number - window_size)
        recent_actions = history.opponent_actions[start_idx:, :]
        total_actions = recent_actions.size
        if total_actions == 0:
            return 1.0
        cooperations = np.sum(recent_actions)
        return cooperations / total_actions

    def _all_cooperated_last_round(self, history):
        """Check if all opponents cooperated in the previous round."""
        if history.round_number == 0:
            return True
        last_round_actions = history.opponent_actions[-1, :]
        return np.all(last_round_actions)

    def _count_exploitative_players(self, history):
        """Count players with recent cooperation rate < 30%."""
        if history.round_number <= 1:
            return 0
        window_size = min(3, history.round_number)
        start_idx = max(0, history.round_number - window_size)
        exploitative_count = 0
        n_opponents = history.opponent_actions.shape[1]
        for player_idx in range(n_opponents):
            player_recent_actions = history.opponent_actions[start_idx:, player_idx]
            if len(player_recent_actions) > 0:
                cooperation_rate = np.mean(player_recent_actions)
                if cooperation_rate < 0.3:
                    exploitative_count += 1
        return exploitative_count

    def _any_player_switched_to_cooperation(self, history):
        """Check if any player switched from defection to cooperation recently."""
        if history.round_number < 2:
            return False
        if history.round_number >= 2:
            prev_prev_actions = history.opponent_actions[-2, :]
            prev_actions = history.opponent_actions[-1, :]
            switched = np.logical_and(prev_prev_actions == False, prev_actions == True)
            return np.any(switched)
        return False

class Strategy_COOPERATIVE_38(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Guardian"
    
    Balances long-term resource sustainability with protection against exploitation.
    Uses dynamic thresholds, behavior tracking, and adaptive mechanisms to maintain
    cooperation while preventing tragedy of the commons.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.exploitation_count = 0
        self.emergency_defection_rounds = 0
        self.my_recent_cooperation_rate = 1.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_stock = state.current_stock
        round_num = history.round_number
        stock_health = current_stock / self.capacity
        if round_num > 0:
            last_round_cooperators = sum(history.opponent_actions[-1, :])
            opponent_cooperation_rate = last_round_cooperators / (self.n_players - 1)
            majority_cooperated = opponent_cooperation_rate > 0.5
            recent_rounds = min(3, round_num)
            my_recent_cooperations = sum(history.my_actions[-recent_rounds:])
            self.my_recent_cooperation_rate = my_recent_cooperations / recent_rounds
        else:
            opponent_cooperation_rate = 1.0
            majority_cooperated = True
        cooperation_threshold = self.capacity * (0.3 + 0.4 * opponent_cooperation_rate)
        if current_stock < 0.2 * self.capacity:
            self.emergency_defection_rounds += 1
            return Action.D
        elif self.emergency_defection_rounds > 0 and current_stock < 0.3 * self.capacity:
            return Action.D
        else:
            self.emergency_defection_rounds = 0
        if round_num == self.n_rounds - 1:
            if current_stock < 0.3 * self.capacity:
                return Action.D
            elif round_num > 0:
                total_opponent_cooperations = sum((sum(history.opponent_actions[i, :]) for i in range(round_num)))
                overall_cooperation_rate = total_opponent_cooperations / (round_num * (self.n_players - 1))
                return Action.C if overall_cooperation_rate > 0.5 else Action.D
            else:
                return Action.C
        if stock_health >= 0.7:
            if round_num > 0 and majority_cooperated and (self.my_recent_cooperation_rate < 0.6):
                return Action.C
            elif self.my_recent_cooperation_rate >= 0.8:
                return Action.C if random.random() < 0.8 else Action.D
            else:
                return Action.C
        elif stock_health <= 0.3:
            if opponent_cooperation_rate > 0.6:
                return Action.C
            else:
                return Action.D
        if current_stock > cooperation_threshold and stock_health > 0.3:
            if majority_cooperated or self.my_recent_cooperation_rate < 0.6:
                return Action.C
            else:
                return Action.C if random.random() < 0.8 else Action.D
        elif opponent_cooperation_rate > 0.6:
            return Action.C
        elif round_num > 0 and opponent_cooperation_rate < 0.5 and (current_stock > 0.2 * self.capacity):
            return Action.D if random.random() < 0.7 else Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_39(BaseStrategy):
    """
    Adaptive Sustainability Strategy (ASS) that balances long-term collective welfare
    with robust defenses against exploitation using a Sustainability-Trust Index.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_rounds_remaining = 0
        self.individual_cooperation_rates = {}

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        rhs = state.current_stock / self.game_description.capacity
        if rhs < 0.2:
            self.punishment_rounds_remaining = 0
            return Action.C
        window_size = min(3, history.round_number)
        recent_rounds = slice(-window_size, None) if window_size > 0 else slice(None)
        if window_size > 0:
            recent_opponent_actions = history.opponent_actions[recent_rounds, :]
            total_recent_actions = recent_opponent_actions.size
            total_cooperate_actions = np.sum(recent_opponent_actions)
            cs = total_cooperate_actions / total_recent_actions if total_recent_actions > 0 else 1.0
        else:
            cs = 1.0
        tt = 0.6 + 0.2 * rhs
        if self.punishment_rounds_remaining > 0:
            if cs > 0.7:
                self.punishment_rounds_remaining = 0
                return Action.C
            else:
                self.punishment_rounds_remaining -= 1
                return Action.D
        rounds_remaining = self.game_description.n_rounds - state.round_number
        if rounds_remaining == 1:
            if rhs > 0.5:
                return Action.C
        if rounds_remaining == 2:
            tt -= 0.1
            if cs > 0.8:
                return Action.C
        if history.round_number >= 2:
            last_round_defectors = np.sum(history.opponent_actions[-1, :] == False)
            second_last_defectors = np.sum(history.opponent_actions[-2, :] == False)
            majority_threshold = self.game_description.n_players // 2
            if last_round_defectors > majority_threshold and second_last_defectors > majority_threshold and (rhs >= 0.2):
                self.punishment_rounds_remaining = min(2, rounds_remaining - 1)
                return Action.D
        if history.round_number >= 1:
            last_round_defectors = np.sum(history.opponent_actions[-1, :] == False)
            if last_round_defectors > self.game_description.n_players // 2 and rhs >= 0.2:
                self.punishment_rounds_remaining = 1
                return Action.D
        if cs >= tt:
            return Action.C
        else:
            punishment_intensity = 1.0 - cs
            punishment_duration = min(2, max(1, int(punishment_intensity * 2)), rounds_remaining - 1)
            if punishment_duration > 0:
                self.punishment_rounds_remaining = punishment_duration - 1
                return Action.D
            else:
                return Action.C
        if cs < 0.4 and history.round_number >= 3:
            recent_my_actions = history.my_actions[-3:]
            if np.all(recent_my_actions == True):
                return Action.D
        return Action.C

class Strategy_COOPERATIVE_40(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Steward"
    
    Prioritizes long-term sustainability while being responsive to group dynamics.
    Uses dynamic cooperation thresholds based on resource health and adapts to
    group behavior patterns while protecting against exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = state.round_number
        stock = state.current_stock
        capacity = self.game_description.capacity
        n = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        if current_round <= 1:
            return Action.C
        cooperation_ratio = stock / capacity
        base_threshold = 0.6 + 0.3 * cooperation_ratio
        window_size = min(3, current_round)
        recent_rounds = history.opponent_actions[-window_size:, :]
        total_actions_in_window = recent_rounds.size
        total_cooperations = np.sum(recent_rounds)
        recent_cooperation_rate = total_cooperations / total_actions_in_window if total_actions_in_window > 0 else 0
        if stock < n and recent_cooperation_rate > 0.3:
            return Action.C
        if stock == 0:
            return Action.C
        if current_round == total_rounds - 1:
            return Action.C if recent_cooperation_rate > 0.4 else Action.D
        if current_round >= 4:
            prev_window_size = min(3, current_round - 1)
            prev_window_start = max(0, current_round - prev_window_size - 1)
            prev_window_end = current_round - 1
            if prev_window_end > prev_window_start:
                prev_window_actions = history.opponent_actions[prev_window_start:prev_window_end, :]
                prev_total_actions = prev_window_actions.size
                prev_cooperations = np.sum(prev_window_actions)
                prev_cooperation_rate = prev_cooperations / prev_total_actions if prev_total_actions > 0 else 0
                if recent_cooperation_rate - prev_cooperation_rate > 0.3:
                    return Action.C
        if cooperation_ratio > 0.9 and recent_cooperation_rate > 0.4:
            return Action.C
        if recent_cooperation_rate >= base_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_41(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Steward"
    
    Prioritizes long-term sustainability while adapting to opponent behavior.
    Starts cooperatively but responds to exploitation with graduated responses
    and forgiveness mechanisms to restore cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.r - 1:
            stock_health_ratio = current_stock / self.capacity
            if stock_health_ratio > 0.5 or stock_health_ratio < 0.3:
                return Action.C
            else:
                last_round_cooperators = np.sum(history.opponent_actions[-1, :])
                if last_round_cooperators >= (self.n - 1) / 2:
                    return Action.C
                else:
                    return Action.D
        stock_health_ratio = current_stock / self.capacity
        critical_threshold = 0.3
        sustainable_threshold = 0.6
        total_rounds_played = len(history.my_actions)
        recent_rounds = min(3, total_rounds_played)
        recent_defections = 0
        recent_total = 0
        for i in range(recent_rounds):
            round_idx = total_rounds_played - 1 - i
            recent_defections += np.sum(~history.opponent_actions[round_idx, :])
            recent_total += self.n - 1
        recent_defection_rate = recent_defections / recent_total if recent_total > 0 else 0
        total_defections = np.sum(~history.opponent_actions)
        total_observations = total_rounds_played * (self.n - 1)
        overall_defection_rate = total_defections / total_observations if total_observations > 0 else 0
        if stock_health_ratio < critical_threshold:
            if current_stock > 0 and total_rounds_played > 0:
                last_round_defectors = np.sum(~history.opponent_actions[-1, :])
                if last_round_defectors > 0.75 * (self.n - 1):
                    return Action.D
            return Action.C
        elif stock_health_ratio < sustainable_threshold:
            if recent_defection_rate < 0.5:
                return Action.C
            else:
                return Action.D
        elif recent_defection_rate < 0.3:
            return Action.C
        else:
            defect_probability = min(recent_defection_rate, 0.8)
            if random.random() < defect_probability:
                return Action.D
            else:
                return Action.C
        if total_rounds_played > 1 and len(history.my_actions) > 0 and (not history.my_actions[-1]):
            if total_rounds_played >= 2:
                prev_round_defectors = np.sum(~history.opponent_actions[-2, :]) if total_rounds_played >= 2 else 0
                last_round_defectors = np.sum(~history.opponent_actions[-1, :])
                prev_rate = prev_round_defectors / (self.n - 1)
                curr_rate = last_round_defectors / (self.n - 1)
                if prev_rate - curr_rate > 0.3:
                    return Action.C
        return Action.C

class Strategy_COOPERATIVE_42(BaseStrategy):
    """
    Guardian of the Commons: An adaptive cooperative strategy that balances long-term 
    collective welfare with protection against exploitation. Uses stock thresholds and 
    reciprocal cooperation to maintain the resource pool while being robust to defectors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = max(self.capacity * 0.4, 2 * self.n)
        self.trust_phase_end = max(2, int(self.r * 0.2))
        self.endgame_start = int(self.r * 0.8)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_num = state.round_number
        stock = state.current_stock
        if stock < self.n * 1.5:
            return Action.D
        if round_num <= self.trust_phase_end:
            if stock >= self.critical_threshold:
                return Action.C
            else:
                return Action.D
        elif round_num >= self.endgame_start:
            if stock >= self.capacity * 0.8:
                return Action.C
            elif stock >= self.critical_threshold:
                recent_defection_rate = self._calculate_recent_defection_rate(history, 2)
                if recent_defection_rate <= 0.3:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
        else:
            recent_coop_rate = self._calculate_recent_cooperation_rate(history, 3)
            if stock >= self.critical_threshold and recent_coop_rate >= 0.5:
                return Action.C
            elif stock >= self.critical_threshold and recent_coop_rate >= 0.3:
                if random.random() < 0.7:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory, lookback_rounds: int) -> float:
        """Calculate cooperation rate of opponents in recent rounds."""
        if history.round_number == 0:
            return 1.0
        start_round = max(0, history.round_number - lookback_rounds)
        recent_actions = history.opponent_actions[start_round:, :]
        if recent_actions.size == 0:
            return 1.0
        total_cooperations = np.sum(recent_actions)
        total_actions = recent_actions.size
        return total_cooperations / total_actions if total_actions > 0 else 1.0

    def _calculate_recent_defection_rate(self, history: PlayerHistory, lookback_rounds: int) -> float:
        """Calculate defection rate of opponents in recent rounds."""
        return 1.0 - self._calculate_recent_cooperation_rate(history, lookback_rounds)

class Strategy_COOPERATIVE_43(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Steward"
    
    Prioritizes long-term sustainability while being adaptive to opponent behavior.
    Uses dynamic cooperation thresholds based on stock health and opponent cooperation rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.base_threshold = 0.6
        self.consecutive_cooperations = 0
        self.exploitation_count = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.consecutive_cooperations = 1
            return Action.C
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        round_num = history.round_number
        if round_num >= total_rounds - 1:
            return Action.D
        if current_stock > 0.8 * capacity:
            self.consecutive_cooperations += 1
            return Action.C
        cooperation_rate = self._estimate_cooperation_rate(history, n)
        threshold = self._calculate_cooperation_threshold(current_stock, capacity, cooperation_rate)
        if cooperation_rate >= threshold:
            self.consecutive_cooperations += 1
            return Action.C
        if current_stock < 0.2 * capacity and self._majority_cooperated_last_round(history, n):
            self.consecutive_cooperations += 1
            return Action.C
        if self._should_send_cooperation_signal(history, round_num):
            self.consecutive_cooperations += 1
            return Action.C
        if self.consecutive_cooperations >= 3 and cooperation_rate < 0.4:
            self.consecutive_cooperations = 0
            return Action.D
        self.consecutive_cooperations = 0
        if history.round_number > 0:
            last_round_cooperators = np.sum(history.opponent_actions[-1, :])
            if history.my_actions[-1] and last_round_cooperators / n < 0.3:
                self.exploitation_count += 1
        return Action.D

    def _estimate_cooperation_rate(self, history: PlayerHistory, n: int) -> float:
        """Estimate recent cooperation rate with weighted average."""
        if history.round_number == 0:
            return 0.5
        last_round_coop = np.sum(history.opponent_actions[-1, :]) / n
        if history.round_number == 1:
            return last_round_coop
        two_rounds_ago_coop = np.sum(history.opponent_actions[-2, :]) / n
        return (last_round_coop + 0.5 * two_rounds_ago_coop) / 1.5

    def _calculate_cooperation_threshold(self, stock: float, capacity: float, cooperation_rate: float) -> float:
        """Calculate dynamic cooperation threshold."""
        threshold = self.base_threshold
        stock_adjustment = -0.3 * (1 - stock / capacity)
        behavior_adjustment = 0.2 * (cooperation_rate - 0.5)
        return max(0.1, min(0.9, threshold + stock_adjustment + behavior_adjustment))

    def _majority_cooperated_last_round(self, history: PlayerHistory, n: int) -> bool:
        """Check if majority of opponents cooperated in the last round."""
        if history.round_number == 0:
            return False
        last_round_cooperators = np.sum(history.opponent_actions[-1, :])
        return last_round_cooperators > n / 2

    def _should_send_cooperation_signal(self, history: PlayerHistory, round_num: int) -> bool:
        """Decide if we should send a cooperation signal to break negative cycles."""
        if round_num < 3 or round_num > self.game_description.n_rounds * 0.8:
            return False
        if round_num % 5 == 0:
            cooperation_rate = self._estimate_cooperation_rate(history, self.game_description.n_players)
            if cooperation_rate < 0.3:
                return True
        if history.round_number > 0:
            last_round_cooperators = np.sum(history.opponent_actions[-1, :])
            my_last_action = history.my_actions[-1]
            if last_round_cooperators == 0 and (not my_last_action):
                return True
        return False

class Strategy_COOPERATIVE_44(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Guardian"
    
    Prioritizes long-term sustainability while being adaptive to opponent behavior.
    Uses stock health assessment and opponent behavior analysis to make intelligent
    cooperation decisions with built-in defenses against exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.coop_threshold_adjustment = 0.1 if self.n_players > 6 else 0.0
        self.declining_rounds = 0
        self.last_stock = None
        self.survival_mode = False
        self.rounds_since_forgiveness = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if history is None:
            self.last_stock = current_stock
            return Action.C
        if self.last_stock is not None:
            if current_stock < self.last_stock:
                self.declining_rounds += 1
            else:
                self.declining_rounds = 0
        self.last_stock = current_stock
        stock_health = self._assess_stock_health(current_stock)
        emergency_threshold = 0.2 * self.capacity
        recovery_threshold = 0.3 * self.capacity
        if current_stock < emergency_threshold:
            self.survival_mode = True
        elif current_stock > recovery_threshold:
            self.survival_mode = False
        if self.survival_mode:
            return Action.D
        if self.n_rounds <= 3:
            if current_round == self.n_rounds - 1 and stock_health == 'Critical':
                return Action.D
            return Action.C
        if current_round == self.n_rounds - 1:
            if stock_health == 'Critical':
                return Action.D
            if len(history.opponent_actions) > 0:
                last_round_coop = np.sum(history.opponent_actions[-1, :])
                if last_round_coop >= len(history.opponent_actions[-1, :]) / 2:
                    return Action.C
            return Action.D
        opponent_coop_rates = self._analyze_opponents(history)
        self.rounds_since_forgiveness += 1
        forgiveness_due = self.rounds_since_forgiveness >= 3 and stock_health != 'Critical' and (random.random() < 0.3)
        if forgiveness_due:
            self.rounds_since_forgiveness = 0
            return Action.C
        if self._detect_perfect_cooperation(history) and stock_health == 'Healthy':
            return Action.C
        return self._main_decision_logic(stock_health, history, opponent_coop_rates)

    def _assess_stock_health(self, stock):
        """Categorize stock health level."""
        if self.capacity < 4 * self.n_players:
            healthy_threshold = 0.8 * self.capacity
            moderate_threshold = 0.5 * self.capacity
        else:
            healthy_threshold = 0.7 * self.capacity
            moderate_threshold = 0.4 * self.capacity
        if stock >= healthy_threshold:
            return 'Healthy'
        elif stock >= moderate_threshold:
            return 'Moderate'
        else:
            return 'Critical'

    def _analyze_opponents(self, history):
        """Analyze opponent cooperation rates over sliding window."""
        window_size = min(5, len(history.my_actions))
        if window_size == 0:
            return []
        recent_actions = history.opponent_actions[-window_size:, :]
        cooperation_rates = np.mean(recent_actions, axis=0)
        return cooperation_rates

    def _get_recent_cooperation_rate(self, history, rounds_back):
        """Get cooperation rate over last N rounds."""
        if len(history.my_actions) < rounds_back:
            rounds_back = len(history.my_actions)
        if rounds_back == 0:
            return 0.5
        recent_actions = history.opponent_actions[-rounds_back:, :]
        return np.mean(recent_actions)

    def _detect_perfect_cooperation(self, history):
        """Detect if all players cooperated for 3+ consecutive rounds."""
        if len(history.my_actions) < 3:
            return False
        last_3_rounds = history.opponent_actions[-3:, :]
        all_coop = np.all(last_3_rounds)
        my_all_coop = np.all(history.my_actions[-3:])
        return all_coop and my_all_coop

    def _main_decision_logic(self, stock_health, history, opponent_coop_rates):
        """Main decision logic based on stock health and opponent behavior."""
        momentum_penalty = 0.2 if self.declining_rounds >= 3 else 0.0
        if stock_health == 'Critical':
            cooperative_opponents = sum((1 for rate in opponent_coop_rates if rate >= 0.6 - self.coop_threshold_adjustment))
            majority_cooperative = cooperative_opponents >= len(opponent_coop_rates) / 2
            if majority_cooperative:
                return Action.C
            else:
                return Action.D
        elif stock_health == 'Moderate':
            coop_rate_3_rounds = self._get_recent_cooperation_rate(history, 3)
            threshold = 0.5 - self.coop_threshold_adjustment - momentum_penalty
            if coop_rate_3_rounds >= threshold:
                return Action.C
            elif coop_rate_3_rounds < 0.2 - self.coop_threshold_adjustment:
                return Action.D
            else:
                return Action.C if random.random() < 0.7 else Action.D
        else:
            coop_rate_1_round = self._get_recent_cooperation_rate(history, 1)
            threshold = 0.6 - self.coop_threshold_adjustment - momentum_penalty
            if coop_rate_1_round >= threshold:
                return Action.C
            elif coop_rate_1_round < 0.3 - self.coop_threshold_adjustment:
                return Action.D
            else:
                return Action.C if random.random() < 0.8 else Action.D

class Strategy_COOPERATIVE_46(BaseStrategy):
    """
    Adaptive Cooperative Pool Management Strategy (ACPM)
    
    Prioritizes long-term sustainability while being adaptive to opponent behaviors.
    Starts cooperative but includes mechanisms to protect against exploitation and 
    encourage cooperation through demonstrated reciprocity.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round <= 2:
            if current_stock < 0.5 * self.capacity:
                return Action.D if random.random() < 0.3 else Action.C
            return Action.C
        stock_ratio = current_stock / self.capacity
        if stock_ratio >= 0.75:
            stock_health = 'Healthy'
        elif stock_ratio >= 0.4:
            stock_health = 'Moderate'
        elif stock_ratio >= 0.15:
            stock_health = 'Critical'
        else:
            stock_health = 'Depleted'
        window_size = min(5, current_round)
        recent_actions = history.opponent_actions[-window_size:, :]
        cooperation_rates = np.mean(recent_actions, axis=0)
        high_cooperators = np.sum(cooperation_rates >= 0.6)
        mixed_players = np.sum((cooperation_rates >= 0.3) & (cooperation_rates < 0.6))
        low_cooperators = np.sum(cooperation_rates < 0.3)
        total_opponents = self.n_players - 1
        fraction_of_defectors = low_cooperators / total_opponents
        if stock_health == 'Healthy':
            cooperate_probability = 0.9
        elif stock_health == 'Moderate':
            cooperate_probability = 0.7 - 0.3 * fraction_of_defectors
        elif stock_health == 'Critical':
            cooperate_probability = 0.5 - 0.4 * fraction_of_defectors
        else:
            cooperate_probability = 0.2
        reciprocity_bonus = 0.2 * (high_cooperators / total_opponents)
        cooperate_probability += reciprocity_bonus
        endgame_threshold = math.ceil(0.8 * self.n_rounds)
        if current_round >= endgame_threshold and stock_health in ['Healthy', 'Moderate']:
            cooperate_probability += 0.1
        if self._is_in_recovery_mode(state, history):
            cooperate_probability = 0.95
        if self._should_forgive(history):
            cooperate_probability += 0.1
        if self._all_cooperated_historically(history):
            cooperate_probability = 0.95
        final_probability = min(cooperate_probability, 0.95)
        if random.random() < final_probability:
            return Action.C
        else:
            return Action.D

    def _is_in_recovery_mode(self, state: CommonPoolState, history: PlayerHistory) -> bool:
        """Check if we're in recovery mode due to severely depleted stock."""
        if state.current_stock >= 0.1 * self.capacity:
            return False
        if len(history.my_actions) < 2:
            return False
        recent_rounds = min(3, len(history.my_actions))
        low_stock_count = 0
        for i in range(1, recent_rounds + 1):
            if state.current_stock < 0.1 * self.capacity:
                low_stock_count += 1
            else:
                break
        return low_stock_count >= 2

    def _should_forgive(self, history: PlayerHistory) -> bool:
        """Check if any previously low-cooperating player should be forgiven."""
        if len(history.my_actions) < 4:
            return False
        recent_actions = history.opponent_actions[-2:, :]
        earlier_actions = history.opponent_actions[:-2, :]
        if len(earlier_actions) == 0:
            return False
        earlier_cooperation = np.mean(earlier_actions, axis=0)
        recent_cooperation = np.mean(recent_actions, axis=0)
        low_cooperators = earlier_cooperation < 0.3
        recent_full_cooperation = recent_cooperation >= 0.99
        return np.any(low_cooperators & recent_full_cooperation)

    def _all_cooperated_historically(self, history: PlayerHistory) -> bool:
        """Check if all players have cooperated in all previous rounds."""
        if len(history.my_actions) == 0:
            return False
        my_cooperation_rate = np.mean(history.my_actions)
        opponent_cooperation_rates = np.mean(history.opponent_actions, axis=0)
        all_opponents_cooperated = np.all(opponent_cooperation_rates >= 0.99)
        return my_cooperation_rate >= 0.99 and all_opponents_cooperated

class Strategy_COOPERATIVE_47(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Steward"
    
    Prioritizes long-term sustainability while being adaptive to opponent behavior.
    Starts cooperative and adjusts based on resource health and opponent cooperation levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = state.round_number
        current_stock = state.current_stock
        if current_stock < self.capacity / (4 * self.n_players):
            return Action.C
        if current_round == self.n_rounds - 1:
            if current_stock >= self.capacity / 2:
                return Action.C
            else:
                return Action.D
        stock_condition = self._assess_stock_health(current_stock)
        coop_rate = self._calculate_cooperation_rate(history)
        adjusted_thresholds = self._adjust_thresholds()
        if stock_condition == 'Healthy':
            if coop_rate >= 0.6:
                return Action.C
            elif coop_rate >= 0.3:
                return Action.C if random.random() < 0.8 else Action.D
            else:
                return Action.D
        elif stock_condition == 'Stressed':
            if coop_rate >= 0.5:
                return Action.C
            else:
                return Action.C if random.random() < 0.6 else Action.D
        elif coop_rate >= 0.7:
            return Action.C
        else:
            return Action.C if random.random() < 0.4 else Action.D

    def _assess_stock_health(self, current_stock):
        """Classify current stock condition"""
        if current_stock >= 0.7 * self.capacity:
            return 'Healthy'
        elif current_stock >= 0.3 * self.capacity:
            return 'Stressed'
        else:
            return 'Critical'

    def _calculate_cooperation_rate(self, history):
        """Calculate cooperation rate from recent rounds"""
        rounds_completed = history.round_number
        lookback_rounds = min(3, rounds_completed)
        if lookback_rounds == 0:
            return 0.5
        total_cooperations = 0
        total_actions = 0
        for round_idx in range(rounds_completed - lookback_rounds, rounds_completed):
            if history.my_actions[round_idx]:
                total_cooperations += 1
            total_actions += 1
            for opponent_idx in range(self.n_players - 1):
                if history.opponent_actions[round_idx, opponent_idx]:
                    total_cooperations += 1
                total_actions += 1
        return total_cooperations / total_actions if total_actions > 0 else 0.5

    def _adjust_thresholds(self):
        """Adjust cooperation thresholds based on game parameters"""
        base_thresholds = {'high': 0.6, 'medium': 0.5, 'low': 0.3}
        if self.n_rounds > 10:
            for key in base_thresholds:
                base_thresholds[key] *= 0.9
        if self.n_players > 6:
            for key in base_thresholds:
                base_thresholds[key] *= 1.1
        return base_thresholds

class Strategy_COOPERATIVE_48(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Guardian of the Commons"
    
    Prioritizes long-term sustainability while being adaptive to opponent behaviors.
    Uses Stock Health Index and cooperation history to make context-sensitive decisions.
    Balances cooperative ideals with defensive mechanisms against exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.recovery_mode = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = state.round_number
        current_stock = state.current_stock
        shi = current_stock / self.capacity
        if current_round == self.n_rounds - 1:
            overall_coop_rate = self._calculate_overall_cooperation_rate(history)
            if shi >= 0.7 and overall_coop_rate >= 0.5:
                return Action.C
            else:
                return Action.D
        if shi <= 0.3:
            return Action.D
        if current_stock < self.n_players:
            return Action.D
        if current_stock >= 0.9 * self.capacity and current_round > 0:
            return Action.C
        if current_round > 0:
            prev_round_defectors = sum(history.opponent_actions[-1, :] == False)
            if prev_round_defectors > 0.7 * (self.n_players - 1):
                return Action.D
        if self._is_sustained_low_cooperation(history):
            return Action.D
        return self._adaptive_cooperation_decision(state, history)

    def _calculate_overall_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate overall cooperation rate across all players and rounds"""
        total_actions = history.opponent_actions.size + len(history.my_actions)
        total_cooperations = np.sum(history.opponent_actions) + np.sum(history.my_actions)
        return total_cooperations / total_actions if total_actions > 0 else 0.0

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate cooperation rate for last 3 rounds"""
        rounds_to_check = min(3, len(history.my_actions))
        if rounds_to_check == 0:
            return 0.0
        recent_opponent_actions = history.opponent_actions[-rounds_to_check:, :]
        recent_my_actions = history.my_actions[-rounds_to_check:]
        total_recent_actions = recent_opponent_actions.size + len(recent_my_actions)
        total_recent_cooperations = np.sum(recent_opponent_actions) + np.sum(recent_my_actions)
        return total_recent_cooperations / total_recent_actions if total_recent_actions > 0 else 0.0

    def _is_sustained_low_cooperation(self, history: PlayerHistory) -> bool:
        """Check if cooperation rate has been below 30% for 3+ consecutive rounds"""
        if len(history.my_actions) < 3:
            return False
        for i in range(3):
            round_idx = -(i + 1)
            round_actions = np.concatenate([history.opponent_actions[round_idx, :], [history.my_actions[round_idx]]])
            round_coop_rate = np.sum(round_actions) / len(round_actions)
            if round_coop_rate >= 0.3:
                return False
        return True

    def _adaptive_cooperation_decision(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        """Main adaptive cooperation logic using weighted cooperation rates"""
        shi = state.current_stock / self.capacity
        current_round = state.round_number
        cooperation_threshold = 0.4 + shi * 0.3
        if shi < 0.5:
            cooperation_threshold -= 0.1
            self.recovery_mode = True
        elif shi > 0.6 and self.recovery_mode:
            self.recovery_mode = False
        if current_round >= self.n_rounds - 3:
            rounds_from_end = self.n_rounds - current_round
            cooperation_threshold -= 0.1 * (3 - rounds_from_end)
        recent_coop_rate = self._calculate_recent_cooperation_rate(history)
        overall_coop_rate = self._calculate_overall_cooperation_rate(history)
        weighted_cooperation = 0.6 * recent_coop_rate + 0.4 * overall_coop_rate
        if abs(weighted_cooperation - cooperation_threshold) <= 0.05:
            return Action.C if shi > 0.6 else Action.D
        return Action.C if weighted_cooperation >= cooperation_threshold else Action.D

class Strategy_COOPERATIVE_49(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Guardian"
    
    Prioritizes long-term sustainability while being adaptive to opponent behavior.
    Maintains high stock levels through cooperation but includes defensive mechanisms
    against excessive exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        final_round = self.game_description.n_rounds - 1
        current_round = state.round_number
        stock = state.current_stock
        stock_health = self._assess_stock_health(stock, capacity)
        environment = self._analyze_opponent_behavior(history, n)
        if current_round == final_round:
            return self._final_round_logic(stock_health, environment, history)
        if environment == 'COOPERATIVE' and self._count_consecutive_cooperative(history) >= 2:
            if stock_health != 'CRITICAL':
                return Action.C
        if stock_health == 'HEALTHY':
            if environment in ['COOPERATIVE', 'MIXED']:
                return Action.C
            else:
                return Action.D
        elif stock_health == 'STRESSED':
            if environment == 'COOPERATIVE':
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _assess_stock_health(self, stock: float, capacity: int) -> str:
        """Assess the current stock condition."""
        if stock >= 0.8 * capacity:
            return 'HEALTHY'
        elif stock >= 0.4 * capacity:
            return 'STRESSED'
        else:
            return 'CRITICAL'

    def _analyze_opponent_behavior(self, history: PlayerHistory, n: int) -> str:
        """Track the defection rate from the previous round."""
        if len(history.opponent_actions) == 0:
            return 'COOPERATIVE'
        last_round_actions = history.opponent_actions[-1, :]
        defectors = sum((1 for action in last_round_actions if not action))
        defection_rate = defectors / n
        if defection_rate <= 0.3:
            return 'COOPERATIVE'
        elif defection_rate <= 0.6:
            return 'MIXED'
        else:
            return 'HOSTILE'

    def _final_round_logic(self, stock_health: str, environment: str, history: PlayerHistory) -> Action:
        """Logic for the final round."""
        if stock_health == 'CRITICAL':
            return Action.D
        elif stock_health == 'HEALTHY' and environment == 'COOPERATIVE':
            return Action.C
        else:
            return Action.D

    def _count_consecutive_cooperative(self, history: PlayerHistory) -> int:
        """Count consecutive cooperative rounds from the end."""
        if len(history.opponent_actions) < 2:
            return 0
        n = self.game_description.n_players
        consecutive = 0
        for round_idx in range(len(history.opponent_actions) - 1, -1, -1):
            round_actions = history.opponent_actions[round_idx, :]
            defectors = sum((1 for action in round_actions if not action))
            defection_rate = defectors / n
            if defection_rate <= 0.3:
                consecutive += 1
            else:
                break
        return consecutive

class Strategy_COOPERATIVE_50(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Guardian"
    
    Prioritizes long-term sustainability while being generous toward cooperation 
    and measured in retaliation. Adapts behavior based on resource health and 
    opponent cooperation patterns.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defection_streak = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.defection_streak = 0
            return Action.C
        current_round = state.round_number
        if current_round <= 2:
            self.defection_streak = 0
            return Action.C
        stock_health = self._assess_stock_health(state.current_stock)
        weighted_coop_rate = self._calculate_weighted_cooperation_rate(history)
        action = self._handle_edge_cases(state, history)
        if action is not None:
            self._update_defection_streak(action)
            return action
        action = self._make_main_decision(stock_health, weighted_coop_rate, current_round, history)
        self._update_defection_streak(action)
        return action

    def _assess_stock_health(self, current_stock: float) -> str:
        """Assess the health of the stock."""
        capacity = self.game_description.capacity
        if current_stock >= 0.7 * capacity:
            return 'Healthy'
        elif current_stock >= 0.4 * capacity:
            return 'Moderate'
        else:
            return 'Critical'

    def _calculate_weighted_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate weighted cooperation rate of opponents."""
        if history.round_number == 0:
            return 1.0
        recent_window = min(3, history.round_number)
        recent_actions = history.opponent_actions[-recent_window:, :]
        recent_rate = np.mean(recent_actions) if recent_window > 0 else 1.0
        overall_rate = np.mean(history.opponent_actions)
        return 0.6 * recent_rate + 0.4 * overall_rate

    def _handle_edge_cases(self, state: CommonPoolState, history: PlayerHistory) -> Action | None:
        """Handle special edge cases."""
        if state.current_stock == 0:
            recent_my_actions = history.my_actions[-2:] if history.round_number >= 2 else history.my_actions
            if len(recent_my_actions) < 2 or np.sum(recent_my_actions) < 2:
                return Action.C
        if history.round_number > 0:
            last_round_all_actions = np.concatenate([[history.my_actions[-1]], history.opponent_actions[-1, :]])
            if np.sum(last_round_all_actions) == 0:
                return Action.C
        if history.round_number > 0:
            last_round_all_actions = np.concatenate([[history.my_actions[-1]], history.opponent_actions[-1, :]])
            if np.sum(last_round_all_actions) == len(last_round_all_actions):
                return Action.C
        stock_health = self._assess_stock_health(state.current_stock)
        if stock_health == 'Healthy' and history.round_number >= 3:
            recent_my_actions = history.my_actions[-3:]
            my_recent_coop_rate = np.mean(recent_my_actions)
            if my_recent_coop_rate < 0.5:
                return Action.C
        return None

    def _make_main_decision(self, stock_health: str, weighted_coop_rate: float, current_round: int, history: PlayerHistory) -> Action:
        """Main decision logic based on stock health and cooperation rates."""
        is_end_game = current_round >= self.game_description.n_rounds - 2
        if stock_health == 'Critical':
            threshold = 0.7 if is_end_game else 0.6
            if weighted_coop_rate >= threshold:
                return Action.C
            else:
                return Action.D
        elif stock_health == 'Moderate':
            if is_end_game:
                threshold = 0.7
                return Action.C if weighted_coop_rate >= threshold else Action.D
            elif weighted_coop_rate >= 0.5:
                return Action.C
            elif weighted_coop_rate >= 0.3:
                return Action.C if random.random() < 0.7 else Action.D
            else:
                return Action.D
        else:
            base_threshold = 0.6 if is_end_game else 0.4
            if weighted_coop_rate >= base_threshold:
                return Action.C
            elif self.defection_streak < 2:
                return Action.D
            else:
                return Action.C

    def _update_defection_streak(self, action: Action):
        """Update the defection streak counter."""
        if action == Action.D:
            self.defection_streak += 1
        else:
            self.defection_streak = 0

class Strategy_COOPERATIVE_51(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Steward"
    
    Prioritizes long-term sustainability while being adaptive to opponent behavior.
    Uses Stock Health Index and Cooperation Rate to make informed decisions.
    Implements forgiveness protocols and emergency sustainability checks.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.forgiveness_counter = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = state.round_number
        current_stock = state.current_stock
        shi = current_stock / self.capacity
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx, :])
        if history.my_actions[last_round_idx]:
            cooperators_last_round += 1
        cooperation_rate = cooperators_last_round / self.n_players
        if current_stock > 0:
            consumption_if_all_defect = self.n_players * (current_stock / self.n_players)
            stock_after_consumption = current_stock - consumption_if_all_defect
            if stock_after_consumption <= 0.2 * self.capacity:
                return Action.C
        if current_round == self.n_rounds:
            if shi >= 0.5 and cooperation_rate >= 0.5:
                return Action.C
            elif shi >= 0.7:
                return Action.C
            else:
                return Action.D
        if shi <= 0.2:
            return Action.C
        if shi >= 0.7:
            return Action.C
        elif shi <= 0.3:
            return Action.D
        elif cooperation_rate >= 0.6:
            return Action.C
        elif cooperation_rate >= 0.3:
            if history.round_number >= 2:
                prev_round_idx = history.round_number - 2
                prev_cooperators = sum(history.opponent_actions[prev_round_idx, :])
                if history.my_actions[prev_round_idx]:
                    prev_cooperators += 1
                prev_cooperation_rate = prev_cooperators / self.n_players
                if cooperation_rate > prev_cooperation_rate:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.C
        else:
            if history.round_number >= 2:
                prev_round_idx = history.round_number - 2
                prev_cooperators = sum(history.opponent_actions[prev_round_idx, :])
                if history.my_actions[prev_round_idx]:
                    prev_cooperators += 1
                prev_cooperation_rate = prev_cooperators / self.n_players
                if prev_cooperation_rate >= 0.3:
                    self.forgiveness_counter = 0
            self.forgiveness_counter += 1
            if self.forgiveness_counter % 3 == 0:
                return Action.C
            else:
                return Action.D

class Strategy_COOPERATIVE_52(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Guardian"
    
    Prioritizes long-term resource sustainability while being adaptive to opponent behavior.
    Uses dynamic cooperation thresholds based on resource health and includes protective
    mechanisms against exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.base_threshold = 0.6
        self.consecutive_defections = 0
        self.test_cooperation_active = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.consecutive_defections = 0
            self.test_cooperation_active = False
            return Action.C
        health = state.current_stock / self.game_description.capacity
        if state.current_stock < 0.15 * self.game_description.capacity:
            self.consecutive_defections += 1
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            last_round_coop_rate = self._get_cooperation_rate(history, -1)
            if health >= 0.5 and last_round_coop_rate >= 0.5:
                return Action.C
            else:
                return Action.D
        adjusted_threshold = self.base_threshold * (2 - health)
        last_round_coop_rate = self._get_cooperation_rate(history, -1)
        if last_round_coop_rate >= adjusted_threshold:
            self.consecutive_defections = 0
            self.test_cooperation_active = False
            return Action.C
        if self._is_trend_improving(history) and health > 0.3:
            self.consecutive_defections = 0
            self.test_cooperation_active = False
            return Action.C
        if self._should_test_cooperation(history, health):
            self.test_cooperation_active = True
            return Action.C
        if self.test_cooperation_active:
            self.test_cooperation_active = False
            if last_round_coop_rate < 0.5:
                self.consecutive_defections += 1
                return Action.D
        self.consecutive_defections += 1
        return Action.D

    def _get_cooperation_rate(self, history: PlayerHistory, round_offset: int) -> float:
        """Returns fraction of players who cooperated in specified round"""
        if history.round_number + round_offset < 0:
            return 0.0
        round_index = history.round_number + round_offset
        if round_index >= len(history.opponent_actions):
            return 0.0
        cooperators = np.sum(history.opponent_actions[round_index, :])
        total_opponents = self.game_description.n_players - 1
        return cooperators / total_opponents if total_opponents > 0 else 0.0

    def _is_trend_improving(self, history: PlayerHistory) -> bool:
        """Returns True if cooperation rate improved in majority of last 3 rounds"""
        if history.round_number < 2:
            return False
        rounds_to_check = min(3, history.round_number)
        improvements = 0
        for i in range(1, rounds_to_check + 1):
            if history.round_number - i < 0:
                continue
            current_rate = self._get_cooperation_rate(history, -i)
            previous_rate = self._get_cooperation_rate(history, -(i + 1))
            if current_rate > previous_rate:
                improvements += 1
        return improvements >= 2

    def _should_test_cooperation(self, history: PlayerHistory, health: float) -> bool:
        """Returns True if conditions met for forgiveness test"""
        if self.consecutive_defections < 2 or health <= 0.25:
            return False
        if self.test_cooperation_active:
            return False
        return self.consecutive_defections >= 2

class Strategy_COOPERATIVE_53(BaseStrategy):
    """
    Adaptive Stewardship strategy that balances sustainability with strategic responsiveness.
    Uses stock health assessment, opponent behavior tracking, and graduated punishment/forgiveness.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_rounds_left = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        health_ratio = state.current_stock / self.game_description.capacity
        if health_ratio >= 0.7:
            base_cooperation_tendency = 0.9
        elif health_ratio >= 0.4:
            base_cooperation_tendency = 0.7
        elif health_ratio >= 0.2:
            base_cooperation_tendency = 0.5
        else:
            base_cooperation_tendency = 0.3
        recent_rounds = min(3, history.round_number)
        if recent_rounds > 0:
            recent_opponent_actions = history.opponent_actions[-recent_rounds:, :]
            total_recent_actions = recent_opponent_actions.size
            total_recent_cooperations = np.sum(recent_opponent_actions)
            recent_cooperation_rate = total_recent_cooperations / total_recent_actions if total_recent_actions > 0 else 1.0
        else:
            recent_cooperation_rate = 1.0
        adjusted_tendency = base_cooperation_tendency
        if self.punishment_rounds_left > 0:
            adjusted_tendency -= 0.4
            self.punishment_rounds_left -= 1
        elif recent_cooperation_rate < 0.3:
            adjusted_tendency -= 0.4
            self.punishment_rounds_left = 1
        elif recent_cooperation_rate > 0.7:
            adjusted_tendency += 0.2
        rounds_remaining = self.game_description.n_rounds - state.round_number
        if rounds_remaining <= 2:
            if health_ratio > 0.5:
                adjusted_tendency += 0.3
            else:
                adjusted_tendency -= 0.2
        if health_ratio < 0.1 and history.round_number > 0:
            last_round_cooperations = np.sum(history.opponent_actions[-1, :])
            last_round_total = history.opponent_actions.shape[1]
            if last_round_cooperations / last_round_total >= 0.5:
                adjusted_tendency = max(adjusted_tendency, 0.7)
            else:
                adjusted_tendency = min(adjusted_tendency, 0.3)
        if history.round_number >= 2:
            last_two_rounds = history.opponent_actions[-2:, :]
            if np.sum(last_two_rounds) == 0:
                if np.all(history.my_actions[-2:]):
                    adjusted_tendency = min(adjusted_tendency, 0.3)
        if adjusted_tendency > 0.6:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_54(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Trust"
    
    Prioritizes long-term sustainability while building and maintaining trust through 
    conditional cooperation. Uses stock health assessment and opponent behavior analysis 
    to make adaptive decisions with forgiveness mechanisms.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = state.round_number + 1
        stock = state.current_stock
        capacity = self.game_description.capacity
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if stock < 0.3 * capacity:
            return Action.C
        if stock < n:
            return Action.C
        recent_rounds = min(3, current_round - 1)
        recent_opponent_actions = history.opponent_actions[-recent_rounds:, :]
        total_opponent_actions = recent_opponent_actions.size
        opponent_defections = np.sum(recent_opponent_actions == False)
        defection_rate = opponent_defections / total_opponent_actions if total_opponent_actions > 0 else 0
        recent_my_actions = history.my_actions[-recent_rounds:]
        my_cooperations = np.sum(recent_my_actions == True)
        my_coop_rate = my_cooperations / recent_rounds if recent_rounds > 0 else 1.0
        if current_round == r:
            if stock < 0.3 * capacity:
                return Action.C
            last_2_rounds = min(2, current_round - 1)
            if last_2_rounds > 0:
                recent_2_opponent_actions = history.opponent_actions[-last_2_rounds:, :]
                recent_2_defections = np.sum(recent_2_opponent_actions == False)
                recent_2_rate = recent_2_defections / recent_2_opponent_actions.size
                if recent_2_rate > 0.7:
                    return Action.D
            return Action.C
        if current_round % 4 == 0:
            recent_rounds = min(2, current_round - 1)
            if recent_rounds > 0:
                recent_opponent_actions = history.opponent_actions[-recent_rounds:, :]
                opponent_defections = np.sum(recent_opponent_actions == False)
                defection_rate = opponent_defections / recent_opponent_actions.size
        if defection_rate <= 0.3:
            return Action.C
        elif defection_rate <= 0.6:
            if stock >= 0.7 * capacity:
                prob = 0.8
            else:
                prob = 0.6
            return Action.C if random.random() < prob else Action.D
        elif my_coop_rate > 0.7:
            return Action.D
        else:
            return Action.C if random.random() < 0.3 else Action.D

class Strategy_COOPERATIVE_55(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Guardian"
    
    This strategy balances long-term sustainability with adaptive responses to opponent behavior.
    It maintains cooperative tendencies while protecting against exploitation and stock depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_threshold = 0.3
        self.base_cooperation_probability = 0.8

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        health_ratio = state.current_stock / self.game_description.capacity
        rounds_left = self.game_description.n_rounds - state.round_number
        recent_cooperation_rate = self._calculate_recent_cooperation_rate(history)
        overall_cooperation_rate = self._calculate_overall_cooperation_rate(history)
        cooperation_trend = self._analyze_cooperation_trend(history)
        if health_ratio <= self.critical_threshold:
            if recent_cooperation_rate < 0.4:
                return Action.D
            else:
                return Action.C
        if state.current_stock == 0:
            return Action.C
        if health_ratio >= 0.95:
            return Action.C
        if overall_cooperation_rate < 0.2 and health_ratio > 0.5:
            if self._check_two_consecutive_majority_defections(history):
                return Action.D
            else:
                return Action.C
        cooperation_probability = self.base_cooperation_probability
        if overall_cooperation_rate >= 0.7:
            cooperation_probability += 0.15
        elif overall_cooperation_rate < 0.4:
            cooperation_probability -= 0.3
        if cooperation_trend == 'increasing':
            cooperation_probability += 0.1
        elif cooperation_trend == 'decreasing':
            cooperation_probability -= 0.2
        if self._check_forgiveness_condition(history):
            cooperation_probability += 0.2
        if rounds_left <= 3:
            cooperation_probability -= 0.1
        if rounds_left == 1:
            if overall_cooperation_rate >= 0.5:
                return Action.C
            else:
                return Action.D
        if health_ratio >= 0.8:
            cooperation_probability += 0.1
        if cooperation_probability >= random.random():
            return Action.C
        else:
            return Action.D

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate cooperation rate in last 3 rounds (or all if fewer)"""
        if len(history.opponent_actions) == 0:
            return 1.0
        recent_rounds = min(3, len(history.opponent_actions))
        recent_actions = history.opponent_actions[-recent_rounds:, :]
        total_actions = recent_actions.size
        total_cooperations = np.sum(recent_actions)
        return total_cooperations / total_actions if total_actions > 0 else 1.0

    def _calculate_overall_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate overall cooperation rate across all previous rounds"""
        if len(history.opponent_actions) == 0:
            return 1.0
        total_actions = history.opponent_actions.size
        total_cooperations = np.sum(history.opponent_actions)
        return total_cooperations / total_actions if total_actions > 0 else 1.0

    def _analyze_cooperation_trend(self, history: PlayerHistory) -> str:
        """Analyze if cooperation is increasing, decreasing, or stable"""
        if len(history.opponent_actions) < 4:
            return 'stable'
        mid_point = len(history.opponent_actions) // 2
        first_half = history.opponent_actions[:mid_point, :]
        second_half = history.opponent_actions[mid_point:, :]
        first_half_rate = np.mean(first_half) if first_half.size > 0 else 0.5
        second_half_rate = np.mean(second_half) if second_half.size > 0 else 0.5
        difference = second_half_rate - first_half_rate
        if difference > 0.1:
            return 'increasing'
        elif difference < -0.1:
            return 'decreasing'
        else:
            return 'stable'

    def _check_forgiveness_condition(self, history: PlayerHistory) -> bool:
        """Check if cooperation rate has improved significantly in recent rounds"""
        if len(history.opponent_actions) < 6:
            return False
        recent_rate = np.mean(history.opponent_actions[-3:, :])
        previous_rate = np.mean(history.opponent_actions[-6:-3, :])
        return recent_rate - previous_rate > 0.3

    def _check_two_consecutive_majority_defections(self, history: PlayerHistory) -> bool:
        """Check if majority defected in last two consecutive rounds"""
        if len(history.opponent_actions) < 2:
            return False
        last_round_cooperation = np.mean(history.opponent_actions[-1, :])
        second_last_cooperation = np.mean(history.opponent_actions[-2, :])
        return last_round_cooperation < 0.5 and second_last_cooperation < 0.5

class Strategy_COOPERATIVE_56(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Guardian"
    
    Prioritizes long-term sustainability while being adaptive to opponent behavior.
    Uses Stock Health Index and cooperation tracking to make decisions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.forgiveness_bonus = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_num = history.round_number + 1
        current_stock = state.current_stock
        SHI = current_stock / self.capacity
        if round_num <= max(3, self.total_rounds * 0.25):
            return Action.C
        if current_stock < self.n:
            return Action.D
        recent_coop_rate = self._calculate_cooperation_rate(history, 3)
        if round_num % 4 == 0:
            self.forgiveness_bonus = 0.2
        else:
            self.forgiveness_bonus *= 0.5
        if round_num > self.total_rounds * 0.85:
            return self._end_game_strategy(SHI, history)
        if SHI >= 0.95:
            return Action.C
        return self._adaptive_decision(SHI, recent_coop_rate)

    def _calculate_cooperation_rate(self, history: PlayerHistory, window: int) -> float:
        """Calculate cooperation rate of opponents in recent rounds."""
        if history.round_number == 0:
            return 1.0
        start_round = max(0, history.round_number - window)
        recent_actions = history.opponent_actions[start_round:, :]
        total_actions = recent_actions.size
        if total_actions == 0:
            return 1.0
        total_cooperations = np.sum(recent_actions)
        return total_cooperations / total_actions

    def _end_game_strategy(self, SHI: float, history: PlayerHistory) -> Action:
        """Strategy for final rounds."""
        if SHI <= 0.6:
            if history.round_number > 0:
                last_round_coop = np.all(history.opponent_actions[-1, :])
                if last_round_coop:
                    return Action.C
            return Action.D
        if history.round_number > 0:
            last_round_cooperators = np.sum(history.opponent_actions[-1, :])
            if last_round_cooperators > (self.n - 1) / 2:
                return Action.C
        return Action.D

    def _adaptive_decision(self, SHI: float, recent_coop_rate: float) -> Action:
        """Main adaptive decision logic based on stock health and cooperation."""
        base_coop_prob = 0.0
        if SHI > 0.8:
            if recent_coop_rate > 0.7:
                base_coop_prob = 1.0
            elif recent_coop_rate > 0.4:
                base_coop_prob = 0.8
            else:
                base_coop_prob = 0.6
        elif SHI >= 0.5:
            if recent_coop_rate > 0.6:
                base_coop_prob = 1.0
            elif recent_coop_rate > 0.3:
                base_coop_prob = 0.7
            else:
                base_coop_prob = 0.0
        elif recent_coop_rate > 0.8:
            base_coop_prob = 1.0
        else:
            base_coop_prob = 0.0
        final_coop_prob = min(1.0, base_coop_prob + self.forgiveness_bonus)
        return Action.C if random.random() < final_coop_prob else Action.D

class Strategy_COOPERATIVE_57(BaseStrategy):
    """
    Sustainable Steward: An adaptive cooperative strategy that prioritizes long-term 
    sustainability while defending against exploitation. Makes decisions based on 
    resource health and opponent behavior patterns using a cooperation threshold system.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        stock_ratio = state.current_stock / self.capacity
        round_number = state.round_number
        window_size = min(5, history.round_number)
        recent_actions = history.opponent_actions[-window_size:, :]
        cooperation_rates = np.mean(recent_actions, axis=0)
        cooperator_count = np.sum(cooperation_rates > 0.7)
        defector_count = np.sum(cooperation_rates < 0.3)
        if stock_ratio >= 0.8:
            if defector_count <= self.n_players / 3:
                return Action.C
            else:
                return Action.D
        elif stock_ratio >= 0.3:
            if cooperator_count >= self.n_players / 2:
                return Action.C
            elif defector_count >= 2 * self.n_players / 3:
                return Action.D
            else:
                last_round_actions = history.opponent_actions[-1, :]
                majority_cooperated = np.mean(last_round_actions) > 0.5
                return Action.C if majority_cooperated else Action.D
        elif round_number >= self.n_rounds - 2:
            return Action.C
        elif cooperator_count >= 2 * self.n_players / 3:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_58(BaseStrategy):
    """
    Sustainable Steward: An adaptive cooperative strategy that prioritizes long-term 
    sustainability while being forgiving to mistakes and adaptive to group dynamics.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = state.round_number
        current_stock = state.current_stock
        if current_stock < self.capacity * 0.3:
            return Action.C
        last_round_cooperators = sum(history.opponent_actions[-1, :])
        if history.my_actions[-1]:
            last_round_cooperators += 1
        cooperation_rate = last_round_cooperators / self.n_players
        if current_round == self.n_rounds - 1:
            if current_stock < self.capacity * 0.2:
                return Action.C
            elif self._get_recent_cooperation_rate(history, 3) >= 0.6:
                return Action.C
            else:
                return Action.D
        if cooperation_rate >= 0.6:
            return Action.C
        elif cooperation_rate <= 0.3:
            return Action.D
        else:
            return self._graduated_response(history, cooperation_rate)

    def _graduated_response(self, history: PlayerHistory, cooperation_rate: float) -> Action:
        """Apply graduated response based on defection streak."""
        defection_streak = self._count_defection_streak(history)
        was_defecting = not history.my_actions[-1] if len(history.my_actions) > 0 else False
        if was_defecting and cooperation_rate > 0.5:
            return Action.C
        if defection_streak == 0:
            return Action.C
        elif defection_streak == 1:
            return Action.C
        elif defection_streak == 2:
            return Action.D
        else:
            return Action.D

    def _count_defection_streak(self, history: PlayerHistory) -> int:
        """Count consecutive rounds where cooperation rate < 0.5."""
        streak = 0
        for round_idx in range(len(history.my_actions) - 1, -1, -1):
            round_cooperators = sum(history.opponent_actions[round_idx, :])
            if history.my_actions[round_idx]:
                round_cooperators += 1
            round_cooperation_rate = round_cooperators / self.n_players
            if round_cooperation_rate < 0.5:
                streak += 1
            else:
                break
        return streak

    def _get_recent_cooperation_rate(self, history: PlayerHistory, num_rounds: int) -> float:
        """Get average cooperation rate over the last num_rounds."""
        if len(history.my_actions) == 0:
            return 0.0
        start_idx = max(0, len(history.my_actions) - num_rounds)
        total_cooperators = 0
        total_decisions = 0
        for round_idx in range(start_idx, len(history.my_actions)):
            round_cooperators = sum(history.opponent_actions[round_idx, :])
            if history.my_actions[round_idx]:
                round_cooperators += 1
            total_cooperators += round_cooperators
            total_decisions += self.n_players
        return total_cooperators / total_decisions if total_decisions > 0 else 0.0

class Strategy_COOPERATIVE_59(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Guardian"
    
    Prioritizes long-term sustainability while being cooperative by default,
    with adaptive mechanisms to protect against exploitation and resource collapse.
    Uses Stock Health Index to determine cooperation thresholds across three phases:
    Sustainable Cooperation, Conservation Mode, and Crisis Mode.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defensive_mode = False
        self.defensive_mode_start = -1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        shi = state.current_stock / self.game_description.capacity
        round_num = state.round_number + 1
        total_rounds = self.game_description.n_rounds
        n = self.game_description.n_players
        prev_round_idx = history.round_number - 1
        prev_defection_count = sum(history.opponent_actions[prev_round_idx, :] == False)
        prev_defection_rate = prev_defection_count / n
        prev_majority_defected = prev_defection_rate > 0.5
        consecutive_majority_defections = 0
        for i in range(min(history.round_number, 5)):
            round_idx = history.round_number - 1 - i
            if round_idx < 0:
                break
            round_defection_rate = sum(history.opponent_actions[round_idx, :] == False) / n
            if round_defection_rate > 0.5:
                consecutive_majority_defections += 1
            else:
                break
        stock_increased_significantly = False
        if history.round_number > 1:
            prev_total_payoff = sum(history.opponent_payoffs[prev_round_idx, :]) + history.my_payoffs[prev_round_idx]
            if history.round_number > 2:
                prev_prev_total_payoff = sum(history.opponent_payoffs[prev_round_idx - 1, :]) + history.my_payoffs[prev_round_idx - 1]
                if prev_total_payoff > prev_prev_total_payoff * 1.1:
                    stock_increased_significantly = True
        if stock_increased_significantly:
            return Action.C
        if round_num == total_rounds:
            if shi >= 0.5:
                return Action.C
            else:
                return Action.D if prev_majority_defected else Action.C
        if round_num == total_rounds - 1:
            if shi >= 0.3:
                return Action.D if prev_defection_rate > 0.6 else Action.C
        if state.current_stock <= self.game_description.capacity / 10:
            return Action.C
        if consecutive_majority_defections >= 3 and shi > 0.2:
            if not self.defensive_mode:
                self.defensive_mode = True
                self.defensive_mode_start = round_num
        if self.defensive_mode and consecutive_majority_defections == 0:
            if history.round_number > 1:
                prev_prev_round_idx = history.round_number - 2
                prev_prev_defection_rate = sum(history.opponent_actions[prev_prev_round_idx, :] == False) / n
                if prev_prev_defection_rate <= 0.5:
                    self.defensive_mode = False
        if shi >= 0.6:
            if prev_majority_defected and round_num <= total_rounds - 2 and (consecutive_majority_defections == 1):
                return Action.D
            return Action.C
        elif shi >= 0.3:
            if self.defensive_mode:
                return Action.C if stock_increased_significantly else Action.D
            return Action.D if prev_majority_defected else Action.C
        else:
            return Action.C if prev_defection_rate <= 0.25 else Action.D

class Strategy_COOPERATIVE_60(BaseStrategy):
    """
    Adaptive Stewardship Strategy: Prioritizes long-term resource sustainability while adapting to opponent behavior.
    Maintains cooperative foundation with defensive mechanisms against exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = state.round_number
        stock = state.current_stock
        stock_ratio = stock / self.capacity
        if stock_ratio < 0.1:
            return Action.C
        if stock_ratio < 0.3:
            return Action.C
        window_size = min(3, history.round_number)
        recent_rounds = history.round_number - window_size
        cooperator_count = 0
        defector_count = 0
        mixed_count = 0
        for player_idx in range(self.n_players - 1):
            if window_size == 0:
                cooperator_count += 1
                continue
            recent_actions = history.opponent_actions[recent_rounds:, player_idx]
            cooperation_rate = np.mean(recent_actions)
            if cooperation_rate >= 0.67:
                cooperator_count += 1
            elif cooperation_rate >= 0.33:
                mixed_count += 1
            else:
                defector_count += 1
        is_final_round = current_round == self.n_rounds - 1
        if is_final_round:
            if stock_ratio >= 0.4:
                return Action.C
            else:
                return Action.D
        total_opponents = self.n_players - 1
        if defector_count == 0:
            return Action.C
        elif defector_count >= total_opponents / 2:
            if stock_ratio >= 0.6:
                return Action.D
            else:
                return Action.C
        elif history.round_number > 0:
            last_round_defectors = np.sum(history.opponent_actions[-1, :] == False)
            if last_round_defectors <= 1:
                return Action.C
            elif stock_ratio >= 0.5:
                return Action.D
            else:
                return Action.C
        if current_round % 3 == 0 and defector_count > 0:
            return Action.C
        if history.round_number >= 2:
            total_cooperations = np.sum(history.opponent_actions) + np.sum(history.my_actions)
            total_actions = history.round_number * self.n_players
            group_cooperation_rate = total_cooperations / total_actions if total_actions > 0 else 1.0
            if group_cooperation_rate < 0.4 and stock_ratio < 0.6:
                return Action.C
        return Action.C

class Strategy_COOPERATIVE_61(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Guardian"
    
    Prioritizes long-term sustainability while being adaptive to opponent behavior.
    Starts cooperatively but has mechanisms to protect against exploitation and 
    encourage cooperation through calculated responses.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.consecutive_low_cooperation = 0
        self.last_cooperation_rate = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        rounds_remaining = self.game_description.n_rounds - current_round + 1
        if current_round <= 3:
            return Action.C
        cooperation_rate = self._get_cooperation_rate(history)
        stock_health = state.current_stock / self.game_description.capacity
        if cooperation_rate < 0.4:
            self.consecutive_low_cooperation += 1
        else:
            self.consecutive_low_cooperation = 0
        if stock_health < 0.2:
            if cooperation_rate > 0.6:
                return Action.C
            else:
                return Action.D
        if rounds_remaining <= max(2, math.ceil(self.game_description.n_rounds * 0.2)):
            if stock_health > 0.5 and cooperation_rate > 0.5:
                return Action.C
            else:
                return Action.D
        if cooperation_rate >= 0.7:
            return Action.C
        if cooperation_rate >= 0.4:
            if stock_health > 0.6:
                return Action.C
            else:
                return self._forgiveness_check(cooperation_rate, stock_health)
        if cooperation_rate < 0.4:
            return self._punishment_phase(stock_health)
        return Action.C

    def _get_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate the cooperation rate of opponents in the most recent round."""
        if history.round_number == 0:
            return 1.0
        last_round_actions = history.opponent_actions[-1, :]
        cooperation_count = sum(last_round_actions)
        total_opponents = len(last_round_actions)
        return cooperation_count / total_opponents if total_opponents > 0 else 0.0

    def _punishment_phase(self, stock_health: float) -> Action:
        """Handle punishment phase for low cooperation."""
        if self.consecutive_low_cooperation >= 2:
            if stock_health < 0.3:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

    def _forgiveness_check(self, cooperation_rate: float, stock_health: float) -> Action:
        """Check if forgiveness should be applied."""
        if self.last_cooperation_rate is not None and cooperation_rate > self.last_cooperation_rate:
            self.last_cooperation_rate = cooperation_rate
            return Action.C
        if stock_health > 0.4 and random.random() < 0.3:
            self.last_cooperation_rate = cooperation_rate
            return Action.C
        self.last_cooperation_rate = cooperation_rate
        return Action.D

class Strategy_COOPERATIVE_62(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Stewardship"
    
    Prioritizes long-term sustainability while adapting to opponent behavior.
    Uses dynamic cooperation thresholds based on stock levels and implements
    graduated responses to group behavior patterns.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number
        stock_level = state.current_stock
        if current_round == self.n_rounds - 1:
            return self._final_round_decision(stock_level, history)
        stock_percentage = stock_level / self.capacity
        if stock_percentage >= 0.8:
            return Action.C
        elif stock_percentage >= 0.4:
            return self._medium_stock_decision(history)
        else:
            return self._conservation_mode_decision(history)

    def _final_round_decision(self, stock_level: float, history: PlayerHistory) -> Action:
        """Final round decision based on stock level and recent cooperation."""
        stock_percentage = stock_level / self.capacity
        recent_cooperation_rate = self._calculate_recent_cooperation_rate(history, 3)
        if stock_percentage >= 0.5 and recent_cooperation_rate >= 0.5:
            return Action.C
        else:
            return Action.D

    def _medium_stock_decision(self, history: PlayerHistory) -> Action:
        """Decision logic for medium stock levels (40-79% capacity)."""
        cooperation_score = self._calculate_recent_cooperation_rate(history, 3)
        my_recent_defections = self._count_my_recent_defections(history, 3)
        if cooperation_score >= 0.6:
            return Action.C
        elif cooperation_score >= 0.3:
            if my_recent_defections <= 1:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

    def _conservation_mode_decision(self, history: PlayerHistory) -> Action:
        """Decision logic for low stock levels (< 40% capacity)."""
        recent_defectors = self._count_defectors_last_round(history)
        if recent_defectors <= self.n_players / 3:
            return Action.C
        else:
            return Action.D

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory, lookback_rounds: int) -> float:
        """Calculate cooperation rate over the last N rounds for all players."""
        rounds_to_check = min(lookback_rounds, history.round_number)
        if rounds_to_check == 0:
            return 1.0
        my_cooperations = sum(history.my_actions[-rounds_to_check:])
        opponent_cooperations = 0
        for round_idx in range(-rounds_to_check, 0):
            opponent_cooperations += sum(history.opponent_actions[round_idx, :])
        total_cooperations = my_cooperations + opponent_cooperations
        total_actions = self.n_players * rounds_to_check
        return total_cooperations / total_actions if total_actions > 0 else 1.0

    def _count_my_recent_defections(self, history: PlayerHistory, lookback_rounds: int) -> int:
        """Count my defections in the last N rounds."""
        rounds_to_check = min(lookback_rounds, history.round_number)
        if rounds_to_check == 0:
            return 0
        recent_actions = history.my_actions[-rounds_to_check:]
        return sum((1 for action in recent_actions if not action))

    def _count_defectors_last_round(self, history: PlayerHistory) -> int:
        """Count how many opponents defected in the most recent round."""
        if history.round_number == 0:
            return 0
        last_round_actions = history.opponent_actions[-1, :]
        return sum((1 for action in last_round_actions if not action))

class Strategy_COOPERATIVE_63(BaseStrategy):
    """
    Adaptive Reciprocal Conservation Strategy (ARCS).
    
    Balances cooperative resource stewardship with adaptive responses to opponent behavior.
    Uses a three-phase approach: initial cooperation, adaptive response based on stock health
    and opponent behavior, and endgame sustainability focus.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_num = state.round_number
        stock = state.current_stock
        if round_num <= 3:
            return self._handle_initial_phase(round_num, stock, history)
        elif round_num > self.n_rounds * 0.8:
            return self._handle_endgame(round_num, stock, history)
        else:
            return self._handle_middle_phase(round_num, stock, history)

    def _handle_initial_phase(self, round_num, stock, history):
        """Handle rounds 1-3 with initial cooperation unless stock is critical."""
        critical_threshold = self.capacity * 0.4
        if stock < critical_threshold:
            return Action.D
        return Action.C

    def _handle_endgame(self, round_num, stock, history):
        """Handle last 20% of rounds with sustainability focus."""
        base_cooperate = stock > self.capacity * 0.3
        if stock > self.capacity * 0.5:
            cooperate_prob = 0.9 if base_cooperate else 0.7
        else:
            cooperate_prob = 0.7 if base_cooperate else 0.3
        if len(history.opponent_actions) > 0:
            last_round_cooperators = sum(history.opponent_actions[-1, :])
            majority_cooperated = last_round_cooperators > len(history.opponent_actions[-1, :]) / 2
            if majority_cooperated:
                cooperate_prob = min(1.0, cooperate_prob + 0.2)
            else:
                cooperate_prob = max(0.0, cooperate_prob - 0.2)
        return Action.C if random.random() < cooperate_prob else Action.D

    def _handle_middle_phase(self, round_num, stock, history):
        """Handle middle rounds with three-tier decision system."""
        if stock < self.capacity * 0.2:
            return Action.D
        if stock <= self.capacity * 0.1:
            return Action.D
        if stock >= self.capacity:
            return Action.C
        recent_defection_rate = self._calculate_recent_defection_rate(history, rounds_back=3)
        trend_increasing = self._is_defection_trend_increasing(history)
        if recent_defection_rate > 0.7:
            return Action.D
        elif recent_defection_rate > 0.5 and trend_increasing:
            return Action.D
        elif recent_defection_rate < 0.3:
            return Action.C
        base_prob = 0.7
        if stock < self.capacity * 0.4:
            base_prob *= 0.7
        prob = self._adjust_for_opponent_behavior(base_prob, history)
        prob = self._apply_forgiveness_mechanism(prob, history, stock)
        if self._detect_all_defectors(history):
            prob = 0.2
        return Action.C if random.random() < prob else Action.D

    def _calculate_recent_defection_rate(self, history, rounds_back=3):
        """Calculate defection rate over the last N rounds."""
        if len(history.opponent_actions) == 0:
            return 0.0
        start_round = max(0, len(history.opponent_actions) - rounds_back)
        recent_actions = history.opponent_actions[start_round:, :]
        if recent_actions.size == 0:
            return 0.0
        total_actions = recent_actions.size
        cooperations = np.sum(recent_actions)
        return 1.0 - cooperations / total_actions

    def _is_defection_trend_increasing(self, history):
        """Check if defection trend is increasing over last few rounds."""
        if len(history.opponent_actions) < 3:
            return False
        if len(history.opponent_actions) < 4:
            return False
        recent_2 = history.opponent_actions[-2:, :]
        previous_2 = history.opponent_actions[-4:-2, :]
        recent_defection_rate = 1.0 - np.sum(recent_2) / recent_2.size
        previous_defection_rate = 1.0 - np.sum(previous_2) / previous_2.size
        return recent_defection_rate > previous_defection_rate

    def _adjust_for_opponent_behavior(self, base_prob, history):
        """Adjust cooperation probability based on recent opponent behavior."""
        if len(history.opponent_actions) == 0:
            return base_prob
        prob = base_prob
        if len(history.opponent_actions) > 0:
            last_round_defectors = len(history.opponent_actions[-1, :]) - sum(history.opponent_actions[-1, :])
            prob -= last_round_defectors * 0.15
        rounds_back = min(3, len(history.opponent_actions))
        majority_coop_rounds = 0
        for i in range(rounds_back):
            round_idx = len(history.opponent_actions) - 1 - i
            if round_idx >= 0:
                cooperators = sum(history.opponent_actions[round_idx, :])
                if cooperators > len(history.opponent_actions[round_idx, :]) / 2:
                    majority_coop_rounds += 1
        prob += majority_coop_rounds * 0.1
        return max(0.0, min(1.0, prob))

    def _apply_forgiveness_mechanism(self, prob, history, stock):
        """Apply forgiveness if we've been defecting consecutively."""
        if len(history.my_actions) < 2:
            return prob
        recent_my_actions = history.my_actions[-2:]
        if all((not action for action in recent_my_actions)):
            if stock > self.capacity * 0.3:
                prob += 0.3
        return max(0.0, min(1.0, prob))

    def _detect_all_defectors(self, history):
        """Detect if >90% of opponents defect for 3 consecutive rounds."""
        if len(history.opponent_actions) < 3:
            return False
        for i in range(3):
            round_idx = len(history.opponent_actions) - 1 - i
            if round_idx < 0:
                return False
            cooperators = sum(history.opponent_actions[round_idx, :])
            total_opponents = len(history.opponent_actions[round_idx, :])
            defection_rate = 1.0 - cooperators / total_opponents
            if defection_rate <= 0.9:
                return False
        return True

class Strategy_COOPERATIVE_64(BaseStrategy):
    """
    Adaptive Sustainability Strategy (ASS) - Prioritizes long-term resource sustainability
    while adapting to opponent behaviors through resource health assessment and cooperation tracking.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.consecutive_high_defection_rounds = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        total_rounds = self.game_description.n_rounds
        current_round = state.round_number
        stock = state.current_stock
        resource_state = self._assess_resource_health(stock, capacity)
        cooperation_rate = self._calculate_cooperation_rate(history)
        if current_round == total_rounds - 1:
            return self._last_round_decision(resource_state, cooperation_rate, history)
        return self._main_decision_logic(resource_state, cooperation_rate, history, stock, capacity, total_rounds)

    def _assess_resource_health(self, stock, capacity):
        """Assess current resource state"""
        if stock >= 0.7 * capacity:
            return 'Healthy'
        elif stock >= 0.3 * capacity:
            return 'Stressed'
        else:
            return 'Critical'

    def _calculate_cooperation_rate(self, history):
        """Calculate opponent cooperation rate over recent rounds"""
        rounds_to_check = min(3, len(history.opponent_actions))
        if rounds_to_check == 0:
            return 0.5
        recent_actions = history.opponent_actions[-rounds_to_check:, :]
        total_actions = recent_actions.size
        total_cooperations = np.sum(recent_actions)
        return total_cooperations / total_actions if total_actions > 0 else 0.5

    def _last_round_decision(self, resource_state, cooperation_rate, history):
        """Special end-game logic for last round"""
        if resource_state == 'Critical':
            return Action.D
        rounds_to_check = min(3, len(history.opponent_actions))
        if rounds_to_check > 0:
            recent_actions = history.opponent_actions[-rounds_to_check:, :]
            recent_coop_rate = np.sum(recent_actions) / recent_actions.size
            if recent_coop_rate > 0.6:
                return Action.C
        return Action.D

    def _main_decision_logic(self, resource_state, cooperation_rate, history, stock, capacity, total_rounds):
        """Main decision logic for middle rounds"""
        n = self.game_description.n_players
        if stock < 0.05 * capacity:
            if len(history.opponent_actions) > 0:
                last_round_all_coop = np.all(history.opponent_actions[-1, :])
                if not last_round_all_coop:
                    return Action.D
        if len(history.opponent_actions) >= 3:
            recent_coop_rates = []
            for i in range(3):
                round_actions = history.opponent_actions[-(i + 1), :]
                round_coop_rate = np.sum(round_actions) / len(round_actions)
                recent_coop_rates.append(round_coop_rate)
            if all((rate < 0.3 for rate in recent_coop_rates)):
                self.consecutive_high_defection_rounds += 1
            else:
                self.consecutive_high_defection_rounds = 0
        if cooperation_rate > 0.6:
            self.consecutive_high_defection_rounds = 0
        if len(history.opponent_actions) >= 3:
            total_opponent_actions = np.sum(history.opponent_actions)
            if total_opponent_actions == 0:
                return Action.D
        if total_rounds <= 5:
            coop_threshold_healthy = 0.25
            coop_threshold_stressed = 0.4
        elif total_rounds > 10:
            coop_threshold_healthy = 0.35
            coop_threshold_stressed = 0.6
        else:
            coop_threshold_healthy = 0.3
            coop_threshold_stressed = 0.5
        if resource_state == 'Critical':
            if cooperation_rate < 0.3:
                return Action.D
            else:
                return Action.C
        elif resource_state == 'Stressed':
            if cooperation_rate > coop_threshold_stressed:
                return Action.C
            else:
                return Action.D
        else:
            if stock > 0.9 * capacity:
                return Action.C
            if cooperation_rate > coop_threshold_healthy:
                return Action.C
            elif self.consecutive_high_defection_rounds >= 2:
                return Action.D
            else:
                return Action.C

class Strategy_COOPERATIVE_65(BaseStrategy):
    """
    Guardian of the Commons - Adaptive Cooperative Strategy
    
    Balances cooperation to sustain the resource with adaptive responses to defection,
    while maintaining a fundamentally cooperative stance that protects the common pool
    for long-term benefit.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.base_threshold = 0.6
        self.forgiveness_counter = 0
        self.recovery_boost_rounds = 0
        self.previous_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.previous_stock = state.current_stock
            return Action.C
        stock_health = state.current_stock / self.game_description.capacity
        if state.current_stock <= self.game_description.n_players:
            return Action.C
        if state.current_stock < self.game_description.capacity * 0.3:
            return Action.C
        cooperation_threshold = self._calculate_cooperation_threshold(state, history, stock_health)
        if self._should_cooperate(state, history, cooperation_threshold, stock_health):
            self._update_forgiveness_counter(history)
            return Action.C
        if self._is_last_round() and stock_health > 0.4:
            return Action.C
        return Action.D

    def _calculate_cooperation_threshold(self, state, history, stock_health):
        threshold = self.base_threshold
        stock_penalty = (self.game_description.capacity - state.current_stock) / self.game_description.capacity * 0.3
        threshold += stock_penalty
        recent_defection_rate = self._get_recent_defection_rate(history)
        defection_penalty = recent_defection_rate * 0.2
        threshold += defection_penalty
        if self.forgiveness_counter >= 3:
            threshold -= defection_penalty * 0.5
            self.forgiveness_counter = 0
        if self._majority_defected_last_round(history) and stock_health > 0.5:
            threshold += 0.1
        if self._stock_is_recovering(state):
            threshold -= 0.05
            self.recovery_boost_rounds = 2
        elif self.recovery_boost_rounds > 0:
            threshold -= 0.05
            self.recovery_boost_rounds -= 1
        if self._is_endgame() and stock_health > 0.6:
            threshold -= 0.1
        return threshold

    def _should_cooperate(self, state, history, cooperation_threshold, stock_health):
        if cooperation_threshold < 0.7:
            return True
        if self._majority_cooperated_last_round(history) and state.current_stock > self.game_description.capacity * 0.2:
            return True
        if self._projected_depletion_soon(state, history):
            return True
        if stock_health > 0.8:
            return True
        return False

    def _get_recent_defection_rate(self, history):
        if history.round_number == 0:
            return 0.0
        lookback = min(3, history.round_number)
        recent_actions = history.opponent_actions[-lookback:, :]
        total_actions = recent_actions.size
        defections = np.sum(~recent_actions)
        return defections / total_actions if total_actions > 0 else 0.0

    def _majority_defected_last_round(self, history):
        if history.round_number == 0:
            return False
        last_round_actions = history.opponent_actions[-1, :]
        defectors = np.sum(~last_round_actions)
        return defectors > len(last_round_actions) / 2

    def _majority_cooperated_last_round(self, history):
        if history.round_number == 0:
            return False
        last_round_actions = history.opponent_actions[-1, :]
        cooperators = np.sum(last_round_actions)
        return cooperators > len(last_round_actions) / 2

    def _stock_is_recovering(self, state):
        if self.previous_stock is None:
            self.previous_stock = state.current_stock
            return False
        recovering = state.current_stock > self.previous_stock
        self.previous_stock = state.current_stock
        return recovering

    def _projected_depletion_soon(self, state, history):
        if history.round_number == 0:
            return False
        current_defection_rate = self._get_recent_defection_rate(history)
        current_stock = state.current_stock
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        estimated_defectors = current_defection_rate * n_players
        estimated_cooperators = n_players - estimated_defectors
        for rounds_ahead in [1, 2]:
            consumption = estimated_defectors * current_stock / n_players + estimated_cooperators * current_stock / (2 * n_players)
            stock_after = current_stock - consumption
            if stock_after <= 0:
                return True
            growth = 2 * stock_after * (1 - stock_after / capacity)
            current_stock = min(stock_after + growth, capacity)
            if current_stock <= n_players:
                return True
        return False

    def _update_forgiveness_counter(self, history):
        if history.round_number >= 1 and history.my_actions[-1]:
            self.forgiveness_counter += 1
        else:
            self.forgiveness_counter = 0

    def _is_last_round(self):
        return self.game_description.n_rounds <= 1

    def _is_endgame(self):
        endgame_threshold = int(0.8 * self.game_description.n_rounds)
        return False

class Strategy_COOPERATIVE_66(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Guardian of the Commons"
    
    This strategy aims to maximize long-term collective welfare while being robust against exploitation.
    It balances cooperation with adaptive punishment to maintain sustainable resource use.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_num = state.round_number
        stock = state.current_stock
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        if round_num <= 2:
            return Action.C
        stock_health = stock / capacity
        lookback = min(3, len(history.my_actions))
        recent_opponent_actions = history.opponent_actions[-lookback:, :]
        total_recent_actions = recent_opponent_actions.size
        recent_cooperations = np.sum(recent_opponent_actions)
        recent_defection_rate = 1.0 - recent_cooperations / total_recent_actions if total_recent_actions > 0 else 0.0
        stock_trend = 0.0
        if len(history.my_actions) >= 3:
            recent_payoffs = history.my_payoffs[-3:]
            recent_my_actions = history.my_actions[-3:]
            stock_estimates = []
            for i, (payoff, my_action) in enumerate(zip(recent_payoffs, recent_my_actions)):
                if my_action:
                    estimated_stock = payoff * 2 * n_players
                else:
                    estimated_stock = payoff * n_players
                stock_estimates.append(estimated_stock)
            if len(stock_estimates) >= 2:
                stock_trend = (stock_estimates[-1] - stock_estimates[0]) / len(stock_estimates) / capacity
        if stock_health < 0.2:
            if recent_defection_rate > 0.6:
                return Action.D
            else:
                return Action.C
        if stock_health < 0.5:
            if recent_defection_rate > 0.4 or stock_trend < -0.1:
                return Action.D
            else:
                return Action.C
        trust_level = self._calculate_trust(history, capacity)
        endgame_threshold = 0.8 * total_rounds
        if round_num > endgame_threshold:
            if stock_health > 0.6:
                return Action.C
            elif stock_health < 0.3:
                if recent_defection_rate > 0.3:
                    return Action.D
        if stock_health < 0.1:
            if recent_defection_rate < 0.5:
                return Action.C
            else:
                return Action.D
        if trust_level > 0.7:
            return Action.C
        elif trust_level < 0.3 and recent_defection_rate > 0.5:
            return Action.D
        else:
            return Action.C

    def _calculate_trust(self, history: PlayerHistory, capacity: float) -> float:
        """Calculate trust level based on cooperation outcomes."""
        if len(history.my_actions) < 2:
            return 1.0
        cooperation_reward_ratio = 0.0
        total_opportunities = 0.0
        lookback = min(5, len(history.my_actions))
        recent_my_actions = history.my_actions[-lookback:]
        recent_opponent_actions = history.opponent_actions[-lookback:, :]
        recent_payoffs = history.my_payoffs[-lookback:]
        for i, (my_action, payoff) in enumerate(zip(recent_my_actions, recent_payoffs)):
            if my_action:
                others_cooperations = np.sum(recent_opponent_actions[i, :])
                others_cooperation_rate = others_cooperations / recent_opponent_actions.shape[1]
                if others_cooperation_rate > 0.5:
                    estimated_stock = payoff * 2 * self.game_description.n_players
                    cooperation_reward_ratio += estimated_stock
                total_opportunities += capacity
        if total_opportunities == 0:
            return 1.0
        return cooperation_reward_ratio / total_opportunities

class Strategy_COOPERATIVE_67(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Guardian of the Commons"
    
    Balances long-term sustainability with adaptive responses to opponent behavior.
    Uses stock health assessment and cooperation tracking to make decisions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.cooperation_scores = [0.5] * (self.n_players - 1)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = state.round_number
        current_stock = state.current_stock
        self._update_cooperation_scores(history)
        group_cooperation_level = sum(self.cooperation_scores) / len(self.cooperation_scores)
        emergency_threshold = self.capacity / (4 * self.n_players)
        if current_stock < emergency_threshold:
            return Action.C
        if current_round == self.n_rounds - 1:
            if group_cooperation_level > 0.4:
                return Action.C
            else:
                return Action.D
        stock_health = self._assess_stock_health(current_stock)
        if self._needs_sustainability_override(current_stock, history):
            return Action.C
        if stock_health == 'healthy':
            if group_cooperation_level >= 0.6:
                return Action.C
            elif group_cooperation_level >= 0.3:
                return Action.C if random.random() < 0.7 else Action.D
            else:
                return Action.D
        elif stock_health == 'stressed':
            if group_cooperation_level >= 0.5:
                return Action.C
            else:
                return Action.C if random.random() < 0.6 else Action.D
        elif group_cooperation_level >= 0.4:
            return Action.C
        elif self._any_recent_cooperation(history):
            return Action.C
        else:
            return Action.C if random.random() < 0.8 else Action.D

    def _update_cooperation_scores(self, history: PlayerHistory):
        """Update cooperation scores based on most recent opponent actions."""
        if len(history.opponent_actions) > 0:
            latest_actions = history.opponent_actions[-1, :]
            for i in range(len(self.cooperation_scores)):
                cooperation_indicator = 1.0 if latest_actions[i] else 0.0
                self.cooperation_scores[i] = 0.7 * self.cooperation_scores[i] + 0.3 * cooperation_indicator

    def _assess_stock_health(self, current_stock: float) -> str:
        """Assess current stock health level."""
        healthy_threshold = 0.7 * self.capacity
        stressed_threshold = 0.3 * self.capacity
        if current_stock >= healthy_threshold:
            return 'healthy'
        elif current_stock >= stressed_threshold:
            return 'stressed'
        else:
            return 'critical'

    def _any_recent_cooperation(self, history: PlayerHistory) -> bool:
        """Check if any opponent cooperated in the last 2 rounds."""
        if len(history.opponent_actions) == 0:
            return False
        if len(history.opponent_actions) >= 1:
            if any(history.opponent_actions[-1, :]):
                return True
        if len(history.opponent_actions) >= 2:
            if any(history.opponent_actions[-2, :]):
                return True
        return False

    def _needs_sustainability_override(self, current_stock: float, history: PlayerHistory) -> bool:
        """Check if sustainability override is needed to prevent stock depletion."""
        if len(history.opponent_actions) == 0:
            return False
        latest_actions = history.opponent_actions[-1, :]
        cooperators = sum(latest_actions)
        defectors = len(latest_actions) - cooperators
        defectors += 1
        consumption_per_round = cooperators * current_stock / (2 * self.n_players) + defectors * current_stock / self.n_players
        if current_stock - 3 * consumption_per_round <= 0:
            return True
        return False

class Strategy_COOPERATIVE_68(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Guardian"
    
    Balances long-term sustainability with protection against exploitation.
    Uses dynamic cooperation thresholds based on stock health, opponent behavior,
    and game phase. Includes crisis mode for critically low stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.player_types = ['unknown'] * (self.n - 1)
        self.cooperation_counts = [0] * (self.n - 1)
        self.total_observations = [0] * (self.n - 1)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = state.round_number
        current_stock = state.current_stock
        if current_stock < self.n:
            return Action.D
        if current_stock < 2 * self.n and len(history.my_actions) > 0 and (not history.my_actions[-1]):
            return Action.D
        if len(history.opponent_actions) > 0:
            last_round_cooperators = np.sum(history.opponent_actions[-1, :])
            cooperation_rate = last_round_cooperators / (self.n - 1)
        else:
            cooperation_rate = 0.5
        self._update_player_types(history, current_stock)
        base_threshold = 0.5
        stock_health = current_stock / self.capacity
        if stock_health >= 0.8:
            threshold = base_threshold - 0.2
        elif stock_health >= 0.4:
            threshold = base_threshold
        else:
            threshold = base_threshold + 0.3
        rounds_remaining = self.r - current_round
        if rounds_remaining > self.r / 2:
            threshold -= 0.1
        elif rounds_remaining <= 3:
            threshold += 0.2
        if rounds_remaining <= 2:
            recent_cooperation = self._get_recent_cooperation_rate(history, 3)
            if recent_cooperation >= 0.8:
                return Action.C
            else:
                return Action.D
        cooperator_count = sum((1 for ptype in self.player_types if ptype == 'cooperator'))
        cooperator_ratio = cooperator_count / (self.n - 1) if self.n > 1 else 0
        threshold -= cooperator_ratio * 0.15
        if cooperation_rate >= threshold:
            return Action.C
        else:
            return Action.D

    def _update_player_types(self, history: PlayerHistory, current_stock: float):
        """Update assessment of each opponent's playing style."""
        if len(history.opponent_actions) == 0:
            return
        stock_health = current_stock / self.capacity
        for i in range(self.n - 1):
            healthy_rounds = []
            cooperation_in_healthy = 0
            for round_idx in range(len(history.opponent_actions)):
                if round_idx == 0 or stock_health >= 0.4:
                    healthy_rounds.append(round_idx)
                    if history.opponent_actions[round_idx, i]:
                        cooperation_in_healthy += 1
            total_healthy_rounds = len(healthy_rounds)
            if total_healthy_rounds >= 3:
                coop_rate_healthy = cooperation_in_healthy / total_healthy_rounds
                overall_coop_rate = np.sum(history.opponent_actions[:, i]) / len(history.opponent_actions)
                if coop_rate_healthy > 0.8:
                    self.player_types[i] = 'cooperator'
                elif overall_coop_rate < 0.2:
                    self.player_types[i] = 'defector'
                else:
                    self.player_types[i] = 'mixed'

    def _get_recent_cooperation_rate(self, history: PlayerHistory, lookback: int) -> float:
        """Calculate average cooperation rate over the last 'lookback' rounds."""
        if len(history.opponent_actions) == 0:
            return 0.5
        start_idx = max(0, len(history.opponent_actions) - lookback)
        recent_actions = history.opponent_actions[start_idx:, :]
        if recent_actions.size == 0:
            return 0.5
        total_cooperations = np.sum(recent_actions)
        total_actions = recent_actions.size
        return total_cooperations / total_actions if total_actions > 0 else 0.5

class Strategy_COOPERATIVE_69(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Guardian"
    
    Prioritizes long-term sustainability while being conditionally cooperative.
    Maintains the resource pool while adapting to opponent behavior patterns.
    Uses stock health assessment and cooperation tracking to make decisions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = state.round_number
        current_stock = state.current_stock
        if self.r <= 3:
            if current_round == self.r - 1:
                if current_stock >= 0.5 * self.capacity:
                    return Action.C
                else:
                    last_round_cooperators = sum(history.opponent_actions[-1, :])
                    if last_round_cooperators > self.n / 2:
                        return Action.C
                    else:
                        return Action.D
            else:
                return Action.C
        if current_stock <= self.n:
            if current_round > 0:
                if sum(history.opponent_actions[-1, :]) == self.n - 1:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
        healthy_threshold = 0.8 * self.capacity
        moderate_threshold = 0.4 * self.capacity
        if current_stock >= healthy_threshold:
            stock_health = 'healthy'
        elif current_stock >= moderate_threshold:
            stock_health = 'moderate'
        else:
            stock_health = 'critical'
        total_actions = history.round_number * (self.n - 1)
        total_cooperations = sum((sum(history.opponent_actions[i, :]) for i in range(history.round_number)))
        total_actions += history.round_number
        total_cooperations += sum(history.my_actions)
        cooperation_rate = total_cooperations / total_actions if total_actions > 0 else 0
        forgiveness_adjustment = 0
        if history.round_number >= 3:
            recent_rounds = min(3, history.round_number)
            if recent_rounds >= 2:
                recent_coop_early = sum(sum(history.opponent_actions[-recent_rounds:-(recent_rounds // 2), :]))
                recent_coop_late = sum(sum(history.opponent_actions[-(recent_rounds // 2):, :]))
                recent_actions_early = (recent_rounds - recent_rounds // 2) * (self.n - 1)
                recent_actions_late = recent_rounds // 2 * (self.n - 1)
                if recent_actions_early > 0 and recent_actions_late > 0:
                    early_rate = recent_coop_early / recent_actions_early
                    late_rate = recent_coop_late / recent_actions_late
                    if late_rate > early_rate:
                        forgiveness_adjustment = -0.1
                    elif late_rate < early_rate:
                        forgiveness_adjustment = 0.1
        capacity_adjustment = 0
        if self.capacity >= 4 * self.n:
            capacity_adjustment = -0.1
        high_coop_threshold = 0.6 + forgiveness_adjustment + capacity_adjustment
        medium_coop_threshold = 0.3 + forgiveness_adjustment + capacity_adjustment
        healthy_coop_threshold = 0.4 + forgiveness_adjustment + capacity_adjustment
        if current_round == self.r - 1:
            if current_stock > 0.6 * self.capacity:
                return Action.C
        if stock_health == 'critical':
            if cooperation_rate >= high_coop_threshold:
                return Action.C
            else:
                return Action.D
        elif stock_health == 'moderate':
            if cooperation_rate >= high_coop_threshold:
                return Action.C
            elif cooperation_rate >= medium_coop_threshold and sum(history.opponent_actions[-1, :]) <= (self.n - 1) / 2:
                return Action.C
            else:
                return Action.D
        elif cooperation_rate >= healthy_coop_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_70(BaseStrategy):
    """
    Adaptive Stewardship Strategy: Balances cooperation with resource sustainability,
    adapting to opponent behavior while prioritizing long-term resource health.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.cooperation_threshold = max(0.4, 1 - 1 / self.n_players)
        self.early_cooperation_bonus = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = state.round_number
        stock_health_ratio = state.current_stock / self.capacity
        if stock_health_ratio < 0.3:
            return Action.C
        if current_round == self.n_rounds - 1:
            if stock_health_ratio >= 0.4:
                return Action.C
            else:
                recent_rounds = min(3, len(history.my_actions))
                if recent_rounds > 0:
                    recent_defection_rate = 1 - np.mean(history.opponent_actions[-recent_rounds:])
                    if recent_defection_rate > 0.7:
                        return Action.D
                return Action.C
        cooperation_momentum = self._calculate_cooperation_momentum(history)
        defection_trend = self._calculate_defection_trend(history)
        defection_threshold = 0.3 + 0.2 * (self.n_rounds - current_round) / self.n_rounds
        if current_round <= 2 and (not self.early_cooperation_bonus):
            if self._check_early_cooperation(history):
                self.cooperation_threshold -= 0.1
                self.early_cooperation_bonus = True
        if cooperation_momentum >= self.cooperation_threshold:
            return Action.C
        elif defection_trend > defection_threshold and stock_health_ratio > 0.6:
            if self._should_forgive(history, stock_health_ratio):
                return Action.C
            return Action.D
        else:
            return Action.C

    def _calculate_cooperation_momentum(self, history):
        """Calculate weighted cooperation momentum favoring recent rounds"""
        if len(history.my_actions) == 0:
            return 1.0
        total_weight = 0
        weighted_cooperation = 0
        for i in range(len(history.my_actions)):
            weight = i + 1
            cooperation_rate = np.mean(history.opponent_actions[i])
            weighted_cooperation += weight * cooperation_rate
            total_weight += weight
        return weighted_cooperation / total_weight if total_weight > 0 else 0

    def _calculate_defection_trend(self, history):
        """Calculate trend toward increased defection"""
        if len(history.my_actions) < 3:
            return 0
        recent_rounds = min(3, len(history.my_actions))
        recent_defection = 1 - np.mean(history.opponent_actions[-recent_rounds:])
        if len(history.my_actions) > recent_rounds:
            earlier_defection = 1 - np.mean(history.opponent_actions[:-recent_rounds])
            return recent_defection - earlier_defection
        else:
            return recent_defection

    def _check_early_cooperation(self, history):
        """Check if all players cooperated in early rounds"""
        if len(history.my_actions) < 2:
            return False
        my_early_coop = all(history.my_actions[:2])
        opponent_early_coop = np.all(history.opponent_actions[:2])
        return my_early_coop and opponent_early_coop

    def _should_forgive(self, history, stock_health_ratio):
        """Check forgiveness conditions after considering retaliation"""
        if len(history.my_actions) == 0:
            return False
        last_round_cooperation = np.mean(history.opponent_actions[-1])
        if last_round_cooperation >= 0.5:
            return True
        if len(history.my_actions) >= 2:
            if last_round_cooperation > np.mean(history.opponent_actions[-2]):
                return True
        return False

class Strategy_COOPERATIVE_71(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Stock Guardian"
    
    Prioritizes long-term sustainability while being adaptive to opponent behavior.
    Uses stock health assessment and opponent behavior analysis to make decisions.
    Always cooperates in critical stock situations and adapts cooperation thresholds
    based on stock levels and recent opponent cooperation rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        stock_ratio = state.current_stock / self.game_description.capacity
        if stock_ratio >= 0.6:
            stock_level = 'healthy'
        elif stock_ratio >= 0.3:
            stock_level = 'moderate'
        else:
            stock_level = 'critical'
        recent_cooperation_rate = self._calculate_recent_cooperation_rate(history)
        overall_cooperation_rate = self._calculate_overall_cooperation_rate(history)
        if state.round_number == self.game_description.n_rounds - 1:
            if stock_level == 'critical':
                return Action.C
            elif recent_cooperation_rate >= 0.4:
                return Action.C
            else:
                return Action.D
        if stock_level == 'critical':
            return Action.C
        elif stock_level == 'healthy':
            if recent_cooperation_rate >= 0.5:
                return Action.C
            elif recent_cooperation_rate >= 0.25:
                if overall_cooperation_rate >= 0.4:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
        elif recent_cooperation_rate >= 0.6:
            return Action.C
        elif recent_cooperation_rate >= 0.3 and overall_cooperation_rate >= 0.5:
            return Action.C
        else:
            return Action.D

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate cooperation rate over the last min(3, current_round-1) rounds."""
        if history.round_number == 0:
            return 1.0
        lookback_rounds = min(3, history.round_number)
        recent_actions = history.opponent_actions[-lookback_rounds:, :]
        total_cooperations = np.sum(recent_actions)
        total_actions = recent_actions.size
        if total_actions == 0:
            return 1.0
        return total_cooperations / total_actions

    def _calculate_overall_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate cooperation rate across all previous rounds."""
        if history.round_number == 0:
            return 1.0
        total_cooperations = np.sum(history.opponent_actions)
        total_actions = history.opponent_actions.size
        if total_actions == 0:
            return 1.0
        return total_cooperations / total_actions

class Strategy_COOPERATIVE_72(BaseStrategy):
    """
    Adaptive Cooperative Resource Management Strategy
    
    Prioritizes long-term sustainability while being responsive to opponent behavior.
    Uses dynamic cooperation thresholds based on stock levels and recent cooperation rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_round = -1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        stock_ratio = state.current_stock / self.game_description.capacity
        total_rounds = self.game_description.n_rounds
        current_round = state.round_number
        if stock_ratio < 0.15:
            return Action.C
        if current_round == total_rounds:
            cooperation_rate = self._calculate_cooperation_rate(history, weight_recent=True)
            if cooperation_rate > 0.6:
                return Action.C
            else:
                if len(history.opponent_actions) > 0:
                    last_round_cooperators = sum(history.opponent_actions[-1, :])
                    total_opponents = len(history.opponent_actions[-1, :])
                    if last_round_cooperators > total_opponents / 2:
                        return Action.C
                    else:
                        return Action.D
                return Action.C
        cooperation_rate = self._calculate_cooperation_rate(history, weight_recent=True)
        if stock_ratio > 0.8:
            return Action.C
        elif stock_ratio > 0.5:
            if cooperation_rate > 0.4:
                return Action.C
            else:
                return self._conditional_defect(current_round)
        elif cooperation_rate > 0.6:
            return Action.C
        else:
            return self._conditional_defect(current_round)

    def _calculate_cooperation_rate(self, history: PlayerHistory, weight_recent: bool=False) -> float:
        """Calculate cooperation rate with optional weighting for recent rounds."""
        if len(history.opponent_actions) == 0:
            return 1.0
        total_cooperations = 0
        total_decisions = 0
        for round_idx in range(len(history.opponent_actions)):
            round_cooperations = sum(history.opponent_actions[round_idx, :])
            round_decisions = len(history.opponent_actions[round_idx, :])
            if weight_recent and len(history.opponent_actions) > 3:
                if round_idx >= len(history.opponent_actions) - 3:
                    weight = 1.5
                else:
                    weight = 1.0
            else:
                weight = 1.0
            total_cooperations += round_cooperations * weight
            total_decisions += round_decisions * weight
        return total_cooperations / total_decisions if total_decisions > 0 else 1.0

    def _conditional_defect(self, current_round: int) -> Action:
        """Implement conditional defection with forgiveness mechanism."""
        if self.punishment_round >= 0 and current_round - self.punishment_round <= 2:
            return Action.C
        self.punishment_round = current_round
        return Action.D

class Strategy_COOPERATIVE_73(BaseStrategy):
    """
    Adaptive Stock-Conscious Cooperative Strategy (ASCCS)
    
    Prioritizes long-term sustainability while being adaptive to opponent behavior.
    Maintains the common pool resource at healthy levels while protecting against
    exploitation through measured retaliation and recovery mechanisms.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.retaliation_counter = 0
        self.in_emergency_mode = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        capacity = self.game_description.capacity
        critical_threshold = capacity * 0.3
        sustainable_threshold = capacity * 0.7
        current_stock = state.current_stock
        if current_stock < critical_threshold:
            self.in_emergency_mode = True
        elif current_stock > capacity * 0.5:
            self.in_emergency_mode = False
        if self.in_emergency_mode:
            self.retaliation_counter = 0
            return Action.C
        if current_stock > sustainable_threshold:
            self.retaliation_counter = 0
            return Action.C
        if history.round_number > 0:
            last_round_opponents = history.opponent_actions[-1, :]
            defectors_last_round = sum(last_round_opponents == False)
            total_opponents = len(last_round_opponents)
            exploitation_score = defectors_last_round / total_opponents if total_opponents > 0 else 0
            if exploitation_score > 0.5 and self.retaliation_counter == 0:
                self.retaliation_counter = 1
                return Action.D
            if self.retaliation_counter > 0:
                if self.retaliation_counter == 1:
                    if exploitation_score <= 0.5:
                        self.retaliation_counter = 0
                        return Action.C
                    else:
                        self.retaliation_counter = 2
                        return Action.D
                else:
                    self.retaliation_counter = 0
                    return Action.C
        return Action.C

class Strategy_COOPERATIVE_74(BaseStrategy):
    """
    Adaptive Threshold Cooperation Strategy (ATCS) - Balances cooperation with 
    exploitation protection using dynamic thresholds based on resource health 
    and opponent behavior patterns.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.base_threshold = 0.6

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round = state.round_number
        stock = state.current_stock
        resource_ratio = stock / capacity
        if current_round == n_rounds - 1:
            if resource_ratio > 0.25:
                return Action.C
            else:
                return Action.D
        if resource_ratio < 0.25:
            return Action.D
        if resource_ratio > 0.8:
            return Action.C
        window_size = min(5, max(1, n_rounds // 3))
        recent_rounds = min(window_size, len(history.my_actions))
        if recent_rounds > 0:
            recent_opponent_actions = history.opponent_actions[-recent_rounds:, :]
            total_recent_actions = recent_opponent_actions.size
            recent_cooperations = np.sum(recent_opponent_actions)
            recent_cooperation_rate = recent_cooperations / total_recent_actions if total_recent_actions > 0 else 0.5
        else:
            recent_cooperation_rate = 0.5
        resource_adjustment = (resource_ratio - 0.5) * 0.3
        history_adjustment = (recent_cooperation_rate - 0.5) * 0.4
        cooperation_threshold = self.base_threshold + resource_adjustment + history_adjustment
        if current_round == n_rounds - 2:
            if resource_ratio > 0.33:
                return Action.C
            elif recent_cooperation_rate < 0.3:
                return Action.D
        if len(history.my_actions) >= 3:
            last_3_rounds = history.opponent_actions[-3:, :]
            defection_rate = 1.0 - np.sum(last_3_rounds) / last_3_rounds.size
            if defection_rate > 0.7:
                cooperation_threshold -= 0.2
        if recent_cooperation_rate < 0.3:
            return Action.D
        if resource_ratio < 0.1 and recent_cooperation_rate < 0.5:
            return Action.D
        if recent_cooperation_rate > cooperation_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_75(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Guardian"
    
    Prioritizes long-term sustainability while being adaptive to opponent behavior.
    Starts cooperative but adjusts based on stock health and opponent patterns,
    maintaining a bias toward preserving the resource for mutual benefit.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = state.round_number
        current_stock = state.current_stock
        stock_health = current_stock / self.capacity
        initial_coop_rounds = max(3, self.r // 5)
        endgame_rounds = max(3, self.r // 5)
        if current_round < initial_coop_rounds:
            return Action.C
        if current_round >= self.r - endgame_rounds:
            if current_round == self.r - 1:
                return Action.D
            elif stock_health >= 0.4 and self._get_recent_coop_rate(history) >= 0.5:
                return Action.C
            else:
                return Action.D
        if current_stock < self.n:
            return Action.D
        if stock_health < 0.3:
            return Action.D
        recent_defections = self._get_recent_defections(history)
        coop_rate = self._get_recent_coop_rate(history)
        if self._check_unanimous_defection(history) and stock_health < 0.4:
            return Action.D
        if stock_health < 0.5 and recent_defections > self.n // 2:
            return Action.D
        if coop_rate >= 0.6:
            return Action.C
        if coop_rate >= 0.3 and stock_health >= 0.5:
            return Action.C
        if recent_defections >= self.n - 1:
            return Action.D
        return Action.C

    def _get_recent_defections(self, history: PlayerHistory) -> int:
        """Count defections by opponents in the last round."""
        if history.round_number == 0:
            return 0
        return sum((1 for action in history.opponent_actions[-1, :] if not action))

    def _get_recent_coop_rate(self, history: PlayerHistory) -> float:
        """Calculate cooperation rate over recent window (last 3 rounds or available)."""
        if history.round_number == 0:
            return 1.0
        window_size = min(3, history.round_number)
        start_round = history.round_number - window_size
        total_actions = 0
        total_cooperations = 0
        for round_idx in range(start_round, history.round_number):
            round_cooperations = sum(history.opponent_actions[round_idx, :])
            total_cooperations += round_cooperations
            total_actions += len(history.opponent_actions[round_idx, :])
        if total_actions == 0:
            return 1.0
        return total_cooperations / total_actions

    def _check_unanimous_defection(self, history: PlayerHistory) -> bool:
        """Check if all opponents defected for 2 consecutive rounds."""
        if history.round_number < 2:
            return False
        for round_offset in [1, 2]:
            round_idx = history.round_number - round_offset
            if round_idx < 0:
                return False
            if any(history.opponent_actions[round_idx, :]):
                return False
        return True

class Strategy_COOPERATIVE_76(BaseStrategy):
    """
    Sustainable Guardian: An adaptive cooperative strategy that prioritizes long-term 
    sustainability while being conditionally cooperative, adapting to opponent behavior 
    patterns, and maintaining resource viability across all rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.initial_phase_end = math.ceil(0.2 * self.n_rounds)
        self.endgame_phase_start = math.floor(0.8 * self.n_rounds)
        self.emergency_cooperation_rounds = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number
        current_stock = state.current_stock
        stock_health = current_stock / self.capacity
        if stock_health < 0.15:
            self.emergency_cooperation_rounds = 3
            return Action.C
        if self.emergency_cooperation_rounds > 0:
            self.emergency_cooperation_rounds -= 1
            if stock_health < 0.25:
                return Action.C
        if current_round < self.initial_phase_end:
            return Action.C
        if current_round >= self.endgame_phase_start:
            return self._endgame_strategy(current_round, stock_health, history)
        return self._adaptive_strategy(stock_health, history)

    def _adaptive_strategy(self, stock_health: float, history: PlayerHistory) -> Action:
        if stock_health < 0.3:
            cooperation_bias = 0.8
        elif stock_health < 0.6:
            cooperation_bias = 0.6
        else:
            cooperation_bias = 0.4
        current_round = history.round_number
        recent_rounds = min(5, max(1, current_round // 2))
        start_round = max(0, current_round - recent_rounds)
        recent_coop_rates = []
        for opponent_idx in range(self.n_players - 1):
            recent_actions = history.opponent_actions[start_round:current_round, opponent_idx]
            if len(recent_actions) > 0:
                coop_rate = np.mean(recent_actions)
            else:
                coop_rate = 0.5
            recent_coop_rates.append(coop_rate)
        avg_opponent_cooperation = np.mean(recent_coop_rates) if recent_coop_rates else 0.5
        if current_round >= 3:
            last_3_rounds = history.opponent_actions[current_round - 3:current_round, :]
            total_defections = np.sum(last_3_rounds == False)
            total_decisions = last_3_rounds.size
            defection_rate = total_defections / total_decisions if total_decisions > 0 else 0
            if defection_rate > 0.75 and stock_health > 0.5:
                cooperation_bias = max(0.1, cooperation_bias - 0.3)
        if self.n_players == 2:
            cooperation_bias += 0.2
            cooperation_bias = min(1.0, cooperation_bias)
            if current_round >= 1:
                last_opponent_action = history.opponent_actions[current_round - 1, 0]
                if last_opponent_action:
                    return Action.C
                elif current_round >= 3:
                    last_3_opponent = history.opponent_actions[current_round - 3:current_round, 0]
                    defections = np.sum(last_3_opponent == False)
                    if defections <= 1:
                        return Action.C
        cooperation_threshold = cooperation_bias * (0.5 + 0.5 * avg_opponent_cooperation)
        if random.random() < cooperation_threshold:
            return Action.C
        else:
            return Action.D

    def _endgame_strategy(self, current_round: int, stock_health: float, history: PlayerHistory) -> Action:
        if current_round == self.n_rounds - 1:
            if stock_health > 0.5:
                return Action.D
            else:
                return Action.C
        if stock_health < 0.4:
            return Action.C
        if current_round >= 2:
            last_2_rounds = history.opponent_actions[current_round - 2:current_round, :]
            defections = np.sum(last_2_rounds == False)
            total_decisions = last_2_rounds.size
            if defections > total_decisions / 2:
                return Action.D
        if random.random() < 0.7:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_77(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Guardian"
    
    Prioritizes long-term sustainability while being cooperative by default, but adaptive to opponent behavior.
    Uses a sustainability threshold system and tracks historical cooperation rates to make decisions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.sustainability_threshold = max(self.capacity * 0.4, 2 * self.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.n_rounds:
            historical_cooperation_rate = self._calculate_cooperation_rate(history)
            if current_stock > self.sustainability_threshold and historical_cooperation_rate >= 0.3:
                return Action.C
            else:
                return Action.D
        if current_stock <= self.sustainability_threshold:
            return Action.D
        historical_cooperation_rate = self._calculate_cooperation_rate(history)
        if historical_cooperation_rate >= 0.5:
            return Action.C
        if historical_cooperation_rate >= 0.25:
            stock_health = current_stock / self.capacity
            cooperation_probability = stock_health * 0.8
            if random.random() < cooperation_probability:
                return Action.C
            else:
                return Action.D
        if current_stock >= self.capacity * 0.8:
            return Action.C
        else:
            return Action.D

    def _calculate_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate the cooperation rate of opponents over the recent window."""
        current_round = history.round_number
        window_size = min(3, current_round)
        if window_size == 0:
            return 0.5
        recent_actions = history.opponent_actions[-window_size:, :]
        total_cooperations = np.sum(recent_actions)
        total_actions = recent_actions.size
        if total_actions == 0:
            return 0.5
        return total_cooperations / total_actions

class Strategy_COOPERATIVE_78(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Steward"
    
    Prioritizes long-term resource sustainability while being adaptive to opponent behaviors.
    Starts cooperatively but responds to exploitation while maintaining cooperation incentives.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.early_phase_end = math.floor(self.n_rounds / 3)
        self.middle_phase_end = math.floor(2 * self.n_rounds / 3)
        self.consecutive_defections = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.consecutive_defections = 0
            return Action.C
        current_round = history.round_number + 1
        stock_health = state.current_stock / self.capacity
        last_round_opponents = history.opponent_actions[-1, :]
        cooperation_rate = np.mean(last_round_opponents)
        trust_score = self._calculate_trust_score(history)
        action = self._get_action_by_phase(current_round, stock_health, cooperation_rate, trust_score, history)
        if action == Action.D:
            self.consecutive_defections += 1
        else:
            self.consecutive_defections = 0
        return action

    def _calculate_trust_score(self, history):
        """Calculate weighted trust score from recent opponent cooperation"""
        if history.round_number == 0:
            return np.mean(history.opponent_actions[-1, :])
        weights = [0.5, 0.3, 0.2]
        trust_score = 0
        total_weight = 0
        for i, weight in enumerate(weights):
            round_idx = -(i + 1)
            if abs(round_idx) <= history.round_number:
                round_coop_rate = np.mean(history.opponent_actions[round_idx, :])
                trust_score += weight * round_coop_rate
                total_weight += weight
            else:
                break
        return trust_score / total_weight if total_weight > 0 else 0

    def _get_action_by_phase(self, current_round, stock_health, cooperation_rate, trust_score, history):
        """Apply phase-specific decision rules"""
        action = self._check_special_mechanisms(stock_health, cooperation_rate, history)
        if action is not None:
            return action
        if current_round <= self.early_phase_end:
            return self._early_phase_decision(stock_health, cooperation_rate)
        elif current_round <= self.middle_phase_end:
            return self._middle_phase_decision(stock_health, trust_score)
        else:
            return self._end_phase_decision(current_round, stock_health, cooperation_rate, trust_score)

    def _early_phase_decision(self, stock_health, cooperation_rate):
        """Decision logic for early phase"""
        if stock_health > 0.6 and cooperation_rate >= 0.5:
            return Action.C
        elif stock_health > 0.3 and cooperation_rate >= 0.3:
            return Action.C if random.random() < 0.8 else Action.D
        else:
            return Action.D

    def _middle_phase_decision(self, stock_health, trust_score):
        """Decision logic for middle phase"""
        if stock_health > 0.7:
            if trust_score >= 0.6:
                return Action.C
            elif trust_score >= 0.3:
                return Action.C if random.random() < 0.7 else Action.D
            else:
                return Action.D
        elif stock_health > 0.4:
            if trust_score >= 0.7:
                return Action.C
            elif trust_score >= 0.5:
                return Action.C if random.random() < 0.6 else Action.D
            else:
                return Action.D
        elif stock_health > 0.2:
            if trust_score >= 0.8:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _end_phase_decision(self, current_round, stock_health, cooperation_rate, trust_score):
        """Decision logic for end phase"""
        rounds_remaining = self.n_rounds - current_round + 1
        if stock_health < 0.1:
            return Action.D
        elif rounds_remaining <= 2:
            if cooperation_rate >= 0.8 and stock_health > 0.4:
                return Action.C
            else:
                return Action.D
        elif trust_score >= 0.6 and stock_health > 0.3:
            return Action.C
        elif trust_score >= 0.4 and stock_health > 0.5:
            return Action.C if random.random() < 0.7 else Action.D
        else:
            return Action.D

    def _check_special_mechanisms(self, stock_health, cooperation_rate, history):
        """Check for special mechanism conditions"""
        if stock_health < 0.1 and self.n_rounds - history.round_number > 3 and (self.consecutive_defections == 0):
            return Action.C
        if history.round_number > 0 and self.consecutive_defections > 0:
            prev_stock_health = self._get_previous_stock_health(history)
            if stock_health - prev_stock_health > 0.2 and cooperation_rate >= 0.4:
                return Action.C
        if self.consecutive_defections >= 2 and stock_health > 0.3:
            if self.consecutive_defections >= 3:
                return Action.C
            elif random.random() < 0.3:
                return Action.C
        return None

    def _get_previous_stock_health(self, history):
        """Estimate previous stock health based on game dynamics"""
        if history.round_number == 0:
            return 1.0
        return min(1.0, history.my_payoffs[-1] * 2 * self.n_players / self.capacity)

class Strategy_COOPERATIVE_79(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Steward"
    
    Prioritizes long-term sustainability while being adaptive to opponent behavior.
    Starts cooperative and adjusts based on observed patterns, with built-in 
    forgiveness mechanisms to restore cooperation when possible.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_number = state.round_number
        stock = state.current_stock
        if round_number <= 3:
            if stock < self.n:
                return Action.D
            return Action.C
        if stock < self.n:
            return Action.D
        if stock <= 0:
            return Action.D
        if stock > 0.9 * self.capacity:
            return Action.C
        cooperator_count, defector_count, mixed_count = self._classify_opponents(history)
        if cooperator_count >= (self.n - 1) / 2:
            return Action.C
        if defector_count <= 1 and stock > 0.5 * self.capacity:
            return Action.C
        if round_number % 5 == 0 and self._is_stock_recovering(history, state):
            return Action.C
        stock_health = stock / self.capacity
        if stock_health >= 0.7:
            if defector_count <= self.n / 3:
                return Action.C
            else:
                return Action.D
        elif stock_health >= 0.4:
            if cooperator_count > defector_count:
                return Action.C
            else:
                return Action.D
        elif cooperator_count >= 2 * defector_count:
            return Action.C
        else:
            return Action.D

    def _classify_opponents(self, history: PlayerHistory):
        """Classify opponents based on recent behavior patterns."""
        recent_rounds = min(5, history.round_number)
        cooperator_count = 0
        defector_count = 0
        mixed_count = 0
        for player_idx in range(self.n - 1):
            if recent_rounds == 0:
                mixed_count += 1
                continue
            recent_actions = history.opponent_actions[-recent_rounds:, player_idx]
            cooperation_rate = np.mean(recent_actions)
            threshold_adjustment = 0
            if self._has_stock_recovery_bonus(history):
                threshold_adjustment = 0.05
            if cooperation_rate >= 0.7 - threshold_adjustment:
                cooperator_count += 1
            elif cooperation_rate < 0.3 + threshold_adjustment:
                defector_count += 1
            else:
                mixed_count += 1
        return (cooperator_count, defector_count, mixed_count)

    def _is_stock_recovering(self, history: PlayerHistory, state: CommonPoolState):
        """Check if stock is recovering (growing in last 2 rounds)."""
        if history.round_number < 2:
            return False
        recent_total_payoffs = []
        for i in range(min(2, history.round_number)):
            round_idx = -(i + 1)
            my_payoff = history.my_payoffs[round_idx]
            opponent_total_payoff = np.sum(history.opponent_payoffs[round_idx, :])
            total_payoff = my_payoff + opponent_total_payoff
            recent_total_payoffs.append(total_payoff)
        if len(recent_total_payoffs) >= 2:
            return recent_total_payoffs[0] > recent_total_payoffs[1]
        return False

    def _has_stock_recovery_bonus(self, history: PlayerHistory):
        """Check if stock has grown significantly in last 3 rounds."""
        if history.round_number < 3:
            return False
        recent_rounds = min(3, history.round_number)
        total_payoffs = []
        for i in range(recent_rounds):
            round_idx = -(i + 1)
            my_payoff = history.my_payoffs[round_idx]
            opponent_total_payoff = np.sum(history.opponent_payoffs[round_idx, :])
            total_payoff = my_payoff + opponent_total_payoff
            total_payoffs.append(total_payoff)
        if len(total_payoffs) >= 3:
            return total_payoffs[0] > total_payoffs[2] * 1.2
        return False

class Strategy_COOPERATIVE_80(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Stock Guardian"
    
    Prioritizes long-term sustainability while being adaptive to opponent behavior.
    Uses emergency protection when stock is critically low, implements generous 
    tit-for-tat with forgiveness, and maintains cooperative signals when possible.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_trust_level = 0.8
        self.emergency_mode = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        stock = state.current_stock
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        current_round = state.round_number
        rounds_remaining = n_rounds - current_round
        self._update_trust_level(history)
        self.emergency_mode = stock < capacity * 0.3 or (stock < capacity * 0.5 and rounds_remaining < 3)
        if self.emergency_mode:
            return Action.D
        if current_round == n_rounds - 1:
            if stock > capacity * 0.5:
                return Action.C
            else:
                return Action.D
        return self._adaptive_decision(stock, capacity, history)

    def _update_trust_level(self, history: PlayerHistory):
        """Update trust level based on recent opponent cooperation."""
        if history.round_number < 1:
            return
        lookback = min(3, history.round_number)
        recent_actions = history.opponent_actions[-lookback:, :]
        total_actions = recent_actions.size
        cooperations = np.sum(recent_actions)
        recent_cooperation_rate = cooperations / total_actions if total_actions > 0 else 0.5
        if recent_cooperation_rate > 0.7:
            self.opponent_trust_level = min(1.0, self.opponent_trust_level + 0.1)
        elif recent_cooperation_rate < 0.3:
            self.opponent_trust_level = max(0.0, self.opponent_trust_level - 0.15)
        else:
            self.opponent_trust_level = self.opponent_trust_level * 0.95

    def _adaptive_decision(self, stock: float, capacity: float, history: PlayerHistory) -> Action:
        """Make adaptive decision based on stock level and opponent behavior."""
        cooperation_rate = self._calculate_recent_cooperation_rate(history, lookback_rounds=3)
        if cooperation_rate >= 0.6:
            return Action.C
        elif cooperation_rate >= 0.4:
            if self._last_round_majority_cooperated(history):
                return Action.C
            else:
                if random.random() < 0.3:
                    return Action.C
                return Action.D
        else:
            if history.round_number % 5 == 0 and random.random() < 0.4:
                return Action.C
            return Action.D

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory, lookback_rounds: int) -> float:
        """Calculate cooperation rate over recent rounds."""
        if history.round_number < 1:
            return 0.5
        lookback = min(lookback_rounds, history.round_number)
        recent_actions = history.opponent_actions[-lookback:, :]
        total_actions = recent_actions.size
        cooperations = np.sum(recent_actions)
        return cooperations / total_actions if total_actions > 0 else 0.5

    def _last_round_majority_cooperated(self, history: PlayerHistory) -> bool:
        """Check if majority of opponents cooperated in the last round."""
        if history.round_number < 1:
            return True
        last_round_actions = history.opponent_actions[-1, :]
        cooperations = np.sum(last_round_actions)
        return cooperations > len(last_round_actions) / 2

class Strategy_COOPERATIVE_81(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Guardian"
    
    Prioritizes long-term sustainability while being adaptive to opponent behavior.
    Uses graduated responses based on stock health and cooperation rates to encourage
    collective cooperation while protecting the resource from depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        round_num = state.round_number
        final_round = self.game_description.n_rounds
        stock_health = current_stock / capacity
        if stock_health < 0.1:
            return Action.C
        cooperation_rate = self._calculate_cooperation_rate(history, n)
        if self._all_cooperated_streak(history, n):
            return Action.C
        if stock_health < 0.3:
            return Action.C
        if round_num >= final_round:
            return Action.C if stock_health >= 0.4 else Action.D
        recovery_bonus = 0.2 if self._stock_grew_last_round(history) else 0.0
        if stock_health >= 0.6:
            if cooperation_rate >= 0.7:
                return Action.C
            elif cooperation_rate >= 0.3:
                prob_cooperate = min(0.8 + recovery_bonus, 1.0)
                return Action.C if random.random() < prob_cooperate else Action.D
            else:
                prob_cooperate = min(0.6 + recovery_bonus, 1.0)
                return Action.C if random.random() < prob_cooperate else Action.D
        elif cooperation_rate >= 0.7:
            return Action.C
        else:
            return Action.C

    def _calculate_cooperation_rate(self, history: PlayerHistory, n: int) -> float:
        """Calculate cooperation rate from last 3 rounds or all available rounds."""
        rounds_to_check = min(3, history.round_number)
        if rounds_to_check == 0:
            return 1.0
        recent_my_actions = history.my_actions[-rounds_to_check:]
        recent_opponent_actions = history.opponent_actions[-rounds_to_check:, :]
        my_cooperations = np.sum(recent_my_actions)
        opponent_cooperations = np.sum(recent_opponent_actions)
        total_cooperations = my_cooperations + opponent_cooperations
        total_actions = rounds_to_check * n
        return total_cooperations / total_actions if total_actions > 0 else 1.0

    def _all_cooperated_streak(self, history: PlayerHistory, n: int) -> bool:
        """Check if all players cooperated for last 2+ consecutive rounds."""
        if history.round_number < 2:
            return False
        rounds_to_check = min(2, history.round_number)
        for i in range(rounds_to_check):
            round_idx = -(i + 1)
            if not history.my_actions[round_idx]:
                return False
            if not np.all(history.opponent_actions[round_idx, :]):
                return False
        return True

    def _stock_grew_last_round(self, history: PlayerHistory) -> bool:
        """Check if stock increased in the last round based on payoff changes."""
        if history.round_number < 2:
            return False
        recent_my_payoffs = history.my_payoffs[-2:]
        recent_opponent_payoffs = history.opponent_payoffs[-2:, :]
        if len(recent_my_payoffs) < 2:
            return False
        prev_avg_payoff = (recent_my_payoffs[0] + np.mean(recent_opponent_payoffs[0, :])) / 2
        last_avg_payoff = (recent_my_payoffs[1] + np.mean(recent_opponent_payoffs[1, :])) / 2
        return last_avg_payoff > prev_avg_payoff

class Strategy_COOPERATIVE_82(BaseStrategy):
    """
    Guardian of the Commons: Adaptive cooperative strategy that balances long-term sustainability
    with protection against exploitation through stock health assessment and opponent behavior analysis.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.crisis_threshold = 0.3
        self.caution_threshold = 0.6
        self.exploitation_threshold = 0.2
        self.cooperation_threshold = 0.6
        self.recent_window = 3
        self.punished_last_round = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = state.round_number
        stock_health_ratio = state.current_stock / self.capacity
        if stock_health_ratio < self.crisis_threshold:
            mode = 'CRISIS'
        elif stock_health_ratio < self.caution_threshold:
            mode = 'CAUTION'
        else:
            mode = 'NORMAL'
        recent_rounds = min(self.recent_window, len(history.my_actions))
        if recent_rounds > 0:
            recent_opponent_actions = history.opponent_actions[-recent_rounds:, :]
            recent_cooperation_rates = np.mean(recent_opponent_actions, axis=0)
            avg_opponent_cooperation = np.mean(recent_cooperation_rates)
            overall_opponent_cooperation = np.mean(history.opponent_actions, axis=0)
            avg_overall_opponent_cooperation = np.mean(overall_opponent_cooperation)
            my_cooperation_rate = np.mean(history.my_actions)
        else:
            avg_opponent_cooperation = 1.0
            avg_overall_opponent_cooperation = 1.0
            my_cooperation_rate = 1.0
        last_round_cooperators = 0
        last_round_defectors = 0
        majority_defected_last = False
        if len(history.opponent_actions) > 0:
            last_round_actions = history.opponent_actions[-1, :]
            last_round_cooperators = np.sum(last_round_actions)
            last_round_defectors = len(last_round_actions) - last_round_cooperators
            majority_defected_last = last_round_defectors > last_round_cooperators
        stock_growing = False
        if len(history.my_payoffs) >= 2:
            recent_payoffs = history.my_payoffs[-2:]
            stock_growing = recent_payoffs[-1] > recent_payoffs[-2]
        if mode == 'CRISIS':
            cooperation_percentage = last_round_cooperators / self.n_players if self.n_players > 0 else 0
            if cooperation_percentage > 0.75:
                return Action.C
            elif majority_defected_last and (not stock_growing):
                return Action.D
            else:
                return Action.C
        elif mode == 'CAUTION':
            exploitation_gap = my_cooperation_rate - avg_overall_opponent_cooperation
            being_exploited = exploitation_gap > self.exploitation_threshold
            if my_cooperation_rate >= avg_overall_opponent_cooperation:
                return Action.C
            elif being_exploited and (not self.punished_last_round):
                self.punished_last_round = True
                return Action.D
            elif stock_growing:
                self.punished_last_round = False
                return Action.C
            else:
                self.punished_last_round = False
                return Action.C if random.random() < 0.8 else Action.D
        else:
            self.punished_last_round = False
            if majority_defected_last:
                return Action.D
            else:
                return Action.C

class Strategy_COOPERATIVE_83(BaseStrategy):
    """
    Adaptive Sustainability Strategy (ASS) - Balances cooperation with resource sustainability,
    adapting based on opponent behavior while maintaining cooperative bias.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.consecutive_mutual_defection_count = 0
        self.base_cooperation = 0.8

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_number = state.round_number
        stock = state.current_stock
        capacity = self.game_description.capacity
        total_rounds = self.game_description.n_rounds
        if stock < 0.1 * capacity:
            if history.round_number > 0:
                recent_cooperators = sum(history.opponent_actions[-1, :])
                if recent_cooperators >= 0.75 * len(history.opponent_actions[-1, :]):
                    return Action.C
            return Action.D
        stock_health = min(1.0, stock / (0.6 * capacity))
        window_size = min(5, history.round_number)
        if window_size > 0:
            recent_actions = history.opponent_actions[-window_size:, :]
            total_opponent_actions = recent_actions.size
            cooperative_actions = np.sum(recent_actions)
            opponent_reciprocity = cooperative_actions / total_opponent_actions if total_opponent_actions > 0 else 0.8
        else:
            opponent_reciprocity = 0.8
        remaining_rounds = total_rounds - round_number
        if remaining_rounds <= 3:
            endgame_factor = 1.0 + 0.3 * (remaining_rounds / total_rounds)
        else:
            endgame_factor = 1.0
        if history.round_number > 0:
            my_last_action = history.my_actions[-1]
            opponents_last_round = history.opponent_actions[-1, :]
            all_defected = not my_last_action and (not np.any(opponents_last_round))
            if all_defected:
                self.consecutive_mutual_defection_count += 1
            else:
                self.consecutive_mutual_defection_count = 0
        if self.consecutive_mutual_defection_count >= 3 and round_number % 5 == 0:
            return Action.C
        CPS = self.base_cooperation * stock_health * opponent_reciprocity * endgame_factor
        if remaining_rounds == 1:
            if stock > 0.3 * capacity:
                return Action.C
            else:
                return Action.D
        return Action.C if CPS >= 0.6 else Action.D

class Strategy_COOPERATIVE_84(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Steward"
    
    Maintains long-term resource sustainability while being responsive to group cooperation levels.
    Balances cooperative behavior with adaptive responses to prevent exploitation while encouraging
    collective cooperation through graduated responses and crisis management.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.sustainability_threshold = game_description.capacity * 0.6
        self.crisis_threshold = game_description.capacity * 0.3
        self.emergency_threshold = game_description.capacity * 0.1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            cooperation_rate = self._calculate_cooperation_rate(history)
            if state.current_stock >= self.sustainability_threshold and cooperation_rate >= 0.4:
                return Action.C
            else:
                return Action.D
        if state.current_stock < self.emergency_threshold:
            return Action.C
        cooperation_rate = self._calculate_cooperation_rate(history)
        if state.current_stock < self.sustainability_threshold:
            if state.current_stock < self.crisis_threshold:
                return Action.C
            elif cooperation_rate >= 0.4:
                return Action.C
            else:
                return Action.C if random.random() < 0.7 else Action.D
        if cooperation_rate >= 0.5:
            return Action.C
        else:
            return self._graduated_response(cooperation_rate, history)

    def _calculate_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate weighted cooperation rate emphasizing recent rounds."""
        if history.round_number == 0:
            return 1.0
        total_actions = history.opponent_actions.size + history.round_number
        total_cooperations = np.sum(history.opponent_actions) + np.sum(history.my_actions)
        if total_actions == 0:
            return 1.0
        recent_rounds = max(2, history.round_number // 4)
        recent_start = max(0, history.round_number - recent_rounds)
        if recent_start < history.round_number:
            recent_opponent_actions = history.opponent_actions[recent_start:, :]
            recent_my_actions = history.my_actions[recent_start:]
            recent_total = recent_opponent_actions.size + len(recent_my_actions)
            recent_cooperations = np.sum(recent_opponent_actions) + np.sum(recent_my_actions)
            recent_cooperation = recent_cooperations / recent_total if recent_total > 0 else 0.0
        else:
            recent_cooperation = 0.0
        historical_cooperation = total_cooperations / total_actions
        cooperation_rate = 0.6 * recent_cooperation + 0.4 * historical_cooperation
        return cooperation_rate

    def _graduated_response(self, cooperation_rate: float, history: PlayerHistory) -> Action:
        """Apply graduated response based on cooperation rate."""
        if self._check_repeated_exploitation(history):
            base_prob = self._get_base_cooperation_probability(cooperation_rate)
            cooperation_prob = max(0.0, base_prob - 0.2)
        elif self._check_cooperation_improvement(history):
            return Action.C
        else:
            cooperation_prob = self._get_base_cooperation_probability(cooperation_rate)
        return Action.C if random.random() < cooperation_prob else Action.D

    def _get_base_cooperation_probability(self, cooperation_rate: float) -> float:
        """Get base cooperation probability based on cooperation rate."""
        if cooperation_rate >= 0.3:
            return 0.8
        elif cooperation_rate >= 0.1:
            return 0.6
        else:
            return 0.3

    def _check_repeated_exploitation(self, history: PlayerHistory) -> bool:
        """Check if being repeatedly exploited (cooperation_rate < 0.2 for 3+ consecutive rounds)."""
        if history.round_number < 3:
            return False
        for i in range(max(0, history.round_number - 3), history.round_number):
            round_actions = np.concatenate([history.opponent_actions[i:i + 1, :].flatten(), [history.my_actions[i]]])
            round_cooperation_rate = np.mean(round_actions)
            if round_cooperation_rate >= 0.2:
                return False
        return True

    def _check_cooperation_improvement(self, history: PlayerHistory) -> bool:
        """Check if cooperation rate has improved significantly (increase > 0.3)."""
        if history.round_number < 4:
            return False
        mid_point = history.round_number // 2
        early_actions = np.concatenate([history.opponent_actions[:mid_point, :].flatten(), history.my_actions[:mid_point]])
        early_cooperation = np.mean(early_actions) if len(early_actions) > 0 else 0.0
        recent_actions = np.concatenate([history.opponent_actions[mid_point:, :].flatten(), history.my_actions[mid_point:]])
        recent_cooperation = np.mean(recent_actions) if len(recent_actions) > 0 else 0.0
        return recent_cooperation - early_cooperation > 0.3

class Strategy_COOPERATIVE_85(BaseStrategy):
    """
    Adaptive Reciprocal Conservation Strategy (ARCS)
    
    Balances immediate cooperation with long-term sustainability by adapting to opponent behavior
    while maintaining a strong cooperative bias. Treats the common pool as a shared asset that
    must be preserved for mutual benefit.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.recovery_reset_triggered = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round <= 2:
            if current_stock < self.capacity * 0.4:
                return self._stock_based_decision(current_stock)
            return Action.C
        if current_stock <= self.capacity * 0.1:
            return self._crisis_mode(history)
        if current_stock > self.capacity * 0.6 and (not self.recovery_reset_triggered):
            self.recovery_reset_triggered = True
        cooperation_ratio = self._calculate_cooperation_ratio(history)
        if self._check_perfect_cooperation(history):
            return Action.C
        if current_round > 0.8 * self.n_rounds:
            return self._endgame_decision(current_stock, cooperation_ratio)
        if cooperation_ratio >= 0.6:
            return Action.C
        elif cooperation_ratio >= 0.3:
            return self._stock_based_decision(current_stock)
        else:
            return self._defensive_mode(history, current_stock)

    def _calculate_cooperation_ratio(self, history: PlayerHistory) -> float:
        """Calculate the ratio of cooperative actions by opponents."""
        if self.recovery_reset_triggered:
            recent_rounds = min(3, history.round_number)
            if recent_rounds == 0:
                return 1.0
            recent_actions = history.opponent_actions[-recent_rounds:, :]
            total_cooperations = np.sum(recent_actions)
            total_actions = recent_rounds * (self.n_players - 1)
            self.recovery_reset_triggered = False
        else:
            total_cooperations = np.sum(history.opponent_actions)
            total_actions = history.round_number * (self.n_players - 1)
        if total_actions == 0:
            return 1.0
        return total_cooperations / total_actions

    def _stock_based_decision(self, current_stock: float) -> Action:
        """Make decision based on stock sustainability."""
        sustainability_index = current_stock / self.capacity
        if sustainability_index >= 0.5:
            return Action.C
        elif sustainability_index >= 0.2:
            if random.random() < sustainability_index:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _defensive_mode(self, history: PlayerHistory, current_stock: float) -> Action:
        """Handle low cooperation environment defensively."""
        if current_stock <= self.capacity * 0.15:
            return Action.D
        if history.round_number > 0:
            last_round_defectors = np.sum(history.opponent_actions[-1, :] == False)
            if last_round_defectors > 0.7 * (self.n_players - 1):
                return Action.D
        return Action.C

    def _crisis_mode(self, history: PlayerHistory) -> Action:
        """Handle stock depletion crisis."""
        if history.round_number > 0:
            last_round_cooperations = np.sum(history.opponent_actions[-1, :])
            if last_round_cooperations == self.n_players - 1:
                return Action.C
        return Action.D

    def _check_perfect_cooperation(self, history: PlayerHistory) -> bool:
        """Check if all players have cooperated for 3+ consecutive rounds."""
        if history.round_number < 3:
            return False
        recent_rounds = history.opponent_actions[-3:, :]
        my_recent_actions = history.my_actions[-3:]
        all_opponent_cooperation = np.all(recent_rounds)
        my_cooperation = np.all(my_recent_actions)
        return all_opponent_cooperation and my_cooperation

    def _endgame_decision(self, current_stock: float, cooperation_ratio: float) -> Action:
        """Handle endgame scenarios."""
        if current_stock > self.capacity * 0.3 and cooperation_ratio > 0.4:
            return Action.C
        else:
            adjusted_cooperation_ratio = cooperation_ratio + 0.1
            if adjusted_cooperation_ratio >= 0.6:
                return Action.C
            elif adjusted_cooperation_ratio >= 0.3:
                return self._stock_based_decision(current_stock)
            else:
                return self._defensive_mode_endgame(current_stock)

    def _defensive_mode_endgame(self, current_stock: float) -> Action:
        """Simplified defensive mode for endgame."""
        if current_stock <= self.capacity * 0.15:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_86(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Guardian"
    
    Prioritizes long-term sustainability while being adaptable to opponent behavior.
    Starts cooperative and dynamically adjusts based on stock health and opponent patterns,
    always erring toward cooperation when uncertain.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        if current_stock < capacity * 0.3:
            return Action.C
        last_round_cooperators = sum(history.opponent_actions[-1, :])
        cooperation_rate_last_round = last_round_cooperators / n
        if cooperation_rate_last_round >= 0.7:
            return Action.C
        rounds_to_check = min(3, len(history.opponent_actions))
        total_cooperators = 0
        total_decisions = 0
        for i in range(rounds_to_check):
            round_idx = -(i + 1)
            total_cooperators += sum(history.opponent_actions[round_idx, :])
            total_decisions += n
        cooperation_rate_recent = total_cooperators / total_decisions if total_decisions > 0 else 0
        stock_declining = False
        if len(history.my_payoffs) >= 2:
            recent_avg_payoff = np.mean(history.my_payoffs[-2:])
            earlier_avg_payoff = np.mean(history.my_payoffs[:-2]) if len(history.my_payoffs) > 2 else recent_avg_payoff
            stock_declining = recent_avg_payoff < earlier_avg_payoff * 0.9
        if stock_declining and cooperation_rate_recent < 0.5:
            return Action.C
        if current_round == total_rounds:
            if current_stock >= capacity * 0.6:
                return Action.C
        if current_round <= 3:
            if cooperation_rate_last_round >= 0.2:
                return Action.C
            else:
                return Action.C if random.random() < 0.8 else Action.D
        if current_round > total_rounds * 0.9:
            cooperation_bonus = 0.1
        else:
            cooperation_bonus = 0.0
        if cooperation_rate_recent >= 0.5:
            return Action.C
        elif cooperation_rate_recent >= 0.3:
            cooperation_prob = 0.7 + cooperation_bonus
        else:
            cooperation_prob = 0.3 + cooperation_bonus
        return Action.C if random.random() < cooperation_prob else Action.D

class Strategy_COOPERATIVE_87(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Steward"
    
    This strategy operates as a sustainable steward that prioritizes long-term resource 
    preservation while adapting to opponent behavior. It maintains cooperation when possible 
    but protects against exploitation through measured retaliation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round = state.round_number + 1
        stock = state.current_stock
        health_ratio = stock / capacity
        recent_coop_rate = self._calculate_recent_cooperation(history, min(3, history.round_number))
        game_phase = self._get_game_phase(current_round, r)
        if health_ratio < 0.3:
            if recent_coop_rate < 0.5:
                return Action.D
            else:
                return Action.C
        if health_ratio >= 0.7:
            if game_phase == 'early':
                return Action.C
            elif recent_coop_rate >= 0.6:
                return Action.C
            else:
                return self._tit_for_tat_response(history)
        if game_phase == 'early':
            return Action.C
        elif game_phase == 'end' and current_round == r:
            return Action.C if recent_coop_rate >= 0.5 else Action.D
        else:
            return self._adaptive_response(recent_coop_rate, history)

    def _calculate_recent_cooperation(self, history: PlayerHistory, window: int) -> float:
        """Calculate cooperation rate over the last 'window' rounds."""
        if history.round_number == 0:
            return 1.0
        n_players = self.game_description.n_players
        start_round = max(0, history.round_number - window)
        recent_actions = history.opponent_actions[start_round:, :]
        total_actions = recent_actions.size
        if total_actions == 0:
            return 1.0
        total_cooperations = np.sum(recent_actions)
        return total_cooperations / total_actions

    def _get_game_phase(self, current_round: int, total_rounds: int) -> str:
        """Determine the current game phase."""
        if current_round <= total_rounds // 3:
            return 'early'
        elif current_round <= 2 * total_rounds // 3:
            return 'mid'
        else:
            return 'end'

    def _tit_for_tat_response(self, history: PlayerHistory) -> Action:
        """Implement tit-for-tat based on majority behavior in last round."""
        if history.round_number == 0:
            return Action.C
        last_round_actions = history.opponent_actions[-1, :]
        cooperators = np.sum(last_round_actions)
        defectors = len(last_round_actions) - cooperators
        return Action.C if cooperators >= defectors else Action.D

    def _adaptive_response(self, recent_coop_rate: float, history: PlayerHistory) -> Action:
        """Adaptive response based on recent cooperation levels."""
        n = self.game_description.n_players
        if recent_coop_rate >= 0.7:
            return Action.C
        elif recent_coop_rate >= 0.4:
            if history.round_number == 0:
                return Action.C
            last_round_defectors = np.sum(history.opponent_actions[-1, :] == False)
            if last_round_defectors <= n // 2:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COOPERATIVE_88(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Steward"
    
    Prioritizes long-term resource sustainability while adapting to opponent behaviors.
    Starts cooperative but adjusts to protect both resource and itself from exploitation,
    always seeking to return to cooperative states when possible.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.base_threshold = 0.6
        self.initial_cooperation_rounds = max(3, int(0.25 * self.n_rounds))
        self.endgame_start = int(0.8 * self.n_rounds)
        self.sliding_window_size = min(5, max(1, self.n_rounds // 3))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number
        current_stock = state.current_stock
        if current_stock < self.n_players:
            return Action.C
        if current_round < self.initial_cooperation_rounds:
            return Action.C
        cooperation_threshold = self._calculate_cooperation_threshold(state, history)
        cooperation_index = self._calculate_trust_level(history)
        if current_round >= self.endgame_start:
            if current_round == self.n_rounds - 1 and current_stock >= self.n_players / 2:
                return Action.D
            rounds_into_endgame = current_round - self.endgame_start
            cooperation_threshold -= 0.05 * rounds_into_endgame
        if cooperation_index >= cooperation_threshold:
            return Action.C
        else:
            return Action.D

    def _calculate_cooperation_threshold(self, state: CommonPoolState, history: PlayerHistory) -> float:
        """Calculate the dynamic cooperation threshold"""
        threshold = self.base_threshold
        stock_ratio = state.current_stock / self.capacity
        stock_bonus = stock_ratio * 0.3
        threshold += stock_bonus
        trust_level = self._calculate_trust_level(history)
        history_adjustment = (trust_level - 0.5) * 0.4
        threshold += history_adjustment
        if stock_ratio > 0.9:
            threshold -= 0.1
        if trust_level < 0.2 and history.round_number >= 3:
            threshold += 0.3
        recent_coop_rate = self._get_recent_cooperation_rate(history)
        if recent_coop_rate > 0.8:
            threshold -= 0.2
        elif recent_coop_rate < 0.2:
            threshold += 0.3
        return max(0.1, min(0.9, threshold))

    def _calculate_trust_level(self, history: PlayerHistory) -> float:
        """Calculate trust level based on opponent cooperation patterns"""
        if history.round_number == 0:
            return 0.5
        window_size = min(self.sliding_window_size, history.round_number)
        recent_rounds = history.opponent_actions[-window_size:, :]
        recent_cooperations = np.sum(recent_rounds)
        recent_total = window_size * (self.n_players - 1)
        recent_cooperation_rate = recent_cooperations / recent_total if recent_total > 0 else 0.5
        total_cooperations = np.sum(history.opponent_actions)
        total_observations = history.round_number * (self.n_players - 1)
        long_term_cooperation_rate = total_cooperations / total_observations if total_observations > 0 else 0.5
        trust_level = 0.7 * recent_cooperation_rate + 0.3 * long_term_cooperation_rate
        return trust_level

    def _get_recent_cooperation_rate(self, history: PlayerHistory) -> float:
        """Get cooperation rate in recent rounds for opponent classification"""
        if history.round_number < 3:
            return 0.5
        recent_window = min(3, history.round_number)
        recent_rounds = history.opponent_actions[-recent_window:, :]
        recent_cooperations = np.sum(recent_rounds)
        recent_total = recent_window * (self.n_players - 1)
        return recent_cooperations / recent_total if recent_total > 0 else 0.5

class Strategy_COOPERATIVE_89(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Resilient Guardian"
    
    This strategy balances sustainable cooperation with adaptive responses to preserve 
    the common resource while maximizing long-term collective welfare. It operates in 
    three phases: establishment, adaptive cooperation, and endgame, with emergency 
    protocols for stock depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_num = state.round_number
        stock = state.current_stock
        stock_percentage = stock / self.capacity
        if stock_percentage < 0.2:
            return Action.D
        cooperation_rate = self._calculate_cooperation_rate(history)
        phase = self._determine_phase(round_num)
        if phase == 'establishment':
            return self._establishment_decision(stock_percentage, history, cooperation_rate)
        elif phase == 'adaptive':
            return self._adaptive_decision(stock_percentage, history, cooperation_rate)
        else:
            return self._endgame_decision(round_num, stock_percentage, cooperation_rate)

    def _calculate_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate overall cooperation rate from all players across all rounds."""
        if history.round_number == 0:
            return 0.5
        total_cooperations = np.sum(history.my_actions) + np.sum(history.opponent_actions)
        total_actions = history.round_number * self.n_players
        return total_cooperations / total_actions if total_actions > 0 else 0.5

    def _determine_phase(self, round_num: int) -> str:
        """Determine which phase of the game we're in."""
        establishment_end = max(1, math.floor(0.2 * self.n_rounds))
        endgame_start = math.floor(0.8 * self.n_rounds)
        if round_num <= establishment_end:
            return 'establishment'
        elif round_num >= endgame_start:
            return 'endgame'
        else:
            return 'adaptive'

    def _establishment_decision(self, stock_percentage: float, history: PlayerHistory, cooperation_rate: float) -> Action:
        """Decision logic for establishment phase (first 20% of rounds)."""
        if stock_percentage < 0.5:
            return Action.D
        if stock_percentage >= 0.75:
            return Action.C
        if history.round_number > 0:
            last_round_cooperators = np.sum(history.opponent_actions[-1, :])
            if last_round_cooperators >= (self.n_players - 1) / 2:
                return Action.C
        return Action.C

    def _adaptive_decision(self, stock_percentage: float, history: PlayerHistory, cooperation_rate: float) -> Action:
        """Decision logic for adaptive cooperation phase (middle 60% of rounds)."""
        sustainable_threshold = max(0.4, min(0.7, cooperation_rate))
        if stock_percentage < 0.3:
            return Action.D
        if stock_percentage < 0.5 and self._is_declining_trend(history):
            return Action.D
        if cooperation_rate >= sustainable_threshold:
            return Action.C
        elif cooperation_rate < 0.3:
            return Action.D
        return self._adapt_to_recent_behavior(history)

    def _endgame_decision(self, round_num: int, stock_percentage: float, cooperation_rate: float) -> Action:
        """Decision logic for endgame phase (final 20% of rounds)."""
        if round_num == self.n_rounds:
            return Action.D
        if round_num >= self.n_rounds - 2:
            if stock_percentage > 0.6 and cooperation_rate > 0.4:
                return Action.C
            else:
                return Action.D
        sustainable_threshold = max(0.3, min(0.6, cooperation_rate - 0.1))
        if stock_percentage > 0.8:
            return Action.C
        if cooperation_rate >= sustainable_threshold:
            return Action.C
        else:
            return Action.D

    def _is_declining_trend(self, history: PlayerHistory) -> bool:
        """Check if stock has been declining in recent rounds."""
        if history.round_number < 3:
            return False
        recent_payoffs = history.my_payoffs[-3:]
        if len(recent_payoffs) < 2:
            return False
        return recent_payoffs[-1] < recent_payoffs[0]

    def _adapt_to_recent_behavior(self, history: PlayerHistory) -> Action:
        """Adapt to recent behavior patterns of other players."""
        if history.round_number < 3:
            return Action.C
        recent_rounds = min(3, history.round_number)
        recent_opponent_actions = history.opponent_actions[-recent_rounds:, :]
        recent_cooperations = np.sum(recent_opponent_actions)
        total_recent_actions = recent_rounds * (self.n_players - 1)
        recent_coop_rate = recent_cooperations / total_recent_actions if total_recent_actions > 0 else 0.5
        if recent_coop_rate < 0.25:
            return Action.D
        if recent_coop_rate > 0.5:
            return Action.C
        return Action.C if random.random() < 0.6 else Action.D

class Strategy_COOPERATIVE_90(BaseStrategy):
    """
    Sustainable Guardian Strategy: An adaptive cooperative strategy that prioritizes 
    long-term sustainability while maintaining cooperative intentions. Adapts to 
    opponent behavior patterns to maximize collective welfare without being exploited.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        stock_health = current_stock / capacity
        recent_coop_rates = self._calculate_recent_cooperation_rates(history, 3)
        if stock_health < 0.3:
            if self._percentage_cooperated_last_round(history) >= 0.75:
                return Action.C
            else:
                return Action.D
        cooperative_opponents = sum((1 for rate in recent_coop_rates if rate >= 0.6))
        total_opponents = n - 1
        if stock_health >= 0.7:
            if cooperative_opponents >= total_opponents * 0.4:
                return Action.C
            else:
                return Action.D
        elif stock_health >= 0.5:
            if cooperative_opponents >= total_opponents * 0.6:
                return Action.C
            else:
                return Action.D
        elif cooperative_opponents >= total_opponents * 0.8:
            return Action.C
        else:
            return Action.D

    def _calculate_recent_cooperation_rates(self, history: PlayerHistory, window_size: int):
        """Calculate cooperation rates for each opponent over the last window_size rounds."""
        n_opponents = self.game_description.n_players - 1
        current_round = history.round_number
        actual_window = min(window_size, current_round)
        if actual_window == 0:
            return [1.0] * n_opponents
        cooperation_rates = []
        for opponent_idx in range(n_opponents):
            recent_actions = history.opponent_actions[-actual_window:, opponent_idx]
            coop_rate = np.mean(recent_actions)
            cooperation_rates.append(coop_rate)
        return cooperation_rates

    def _percentage_cooperated_last_round(self, history: PlayerHistory):
        """Calculate the percentage of all players (including self) who cooperated in the last round."""
        if history.round_number == 0:
            return 1.0
        last_round_opponent_cooperations = sum(history.opponent_actions[-1, :])
        my_last_action = history.my_actions[-1]
        total_cooperations = last_round_opponent_cooperations + (1 if my_last_action else 0)
        total_players = self.game_description.n_players
        return total_cooperations / total_players

class Strategy_COOPERATIVE_91(BaseStrategy):
    """
    Adaptive Sustainable Cooperation Strategy (ASCS)
    
    Prioritizes long-term sustainability while being adaptive to opponent behavior.
    Starts cooperatively but responds intelligently to defection patterns,
    always seeking to return to cooperation when conditions allow.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.window_size = max(3, self.n_rounds // 4)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = state.round_number
        stock_ratio = state.current_stock / self.capacity
        if current_round == self.n_rounds:
            if stock_ratio > 0.5 and self._get_average_cooperation_rate(history) > 0.6:
                return Action.C
            else:
                return Action.D
        if stock_ratio < 0.3:
            if self._count_recent_cooperators(history) >= self.n_players // 2:
                return Action.C
            else:
                return Action.D
        cooperative_opponents = self._count_cooperative_opponents(history)
        hostile_opponents = self._count_hostile_opponents(history)
        if cooperative_opponents >= self.n_players // 2:
            return Action.C
        if hostile_opponents >= self.n_players // 2:
            if stock_ratio > 0.7:
                return Action.C
            else:
                return Action.D
        recent_defections = self._count_recent_defections(history, window=2)
        if recent_defections >= self.n_players // 2:
            if random.random() < 0.2:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C

    def _get_cooperation_rate(self, actions):
        """Calculate cooperation rate from boolean array."""
        if len(actions) == 0:
            return 0.0
        return np.mean(actions)

    def _get_recent_actions(self, history, window_size=None):
        """Get recent opponent actions within the specified window."""
        if window_size is None:
            window_size = self.window_size
        start_idx = max(0, history.round_number - window_size)
        return history.opponent_actions[start_idx:, :]

    def _count_cooperative_opponents(self, history):
        """Count opponents classified as cooperative (cooperation rate >= 0.7)."""
        recent_actions = self._get_recent_actions(history)
        count = 0
        for player_idx in range(self.n_players - 1):
            player_actions = recent_actions[:, player_idx]
            if len(player_actions) > 0:
                coop_rate = self._get_cooperation_rate(player_actions)
                if coop_rate >= 0.7:
                    count += 1
        return count

    def _count_hostile_opponents(self, history):
        """Count opponents classified as hostile (cooperation rate <= 0.3)."""
        recent_actions = self._get_recent_actions(history)
        count = 0
        for player_idx in range(self.n_players - 1):
            player_actions = recent_actions[:, player_idx]
            if len(player_actions) > 0:
                coop_rate = self._get_cooperation_rate(player_actions)
                if coop_rate <= 0.3:
                    count += 1
        return count

    def _count_recent_cooperators(self, history):
        """Count cooperators in the most recent round."""
        if history.round_number == 0:
            return 0
        recent_round = history.opponent_actions[-1, :]
        return np.sum(recent_round)

    def _count_recent_defections(self, history, window):
        """Count recent defections within the specified window."""
        if history.round_number == 0:
            return 0
        start_idx = max(0, history.round_number - window)
        recent_actions = history.opponent_actions[start_idx:, :]
        total_defections = np.sum(~recent_actions)
        return total_defections

    def _get_average_cooperation_rate(self, history):
        """Get the average cooperation rate across all opponents."""
        if history.round_number == 0:
            return 1.0
        all_opponent_actions = history.opponent_actions.flatten()
        return self._get_cooperation_rate(all_opponent_actions)

class Strategy_COOPERATIVE_92(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Steward"
    
    Prioritizes long-term sustainability while being forgiving enough to encourage cooperation 
    and robust enough to protect against exploitation. Uses stock health assessment and 
    cooperation score tracking to make adaptive decisions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_score = 1.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if history.round_number > 0:
            last_round_cooperators = np.sum(history.opponent_actions[-1, :])
            total_opponents = self.game_description.n_players - 1
            last_round_cooperation_rate = last_round_cooperators / total_opponents if total_opponents > 0 else 1.0
            self.cooperation_score = 0.7 * self.cooperation_score + 0.3 * last_round_cooperation_rate
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if current_stock >= 0.7 * capacity:
            stock_health = 'Healthy'
        elif current_stock >= 0.3 * capacity:
            stock_health = 'Stressed'
        else:
            stock_health = 'Critical'
        is_final_round = state.round_number == self.game_description.n_rounds - 1
        if is_final_round:
            if stock_health == 'Critical':
                return Action.C
            elif self.cooperation_score >= 0.5:
                return Action.C
            else:
                return Action.D
        if stock_health == 'Critical':
            if self.cooperation_score < 0.3:
                return Action.D
            else:
                return Action.C
        elif stock_health == 'Stressed':
            if self.cooperation_score < 0.5:
                return Action.D
            else:
                return Action.C
        elif self.cooperation_score < 0.2:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_93(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Guardian"
    
    This strategy aims to maximize long-term collective welfare while protecting against 
    exploitation through adaptive cooperation that responds to both resource state and 
    opponent behavior patterns.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.rounds_since_last_defection = 0
        self.consecutive_high_cooperation_rounds = 0
        self.declining_stock_rounds = 0
        self.last_stock = None
        self.emergency_conservation_rounds = 0
        self.cooperation_threshold_adjustment = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.last_stock = state.current_stock
            return Action.C
        self._update_tracking_variables(state, history)
        if self._is_emergency_conservation_needed(state):
            return Action.C
        stock_health = self._assess_stock_health(state)
        cooperation_rate = self._calculate_cooperation_rate(history)
        if state.round_number == self.game_description.n_rounds - 1:
            return self._last_round_decision(stock_health, history)
        else:
            return self._middle_round_decision(stock_health, cooperation_rate)

    def _update_tracking_variables(self, state: CommonPoolState, history: PlayerHistory):
        """Update internal tracking variables"""
        if len(history.my_actions) > 0 and (not history.my_actions[-1]):
            self.rounds_since_last_defection = 0
        else:
            self.rounds_since_last_defection += 1
        cooperation_rate = self._calculate_cooperation_rate(history)
        if cooperation_rate >= 0.7:
            self.consecutive_high_cooperation_rounds += 1
        else:
            self.consecutive_high_cooperation_rounds = 0
        if self.last_stock is not None and state.current_stock < self.last_stock:
            self.declining_stock_rounds += 1
        else:
            self.declining_stock_rounds = 0
        if self.emergency_conservation_rounds > 0:
            self.emergency_conservation_rounds -= 1
        if self.declining_stock_rounds >= 3 and cooperation_rate > 0.5 and (self.cooperation_threshold_adjustment < 0.2):
            self.cooperation_threshold_adjustment += 0.1
        if self.consecutive_high_cooperation_rounds >= 3:
            self.cooperation_threshold_adjustment = 0.0
        self.last_stock = state.current_stock

    def _is_emergency_conservation_needed(self, state: CommonPoolState) -> bool:
        """Check if emergency conservation protocol should activate"""
        critical_threshold = 0.15 * self.game_description.capacity
        if state.current_stock < critical_threshold and self.emergency_conservation_rounds == 0:
            self.emergency_conservation_rounds = 2
            return True
        return self.emergency_conservation_rounds > 0

    def _assess_stock_health(self, state: CommonPoolState) -> str:
        """Assess current resource health level"""
        capacity = self.game_description.capacity
        stock_ratio = state.current_stock / capacity
        if stock_ratio >= 0.7:
            return 'Healthy'
        elif stock_ratio >= 0.3:
            return 'Stressed'
        else:
            return 'Critical'

    def _calculate_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate cooperation rate over recent rounds"""
        if len(history.opponent_actions) == 0:
            return 1.0
        rounds_to_check = min(5, len(history.opponent_actions))
        recent_actions = history.opponent_actions[-rounds_to_check:]
        total_actions = recent_actions.size
        if total_actions == 0:
            return 1.0
        cooperative_actions = np.sum(recent_actions)
        return float(cooperative_actions) / total_actions

    def _calculate_overall_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate overall cooperation rate across all rounds"""
        if len(history.opponent_actions) == 0:
            return 1.0
        total_actions = history.opponent_actions.size
        if total_actions == 0:
            return 1.0
        cooperative_actions = np.sum(history.opponent_actions)
        return float(cooperative_actions) / total_actions

    def _middle_round_decision(self, stock_health: str, cooperation_rate: float) -> Action:
        """Decision logic for middle rounds"""
        if self.consecutive_high_cooperation_rounds >= 3:
            pass
        adjusted_coop_rate_high = 0.8 + self.cooperation_threshold_adjustment
        adjusted_coop_rate_mid = 0.6 + self.cooperation_threshold_adjustment
        adjusted_coop_rate_low = 0.4 + self.cooperation_threshold_adjustment
        if stock_health == 'Critical':
            return Action.C
        elif stock_health == 'Stressed':
            if cooperation_rate >= adjusted_coop_rate_mid:
                return Action.C
            else:
                return Action.D
        elif cooperation_rate >= adjusted_coop_rate_high:
            return Action.C
        elif cooperation_rate >= adjusted_coop_rate_low:
            if self.rounds_since_last_defection >= 3:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _last_round_decision(self, stock_health: str, history: PlayerHistory) -> Action:
        """Decision logic for the last round"""
        if stock_health == 'Critical':
            return Action.C
        overall_cooperation_rate = self._calculate_overall_cooperation_rate(history)
        if overall_cooperation_rate >= 0.6:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_94(BaseStrategy):
    """
    Adaptive Sustainability Strategy (ASS) - Prioritizes long-term collective welfare 
    while maintaining resilience against exploitation through graduated responses 
    based on stock health and cooperation rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        current_round = history.round_number + 1
        final_round = self.game_description.n_rounds
        stock_health_ratio = state.current_stock / capacity
        sustainability_threshold = max(0.3, 1 / n)
        last_round_cooperators = sum(history.opponent_actions[-1, :])
        cooperation_rate_last_round = last_round_cooperators / n
        if current_round == final_round:
            if stock_health_ratio > sustainability_threshold:
                return Action.C
            else:
                return Action.D
        if stock_health_ratio < sustainability_threshold:
            if cooperation_rate_last_round >= 0.5:
                return Action.C
            else:
                return Action.D
        cooperation_threshold = 0.3 + 0.4 * stock_health_ratio
        if cooperation_rate_last_round >= cooperation_threshold:
            return Action.C
        else:
            defection_severity = 1 - cooperation_rate_last_round
            if defection_severity > 0.7:
                return Action.D
            elif defection_severity > 0.4:
                if stock_health_ratio > 0.6:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.C

class Strategy_COOPERATIVE_95(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Stock Guardian"
    
    Prioritizes long-term sustainability while being adaptive to opponent behavior.
    Starts cooperative but can defend against exploitation while maintaining
    pathways back to cooperation through threshold-based decisions and forgiveness mechanisms.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.base_threshold = game_description.capacity * 0.4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        round_number = history.round_number
        if current_stock < capacity * 0.15:
            if len(history.opponent_actions) > 0:
                last_round_actions = history.opponent_actions[-1, :]
                if np.all(last_round_actions == 1):
                    return Action.C
            return Action.D
        if current_stock >= capacity * 0.9:
            return Action.C
        cooperation_rate = self._calculate_cooperation_rate(history)
        threshold = self._calculate_adaptive_threshold(cooperation_rate, history)
        if current_stock >= threshold:
            return Action.C
        else:
            return Action.D

    def _calculate_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate the overall cooperation rate of opponents."""
        if len(history.opponent_actions) == 0:
            return 0.5
        total_actions = np.sum(history.opponent_actions >= 0)
        total_cooperations = np.sum(history.opponent_actions == 1)
        if total_actions == 0:
            return 0.5
        return total_cooperations / total_actions

    def _calculate_adaptive_threshold(self, cooperation_rate: float, history: PlayerHistory) -> float:
        """Calculate adaptive threshold based on opponent behavior patterns."""
        base_threshold = self.base_threshold
        if cooperation_rate >= 0.7:
            threshold = base_threshold * 0.9
        elif cooperation_rate <= 0.3:
            threshold = base_threshold * 1.15
        else:
            threshold = base_threshold
        if self._has_recent_cooperation_trend(history) and cooperation_rate >= 0.5:
            threshold = base_threshold * 0.95
        return threshold

    def _has_recent_cooperation_trend(self, history: PlayerHistory) -> bool:
        """Check if opponents show sustained cooperation in recent rounds."""
        if len(history.opponent_actions) < 2:
            return False
        recent_rounds = min(3, len(history.opponent_actions))
        recent_actions = history.opponent_actions[-recent_rounds:, :]
        total_recent_actions = np.sum(recent_actions >= 0)
        total_recent_cooperations = np.sum(recent_actions == 1)
        if total_recent_actions == 0:
            return False
        recent_coop_rate = total_recent_cooperations / total_recent_actions
        return recent_coop_rate >= 0.5

class Strategy_COOPERATIVE_96(BaseStrategy):
    """
    Sustainable Guardian: An adaptive cooperative strategy that prioritizes long-term 
    resource sustainability while defending against exploitation. Uses stock-sensitive 
    thresholds and multi-timeframe analysis to balance cooperation with pragmatic adaptation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = state.round_number
        current_stock = state.current_stock
        critical_threshold = self.capacity * 0.3
        healthy_threshold = self.capacity * 0.7
        if current_stock <= critical_threshold:
            return Action.C
        if current_stock >= healthy_threshold:
            return Action.C
        if current_round == self.n_rounds - 1:
            if current_stock > self.capacity * 0.5:
                return Action.C
            else:
                return Action.D
        if len(history.my_actions) > 0:
            min_payoff = np.min(history.my_payoffs)
            if min_payoff < 0.1:
                return Action.C
        recent_window = min(3, len(history.my_actions))
        if recent_window > 0:
            recent_opponent_actions = history.opponent_actions[-recent_window:, :]
            recent_defections = np.sum(recent_opponent_actions == False)
            recent_total = recent_window * self.n_players
            recent_defection_rate = recent_defections / recent_total if recent_total > 0 else 0
        else:
            recent_defection_rate = 0
        if len(history.my_actions) > 0:
            all_opponent_actions = history.opponent_actions
            total_defections = np.sum(all_opponent_actions == False)
            total_actions = len(history.my_actions) * self.n_players
            historical_defection_rate = total_defections / total_actions if total_actions > 0 else 0
        else:
            historical_defection_rate = 0
        if recent_defection_rate > 0.6:
            return Action.D
        elif recent_defection_rate > 0.3:
            if random.random() < recent_defection_rate:
                return Action.D
            else:
                return Action.C
        else:
            return Action.C
        final_phase_start = math.ceil(self.n_rounds * 0.8)
        if current_round >= final_phase_start:
            if current_stock >= self.capacity * 0.8:
                return Action.C
            elif current_stock > critical_threshold:
                base_defection_prob = min(0.4, recent_defection_rate * 1.2)
                if random.random() < base_defection_prob:
                    return Action.D
        if len(history.my_actions) >= 3:
            recent_payoffs = history.my_payoffs[-3:]
            if len(recent_payoffs) >= 2:
                payoff_trend = recent_payoffs[-1] - recent_payoffs[0]
                if payoff_trend < -5 and recent_defection_rate > 0.4:
                    return Action.C
        if len(history.my_actions) >= 2:
            last_2_rounds = history.opponent_actions[-2:, :]
            defections_last_2 = np.sum(last_2_rounds == False)
            total_last_2 = 2 * self.n_players
            if defections_last_2 / total_last_2 > 0.8 and current_stock > self.capacity * 0.4:
                return Action.D
        return Action.C

class Strategy_COOPERATIVE_97(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Guardian"
    
    Prioritizes long-term sustainability while being cooperative by default,
    with robust defensive mechanisms against exploitation. Uses a weighted
    scoring system to balance resource preservation and cooperative reciprocity.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_num = history.round_number
        current_stock = state.current_stock
        if current_stock <= 0.2 * self.capacity:
            return Action.D
        if round_num == 1:
            return Action.C
        if round_num >= self.n_rounds - 2:
            return self._end_game_strategy(state, history)
        return self._adaptive_cooperation_strategy(state, history)

    def _adaptive_cooperation_strategy(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        score = 0
        current_stock = state.current_stock
        stock_ratio = current_stock / self.capacity
        if stock_ratio >= 0.7:
            score += 2
        elif stock_ratio >= 0.4:
            score += 1
        else:
            score += -1
        cooperation_rate = self._get_recent_cooperation_rate(history, 2)
        if cooperation_rate >= 0.6:
            score += 2
        elif cooperation_rate >= 0.3:
            score += 1
        else:
            score += -2
        if len(history.my_actions) >= 2:
            trend_score = self._analyze_stock_trend(history)
            score += trend_score
        if len(history.my_actions) >= 1:
            my_last_action = history.my_actions[-1]
            opponent_last_actions = history.opponent_actions[-1, :]
            if my_last_action and (not any(opponent_last_actions)):
                score += -2
            total_cooperators = sum(opponent_last_actions) + (1 if my_last_action else 0)
            cooperation_rate_last = total_cooperators / self.n_players
            if cooperation_rate_last < 0.25 and current_stock < 0.5 * self.capacity:
                score += -1
        if score >= 2:
            return Action.C
        elif score <= -2:
            return Action.D
        else:
            return self._tit_for_tat(history)

    def _end_game_strategy(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        round_num = history.round_number
        current_stock = state.current_stock
        if round_num == self.n_rounds - 2:
            recent_cooperation_rate = self._get_recent_cooperation_rate(history, 2)
            if current_stock >= 0.5 * self.capacity and recent_cooperation_rate >= 0.4:
                return Action.C
            else:
                return Action.D
        else:
            if len(history.my_actions) >= 1:
                my_last_action = history.my_actions[-1]
                opponent_last_actions = history.opponent_actions[-1, :]
                last_cooperation_rate = sum(opponent_last_actions) / len(opponent_last_actions)
                if current_stock >= 0.6 * self.capacity and my_last_action and (last_cooperation_rate >= 0.5):
                    return Action.C
            return Action.D

    def _get_recent_cooperation_rate(self, history: PlayerHistory, num_rounds: int) -> float:
        """Calculate cooperation rate over the last num_rounds rounds."""
        if len(history.my_actions) == 0:
            return 0.5
        start_idx = max(0, len(history.my_actions) - num_rounds)
        total_cooperations = 0
        total_actions = 0
        for round_idx in range(start_idx, len(history.my_actions)):
            if history.my_actions[round_idx]:
                total_cooperations += 1
            total_actions += 1
            for opponent_action in history.opponent_actions[round_idx, :]:
                if opponent_action:
                    total_cooperations += 1
                total_actions += 1
        return total_cooperations / total_actions if total_actions > 0 else 0.5

    def _analyze_stock_trend(self, history: PlayerHistory) -> int:
        """Analyze stock trend based on payoff patterns. Returns score adjustment."""
        if len(history.my_payoffs) < 2:
            return 0
        recent_avg = np.mean(history.my_payoffs[-2:])
        earlier_avg = np.mean(history.my_payoffs[:-2]) if len(history.my_payoffs) > 2 else recent_avg
        threshold = 0.05 * self.capacity / (2 * self.n_players)
        if recent_avg > earlier_avg + threshold:
            return 1
        elif recent_avg < earlier_avg - threshold:
            return -1
        else:
            return 0

    def _tit_for_tat(self, history: PlayerHistory) -> Action:
        """Match the majority action from the previous round."""
        if len(history.my_actions) == 0:
            return Action.C
        my_last_action = history.my_actions[-1]
        opponent_last_actions = history.opponent_actions[-1, :]
        total_cooperators = sum(opponent_last_actions) + (1 if my_last_action else 0)
        if total_cooperators >= self.n_players / 2:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_98(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Steward"
    
    Balances long-term sustainability with adaptive responses to group behavior.
    Uses stock health, group cooperation levels, and recent trends to make decisions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_num = state.round_number
        current_stock = state.current_stock
        if round_num <= 2:
            return Action.C
        stock_health = current_stock / self.capacity
        if stock_health < 0.2:
            return Action.C
        elif stock_health < 0.3:
            stock_mode = 'CRISIS'
        elif stock_health < 0.6:
            stock_mode = 'CAUTION'
        else:
            stock_mode = 'STABLE'
        total_actions = len(history.my_actions) * self.n_players
        total_cooperations = np.sum(history.opponent_actions) + np.sum(history.my_actions)
        group_coop_rate = total_cooperations / total_actions
        if group_coop_rate >= 0.7:
            trust_level = 'HIGH_TRUST'
        elif group_coop_rate >= 0.4:
            trust_level = 'MEDIUM_TRUST'
        else:
            trust_level = 'LOW_TRUST'
        recent_rounds = min(2, len(history.opponent_actions))
        recent_defections = 0
        for i in range(recent_rounds):
            round_idx = -(i + 1)
            recent_defections += np.sum(history.opponent_actions[round_idx, :] == False)
        under_attack = recent_defections > self.n_players
        my_total_payoff = np.sum(history.my_payoffs)
        estimated_max_possible = my_total_payoff * 1.5
        exploitation_ratio = max(0, (estimated_max_possible - my_total_payoff) / max(estimated_max_possible, 1))
        being_exploited = exploitation_ratio > 0.3
        coop_probability = 0.5
        if stock_mode == 'CRISIS':
            coop_probability = 0.95
        elif stock_mode == 'CAUTION':
            if trust_level == 'HIGH_TRUST':
                coop_probability = 0.85
            elif trust_level == 'MEDIUM_TRUST':
                coop_probability = 0.7
            else:
                coop_probability = 0.5
            if under_attack:
                coop_probability = 0.8
        else:
            if trust_level == 'HIGH_TRUST':
                coop_probability = 0.8
            elif trust_level == 'MEDIUM_TRUST':
                coop_probability = 0.65
            else:
                coop_probability = 0.4
            if under_attack:
                coop_probability = 0.2
        if being_exploited and len(history.my_actions) >= 3:
            recent_payoffs = history.my_payoffs[-3:]
            avg_recent = np.mean(recent_payoffs)
            if avg_recent < np.mean(history.my_payoffs) * 0.6:
                coop_probability *= 0.5
        rounds_remaining = self.n_rounds - round_num
        if rounds_remaining <= 2:
            coop_probability *= 0.85
        if rounds_remaining == 1 and stock_health > 0.5:
            coop_probability = 0.7
        if len(history.opponent_actions) >= 3:
            opponent_coop_rates = np.mean(history.opponent_actions, axis=0)
            max_trustworthiness = np.max(opponent_coop_rates)
            if max_trustworthiness > 0.8:
                coop_probability = min(0.98, coop_probability + 0.05)
            elif max_trustworthiness < 0.2:
                coop_probability = max(0.02, coop_probability - 0.1)
        if len(history.opponent_actions) >= 4:
            recent_coop_rate = np.mean(history.opponent_actions[-2:])
            earlier_coop_rate = np.mean(history.opponent_actions[-4:-2])
            if recent_coop_rate > earlier_coop_rate + 0.1:
                coop_probability = min(0.95, coop_probability + 0.1)
        return Action.C if random.random() < coop_probability else Action.D

class Strategy_COOPERATIVE_99(BaseStrategy):
    """
    Adaptive Cooperative Strategy: 'Sustainable Guardian'
    
    Balances cooperation with self-protection through adaptive thresholds.
    Aims to maximize long-term collective welfare while being robust against exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.early_defection_detected = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round = state.round_number + 1
        current_stock = state.current_stock
        sustainability_index = current_stock / capacity
        total_cooperations = np.sum(history.opponent_actions) + np.sum(history.my_actions)
        total_actions = len(history.my_actions) * n
        cooperation_rate = total_cooperations / total_actions if total_actions > 0 else 0
        if current_round == total_rounds:
            return Action.D
        if current_round == total_rounds - 1:
            return Action.C if cooperation_rate >= 0.6 else Action.D
        if sustainability_index < 0.2:
            if len(history.opponent_actions) > 0:
                last_round_cooperations = np.sum(history.opponent_actions[-1, :])
                last_round_total = len(history.opponent_actions[-1, :])
                recent_cooperation_rate = last_round_cooperations / last_round_total if last_round_total > 0 else 0
                return Action.C if recent_cooperation_rate > 0.7 else Action.D
            else:
                return Action.D
        if current_round <= 3 and cooperation_rate < 0.4:
            self.early_defection_detected = True
        if self.early_defection_detected:
            cooperation_threshold = 0.25
        else:
            cooperation_threshold = max(0.4, 1.0 / n)
        if len(history.my_actions) >= 2:
            prev_total_cooperations = np.sum(history.opponent_actions[:-1]) + np.sum(history.my_actions[:-1])
            prev_total_actions = (len(history.my_actions) - 1) * n
            prev_cooperation_rate = prev_total_cooperations / prev_total_actions if prev_total_actions > 0 else 0
            if cooperation_rate - prev_cooperation_rate > 0.2:
                cooperation_threshold = max(cooperation_threshold - 0.1, 0.2)
        if sustainability_index >= 0.3 and cooperation_rate >= cooperation_threshold and (current_round <= total_rounds - 2):
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_100(BaseStrategy):
    """
    Adaptive Cooperative Resource Management Strategy - "Sustainable Guardian"
    
    This strategy prioritizes long-term sustainability while being robust against exploitation.
    It balances cooperation with adaptive responses to maintain both resource health and 
    competitive viability. Key features:
    - Starts cooperatively but adapts based on resource health and opponent behavior
    - Uses dynamic thresholds based on game parameters and history
    - Implements emergency defection when resources are critically low
    - Includes forgiveness mechanisms to recover cooperation
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        stock_health = state.current_stock / self.capacity
        round_number = state.round_number
        if stock_health < 0.3:
            return Action.D
        cooperation_threshold = self._calculate_cooperation_threshold(round_number)
        recent_coop_rate = self._calculate_recent_cooperation(history)
        if round_number == self.n_rounds:
            if stock_health > 0.5:
                return Action.C
            else:
                return Action.D
        if stock_health >= 0.7 and recent_coop_rate >= cooperation_threshold:
            return Action.C
        elif stock_health >= 0.5 and recent_coop_rate >= cooperation_threshold + 0.2:
            return Action.C
        else:
            return Action.D

    def _calculate_cooperation_threshold(self, round_number: int) -> float:
        """Calculate dynamic cooperation threshold based on game parameters."""
        base_threshold = 0.4
        early_game_bonus = max(0, (self.n_rounds / 4 - round_number) / (self.n_rounds / 4)) * 0.2
        group_adjustment = (self.n_players - 2) * 0.05
        return min(0.8, base_threshold + group_adjustment - early_game_bonus)

    def _calculate_recent_cooperation(self, history: PlayerHistory) -> float:
        """Calculate recent cooperation rate with dynamic lookback window."""
        if history.round_number == 0:
            return 1.0
        lookback_window = min(5, max(2, history.round_number // 3))
        window = min(lookback_window, history.round_number)
        recent_opponent_actions = history.opponent_actions[-window:, :]
        total_cooperators = np.sum(recent_opponent_actions)
        total_possible = recent_opponent_actions.size
        return total_cooperators / total_possible if total_possible > 0 else 1.0

class Strategy_COOPERATIVE_101(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Guardian"
    
    This strategy aims to maximize long-term collective welfare by maintaining stock 
    sustainability while being resilient to exploitation. It balances cooperation 
    with strategic defection to protect the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.rounds_since_last_punishment = 0
        self.consecutive_mutual_cooperation = 0
        self.threshold_adjustment = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.rounds_since_last_punishment = 0
            self.consecutive_mutual_cooperation = 0
            return Action.C
        stock_health = state.current_stock / self.game_description.capacity
        last_round_cooperators = sum(history.opponent_actions[-1, :])
        cooperation_rate = last_round_cooperators / self.game_description.n_players
        self._update_tracking_variables(history, cooperation_rate)
        edge_case_action = self._handle_edge_cases(state, history, stock_health, cooperation_rate)
        if edge_case_action is not None:
            return edge_case_action
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds - 1:
            return self._final_round_logic(stock_health, cooperation_rate)
        return self._main_decision_logic(stock_health, cooperation_rate, history)

    def _update_tracking_variables(self, history, cooperation_rate):
        """Update internal tracking variables"""
        if cooperation_rate >= 0.8 and history.my_actions[-1]:
            self.consecutive_mutual_cooperation += 1
        else:
            self.consecutive_mutual_cooperation = 0
        if history.my_actions[-1]:
            self.rounds_since_last_punishment += 1
        else:
            self.rounds_since_last_punishment = 0

    def _handle_edge_cases(self, state, history, stock_health, cooperation_rate):
        """Handle special edge cases"""
        if state.current_stock < 0.1 * self.game_description.capacity:
            return Action.D
        if stock_health > 0.9:
            return Action.C
        if len(history.my_payoffs) >= 2:
            prev_stock = self._estimate_previous_stock(history)
            if abs(state.current_stock - prev_stock) / prev_stock > 0.4:
                self.threshold_adjustment = min(0.2, self.threshold_adjustment + 0.1)
        if cooperation_rate == 0.0 and len(history.my_actions) > 1:
            return Action.C
        return None

    def _estimate_previous_stock(self, history):
        """Estimate previous round's stock from payoff information"""
        last_payoff = history.my_payoffs[-1]
        last_action_cooperated = history.my_actions[-1]
        if last_action_cooperated:
            estimated_stock = last_payoff * 2 * self.game_description.n_players
        else:
            estimated_stock = last_payoff * self.game_description.n_players
        return max(estimated_stock, 1.0)

    def _final_round_logic(self, stock_health, cooperation_rate):
        """Logic for the final round"""
        if stock_health < 0.3:
            return Action.D
        elif cooperation_rate >= 0.5:
            return Action.C
        else:
            return Action.D

    def _main_decision_logic(self, stock_health, cooperation_rate, history):
        """Main decision logic for middle rounds"""
        coop_threshold_low = 0.3 + self.threshold_adjustment
        coop_threshold_medium = 0.6 + self.threshold_adjustment
        coop_threshold_high = 0.4 + self.threshold_adjustment
        if self.consecutive_mutual_cooperation >= 3:
            coop_threshold_low -= 0.1
            coop_threshold_medium -= 0.1
            coop_threshold_high -= 0.1
        if stock_health < 0.3:
            if cooperation_rate >= 0.5:
                return Action.C
            else:
                return Action.D
        elif stock_health <= 0.7:
            if cooperation_rate >= coop_threshold_medium:
                return Action.C
            elif cooperation_rate >= coop_threshold_low:
                if self._was_exploited_last_round(history):
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.D
        elif cooperation_rate >= coop_threshold_high:
            return Action.C
        elif self.rounds_since_last_punishment > 2:
            return Action.D
        else:
            return Action.C

    def _was_exploited_last_round(self, history):
        """Check if we cooperated but were exploited by low cooperation from others"""
        if not history.my_actions[-1]:
            return False
        last_round_cooperators = sum(history.opponent_actions[-1, :])
        cooperation_rate = last_round_cooperators / self.game_description.n_players
        return cooperation_rate < 0.4

class Strategy_COOPERATIVE_102(BaseStrategy):
    """
    Adaptive Stewardship Strategy: Balances cooperative resource stewardship with defensive mechanisms 
    against exploitation. Maintains the common pool while being robust to various opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_num = history.round_number + 1
        stock_health = state.current_stock / self.capacity
        if stock_health < 0.3:
            return Action.D
        if round_num == self.n_rounds:
            return Action.D
        if round_num <= 3:
            if stock_health < 0.4:
                return Action.D
            return Action.C
        recent_rounds = min(3, len(history.opponent_actions))
        recent_coop_ratios = []
        for i in range(recent_rounds):
            round_idx = -(i + 1)
            cooperators = sum(history.opponent_actions[round_idx, :])
            coop_ratio = cooperators / self.n_players
            recent_coop_ratios.append(coop_ratio)
        avg_recent_coop = np.mean(recent_coop_ratios) if recent_coop_ratios else 0.5
        stock_trend = 0
        if len(history.my_payoffs) >= 2:
            last_payoff = history.my_payoffs[-1]
            prev_payoff = history.my_payoffs[-2]
            if last_payoff > 0 and prev_payoff > 0:
                stock_trend = (last_payoff - prev_payoff) / prev_payoff
        cooperation_momentum = 0.4 * avg_recent_coop + 0.3 * max(0, stock_trend) + 0.3 * stock_health
        recent_defection_rate = 1 - avg_recent_coop
        stock_decline_rate = max(0, -stock_trend)
        defection_momentum = 0.5 * recent_defection_rate + 0.5 * stock_decline_rate
        if cooperation_momentum > defection_momentum:
            return Action.C
        if len(history.opponent_actions) > 0:
            last_round_defectors = sum(history.opponent_actions[-1, :] == False)
            if last_round_defectors / self.n_players > 0.75:
                return Action.D
        if len(history.opponent_actions) > 0:
            last_cooperators = sum(history.opponent_actions[-1, :])
            if last_cooperators / self.n_players >= 0.5:
                return Action.C
        if len(history.my_payoffs) >= 3 and len(history.opponent_payoffs) >= 3:
            my_avg_recent = np.mean(history.my_payoffs[-3:])
            opponent_avg_recent = np.mean(history.opponent_payoffs[-3:])
            if my_avg_recent > 0 and opponent_avg_recent > my_avg_recent * 1.5:
                cooperation_prob = max(0.1, stock_health * 0.5)
                return Action.C if random.random() < cooperation_prob else Action.D
        historical_coop_ratio = np.mean([sum(history.opponent_actions[i, :]) / self.n_players for i in range(len(history.opponent_actions))]) if len(history.opponent_actions) > 0 else 0.5
        cooperation_prob = 0.3 + 0.6 * stock_health + 0.1 * historical_coop_ratio
        cooperation_prob = max(0.1, min(0.9, cooperation_prob))
        return Action.C if random.random() < cooperation_prob else Action.D

class Strategy_COOPERATIVE_103(BaseStrategy):
    """
    Adaptive Stewardship Strategy: Balances immediate cooperation with long-term resource 
    sustainability, adapting to opponent behavior while maintaining a fundamentally 
    cooperative orientation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        rhi = state.current_stock / self.game_description.capacity
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        n_opponents = self.game_description.n_players - 1
        if current_round <= 2:
            if current_round == 1:
                recent_coop_rate = np.mean(history.opponent_actions[0, :])
            else:
                recent_coop_rate = np.mean(history.opponent_actions[:2, :])
            return Action.C if recent_coop_rate >= 0.5 else Action.D
        rounds_to_consider = min(3, len(history.opponent_actions))
        weights = [0.5, 0.3, 0.2][:rounds_to_consider]
        recent_coop_rate = 0
        for i in range(rounds_to_consider):
            round_idx = len(history.opponent_actions) - 1 - i
            round_coop_rate = np.mean(history.opponent_actions[round_idx, :])
            recent_coop_rate += weights[i] * round_coop_rate
        recent_coop_rate /= sum(weights[:rounds_to_consider])
        if rhi >= 0.8:
            threshold = 0.3
        elif rhi >= 0.5:
            threshold = 0.5
        elif rhi >= 0.2:
            threshold = 0.7
        else:
            threshold = 0.9
        if len(history.my_actions) >= 2:
            if rhi > 0.3 and recent_coop_rate > 0.3:
                return Action.C
        if recent_coop_rate >= threshold:
            return Action.C
        if (current_round + 1) % 4 == 0 and rhi > 0.15:
            return Action.C
        if current_round >= total_rounds - 2 and rhi > 0.25:
            return Action.C
        if current_round >= total_rounds - 2:
            if rhi > 0.5:
                return Action.C
            elif rhi > 0.25:
                if len(history.opponent_actions) > 0:
                    last_round_cooperators = np.sum(history.opponent_actions[-1, :])
                    if last_round_cooperators >= 1:
                        return Action.C
            elif len(history.opponent_actions) > 0:
                last_round_coop_rate = np.mean(history.opponent_actions[-1, :])
                return Action.C if last_round_coop_rate > 0.5 else Action.D
        if rhi < 0.1:
            if len(history.opponent_actions) > 0:
                last_round_coop_rate = np.mean(history.opponent_actions[-1, :])
                return Action.C if last_round_coop_rate >= 0.9 else Action.D
        return Action.D

class Strategy_COOPERATIVE_104(BaseStrategy):
    """
    Adaptive Sustainable Cooperation Strategy (ASCS)
    
    Balances long-term resource sustainability with strategic adaptation to opponent behavior.
    Maintains cooperative foundation while protecting against exploitation through reciprocity
    and stock-health based adjustments.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_num = state.round_number
        stock = state.current_stock
        stock_ratio = stock / self.capacity
        base_coop_prob = min(0.9, stock_ratio + 0.1)
        if stock < 0.2 * self.capacity:
            return Action.C
        recent_rounds = min(5, history.round_number)
        if recent_rounds > 0:
            recent_opponent_actions = history.opponent_actions[-recent_rounds:, :]
            avg_opponent_coop = np.mean(recent_opponent_actions)
        else:
            avg_opponent_coop = 0.5
        reciprocity_factor = 0.5 + 0.5 * avg_opponent_coop
        adjusted_prob = base_coop_prob * reciprocity_factor
        if round_num == self.n_rounds:
            if stock > 0.6 * self.capacity and avg_opponent_coop > 0.4:
                return Action.C
            else:
                return Action.D
        if round_num <= 3:
            if avg_opponent_coop > 0.3:
                return Action.C
            else:
                return Action.C if random.random() < 0.7 else Action.D
        if avg_opponent_coop > 0.6:
            final_prob = min(0.95, adjusted_prob + 0.2)
        elif avg_opponent_coop > 0.3:
            final_prob = adjusted_prob
        else:
            final_prob = max(0.25, adjusted_prob - 0.3)
        if avg_opponent_coop < 0.2 and stock_ratio < 0.8:
            final_prob = max(0.15, final_prob - 0.1)
        final_prob = max(0.15, final_prob)
        return Action.C if random.random() < final_prob else Action.D

class Strategy_COOPERATIVE_105(BaseStrategy):
    """
    Adaptive Threshold Cooperation Strategy (ATCS) that balances cooperative intent 
    with adaptive protection against exploitation, using stock level as a key indicator 
    of collective behavior and sustainability needs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.cooperation_threshold = self.capacity * 0.6
        self.crisis_threshold = self.capacity * 0.3
        self.recovery_threshold = self.capacity * 0.8
        self.trust_reset_flag = False
        self.leading_by_example_count = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.n_rounds - 1:
            last_round_cooperators = sum(history.opponent_actions[-1, :])
            majority_cooperated = last_round_cooperators > (self.n_players - 1) / 2
            return Action.C if majority_cooperated else Action.D
        if current_stock < self.crisis_threshold:
            return Action.D
        if current_stock > self.recovery_threshold and (not self.trust_reset_flag):
            self.trust_reset_flag = True
            self.leading_by_example_count = 0
        elif current_stock <= self.recovery_threshold:
            self.trust_reset_flag = False
        window_size = min(5, history.round_number)
        trustworthy_opponents = 0
        recent_opponent_actions = history.opponent_actions[-window_size:, :]
        for player_idx in range(self.n_players - 1):
            cooperation_rate = np.mean(recent_opponent_actions[:, player_idx])
            if cooperation_rate >= 0.6:
                trustworthy_opponents += 1
        majority_trustworthy = trustworthy_opponents >= (self.n_players - 1) / 2
        my_recent_actions = history.my_actions[-window_size:]
        my_cooperation_rate = np.mean(my_recent_actions)
        if current_stock >= self.cooperation_threshold:
            if majority_trustworthy:
                self.leading_by_example_count = 0
                return Action.C
            elif my_cooperation_rate > 0.5:
                if self.leading_by_example_count < 3:
                    self.leading_by_example_count += 1
                    return Action.C
                else:
                    self.leading_by_example_count = 0
                    return Action.D
            else:
                return Action.D
        else:
            last_round_cooperators = sum(history.opponent_actions[-1, :])
            all_cooperated_last = last_round_cooperators == self.n_players - 1
            if all_cooperated_last:
                return Action.C
            elif trustworthy_opponents >= (self.n_players - 1) * 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_COOPERATIVE_106(BaseStrategy):
    """
    Adaptive Cooperative Resource Management Strategy (ACRMS)
    
    Prioritizes long-term sustainability while adapting to opponent behavior.
    Uses stock health index and recent defection rates to make decisions.
    Includes forgiveness protocols and endgame strategies.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_number = state.round_number
        stock = state.current_stock
        shi = stock / self.capacity
        if round_number <= 3:
            if round_number == 1:
                return Action.C
            if shi >= 0.5:
                return Action.C
            else:
                return Action.D
        if round_number > 0.8 * self.n_rounds:
            if shi >= 0.5:
                return Action.C
            elif shi >= 0.2:
                if self._majority_cooperated_last_round(history):
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
        if self._should_attempt_forgiveness(round_number, history) and shi >= 0.4:
            return Action.C
        if self._stock_recovery_detected(history) and shi >= 0.15:
            return Action.C
        if shi >= 0.6:
            return Action.C
        elif shi < 0.3:
            return Action.D
        else:
            recent_defection_rate = self._calculate_recent_defection_rate(history, 2)
            if recent_defection_rate <= 0.4:
                return Action.C
            else:
                return Action.D

    def _majority_cooperated_last_round(self, history: PlayerHistory) -> bool:
        """Check if majority of players cooperated in the last round."""
        if len(history.opponent_actions) == 0:
            return True
        last_round_cooperators = np.sum(history.opponent_actions[-1, :])
        if history.my_actions[-1]:
            last_round_cooperators += 1
        return last_round_cooperators > self.n_players / 2

    def _calculate_recent_defection_rate(self, history: PlayerHistory, lookback_rounds: int) -> float:
        """Calculate the defection rate over the last lookback_rounds."""
        if len(history.opponent_actions) == 0:
            return 0.0
        start_idx = max(0, len(history.opponent_actions) - lookback_rounds)
        total_actions = 0
        total_defections = 0
        for round_idx in range(start_idx, len(history.opponent_actions)):
            round_defections = np.sum(~history.opponent_actions[round_idx, :])
            if not history.my_actions[round_idx]:
                round_defections += 1
            total_defections += round_defections
            total_actions += self.n_players
        if total_actions == 0:
            return 0.0
        return total_defections / total_actions

    def _should_attempt_forgiveness(self, round_number: int, history: PlayerHistory) -> bool:
        """Check if should attempt forgiveness protocol (every 3-4 rounds)."""
        if round_number >= 5 and (round_number - 1) % 4 == 0:
            recent_defection_rate = self._calculate_recent_defection_rate(history, 3)
            return recent_defection_rate > 0.5
        return False

    def _stock_recovery_detected(self, history: PlayerHistory) -> bool:
        """Check if stock has increased significantly, indicating widespread cooperation."""
        if len(history.my_payoffs) < 2:
            return False
        last_round_stock = 0
        second_last_stock = 0
        if history.my_actions[-1]:
            last_round_stock = history.my_payoffs[-1] * 2 * self.n_players
        else:
            last_round_stock = history.my_payoffs[-1] * self.n_players
        if history.my_actions[-2]:
            second_last_stock = history.my_payoffs[-2] * 2 * self.n_players
        else:
            second_last_stock = history.my_payoffs[-2] * self.n_players
        if second_last_stock > 0:
            return (last_round_stock - second_last_stock) / second_last_stock > 0.15
        return False

class Strategy_COOPERATIVE_107(BaseStrategy):
    """
    Adaptive Sustainability Strategy (ASS) - prioritizes long-term resource sustainability
    while maintaining fairness and adaptability. Uses weighted scoring system to balance
    recent behavior, stock health, and reciprocity.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number
        current_stock = state.current_stock
        if current_round < 3:
            return Action.C
        if current_stock < self.capacity * 0.3:
            return Action.C
        cooperation_score = 0.0
        recent_rounds = min(3, current_round)
        recent_defections = 0
        for i in range(recent_rounds):
            round_idx = current_round - 1 - i
            recent_defections += np.sum(history.opponent_actions[round_idx, :] == False)
        recent_defection_rate = recent_defections / (recent_rounds * self.n_players)
        cooperation_score += (1 - recent_defection_rate) * 0.4
        total_cooperations = np.sum(history.opponent_actions == True)
        total_decisions = current_round * self.n_players
        historical_cooperation_rate = total_cooperations / total_decisions if total_decisions > 0 else 0
        cooperation_score += historical_cooperation_rate * 0.2
        stock_health = current_stock / self.capacity
        cooperation_score += stock_health * 0.3
        if current_round > 0:
            last_round_cooperators = np.sum(history.opponent_actions[-1, :] == True)
            if last_round_cooperators > self.n_players / 2:
                cooperation_score += 0.1
        if current_round >= self.n_rounds - 2:
            if current_stock < self.capacity * 0.3:
                return Action.C
            elif current_stock > self.capacity * 0.6:
                pass
            else:
                cooperation_score -= (1 - recent_defection_rate) * 0.4
                cooperation_score += (1 - recent_defection_rate) * 0.6
        if current_round >= 2:
            last_two_rounds_defection = True
            for i in range(2):
                round_idx = current_round - 1 - i
                cooperators = np.sum(history.opponent_actions[round_idx, :] == True)
                if cooperators >= self.n_players / 2:
                    last_two_rounds_defection = False
                    break
            if last_two_rounds_defection and cooperation_score <= 0.5:
                return Action.D
        if current_stock < self.capacity * 0.05:
            return Action.C
        return Action.C if cooperation_score > 0.5 else Action.D

class Strategy_COOPERATIVE_108(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Guardian"
    
    Prioritizes long-term sustainability while being cooperative by default,
    but adapts to protect the common resource from exploitation through
    dynamic thresholds and strategic defection triggers.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        cooperation_rate = self._calculate_cooperation_rate(history)
        sustainability_threshold = self.game_description.capacity * (0.4 + 0.3 * cooperation_rate)
        if state.round_number > self.game_description.n_rounds - 2:
            return Action.D
        if state.current_stock < self.game_description.capacity * 0.3:
            return Action.D
        if cooperation_rate < 0.5 and state.current_stock > self.game_description.capacity * 0.15:
            return Action.D
        if state.current_stock >= sustainability_threshold:
            return Action.C
        else:
            return Action.D

    def _calculate_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate the fraction of players who cooperated in the last round."""
        if history.round_number < 1:
            return 1.0
        last_round_idx = history.round_number - 1
        opponent_cooperators = sum(history.opponent_actions[last_round_idx, :])
        my_cooperation = 1 if history.my_actions[last_round_idx] else 0
        total_cooperators = opponent_cooperators + my_cooperation
        total_players = self.game_description.n_players
        return total_cooperators / total_players

class Strategy_COOPERATIVE_109(BaseStrategy):
    """
    Adaptive Cooperative Strategy: 'Sustainable Guardian'
    
    Prioritizes long-term resource sustainability while maintaining cooperative behavior,
    using adaptive thresholds based on observed opponent behavior and resource depletion patterns.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.sustainability_threshold = self.capacity * 0.4
        self.critical_threshold = self.capacity * 0.15
        self.current_trust = 1.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = state.round_number
        stock = state.current_stock
        if stock < self.critical_threshold:
            resource_status = 'CRITICAL'
        elif stock < self.sustainability_threshold:
            resource_status = 'THREATENED'
        else:
            resource_status = 'HEALTHY'
        total_rounds = len(history.my_actions)
        recent_rounds = min(3, total_rounds)
        recent_actions = history.opponent_actions[-recent_rounds:, :]
        recent_defections = np.sum(recent_actions == False)
        recent_total_actions = recent_rounds * self.n
        recent_defection_rate = recent_defections / recent_total_actions if recent_total_actions > 0 else 0
        total_opponent_actions = np.sum(history.opponent_actions)
        total_actions_count = total_rounds * self.n
        overall_cooperation_level = total_opponent_actions / total_actions_count if total_actions_count > 0 else 0
        trust_adjustment = -0.2 * recent_defection_rate
        self.current_trust = max(0.1, self.current_trust + trust_adjustment)
        if total_rounds % 5 == 0 and stock > self.sustainability_threshold:
            self.current_trust = max(self.current_trust, 0.5)
        stock_increasing = False
        if total_rounds >= 2:
            if recent_defection_rate < 0.3:
                stock_increasing = True
        cooperation_bonus = 0.0
        if stock_increasing and self.current_trust > 0.3:
            cooperation_bonus = 0.2
        majority_defected_last_round = False
        if total_rounds > 0:
            last_round_defectors = np.sum(history.opponent_actions[-1, :] == False)
            majority_defected_last_round = last_round_defectors > self.n / 2
        if resource_status == 'CRITICAL':
            if self.current_trust > 0.6 and recent_defection_rate < 0.3:
                return Action.C
            else:
                return Action.D
        elif resource_status == 'THREATENED':
            if overall_cooperation_level > 0.5 and recent_defection_rate < 0.4:
                return Action.C
            else:
                return Action.D
        else:
            effective_cooperation_threshold = 0.25 - cooperation_bonus
            if recent_defection_rate < effective_cooperation_threshold:
                return Action.C
            elif recent_defection_rate < 0.6:
                if majority_defected_last_round:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.D
        if current_round == self.r - 1 and resource_status != 'CRITICAL':
            if overall_cooperation_level > 0.4:
                return Action.C
            else:
                return Action.D
        return Action.C

class Strategy_COOPERATIVE_110(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Steward"
    
    Prioritizes long-term sustainability while being forgiving to encourage cooperation.
    Balances trust-building with self-protection against exploitation through dynamic
    cooperation thresholds based on stock health and opponent behavior patterns.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.initial_coop_rounds = max(1, int(0.2 * self.n_rounds))
        self.consecutive_below_threshold = 0
        self.last_forgiveness_round = -1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number
        current_stock = state.current_stock
        if current_round < self.initial_coop_rounds:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        min_stock_needed = self.n_players * 2
        if current_stock < min_stock_needed:
            if current_round > 0:
                last_round_cooperators = sum(history.opponent_actions[-1, :])
                last_round_coop_rate = last_round_cooperators / (self.n_players - 1)
                if last_round_coop_rate > 0.5:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.C
        lookback_rounds = min(3, current_round)
        if lookback_rounds == 0:
            return Action.C
        recent_opponent_actions = history.opponent_actions[-lookback_rounds:, :]
        total_recent_actions = recent_opponent_actions.size
        total_cooperations = np.sum(recent_opponent_actions)
        cooperation_rate = total_cooperations / total_recent_actions if total_recent_actions > 0 else 0
        stock_ratio = current_stock / self.capacity
        if stock_ratio < 0.3:
            return Action.C
        elif stock_ratio < 0.6:
            threshold = 0.6
        else:
            threshold = 0.4
        if cooperation_rate >= threshold:
            self.consecutive_below_threshold = 0
            return Action.C
        else:
            self.consecutive_below_threshold += 1
            if self.consecutive_below_threshold >= 2:
                rounds_since_forgiveness = current_round - self.last_forgiveness_round
                if rounds_since_forgiveness >= 3:
                    self.last_forgiveness_round = current_round
                    return Action.C
            if cooperation_rate < 0.2 and self.consecutive_below_threshold >= 3:
                if current_round % 4 == 0:
                    return Action.C
                if current_round > 0:
                    last_round_cooperators = sum(history.opponent_actions[-1, :])
                    if last_round_cooperators > (self.n_players - 1) / 2:
                        return Action.C
                    else:
                        return Action.D
            if lookback_rounds >= 2:
                prev_lookback = min(3, current_round - 1)
                if prev_lookback > 0:
                    prev_actions = history.opponent_actions[-(prev_lookback + 1):-1, :]
                    prev_total = prev_actions.size
                    prev_cooperations = np.sum(prev_actions)
                    prev_rate = prev_cooperations / prev_total if prev_total > 0 else 0
                    if cooperation_rate - prev_rate > 0.3:
                        self.consecutive_below_threshold = 0
                        return Action.C
            return Action.D

class Strategy_COOPERATIVE_111(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Guardian of the Commons"
    
    Prioritizes long-term sustainability while being adaptive to opponent behaviors.
    Uses cooperation rate thresholds and stock health monitoring to make decisions.
    Starts cooperative, switches to protection when cooperation drops below 70%,
    returns to cooperation when it rises above 80%, and enters crisis mode
    when stock falls below 30% of capacity.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        last_round_cooperators = sum(history.opponent_actions[-1, :])
        cooperation_rate = last_round_cooperators / (self.n_players - 1)
        stock_health = state.current_stock / self.capacity
        was_cooperating_last_round = history.my_actions[-1]
        if stock_health < 0.3:
            return Action.D
        elif cooperation_rate >= 0.8:
            return Action.C
        elif cooperation_rate <= 0.7:
            return Action.D
        elif was_cooperating_last_round:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_112(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Steward"
    
    This strategy aims to maximize long-term collective welfare while protecting against 
    exploitation through adaptive cooperation with built-in safeguards. It uses stock 
    health and recent opponent behavior to make cooperative decisions that balance 
    sustainability with protection against defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        stock_health = state.current_stock / self.game_description.capacity
        recent_rounds = min(3, history.round_number)
        if recent_rounds > 0:
            recent_actions = history.opponent_actions[-recent_rounds:, :]
            total_recent_actions = recent_actions.size
            defections = np.sum(recent_actions == False)
            defection_rate = defections / total_recent_actions if total_recent_actions > 0 else 0
        else:
            defection_rate = 0
        rounds_remaining = self.game_description.n_rounds - state.round_number - 1
        if rounds_remaining == 0:
            if stock_health > 0.5:
                return Action.C
            else:
                return Action.D
        elif rounds_remaining <= 2:
            if stock_health > 0.3 and defection_rate < 0.5:
                return Action.C
            else:
                return Action.D
        if stock_health < 0.15:
            if defection_rate < 0.7:
                return Action.C
            else:
                return Action.D
        elif stock_health < 0.4:
            if defection_rate < 0.5:
                return Action.C
            elif random.random() < defection_rate:
                return Action.D
            else:
                return Action.C
        elif defection_rate < 0.3:
            return Action.C
        elif defection_rate < 0.6:
            coop_probability = 1 - defection_rate + 0.2
            coop_probability = min(1.0, max(0.0, coop_probability))
            if random.random() < coop_probability:
                return Action.C
            else:
                return Action.D
        elif random.random() < 0.6:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_113(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Steward"
    
    Prioritizes long-term sustainability while maintaining cooperative intent.
    Adapts to opponent behavior patterns and resource conditions, seeking to
    preserve the common pool for collective benefit while protecting against exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.n_rounds - 1:
            critical_threshold = self.capacity * 0.3
            if current_stock > critical_threshold:
                recent_rounds = min(3, len(history.my_actions))
                recent_coop_rate = np.mean(history.opponent_actions[-recent_rounds:, :])
                if recent_coop_rate > 0.6:
                    return Action.C
            return Action.D
        critical_threshold = self.capacity * 0.3
        danger_threshold = self.capacity * 0.15
        if current_stock < danger_threshold:
            stock_signal = Action.D
        elif current_stock < critical_threshold:
            stock_signal = Action.D if random.random() < 0.7 else Action.C
        else:
            stock_signal = Action.C
        recent_rounds = min(3, len(history.my_actions))
        total_opponent_actions = self.n_players * recent_rounds
        recent_cooperators = np.sum(history.opponent_actions[-recent_rounds:, :])
        cooperation_rate = recent_cooperators / total_opponent_actions if total_opponent_actions > 0 else 0
        if cooperation_rate >= 0.7:
            social_signal = Action.C
        elif cooperation_rate >= 0.4:
            social_signal = Action.C if random.random() < 0.6 else Action.D
        else:
            social_signal = Action.D
        if len(history.my_actions) >= 2:
            last_round_coop_rate = np.mean(history.opponent_actions[-1, :])
            prev_round_coop_rate = np.mean(history.opponent_actions[-2, :])
            if last_round_coop_rate > prev_round_coop_rate:
                trend_signal = Action.C
            elif abs(last_round_coop_rate - prev_round_coop_rate) < 0.1:
                trend_signal = Action.C
            else:
                trend_signal = Action.C if random.random() < 0.4 else Action.D
        else:
            trend_signal = Action.C
        signals = [stock_signal, social_signal, trend_signal]
        weights = [0.4, 0.35, 0.25]
        cooperate_score = sum((weight for signal, weight in zip(signals, weights) if signal == Action.C))
        if cooperate_score >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_114(BaseStrategy):
    """
    Sustainable Steward: An adaptive cooperative strategy that prioritizes long-term 
    sustainability while adapting to opponent behavior. Starts cooperative and adjusts 
    based on collective behavior with mechanisms to promote cooperation and punish 
    excessive defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.6
        self.sustainability_threshold = 0.4 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_num = history.round_number
        current_stock = state.current_stock
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if round_num == 1:
            if current_stock >= 0.5 * capacity:
                return Action.C
            else:
                return Action.D
        window_size = min(2, round_num)
        recent_actions = history.opponent_actions[-window_size:, :]
        my_recent_actions = history.my_actions[-window_size:]
        total_coop_actions = np.sum(recent_actions) + np.sum(my_recent_actions)
        total_actions = window_size * n_players
        recent_cooperation_rate = total_coop_actions / total_actions if total_actions > 0 else 0
        if round_num >= n_rounds - 2:
            if round_num == n_rounds - 2:
                if current_stock > 0.7 * capacity:
                    return Action.C
                elif current_stock > 0.3 * capacity:
                    return Action.C if recent_cooperation_rate > 0.4 else Action.D
                else:
                    return Action.D
            else:
                return Action.C if current_stock > 0.5 * capacity else Action.D
        if round_num >= 4:
            prev_window_size = min(2, round_num - 2)
            prev_window_actions = history.opponent_actions[-window_size - prev_window_size:-window_size, :]
            prev_my_actions = history.my_actions[-window_size - prev_window_size:-window_size]
            prev_total_coop = np.sum(prev_window_actions) + np.sum(prev_my_actions)
            prev_total_actions = prev_window_size * n_players
            prev_cooperation_rate = prev_total_coop / prev_total_actions if prev_total_actions > 0 else 0
            if recent_cooperation_rate - prev_cooperation_rate > 0.3:
                return Action.C
        if round_num >= 3:
            last_3_rounds = min(3, round_num)
            last_3_actions = history.opponent_actions[-last_3_rounds:, :]
            my_last_3_actions = history.my_actions[-last_3_rounds:]
            total_coop_3 = np.sum(last_3_actions) + np.sum(my_last_3_actions)
            total_actions_3 = last_3_rounds * n_players
            coop_rate_3 = total_coop_3 / total_actions_3 if total_actions_3 > 0 else 0
            if coop_rate_3 < 0.1:
                return Action.D
        if current_stock >= 0.95 * capacity:
            return Action.C
        if current_stock <= 0:
            return Action.C
        if current_stock < self.sustainability_threshold:
            if recent_cooperation_rate >= 0.5:
                return Action.C
            else:
                return Action.D
        else:
            adjusted_threshold = self.cooperation_threshold
            if current_stock > 0.8 * capacity:
                adjusted_threshold = 0.5
            elif current_stock < 0.4 * capacity:
                adjusted_threshold = 0.7
            if recent_cooperation_rate >= adjusted_threshold:
                return Action.C
            elif recent_cooperation_rate >= 0.3:
                return Action.C if random.random() < 0.7 else Action.D
            else:
                return Action.D

class Strategy_COOPERATIVE_115(BaseStrategy):
    """
    Adaptive Stewardship Strategy: Balances immediate cooperation with long-term resource 
    sustainability, adapting to opponent behavior while maintaining a fundamentally 
    cooperative stance that protects the common pool for all players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.defection_streak = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.defection_streak = 0
            return Action.C
        round_number = history.round_number
        current_stock = state.current_stock
        critical_threshold = self.capacity * 0.3
        stress_threshold = self.capacity * 0.6
        depletion_threshold = self.capacity * 0.15
        if round_number == self.n_rounds - 1:
            if current_stock > self.capacity * 0.5:
                return Action.C
            my_cooperation_rate = np.mean(history.my_actions)
            if my_cooperation_rate > 0.7:
                return Action.C
            else:
                return Action.D
        last_round_actions = history.opponent_actions[-1, :]
        cooperators_last_round = np.sum(last_round_actions)
        majority_defected = cooperators_last_round < (self.n_players - 1) / 2
        if current_stock < depletion_threshold:
            if cooperators_last_round == 0:
                self.defection_streak += 1
                return Action.D
            else:
                self.defection_streak = 0
                return Action.C
        if current_stock < critical_threshold:
            if majority_defected:
                self.defection_streak += 1
                return Action.D
            else:
                self.defection_streak = 0
                return Action.C
        if round_number <= 4:
            recent_cooperation_rate = cooperators_last_round / (self.n_players - 1)
            if recent_cooperation_rate < 0.4:
                if self.defection_streak < 2:
                    self.defection_streak += 1
                    return Action.D
                else:
                    self.defection_streak = 0
                    return Action.C
        if round_number >= 3:
            recent_rounds = min(3, round_number)
            recent_cooperation_rates = []
            for i in range(recent_rounds):
                round_idx = round_number - 1 - i
                round_cooperators = np.sum(history.opponent_actions[round_idx, :])
                cooperation_rate = round_cooperators / (self.n_players - 1)
                recent_cooperation_rates.append(cooperation_rate)
            if all((rate > 0.8 for rate in recent_cooperation_rates)):
                self.defection_streak = 0
                return Action.C
        if current_stock < stress_threshold:
            cooperation_rate = cooperators_last_round / (self.n_players - 1)
            if cooperation_rate < 0.4:
                recent_rounds = min(3, round_number)
                my_recent_cooperation = np.mean(history.my_actions[-recent_rounds:])
                if my_recent_cooperation > 0.7:
                    self.defection_streak += 1
                    return Action.D
                else:
                    self.defection_streak = 0
                    return Action.C
            else:
                self.defection_streak = 0
                return Action.C
        if self.defection_streak >= 2:
            self.defection_streak = 0
            return Action.C
        if round_number >= 2:
            prev_cooperation_rate = np.sum(history.opponent_actions[-2, :]) / (self.n_players - 1) if round_number >= 2 else 0
            current_cooperation_rate = cooperators_last_round / (self.n_players - 1)
            if current_cooperation_rate > prev_cooperation_rate + 0.3:
                self.defection_streak = 0
                return Action.C
        self.defection_streak = 0
        return Action.C

class Strategy_COOPERATIVE_116(BaseStrategy):
    """
    Adaptive Threshold Cooperation Strategy (ATCS)
    
    Balances cooperative intent with adaptive self-preservation, maintaining cooperation
    as long as the resource remains viable while protecting against exploitation and
    resource collapse through dynamic thresholds based on resource health and opponent
    behavior patterns.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_confidence = 0.0
        self.exploitation_count = 0
        self.punishment_rounds_left = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        resource_health = state.current_stock / self.game_description.capacity
        critical_threshold = 0.3
        sustainable_threshold = 0.6
        rounds_remaining = self.game_description.n_rounds - state.round_number
        if rounds_remaining == 1:
            if resource_health > 0.4:
                return Action.D
            else:
                return Action.C
        recent_rounds = min(3, len(history.my_actions))
        if recent_rounds > 0:
            recent_opponent_actions = history.opponent_actions[-recent_rounds:, :]
            total_recent_decisions = recent_rounds * self.game_description.n_players
            recent_cooperations = np.sum(recent_opponent_actions)
            cooperation_rate = recent_cooperations / total_recent_decisions if total_recent_decisions > 0 else 0.0
        else:
            cooperation_rate = 0.5
        high_cooperation = cooperation_rate >= 0.7
        medium_cooperation = 0.4 <= cooperation_rate < 0.7
        low_cooperation = cooperation_rate < 0.4
        if self.punishment_rounds_left > 0:
            self.punishment_rounds_left -= 1
            return Action.D
        self._update_exploitation_tracking(history, cooperation_rate)
        self._update_cooperation_confidence(history, state)
        if resource_health < critical_threshold:
            if cooperation_rate > 0.5:
                return Action.C
            else:
                return Action.D
        elif resource_health < sustainable_threshold:
            if high_cooperation:
                return Action.C
            elif medium_cooperation and rounds_remaining > 3:
                return Action.C
            else:
                return Action.D
        else:
            end_game_threshold = max(2, self.game_description.n_rounds // 5)
            if rounds_remaining <= end_game_threshold:
                if resource_health > sustainable_threshold:
                    if low_cooperation or not high_cooperation:
                        return Action.D
                    else:
                        return Action.C
                else:
                    return Action.C
            if low_cooperation:
                return Action.D
            else:
                if self._has_positive_momentum(history, cooperation_rate):
                    return Action.C
                if self.cooperation_confidence > 0.2:
                    return Action.C
                elif medium_cooperation:
                    return Action.C
                else:
                    return Action.D

    def _update_exploitation_tracking(self, history: PlayerHistory, cooperation_rate: float):
        """Track if being systematically exploited"""
        recent_rounds = min(4, len(history.my_actions))
        if recent_rounds < 2:
            return
        exploitation_instances = 0
        for i in range(max(0, len(history.my_actions) - recent_rounds), len(history.my_actions)):
            if history.my_actions[i]:
                opponent_cooperations = np.sum(history.opponent_actions[i, :])
                if opponent_cooperations < self.game_description.n_players * 0.5:
                    exploitation_instances += 1
        if exploitation_instances >= 3:
            self.punishment_rounds_left = 2

    def _update_cooperation_confidence(self, history: PlayerHistory, state: CommonPoolState):
        """Update confidence in cooperation based on recent outcomes"""
        if len(history.my_actions) < 2:
            return
        if len(history.my_actions) >= 2:
            recent_cooperations = np.sum(history.opponent_actions[-2:, :]) / (2 * self.game_description.n_players)
            if recent_cooperations > 0.5:
                self.cooperation_confidence = min(1.0, self.cooperation_confidence + 0.1)
            else:
                self.cooperation_confidence = max(-1.0, self.cooperation_confidence - 0.1)

    def _has_positive_momentum(self, history: PlayerHistory, cooperation_rate: float) -> bool:
        """Check if there's positive cooperation momentum to reward"""
        if len(history.my_actions) < 2:
            return False
        recent_rounds = min(2, len(history.my_actions))
        if recent_rounds < 2:
            return False
        return cooperation_rate >= 0.5 and self.cooperation_confidence > 0

class Strategy_COOPERATIVE_117(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Guardian"
    
    This strategy prioritizes long-term sustainability while being cooperative by default,
    but includes protective mechanisms against exploitation. It adapts its cooperation
    threshold based on stock levels, remaining rounds, and recent opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        current_round = state.round_number
        rounds_remaining = n_rounds - current_round
        if rounds_remaining == 1:
            if current_stock >= capacity * 0.3:
                return Action.C
            else:
                return Action.D
        stock_ratio = current_stock / capacity
        if stock_ratio < 0.25:
            stock_zone = 'critical'
        elif stock_ratio < 0.5:
            stock_zone = 'danger'
        else:
            stock_zone = 'safe'
        cooperation_threshold = max(0.2, min(0.8, 0.3 + 0.4 * stock_ratio + 0.1 * (rounds_remaining / n_rounds)))
        rounds_to_check = min(3, len(history.my_actions))
        if rounds_to_check == 0:
            recent_defection_rate = 0.5
        else:
            recent_actions = history.opponent_actions[-rounds_to_check:, :]
            weights = np.array([0.2, 0.3, 0.5][-rounds_to_check:])
            weights = weights / np.sum(weights)
            total_weighted_actions = 0
            total_weighted_defections = 0
            for i, weight in enumerate(weights):
                round_actions = recent_actions[i, :]
                cooperations = np.sum(round_actions)
                defections = len(round_actions) - cooperations
                total_weighted_actions += weight * len(round_actions)
                total_weighted_defections += weight * defections
            recent_defection_rate = total_weighted_defections / total_weighted_actions if total_weighted_actions > 0 else 0.5
        if len(history.my_actions) >= 2:
            last_two_rounds = history.opponent_actions[-2:, :]
            cooperation_rates = []
            for round_actions in last_two_rounds:
                cooperations = np.sum(round_actions)
                cooperation_rate = cooperations / len(round_actions)
                cooperation_rates.append(cooperation_rate)
            if all((rate > 0.6 for rate in cooperation_rates)):
                recent_defection_rate = min(recent_defection_rate, 0.4)
        if stock_zone == 'critical':
            if recent_defection_rate > 0.7:
                return Action.D
            else:
                return Action.C
        elif stock_zone == 'danger':
            if recent_defection_rate > cooperation_threshold:
                return Action.D
            else:
                return Action.C
        elif recent_defection_rate > 0.8:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_118(BaseStrategy):
    """
    Adaptive Stewardship: A cooperative strategy that balances sustainability, 
    reciprocity, and protection against exploitation in common pool resource games.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.capacity = game_description.capacity
        self.r = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if history is None:
            return Action.C
        if current_stock < self.capacity / 4:
            return Action.C
        lookback = min(3, history.round_number)
        if lookback > 0:
            recent_opponent_actions = history.opponent_actions[-lookback:, :]
            total_actions = recent_opponent_actions.size
            total_cooperations = np.sum(recent_opponent_actions)
            coop_ratio = total_cooperations / total_actions if total_actions > 0 else 1.0
        else:
            coop_ratio = 1.0
        if current_stock < self.capacity / 2:
            return Action.C
        if self._is_future_stock_critical(history, current_stock):
            if current_stock > self.capacity / 2:
                return Action.D
        if round_number == self.r - 1:
            if current_stock > self.capacity / 3:
                return Action.C
            else:
                return Action.D
        if coop_ratio >= 0.6:
            return Action.C
        elif coop_ratio >= 0.3:
            return Action.C if random.random() < 0.7 else Action.D
        else:
            return Action.C if random.random() < 0.4 else Action.D

    def _is_future_stock_critical(self, history: PlayerHistory, current_stock: float) -> bool:
        """Check if continuing current behavior patterns will deplete stock critically within 2 rounds."""
        if history.round_number < 2:
            return False
        recent_rounds = min(2, history.round_number)
        total_recent_consumption = 0
        for i in range(recent_rounds):
            round_idx = -(i + 1)
            opponent_cooperators = np.sum(history.opponent_actions[round_idx, :])
            opponent_defectors = self.n - 1 - opponent_cooperators
            my_cooperated = history.my_actions[round_idx]
            if my_cooperated:
                my_consumption = current_stock / (2 * self.n)
                cooperators = opponent_cooperators + 1
                defectors = opponent_defectors
            else:
                my_consumption = current_stock / self.n
                cooperators = opponent_cooperators
                defectors = opponent_defectors + 1
            round_consumption = cooperators * current_stock / (2 * self.n) + defectors * current_stock / self.n
            total_recent_consumption += round_consumption
        avg_consumption_rate = total_recent_consumption / recent_rounds
        projected_stock = current_stock
        for _ in range(2):
            stock_after_consumption = max(0, projected_stock - avg_consumption_rate)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            projected_stock = min(stock_after_consumption + growth, self.capacity)
        return projected_stock < self.capacity / 4

class Strategy_COOPERATIVE_119(BaseStrategy):
    """
    Guardian of the Commons: Adaptive cooperative strategy that prioritizes long-term 
    resource sustainability while being adaptive to opponent behavior. Uses graduated 
    responses and forgiveness mechanisms to maintain cooperation when possible.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        current_round = history.round_number
        total_rounds = self.game_description.n_rounds
        stock = state.current_stock
        healthy_threshold = 0.7 * capacity
        critical_threshold = 0.4 * capacity
        if stock < critical_threshold:
            return Action.C
        lookback_rounds = min(2, current_round)
        total_opponent_actions = 0
        total_defections = 0
        for i in range(lookback_rounds):
            round_idx = current_round - 1 - i
            opponent_actions_in_round = history.opponent_actions[round_idx, :]
            defections_in_round = sum((1 for action in opponent_actions_in_round if not action))
            total_defections += defections_in_round
            total_opponent_actions += len(opponent_actions_in_round)
        defection_rate = total_defections / total_opponent_actions if total_opponent_actions > 0 else 0
        if current_round >= 2:
            recent_defections = 0
            recent_total = 0
            for i in range(2):
                round_idx = current_round - 1 - i
                opponent_actions_in_round = history.opponent_actions[round_idx, :]
                recent_defections += sum((1 for action in opponent_actions_in_round if not action))
                recent_total += len(opponent_actions_in_round)
            recent_defection_rate = recent_defections / recent_total if recent_total > 0 else 0
            stock_recovering = True
            if current_round >= 3:
                stock_recovering = recent_defection_rate < 0.5
            if recent_defection_rate <= 0.2 and stock_recovering:
                return Action.C
        rounds_remaining = total_rounds - current_round
        endgame_threshold = int(0.2 * total_rounds)
        if rounds_remaining <= endgame_threshold:
            if stock < critical_threshold:
                return Action.C
            elif defection_rate > 0.4:
                return Action.D
            else:
                return Action.C
        if defection_rate > 0.6 and stock > critical_threshold:
            return Action.D
        elif defection_rate <= 0.3:
            return Action.C
        if stock >= healthy_threshold:
            cooperation_probability = 1 - defection_rate
        else:
            cooperation_probability = 0.8 - defection_rate
        if random.random() < cooperation_probability:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_120(BaseStrategy):
    """
    Adaptive Stewardship Strategy: Balances cooperative stewardship with adaptive responses
    to others' behavior using a "trust but verify" approach with graduated responses.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.survival_mode_counter = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = state.round_number
        stock = state.current_stock
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        shr = stock / capacity
        recent_rounds = min(3, current_round)
        if recent_rounds > 0:
            recent_opponent_actions = history.opponent_actions[-recent_rounds:, :]
            total_recent_actions = recent_opponent_actions.size
            cooperation_count = np.sum(recent_opponent_actions)
            cooperation_rate = cooperation_count / total_recent_actions if total_recent_actions > 0 else 0
        else:
            cooperation_rate = 0
        if current_round % 4 == 0 and current_round > 3:
            all_opponent_actions = history.opponent_actions
            if all_opponent_actions.size > 0:
                cooperation_rate = np.sum(all_opponent_actions) / all_opponent_actions.size
            else:
                cooperation_rate = 0
        in_survival_mode = False
        if cooperation_rate < 0.2:
            self.survival_mode_counter += 1
            if self.survival_mode_counter >= 3:
                in_survival_mode = True
        else:
            self.survival_mode_counter = 0
        if current_round == total_rounds - 1 and stock > 0:
            return Action.C
        if stock <= 0:
            return Action.C
        if in_survival_mode:
            return Action.C if shr >= 0.8 else Action.D
        if current_round <= 2:
            if cooperation_rate >= 0.3 and shr >= 0.5:
                return Action.C
            else:
                return Action.D
        if shr >= 0.7 and cooperation_rate >= 0.5 or (shr >= 0.4 and cooperation_rate >= 0.7):
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_121(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Guardian"
    
    This strategy prioritizes long-term sustainability while being cooperative by default,
    but adapts based on collective behavior. It maintains the resource pool while 
    encouraging cooperation through conditional reciprocation and stock-aware decisions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.trust_score = 1.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        recent_rounds = min(3, current_round)
        if recent_rounds > 0:
            recent_opponent_actions = history.opponent_actions[-recent_rounds:, :]
            total_recent_actions = recent_opponent_actions.size
            cooperation_count = np.sum(recent_opponent_actions)
            cooperation_rate = cooperation_count / total_recent_actions if total_recent_actions > 0 else 0.5
        else:
            cooperation_rate = 0.5
        self.trust_score = 0.8 * self.trust_score + 0.2 * cooperation_rate
        trust_adjustment = 0
        if self.trust_score > 0.8:
            trust_adjustment = 0.1
        elif self.trust_score < 0.4:
            trust_adjustment = -0.1
        high_threshold = 0.6 + trust_adjustment
        medium_threshold = 0.4
        emergency_threshold = 0.2
        stock_ratio = current_stock / capacity
        if stock_ratio < emergency_threshold:
            return Action.C
        if current_round == total_rounds - 1:
            if stock_ratio >= 0.5:
                return Action.C
        if stock_ratio >= high_threshold:
            return Action.C
        elif stock_ratio >= medium_threshold and cooperation_rate >= 0.7:
            return Action.C
        elif stock_ratio < medium_threshold and cooperation_rate < 0.3:
            return Action.D
        else:
            return Action.C if stock_ratio >= medium_threshold else Action.D

class Strategy_COOPERATIVE_122(BaseStrategy):
    """
    Adaptive Stewardship Strategy: Balances cooperative resource stewardship with adaptive 
    responses to exploitation through graduated reciprocation and stock-sensitive decision making.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.initial_trust = 0.5
        self.cooperation_bonus = 0.1
        self.defection_penalty = 0.2
        self.base_threshold = 0.3
        self.trust_scores = {}

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round = state.round_number
        if current_round == n_rounds - 1:
            return self._endgame_strategy(state, history)
        return self._adaptive_response(state, history)

    def _adaptive_response(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        stock_health = current_stock / capacity
        self._update_trust_scores(history)
        avg_trust = np.mean(list(self.trust_scores.values())) if self.trust_scores else self.initial_trust
        cooperation_threshold = self.base_threshold * stock_health
        if stock_health < 0.3:
            cooperation_threshold *= 0.5
        if stock_health < 0.1:
            recent_coop_rate = np.mean(history.opponent_actions[-1, :])
            return Action.C if recent_coop_rate > 0.8 else Action.D
        if current_stock < n_players:
            return self._crisis_cooperation_mode(history)
        if avg_trust >= cooperation_threshold:
            return Action.C
        else:
            if abs(avg_trust - cooperation_threshold) < 0.1:
                recent_coop_rate = np.mean(history.opponent_actions[-1, :])
                return Action.C if recent_coop_rate > 0.5 else Action.D
            return Action.D

    def _update_trust_scores(self, history: PlayerHistory):
        n_opponents = self.game_description.n_players - 1
        most_recent_actions = history.opponent_actions[-1, :]
        if not self.trust_scores:
            for i in range(n_opponents):
                self.trust_scores[i] = self.initial_trust
        for i in range(n_opponents):
            if most_recent_actions[i]:
                self.trust_scores[i] += self.cooperation_bonus
            else:
                self.trust_scores[i] -= self.defection_penalty
            self.trust_scores[i] += 0.02
            self.trust_scores[i] = max(0.0, min(1.0, self.trust_scores[i]))

    def _crisis_cooperation_mode(self, history: PlayerHistory) -> Action:
        if len(history.opponent_actions) >= 2:
            recent_defection_rate = 1.0 - np.mean(history.opponent_actions[-2:, :])
            if recent_defection_rate > 0.75:
                return Action.D
        return Action.C

    def _endgame_strategy(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        if current_stock <= n_players:
            return Action.C
        opponent_cooperation_rate = np.mean(history.opponent_actions)
        if opponent_cooperation_rate > 0.6:
            return Action.C
        if current_stock > 1.5 * capacity:
            return Action.C
        if len(history.opponent_actions) > 0:
            recent_coop_rate = np.mean(history.opponent_actions[-1, :])
            predicted_cooperators = recent_coop_rate * (n_players - 1)
            predicted_defectors = n_players - 1 - predicted_cooperators
            if predicted_defectors < n_players / 2:
                return Action.C
            else:
                return Action.D
        return Action.C

class Strategy_COOPERATIVE_123(BaseStrategy):
    """
    Adaptive Cooperative Resource Management Strategy.
    
    Prioritizes long-term sustainability while being adaptive to opponent behavior.
    Starts cooperative and adjusts based on observed patterns, always maintaining
    a bias toward cooperation when the resource can sustain it.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.capacity = game_description.capacity
        self.total_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = state.round_number
        stock = state.current_stock
        stock_health = self._assess_stock_health(stock)
        if current_round == self.total_rounds - 1:
            return self._final_round_decision(stock_health, history)
        if stock_health == 'Critical':
            return Action.C
        lookback_window = min(3, current_round)
        defection_rate = self._calculate_defection_rate(history, lookback_window)
        my_recent_cooperations = self._count_my_recent_cooperations(history, lookback_window)
        rounds_since_my_defection = self._rounds_since_my_defection(history)
        if stock_health == 'Healthy':
            if defection_rate > 0.7:
                if my_recent_cooperations > 2:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.C
        elif defection_rate > 0.5:
            if rounds_since_my_defection > 2:
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

    def _assess_stock_health(self, stock):
        """Assess current stock health level."""
        if stock >= 0.6 * self.capacity:
            return 'Healthy'
        elif stock >= 0.3 * self.capacity:
            return 'Stressed'
        else:
            return 'Critical'

    def _calculate_defection_rate(self, history, lookback_window):
        """Calculate defection rate over recent rounds."""
        if lookback_window == 0:
            return 0.0
        start_idx = max(0, history.round_number - lookback_window)
        recent_actions = history.opponent_actions[start_idx:, :]
        total_actions = recent_actions.size
        total_cooperations = np.sum(recent_actions)
        total_defections = total_actions - total_cooperations
        return total_defections / total_actions if total_actions > 0 else 0.0

    def _count_my_recent_cooperations(self, history, lookback_window):
        """Count my cooperations in recent rounds."""
        if lookback_window == 0:
            return 0
        start_idx = max(0, history.round_number - lookback_window)
        recent_my_actions = history.my_actions[start_idx:]
        return np.sum(recent_my_actions)

    def _rounds_since_my_defection(self, history):
        """Count rounds since my last defection."""
        if history.round_number == 0:
            return float('inf')
        my_actions = history.my_actions
        for i in range(len(my_actions) - 1, -1, -1):
            if not my_actions[i]:
                return len(my_actions) - 1 - i
        return float('inf')

    def _final_round_decision(self, stock_health, history):
        """Handle final round decision."""
        if stock_health == 'Critical':
            return Action.C
        lookback_window = min(3, history.round_number)
        defection_rate = self._calculate_defection_rate(history, lookback_window)
        if stock_health == 'Healthy' and defection_rate > 0.8:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_124(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Sustainable Guardian"
    
    This strategy prioritizes long-term sustainability while being responsive to opponent behavior.
    It starts cooperative but adapts based on observed patterns to maintain both the resource 
    and competitive viability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.initial_phase_length = max(3, math.ceil(game_description.n_rounds * 0.25))
        self.end_game_threshold = math.ceil(game_description.n_rounds * 0.8)
        self.cooperation_threshold = 0.4
        self.forgiveness_counter = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = state.round_number
        stock_ratio = state.current_stock / self.game_description.capacity
        if current_round < self.initial_phase_length:
            return Action.C
        if stock_ratio <= 0.1:
            return Action.C
        recent_window = min(5, current_round)
        recent_opponent_actions = history.opponent_actions[-recent_window:]
        total_recent_decisions = recent_opponent_actions.size
        recent_cooperations = np.sum(recent_opponent_actions)
        opponent_coop_rate = recent_cooperations / total_recent_decisions if total_recent_decisions > 0 else 0.5
        if current_round >= self.end_game_threshold:
            if current_round == self.game_description.n_rounds - 1:
                if stock_ratio > 0.7 and opponent_coop_rate < 0.3:
                    return Action.D
                else:
                    return Action.C
            if stock_ratio <= 0.5:
                return Action.C
        if stock_ratio <= 0.3:
            return Action.C
        self.forgiveness_counter += 1
        forgiveness_frequency = max(3, 5 - int(3 * (1 - stock_ratio)))
        if self.forgiveness_counter >= forgiveness_frequency:
            self.forgiveness_counter = 0
            if opponent_coop_rate < self.cooperation_threshold:
                return Action.C
        if stock_ratio >= 0.8:
            if opponent_coop_rate >= 0.6:
                return Action.C
            elif opponent_coop_rate < 0.4:
                if random.random() < 0.7:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.C
        cooperation_probability = 0.3 + 0.4 * opponent_coop_rate + 0.3 * stock_ratio
        cooperation_probability = min(1.0, max(0.0, cooperation_probability))
        if random.random() < cooperation_probability:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_125(BaseStrategy):
    """
    Guardian of the Commons: Adaptive Cooperative Strategy
    
    A conditional cooperation strategy that balances resource preservation with
    protection against exploitation. Uses adaptive thresholds based on stock
    health and cooperation rates, with emergency cooperation when stock is critical.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = state.round_number
        rounds_remaining = self.game_description.n_rounds - current_round
        stock_health = state.current_stock / self.game_description.capacity
        if current_round == 1:
            if stock_health >= 0.75:
                return Action.C
            else:
                return Action.D
        last_round_cooperators = sum(history.opponent_actions[-1, :])
        previous_cooperation_rate = last_round_cooperators / self.game_description.n_players
        if rounds_remaining <= 3:
            cooperation_threshold = 0.3
        elif stock_health < 0.4:
            cooperation_threshold = 0.6
        else:
            cooperation_threshold = 0.5
        if stock_health < 0.2:
            return Action.C
        if previous_cooperation_rate >= cooperation_threshold:
            return Action.C
        elif stock_health > 0.8 and previous_cooperation_rate >= 0.3:
            return Action.C
        else:
            if len(history.my_actions) >= 2:
                if previous_cooperation_rate == 0:
                    if len(history.my_actions) >= 2:
                        second_last_cooperators = sum(history.opponent_actions[-2, :])
                        second_last_cooperation_rate = second_last_cooperators / self.game_description.n_players
                        if second_last_cooperation_rate == 0 and stock_health <= 0.4:
                            return Action.D
                        elif stock_health > 0.4:
                            return Action.C
            if rounds_remaining == 1:
                if stock_health > 0.3:
                    return Action.C
                else:
                    return Action.D
            return Action.D

class Strategy_COOPERATIVE_126(BaseStrategy):
    """
    Guardian of the Commons: An adaptive cooperative strategy that prioritizes long-term 
    resource sustainability while defending against excessive exploitation. Starts cooperative 
    and adapts based on stock health and opponent behavior patterns.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = self.capacity / (4 * self.n_players)
        self.high_pressure_threshold = 0.6
        self.cooperation_threshold = 0.4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = state.round_number
        stock_level = state.current_stock
        if stock_level <= self.critical_threshold:
            return Action.C
        defection_pressure = self._calculate_defection_pressure(history)
        recent_cooperation_rate = self._calculate_recent_cooperation_rate(history)
        if current_round >= 0.8 * self.n_rounds:
            return self._endgame_strategy(stock_level, history)
        if current_round == self.n_rounds - 1:
            if stock_level > 0.3 * self.capacity:
                return Action.D
            else:
                return Action.C
        if defection_pressure >= self.high_pressure_threshold:
            return Action.D
        if recent_cooperation_rate >= self.cooperation_threshold:
            return Action.C
        return Action.C

    def _calculate_defection_pressure(self, history: PlayerHistory) -> float:
        """Calculate weighted average of defection rates over recent rounds."""
        if history.round_number == 0:
            return 0.0
        recent_rounds = min(3, history.round_number)
        weights = [0.5, 0.3, 0.2]
        total_weighted_defections = 0.0
        total_weight = 0.0
        for i in range(recent_rounds):
            round_idx = history.round_number - 1 - i
            weight = weights[i]
            defections_in_round = sum(1 - history.opponent_actions[round_idx, :])
            defection_rate = defections_in_round / self.n_players
            total_weighted_defections += weight * defection_rate
            total_weight += weight
        return total_weighted_defections / total_weight if total_weight > 0 else 0.0

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate simple average cooperation rate over last 3 rounds."""
        if history.round_number == 0:
            return 1.0
        recent_rounds = min(3, history.round_number)
        total_cooperations = 0
        total_actions = 0
        for i in range(recent_rounds):
            round_idx = history.round_number - recent_rounds + i
            cooperations_in_round = sum(history.opponent_actions[round_idx, :])
            total_cooperations += cooperations_in_round
            total_actions += self.n_players
        return total_cooperations / total_actions if total_actions > 0 else 1.0

    def _endgame_strategy(self, stock_level: float, history: PlayerHistory) -> Action:
        """Handle strategy in final 20% of rounds."""
        stock_health = stock_level / self.capacity
        if stock_health > 0.5:
            defection_pressure = self._calculate_defection_pressure(history)
            recent_cooperation_rate = self._calculate_recent_cooperation_rate(history)
            if defection_pressure >= self.high_pressure_threshold:
                return Action.D
            if recent_cooperation_rate >= self.cooperation_threshold:
                return Action.C
            return Action.C
        elif stock_health < 0.3:
            return Action.C
        else:
            if history.round_number > 0:
                last_round_cooperations = sum(history.opponent_actions[-1, :])
                if last_round_cooperations > self.n_players / 2:
                    return Action.C
                else:
                    return Action.D
            return Action.C

class Strategy_COOPERATIVE_127(BaseStrategy):
    """
    Sustainable Guardian: An adaptive cooperative strategy that prioritizes long-term 
    resource sustainability while being forgiving toward occasional defections.
    Uses cooperation scores and stock health assessment to make decisions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.cooperation_scores = [1.0] * (self.n_players - 1)
        self.emergency_threshold = 0.4 * self.capacity
        self.healthy_threshold = 0.8 * self.capacity
        self.learning_rate = 0.1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        last_round_idx = history.round_number - 1
        for i in range(self.n_players - 1):
            if history.opponent_actions[last_round_idx, i]:
                self.cooperation_scores[i] += self.learning_rate * (1.0 - self.cooperation_scores[i])
            else:
                self.cooperation_scores[i] -= self.learning_rate * self.cooperation_scores[i]
        avg_cooperation_score = sum(self.cooperation_scores) / len(self.cooperation_scores)
        current_stock = state.current_stock
        current_round = state.round_number
        if current_stock < self.emergency_threshold:
            return Action.C
        elif current_stock >= self.healthy_threshold:
            if avg_cooperation_score >= 0.5:
                return Action.C
            else:
                cooperation_prob = 0.7 * avg_cooperation_score + 0.3
                return Action.C if random.random() < cooperation_prob else Action.D
        else:
            cooperation_probability = 0.3 + 0.6 * avg_cooperation_score
            if current_round > 0.7 * self.n_rounds:
                cooperation_probability += 0.2
            cooperation_probability = min(1.0, max(0.0, cooperation_probability))
            return Action.C if random.random() < cooperation_probability else Action.D

class Strategy_COOPERATIVE_128(BaseStrategy):
    """
    Adaptive Trust-Based Cooperative Strategy: Balances collective welfare with protection
    against exploitation through adaptive trust management and sustainable resource monitoring.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.trust_scores = [0.8] * (game_description.n_players - 1)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        group_trust = sum(self.trust_scores) / len(self.trust_scores)
        sustainability_index = state.current_stock / self.game_description.capacity
        current_round = history.round_number + 1
        self._update_trust_scores(history)
        if current_round == self.game_description.n_rounds:
            return Action.C if group_trust >= 0.6 else Action.D
        if sustainability_index < 0.15:
            return Action.D
        if sustainability_index < 0.3:
            if len(history.opponent_actions) > 0:
                last_round_cooperators = sum(history.opponent_actions[-1, :])
                total_opponents = len(history.opponent_actions[-1, :])
                cooperation_rate = last_round_cooperators / total_opponents
                return Action.C if cooperation_rate >= 0.75 else Action.D
            else:
                return Action.D
        if group_trust >= 0.5:
            return Action.C
        else:
            return Action.C if random.random() < group_trust else Action.D

    def _update_trust_scores(self, history: PlayerHistory):
        """Update trust scores based on opponents' last actions."""
        if len(history.opponent_actions) == 0:
            return
        last_round_actions = history.opponent_actions[-1, :]
        for i, action in enumerate(last_round_actions):
            if action:
                self.trust_scores[i] = min(1.0, self.trust_scores[i] + 0.1)
            else:
                self.trust_scores[i] = max(0.0, self.trust_scores[i] - 0.2)

class Strategy_AGGRESSIVE_1(BaseStrategy):
    """
    Aggressive Opportunistic Strategy: "Resource Predator"
    
    Operates on aggressive opportunism - maximizing immediate gains while strategically
    preserving resources only when it serves long-term advantage. Views other players
    as competitors to outmaneuver rather than partners to cooperate with.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = state.round_number
        stock = state.current_stock
        rounds_remaining = self.r - current_round
        if rounds_remaining <= 1:
            return Action.D
        if current_round <= 1:
            return Action.D
        depletion_threshold = self.n * 2
        abundance_threshold = self.capacity * 0.7
        if stock > abundance_threshold:
            return Action.D
        if current_round >= max(self.r - 2, self.r * 0.8):
            return Action.D
        if stock < self.n * 1.5 and rounds_remaining <= 3:
            return Action.D
        if current_round >= 3:
            recent_rounds = min(3, current_round)
            start_idx = current_round - recent_rounds
            recent_opponent_actions = history.opponent_actions[start_idx:current_round, :]
            total_recent_actions = recent_opponent_actions.size
            if total_recent_actions > 0:
                recent_defections = np.sum(~recent_opponent_actions)
                defection_rate = recent_defections / total_recent_actions
                if defection_rate > 0.6:
                    return Action.D
        if stock < depletion_threshold and rounds_remaining > self.r * 0.3:
            return Action.D
        if current_round >= 3:
            my_recent_defections = np.sum(~history.my_actions[-3:])
            my_defect_rate = my_recent_defections / min(3, current_round)
            if my_defect_rate > 0.7:
                if current_round >= 2:
                    recent_cooperation = np.mean(history.opponent_actions[-2:, :])
                    if recent_cooperation > 0.6:
                        return Action.D
        base_aggression = 0.8
        stock_multiplier = min(2.0, stock / self.capacity + 0.5)
        endgame_multiplier = min(3.0, (self.r - rounds_remaining + 1) / (self.r * 0.3))
        aggression_factor = base_aggression * stock_multiplier * endgame_multiplier
        if random.random() < aggression_factor:
            return Action.D
        if random.random() < 0.1:
            return Action.C
        if stock < self.n * 0.5:
            if rounds_remaining > 5:
                return Action.C
            else:
                return Action.D
        if current_round >= 2 and stock >= self.capacity * 0.95:
            if random.random() < 0.9:
                return Action.D
        return Action.C

class Strategy_AGGRESSIVE_2(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Resource Predator"
    
    Operates on aggressive resource extraction while maintaining strategic sustainability.
    Aims to extract maximum value from the common pool while preventing complete collapse.
    Uses adaptive exploitation thresholds and responds to opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = state.round_number
        remaining_rounds = self.n_rounds - current_round
        stock_ratio = state.current_stock / self.capacity
        if remaining_rounds <= 1:
            return Action.D
        if remaining_rounds == 2 and stock_ratio >= 0.1:
            return Action.D
        total_opponent_actions = history.opponent_actions.size
        total_defections = np.sum(history.opponent_actions == False)
        opponent_defection_rate = total_defections / total_opponent_actions if total_opponent_actions > 0 else 0
        base_threshold = 0.3 + 0.4 * remaining_rounds / self.n_rounds
        aggression_multiplier = 1 + opponent_defection_rate * 0.3
        adjusted_threshold = max(0.2, base_threshold / aggression_multiplier)
        if stock_ratio < 0.15:
            return Action.C
        if stock_ratio > adjusted_threshold:
            return Action.D
        if len(history.my_payoffs) >= 2:
            last_payoff = history.my_payoffs[-1]
            prev_payoff = history.my_payoffs[-2]
            if last_payoff > prev_payoff and stock_ratio > 0.25:
                return Action.D
        if len(history.opponent_actions) > 0:
            last_round_opponents = history.opponent_actions[-1, :]
            opponent_defectors = np.sum(last_round_opponents == False)
            opponent_cooperators = np.sum(last_round_opponents == True)
            if opponent_defectors > opponent_cooperators:
                return Action.D
            if opponent_cooperators == len(last_round_opponents):
                return Action.D
        if len(history.opponent_actions) >= 2:
            recent_actions = history.opponent_actions[-2:, :]
            recent_cooperation_rate = np.mean(recent_actions == True)
            if recent_cooperation_rate >= 0.8:
                return Action.D
        if stock_ratio < 0.25:
            if len(history.my_actions) >= 2:
                recent_my_actions = history.my_actions[-2:]
                if np.mean(recent_my_actions == True) >= 0.5:
                    if stock_ratio < 0.3:
                        return Action.C
                    else:
                        return Action.D
            return Action.C
        return Action.C

class Strategy_AGGRESSIVE_3(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES) - A predatory strategy that maximizes 
    extraction while maintaining resource sustainability through calculated cooperation only 
    when absolutely necessary.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_num = state.round_number + 1
        stock = state.current_stock
        if round_num <= 3:
            if round_num == 1 or stock >= self.capacity / 4:
                return Action.D
            else:
                return Action.C
        if round_num >= self.n_rounds - 1:
            if round_num == self.n_rounds or stock >= self.capacity * 0.3:
                return Action.D
            else:
                return Action.C
        if stock <= self.capacity * 0.15:
            return Action.C
        if stock >= self.capacity * 0.7:
            return Action.D
        if stock == 0:
            return Action.C
        coop_rate = self._calculate_recent_cooperation_rate(history)
        if coop_rate >= 0.6:
            return Action.D
        if coop_rate <= 0.3:
            return Action.C
        my_recent_defection_rate = self._calculate_my_recent_defection_rate(history)
        if self._is_stock_declining_trend(history) and stock < self.capacity * 0.4:
            return Action.C
        if my_recent_defection_rate < 0.7:
            return Action.D
        else:
            return Action.C

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate cooperation rate over last 3 rounds"""
        if history.round_number == 0:
            return 0.5
        lookback = min(3, history.round_number)
        recent_actions = history.opponent_actions[-lookback:, :]
        total_actions = lookback * self.n_players
        total_cooperations = np.sum(recent_actions)
        return total_cooperations / total_actions if total_actions > 0 else 0.5

    def _calculate_my_recent_defection_rate(self, history: PlayerHistory) -> float:
        """Calculate my defection rate over last 3 rounds"""
        if history.round_number == 0:
            return 0.0
        lookback = min(3, history.round_number)
        recent_my_actions = history.my_actions[-lookback:]
        defections = np.sum(~recent_my_actions)
        return defections / lookback

    def _is_stock_declining_trend(self, history: PlayerHistory) -> bool:
        """Check if stock has been declining for 3+ consecutive rounds"""
        if history.round_number < 3:
            return False
        recent_payoffs = history.my_payoffs[-3:]
        if len(recent_payoffs) >= 3:
            return recent_payoffs[1] < recent_payoffs[0] and recent_payoffs[2] < recent_payoffs[1]
        return False

class Strategy_AGGRESSIVE_4(BaseStrategy):
    """
    Aggressive Opportunistic Resource Extraction Strategy.
    
    Operates on aggressive resource extraction with calculated sustainability.
    Maximizes immediate gains while maintaining just enough sustainability to continue extracting value.
    Adapts to opponent behaviors and resource levels dynamically.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.burn_threshold = max(3, self.n_rounds // 4)
        self.critical_threshold = self.capacity / 4
        self.hostile_threshold = 0.7
        self.advantage_threshold = 0.2
        self.endgame_threshold = max(1, self.n_rounds // 5)
        self.opponent_aggression = {}
        self.hostile_opponents = set()

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round <= self.burn_threshold:
            return Action.D
        if current_round >= self.n_rounds - self.endgame_threshold:
            return Action.D
        if current_stock <= self.critical_threshold:
            return Action.D
        self._update_opponent_tracking(history)
        hostile_count = len(self.hostile_opponents)
        avg_aggression = self._calculate_average_aggression(history)
        if avg_aggression >= self.hostile_threshold:
            return Action.D
        if self._should_cooperate_tactically(state, history):
            return Action.C
        return Action.D

    def _update_opponent_tracking(self, history: PlayerHistory):
        """Update opponent aggression scores and hostile player set."""
        current_round = history.round_number
        for opponent_idx in range(self.n_players - 1):
            opponent_defections = sum(~history.opponent_actions[:current_round, opponent_idx])
            aggression_score = opponent_defections / current_round if current_round > 0 else 0
            self.opponent_aggression[opponent_idx] = aggression_score
            if aggression_score >= self.hostile_threshold:
                self.hostile_opponents.add(opponent_idx)

    def _calculate_average_aggression(self, history: PlayerHistory):
        """Calculate average aggression score across all opponents."""
        if len(self.opponent_aggression) == 0:
            return 0.0
        return sum(self.opponent_aggression.values()) / len(self.opponent_aggression)

    def _should_cooperate_tactically(self, state: CommonPoolState, history: PlayerHistory) -> bool:
        """Check if all conditions are met for tactical cooperation."""
        current_round = history.round_number
        current_stock = state.current_stock
        if current_stock <= self.capacity / 2:
            return False
        if current_round > 0:
            last_round_cooperators = sum(history.opponent_actions[current_round - 1, :])
            if last_round_cooperators <= (self.n_players - 1) / 2:
                return False
        my_total_payoff = sum(history.my_payoffs[:current_round])
        opponent_total_payoffs = np.sum(history.opponent_payoffs[:current_round, :], axis=0)
        all_payoffs = np.append(opponent_total_payoffs, my_total_payoff)
        avg_payoff = np.mean(all_payoffs)
        if my_total_payoff >= avg_payoff:
            return False
        if current_round >= 2:
            recent_cooperation_rate = self._get_recent_cooperation_rate(history, 3)
            if recent_cooperation_rate < 0.5:
                return False
        return True

    def _get_recent_cooperation_rate(self, history: PlayerHistory, lookback: int) -> float:
        """Calculate cooperation rate over recent rounds."""
        current_round = history.round_number
        start_round = max(0, current_round - lookback)
        if start_round >= current_round:
            return 0.0
        my_cooperations = sum(history.my_actions[start_round:current_round])
        opponent_cooperations = np.sum(history.opponent_actions[start_round:current_round, :])
        total_cooperations = my_cooperations + opponent_cooperations
        total_actions = (current_round - start_round) * self.n_players
        return total_cooperations / total_actions if total_actions > 0 else 0.0

class Strategy_AGGRESSIVE_5(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES)
    
    A strategy focused on maximum extraction with calculated aggression.
    Uses opening aggression, opponent punishment, stock monitoring, and endgame exploitation
    to maximize individual payoff while preventing total resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if history is None:
            return Action.D
        if round_num <= 1:
            return Action.D
        if round_num == self.n_rounds - 1:
            return Action.D
        if round_num == self.n_rounds - 2:
            return Action.D if stock > self.capacity * 0.2 else Action.C
        if stock <= self.capacity * 0.1:
            return Action.C
        last_round_opponents = history.opponent_actions[-1, :]
        defectors_last_round = sum(last_round_opponents == False)
        if defectors_last_round >= self.n_players * 0.5:
            return Action.D
        rounds_remaining = self.n_rounds - round_num
        if stock < self.capacity * 0.3 and rounds_remaining < 3:
            return Action.C
        if stock < self.capacity * 0.5:
            all_cooperated_last = all(last_round_opponents == True)
            if all_cooperated_last:
                return Action.C
        if len(history.my_payoffs) >= 2:
            prev_round_total_cooperators = sum(history.opponent_actions[-1, :] == True)
            if history.my_actions[-1]:
                prev_round_total_cooperators += 1
            expected_consumption_ratio = (prev_round_total_cooperators * 0.5 + (self.n_players - prev_round_total_cooperators) * 1.0) / self.n_players
            if stock > self.capacity * 0.4:
                return Action.D
        if len(history.opponent_actions) >= 2:
            all_coop_last = all(history.opponent_actions[-1, :] == True)
            all_coop_second_last = all(history.opponent_actions[-2, :] == True)
            if all_coop_last and all_coop_second_last and (stock > self.capacity * 0.4):
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_6(BaseStrategy):
    """
    Aggressive Opportunistic Resource Maximizer (AORM)
    
    This strategy maximizes personal payoff through aggressive resource extraction
    while maintaining strategic flexibility. It prioritizes immediate gains but
    includes calculated cooperation to prevent total resource collapse when beneficial.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_num = history.round_number + 1
        stock = state.current_stock
        if round_num == self.n_rounds:
            return Action.D
        if stock <= 0.05 * self.capacity:
            return self._emergency_cooperate(history)
        phase = self._determine_phase(round_num)
        if phase == 'early':
            return self._early_exploitation(stock)
        elif phase == 'adaptive':
            return self._adaptive_predation(stock, history)
        else:
            return self._endgame_extraction(stock, round_num)

    def _determine_phase(self, round_num):
        """Determine which phase of the strategy we're in."""
        early_end = math.ceil(self.n_rounds / 3)
        adaptive_end = math.ceil(2 * self.n_rounds / 3)
        if round_num <= early_end:
            return 'early'
        elif round_num <= adaptive_end:
            return 'adaptive'
        else:
            return 'endgame'

    def _early_exploitation(self, stock):
        """Phase 1: Early exploitation with exception for low stock."""
        if stock < self.capacity / 4:
            return Action.C
        return Action.D

    def _adaptive_predation(self, stock, history):
        """Phase 2: Dynamic decision based on stock health and opponent patterns."""
        if stock > self.capacity / 2:
            return Action.D
        if stock <= self.capacity / 4:
            return Action.C
        return self._opponent_tracking_logic(stock, history)

    def _opponent_tracking_logic(self, stock, history):
        """Track opponent behavior and respond strategically."""
        lookback = min(3, len(history.my_actions))
        if lookback == 0:
            return Action.D
        recent_opponent_actions = history.opponent_actions[-lookback:, :]
        defection_rate = 1.0 - np.mean(recent_opponent_actions)
        if defection_rate > 0.6:
            return Action.D
        elif defection_rate < 0.4:
            return Action.D
        else:
            if self._is_stock_declining_rapidly(history):
                return Action.C
            return Action.D

    def _is_stock_declining_rapidly(self, history):
        """Check if stock is declining by >15% per round."""
        if len(history.my_actions) < 2:
            return False
        recent_payoffs = history.my_payoffs[-2:]
        if len(recent_payoffs) < 2:
            return False
        decline_rate = (recent_payoffs[0] - recent_payoffs[1]) / recent_payoffs[0]
        return decline_rate > 0.15

    def _endgame_extraction(self, stock, round_num):
        """Phase 3: Maximize final value with calculated risk."""
        remaining_rounds = self.n_rounds - round_num + 1
        if stock > self.capacity / 3:
            return Action.D
        coop_payoff = remaining_rounds * (stock / (2 * self.n_players))
        defect_once_payoff = stock / self.n_players
        if defect_once_payoff > coop_payoff:
            return Action.D
        else:
            if remaining_rounds <= 2:
                return Action.D
            return Action.C

    def _emergency_cooperate(self, history):
        """Emergency cooperation when stock is critically low."""
        if len(history.my_actions) >= 2:
            recent_actions = history.my_actions[-2:]
            if all(recent_actions):
                return Action.D
        return Action.C

    def _detect_mass_cooperation(self, history):
        """Detect if >= 75% of opponents cooperated in last round."""
        if len(history.my_actions) == 0:
            return False
        last_round_actions = history.opponent_actions[-1, :]
        cooperation_rate = np.mean(last_round_actions)
        return cooperation_rate >= 0.75

    def _detect_mass_defection(self, history):
        """Detect if >= 75% of opponents defected in last round."""
        if len(history.my_actions) == 0:
            return False
        last_round_actions = history.opponent_actions[-1, :]
        defection_rate = 1.0 - np.mean(last_round_actions)
        return defection_rate >= 0.75

class Strategy_AGGRESSIVE_7(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Resource Predator"
    
    Operates on aggressive resource extraction with strategic timing.
    Maximizes personal payoffs while maintaining just enough restraint 
    to keep the resource pool viable for continued exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round = state.round_number
        stock = state.current_stock
        if current_round <= r // 2:
            if stock < capacity / 4:
                return Action.C
            else:
                return Action.D
        if current_round >= r - 2:
            return Action.D
        if stock > capacity / 3:
            return Action.D
        else:
            last_round_actions = history.opponent_actions[-1, :]
            defectors_last_round = sum(1 - last_round_actions)
            if defectors_last_round > n / 2:
                return Action.D
            else:
                return Action.C

class Strategy_AGGRESSIVE_8(BaseStrategy):
    """
    Aggressive Exploitative Strategy: "Resource Predator"
    
    Operates on aggressive opportunism - maximizing immediate gains while strategically
    preserving the resource only when absolutely necessary. Exploits cooperators and
    matches defectors' aggression in a tournament setting.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.opponent_cooperation_window = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = state.round_number
        remaining_rounds = self.r - current_round
        stock = state.current_stock
        if remaining_rounds <= 0:
            return Action.D
        if stock < self.capacity * 0.05:
            return Action.D
        if stock < self.capacity * 0.3 and remaining_rounds <= 3:
            return Action.D
        if stock < self.capacity * 0.1:
            return Action.D
        early_phase_end = math.ceil(self.r / 3)
        middle_phase_end = math.ceil(2 * self.r / 3)
        is_early_phase = current_round <= early_phase_end
        is_middle_phase = early_phase_end < current_round <= middle_phase_end
        is_end_phase = current_round > middle_phase_end
        if is_end_phase:
            return Action.D
        recent_rounds = min(self.opponent_cooperation_window, len(history.my_actions))
        if recent_rounds > 0:
            recent_opponent_actions = history.opponent_actions[-recent_rounds:, :]
            cooperation_rates = np.mean(recent_opponent_actions, axis=0)
            avg_cooperation_rate = np.mean(cooperation_rates)
            if avg_cooperation_rate > 0.6:
                return Action.D
            elif avg_cooperation_rate < 0.3:
                return Action.D
        if len(history.my_actions) > 0:
            last_round_opponent_actions = history.opponent_actions[-1, :]
            num_opponent_defectors = np.sum(last_round_opponent_actions == False)
            num_opponent_cooperators = np.sum(last_round_opponent_actions == True)
            my_last_action = history.my_actions[-1]
            if num_opponent_cooperators == self.n - 1:
                return Action.D
            total_defectors_last_round = num_opponent_defectors
            if not my_last_action:
                total_defectors_last_round += 1
            if total_defectors_last_round <= math.ceil(self.n / 3) and my_last_action:
                return Action.D
        if len(history.my_actions) > 0:
            if stock > self.capacity * 0.8:
                return Action.D
        if is_early_phase:
            if stock > 0.8 * self.capacity:
                if len(history.my_actions) > 0:
                    last_round_defectors = np.sum(history.opponent_actions[-1, :] == False)
                    if last_round_defectors < (self.n - 1) // 2:
                        return Action.C
            return Action.D
        elif is_middle_phase:
            if stock > 0.7 * self.capacity:
                if len(history.my_actions) > 0:
                    my_last_action = history.my_actions[-1]
                    last_round_defectors = np.sum(history.opponent_actions[-1, :] == False)
                    if not my_last_action and last_round_defectors == 0:
                        return Action.C
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_9(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Predator"
    
    Operates on aggressive opportunism - maximizing immediate gains while strategically 
    preserving just enough resources to maintain exploitation opportunities. Views the 
    common pool as a resource to be dominated and extracted from as efficiently as possible.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = 0.3
        self.opportunity_threshold = 0.7
        self.base_aggression = 0.8

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        stock_health = state.current_stock / self.capacity
        current_round = state.round_number
        remaining_rounds = self.n_rounds - current_round
        last_round_actions = history.opponent_actions[-1, :]
        cooperators_last_round = sum(last_round_actions)
        defectors_last_round = self.n_players - 1 - cooperators_last_round
        cooperation_rate = cooperators_last_round / (self.n_players - 1)
        if remaining_rounds <= 1:
            return Action.D
        early_game_end = self.n_rounds // 3
        mid_game_end = 2 * self.n_rounds // 3
        if current_round <= early_game_end:
            if stock_health > self.opportunity_threshold:
                return Action.D
            elif stock_health > 0.4 and cooperators_last_round > (self.n_players - 1) // 2:
                return Action.D
            elif stock_health <= self.critical_threshold:
                return Action.C
            else:
                return Action.D
        elif current_round <= mid_game_end:
            exploitation_score = defectors_last_round / (self.n_players - 1) * stock_health
            if exploitation_score > 0.5:
                return Action.D
            elif stock_health < 0.25 and remaining_rounds > 3:
                return Action.C
            elif self._count_consecutive_cooperations(history) >= 2:
                return Action.D
            else:
                return Action.D
        elif stock_health < 0.2 and remaining_rounds <= 2:
            return Action.D
        elif stock_health > 0.6:
            return Action.D
        else:
            expected_defect_gain = self._estimate_payoff_if_defect(state, cooperation_rate)
            expected_coop_gain = self._estimate_payoff_if_cooperate(state)
            if expected_defect_gain > 2 * expected_coop_gain:
                return Action.D
            else:
                return Action.C

    def _count_consecutive_cooperations(self, history: PlayerHistory) -> int:
        """Count consecutive rounds where majority of opponents cooperated."""
        if len(history.opponent_actions) == 0:
            return 0
        consecutive = 0
        for round_idx in range(len(history.opponent_actions) - 1, -1, -1):
            cooperators = sum(history.opponent_actions[round_idx, :])
            if cooperators > (self.n_players - 1) // 2:
                consecutive += 1
            else:
                break
        return consecutive

    def _estimate_payoff_if_defect(self, state: CommonPoolState, opponent_cooperation_rate: float) -> float:
        """Estimate payoff if I defect, based on opponent cooperation rate."""
        if state.current_stock <= 0:
            return 0
        return state.current_stock / self.n_players

    def _estimate_payoff_if_cooperate(self, state: CommonPoolState) -> float:
        """Estimate payoff if I cooperate."""
        if state.current_stock <= 0:
            return 0
        return state.current_stock / (2 * self.n_players)

class Strategy_AGGRESSIVE_10(BaseStrategy):
    """
    Opportunistic Predator: An aggressive common pool resource strategy that maximizes 
    immediate gains through front-loaded aggression, conditional preservation only when 
    necessary, and end-game extraction. Exploits cooperative opponents while using 
    tactical cooperation only to preserve future extraction opportunities.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.phase1_end = max(1, self.n_rounds // 3)
        self.phase2_end = max(2, 2 * self.n_rounds // 3)
        self.critical_stock_threshold = self.capacity / 10
        self.survival_threshold = self.capacity / 6

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if history is None:
            return Action.D
        if current_stock < self.critical_stock_threshold:
            return Action.C
        if current_round <= self.phase1_end:
            return self._phase1_strategy(current_stock, history)
        elif current_round > self.phase2_end:
            return self._phase3_strategy(current_stock, history)
        else:
            return self._phase2_strategy(current_stock, history)

    def _phase1_strategy(self, current_stock, history):
        """Early rounds: Aggressive exploration with minimal cooperation"""
        if current_stock > self.capacity / 2:
            return Action.D
        if self._get_recent_defection_rate(history, 1) >= 0.5:
            return Action.D
        if current_stock <= self.capacity / 4:
            return Action.C
        return Action.D

    def _phase2_strategy(self, current_stock, history):
        """Middle rounds: Adaptive exploitation with retaliation"""
        if current_stock > self.capacity / 3:
            return Action.D
        recent_defection_rate = self._get_recent_defection_rate(history, 3)
        if recent_defection_rate > 0.4:
            return Action.D
        if len(history.opponent_actions) > 0:
            last_round_defection_rate = 1 - np.mean(history.opponent_actions[-1, :])
            if last_round_defection_rate > 0.6:
                if len(history.opponent_actions) >= 2:
                    prev_defection_rate = 1 - np.mean(history.opponent_actions[-2, :])
                    if prev_defection_rate > 0.6:
                        return Action.D
                return Action.D
        if current_stock <= self.capacity / 5:
            consumption_per_cooperator = current_stock / (2 * self.n_players)
            consumption_per_defector = current_stock / self.n_players
            estimated_cooperators = max(1, int(recent_defection_rate * self.n_players))
            estimated_defectors = self.n_players - estimated_cooperators
            total_consumption = estimated_cooperators * consumption_per_cooperator + estimated_defectors * consumption_per_defector
            stock_after = max(0, current_stock - total_consumption)
            growth_potential = 2 * stock_after * (1 - stock_after / self.capacity)
            defection_gain = consumption_per_defector - consumption_per_cooperator
            if growth_potential > defection_gain:
                return Action.C
        return Action.D

    def _phase3_strategy(self, current_stock, history):
        """End game: Maximum extraction with escalating aggression"""
        remaining_rounds = self.n_rounds - len(history.my_actions)
        if remaining_rounds <= 2:
            return Action.D
        if current_stock > self.survival_threshold:
            return Action.D
        if remaining_rounds <= max(1, self.n_rounds // 5):
            consumption_if_all_defect = current_stock
            if consumption_if_all_defect < current_stock:
                return Action.D
        return Action.C

    def _get_recent_defection_rate(self, history, rounds_back):
        """Calculate opponent defection rate over recent rounds"""
        if len(history.opponent_actions) == 0:
            return 0.0
        start_idx = max(0, len(history.opponent_actions) - rounds_back)
        recent_actions = history.opponent_actions[start_idx:, :]
        if recent_actions.size == 0:
            return 0.0
        cooperation_rate = np.mean(recent_actions)
        return 1.0 - cooperation_rate

class Strategy_AGGRESSIVE_11(BaseStrategy):
    """
    Aggressive Adaptive Resource Exploitation Strategy - "Predatory Sustainability"
    
    Operates on calculated aggression: maximize immediate gains while strategically 
    preserving just enough resource sustainability. Always defects unless specific 
    sustainability conditions are met AND cooperation appears profitable.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_rounds_remaining = 0
        self.emergency_coop_rounds_remaining = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = state.round_number
        stock = state.current_stock
        capacity = self.game_description.capacity
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if current_round <= 3:
            return Action.D
        if current_round > total_rounds - 2:
            return Action.D
        if stock < capacity * 0.1:
            self.emergency_coop_rounds_remaining = 3
            return Action.C
        if self.emergency_coop_rounds_remaining > 0:
            self.emergency_coop_rounds_remaining -= 1
            if stock > capacity * 0.2:
                self.emergency_coop_rounds_remaining = 0
            else:
                return Action.C
        recent_rounds = min(3, len(history.opponent_actions))
        if recent_rounds > 0:
            recent_opponent_actions = history.opponent_actions[-recent_rounds:, :]
            recent_defections = np.sum(recent_opponent_actions == False)
            total_recent_actions = recent_rounds * (n_players - 1)
            opponent_defection_rate = recent_defections / total_recent_actions if total_recent_actions > 0 else 0
            if len(history.opponent_actions) > 0:
                last_round_cooperators = np.sum(history.opponent_actions[-1, :] == True)
                last_round_coop_rate = last_round_cooperators / (n_players - 1)
            else:
                last_round_coop_rate = 0
        else:
            opponent_defection_rate = 0
            last_round_coop_rate = 0
        punishment_triggered = False
        if len(history.opponent_actions) >= 3:
            for opponent_idx in range(n_players - 1):
                recent_opponent_defections = np.sum(history.opponent_actions[-3:, opponent_idx] == False)
                if recent_opponent_defections > 1.5:
                    punishment_triggered = True
                    break
        if punishment_triggered and self.punishment_rounds_remaining <= 0:
            self.punishment_rounds_remaining = 2
        if self.punishment_rounds_remaining > 0:
            self.punishment_rounds_remaining -= 1
            return Action.D
        stock_ratio = stock / capacity
        if stock_ratio < 0.3 or opponent_defection_rate > 0.6 or (stock_ratio > 0.7 and last_round_coop_rate < 0.75):
            return Action.D
        if stock_ratio >= 0.3 and last_round_coop_rate >= 0.75 and (current_round <= total_rounds - 2) and (0.3 <= stock_ratio <= 0.7):
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_12(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES) - Maximizes individual payoffs through
    aggressive resource extraction while maintaining strategic sustainability awareness.
    Always defects in first round, then adapts based on opponent cooperation rates,
    stock health, and game progression.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        cooperation_rate = self._calculate_cooperation_rate(history)
        stock_health = state.current_stock / self.game_description.capacity
        rounds_remaining = self.game_description.n_rounds - state.round_number
        if state.current_stock < self.game_description.capacity * 0.3:
            return Action.C
        if rounds_remaining <= 2:
            return Action.D
        if cooperation_rate >= 0.7:
            return Action.D
        elif cooperation_rate <= 0.3:
            return Action.D
        elif stock_health > 0.6 and rounds_remaining > 3:
            return Action.C
        else:
            return Action.D

    def _calculate_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate the cooperation rate of opponents in the last round."""
        if len(history.opponent_actions) == 0:
            return 0.0
        last_round_actions = history.opponent_actions[-1, :]
        cooperators = np.sum(last_round_actions)
        total_opponents = len(last_round_actions)
        if total_opponents == 0:
            return 0.0
        return cooperators / total_opponents

class Strategy_AGGRESSIVE_13(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES) - Maximizes extraction through intelligent
    aggression while preventing resource collapse. Operates in three phases: early exploitation,
    strategic adaptation, and endgame extraction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.betrayal_count = {}
        self.consecutive_decline_rounds = 0
        self.last_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.last_stock = state.current_stock
            return Action.D
        if self.last_stock is not None:
            if state.current_stock < self.last_stock:
                self.consecutive_decline_rounds += 1
            else:
                self.consecutive_decline_rounds = 0
        self.last_stock = state.current_stock
        round_num = history.round_number
        n_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        phase = self._determine_phase(round_num, n_rounds)
        if self._check_punishment_needed(history):
            return Action.D
        if current_stock < 0.1 * capacity:
            return Action.C
        if phase == 'early':
            return self._early_exploitation_logic(round_num, current_stock, capacity, history)
        elif phase == 'middle':
            return self._strategic_adaptation_logic(current_stock, capacity, history)
        else:
            return self._endgame_extraction_logic(round_num, current_stock, capacity, n_rounds)

    def _determine_phase(self, round_num, n_rounds):
        if round_num <= n_rounds // 3:
            return 'early'
        elif round_num <= 2 * n_rounds // 3:
            return 'middle'
        else:
            return 'endgame'

    def _early_exploitation_logic(self, round_num, current_stock, capacity, history):
        if current_stock > 0.8 * capacity:
            return Action.D
        if current_stock <= 0.8 * capacity:
            last_round_cooperators = sum(history.opponent_actions[-1, :])
            majority_cooperated = last_round_cooperators > len(history.opponent_actions[-1, :]) // 2
            if majority_cooperated:
                return Action.D
        if current_stock <= 0.5 * capacity:
            all_defected = sum(history.opponent_actions[-1, :]) == 0
            if all_defected:
                return Action.C
        return Action.D

    def _strategic_adaptation_logic(self, current_stock, capacity, history):
        if current_stock > 0.6 * capacity:
            return Action.D
        if current_stock <= 0.3 * capacity:
            return Action.C
        opponent_types = self._classify_opponents(history)
        cooperative_count = opponent_types['cooperative']
        aggressive_count = opponent_types['aggressive']
        total_opponents = len(history.opponent_actions[0, :])
        if cooperative_count >= total_opponents // 2:
            return Action.D
        if aggressive_count >= 0.7 * total_opponents:
            return Action.C
        return Action.D

    def _endgame_extraction_logic(self, round_num, current_stock, capacity, n_rounds):
        rounds_remaining = n_rounds - round_num
        if rounds_remaining <= 3:
            return Action.D
        if current_stock > 0.4 * capacity:
            return Action.D
        if current_stock <= 0.2 * capacity:
            return Action.C
        return Action.D

    def _classify_opponents(self, history):
        n_opponents = len(history.opponent_actions[0, :])
        n_rounds_played = len(history.opponent_actions)
        cooperative_count = 0
        aggressive_count = 0
        for opponent_idx in range(n_opponents):
            opponent_actions = history.opponent_actions[:, opponent_idx]
            cooperation_rate = sum(opponent_actions) / len(opponent_actions)
            if cooperation_rate >= 0.7:
                cooperative_count += 1
            elif cooperation_rate <= 0.3:
                aggressive_count += 1
        return {'cooperative': cooperative_count, 'aggressive': aggressive_count, 'adaptive': n_opponents - cooperative_count - aggressive_count}

    def _check_punishment_needed(self, history):
        if len(history.opponent_actions) < 2:
            return False
        if self.consecutive_decline_rounds >= 3 and len(history.my_actions) > 0 and (history.my_actions[-1] == True):
            return True
        return False

class Strategy_AGGRESSIVE_14(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES) - maximizes immediate gains while 
    strategically preserving future exploitation opportunities through aggressive opportunism.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = self.capacity / 4
        self.healthy_threshold = self.capacity / 2
        self.optimal_threshold = 3 * self.capacity / 4
        self.probe_end = min(3, self.n_rounds)
        self.endgame_start = max(1, self.n_rounds - 2)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number
        current_stock = state.current_stock
        if current_round < self.probe_end:
            if current_stock < self.critical_threshold:
                return Action.C
            else:
                return Action.D
        elif current_round >= self.endgame_start:
            if current_round == self.n_rounds - 1:
                return Action.D
            elif current_stock >= self.capacity / 6:
                return Action.D
            else:
                return Action.C
        else:
            if current_stock < 0.1 * self.capacity:
                return Action.C
            if current_round >= 2:
                recent_my_actions = history.my_actions[-2:]
                if all(recent_my_actions):
                    return Action.D
            if current_stock >= self.healthy_threshold:
                return Action.D
            elif current_stock >= self.critical_threshold:
                cooperation_ratio = self._get_recent_cooperation_ratio(history, 3)
                if cooperation_ratio >= 0.6:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.C

    def _get_recent_cooperation_ratio(self, history: PlayerHistory, window: int) -> float:
        """Calculate the ratio of cooperative actions by opponents in recent rounds."""
        if history.round_number == 0:
            return 0.0
        lookback = min(window, history.round_number)
        if lookback == 0:
            return 0.0
        recent_actions = history.opponent_actions[-lookback:, :]
        total_actions = recent_actions.size
        if total_actions == 0:
            return 0.0
        cooperations = np.sum(recent_actions)
        return cooperations / total_actions

class Strategy_AGGRESSIVE_15(BaseStrategy):
    """
    Aggressive Exploitative Strategy: "Resource Predator"
    
    Operates on aggressive exploitation with calculated sustainability.
    Always defects in first and last rounds, exploits cooperative opponents,
    but switches to conservation when stock becomes critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = 0.15
        self.sustainable_threshold = 0.4
        self.abundance_threshold = 0.75
        self.exploitation_threshold = 0.6
        self.grudge_scores = {}

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_num = state.round_number
        if history is None:
            return Action.D
        if round_num == self.n_rounds - 1:
            return Action.D
        if current_stock <= self.capacity * self.critical_threshold:
            return Action.C
        cooperation_rate = self._calculate_recent_cooperation_rate(history)
        if current_stock >= self.capacity * self.abundance_threshold:
            return Action.D
        if cooperation_rate >= self.exploitation_threshold and current_stock >= self.capacity * self.sustainable_threshold:
            return Action.D
        if self._should_punish_opponents(history) and current_stock >= self.capacity * self.sustainable_threshold:
            return Action.D
        final_phase_threshold = int(0.8 * self.n_rounds)
        if round_num >= final_phase_threshold and current_stock >= self.capacity * self.sustainable_threshold:
            endgame_defect_prob = 0.3 + 0.4 * ((round_num - final_phase_threshold) / (self.n_rounds - final_phase_threshold))
            if random.random() < endgame_defect_prob:
                return Action.D
        return Action.C

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate cooperation rate of opponents, weighting recent rounds more heavily."""
        if history.round_number == 0:
            return 0.0
        lookback = min(5, history.round_number)
        recent_actions = history.opponent_actions[-lookback:, :]
        total_actions = recent_actions.size
        if total_actions == 0:
            return 0.0
        cooperations = np.sum(recent_actions)
        return cooperations / total_actions

    def _should_punish_opponents(self, history: PlayerHistory) -> bool:
        """Determine if we should punish opponents based on their past defections against us."""
        if history.round_number < 2:
            return False
        last_round = history.round_number - 1
        my_last_action = history.my_actions[last_round]
        if my_last_action:
            opponent_last_actions = history.opponent_actions[last_round, :]
            defectors = np.sum(~opponent_last_actions)
            if defectors > self.n_players // 2:
                return True
        return False

class Strategy_AGGRESSIVE_16(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Resource Predator"
    
    Operates on aggressive early exploitation combined with intelligent opportunism.
    Phase 1: Always defect early to capture maximum value.
    Phase 2: Tactical adaptation - defect by default, cooperate only under strict conditions.
    Phase 3: Always defect in endgame to extract remaining value.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = state.round_number
        current_stock = state.current_stock
        total_rounds = self.n_rounds
        if current_round <= total_rounds // 3:
            return Action.D
        if current_round > 2 * total_rounds // 3:
            return Action.D
        if current_stock < self.capacity / 4:
            return Action.D
        if len(history.opponent_actions) > 0:
            last_round_cooperators = sum(history.opponent_actions[-1, :])
            if last_round_cooperators == 0:
                return Action.D
        phase_2_end = 2 * total_rounds // 3
        rounds_remaining_in_phase = phase_2_end - current_round
        if current_stock > self.capacity / 2 and len(history.opponent_actions) > 0 and (rounds_remaining_in_phase > 3):
            last_round_cooperators = sum(history.opponent_actions[-1, :])
            cooperation_rate = last_round_cooperators / (self.n_players - 1)
            stock_grew = False
            if len(history.my_payoffs) >= 2:
                current_payoff = history.my_payoffs[-1]
                previous_payoff = history.my_payoffs[-2]
                if history.my_actions[-1]:
                    estimated_last_stock = current_payoff * 2 * self.n_players
                else:
                    estimated_last_stock = current_payoff * self.n_players
                if history.my_actions[-2]:
                    estimated_prev_stock = previous_payoff * 2 * self.n_players
                else:
                    estimated_prev_stock = previous_payoff * self.n_players
                stock_grew = estimated_last_stock > estimated_prev_stock
            if cooperation_rate >= 0.6 and stock_grew:
                return Action.C
        return Action.D

class Strategy_AGGRESSIVE_17(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES) - Treats the common pool as a resource 
    to be maximally exploited while maintaining just enough sustainability. Aggressively 
    opportunistic, punishes cooperative players, and adapts quickly to opponent behavior patterns.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = state.round_number
        current_stock = state.current_stock
        if current_stock >= 0.7 * self.capacity:
            return Action.D
        if current_stock <= 0.15 * self.capacity:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D if current_stock > 0.1 * self.capacity else Action.C
        if current_round == self.n_rounds - 2:
            return Action.D if current_stock >= 0.2 * self.capacity else Action.C
        recent_rounds = min(3, history.round_number)
        if recent_rounds > 0:
            start_idx = max(0, history.round_number - recent_rounds)
            recent_opponent_actions = history.opponent_actions[start_idx:, :]
            total_actions = recent_opponent_actions.size
            cooperation_count = np.sum(recent_opponent_actions)
            opponent_coop_rate = cooperation_count / total_actions if total_actions > 0 else 0
        else:
            opponent_coop_rate = 0
        if opponent_coop_rate > 0.6:
            return Action.D
        if opponent_coop_rate < 0.3:
            return Action.C
        if history.round_number >= 2:
            last_round_actions = history.opponent_actions[-1, :]
            last_cooperation_rate = np.mean(last_round_actions)
            if last_cooperation_rate > 0.5:
                return Action.D
        if history.round_number >= 3:
            for player_idx in range(self.n_players - 1):
                recent_actions = history.opponent_actions[-3:, player_idx]
                if np.all(recent_actions == recent_actions[0]):
                    return Action.D
        if history.round_number >= 2:
            last_two_rounds = history.opponent_actions[-2:, :]
            if np.sum(last_two_rounds) == 0:
                return Action.D if random.random() < 0.7 else Action.C
        if history.round_number >= 2:
            prev_coop_rate = np.mean(history.opponent_actions[-2, :])
            current_coop_rate = np.mean(history.opponent_actions[-1, :]) if history.round_number >= 1 else 0
            if current_coop_rate > prev_coop_rate + 0.2:
                return Action.D
        if self.n_players > 6:
            cooperation_threshold = 0.2 * self.capacity
            if current_stock <= cooperation_threshold:
                return Action.C
        if self.n_rounds <= 5:
            if current_round <= 1 or current_round == self.n_rounds - 1:
                return Action.D
            if current_stock < 0.2 * self.capacity:
                return Action.C
        return Action.D

class Strategy_AGGRESSIVE_18(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy - Maximizes individual payoffs through 
    calculated exploitation, adaptive retaliation, and opportunistic cooperation only 
    when it serves long-term dominance.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round <= 2:
            return Action.D
        if current_round >= self.r - 1:
            if current_round == self.r:
                return Action.D
            elif state.current_stock > self.n / 2:
                return Action.D
            else:
                return Action.C
        sdr = (self.capacity - state.current_stock) / self.capacity
        last_round_defections = np.sum(~history.opponent_actions[-1, :])
        majority_defected_last_round = last_round_defections > (self.n - 1) / 2
        if history.round_number >= 2:
            recent_defections = np.sum(~history.opponent_actions[-2:, :])
            dm = recent_defections / (2 * (self.n - 1))
        else:
            recent_defections = np.sum(~history.opponent_actions[-1, :])
            dm = recent_defections / (self.n - 1)
        if sdr > 0.7:
            if majority_defected_last_round and state.current_stock > self.n:
                return Action.C
            else:
                return Action.D
        elif sdr > 0.4:
            my_cumulative_payoff = np.sum(history.my_payoffs)
            avg_opponent_payoff = np.mean(np.sum(history.opponent_payoffs, axis=0))
            if my_cumulative_payoff < avg_opponent_payoff * 1.2:
                return Action.D
            else:
                return Action.C
        elif dm > 0.6:
            return Action.D
        elif dm < 0.3:
            return Action.D
        else:
            if history.round_number >= 2:
                stock_increase_indicator = state.current_stock > self.capacity * 0.75
                if stock_increase_indicator:
                    return Action.D
            my_cumulative_payoff = np.sum(history.my_payoffs)
            max_opponent_payoff = np.max(np.sum(history.opponent_payoffs, axis=0))
            if my_cumulative_payoff < max_opponent_payoff * 0.9:
                return Action.D if random.random() < 0.8 else Action.C
            return Action.D

class Strategy_AGGRESSIVE_19(BaseStrategy):
    """
    Aggressive Opportunistic "Predator" Strategy.
    
    Maximizes immediate gains through aggressive exploitation while maintaining
    the resource base only when absolutely necessary. Uses dynamic phase classification
    and opportunistic adaptation to maximize individual payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        stock = state.current_stock
        if history is None:
            if stock > self.capacity * 0.8:
                return Action.D
            else:
                return Action.C
        if current_round >= self.r - 2:
            return Action.D
        if stock < self.n:
            return Action.C
        if stock >= self.capacity * 0.6:
            return Action.D
        recent_rounds = min(3, len(history.my_actions))
        if recent_rounds > 0:
            start_idx = max(0, len(history.my_actions) - recent_rounds)
            recent_opponent_actions = history.opponent_actions[start_idx:, :]
            total_recent_actions = recent_opponent_actions.size
            recent_cooperations = np.sum(recent_opponent_actions)
            cooperation_rate_last_3_rounds = recent_cooperations / total_recent_actions if total_recent_actions > 0 else 0.5
            my_recent_actions = history.my_actions[start_idx:]
            my_recent_cooperation_rate = np.mean(my_recent_actions) if len(my_recent_actions) > 0 else 0.5
            defection_count_last_3_rounds = total_recent_actions - recent_cooperations
            if cooperation_rate_last_3_rounds < 0.4 or my_recent_cooperation_rate > 0.6:
                return Action.D
            cooperation_pressure = min(1.0, defection_count_last_3_rounds / (3 * self.n))
            defection_probability = 0.3 + 0.5 * cooperation_pressure
            if random.random() < defection_probability:
                return Action.D
            else:
                return Action.C
        elif random.random() < 0.6:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_20(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES)
    
    Operates on intelligent aggression: maximize immediate gains while maintaining 
    resource sustainability. Uses stock thresholds and opponent behavior tracking
    to calibrate aggression levels dynamically.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.collapse_threshold = self.n_players
        self.exploitation_threshold = self.capacity * 0.4
        self.abundance_threshold = self.capacity * 0.7
        self.punishment_rounds = [0] * (self.n_players - 1)
        self.previous_opponent_actions = [None] * (self.n_players - 1)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = state.round_number
        stock = state.current_stock
        if current_round == self.n_rounds - 1:
            return Action.D
        if stock < self.collapse_threshold:
            return Action.C
        if current_round >= self.n_rounds - 2:
            return Action.D
        self._update_punishment_tracking(history)
        if any((rounds > 0 for rounds in self.punishment_rounds)):
            self._decrement_punishment_counters()
            return Action.D
        if len(history.opponent_actions) > 0:
            aggressive_last_round = np.sum(history.opponent_actions[-1, :] == 0)
        else:
            aggressive_last_round = 0
        exploitable_opponents = self._count_exploitable_opponents(history)
        if stock >= self.abundance_threshold and exploitable_opponents >= self.n_players // 2:
            return Action.D
        if aggressive_last_round >= self.n_players // 2:
            return Action.C
        else:
            return Action.D

    def _update_punishment_tracking(self, history: PlayerHistory):
        """Update punishment tracking for opponents who switched from cooperation to defection."""
        if len(history.opponent_actions) < 2:
            return
        current_actions = history.opponent_actions[-1, :]
        previous_actions = history.opponent_actions[-2, :]
        for i in range(len(current_actions)):
            if previous_actions[i] == 1 and current_actions[i] == 0:
                self.punishment_rounds[i] = 2
            self.previous_opponent_actions[i] = current_actions[i]

    def _decrement_punishment_counters(self):
        """Decrement punishment counters."""
        for i in range(len(self.punishment_rounds)):
            if self.punishment_rounds[i] > 0:
                self.punishment_rounds[i] -= 1

    def _count_exploitable_opponents(self, history: PlayerHistory) -> int:
        """Count opponents with cooperation rate > 0.67 in last 3 rounds."""
        if len(history.opponent_actions) == 0:
            return 0
        lookback = min(3, len(history.opponent_actions))
        recent_actions = history.opponent_actions[-lookback:, :]
        exploitable_count = 0
        for player_idx in range(recent_actions.shape[1]):
            cooperation_rate = np.mean(recent_actions[:, player_idx])
            if cooperation_rate > 0.67:
                exploitable_count += 1
        return exploitable_count

class Strategy_AGGRESSIVE_21(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES)
    
    Operates on intelligent aggression: maximize immediate gains while maintaining 
    resource base. Uses front-loaded defection, adaptive thresholds, and endgame 
    maximization to outperform both cooperative and competitive opponents.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number
        current_stock = state.current_stock
        phase1_end = self.n_rounds // 3
        phase2_end = 2 * self.n_rounds // 3
        death_spiral_threshold = self.capacity / 8
        caution_threshold = self.capacity / 4
        exploitation_threshold = self.capacity / 2
        preservation_threshold = self.capacity / 6
        final_threshold = self.capacity / 10
        recent_rounds = min(3, current_round)
        if recent_rounds > 0:
            recent_opponent_actions = history.opponent_actions[-recent_rounds:, :]
            opponent_defection_rate = 1.0 - np.mean(recent_opponent_actions)
        else:
            opponent_defection_rate = 0.0
        last_payoff = history.my_payoffs[-1] if current_round > 0 else 0
        if current_round <= phase1_end:
            if current_stock < caution_threshold:
                return Action.C
            else:
                return Action.D
        elif current_round > phase2_end:
            if current_round > self.n_rounds - 3:
                return Action.D
            elif current_stock < preservation_threshold:
                return Action.C
            else:
                return Action.D
        elif current_stock < death_spiral_threshold:
            return Action.C
        elif opponent_defection_rate > 0.7:
            return Action.D
        elif current_stock > exploitation_threshold and last_payoff > self.capacity / (4 * self.n_players):
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_22(BaseStrategy):
    """
    Adaptive Aggressive Exploitation Strategy (AAES)
    
    Operates on aggressive opportunism - maximize immediate gains while maintaining 
    the resource base only when absolutely necessary for future exploitation.
    Uses dynamic aggression scaling, opponent exploitation tracking, and strategic
    punishment protocols.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.betrayal_count = 0
        self.base_aggression = 0.7

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round > self.n_rounds - self.n_players:
            return Action.D
        stock_ratio = current_stock / self.capacity
        if stock_ratio <= 0.3:
            return Action.D
        if current_stock < self.n_players * 0.5:
            return Action.D
        recent_rounds = min(3, history.round_number)
        if recent_rounds > 0:
            recent_opponent_actions = history.opponent_actions[-recent_rounds:, :]
            recent_coop_rates = np.mean(recent_opponent_actions, axis=0)
            exploitation_opportunity = np.mean(recent_coop_rates)
            if exploitation_opportunity > 0.6:
                return Action.D
            elif exploitation_opportunity < 0.2:
                pass
        if stock_ratio < 0.15 and current_round < self.n_rounds * 0.7:
            if history.round_number > 0:
                last_round_cooperators = np.sum(history.opponent_actions[-1, :])
                if last_round_cooperators > self.n_players / 2:
                    return Action.C
                else:
                    return Action.D
        if history.round_number > 0 and history.my_actions[-1]:
            last_round_defectors = np.sum(~history.opponent_actions[-1, :])
            if last_round_defectors > 0:
                self.betrayal_count += 1
                return Action.D
        if history.round_number >= 2:
            if history.my_actions[-2] and np.any(~history.opponent_actions[-2, :]) and (not history.my_actions[-1]):
                return Action.D
        if history.round_number >= 2:
            last_two_rounds = history.opponent_actions[-2:, :]
            if np.all(last_two_rounds):
                if random.random() < 0.8:
                    return Action.D
                else:
                    return Action.C
        if stock_ratio > 0.95:
            abundance_rounds = 0
            for i in range(min(2, history.round_number)):
                past_stock_ratio = history.my_payoffs[-(i + 1)] * (2 * self.n_players) / self.capacity
                if past_stock_ratio > 0.95:
                    abundance_rounds += 1
            if abundance_rounds >= 2:
                if random.random() < 0.7:
                    return Action.D
        round_multiplier = current_round / self.n_rounds * 0.2
        if history.round_number > 0:
            avg_opponent_cooperation = np.mean(history.opponent_actions)
            opponent_weakness_bonus = (avg_opponent_cooperation - 0.5) * 0.3
        else:
            opponent_weakness_bonus = 0
        aggression_level = self.base_aggression + round_multiplier + opponent_weakness_bonus
        aggression_level += self.betrayal_count * 0.15
        if stock_ratio < 0.8:
            aggression_level += 0.2
        if stock_ratio > 0.9 and random.random() < 0.1:
            return Action.C
        if random.random() < aggression_level:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_23(BaseStrategy):
    """
    Aggressive Opportunistic Strategy: "Predator"
    
    This strategy maximizes individual payoffs through aggressive resource extraction
    while maintaining sustainability for continued exploitation. It exploits cooperative
    opponents and punishes betrayal while adapting to game phases and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_rounds_remaining = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        stock = state.current_stock
        if current_round > r - 2:
            return Action.D
        aggression_threshold = capacity * (0.3 + 0.4 * (r - current_round) / r)
        if stock > aggression_threshold:
            return Action.D
        if self.punishment_rounds_remaining > 0:
            self.punishment_rounds_remaining -= 1
            return Action.D
        if self._should_trigger_punishment(history):
            self.punishment_rounds_remaining = 1
            return Action.D
        if self._any_highly_cooperative_opponent(history):
            return Action.D
        critical_level = n * 2
        if stock <= critical_level:
            return Action.C
        if self._majority_cooperating(history) and stock > capacity * 0.2:
            return Action.C
        return Action.D

    def _should_trigger_punishment(self, history: PlayerHistory) -> bool:
        """Check if we should trigger punishment based on last round's betrayal."""
        if history.round_number == 0:
            return False
        last_my_action = history.my_actions[-1]
        last_opponent_actions = history.opponent_actions[-1, :]
        if last_my_action:
            defectors = sum((1 for action in last_opponent_actions if not action))
            if defectors > len(last_opponent_actions) / 2:
                return True
        return False

    def _any_highly_cooperative_opponent(self, history: PlayerHistory) -> bool:
        """Check if any opponent has cooperation rate > 0.6 in recent rounds."""
        lookback_rounds = min(5, history.round_number)
        if lookback_rounds == 0:
            return False
        start_round = max(0, history.round_number - lookback_rounds)
        for opponent_idx in range(self.game_description.n_players - 1):
            recent_actions = history.opponent_actions[start_round:, opponent_idx]
            cooperation_rate = np.mean(recent_actions)
            if cooperation_rate > 0.6:
                return True
        return False

    def _majority_cooperating(self, history: PlayerHistory) -> bool:
        """Check if majority of opponents cooperated in the last round."""
        if history.round_number == 0:
            return False
        last_opponent_actions = history.opponent_actions[-1, :]
        cooperators = sum(last_opponent_actions)
        return cooperators > len(last_opponent_actions) / 2

class Strategy_AGGRESSIVE_24(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES) - A ruthlessly opportunistic strategy 
    that maximizes personal payoff through strategic defection while maintaining just enough 
    cooperation to prevent complete resource collapse when necessary.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.phase1_end = max(1, int(0.2 * self.n_rounds))
        self.phase3_start = int(0.8 * self.n_rounds)
        self.cooperation_streak = 0
        self.defection_streak = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = state.round_number
        stock = state.current_stock
        if stock < self.capacity / 6:
            return Action.C
        if current_round <= self.phase1_end:
            if stock < self.capacity / 4:
                return Action.C
            return Action.D
        if current_round >= self.phase3_start:
            if current_round == self.n_rounds - 1:
                return Action.D
            if stock < self.capacity / 10:
                recent_coop_rate = self._get_recent_cooperation_rate(history, 2)
                if recent_coop_rate > 0.7:
                    return Action.C
            return Action.D
        return self._adaptive_exploitation_decision(state, history)

    def _adaptive_exploitation_decision(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        stock = state.current_stock
        remaining_rounds = self.n_rounds - state.round_number
        if stock > 3 * self.capacity / 4:
            return Action.D
        exploitation_threshold = stock / (2 * remaining_rounds * self.n_players)
        if exploitation_threshold > stock / (4 * self.n_players):
            if stock < self.capacity / 3:
                return Action.C
            defector_ratio = self._get_recent_defection_rate(history, 3)
            if defector_ratio > 0.6:
                return Action.D
            if self._should_exploit_cooperators(history):
                return Action.D
            if stock > self.capacity / 2 and random.random() < 0.1:
                return Action.C
            return Action.D
        if stock < self.capacity / 3:
            return Action.C
        if self._should_break_pattern():
            return Action.C if self.defection_streak > 4 else Action.D
        return Action.C

    def _get_recent_cooperation_rate(self, history: PlayerHistory, rounds: int) -> float:
        """Get cooperation rate of opponents in recent rounds"""
        if history.round_number == 0:
            return 0.0
        start_round = max(0, history.round_number - rounds)
        recent_actions = history.opponent_actions[start_round:history.round_number, :]
        if recent_actions.size == 0:
            return 0.0
        return np.mean(recent_actions)

    def _get_recent_defection_rate(self, history: PlayerHistory, rounds: int) -> float:
        """Get defection rate of opponents in recent rounds"""
        return 1.0 - self._get_recent_cooperation_rate(history, rounds)

    def _should_exploit_cooperators(self, history: PlayerHistory) -> bool:
        """Check if should exploit based on recent performance"""
        if history.round_number < 3:
            return True
        recent_my_payoffs = history.my_payoffs[-3:]
        recent_opponent_payoffs = history.opponent_payoffs[-3:, :]
        my_avg = np.mean(recent_my_payoffs)
        recent_opponent_actions = history.opponent_actions[-3:, :]
        cooperator_mask = recent_opponent_actions > 0.5
        if not np.any(cooperator_mask):
            return True
        cooperator_payoffs = recent_opponent_payoffs[cooperator_mask]
        if len(cooperator_payoffs) == 0:
            return True
        avg_cooperator_payoff = np.mean(cooperator_payoffs)
        return my_avg < avg_cooperator_payoff * 1.2

    def _should_break_pattern(self) -> bool:
        """Determine if should break current action pattern"""
        if len(self.game_description.__dict__) > 0:
            return self.cooperation_streak > 4 or self.defection_streak > 4
        return False

class Strategy_AGGRESSIVE_25(BaseStrategy):
    """
    Aggressive Adaptive Resource Exploitation Strategy (AARES)
    
    Prioritizes immediate gains while maintaining long-term viability through calculated aggression.
    Operates on "exploit first, adapt second" principle - maximizing extraction when advantageous
    while preserving enough resources to continue exploiting.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.early_phase_end = math.floor(self.n_rounds / 3)
        self.middle_phase_end = math.floor(2 * self.n_rounds / 3)
        self.recovery_mode = False
        self.low_stock_count = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_num = history.round_number
        current_stock = state.current_stock
        if current_stock < self.n_players:
            return Action.D
        if current_stock < self.n_players / 2:
            self.low_stock_count += 1
        else:
            self.low_stock_count = 0
        if self.low_stock_count >= 3:
            self.recovery_mode = True
        if self.recovery_mode and current_stock > self.n_players:
            self.recovery_mode = False
        if self.recovery_mode:
            return Action.C
        if round_num <= self.early_phase_end:
            return self._early_phase_decision(history, current_stock)
        elif round_num <= self.middle_phase_end:
            return self._middle_phase_decision(history, current_stock)
        else:
            return self._end_phase_decision(history, current_stock, round_num)

    def _early_phase_decision(self, history: PlayerHistory, current_stock: float) -> Action:
        """Early Phase: Exploration & Exploitation"""
        if history.round_number == 1:
            prev_cooperators = sum(history.opponent_actions[-1, :])
            cooperation_rate = prev_cooperators / self.n_players
            if cooperation_rate >= 0.5:
                return Action.D
            else:
                return Action.C
        else:
            if len(history.opponent_actions) > 0:
                prev_cooperators = sum(history.opponent_actions[-1, :])
                cooperation_rate = prev_cooperators / self.n_players
                if cooperation_rate >= 0.5:
                    return Action.D
                else:
                    return Action.C
            return Action.D

    def _middle_phase_decision(self, history: PlayerHistory, current_stock: float) -> Action:
        """Middle Phase: Adaptive Pressure"""
        if len(history.opponent_actions) >= 3:
            recent_coop_rates = []
            for i in range(-3, 0):
                cooperators = sum(history.opponent_actions[i, :])
                recent_coop_rates.append(cooperators / self.n_players)
            trend_increasing = recent_coop_rates[-1] > recent_coop_rates[0]
            if trend_increasing:
                return Action.D
            elif not trend_increasing and current_stock < self.capacity / 2:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _end_phase_decision(self, history: PlayerHistory, current_stock: float, round_num: int) -> Action:
        """End Phase: Maximum Extraction"""
        remaining_rounds = self.n_rounds - round_num
        if remaining_rounds == 0:
            return Action.D
        if current_stock * remaining_rounds > self.n_players * (remaining_rounds + 1):
            return Action.D
        if len(history.opponent_actions) >= 2:
            recent_payoffs = history.my_payoffs[-2:]
            if len(recent_payoffs) >= 2:
                decline_rate = (recent_payoffs[-2] - recent_payoffs[-1]) / recent_payoffs[-2] if recent_payoffs[-2] > 0 else 0
                if decline_rate > 0.2:
                    return Action.C
        return Action.D

    def _check_mass_defection_recovery(self, history: PlayerHistory) -> bool:
        """Check if we should cooperate after mass defection for stock recovery"""
        if len(history.opponent_actions) == 0:
            return False
        last_round_cooperators = sum(history.opponent_actions[-1, :])
        cooperation_rate = last_round_cooperators / self.n_players
        return cooperation_rate < 0.25

class Strategy_AGGRESSIVE_26(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy: Maximizes personal gain through aggressive 
    resource extraction while maintaining calculated sustainability. Defaults to defection 
    and exploits cooperative opponents while adapting to competitive environments.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.base_aggression_threshold = 0.6
        self.opponent_classifications = ['unknown'] * (self.n - 1)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number
        rounds_remaining = self.r - current_round - 1
        stock = state.current_stock
        self._update_opponent_classifications(history)
        if rounds_remaining == 0:
            return Action.D
        if rounds_remaining <= 1:
            if stock < self.capacity / 10 and self._all_opponents_cooperated_last_round(history):
                return Action.C
            return Action.D
        estimated_cooperators = self._estimate_cooperators_this_round(history)
        if estimated_cooperators >= self.n / 2 and stock > self.capacity / 3:
            return Action.D
        if stock >= 0.8 * self.capacity:
            return Action.D
        opponent_defection_rate = self._get_opponent_defection_rate_last_3_rounds(history)
        if opponent_defection_rate > 0.6:
            return Action.D
        projected_defectors = self._project_defectors_this_round(history)
        if projected_defectors >= self.n / 2:
            return Action.D
        if self._should_accelerate_extraction(history, stock):
            if random.random() < 0.8:
                return Action.D
        aggression_threshold = self._calculate_dynamic_aggression_threshold(history)
        if random.random() < aggression_threshold:
            return Action.D
        if stock <= self.n and rounds_remaining >= 3 and self._all_opponents_cooperated_last_round(history):
            return Action.C
        if stock < self.capacity / 4 and rounds_remaining > 3 and self._majority_cooperated_last_round(history) and self._personal_payoff_above_average(history):
            return Action.C
        return Action.D

    def _update_opponent_classifications(self, history):
        """Update opponent classifications based on recent behavior"""
        if history.round_number == 1:
            for i in range(self.n - 1):
                if history.opponent_actions[0, i]:
                    self.opponent_classifications[i] = 'E'
                else:
                    self.opponent_classifications[i] = 'R'
        else:
            for i in range(self.n - 1):
                recent_coop_rate = np.mean(history.opponent_actions[-3:, i]) if history.round_number >= 3 else np.mean(history.opponent_actions[:, i])
                if recent_coop_rate > 0.6:
                    self.opponent_classifications[i] = 'E'
                else:
                    self.opponent_classifications[i] = 'R'

    def _estimate_cooperators_this_round(self, history):
        """Estimate how many opponents will cooperate this round"""
        if history.round_number == 0:
            return 0
        cooperators = 0
        for i in range(self.n - 1):
            if history.round_number >= 3:
                recent_coop_rate = np.mean(history.opponent_actions[-3:, i])
            else:
                recent_coop_rate = np.mean(history.opponent_actions[:, i])
            if recent_coop_rate > 0.5:
                cooperators += 1
        return cooperators

    def _get_opponent_defection_rate_last_3_rounds(self, history):
        """Calculate opponent defection rate over last 3 rounds"""
        if history.round_number < 3:
            return np.mean(1 - history.opponent_actions)
        else:
            return np.mean(1 - history.opponent_actions[-3:])

    def _project_defectors_this_round(self, history):
        """Project how many opponents will defect this round"""
        if history.round_number == 0:
            return self.n - 1
        defectors = 0
        for i in range(self.n - 1):
            recent_defection_rate = 1 - np.mean(history.opponent_actions[-2:, i]) if history.round_number >= 2 else 1 - np.mean(history.opponent_actions[:, i])
            if recent_defection_rate > 0.5:
                defectors += 1
        return defectors

    def _should_accelerate_extraction(self, history, stock):
        """Check if we should accelerate resource extraction"""
        if history.round_number < 2:
            return False
        recent_stocks = [stock]
        return stock > 0.6 * self.capacity

    def _calculate_dynamic_aggression_threshold(self, history):
        """Calculate dynamic aggression threshold based on performance"""
        base_threshold = self.base_aggression_threshold
        if history.round_number < 2:
            return base_threshold
        my_avg_payoff = np.mean(history.my_payoffs)
        opponent_avg_payoffs = np.mean(history.opponent_payoffs, axis=0)
        median_opponent_payoff = np.median(opponent_avg_payoffs)
        if my_avg_payoff <= median_opponent_payoff:
            return min(0.9, base_threshold + 0.2)
        else:
            return max(0.3, base_threshold - 0.1)

    def _all_opponents_cooperated_last_round(self, history):
        """Check if all opponents cooperated in the last round"""
        if history.round_number == 0:
            return False
        return np.all(history.opponent_actions[-1, :])

    def _majority_cooperated_last_round(self, history):
        """Check if majority of opponents cooperated in last round"""
        if history.round_number == 0:
            return False
        return np.sum(history.opponent_actions[-1, :]) > (self.n - 1) / 2

    def _personal_payoff_above_average(self, history):
        """Check if personal payoff is above average opponent payoff"""
        if history.round_number == 0:
            return True
        my_total = np.sum(history.my_payoffs)
        opponent_totals = np.sum(history.opponent_payoffs, axis=0)
        avg_opponent_total = np.mean(opponent_totals)
        return my_total > avg_opponent_total

class Strategy_AGGRESSIVE_27(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy: A smart predator that maximizes immediate gains
    while maintaining resource sustainability through dynamic opponent modeling and adaptive responses.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.opponent_cooperate_counts = np.zeros(self.n_players - 1)
        self.opponent_total_rounds = 0
        self.in_recovery_mode = False
        self.recovery_counter = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number
        current_stock = state.current_stock
        self._update_opponent_classifications(history)
        if self._handle_recovery_mode(current_stock):
            return Action.C
        if current_stock < self.capacity * 0.4:
            return Action.C
        rounds_remaining = self.n_rounds - current_round
        if rounds_remaining == 1:
            return Action.D
        if rounds_remaining <= self.n_rounds * 0.2:
            discount_factor = rounds_remaining / (self.n_rounds * 0.2)
            if current_stock > self.capacity * 0.3 * discount_factor:
                return Action.D
            else:
                return Action.C
        if self._should_retaliate(history, current_stock):
            return Action.D
        return self._apply_exploitation_logic(history, current_stock)

    def _update_opponent_classifications(self, history: PlayerHistory):
        """Update opponent cooperation counts for classification."""
        self.opponent_total_rounds = history.round_number
        for i in range(self.n_players - 1):
            self.opponent_cooperate_counts[i] = np.sum(history.opponent_actions[:, i])

    def _classify_opponents(self):
        """Classify opponents based on cooperation rates."""
        if self.opponent_total_rounds == 0:
            return (0, 0, 0)
        cooperators = 0
        defectors = 0
        conditionals = 0
        for i in range(self.n_players - 1):
            coop_rate = self.opponent_cooperate_counts[i] / self.opponent_total_rounds
            if coop_rate >= 0.7:
                cooperators += 1
            elif coop_rate <= 0.3:
                defectors += 1
            else:
                conditionals += 1
        return (cooperators, defectors, conditionals)

    def _handle_recovery_mode(self, current_stock):
        """Handle stock crisis recovery protocol."""
        if current_stock < self.capacity * 0.2:
            if not self.in_recovery_mode:
                self.in_recovery_mode = True
                self.recovery_counter = 0
            if self.recovery_counter < 3:
                self.recovery_counter += 1
                return True
            else:
                self.in_recovery_mode = False
                return False
        else:
            self.in_recovery_mode = False
            self.recovery_counter = 0
            return False

    def _should_retaliate(self, history: PlayerHistory, current_stock):
        """Check if retaliation is warranted based on recent history."""
        if current_stock <= self.capacity * 0.3:
            return False
        if history.round_number < 2:
            return False
        my_recent_actions = history.my_actions[-2:]
        opponent_recent_actions = history.opponent_actions[-2:, :]
        for round_offset in range(min(2, history.round_number)):
            round_idx = -(round_offset + 1)
            if my_recent_actions[round_idx]:
                defecting_opponents = np.sum(~opponent_recent_actions[round_idx, :])
                if defecting_opponents > 0 and random.random() < 0.8:
                    return True
        return False

    def _apply_exploitation_logic(self, history: PlayerHistory, current_stock):
        """Apply the main exploitation decision logic."""
        cooperators, defectors, conditionals = self._classify_opponents()
        exploitation_score = cooperators * 2 + conditionals * 1
        exploitation_threshold = (self.n_players - 1) * 0.6
        if exploitation_score >= exploitation_threshold:
            return Action.D
        else:
            return self._adaptive_response(history, current_stock, cooperators)

    def _adaptive_response(self, history: PlayerHistory, current_stock, cooperators):
        """Apply adaptive response logic."""
        if history.round_number > 0:
            last_round_defectors = np.sum(~history.opponent_actions[-1, :])
        else:
            last_round_defectors = 0
        if last_round_defectors > self.n_players / 2:
            return Action.D
        elif current_stock > self.capacity * 0.8 and cooperators > 0:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_28(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES)
    
    Maximizes individual payoff through calculated aggression while maintaining
    tactical flexibility to avoid complete resource collapse when it serves our interests.
    Prioritizes exploitation over cooperation, viewing other players as competitors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_stock_threshold = self.capacity / (4 * self.n)
        self.danger_stock_threshold = self.capacity / (8 * self.n)
        self.early_phase_end = self.r // 3
        self.middle_phase_end = 2 * self.r // 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round <= self.early_phase_end:
            return self._early_phase_decision(current_stock, history)
        elif current_round <= self.middle_phase_end:
            return self._middle_phase_decision(current_stock, history)
        else:
            return self._end_game_decision(current_stock, history)

    def _early_phase_decision(self, current_stock: float, history: PlayerHistory) -> Action:
        """Early rounds: Exploration and establishment phase"""
        if current_stock > self.critical_stock_threshold:
            return Action.D
        else:
            return Action.C

    def _middle_phase_decision(self, current_stock: float, history: PlayerHistory) -> Action:
        """Middle rounds: Exploitation phase"""
        opponent_defection_rate = self._get_recent_opponent_defection_rate(history, 3)
        if opponent_defection_rate > 0.6:
            return Action.D
        elif current_stock > self.critical_stock_threshold and self._am_behind_expected_payoff(history):
            return Action.D
        else:
            return Action.C

    def _end_game_decision(self, current_stock: float, history: PlayerHistory) -> Action:
        """End game: Terminal extraction phase"""
        current_round = history.round_number + 1
        remaining_rounds = self.r - current_round + 1
        if remaining_rounds <= 2:
            return Action.D
        elif current_stock > self.danger_stock_threshold:
            return Action.D
        else:
            return Action.C

    def _get_recent_opponent_defection_rate(self, history: PlayerHistory, num_rounds: int) -> float:
        """Calculate opponent defection rate over the last num_rounds"""
        if len(history.opponent_actions) == 0:
            return 0.0
        start_idx = max(0, len(history.opponent_actions) - num_rounds)
        recent_actions = history.opponent_actions[start_idx:]
        if len(recent_actions) == 0:
            return 0.0
        total_actions = recent_actions.size
        total_cooperations = np.sum(recent_actions)
        total_defections = total_actions - total_cooperations
        return total_defections / total_actions if total_actions > 0 else 0.0

    def _am_behind_expected_payoff(self, history: PlayerHistory) -> bool:
        """Check if we're significantly behind expected cumulative payoffs"""
        if len(history.my_payoffs) == 0:
            return False
        my_cumulative_payoff = np.sum(history.my_payoffs)
        rounds_played = len(history.my_payoffs)
        expected_avg_per_round = self.capacity / (2 * self.n)
        expected_max_payoff = expected_avg_per_round * rounds_played * 1.5
        return my_cumulative_payoff < expected_max_payoff * 0.8

    def _estimate_next_round_stock(self, current_stock: float, history: PlayerHistory) -> float:
        """Estimate stock level after next round based on recent behavior"""
        if len(history.opponent_actions) == 0:
            estimated_cooperators = self.n / 2
        else:
            recent_coop_rate = self._get_recent_opponent_cooperation_rate(history, 2)
            estimated_cooperators = recent_coop_rate * (self.n - 1)
        my_consumption = current_stock / self.n
        opponent_consumption = estimated_cooperators * (current_stock / (2 * self.n)) + (self.n - 1 - estimated_cooperators) * (current_stock / self.n)
        total_consumption = my_consumption + opponent_consumption
        stock_after_consumption = max(0, current_stock - total_consumption)
        growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
        new_stock = min(stock_after_consumption + growth, self.capacity)
        return new_stock

    def _get_recent_opponent_cooperation_rate(self, history: PlayerHistory, num_rounds: int) -> float:
        """Calculate opponent cooperation rate over the last num_rounds"""
        if len(history.opponent_actions) == 0:
            return 0.5
        start_idx = max(0, len(history.opponent_actions) - num_rounds)
        recent_actions = history.opponent_actions[start_idx:]
        if len(recent_actions) == 0:
            return 0.5
        total_actions = recent_actions.size
        total_cooperations = np.sum(recent_actions)
        return total_cooperations / total_actions if total_actions > 0 else 0.5

class Strategy_AGGRESSIVE_29(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES)
    
    Operates on aggressive opportunism with calculated sustainability.
    Seeks to maximize individual payoffs by exploiting cooperative opponents
    while maintaining just enough resource sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.early_phase_end = min(3, self.n_rounds // 3)
        self.endgame_start = max(self.n_rounds - max(3, self.n_rounds // 4), 0)
        self.base_defect_threshold = self.capacity * 0.3
        self.critical_threshold = self.capacity / 4
        self.emergency_threshold = self.capacity / 10

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if history is None:
            return Action.D
        cooperators_last_round = 0
        defectors_last_round = 0
        if history.round_number > 0:
            cooperators_last_round = int(np.sum(history.opponent_actions[-1, :]))
            defectors_last_round = self.n_players - 1 - cooperators_last_round
        my_avg_payoff = np.mean(history.my_payoffs) if len(history.my_payoffs) > 0 else 0
        opponent_payoffs_flat = history.opponent_payoffs.flatten()
        avg_opponent_payoff = np.mean(opponent_payoffs_flat) if len(opponent_payoffs_flat) > 0 else 0
        if current_stock < self.emergency_threshold:
            return Action.C
        if current_round < self.early_phase_end:
            if current_stock < self.critical_threshold:
                return Action.C
            return Action.D
        if current_round >= self.endgame_start:
            rounds_remaining = self.n_rounds - current_round
            if rounds_remaining <= 1:
                return Action.D
            if rounds_remaining == 2 and current_stock < self.capacity / 6:
                return Action.C
            endgame_threshold = self.capacity * (0.2 + 0.1 * rounds_remaining)
            if current_stock >= endgame_threshold:
                return Action.D
            else:
                return Action.C
        opponents_mostly_cooperative = False
        opponents_mostly_defecting = False
        if history.round_number >= 3:
            recent_rounds = min(3, history.round_number)
            recent_coop_rate = np.mean(history.opponent_actions[-recent_rounds:, :])
            if recent_coop_rate > 0.6:
                opponents_mostly_cooperative = True
            elif recent_coop_rate < 0.4:
                opponents_mostly_defecting = True
        defect_threshold = self.base_defect_threshold
        if opponents_mostly_cooperative:
            defect_threshold *= 0.7
        elif opponents_mostly_defecting:
            defect_threshold *= 1.3
        if my_avg_payoff < avg_opponent_payoff * 0.9 and avg_opponent_payoff > 0:
            defect_threshold *= 0.8
        if current_stock >= self.capacity * 0.6:
            return Action.D
        if current_stock >= defect_threshold:
            if cooperators_last_round > defectors_last_round:
                return Action.D
            if my_avg_payoff < avg_opponent_payoff * 1.1 and avg_opponent_payoff > 0:
                return Action.D
            return Action.C
        return Action.C

class Strategy_AGGRESSIVE_30(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES) - maximizes immediate gains through
    opportunistic exploitation while maintaining just enough restraint to keep resource viable.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_rounds_remaining = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        stock = state.current_stock
        round_num = history.round_number + 1
        critical_stock = capacity * 0.3
        emergency_stock = capacity * 0.15
        early_end = math.floor(r / 3)
        middle_end = math.floor(2 * r / 3)
        if stock <= emergency_stock:
            return Action.C
        opponent_defection_rate = self._calculate_opponent_defection_rate(history)
        if self.punishment_rounds_remaining > 0:
            self.punishment_rounds_remaining -= 1
            return Action.D
        if round_num <= early_end:
            return self._early_phase_logic(round_num, stock, critical_stock, opponent_defection_rate)
        elif round_num <= middle_end:
            return self._middle_phase_logic(round_num, stock, critical_stock, opponent_defection_rate, history, r)
        else:
            return self._end_phase_logic(round_num, stock, critical_stock, r, capacity)

    def _calculate_opponent_defection_rate(self, history: PlayerHistory) -> float:
        """Calculate the rate at which opponents have defected."""
        if history.round_number == 0:
            return 0.0
        total_opponent_actions = history.opponent_actions.size
        total_defections = np.sum(~history.opponent_actions)
        if total_opponent_actions == 0:
            return 0.0
        return total_defections / total_opponent_actions

    def _early_phase_logic(self, round_num: int, stock: float, critical_stock: float, opponent_defection_rate: float) -> Action:
        """Logic for early phase rounds."""
        if stock <= critical_stock:
            return Action.C
        if opponent_defection_rate >= 0.6:
            return Action.D
        return Action.D if random.random() < 0.8 else Action.C

    def _middle_phase_logic(self, round_num: int, stock: float, critical_stock: float, opponent_defection_rate: float, history: PlayerHistory, r: int) -> Action:
        """Logic for middle phase rounds."""
        if self._should_punish(history):
            self.punishment_rounds_remaining = 3
            return Action.D
        if stock <= critical_stock:
            return Action.C
        if opponent_defection_rate <= 0.3:
            return Action.D
        if self._recent_opponent_cooperation(history):
            return Action.D
        return Action.D if random.random() < 0.9 else Action.C

    def _end_phase_logic(self, round_num: int, stock: float, critical_stock: float, r: int, capacity: float) -> Action:
        """Logic for end phase rounds."""
        if round_num > r - 2:
            return Action.D
        if stock <= capacity * 0.15:
            return Action.C
        return Action.D

    def _should_punish(self, history: PlayerHistory) -> bool:
        """Check if any opponent switched from C to D in last 2 rounds."""
        if history.round_number < 2:
            return False
        for round_idx in range(max(0, history.round_number - 2), history.round_number):
            if round_idx == 0:
                continue
            prev_round = round_idx - 1
            curr_round = round_idx
            for opponent_idx in range(history.opponent_actions.shape[1]):
                if history.opponent_actions[prev_round, opponent_idx] and (not history.opponent_actions[curr_round, opponent_idx]):
                    return True
        return False

    def _recent_opponent_cooperation(self, history: PlayerHistory) -> bool:
        """Check if opponents have been very cooperative in last 3 rounds."""
        if history.round_number < 3:
            return False
        recent_rounds = min(3, history.round_number)
        start_idx = max(0, history.round_number - recent_rounds)
        recent_actions = history.opponent_actions[start_idx:, :]
        cooperation_rate = np.mean(recent_actions)
        return cooperation_rate >= 0.75

class Strategy_AGGRESSIVE_31(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy - maximizes personal payoffs through 
    aggressive resource extraction while maintaining strategic sustainability to prevent 
    complete resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.early_phase_end = self.n_rounds // 3
        self.middle_phase_end = 2 * self.n_rounds // 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = state.round_number
        current_stock = state.current_stock
        if current_stock < self.n_players * 1.5 and current_round < self.n_rounds - 2:
            return Action.C
        if current_stock < self.n_players:
            return Action.C
        if current_round <= self.early_phase_end:
            return self._early_phase_decision(current_stock)
        elif current_round <= self.middle_phase_end:
            return self._middle_phase_decision(history, current_stock, current_round)
        else:
            return self._end_phase_decision(history, current_stock, current_round)

    def _early_phase_decision(self, current_stock):
        """Early phase: Aggressive positioning with collapse prevention"""
        if current_stock < self.capacity * 0.3:
            return Action.C
        else:
            return Action.D

    def _middle_phase_decision(self, history, current_stock, current_round):
        """Middle phase: Adaptive exploitation based on opponent patterns"""
        rounds_to_check = min(3, len(history.opponent_actions))
        if rounds_to_check == 0:
            cooperation_rate = 0.5
        else:
            recent_actions = history.opponent_actions[-rounds_to_check:, :]
            total_actions = recent_actions.size
            cooperations = np.sum(recent_actions)
            cooperation_rate = cooperations / total_actions if total_actions > 0 else 0.5
        if cooperation_rate > 0.6:
            return Action.D
        elif cooperation_rate < 0.3:
            if current_stock > self.capacity * 0.4:
                return Action.D
            else:
                return Action.C
        elif current_round % 3 == 0:
            return Action.C
        else:
            return Action.D

    def _end_phase_decision(self, history, current_stock, current_round):
        """End phase: Maximum extraction with calculated sustainability"""
        if current_round == self.n_rounds - 1:
            return Action.D
        elif current_stock < self.n_players * 2:
            return Action.C
        else:
            future_defectors = self._estimate_defectors_next_round(history)
            defect_consumption = current_stock / self.n_players
            coop_consumption = current_stock / (2 * self.n_players)
            estimated_total_consumption = future_defectors * defect_consumption + (self.n_players - future_defectors - 1) * coop_consumption + defect_consumption
            if current_stock > estimated_total_consumption:
                return Action.D
            else:
                return Action.C

    def _estimate_defectors_next_round(self, history):
        """Estimate how many opponents will defect next round based on recent behavior"""
        if len(history.opponent_actions) == 0:
            return self.n_players // 2
        last_round_defectors = np.sum(history.opponent_actions[-1, :] == False)
        if len(history.opponent_actions) >= 2:
            prev_round_defectors = np.sum(history.opponent_actions[-2, :] == False)
            trend = last_round_defectors - prev_round_defectors
            estimated = last_round_defectors + trend
            return max(0, min(self.n_players - 1, estimated))
        return last_round_defectors

class Strategy_AGGRESSIVE_32(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES) - maximizes individual payoffs 
    through strategic aggression while preventing resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        current_stock = state.current_stock
        rounds_remaining = self.n_rounds - current_round
        resource_health = current_stock / self.capacity
        if current_round <= 3:
            if current_round == 2:
                if resource_health < 0.5:
                    return Action.C
                else:
                    prev_defections = np.sum(history.opponent_actions[-1, :] == False)
                    defection_rate = prev_defections / (self.n_players - 1)
                    return Action.D if defection_rate >= 0.6 else Action.C
            elif current_round == 3:
                if resource_health < 0.5:
                    return Action.C
                else:
                    prev_defections = np.sum(history.opponent_actions[-1, :] == False)
                    defection_rate = prev_defections / (self.n_players - 1)
                    return Action.D if defection_rate >= 0.6 else Action.C
        if rounds_remaining <= 1:
            if rounds_remaining == 1:
                return Action.D if resource_health > 0.4 else Action.C
            else:
                return Action.D
        total_opponent_defections = np.sum(history.opponent_actions == False)
        total_possible_opponent_defections = history.round_number * (self.n_players - 1)
        opponent_aggression_rate = total_opponent_defections / total_possible_opponent_defections if total_possible_opponent_defections > 0 else 0
        if resource_health < 0.3:
            return Action.C
        if resource_health < 0.1:
            return Action.C
        if resource_health > 0.8 and opponent_aggression_rate < 0.4:
            return Action.D
        if opponent_aggression_rate > 0.6:
            return Action.D if rounds_remaining > 3 else Action.C
        recent_rounds = min(2, history.round_number)
        if recent_rounds > 0:
            recent_defections = np.sum(history.opponent_actions[-recent_rounds:, :] == False)
            recent_possible = recent_rounds * (self.n_players - 1)
            recent_defection_rate = recent_defections / recent_possible if recent_possible > 0 else 0
            if recent_defection_rate > 0.5:
                return Action.D
        if history.round_number > 0:
            last_round_cooperators = np.sum(history.opponent_actions[-1, :] == True)
            if last_round_cooperators == self.n_players - 1 and resource_health > 0.5:
                return Action.D
        cooperation_probability = 1 - opponent_aggression_rate
        cooperation_probability = max(0.3, cooperation_probability)
        return Action.C if random.random() < cooperation_probability else Action.D

class Strategy_AGGRESSIVE_33(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES): Maximizes immediate gains while 
    strategically managing the resource through aggressive opportunism and dynamic 
    opponent profiling.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.opponent_profiles = ['unknown'] * (self.n - 1)
        self.scorched_earth_rounds = 0
        self.forced_cooperation_rounds = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = state.round_number
        stock = state.current_stock
        rounds_remaining = self.r - current_round
        if self.forced_cooperation_rounds > 0:
            self.forced_cooperation_rounds -= 1
            return Action.C
        if self.scorched_earth_rounds > 0:
            self.scorched_earth_rounds -= 1
            return Action.D
        self._update_opponent_profiles(history)
        if stock < self.capacity * 0.1 and rounds_remaining > 3:
            self.forced_cooperation_rounds = 1
            return Action.C
        if rounds_remaining == 0:
            return Action.D
        if rounds_remaining <= 3:
            return self._endgame_strategy(state, history)
        return self._exploitation_strategy(state, history)

    def _exploitation_strategy(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        stock = state.current_stock
        if stock > self.capacity * 0.7:
            return Action.D
        elif stock < self.capacity * 0.3:
            return Action.C
        else:
            return self._adaptive_response(state, history)

    def _adaptive_response(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        stock = state.current_stock
        last_round_actions = history.opponent_actions[-1, :]
        defection_rate = 1 - np.mean(last_round_actions)
        my_avg_payoff = np.mean(history.my_payoffs)
        opponent_avg_payoff = np.mean(history.opponent_payoffs)
        my_advantage = my_avg_payoff - opponent_avg_payoff
        stock_trend = 0
        if len(history.my_payoffs) >= 3:
            recent_total_payoffs = []
            for i in range(min(3, len(history.my_payoffs))):
                round_idx = -(i + 1)
                my_payoff = history.my_payoffs[round_idx]
                opponent_payoffs = history.opponent_payoffs[round_idx, :]
                total_round_payoff = my_payoff + np.sum(opponent_payoffs)
                recent_total_payoffs.append(total_round_payoff)
            if len(recent_total_payoffs) >= 2:
                stock_trend = recent_total_payoffs[0] - recent_total_payoffs[-1]
        if defection_rate > 0.6:
            return Action.D
        elif defection_rate < 0.3 and my_advantage > 0:
            return Action.D
        elif stock_trend < 0 and my_advantage < -2:
            return Action.C
        else:
            return Action.D

    def _endgame_strategy(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        stock = state.current_stock
        if stock > self.capacity * 0.4:
            return Action.D
        elif stock > self.capacity * 0.2:
            last_round_actions = history.opponent_actions[-1, :]
            if np.all(last_round_actions):
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

    def _update_opponent_profiles(self, history: PlayerHistory):
        if len(history.opponent_actions) < 3:
            return
        for i in range(self.n - 1):
            actions = history.opponent_actions[:, i]
            coop_rate = np.mean(actions)
            if coop_rate > 0.7:
                self.opponent_profiles[i] = 'cooperator'
            elif coop_rate < 0.3:
                self.opponent_profiles[i] = 'defector'
            else:
                self.opponent_profiles[i] = 'adaptive'
        if len(history.my_payoffs) >= 3:
            my_recent_avg = np.mean(history.my_payoffs[-3:])
            opponent_recent_avg = np.mean(history.opponent_payoffs[-3:, :])
            if my_recent_avg < opponent_recent_avg * 0.7:
                self.scorched_earth_rounds = 2

    def _get_majority_profile(self):
        cooperator_count = sum((1 for p in self.opponent_profiles if p == 'cooperator'))
        defector_count = sum((1 for p in self.opponent_profiles if p == 'defector'))
        if cooperator_count > defector_count:
            return 'cooperator'
        elif defector_count > cooperator_count:
            return 'defector'
        else:
            return 'mixed'

class Strategy_AGGRESSIVE_34(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES) - Maximizes personal payoffs through 
    calculated aggression, exploiting cooperative opponents while preventing total resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.force_cooperate_remaining = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = state.round_number + 1
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if self.force_cooperate_remaining > 0:
            self.force_cooperate_remaining -= 1
            return Action.C
        if current_stock < capacity * 0.15:
            self.force_cooperate_remaining = max(0, n_rounds - current_round)
            return Action.C
        if current_round == 2:
            return Action.D
        if current_round == n_rounds:
            return Action.D
        if current_stock < capacity * 0.2:
            self.force_cooperate_remaining = 2
            return Action.C
        total_actions = history.opponent_actions.size
        total_cooperators = np.sum(history.opponent_actions)
        coop_ratio = total_cooperators / total_actions if total_actions > 0 else 0
        if current_round == n_rounds - 1:
            if current_stock > capacity * 0.5:
                return Action.D
            return Action.D if coop_ratio > 0.4 else Action.C
        if coop_ratio > 0.6:
            return Action.D
        elif coop_ratio <= 0.3:
            return Action.C
        if current_stock < capacity * 0.4:
            return Action.C
        if len(history.opponent_actions) > 0:
            last_round_defectors = np.sum(history.opponent_actions[-1, :] == 0)
            all_defected = last_round_defectors == self.game_description.n_players - 1
            if all_defected and current_stock < capacity * 0.3:
                return Action.C
            elif all_defected:
                return Action.D
        if coop_ratio > 0.85 and current_stock > capacity * 0.6:
            return Action.D
        if len(history.opponent_actions) > 0:
            last_round_defection_rate = np.sum(history.opponent_actions[-1, :] == 0) / (self.game_description.n_players - 1)
            if last_round_defection_rate >= 0.5:
                return Action.D
        if len(history.opponent_actions) >= 2:
            recent_defection_rate = np.sum(history.opponent_actions[-1, :] == 0) / (self.game_description.n_players - 1)
            prev_defection_rate = np.sum(history.opponent_actions[-2, :] == 0) / (self.game_description.n_players - 1)
            rate_change = recent_defection_rate - prev_defection_rate
            if abs(rate_change) > 0.25:
                return Action.D
        game_progress = current_round / n_rounds
        if game_progress < 1 / 3:
            return Action.D if coop_ratio > 0.4 else Action.C
        elif game_progress > 2 / 3:
            return Action.D if coop_ratio > 0.35 else Action.C
        else:
            return Action.D if coop_ratio > 0.5 else Action.C

class Strategy_AGGRESSIVE_35(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy - maximizes individual payoffs by aggressively 
    exploiting cooperative opponents while protecting against exploitation through opponent 
    classification and adaptive decision-making.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_num = history.round_number + 1
        stock = state.current_stock
        if round_num >= self.n_rounds - 2:
            return Action.D
        if round_num <= 2:
            return Action.D
        high_threshold = self.capacity * 0.7
        medium_threshold = self.capacity * 0.3
        low_threshold = self.capacity * 0.2
        cooperator_count = 0
        retaliator_count = 0
        exploiter_count = 0
        for player in range(self.n_players - 1):
            if len(history.opponent_actions) >= 2:
                round1_action = history.opponent_actions[0, player]
                round2_action = history.opponent_actions[1, player]
                if round1_action and round2_action:
                    cooperator_count += 1
                elif round1_action and (not round2_action):
                    retaliator_count += 1
                elif not round1_action and (not round2_action):
                    exploiter_count += 1
        total_opponents = self.n_players - 1
        cooperator_ratio = cooperator_count / total_opponents if total_opponents > 0 else 0
        retaliator_ratio = retaliator_count / total_opponents if total_opponents > 0 else 0
        recent_rounds = min(3, len(history.opponent_actions))
        if recent_rounds > 0:
            recent_coop_sum = 0
            recent_total = 0
            for i in range(recent_rounds):
                round_idx = len(history.opponent_actions) - 1 - i
                if round_idx >= 0:
                    recent_coop_sum += np.sum(history.opponent_actions[round_idx, :])
                    recent_total += total_opponents
            recent_coop_rate = recent_coop_sum / recent_total if recent_total > 0 else 0
            if recent_coop_rate > 0.5:
                return Action.D
        if len(history.my_actions) >= 2:
            last_round_defections = np.sum(~history.opponent_actions[-1, :]) + (0 if history.my_actions[-1] else 1)
            expected_heavy_depletion = last_round_defections > total_opponents / 2
            if not expected_heavy_depletion and stock > medium_threshold:
                return Action.D
        if stock > high_threshold:
            if cooperator_ratio >= 0.5:
                return Action.D
            if retaliator_ratio >= 0.5 and round_num % 3 != 0:
                return Action.D
            if exploiter_count >= cooperator_count + retaliator_count:
                return Action.D
        elif stock >= medium_threshold:
            if cooperator_ratio >= 0.6:
                return Action.D
            if retaliator_ratio >= 0.5 and round_num % 2 == 0:
                return Action.D
            if exploiter_count >= cooperator_count + retaliator_count:
                return Action.C
        else:
            if stock < low_threshold:
                return Action.C
            if len(history.opponent_actions) > 0:
                last_round_coop_rate = np.mean(history.opponent_actions[-1, :])
                if last_round_coop_rate >= 0.7:
                    return Action.D
        return Action.C

class Strategy_AGGRESSIVE_36(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES)
    
    Maximizes individual payoffs through aggressive resource extraction while maintaining
    adaptive cooperation to prevent complete resource collapse. Uses opponent classification,
    stock health monitoring, and strategic punishment/forgiveness mechanisms.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.opponent_classifications = ['unknown'] * (self.n_players - 1)
        self.punishment_counters = [0] * (self.n_players - 1)
        self.emergency_mode = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = state.round_number
        current_stock = state.current_stock
        stock_health = current_stock / self.capacity
        if current_round < 3:
            if current_round == 2 and stock_health < 0.25:
                return Action.C
            return Action.D
        self._update_opponent_classifications(history)
        if current_round >= self.n_rounds - 2:
            if current_round == self.n_rounds - 1:
                return Action.D
            else:
                if stock_health < 1.0 / 6.0:
                    return Action.C
                return Action.D
        return self._adaptive_exploitation_decision(state, history, stock_health)

    def _adaptive_exploitation_decision(self, state, history, stock_health):
        current_stock = state.current_stock
        if stock_health < 0.1:
            self.emergency_mode = True
            return Action.C
        elif stock_health > 0.25:
            self.emergency_mode = False
        if self.emergency_mode:
            recent_cooperations = sum(history.my_actions[-2:]) if len(history.my_actions) >= 2 else 0
            if recent_cooperations < 2:
                return Action.C
            else:
                self.emergency_mode = False
        if len(history.opponent_actions) > 0:
            cooperation_ratio = np.mean(history.opponent_actions[-1, :])
        else:
            cooperation_ratio = 0.5
        defection_threshold = max(0.3, min(0.8, stock_health))
        if self._should_punish(history, stock_health):
            return Action.D
        if stock_health >= defection_threshold:
            return Action.D
        elif cooperation_ratio >= 0.5:
            if cooperation_ratio >= 0.75:
                return Action.D
            return Action.D
        elif cooperation_ratio < 0.25:
            return Action.C
        elif stock_health < 1.0 / 3.0:
            return Action.C if random.random() < 0.4 else Action.D
        else:
            rounds_remaining = self.n_rounds - state.round_number
            late_game_factor = 0.2 if rounds_remaining <= self.n_rounds * 0.2 else 0
            defect_prob = 0.8 + late_game_factor
            recent_cooperations = 0
            if len(history.my_actions) >= 2:
                recent_cooperations = sum(history.my_actions[-2:])
            if recent_cooperations >= 2:
                return Action.D
            if stock_health > 0.8 and random.random() < 0.15:
                return Action.C
            return Action.D if random.random() < defect_prob else Action.C

    def _update_opponent_classifications(self, history):
        if len(history.opponent_actions) == 0:
            return
        for i in range(self.n_players - 1):
            if len(history.opponent_actions) < 3:
                continue
            coop_rate = np.mean(history.opponent_actions[:, i])
            if coop_rate > 0.7:
                self.opponent_classifications[i] = 'cooperator'
            elif coop_rate < 0.3:
                self.opponent_classifications[i] = 'aggressive'
            elif len(history.my_actions) >= 2:
                my_prev_actions = history.my_actions[:-1]
                opp_current_actions = history.opponent_actions[1:, i]
                if len(my_prev_actions) > 0 and len(opp_current_actions) > 0:
                    correlation = np.corrcoef(my_prev_actions.astype(float), opp_current_actions.astype(float))[0, 1]
                    if not np.isnan(correlation) and abs(correlation) > 0.5:
                        self.opponent_classifications[i] = 'reciprocator'
                    else:
                        self.opponent_classifications[i] = 'random'

    def _should_punish(self, history, stock_health):
        if len(history.opponent_actions) == 0:
            return False
        last_round_stock_critical = stock_health < 0.2
        for i in range(self.n_players - 1):
            if self.punishment_counters[i] > 0:
                self.punishment_counters[i] -= 1
                return True
            if len(history.opponent_actions) > 0 and (not history.opponent_actions[-1, i]) and last_round_stock_critical:
                self.punishment_counters[i] = 2
                return True
        return False

class Strategy_AGGRESSIVE_37(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Opportunistic Predator"
    
    This strategy operates on aggressive resource extraction while maintaining strategic sustainability.
    It exploits cooperative opponents while protecting against being exploited by other aggressive players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_cooperate_rounds = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if self.punishment_cooperate_rounds > 0:
            self.punishment_cooperate_rounds -= 1
            return Action.C
        if current_stock <= n_players * 2:
            return Action.C
        if current_round >= total_rounds - 1:
            return Action.D
        if current_round >= total_rounds - 2:
            if current_stock < capacity * 0.2:
                return Action.C
            else:
                return Action.D
        last_round_opponents = history.opponent_actions[-1, :]
        cooperators_last_round = sum(last_round_opponents)
        opponent_cooperation_rate = cooperators_last_round / (n_players - 1)
        if len(history.my_actions) >= 2:
            my_previous_action = history.my_actions[-1]
            if not my_previous_action and cooperators_last_round == 0 and (len(history.my_actions) >= 2):
                if len(history.my_actions) >= 2:
                    self.punishment_cooperate_rounds = 2
                    return Action.C
        stock_ratio = current_stock / capacity
        if stock_ratio < 0.3:
            return Action.C
        elif stock_ratio < 0.6:
            if opponent_cooperation_rate >= 0.5:
                return Action.D
            else:
                return Action.C
        elif opponent_cooperation_rate >= 0.7:
            return Action.D
        elif opponent_cooperation_rate >= 0.4:
            if len(history.my_actions) > 0:
                i_defected_last = not history.my_actions[-1]
                if i_defected_last and current_stock > capacity * 0.5:
                    return Action.D
                else:
                    return Action.D if random.random() < 0.7 else Action.C
            else:
                return Action.D
        elif stock_ratio > 0.8:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_38(BaseStrategy):
    """
    Opportunistic Predator: An aggressive common pool resource strategy that maximizes 
    immediate gains while strategically managing the resource for continued exploitation.
    Always defects in first round, exploits cooperative opponents, and only cooperates
    when necessary to prevent resource collapse that would hurt future extraction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.punishment_rounds = {}

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_num = history.round_number
        stock = state.current_stock
        if round_num >= self.n_rounds - 1:
            return Action.D
        if stock < self.capacity * 0.15:
            if self._more_than_half_opponents_cooperated_last_round(history):
                return Action.C
            else:
                return Action.D
        if stock > self.capacity * 0.7:
            return Action.D
        cooperation_ratio = self._get_cooperation_ratio_last_round(history)
        if cooperation_ratio > 0.6:
            return Action.D
        if cooperation_ratio < 0.3:
            if stock < self.capacity * 0.4:
                return Action.C
            else:
                return Action.D
        our_payoff = self._get_our_cumulative_payoff(history)
        avg_opponent_payoff = self._get_average_opponent_payoff(history)
        if our_payoff < avg_opponent_payoff * 0.9:
            return Action.D
        elif stock < self.capacity * 0.3:
            return Action.C
        else:
            if random.random() < 0.05 and stock > self.capacity * 0.4:
                return Action.C
            return Action.D

    def _more_than_half_opponents_cooperated_last_round(self, history: PlayerHistory) -> bool:
        if len(history.opponent_actions) == 0:
            return False
        last_round_actions = history.opponent_actions[-1, :]
        cooperators = sum(last_round_actions)
        return cooperators > len(last_round_actions) / 2

    def _get_cooperation_ratio_last_round(self, history: PlayerHistory) -> float:
        if len(history.opponent_actions) == 0:
            return 0.0
        last_round_actions = history.opponent_actions[-1, :]
        cooperators = sum(last_round_actions)
        return cooperators / len(last_round_actions)

    def _get_our_cumulative_payoff(self, history: PlayerHistory) -> float:
        return sum(history.my_payoffs)

    def _get_average_opponent_payoff(self, history: PlayerHistory) -> float:
        if len(history.opponent_payoffs) == 0:
            return 0.0
        total_opponent_payoffs = np.sum(history.opponent_payoffs)
        num_opponents = history.opponent_payoffs.shape[1]
        num_rounds = len(history.opponent_payoffs)
        return total_opponent_payoffs / (num_opponents * num_rounds)

class Strategy_AGGRESSIVE_39(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES) - Maximizes individual payoff through
    opportunistic aggression while maintaining resource viability for continued exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.forced_cooperate_rounds = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        if self.forced_cooperate_rounds > 0:
            self.forced_cooperate_rounds -= 1
            return Action.C
        current_round = state.round_number
        stock = state.current_stock
        capacity = self.game_description.capacity
        total_rounds = self.game_description.n_rounds
        if current_round >= total_rounds - 3:
            return self._endgame_strategy(stock, capacity, history)
        critical_threshold = capacity * 0.15
        if stock < critical_threshold:
            self.forced_cooperate_rounds = 1
            return Action.C
        if stock > capacity * 0.8:
            return Action.D
        opponent_coop_rate = self._calculate_recent_cooperation_rate(history)
        if self._should_retaliate(history, opponent_coop_rate):
            return Action.D
        stock_ratio = stock / capacity
        rounds_remaining_ratio = (total_rounds - current_round) / total_rounds
        exploitation_score = stock_ratio * opponent_coop_rate * rounds_remaining_ratio
        if exploitation_score > 0.4:
            return Action.D
        else:
            return Action.C

    def _endgame_strategy(self, stock, capacity, history):
        """Strategy for last 3 rounds"""
        current_round = history.round_number
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds - 1:
            return Action.D
        if stock > capacity * 0.3:
            return Action.D
        else:
            if len(history.opponent_actions) > 0:
                recent_cooperators = sum(history.opponent_actions[-1, :])
                total_opponents = len(history.opponent_actions[-1, :])
                if recent_cooperators >= total_opponents * 0.5:
                    return Action.D
            return Action.C

    def _calculate_recent_cooperation_rate(self, history):
        """Calculate average opponent cooperation rate over last 3 rounds"""
        if len(history.opponent_actions) == 0:
            return 0.5
        rounds_to_check = min(3, len(history.opponent_actions))
        recent_actions = history.opponent_actions[-rounds_to_check:]
        total_actions = recent_actions.size
        if total_actions == 0:
            return 0.5
        total_cooperations = np.sum(recent_actions)
        return total_cooperations / total_actions

    def _should_retaliate(self, history, current_coop_rate):
        """Check if we should retaliate against overly aggressive opponents"""
        if len(history.opponent_actions) < 2:
            return False
        if len(history.opponent_actions) >= 2:
            last_2_rounds = history.opponent_actions[-2:]
            total_actions = last_2_rounds.size
            if total_actions > 0:
                coop_rate_last_2 = np.sum(last_2_rounds) / total_actions
                if coop_rate_last_2 < 0.3 and current_coop_rate < 0.3:
                    return True
        return False

class Strategy_AGGRESSIVE_40(BaseStrategy):
    """
    Aggressive Adaptive Resource Extraction Strategy (AARES)
    
    Prioritizes immediate high payoffs while maintaining long-term viability through calculated aggression.
    Uses three phases: early aggression, adaptive exploitation, and endgame maximization.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.phase1_end = max(1, self.n_rounds // 3)
        self.phase2_end = max(2, 2 * self.n_rounds // 3)
        self.force_cooperate_rounds = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if self.force_cooperate_rounds > 0:
            self.force_cooperate_rounds -= 1
            return Action.C
        if history is None:
            return Action.D
        critical_threshold = max(self.capacity / 8, self.n_players)
        if current_stock < critical_threshold:
            self.force_cooperate_rounds = 2
            return Action.C
        if current_stock > 0.9 * self.capacity:
            return Action.D
        others_cooperation_rate = self._get_cooperation_rate(history)
        stock_trend = self._get_stock_trend(history, current_stock)
        rounds_remaining = self.n_rounds - current_round
        if current_round <= self.phase1_end:
            return self._phase1_decision(current_stock, others_cooperation_rate)
        elif current_round > self.phase2_end:
            return self._phase3_decision(current_stock, others_cooperation_rate, rounds_remaining)
        else:
            return self._phase2_decision(current_stock, others_cooperation_rate, stock_trend, history)

    def _get_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate recent cooperation rate of opponents"""
        if len(history.opponent_actions) == 0:
            return 0.5
        recent_rounds = min(5, len(history.opponent_actions))
        recent_actions = history.opponent_actions[-recent_rounds:, :]
        total_actions = recent_actions.size
        if total_actions == 0:
            return 0.5
        cooperations = np.sum(recent_actions)
        return cooperations / total_actions

    def _get_stock_trend(self, history: PlayerHistory, current_stock: float) -> float:
        """Calculate stock trend over last 3 rounds"""
        if len(history.my_payoffs) < 3:
            return 0
        recent_payoffs = history.my_payoffs[-3:]
        my_recent_actions = history.my_actions[-3:]
        estimated_stocks = []
        for i, (payoff, action) in enumerate(zip(recent_payoffs, my_recent_actions)):
            if action:
                estimated_stock = payoff * (2 * self.n_players)
            else:
                estimated_stock = payoff * self.n_players
            estimated_stocks.append(estimated_stock)
        if len(estimated_stocks) >= 2:
            return estimated_stocks[-1] - estimated_stocks[0]
        return 0

    def _phase1_decision(self, current_stock: float, others_cooperation_rate: float) -> Action:
        """Phase 1: Early Aggression"""
        critical_threshold = self.capacity / 4
        if current_stock < critical_threshold:
            return Action.C
        else:
            return Action.D

    def _phase2_decision(self, current_stock: float, others_cooperation_rate: float, stock_trend: float, history: PlayerHistory) -> Action:
        """Phase 2: Adaptive Exploitation"""
        if len(history.opponent_actions) >= 2:
            recent_coop = np.mean(history.opponent_actions[-2:, :])
            older_coop = np.mean(history.opponent_actions[-4:-2, :]) if len(history.opponent_actions) >= 4 else recent_coop
            if older_coop - recent_coop > 0.3:
                return Action.D
        if others_cooperation_rate > 0.6 and current_stock > self.capacity / 3:
            return Action.D
        elif others_cooperation_rate < 0.3 or current_stock < self.capacity / 4:
            return Action.C
        elif stock_trend > 0:
            return Action.D
        else:
            return Action.C

    def _phase3_decision(self, current_stock: float, others_cooperation_rate: float, rounds_remaining: int) -> Action:
        """Phase 3: Endgame Maximization"""
        if rounds_remaining <= 3:
            return Action.D
        if rounds_remaining <= 6 and current_stock > self.capacity / 6:
            return Action.D
        if current_stock > self.capacity / 2:
            return Action.D
        if others_cooperation_rate > 0.6:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_41(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES) - Maximizes resource extraction
    while maintaining strategic sustainability to outcompete opponents through
    adaptive behavior based on stock levels, opponent patterns, and game progression.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_stock = self.capacity * 0.3
        self.danger_stock = self.capacity * 0.15
        self.recovery_stock = self.capacity * 0.6
        self.opponent_classifications = {}
        self.punishment_targets = set()
        self.punishment_rounds_remaining = {}

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = state.round_number
        current_stock = state.current_stock
        rounds_remaining = self.n_rounds - current_round
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_round == self.n_rounds - 2:
            if current_stock < self.danger_stock:
                return Action.C
            else:
                return Action.D
        self._update_opponent_classifications(history)
        payoff_trend = self._calculate_payoff_trend(history)
        stock_velocity = self._calculate_stock_velocity(history, current_stock)
        if current_stock < self.danger_stock:
            return Action.C
        if current_stock < self.critical_stock:
            aggressive_ratio = self._get_aggressive_opponent_ratio()
            if aggressive_ratio > 0.5:
                return Action.D
            else:
                return Action.C
        if current_stock > self.recovery_stock:
            return Action.D
        last_round_defectors = self._count_last_round_defectors(history)
        if last_round_defectors > (self.n_players - 1) / 2:
            return Action.D
        elif payoff_trend < 0:
            return Action.D
        elif rounds_remaining / self.n_rounds > 0.3:
            return self._apply_adaptive_mechanisms(history, current_stock, rounds_remaining)
        else:
            endgame_factor = 1 - rounds_remaining / self.n_rounds * 5
            if random.random() < endgame_factor * 0.8:
                return Action.D
            else:
                return Action.C

    def _update_opponent_classifications(self, history):
        """Classify opponents based on their recent behavior (last 3 rounds)."""
        recent_rounds = min(3, history.round_number)
        if recent_rounds == 0:
            return
        start_round = max(0, history.round_number - recent_rounds)
        for opponent_idx in range(self.n_players - 1):
            recent_actions = history.opponent_actions[start_round:history.round_number, opponent_idx]
            defection_rate = 1 - np.mean(recent_actions)
            if defection_rate > 0.66:
                self.opponent_classifications[opponent_idx] = 'aggressive'
            elif defection_rate > 0.33:
                self.opponent_classifications[opponent_idx] = 'moderate'
            else:
                self.opponent_classifications[opponent_idx] = 'cooperative'

    def _get_aggressive_opponent_ratio(self):
        """Get ratio of aggressive opponents."""
        if not self.opponent_classifications:
            return 0.0
        aggressive_count = sum((1 for classification in self.opponent_classifications.values() if classification == 'aggressive'))
        return aggressive_count / len(self.opponent_classifications)

    def _calculate_payoff_trend(self, history):
        """Calculate payoff trend over last 3 rounds."""
        if history.round_number < 3:
            return 0
        recent_payoffs = history.my_payoffs[-3:]
        if len(recent_payoffs) < 2:
            return 0
        return recent_payoffs[-1] - recent_payoffs[0]

    def _calculate_stock_velocity(self, history, current_stock):
        """Calculate rate of stock depletion."""
        if history.round_number < 1:
            return 0
        last_round_actions = history.opponent_actions[-1, :] if history.round_number > 0 else np.array([])
        my_last_action = history.my_actions[-1] if history.round_number > 0 else True
        if len(last_round_actions) == 0:
            return 0
        cooperators = np.sum(last_round_actions) + (1 if my_last_action else 0)
        defectors = self.n_players - cooperators
        total_consumption_rate = (cooperators * 0.5 + defectors * 1.0) / self.n_players
        return min(total_consumption_rate, 1.0)

    def _count_last_round_defectors(self, history):
        """Count defectors in the last round."""
        if history.round_number == 0:
            return 0
        last_round_defectors = np.sum(~history.opponent_actions[-1, :])
        return last_round_defectors

    def _apply_adaptive_mechanisms(self, history, current_stock, rounds_remaining):
        """Apply advanced adaptive mechanisms for decision making."""
        stock_velocity = self._calculate_stock_velocity(history, current_stock)
        if stock_velocity > 0.4:
            cooperation_bonus = 0.3
        elif stock_velocity < 0.1:
            cooperation_bonus = -0.2
        else:
            cooperation_bonus = 0.0
        if history.round_number > 0:
            recent_cooperation_rate = np.mean(history.opponent_actions[-min(3, history.round_number):, :])
            if recent_cooperation_rate > 0.7:
                cooperation_bonus -= 0.4
        else:
            recent_cooperation_rate = 0.5
        base_cooperation_prob = 0.4
        final_cooperation_prob = max(0.1, min(0.9, base_cooperation_prob + cooperation_bonus))
        if random.random() < final_cooperation_prob:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_42(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy - maximizes immediate gains while maintaining 
    resource base only when necessary for future exploitation. Treats cooperation as a 
    calculated investment in future defection opportunities.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_minimum = self.capacity * 0.15
        self.high_stock_threshold = self.capacity * 0.6
        self.critical_stock_threshold = self.capacity * 0.05
        self.endgame_threshold = self.n_rounds * 0.8
        self.exploitation_window_end = self.n_rounds * 0.7

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = state.round_number
        current_stock = state.current_stock
        if current_stock < self.threshold_minimum:
            return Action.C
        if current_round > self.endgame_threshold:
            return Action.D
        if current_stock < self.critical_stock_threshold:
            return Action.C
        if current_stock > self.high_stock_threshold and current_round <= self.exploitation_window_end:
            return Action.D
        if history.round_number > 0:
            total_opponent_actions = history.opponent_actions.size
            total_cooperations = np.sum(history.opponent_actions)
            avg_opponent_cooperation = total_cooperations / total_opponent_actions if total_opponent_actions > 0 else 0
            if avg_opponent_cooperation > 0.5:
                return Action.D
            if history.round_number >= 3:
                recent_rounds = min(3, history.round_number)
                my_recent_payoffs = history.my_payoffs[-recent_rounds:]
                if len(my_recent_payoffs) >= 2:
                    recent_trend = my_recent_payoffs[-1] - my_recent_payoffs[0]
                    if recent_trend < -self.capacity * 0.05:
                        if avg_opponent_cooperation < 0.3:
                            return Action.C
                        else:
                            return Action.D
            if history.round_number >= 2:
                last_round_all_coop = np.all(history.opponent_actions[-1, :])
                if history.round_number >= 3:
                    second_last_round_all_coop = np.all(history.opponent_actions[-2, :])
                else:
                    second_last_round_all_coop = True
                my_last_action = history.my_actions[-1]
                if history.round_number >= 2:
                    my_second_last = history.my_actions[-2] if history.round_number >= 2 else True
                else:
                    my_second_last = True
                if last_round_all_coop and second_last_round_all_coop and my_last_action and my_second_last:
                    return Action.D
        if history.round_number > 0:
            my_defection_rate = np.sum(~history.my_actions) / len(history.my_actions)
            if my_defection_rate > 0.8:
                if len(history.my_payoffs) >= 2:
                    recent_payoff_decline = history.my_payoffs[-2] - history.my_payoffs[-1]
                    if recent_payoff_decline > self.capacity * 0.02:
                        return Action.C
        return Action.D

class Strategy_AGGRESSIVE_43(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES)
    
    Operates on intelligent aggression: maximize immediate gains while strategically 
    preserving the resource when it benefits long-term extraction. Defaults to 
    defection but adapts based on stock levels, opponent behavior, and rounds remaining.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold_critical = game_description.capacity * 0.15
        self.threshold_moderate = game_description.capacity * 0.4
        self.high_stock_threshold = game_description.capacity * 0.7

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = state.round_number
        stock = state.current_stock
        rounds_remaining = self.game_description.n_rounds - current_round
        if rounds_remaining == 0:
            return Action.D
        opponents_mostly_cooperating = self._analyze_opponents(history)
        if stock < self.threshold_critical:
            return Action.C
        elif stock < self.threshold_moderate:
            if opponents_mostly_cooperating and rounds_remaining > 2:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _analyze_opponents(self, history: PlayerHistory) -> bool:
        """
        Analyze opponent cooperation rate over recent history.
        Returns True if opponents are mostly cooperating (>60% cooperation rate).
        """
        if len(history.opponent_actions) == 0:
            return False
        total_opponent_actions = history.opponent_actions.size
        if total_opponent_actions == 0:
            return False
        total_cooperations = np.sum(history.opponent_actions)
        cooperation_rate = total_cooperations / total_opponent_actions
        return cooperation_rate > 0.6

class Strategy_AGGRESSIVE_44(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES)
    
    Operates on intelligent selfishness: maximize personal extraction while strategically 
    managing the resource to ensure continued exploitation opportunities. Uses phase-based
    decision making with opponent tracking and adaptive mechanisms.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.opponent_punishment = {}

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = state.round_number
        stock = state.current_stock
        if stock == 0:
            return Action.C
        if current_round >= self.n_rounds - 2:
            return Action.D
        phase = self._determine_phase(current_round)
        defection_rate = self._calculate_opponent_defection_rate(history, 3)
        stock_trend = self._calculate_stock_trend(history, 3)
        if self._should_punish(history, current_round):
            return Action.D
        if phase == 1:
            return self._early_phase_logic(current_round, stock)
        elif phase == 2:
            return self._middle_phase_logic(stock, defection_rate, stock_trend)
        else:
            return self._end_phase_logic(current_round, stock)

    def _determine_phase(self, current_round: int) -> int:
        """Determine which phase of the game we're in (1, 2, or 3)"""
        third = self.n_rounds // 3
        if current_round <= third:
            return 1
        elif current_round <= 2 * third:
            return 2
        else:
            return 3

    def _calculate_opponent_defection_rate(self, history: PlayerHistory, lookback: int) -> float:
        """Calculate the defection rate of opponents over the last 'lookback' rounds"""
        if history.round_number == 0:
            return 0.0
        start_round = max(0, history.round_number - lookback)
        recent_actions = history.opponent_actions[start_round:, :]
        total_actions = recent_actions.size
        if total_actions == 0:
            return 0.0
        defections = np.sum(~recent_actions)
        return defections / total_actions

    def _calculate_stock_trend(self, history: PlayerHistory, lookback: int) -> float:
        """Calculate stock trend over the last 'lookback' rounds"""
        if history.round_number < lookback:
            return 0.0
        recent_payoffs = history.my_payoffs[-lookback:]
        if len(recent_payoffs) < 2:
            return 0.0
        return (recent_payoffs[-1] - recent_payoffs[0]) / lookback

    def _should_punish(self, history: PlayerHistory, current_round: int) -> bool:
        """Check if we should punish any opponent for recent betrayals"""
        if history.round_number < 2:
            return False
        if history.my_actions[-1] == True and np.sum(~history.opponent_actions[-1, :]) > len(history.opponent_actions[-1, :]) / 2:
            return current_round <= history.round_number + 2
        return False

    def _early_phase_logic(self, current_round: int, stock: float) -> Action:
        """Phase 1: Early rounds (establish dominance and gather intelligence)"""
        if current_round == 1:
            return Action.D
        stock_ratio = stock / self.capacity
        if stock_ratio > 0.7:
            return Action.D
        elif stock_ratio > 0.4:
            return Action.D
        else:
            return Action.C

    def _middle_phase_logic(self, stock: float, defection_rate: float, stock_trend: float) -> Action:
        """Phase 2: Middle rounds (exploit opponent patterns while maintaining viability)"""
        if defection_rate > 0.6:
            return Action.D
        if defection_rate <= 0.3:
            if stock_trend >= 0:
                return Action.D
            else:
                return Action.C
        if stock > 0.5 * self.capacity:
            return Action.D
        else:
            return Action.C

    def _end_phase_logic(self, current_round: int, stock: float) -> Action:
        """Phase 3: End game (extract maximum value with calculated risks)"""
        threshold_high = self.capacity / self.n_players
        threshold_low = self.capacity / (2 * self.n_players)
        if stock > threshold_high:
            return Action.D
        if stock > threshold_low:
            remaining_rounds = self.n_rounds - current_round
            if remaining_rounds > self.n_rounds // 6:
                return Action.D
            else:
                return Action.C
        return Action.C

class Strategy_AGGRESSIVE_45(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES)
    
    Maximizes individual payoffs through strategic exploitation of cooperative opponents
    while maintaining emergency conservation protocols to preserve future extraction opportunities.
    Uses dynamic phase classification and opponent pattern recognition for optimal aggression timing.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.base_aggression = 0.8
        self.lookback_window = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        stock_ratio = state.current_stock / self.game_description.capacity
        rounds_remaining = self.game_description.n_rounds - state.round_number
        phase = self._classify_phase(stock_ratio, state.round_number, rounds_remaining)
        opponent_coop_rate = self._calculate_recent_cooperation_rate(history)
        return self._make_decision(phase, stock_ratio, rounds_remaining, opponent_coop_rate, history)

    def _classify_phase(self, stock_ratio: float, round_num: int, rounds_remaining: int) -> str:
        """Classify current game phase based on stock health and round position."""
        if rounds_remaining <= 3:
            return 'ENDGAME'
        elif stock_ratio < 0.3:
            return 'CRISIS'
        elif stock_ratio <= 0.7:
            return 'SCARCITY'
        else:
            return 'ABUNDANCE'

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate cooperation rate of opponents over recent rounds."""
        if history.round_number == 0:
            return 0.0
        lookback = min(self.lookback_window, history.round_number)
        recent_rounds = history.opponent_actions[-lookback:, :]
        total_actions = recent_rounds.size
        if total_actions == 0:
            return 0.0
        total_cooperations = np.sum(recent_rounds)
        return total_cooperations / total_actions

    def _stock_declining_rapidly(self, history: PlayerHistory) -> bool:
        """Check if stock is declining rapidly over recent rounds."""
        if history.round_number < 2:
            return False
        recent_payoffs = history.my_payoffs[-2:]
        if len(recent_payoffs) >= 2:
            decline_rate = (recent_payoffs[0] - recent_payoffs[1]) / recent_payoffs[0] if recent_payoffs[0] > 0 else 0
            return decline_rate > 0.3
        return False

    def _calculate_cooperation_exploitation_index(self, opponent_coop_rate: float, stock_ratio: float) -> float:
        """Calculate the Cooperation Exploitation Index."""
        stock_health_multiplier = max(0.5, stock_ratio)
        return opponent_coop_rate * stock_health_multiplier

    def _emergency_stock_check(self, state: CommonPoolState) -> bool:
        """Check if stock is at emergency levels requiring immediate conservation."""
        emergency_threshold = self.game_description.capacity * 0.15
        return state.current_stock <= emergency_threshold

    def _make_decision(self, phase: str, stock_ratio: float, rounds_remaining: int, opponent_coop_rate: float, history: PlayerHistory) -> Action:
        """Core decision logic based on phase and opponent behavior."""
        if self._emergency_stock_check(CommonPoolState(history.round_number, stock_ratio * self.game_description.capacity)):
            if rounds_remaining > 2:
                return Action.C
        if phase == 'ABUNDANCE':
            return Action.D
        elif phase == 'SCARCITY':
            cei = self._calculate_cooperation_exploitation_index(opponent_coop_rate, stock_ratio)
            if cei > 0.6 and stock_ratio > 0.4:
                return Action.D
            elif opponent_coop_rate > 0.5:
                return Action.D
            elif self._stock_declining_rapidly(history):
                return Action.C
            else:
                return Action.D
        elif phase == 'CRISIS':
            if rounds_remaining > self.game_description.n_rounds * 0.2:
                return Action.C
            else:
                return Action.D
        elif phase == 'ENDGAME':
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_46(BaseStrategy):
    """
    Aggressive Opportunistic Strategy: "Resource Predator"
    
    This strategy prioritizes aggressive early accumulation while maintaining 
    adaptive responses to opponent behavior and stock levels. It exploits 
    cooperative opponents, punishes aggressive ones, and preserves critical 
    stock levels only when necessary.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_num = history.round_number
        current_stock = state.current_stock
        if round_num <= 2 or current_stock >= self.capacity / 2:
            return Action.D
        if round_num == self.n_rounds - 1:
            return Action.D
        stock_very_low = current_stock < self.capacity / 6
        stock_low = current_stock < self.capacity / 3
        stock_high = current_stock > self.capacity * 0.8
        stock_medium_high = current_stock > self.capacity * 0.6
        if stock_high:
            return Action.D
        if stock_very_low:
            return Action.C
        if len(history.opponent_actions) > 0:
            last_round_opponents = history.opponent_actions[-1, :]
            opponents_cooperated_last = np.sum(last_round_opponents)
            total_opponents = len(last_round_opponents)
            cooperation_rate_last = opponents_cooperated_last / total_opponents if total_opponents > 0 else 0
            has_aggressive_opponent = False
            if len(history.opponent_actions) >= 3:
                for opponent_idx in range(total_opponents):
                    recent_actions = history.opponent_actions[-3:, opponent_idx]
                    if len(recent_actions) >= 3 and np.sum(recent_actions) == 0:
                        has_aggressive_opponent = True
                        break
            if cooperation_rate_last < 0.5 or has_aggressive_opponent or round_num >= self.n_rounds - 2:
                return Action.D
            if stock_medium_high and cooperation_rate_last > 0.8:
                return Action.D
            stock_depletion_rate = 0
            if len(history.opponent_actions) >= 2:
                rounds_to_check = min(2, len(history.opponent_actions))
                recent_defection_rate = 0
                for i in range(1, rounds_to_check + 1):
                    round_actions = history.opponent_actions[-i, :]
                    my_action = history.my_actions[-i]
                    round_defections = np.sum(round_actions == False) + (1 if not my_action else 0)
                    recent_defection_rate += round_defections
                stock_depletion_rate = recent_defection_rate / rounds_to_check
            if stock_low and (not stock_very_low) and (cooperation_rate_last >= 0.7) and (round_num < self.n_rounds - 2) and (stock_depletion_rate < self.capacity / 4 / self.n_players):
                return Action.C
        return Action.D

class Strategy_AGGRESSIVE_47(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES)
    
    Maximizes immediate gains while maintaining resource base only when necessary.
    Uses aggressive opening, opponent classification, and dynamic adaptation based
    on stock levels and opponent behavior patterns.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.opponent_coop_counts = np.zeros(self.n - 1)
        self.opponent_total_rounds = 0
        self.retaliation_rounds_left = 0
        self.last_cooperated = False

    def _get_stock_category(self, stock):
        """Categorize current stock level"""
        if stock < self.n:
            return 'CRITICAL'
        elif stock < 1.5 * self.n:
            return 'LOW'
        elif stock < self.capacity * 0.7:
            return 'MODERATE'
        else:
            return 'HIGH'

    def _classify_opponents(self, history):
        """Classify each opponent based on cooperation rate"""
        if self.opponent_total_rounds == 0:
            return []
        classifications = []
        for i in range(self.n - 1):
            coop_rate = self.opponent_coop_counts[i] / self.opponent_total_rounds
            if coop_rate > 0.7:
                classifications.append('EXPLOITABLE')
            elif coop_rate < 0.3:
                classifications.append('HOSTILE')
            elif abs(coop_rate - sum(history.my_actions) / len(history.my_actions)) < 0.2:
                classifications.append('RECIPROCAL')
            else:
                classifications.append('UNPREDICTABLE')
        return classifications

    def _update_opponent_tracking(self, history):
        """Update opponent cooperation tracking"""
        if len(history.my_actions) > 0:
            last_round = len(history.my_actions) - 1
            self.opponent_coop_counts += history.opponent_actions[last_round, :]
            self.opponent_total_rounds += 1

    def _check_retaliation(self, history):
        """Check if retaliation is needed based on last round"""
        if len(history.my_actions) > 0 and self.last_cooperated:
            last_round = len(history.my_actions) - 1
            if any(history.opponent_actions[last_round, :] == False):
                return True
        return False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        stock = state.current_stock
        if history is None:
            self.last_cooperated = False
            return Action.D
        self._update_opponent_tracking(history)
        if self._check_retaliation(history) and self._get_stock_category(stock) not in ['CRITICAL', 'LOW']:
            self.retaliation_rounds_left = 2
        if self.retaliation_rounds_left > 0:
            self.retaliation_rounds_left -= 1
            if self._get_stock_category(stock) != 'CRITICAL':
                self.last_cooperated = False
                return Action.D
        if current_round == self.r - 1:
            self.last_cooperated = False
            return Action.D
        if current_round == self.r - 2:
            if stock >= 1.5 * self.n:
                self.last_cooperated = False
                return Action.D
            else:
                self.last_cooperated = True
                return Action.C
        stock_category = self._get_stock_category(stock)
        remaining_rounds = self.r - current_round
        if stock_category == 'CRITICAL':
            self.last_cooperated = True
            return Action.C
        elif stock_category == 'LOW':
            if self.opponent_total_rounds > 0:
                avg_coop_rate = np.mean(self.opponent_coop_counts) / self.opponent_total_rounds
                if avg_coop_rate > 0.6 and remaining_rounds > 3:
                    self.last_cooperated = True
                    return Action.C
            self.last_cooperated = False
            return Action.D
        elif stock_category == 'MODERATE':
            classifications = self._classify_opponents(history)
            exploitable_count = classifications.count('EXPLOITABLE')
            if exploitable_count >= (self.n - 1) / 2:
                self.last_cooperated = False
                return Action.D
            if len(history.opponent_actions) > 0:
                last_round_coop_rate = np.mean(history.opponent_actions[-1, :])
                if last_round_coop_rate > 0.6:
                    self.last_cooperated = False
                    return Action.D
            if current_round >= 0.8 * self.r:
                if stock < 0.8 * self.n:
                    self.last_cooperated = True
                    return Action.C
                else:
                    self.last_cooperated = False
                    return Action.D
            if exploitable_count >= 2:
                if random.random() < 0.25:
                    self.last_cooperated = False
                    return Action.D
            if random.random() < 0.1:
                action = random.choice([Action.C, Action.D])
                self.last_cooperated = action == Action.C
                return action
            self.last_cooperated = True
            return Action.C
        else:
            self.last_cooperated = False
            return Action.D

class Strategy_AGGRESSIVE_48(BaseStrategy):
    """
    Predatory Harvester: An aggressive exploitation strategy that maximizes immediate gains
    while strategically timing cooperative phases to maintain resource viability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_num = state.round_number
        stock = state.current_stock
        if round_num > 0.8 * self.n_rounds:
            return Action.D
        if stock < self.capacity / 20 and round_num < 0.9 * self.n_rounds:
            return Action.C
        if round_num <= 3 or stock > 0.5 * self.capacity:
            return Action.D
        recent_coop_rate = self._calculate_recent_cooperation(history, 3)
        if recent_coop_rate > 0.75:
            return Action.D
        if stock <= self.capacity / 3:
            if recent_coop_rate < 0.25:
                return Action.C
            else:
                return Action.D
        return Action.D

    def _calculate_recent_cooperation(self, history: PlayerHistory, lookback_rounds: int) -> float:
        """Calculate the cooperation rate of opponents over the last N rounds."""
        if history.round_number == 0:
            return 0.0
        actual_lookback = min(lookback_rounds, history.round_number)
        recent_actions = history.opponent_actions[-actual_lookback:, :]
        total_actions = recent_actions.size
        if total_actions == 0:
            return 0.0
        cooperations = np.sum(recent_actions)
        return cooperations / total_actions

class Strategy_AGGRESSIVE_49(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES)
    
    Operates on aggressive resource extraction while maintaining strategic sustainability.
    Uses phase-based approach: early aggression, adaptive exploitation, and endgame extraction.
    Exploits cooperative opponents while competing against defectors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.crisis_mode = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = state.round_number
        current_stock = state.current_stock
        if current_stock < self.capacity / 10:
            self.crisis_mode = True
            return Action.C
        if self.crisis_mode and current_stock > self.capacity / 5:
            self.crisis_mode = False
        if current_round <= self.n_rounds / 3:
            if current_stock < self.capacity / 4:
                return Action.C
            return Action.D
        elif current_round <= 2 * self.n_rounds / 3:
            total_opponent_actions = np.sum(history.opponent_actions)
            total_possible_actions = len(history.opponent_actions) * self.n_players
            opponent_cooperation_rate = total_opponent_actions / total_possible_actions if total_possible_actions > 0 else 0
            lookback = min(3, len(history.my_payoffs))
            if lookback > 0:
                my_recent_avg = np.mean(history.my_payoffs[-lookback:])
                opponent_recent_avg = np.mean(history.opponent_payoffs[-lookback:])
                my_recent_advantage = my_recent_avg - opponent_recent_avg
            else:
                my_recent_advantage = 0
            if opponent_cooperation_rate > 0.6:
                return Action.D
            elif opponent_cooperation_rate < 0.3:
                if current_stock > self.capacity / 3:
                    return Action.D
                else:
                    return Action.C
            elif my_recent_advantage > 0:
                return Action.D
            elif current_stock > self.capacity / 2:
                return Action.D
            else:
                return Action.C
        else:
            rounds_remaining = self.n_rounds - current_round
            if rounds_remaining <= 2:
                return Action.D
            elif rounds_remaining <= self.n_rounds / 6:
                if current_stock < self.capacity / 6:
                    return Action.C
                else:
                    return Action.D
            else:
                stock_per_remaining_round = current_stock / rounds_remaining if rounds_remaining > 0 else current_stock
                sustainable_extraction = self.capacity / (4 * self.n_players)
                if stock_per_remaining_round > sustainable_extraction:
                    return Action.D
                else:
                    return Action.C

class Strategy_AGGRESSIVE_50(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES)
    
    Operates on aggressive opportunism - maximizing immediate gains while maintaining 
    the resource base only when necessary. Exploits cooperative opponents while 
    punishing defectors. Uses phase-based adaptation and stock monitoring.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.depletion_threshold = self.capacity * 0.3
        self.crisis_threshold = self.capacity * 0.15
        self.collapse_threshold = self.n
        self.early_phase_end = self.r // 3
        self.middle_phase_end = 2 * self.r // 3
        self.punishment_rounds_remaining = 0
        self.exploitation_mode = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number
        stock = state.current_stock
        rounds_remaining = self.r - current_round
        opponents_defect_rate = self._get_opponent_defect_rate(history)
        opponents_cooperation_rate = 1.0 - opponents_defect_rate
        if self._should_punish(history) and self.punishment_rounds_remaining == 0:
            self.punishment_rounds_remaining = 2
        if self.punishment_rounds_remaining > 0 and stock >= self.crisis_threshold:
            self.punishment_rounds_remaining -= 1
            return Action.D
        if self._should_exploit(history):
            self.exploitation_mode = True
        elif opponents_cooperation_rate < 0.5:
            self.exploitation_mode = False
        if self.exploitation_mode and stock > self.depletion_threshold:
            return Action.D
        if current_round <= self.early_phase_end:
            return self._early_phase_decision(stock, opponents_defect_rate, opponents_cooperation_rate, history)
        elif current_round <= self.middle_phase_end:
            return self._middle_phase_decision(stock, opponents_defect_rate, opponents_cooperation_rate, history)
        else:
            return self._endgame_decision(stock, rounds_remaining, opponents_defect_rate)

    def _early_phase_decision(self, stock, opponents_defect_rate, opponents_cooperation_rate, history):
        if stock > self.depletion_threshold:
            if opponents_cooperation_rate > 0.5:
                return Action.D
            elif stock > self.capacity * 0.6 and opponents_defect_rate > 0.5:
                return Action.D
            else:
                return Action.C
        elif stock > self.crisis_threshold:
            if opponents_defect_rate > 0.7:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C

    def _middle_phase_decision(self, stock, opponents_defect_rate, opponents_cooperation_rate, history):
        if stock > self.depletion_threshold:
            if opponents_cooperation_rate > 0.4:
                return Action.D
            elif self._am_i_winning(history):
                return Action.D
            else:
                return Action.C
        elif stock > self.crisis_threshold:
            if opponents_defect_rate > 0.8:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C

    def _endgame_decision(self, stock, rounds_remaining, opponents_defect_rate):
        if rounds_remaining > 3:
            if stock > self.crisis_threshold:
                return Action.D
            else:
                return Action.C
        elif rounds_remaining > 1:
            if stock > self.collapse_threshold:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

    def _get_opponent_defect_rate(self, history):
        if history.round_number == 0:
            return 0.0
        lookback = min(3, history.round_number)
        recent_actions = history.opponent_actions[-lookback:, :]
        total_actions = recent_actions.size
        defections = np.sum(recent_actions == False)
        return defections / total_actions if total_actions > 0 else 0.0

    def _should_punish(self, history):
        """Check if opponent defect rate increased significantly"""
        if history.round_number < 2:
            return False
        current_defect_rate = np.mean(history.opponent_actions[-1, :] == False)
        if history.round_number >= 2:
            previous_defect_rate = np.mean(history.opponent_actions[-2, :] == False)
            return current_defect_rate - previous_defect_rate > 0.2
        return False

    def _should_exploit(self, history):
        """Check if opponents suddenly became more cooperative"""
        if history.round_number < 2:
            return False
        current_coop_rate = np.mean(history.opponent_actions[-1, :] == True)
        if history.round_number >= 2:
            previous_coop_rate = np.mean(history.opponent_actions[-2, :] == True)
            return current_coop_rate - previous_coop_rate > 0.3
        return False

    def _am_i_winning(self, history):
        """Check if my recent performance is better than average opponent"""
        if history.round_number == 0:
            return False
        my_recent_payoff = history.my_payoffs[-1]
        avg_opponent_payoff = np.mean(history.opponent_payoffs[-1, :])
        return my_recent_payoff > avg_opponent_payoff

class Strategy_AGGRESSIVE_51(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES)
    
    Maximizes immediate gains while maintaining the resource base only when necessary.
    Uses aggressive opportunism with calculated restraint to preserve exploitation base.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.early_phase_end = math.floor(self.r / 3)
        self.middle_phase_end = math.floor(2 * self.r / 3)
        self.critical_stock = self.capacity * 0.3
        self.danger_stock = self.capacity * 0.15
        self.collapse_stock = self.capacity * 0.05

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = state.round_number + 1
        stock = state.current_stock
        recent_defection_rate = self._calculate_recent_defection_rate(history)
        high_aggression = recent_defection_rate > 0.6
        moderate_aggression = 0.3 <= recent_defection_rate <= 0.6
        if stock <= self.collapse_stock:
            return Action.C
        if current_round == self.r:
            return Action.D
        if current_round <= self.early_phase_end:
            return self._early_phase_decision(stock, high_aggression)
        elif current_round <= self.middle_phase_end:
            return self._middle_phase_decision(stock, recent_defection_rate)
        else:
            return self._endgame_phase_decision(stock, current_round, history)

    def _calculate_recent_defection_rate(self, history: PlayerHistory) -> float:
        """Calculate defection rate over last 3 rounds"""
        rounds_to_check = min(3, len(history.my_actions))
        if rounds_to_check == 0:
            return 0.0
        recent_actions = history.opponent_actions[-rounds_to_check:, :]
        total_actions = recent_actions.size
        defections = np.sum(recent_actions == False)
        return defections / total_actions if total_actions > 0 else 0.0

    def _early_phase_decision(self, stock: float, high_aggression: bool) -> Action:
        """Early phase decision logic"""
        if stock > self.critical_stock:
            return Action.D
        elif stock > self.danger_stock:
            if high_aggression:
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

    def _middle_phase_decision(self, stock: float, recent_defection_rate: float) -> Action:
        """Middle phase decision logic"""
        if stock > self.critical_stock:
            return Action.D
        elif recent_defection_rate < 0.4:
            return Action.C
        elif random.random() < 0.7:
            return Action.D
        else:
            return Action.C

    def _endgame_phase_decision(self, stock: float, current_round: int, history: PlayerHistory) -> Action:
        """Endgame phase decision logic"""
        rounds_remaining = self.r - current_round + 1
        if rounds_remaining <= 3:
            if rounds_remaining == 3:
                return Action.D if stock > self.danger_stock else Action.C
            elif rounds_remaining == 2:
                return Action.D if stock > self.danger_stock else Action.C
            else:
                return Action.D
        if stock > self.danger_stock:
            return Action.D
        elif self._enables_profitable_final_defection(stock, rounds_remaining):
            return Action.C
        else:
            return Action.D

    def _enables_profitable_final_defection(self, stock: float, rounds_remaining: int) -> bool:
        """Check if cooperation now enables more profitable final defection"""
        if stock <= self.danger_stock and rounds_remaining > 2:
            return True
        return False

    def _check_unanimous_cooperation(self, history: PlayerHistory) -> bool:
        """Check if all opponents cooperated in last 2 rounds"""
        rounds_to_check = min(2, len(history.my_actions))
        if rounds_to_check == 0:
            return False
        recent_actions = history.opponent_actions[-rounds_to_check:, :]
        return np.all(recent_actions == True)

class Strategy_AGGRESSIVE_52(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES) - Maximizes individual payoffs through 
    strategic exploitation while maintaining resource viability. Always defects first, then 
    uses weighted exploitation index and adaptive learning to dominate cooperators and 
    respond to defectors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.opponent_types = ['unknown'] * (self.n - 1)
        self.threshold_adjustment = 0.0
        self.consecutive_defect_rounds = 0
        self.was_exploited_last_round = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number
        current_stock = state.current_stock
        if current_round == self.r - 1:
            return self._final_round_strategy(current_stock)
        if current_round >= 3:
            self._classify_opponents(history)
        if current_stock < self.capacity / 4:
            return self._emergency_conservation(history)
        wei = self._calculate_wei(history, current_stock)
        wei += random.random() * 0.1 - 0.05
        wei_threshold_high = 0.6 + self.threshold_adjustment
        wei_threshold_low = 0.3 + self.threshold_adjustment
        if wei > wei_threshold_high:
            return Action.D
        elif wei < wei_threshold_low:
            return Action.C
        else:
            return self._apply_conditional_rules(history, current_stock)

    def _calculate_wei(self, history, current_stock):
        """Calculate Weighted Exploitation Index"""
        current_round = history.round_number
        total_opponent_defections = np.sum(~history.opponent_actions)
        total_opponent_actions = (self.n - 1) * current_round
        defection_rate = total_opponent_defections / total_opponent_actions if total_opponent_actions > 0 else 0
        stock_health = current_stock / self.capacity
        punishment_factor = 1.2 if self.was_exploited_last_round else 1.0
        if current_round > 0:
            last_round_cooperators = np.sum(history.opponent_actions[-1, :])
            my_last_action = history.my_actions[-1]
            self.was_exploited_last_round = my_last_action == 1 and last_round_cooperators < (self.n - 1) / 2
        wei = defection_rate * stock_health * punishment_factor
        return wei

    def _classify_opponents(self, history):
        """Classify opponents as cooperator, defector, or adaptive"""
        current_round = history.round_number
        for i in range(self.n - 1):
            cooperation_rate = np.sum(history.opponent_actions[:current_round, i]) / current_round
            if cooperation_rate > 0.6:
                self.opponent_types[i] = 'cooperator'
            elif cooperation_rate < 0.4:
                self.opponent_types[i] = 'defector'
            else:
                self.opponent_types[i] = 'adaptive'

    def _emergency_conservation(self, history):
        """Handle low stock scenarios"""
        if history.round_number > 0:
            last_round_cooperators = np.sum(history.opponent_actions[-1, :])
            if last_round_cooperators == 0:
                return Action.D
        return Action.C

    def _apply_conditional_rules(self, history, current_stock):
        """Apply conditional aggression rules when WEI is in middle range"""
        current_round = history.round_number
        if current_stock < self.capacity / 2:
            if current_round > 0:
                last_round_cooperators = np.sum(history.opponent_actions[-1, :])
                if last_round_cooperators > (self.n - 1) / 2:
                    return Action.C
        if current_stock > 3 * self.capacity / 4:
            if current_round > 0:
                last_round_cooperators = np.sum(history.opponent_actions[-1, :])
                if last_round_cooperators > 0:
                    return Action.D
        if current_round > 2:
            my_avg_payoff = np.mean(history.my_payoffs)
            opponent_avg_payoff = np.mean(history.opponent_payoffs)
            if my_avg_payoff < opponent_avg_payoff * 0.85:
                self.consecutive_defect_rounds = 2
        if self.consecutive_defect_rounds > 0:
            self.consecutive_defect_rounds -= 1
            return Action.D
        if current_round > 0:
            last_round_defectors = np.sum(~history.opponent_actions[-1, :])
            if last_round_defectors > (self.n - 1) / 2:
                return Action.D
        if current_round >= 3:
            for i in range(self.n - 1):
                defection_rate = np.sum(~history.opponent_actions[:current_round, i]) / current_round
                if defection_rate >= 0.7 and current_stock > self.capacity / 3:
                    return Action.D
        return Action.D

    def _final_round_strategy(self, current_stock):
        """Endgame maximization strategy for final round"""
        if current_stock > self.capacity / 3:
            return Action.D
        defect_payoff = current_stock / self.n
        cooperate_payoff = current_stock / (2 * self.n)
        if defect_payoff > cooperate_payoff * 1.5:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_53(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES)
    
    Operates on opportunistic dominance - maximizing immediate gains while strategically
    preserving the resource when it serves long-term exploitation potential. Uses three
    phases: early aggression, adaptive exploitation, and endgame extraction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_num = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        stock = state.current_stock
        capacity = self.game_description.capacity
        n = self.game_description.n_players
        early_phase = round_num <= max(3, int(0.2 * total_rounds))
        endgame_phase = round_num > int(0.85 * total_rounds)
        healthy_stock = stock > 0.6 * capacity
        critical_stock = stock < 0.3 * capacity
        if early_phase:
            if stock > 0.5 * capacity:
                return Action.D
            if critical_stock and len(history.opponent_actions) > 0:
                all_cooperated = all(history.opponent_actions[-1, :])
                if all_cooperated:
                    return Action.C
            return Action.D
        if endgame_phase:
            if stock > capacity / 4:
                return Action.D
            if stock > 0 and len(history.my_actions) > 0:
                i_defected = not history.my_actions[-1]
                others_cooperated = all(history.opponent_actions[-1, :])
                if i_defected and others_cooperated:
                    return Action.C
            return Action.D
        lookback = min(3, len(history.opponent_actions))
        if lookback > 0:
            recent_actions = history.opponent_actions[-lookback:, :]
            total_decisions = recent_actions.size
            cooperations = np.sum(recent_actions)
            defections = total_decisions - cooperations
            opponent_defect_rate = defections / total_decisions if total_decisions > 0 else 0
        else:
            opponent_defect_rate = 0
        if critical_stock and opponent_defect_rate < 0.5:
            return Action.C
        if healthy_stock:
            return Action.D
        if opponent_defect_rate > 0.6:
            return Action.D
        if len(history.my_payoffs) >= 2:
            recent_payoffs = history.my_payoffs[-2:]
            if recent_payoffs[1] < recent_payoffs[0] * 0.8:
                return Action.D
        if round_num % 3 != 0:
            return Action.D
        return Action.C

class Strategy_AGGRESSIVE_54(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Resource Predator"
    
    Maximizes immediate extraction while strategically timing cooperation only when 
    mathematically advantageous for long-term domination. Exploits cooperative opponents
    while minimizing own cooperative "losses".
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if history is None:
            return Action.D
        if round_number == self.n_rounds - 1:
            return Action.D
        if current_stock < self.capacity * 0.15:
            return Action.C
        if current_stock > self.capacity * 0.85:
            return Action.D
        recent_opponent_coop_rate = self._calculate_recent_coop_rate(history, 3)
        early_game_end = self.n_rounds // 3
        mid_game_end = 2 * self.n_rounds // 3
        if round_number <= early_game_end:
            if recent_opponent_coop_rate > 0.4:
                return Action.D
            elif current_stock > self.capacity * 0.5:
                return Action.D
            else:
                return Action.C
        elif round_number <= mid_game_end:
            exploitation_threshold = 0.3 + current_stock / self.capacity * 0.3
            if recent_opponent_coop_rate > exploitation_threshold:
                return Action.D
            elif current_stock > self.capacity * 0.4 and recent_opponent_coop_rate > 0.2:
                return Action.D
            else:
                return Action.C
        elif current_stock > self.capacity * 0.3 or recent_opponent_coop_rate > 0.25:
            return Action.D
        else:
            return Action.C

    def _calculate_recent_coop_rate(self, history: PlayerHistory, lookback_rounds: int) -> float:
        """Calculate the average cooperation rate of opponents over the last N rounds."""
        if history.round_number == 0:
            return 0.0
        actual_lookback = min(lookback_rounds, history.round_number)
        recent_actions = history.opponent_actions[-actual_lookback:, :]
        total_actions = recent_actions.size
        if total_actions == 0:
            return 0.0
        cooperations = np.sum(recent_actions)
        return cooperations / total_actions

class Strategy_AGGRESSIVE_55(BaseStrategy):
    """
    Aggressive Exploitative Strategy: "Opportunistic Dominance"
    
    This strategy aggressively exploits cooperative behavior while maintaining strategic 
    sustainability. It defects when stock is high, punishes defectors, and escalates 
    in the endgame, but cooperates when stock is critically low to preserve the resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.base_aggression = 0.8
        self.critical_stock_threshold = self.capacity / (4 * self.n_players)
        self.high_stock_threshold = 0.7 * self.capacity
        self.end_game_threshold = 0.8 * self.n_rounds
        self.opening_rounds = min(2, self.n_rounds // 10)
        self.consecutive_cooperations = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.consecutive_cooperations = 1
            return Action.C
        round_num = history.round_number
        current_stock = state.current_stock
        if current_stock < self.critical_stock_threshold:
            self.consecutive_cooperations += 1
            return Action.C
        if round_num > 0:
            if len(history.my_payoffs) >= 2:
                prev_payoff = history.my_payoffs[-2] if len(history.my_payoffs) >= 2 else 0
                curr_payoff = history.my_payoffs[-1]
                if prev_payoff > 0 and curr_payoff < prev_payoff * 0.5:
                    if self.consecutive_cooperations < 2:
                        self.consecutive_cooperations += 1
                        return Action.C
        if round_num < self.opening_rounds:
            self.consecutive_cooperations += 1
            return Action.C
        self.consecutive_cooperations = 0
        if round_num >= self.end_game_threshold:
            if current_stock > self.capacity / (8 * self.n_players):
                return Action.D
            else:
                self.consecutive_cooperations += 1
                return Action.C
        if current_stock >= self.high_stock_threshold:
            return Action.D
        if round_num > 0:
            last_round_cooperators = np.sum(history.opponent_actions[-1, :])
            total_opponents = self.n_players - 1
            if last_round_cooperators >= total_opponents / 2:
                return Action.D
        if round_num >= 2:
            recent_payoffs = history.my_payoffs[-2:]
            if len(recent_payoffs) >= 2 and recent_payoffs[-1] > recent_payoffs[-2]:
                return Action.D
        if round_num >= 3:
            recent_rounds = min(3, round_num)
            recent_actions = history.opponent_actions[-recent_rounds:, :]
            defection_rates = np.mean(recent_actions == False, axis=0)
            high_defectors = np.sum(defection_rates > 0.6)
            if high_defectors > 0 and current_stock >= self.capacity / (2 * self.n_players):
                return Action.D
        stock_multiplier = min(2.0, current_stock / (self.capacity / 2))
        round_multiplier = 1 + round_num / self.n_rounds * 0.5
        aggression_level = self.base_aggression * stock_multiplier * round_multiplier
        if random.random() < aggression_level:
            return Action.D
        if self.consecutive_cooperations >= 2:
            return Action.D
        else:
            self.consecutive_cooperations += 1
            return Action.C

class Strategy_AGGRESSIVE_56(BaseStrategy):
    """
    Aggressive Adaptive Resource Extraction Strategy (AARES)
    
    Operates on aggressive opportunism - maximizing immediate gains while maintaining 
    long-term viability through calculated risk management. Assumes opponents will 
    exploit weakness and adapts accordingly through three phases: aggressive opening,
    adaptive exploitation, and endgame exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.betrayal_tracking = {}
        self.punishment_rounds = 0
        self.max_aggression_rounds = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = state.round_number
        current_stock = state.current_stock
        stock_health_ratio = current_stock / self.capacity
        if stock_health_ratio >= 0.8:
            stock_status = 'ABUNDANT'
        elif stock_health_ratio >= 0.4:
            stock_status = 'MODERATE'
        elif stock_health_ratio >= 0.15:
            stock_status = 'CRITICAL'
        else:
            stock_status = 'COLLAPSE'
        total_opponent_actions = history.opponent_actions.size
        total_defections = np.sum(history.opponent_actions == False)
        defection_rate = total_defections / total_opponent_actions if total_opponent_actions > 0 else 0
        if defection_rate >= 0.7:
            opponent_type = 'HIGHLY_AGGRESSIVE'
        elif defection_rate >= 0.4:
            opponent_type = 'MODERATELY_AGGRESSIVE'
        else:
            opponent_type = 'COOPERATIVE'
        if self.punishment_rounds > 0:
            self.punishment_rounds -= 1
            return Action.D
        if self.max_aggression_rounds > 0:
            self.max_aggression_rounds -= 1
            if stock_status != 'COLLAPSE':
                return Action.D
        if current_round >= self.n_rounds - 2:
            if current_round == self.n_rounds - 1:
                return Action.D
            elif current_stock > self.capacity / 4:
                return Action.D
            else:
                return Action.C
        if len(history.my_actions) > 0:
            last_round = len(history.my_actions) - 1
            if history.my_actions[last_round]:
                last_stock_ratio = self._estimate_previous_stock_health(history, last_round)
                if last_stock_ratio >= 0.4:
                    betrayers = np.sum(history.opponent_actions[last_round, :] == False)
                    if betrayers > 0:
                        self.punishment_rounds = 1
                        return Action.D
        if len(history.opponent_actions) > 0:
            last_round_opponents = history.opponent_actions[-1, :]
            defectors_last_round = np.sum(last_round_opponents == False)
            if defectors_last_round >= len(last_round_opponents) * 0.5 and stock_status == 'CRITICAL':
                self.max_aggression_rounds = 2
                return Action.D
        if self.n_players == 2:
            if stock_status != 'COLLAPSE':
                return Action.D
            else:
                return Action.C
        if self.n_rounds <= 3:
            if stock_status != 'COLLAPSE':
                return Action.D
            else:
                return Action.C
        if stock_status == 'COLLAPSE':
            if current_round < self.n_rounds - 3:
                if opponent_type == 'HIGHLY_AGGRESSIVE':
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.D
        elif stock_status == 'CRITICAL':
            if opponent_type == 'COOPERATIVE':
                return Action.D
            elif opponent_type == 'MODERATELY_AGGRESSIVE':
                if len(history.opponent_actions) > 0:
                    last_cooperators = np.sum(history.opponent_actions[-1, :] == True)
                    if last_cooperators > len(history.opponent_actions[-1, :]) / 2:
                        return Action.C
                    else:
                        return Action.D
                else:
                    return Action.D
            else:
                return Action.D
        elif stock_status == 'MODERATE':
            if opponent_type == 'COOPERATIVE':
                return Action.D
            elif opponent_type == 'MODERATELY_AGGRESSIVE':
                if self._is_stock_trending_up(history):
                    return Action.D
                else:
                    return Action.C
            elif self._can_sustain_mutual_defection(current_stock, 2):
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

    def _estimate_previous_stock_health(self, history, round_idx):
        """Estimate stock health in a previous round"""
        current_round_ratio = len(history.my_actions)
        if current_round_ratio <= 1:
            return 0.8
        decay_factor = 0.9 ** (current_round_ratio - round_idx)
        return min(0.8 * decay_factor, 0.8)

    def _is_stock_trending_up(self, history):
        """Simple heuristic to check if stock is trending upward"""
        if len(history.my_actions) < 2:
            return False
        recent_payoffs = history.my_payoffs[-2:]
        return recent_payoffs[-1] > recent_payoffs[-2]

    def _can_sustain_mutual_defection(self, current_stock, rounds):
        """Check if current stock can sustain mutual defection for given rounds"""
        consumption_per_round = current_stock
        return current_stock > consumption_per_round * 0.5

class Strategy_AGGRESSIVE_57(BaseStrategy):
    """
    Aggressive Opportunistic Strategy: "Resource Hawk"
    
    Operates on aggressive opportunism - maximizing immediate gains while maintaining
    just enough restraint to prevent complete resource collapse when profitable.
    Exploits cooperators ruthlessly and adapts based on stock levels and opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_num = state.round_number
        stock = state.current_stock
        stock_ratio = stock / self.capacity
        if round_num > 2 * self.r / 3:
            if stock_ratio < 0.15:
                if self._majority_cooperated_last_round(history):
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
        if stock_ratio > 0.7:
            return Action.D
        if stock_ratio < 0.3:
            if self._stock_is_increasing(history, stock) and round_num < self.r:
                return Action.D
            elif self._majority_cooperated_last_round(history):
                return Action.C
            else:
                return Action.D
        if stock_ratio >= 0.3 and stock_ratio <= 0.7:
            cooperator_count = self._count_frequent_cooperators(history)
            if cooperator_count > 0:
                return Action.D
            if stock_ratio > 0.4:
                mixed_players = self._count_mixed_players(history)
                if mixed_players > 0:
                    return Action.D
            defector_count = self._count_frequent_defectors(history)
            if defector_count >= self.n - 1:
                return Action.D
        return Action.D

    def _majority_cooperated_last_round(self, history: PlayerHistory) -> bool:
        """Check if majority of opponents cooperated in the last round."""
        if len(history.opponent_actions) == 0:
            return False
        last_round_actions = history.opponent_actions[-1, :]
        cooperators = sum(last_round_actions)
        return cooperators > (self.n - 1) / 2

    def _stock_is_increasing(self, history: PlayerHistory, current_stock: float) -> bool:
        """Check if stock is increasing compared to previous round."""
        if len(history.my_actions) < 2:
            return False
        last_payoff = history.my_payoffs[-1]
        second_last_payoff = history.my_payoffs[-2] if len(history.my_payoffs) >= 2 else last_payoff
        return current_stock > last_payoff * (2 * self.n)

    def _count_frequent_cooperators(self, history: PlayerHistory) -> int:
        """Count opponents with cooperation rate > 0.6 in recent rounds."""
        if len(history.opponent_actions) == 0:
            return 0
        lookback = min(5, len(history.opponent_actions))
        recent_actions = history.opponent_actions[-lookback:, :]
        cooperator_count = 0
        for player_idx in range(self.n - 1):
            player_actions = recent_actions[:, player_idx]
            cooperation_rate = sum(player_actions) / len(player_actions)
            if cooperation_rate > 0.6:
                cooperator_count += 1
        return cooperator_count

    def _count_mixed_players(self, history: PlayerHistory) -> int:
        """Count opponents with cooperation rate between 0.3 and 0.6."""
        if len(history.opponent_actions) == 0:
            return 0
        lookback = min(5, len(history.opponent_actions))
        recent_actions = history.opponent_actions[-lookback:, :]
        mixed_count = 0
        for player_idx in range(self.n - 1):
            player_actions = recent_actions[:, player_idx]
            cooperation_rate = sum(player_actions) / len(player_actions)
            if 0.3 <= cooperation_rate <= 0.6:
                mixed_count += 1
        return mixed_count

    def _count_frequent_defectors(self, history: PlayerHistory) -> int:
        """Count opponents with cooperation rate < 0.3."""
        if len(history.opponent_actions) == 0:
            return 0
        lookback = min(5, len(history.opponent_actions))
        recent_actions = history.opponent_actions[-lookback:, :]
        defector_count = 0
        for player_idx in range(self.n - 1):
            player_actions = recent_actions[:, player_idx]
            cooperation_rate = sum(player_actions) / len(player_actions)
            if cooperation_rate < 0.3:
                defector_count += 1
        return defector_count

class Strategy_AGGRESSIVE_58(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES) - Maximizes individual payoffs through 
    intelligent exploitation while maintaining resource viability. Features opening aggression,
    stock threshold monitoring, adaptive response system, and endgame acceleration.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.danger_threshold = self.capacity / 4
        self.opportunity_threshold = self.capacity * 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if history is None:
            return Action.D
        if current_round <= 2:
            return Action.D
        remaining_rounds = self.n_rounds - current_round - 1
        if remaining_rounds <= 1:
            return Action.D
        if current_stock < self.danger_threshold:
            if len(history.opponent_actions) > 0:
                last_round_cooperators = sum(history.opponent_actions[-1, :])
                if last_round_cooperators > self.n_players * 0.6:
                    return Action.C
            return Action.D
        if current_stock > self.opportunity_threshold:
            return Action.D
        defection_rate = self._calculate_defection_rate(history)
        stock_ratio = current_stock / self.capacity
        time_pressure = 1.0 / max(remaining_rounds, 1)
        exploitation_score = defection_rate * 0.4 + stock_ratio * 0.3 + time_pressure * 0.3
        if exploitation_score > 0.6:
            return Action.D
        cooperation_momentum = self._check_cooperation_momentum(history)
        stock_recovering = self._check_stock_recovery(history, state)
        if cooperation_momentum and stock_recovering:
            return Action.C
        if self._detect_coordination_pattern(history):
            return Action.D
        return Action.D

    def _calculate_defection_rate(self, history: PlayerHistory) -> float:
        """Calculate average defection rate over last 3 rounds."""
        if len(history.opponent_actions) == 0:
            return 0.5
        rounds_to_check = min(3, len(history.opponent_actions))
        total_defections = 0
        total_decisions = 0
        for i in range(rounds_to_check):
            round_idx = len(history.opponent_actions) - 1 - i
            round_defections = sum(1 - history.opponent_actions[round_idx, :])
            total_defections += round_defections
            total_decisions += self.n_players
        return total_defections / max(total_decisions, 1)

    def _check_cooperation_momentum(self, history: PlayerHistory) -> bool:
        """Check if cooperation is increasing among opponents."""
        if len(history.opponent_actions) < 2:
            return False
        last_round_coop = sum(history.opponent_actions[-1, :])
        prev_round_coop = sum(history.opponent_actions[-2, :])
        return last_round_coop > prev_round_coop

    def _check_stock_recovery(self, history: PlayerHistory, state: CommonPoolState) -> bool:
        """Check if stock is recovering (growth > consumption in previous round)."""
        if len(history.my_payoffs) < 2:
            return False
        return state.current_stock > self.capacity * 0.3

    def _detect_coordination_pattern(self, history: PlayerHistory) -> bool:
        """Detect if opponents are establishing coordinated cooperation."""
        if len(history.opponent_actions) < 2:
            return False
        cooperation_rates = []
        for i in range(min(2, len(history.opponent_actions))):
            round_idx = len(history.opponent_actions) - 1 - i
            coop_rate = sum(history.opponent_actions[round_idx, :]) / self.n_players
            cooperation_rates.append(coop_rate)
        return all((rate > 0.75 for rate in cooperation_rates))

class Strategy_AGGRESSIVE_59(BaseStrategy):
    """
    Aggressive Exploitative Strategy: "Predator"
    
    Operates on aggressive exploitation with calculated sustainability.
    Always defects in first round, then uses stock health assessment
    and opponent analysis to maximize extraction while maintaining
    minimum viable resource base.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = state.round_number
        current_stock = state.current_stock
        rounds_remaining = self.r - current_round
        if rounds_remaining <= 1:
            return Action.D
        min_stock_needed = self.n * 0.5 * rounds_remaining
        if current_stock <= min_stock_needed:
            return Action.C
        if history.round_number > 0:
            last_round_cooperators = sum(history.opponent_actions[-1, :])
            coop_ratio_last_round = last_round_cooperators / (self.n - 1)
            punishment_intensity = 0.0
            if history.round_number >= 2:
                recent_defectors = sum(1 - history.opponent_actions[-1, :])
                prev_defectors = sum(1 - history.opponent_actions[-2, :])
                punishment_intensity = max(0, (recent_defectors - prev_defectors) / (self.n - 1))
        else:
            coop_ratio_last_round = 1.0
            punishment_intensity = 0.0
        critical_threshold = self.n
        danger_threshold = 1.5 * self.n
        if current_stock > danger_threshold and coop_ratio_last_round > 0.3:
            return Action.D
        if coop_ratio_last_round > 0.6 and punishment_intensity < 0.3:
            return Action.D
        if current_stock < critical_threshold and rounds_remaining > 3:
            return Action.C
        if current_stock <= 0.1:
            return Action.C
        if rounds_remaining <= max(1, self.r * 0.2):
            if current_stock > self.n * 0.8:
                return Action.D
        if coop_ratio_last_round > 0.7:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_60(BaseStrategy):
    """
    Aggressive Predatory Strategy: "Stock Shark"
    
    Operates on aggressive resource extraction with calculated sustainability.
    Divides game into phases: Exploitation, Escalation, and Endgame.
    Exploits cooperative players while maintaining minimal stock viability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = state.round_number
        stock = state.current_stock
        rounds_remaining = self.r - current_round
        if stock <= self.n / 2:
            return Action.C
        if rounds_remaining == 0:
            return Action.D
        elif rounds_remaining <= 2:
            return self._escalation_phase_decision(stock, rounds_remaining, history)
        else:
            return self._exploitation_phase_decision(stock, history)

    def _escalation_phase_decision(self, stock, rounds_remaining, history):
        """Near endgame maximum pressure tactics"""
        if stock <= self.n:
            return Action.C
        elif rounds_remaining == 2 and stock > 2 * self.n:
            return Action.D
        else:
            return Action.D if random.random() < 0.8 else Action.C

    def _exploitation_phase_decision(self, stock, history):
        """Main aggressive tactics with strategic cooperation"""
        if stock <= self.n:
            return Action.C
        elif stock <= 1.5 * self.n:
            return Action.C if random.random() < 0.7 else Action.D
        last_round_actions = history.opponent_actions[-1, :]
        cooperators_last_round = sum(last_round_actions)
        majority_cooperated = cooperators_last_round > self.n / 2
        my_cooperation_rate = sum(history.my_actions) / len(history.my_actions)
        if stock > 1.5 * self.n and majority_cooperated:
            return Action.D
        if stock > 1.5 * self.n and my_cooperation_rate < 0.3:
            return Action.C
        defector_count_last_round = self.n - cooperators_last_round
        if defector_count_last_round >= self.n / 2:
            return Action.C
        if self._should_exploit_recovery(stock, history):
            return Action.D
        if self._should_punish_defectors(history):
            return Action.D
        return Action.D

    def _should_exploit_recovery(self, current_stock, history):
        """Check if stock is recovering and exploit the opportunity"""
        if len(history.my_payoffs) < 2:
            return False
        last_action_was_coop = history.my_actions[-1]
        last_payoff = history.my_payoffs[-1]
        if last_payoff <= 0:
            return False
        if last_action_was_coop:
            estimated_previous_stock = last_payoff * (2 * self.n)
        else:
            estimated_previous_stock = last_payoff * self.n
        return current_stock > estimated_previous_stock * 1.1

    def _should_punish_defectors(self, history):
        """Punish players who have been consistently defecting"""
        if len(history.opponent_actions) < 3:
            return False
        recent_rounds = min(3, len(history.opponent_actions))
        for player_idx in range(self.n):
            recent_actions = history.opponent_actions[-recent_rounds:, player_idx]
            defection_rate = 1 - sum(recent_actions) / len(recent_actions)
            if defection_rate > 0.75:
                return True
        return False

class Strategy_AGGRESSIVE_61(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES)
    
    Maximizes individual payoff through calculated aggression while maintaining 
    resource base for sustained exploitation. Defaults to defection with selective
    cooperation only when necessary to prevent complete collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.r - 1:
            return Action.D
        if current_stock < self.n:
            return Action.C
        if current_round < self.r // 3:
            return Action.D
        elif current_round < 2 * self.r // 3:
            return self._phase_two_decision(state, history)
        else:
            return self._phase_three_decision(state, history)

    def _phase_two_decision(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        current_stock = state.current_stock
        condition_1 = current_stock < self.capacity / 3
        condition_2 = self._has_declining_trend(history, 2)
        condition_3 = self._opponent_cooperation_rate(history) > 0.6
        condition_4 = self._above_cooperate_benchmark(history)
        if condition_1 and condition_2 and condition_3 and condition_4:
            return Action.C
        else:
            return Action.D

    def _phase_three_decision(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if current_stock < self.capacity / 4:
            return Action.C
        remaining_rounds = self.r - current_round
        remaining_value = current_stock * remaining_rounds
        current_lead = self._calculate_payoff_lead(history)
        if remaining_value < current_lead:
            return Action.D
        else:
            return Action.D

    def _has_declining_trend(self, history: PlayerHistory, num_rounds: int) -> bool:
        """Check if stock has declined for specified consecutive rounds"""
        if len(history.my_payoffs) < num_rounds + 1:
            return False
        recent_payoffs = history.my_payoffs[-num_rounds - 1:]
        recent_actions = history.my_actions[-num_rounds - 1:]
        estimated_stocks = []
        for i, (payoff, action) in enumerate(zip(recent_payoffs, recent_actions)):
            if action:
                estimated_stock = payoff * 2 * self.n
            else:
                estimated_stock = payoff * self.n
            estimated_stocks.append(estimated_stock)
        for i in range(1, len(estimated_stocks)):
            if estimated_stocks[i] >= estimated_stocks[i - 1]:
                return False
        return True

    def _opponent_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate cooperation rate of opponents in previous round"""
        if len(history.opponent_actions) == 0:
            return 0.0
        last_round_actions = history.opponent_actions[-1, :]
        return np.mean(last_round_actions)

    def _above_cooperate_benchmark(self, history: PlayerHistory) -> bool:
        """Check if current payoff is above theoretical all-cooperate benchmark"""
        my_total = np.sum(history.my_payoffs)
        rounds_played = len(history.my_payoffs)
        estimated_benchmark = rounds_played * (self.capacity / (2 * self.n)) * 0.8
        return my_total > estimated_benchmark

    def _calculate_payoff_lead(self, history: PlayerHistory) -> float:
        """Calculate current payoff advantage over opponents"""
        my_total = np.sum(history.my_payoffs)
        opponent_totals = np.sum(history.opponent_payoffs, axis=0)
        avg_opponent_total = np.mean(opponent_totals)
        return my_total - avg_opponent_total

class Strategy_AGGRESSIVE_62(BaseStrategy):
    """
    Aggressive Opportunistic Strategy: "Predatory Depletion"
    
    This strategy operates on aggressive resource extraction while maintaining just enough
    restraint to keep the pool viable for maximum personal gain. It uses three phases:
    early exploitation, adaptive predation, and endgame maximization.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        early_phase = round_num <= self.r // 3
        middle_phase = self.r // 3 < round_num <= 2 * self.r // 3
        end_phase = round_num > 2 * self.r // 3
        final_round = round_num == self.r - 1
        danger_zone = stock < self.capacity / 8
        collapse_zone = stock < self.capacity / 16
        high_stock = stock > self.capacity / 2
        medium_stock = stock > self.capacity / 3
        if history is None:
            return Action.D
        last_round_idx = history.round_number - 1
        opponent_defection_rate = 1.0 - np.mean(history.opponent_actions[last_round_idx, :])
        any_opponent_cooperated = opponent_defection_rate < 1.0
        mostly_defected = opponent_defection_rate > 0.75
        i_defected_last = not history.my_actions[last_round_idx]
        if final_round:
            return Action.D
        if early_phase:
            return Action.D
        if high_stock and (not collapse_zone):
            return Action.D
        if collapse_zone and i_defected_last:
            return Action.C
        if danger_zone and round_num == 0:
            return Action.D
        if middle_phase:
            if stock <= self.capacity / 4 and mostly_defected:
                return Action.C
            else:
                return Action.D
        if end_phase:
            if medium_stock:
                return Action.D
            if stock <= self.capacity / 3 and any_opponent_cooperated:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_63(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy - maximizes immediate gains through
    opportunistic defection while maintaining minimal resource sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_num = history.round_number
        stock = state.current_stock
        if round_num == self.n_rounds - 1:
            return Action.D
        critical_threshold = self.capacity * 0.3
        cooperation_threshold = self.capacity * 0.15
        recent_cooperation_rate = self._calculate_recent_cooperation_rate(history)
        if stock <= cooperation_threshold:
            if recent_cooperation_rate > 0.6:
                return Action.C
            else:
                return Action.D
        if stock > critical_threshold:
            return Action.D
        if recent_cooperation_rate > 0.4:
            return Action.D
        elif round_num % 4 == 0:
            return Action.C
        else:
            return Action.D

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate cooperation rate of opponents in the last 3 rounds."""
        if history.round_number == 0:
            return 0.0
        lookback = min(3, history.round_number)
        recent_rounds = history.opponent_actions[-lookback:, :]
        total_actions = recent_rounds.size
        if total_actions == 0:
            return 0.0
        cooperations = np.sum(recent_rounds)
        return cooperations / total_actions

class Strategy_AGGRESSIVE_64(BaseStrategy):
    """
    Aggressive Adaptive Resource Exploitation Strategy - "Predatory Harvester"
    
    Operates on opportunistic dominance principle: maximize immediate gains while 
    preserving resources only when absolutely necessary. Uses front-loaded aggression,
    behavioral analysis of opponents, and endgame liquidation tactics.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = state.round_number
        current_stock = state.current_stock
        opening_aggression_rounds = min(3, max(1, int(0.2 * self.n_rounds)))
        if current_round < opening_aggression_rounds:
            return Action.D
        rounds_remaining = self.n_rounds - current_round
        endgame_threshold = max(1, int(0.2 * self.n_rounds))
        if rounds_remaining <= endgame_threshold:
            return self._endgame_strategy(current_stock, rounds_remaining, history)
        return self._adaptive_exploitation(current_stock, history)

    def _endgame_strategy(self, stock: float, rounds_remaining: int, history: PlayerHistory) -> Action:
        """Endgame maximization strategy"""
        if rounds_remaining <= 2:
            if stock > self.n_players * rounds_remaining:
                return Action.D
            else:
                return Action.C
        if rounds_remaining <= 4:
            if len(history.opponent_actions) > 0:
                last_round_defectors = sum(history.opponent_actions[-1, :] == False)
                if last_round_defectors >= self.n_players // 2:
                    return Action.D
            return Action.C if random.random() < 0.6 else Action.D
        return self._adaptive_exploitation(stock, history)

    def _adaptive_exploitation(self, stock: float, history: PlayerHistory) -> Action:
        """Core adaptive exploitation logic for middle rounds"""
        stock_ratio = stock / self.capacity
        if stock_ratio <= 0.3:
            return Action.C
        elif stock_ratio >= 0.8:
            return Action.D
        if stock <= self.n_players:
            if self._recent_cooperation_rate(history, 1) >= 0.7:
                return Action.C
            else:
                return Action.D
        if self._check_resource_abundance(history):
            return Action.D
        if len(history.opponent_actions) > 0:
            last_round_defectors = sum(history.opponent_actions[-1, :] == False)
            if last_round_defectors >= self.n_players // 2:
                return Action.D
        return self._behavioral_analysis(history)

    def _behavioral_analysis(self, history: PlayerHistory) -> Action:
        """Analyze opponent behavior and respond accordingly"""
        if len(history.opponent_actions) < 3:
            return Action.D if random.random() < 0.7 else Action.C
        window_size = min(3, len(history.opponent_actions))
        recent_actions = history.opponent_actions[-window_size:, :]
        defect_against_count = 0
        cooperate_with_count = 0
        mixed_opponents = 0
        for player_idx in range(self.n_players - 1):
            player_actions = recent_actions[:, player_idx]
            coop_rate = sum(player_actions) / len(player_actions)
            if coop_rate < 0.4:
                defect_against_count += 1
            elif coop_rate > 0.7:
                cooperate_with_count += 1
            else:
                mixed_opponents += 1
        if defect_against_count > 0:
            return Action.D
        if cooperate_with_count > mixed_opponents:
            return Action.D if random.random() < 0.8 else Action.C
        if mixed_opponents > 0 and len(history.opponent_actions) > 0:
            last_actions = history.opponent_actions[-1, :]
            majority_cooperated = sum(last_actions) > len(last_actions) / 2
            if random.random() < 0.7:
                return Action.C if majority_cooperated else Action.D
            else:
                return Action.D
        return Action.D if random.random() < 0.65 else Action.C

    def _recent_cooperation_rate(self, history: PlayerHistory, rounds: int) -> float:
        """Calculate recent cooperation rate of opponents"""
        if len(history.opponent_actions) == 0:
            return 0.5
        window_size = min(rounds, len(history.opponent_actions))
        recent_actions = history.opponent_actions[-window_size:, :]
        total_actions = recent_actions.size
        total_cooperation = np.sum(recent_actions)
        return total_cooperation / total_actions if total_actions > 0 else 0.5

    def _check_resource_abundance(self, history: PlayerHistory) -> bool:
        """Check if resource has been at capacity for 2+ consecutive rounds"""
        if len(history.my_payoffs) < 2:
            return False
        recent_payoffs = history.my_payoffs[-2:]
        max_possible_payoff = self.capacity / (2 * self.n_players)
        return all((payoff >= max_possible_payoff * 0.9 for payoff in recent_payoffs))

class Strategy_AGGRESSIVE_65(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES).
    
    This strategy aggressively extracts resources while adapting to opponents' behavior
    and maintaining just enough sustainability to prevent stock collapse when profitable.
    Uses a three-phase approach: aggressive opening, adaptive exploitation, and endgame aggression.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.forced_coop_rounds = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        stock = state.current_stock
        if history is None:
            return Action.D
        round_num = history.round_number
        if stock < self.capacity / 8:
            self.forced_coop_rounds = max(2, self.forced_coop_rounds)
        if self.forced_coop_rounds > 0:
            self.forced_coop_rounds -= 1
            if stock <= self.capacity / 4:
                return Action.C
            elif stock > self.capacity / 4:
                self.forced_coop_rounds = 0
        if round_num <= 2:
            if stock > self.capacity / 3:
                return Action.D
            else:
                return Action.C
        if round_num >= self.r - 2:
            if round_num == self.r - 1:
                return Action.D
            elif stock > self.capacity / 6:
                return Action.D
            else:
                return Action.C
        if stock <= self.capacity / 4:
            return Action.C
        recent_rounds = min(3, round_num)
        start_idx = max(0, round_num - recent_rounds)
        total_actions = 0
        total_defections = 0
        for r in range(start_idx, round_num):
            for p in range(self.n - 1):
                total_actions += 1
                if not history.opponent_actions[r, p]:
                    total_defections += 1
        defection_ratio = total_defections / total_actions if total_actions > 0 else 0
        if defection_ratio > 0.6:
            return Action.D
        my_recent_avg = 0
        opponent_recent_avg = 0
        if recent_rounds > 0:
            my_recent_payoffs = history.my_payoffs[start_idx:round_num]
            my_recent_avg = np.mean(my_recent_payoffs)
            opponent_payoffs = []
            for r in range(start_idx, round_num):
                for p in range(self.n - 1):
                    opponent_payoffs.append(history.opponent_payoffs[r, p])
            if len(opponent_payoffs) > 0:
                opponent_recent_avg = np.mean(opponent_payoffs)
        my_recent_advantage = my_recent_avg - opponent_recent_avg
        if my_recent_advantage > 0:
            return Action.D
        if round_num > 0:
            cooperative_players = sum(history.opponent_actions[round_num - 1, :])
            if cooperative_players >= (self.n - 1) / 2 and stock > self.capacity / 2:
                return Action.D
        return Action.C

class Strategy_AGGRESSIVE_66(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES)
    
    A ruthlessly opportunistic strategy that maximizes immediate gains while maintaining
    the resource base only when absolutely necessary. Uses three phases: early exploitation,
    strategic adaptation, and endgame exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.opponent_cooperate_counts = [0] * (self.n - 1)
        self.opponent_total_actions = [0] * (self.n - 1)
        self.punishment_targets = set()
        self.last_defection_rate = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        stock = state.current_stock
        if stock <= self.capacity * 0.1:
            return Action.C
        if history is None:
            return Action.D
        self._update_opponent_tracking(history)
        phase = self._determine_phase(current_round)
        if phase == 'early':
            return self._early_exploitation_logic(stock, history)
        elif phase == 'middle':
            return self._strategic_adaptation_logic(stock, history)
        else:
            return self._endgame_exploitation_logic(stock, history, current_round)

    def _determine_phase(self, round_num):
        if round_num <= self.r // 3:
            return 'early'
        elif round_num <= 2 * self.r // 3:
            return 'middle'
        else:
            return 'endgame'

    def _update_opponent_tracking(self, history):
        if len(history.my_actions) == 0:
            return
        last_round_idx = len(history.my_actions) - 1
        last_opponent_actions = history.opponent_actions[last_round_idx, :]
        for i in range(self.n - 1):
            self.opponent_total_actions[i] += 1
            if last_opponent_actions[i]:
                self.opponent_cooperate_counts[i] += 1
        if len(history.my_actions) > 0:
            prev_stock = self._estimate_previous_stock(history, last_round_idx)
            if prev_stock < self.capacity * 0.3:
                for i in range(self.n - 1):
                    if not last_opponent_actions[i]:
                        self.punishment_targets.add(i)
        defections = sum((1 for action in last_opponent_actions if not action))
        self.last_defection_rate = defections / len(last_opponent_actions)

    def _estimate_previous_stock(self, history, round_idx):
        return history.my_payoffs[round_idx] * (2 * self.n)

    def _early_exploitation_logic(self, stock, history):
        if stock <= self.capacity * 0.3:
            return Action.C
        if stock > self.capacity * 0.7:
            return Action.D
        if len(history.my_actions) > 0:
            last_round_idx = len(history.my_actions) - 1
            last_opponent_actions = history.opponent_actions[last_round_idx, :]
            defection_rate = sum((1 for action in last_opponent_actions if not action)) / len(last_opponent_actions)
            if defection_rate >= 0.5:
                return Action.D
            else:
                return Action.C
        return Action.D

    def _strategic_adaptation_logic(self, stock, history):
        if stock <= self.capacity * 0.2:
            return Action.C
        pushover_count = 0
        aggressor_count = 0
        for i in range(self.n - 1):
            if self.opponent_total_actions[i] > 0:
                coop_rate = self.opponent_cooperate_counts[i] / self.opponent_total_actions[i]
                if coop_rate > 0.7:
                    pushover_count += 1
                elif coop_rate < 0.3:
                    aggressor_count += 1
        total_opponents = self.n - 1
        pushover_rate = pushover_count / total_opponents
        aggressor_rate = aggressor_count / total_opponents
        if pushover_rate >= 0.75:
            return Action.D
        if aggressor_rate >= 0.75:
            if stock < self.capacity * 0.6:
                return Action.C
            else:
                return Action.D
        last_round_idx = len(history.my_actions) - 1
        last_opponent_actions = history.opponent_actions[last_round_idx, :]
        last_defection_rate = sum((1 for action in last_opponent_actions if not action)) / len(last_opponent_actions)
        if stock > self.capacity * 0.6 and last_defection_rate < 0.6:
            return Action.D
        elif stock < self.capacity * 0.4 or last_defection_rate >= 0.8:
            return Action.C
        else:
            return Action.D

    def _endgame_exploitation_logic(self, stock, history, current_round):
        rounds_remaining = self.r - current_round
        if rounds_remaining <= 1:
            return Action.D
        if rounds_remaining == 2:
            if stock < self.capacity * 0.15:
                return Action.C
            else:
                return Action.D
        if stock > self.capacity * 0.5:
            return Action.D
        if stock <= self.capacity * 0.2:
            return Action.C
        if rounds_remaining <= 3:
            return Action.D
        last_round_idx = len(history.my_actions) - 1
        last_opponent_actions = history.opponent_actions[last_round_idx, :]
        defection_count = sum((1 for action in last_opponent_actions if not action))
        if defection_count > len(last_opponent_actions) / 2:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_67(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Ruthless Opportunist"
    
    Maximizes individual payoffs through aggressive exploitation while maintaining
    just enough restraint to keep the resource pool viable for continued extraction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.observation_window = min(5, game_description.n_rounds // 3)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        current_round = state.round_number
        last_round = self.game_description.n_rounds - 1
        stock = state.current_stock
        if current_round == last_round:
            return Action.D
        if stock <= capacity * 0.15:
            return Action.C
        window_start = max(0, history.round_number - self.observation_window)
        recent_rounds = history.round_number - window_start
        if recent_rounds > 0:
            recent_opponent_actions = history.opponent_actions[window_start:, :]
            total_recent_actions = recent_opponent_actions.size
            recent_defections = np.sum(~recent_opponent_actions)
            defection_ratio = recent_defections / total_recent_actions if total_recent_actions > 0 else 0
            my_recent_actions = history.my_actions[window_start:]
            my_recent_defections = np.sum(~my_recent_actions)
            my_recent_aggression = my_recent_defections / recent_rounds
        else:
            defection_ratio = 0
            my_recent_aggression = 0
        if defection_ratio >= 0.6:
            return Action.D
        if defection_ratio <= 0.2 and my_recent_aggression < 0.3:
            return Action.D
        if stock >= capacity * 0.8 and defection_ratio < 0.4:
            return Action.D
        rounds_remaining = last_round - current_round + 1
        if rounds_remaining > 0:
            if history.round_number > 0:
                recent_my_payoffs = history.my_payoffs[-min(3, history.round_number):]
                recent_opponent_payoffs = history.opponent_payoffs[-min(3, history.round_number):, :]
                avg_total_consumption = 0
                payoff_samples = len(recent_my_payoffs)
                for i in range(payoff_samples):
                    round_idx = history.round_number - payoff_samples + i
                    if round_idx >= 0:
                        if round_idx == 0:
                            start_stock = capacity
                        else:
                            start_stock = stock * 1.2 ** (payoff_samples - i)
                        my_consumption = recent_my_payoffs[i] * (2 if history.my_actions[round_idx] else 1)
                        opponent_consumption = np.sum(recent_opponent_payoffs[i, :]) * (2 if np.mean(history.opponent_actions[round_idx, :]) > 0.5 else 1)
                        total_consumption = my_consumption + opponent_consumption
                        avg_total_consumption += total_consumption / payoff_samples
                projected_depletion_rounds = stock / max(avg_total_consumption, stock / (rounds_remaining * 2))
            else:
                projected_depletion_rounds = rounds_remaining
            if projected_depletion_rounds <= 3:
                return Action.C
        return Action.D

class Strategy_AGGRESSIVE_68(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Predator"
    
    This strategy treats the common pool as a resource to be maximally extracted while 
    protecting against being exploited by others. It uses front-loaded aggression, 
    adaptive response to opponent behavior, and stock preservation mechanisms.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_stock = self.n_players * (self.n_players + 1)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number
        current_stock = state.current_stock
        if current_round < 3:
            return Action.D
        if current_stock <= self.critical_stock:
            return Action.C
        if current_round >= self.n_rounds - 2:
            return Action.D
        return self._adaptive_response(current_stock, history)

    def _adaptive_response(self, current_stock: float, history: PlayerHistory) -> Action:
        """
        Determine action based on opponent behavior and stock levels.
        """
        lookback_rounds = min(3, history.round_number)
        recent_opponent_actions = history.opponent_actions[-lookback_rounds:, :]
        total_cooperations = np.sum(recent_opponent_actions)
        total_actions = recent_opponent_actions.size
        avg_opponent_cooperation = total_cooperations / total_actions if total_actions > 0 else 0
        if avg_opponent_cooperation >= 0.67:
            return Action.D
        elif avg_opponent_cooperation <= 0.33:
            return Action.C
        elif current_stock >= 0.8 * self.capacity:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_69(BaseStrategy):
    """
    Aggressive Opportunistic Strategy: "Shark"
    
    Maximizes exploitation while maintaining resource viability. Always defects when
    stock is high, strategically cooperates only when necessary to prevent collapse,
    and applies punishment mechanisms against aggressive opponents.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.consecutive_cooperations = 0
        self.consecutive_defections = 0
        self.punishment_rounds_remaining = 0
        self.in_punishment_mode = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.consecutive_cooperations = 0
            self.consecutive_defections = 1
            return Action.D
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        stock = state.current_stock
        round_num = history.round_number + 1
        high_threshold = 0.7 * capacity
        medium_threshold = 0.3 * capacity
        critical_threshold = 0.15 * capacity
        if round_num > r - 3:
            return Action.D
        if stock < critical_threshold and self.consecutive_cooperations < 3:
            self.consecutive_cooperations += 1
            self.consecutive_defections = 0
            return Action.C
        if stock >= high_threshold:
            self.consecutive_defections += 1
            self.consecutive_cooperations = 0
            return Action.D
        if self.in_punishment_mode and self.punishment_rounds_remaining > 0:
            self.punishment_rounds_remaining -= 1
            if self.punishment_rounds_remaining == 0:
                self.in_punishment_mode = False
            self.consecutive_defections += 1
            self.consecutive_cooperations = 0
            return Action.D
        lookback_rounds = min(5, history.round_number)
        if lookback_rounds > 0:
            recent_actions = history.opponent_actions[-lookback_rounds:, :]
            exploitable_opponents = 0
            for player_idx in range(n - 1):
                player_recent_actions = recent_actions[:, player_idx]
                cooperation_rate = np.mean(player_recent_actions)
                if cooperation_rate >= 0.6:
                    exploitable_opponents += 1
        if history.round_number > 0:
            last_stock_estimate = self._estimate_previous_stock(history)
            if last_stock_estimate >= medium_threshold:
                last_round_defectors = np.sum(history.opponent_actions[-1, :] == False)
                if last_round_defectors > (n - 1) / 2:
                    self.in_punishment_mode = True
                    self.punishment_rounds_remaining = 1
        if stock >= medium_threshold:
            if lookback_rounds > 0 and exploitable_opponents > (n - 1) / 2:
                self.consecutive_defections += 1
                self.consecutive_cooperations = 0
                return Action.D
            elif history.round_number > 0:
                last_round_cooperators = np.sum(history.opponent_actions[-1, :])
                if last_round_cooperators > (n - 1) / 2:
                    self.consecutive_cooperations += 1
                    self.consecutive_defections = 0
                    return Action.C
                else:
                    self.consecutive_defections += 1
                    self.consecutive_cooperations = 0
                    return Action.D
        if self.consecutive_defections > 1 or stock < 0.4 * capacity:
            if self.consecutive_cooperations < 3:
                self.consecutive_cooperations += 1
                self.consecutive_defections = 0
                return Action.C
            else:
                self.consecutive_defections += 1
                self.consecutive_cooperations = 0
                return Action.D
        else:
            self.consecutive_defections += 1
            self.consecutive_cooperations = 0
            return Action.D

    def _estimate_previous_stock(self, history: PlayerHistory) -> float:
        """Estimate what the stock level was in the previous round based on payoffs"""
        if history.round_number == 0:
            return self.game_description.capacity
        last_payoff = history.my_payoffs[-1]
        last_action = history.my_actions[-1]
        n = self.game_description.n_players
        if last_action:
            estimated_stock = last_payoff * 2 * n
        else:
            estimated_stock = last_payoff * n
        return estimated_stock

class Strategy_AGGRESSIVE_70(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Predatory Adaptive"
    
    This strategy maximizes individual payoffs through aggressive resource extraction
    while maintaining just enough sustainability to avoid complete collapse. It operates
    on controlled predation - extracting maximum value while keeping the resource pool
    barely viable.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_critical = self.capacity * 0.15
        self.threshold_exploit = self.capacity * 0.6

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_num = state.round_number
        if history is None:
            if current_stock > 0.8 * self.capacity:
                return Action.D
            else:
                return Action.C
        if current_stock <= 0:
            return Action.C
        opponent_defect_rate = self._calculate_opponent_defect_rate(history)
        declining_trend = self._is_declining_trend(history)
        stable_growth = self._is_stable_growth(history)
        if round_num == self.r - 1:
            return Action.D
        if current_stock <= self.threshold_critical:
            return Action.C
        if round_num == self.r - 2:
            if current_stock <= self.threshold_critical:
                return Action.C
            elif current_stock > 0.7 * self.capacity:
                return Action.D
            elif opponent_defect_rate > 0.5:
                return Action.D
            else:
                return Action.D if random.random() < 0.7 else Action.C
        if current_stock >= self.threshold_exploit and self._can_sustain_defection(current_stock):
            return Action.D
        if opponent_defect_rate > 0.6:
            return Action.D
        if opponent_defect_rate < 0.1 and round_num > 2:
            return Action.D if random.random() < 0.9 else Action.C
        if declining_trend and current_stock < 0.5 * self.capacity:
            return Action.C if random.random() < 0.7 else Action.D
        if stable_growth and current_stock > 0.7 * self.capacity:
            return Action.D if random.random() < 0.8 else Action.C
        return Action.D if random.random() < 0.6 else Action.C

    def _calculate_opponent_defect_rate(self, history: PlayerHistory) -> float:
        """Calculate opponent defection rate over last 3 rounds."""
        if history.round_number == 0:
            return 0.0
        look_back = min(3, history.round_number)
        recent_actions = history.opponent_actions[-look_back:, :]
        total_defections = np.sum(~recent_actions)
        total_actions = recent_actions.size
        return total_defections / total_actions if total_actions > 0 else 0.0

    def _is_declining_trend(self, history: PlayerHistory) -> bool:
        """Check if stock has been declining for 2+ consecutive rounds."""
        if history.round_number < 2:
            return False
        recent_payoffs = history.my_payoffs[-2:]
        return len(recent_payoffs) >= 2 and recent_payoffs[-1] < recent_payoffs[-2] and (recent_payoffs[-2] < recent_payoffs[0]) if len(recent_payoffs) > 2 else False

    def _is_stable_growth(self, history: PlayerHistory) -> bool:
        """Check if stock has been stable/growing for 2+ rounds above 70% capacity."""
        if history.round_number < 2:
            return False
        recent_payoffs = history.my_payoffs[-2:]
        avg_recent_payoff = np.mean(recent_payoffs)
        estimated_cooperation_payoff = self.capacity / (2 * self.n)
        return avg_recent_payoff > 0.7 * estimated_cooperation_payoff

    def _can_sustain_defection(self, current_stock: float) -> bool:
        """Check if current stock can survive one round of all-defect and still regenerate."""
        total_consumption = self.n * (current_stock / self.n)
        stock_after_consumption = current_stock - total_consumption
        if stock_after_consumption <= 0:
            return False
        growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
        new_stock = min(stock_after_consumption + growth, self.capacity)
        return new_stock > self.threshold_critical

class Strategy_AGGRESSIVE_71(BaseStrategy):
    """
    Aggressive Adaptive Resource Extraction Strategy (AARES)
    
    Prioritizes immediate gains while maintaining long-term viability through calculated aggression.
    Uses three phases: early aggression, strategic exploitation, and endgame extraction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.punishment_rounds = {}

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if stock <= self.capacity / 10:
            return Action.C
        if current_round == self.r:
            return Action.D
        if current_round <= self.r / 4:
            return self._early_aggression_logic(stock, history)
        elif current_round <= 3 * self.r / 4:
            return self._strategic_exploitation_logic(stock, history)
        else:
            return self._endgame_extraction_logic(current_round, stock, history)

    def _early_aggression_logic(self, stock, history):
        """Phase 1: Early aggression with limited cooperation conditions"""
        if stock > self.capacity / 2:
            return Action.D
        if len(history.opponent_actions) > 0:
            prev_round_defectors = sum(history.opponent_actions[-1, :] == False)
            if prev_round_defectors > 0:
                return Action.D
        if len(history.opponent_actions) > 0 and stock < self.capacity / 3:
            all_cooperated_prev = all(history.opponent_actions[-1, :] == True)
            my_cooperated_prev = history.my_actions[-1] == True
            if all_cooperated_prev and my_cooperated_prev:
                return Action.C
        return Action.D

    def _strategic_exploitation_logic(self, stock, history):
        """Phase 2: Strategic exploitation with pattern detection"""
        if stock < self.capacity / 4:
            return Action.C
        if stock > 3 * self.capacity / 4:
            return Action.D
        if len(history.opponent_actions) >= 3:
            recent_actions = history.opponent_actions[-3:, :]
            cooperation_rates = np.mean(recent_actions, axis=0)
            high_cooperators = sum(cooperation_rates > 0.7)
            if high_cooperators > self.n / 2:
                return Action.D
        if len(history.my_payoffs) > 0:
            my_avg_payoff = np.mean(history.my_payoffs)
            opponent_avg_payoffs = np.mean(history.opponent_payoffs, axis=0)
            overall_opponent_avg = np.mean(opponent_avg_payoffs)
            if my_avg_payoff < overall_opponent_avg:
                return Action.D
            else:
                return Action.C
        return Action.D

    def _endgame_extraction_logic(self, current_round, stock, history):
        """Phase 3: Endgame extraction with stock awareness"""
        remaining_rounds = self.r - current_round + 1
        minimum_needed = self.n * remaining_rounds
        if stock > 2 * minimum_needed:
            return Action.D
        if stock > minimum_needed:
            if len(history.opponent_actions) > 0:
                all_others_cooperated = all(history.opponent_actions[-1, :] == True)
                if not all_others_cooperated:
                    return Action.D
            else:
                return Action.D
        if stock <= minimum_needed:
            return Action.C
        return Action.C

class Strategy_AGGRESSIVE_72(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES) - Maximizes immediate gains while 
    maintaining long-term viability through calculated exploitation of cooperative behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.exploration_end = max(1, int(0.2 * self.n_rounds))
        self.exploitation_end = max(2, int(0.8 * self.n_rounds))
        self.exploitation_threshold = self.capacity / 3
        self.crisis_threshold = self.capacity / 4
        self.opportunity_threshold = self.capacity / 2
        self.punishment_rounds_remaining = 0
        self.last_cooperation_ratio = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number
        stock = state.current_stock
        cooperation_ratio = 0.0
        if current_round > 0:
            cooperators = sum(history.opponent_actions[-1, :])
            cooperation_ratio = cooperators / (self.n_players - 1)
        if current_round > 1 and self.punishment_rounds_remaining == 0:
            if self.last_cooperation_ratio > 0.5 and cooperation_ratio < 0.2 and (sum(history.opponent_actions[-1, :]) == 0):
                self.punishment_rounds_remaining = 2
        self.last_cooperation_ratio = cooperation_ratio
        if self.punishment_rounds_remaining > 0:
            self.punishment_rounds_remaining -= 1
            if random.random() < 0.3:
                return Action.C
            else:
                return Action.D
        if current_round <= self.exploration_end:
            return self._exploration_phase_action(stock, cooperation_ratio)
        elif current_round <= self.exploitation_end:
            return self._exploitation_phase_action(stock, cooperation_ratio)
        else:
            return self._endgame_phase_action(stock, cooperation_ratio, current_round)

    def _exploration_phase_action(self, stock, cooperation_ratio):
        """Decision logic for exploration phase (first 20% of rounds)."""
        if stock < self.crisis_threshold:
            return Action.C
        elif cooperation_ratio > 0.5:
            return Action.D
        elif self._is_stock_declining_rapidly(stock):
            if random.random() < 0.3:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _exploitation_phase_action(self, stock, cooperation_ratio):
        """Decision logic for exploitation phase (middle 60% of rounds)."""
        if stock < self.exploitation_threshold:
            if cooperation_ratio > 0.6:
                return Action.C
            else:
                return Action.D
        elif cooperation_ratio > 0.5:
            return Action.D
        elif stock > self.capacity * 0.8 and cooperation_ratio < 0.2:
            if random.random() < 0.2:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _endgame_phase_action(self, stock, cooperation_ratio, current_round):
        """Decision logic for endgame phase (final 20% of rounds)."""
        rounds_remaining = self.n_rounds - current_round
        if rounds_remaining <= 2:
            return Action.D
        elif stock < self.capacity / 6:
            if cooperation_ratio > 0.7:
                return Action.C
            else:
                return Action.D
        elif cooperation_ratio > 0.4:
            return Action.D
        elif random.random() < 0.8:
            return Action.D
        else:
            return Action.C

    def _is_stock_declining_rapidly(self, current_stock):
        """Check if stock is declining by more than 25% per round."""
        return current_stock < 0.75 * self.capacity

class Strategy_AGGRESSIVE_73(BaseStrategy):
    """
    Aggressive Adaptive Strategy: "Opportunistic Exploiter"
    
    Maximizes individual payoffs through calculated aggression while maintaining
    resource base when necessary for long-term exploitation. Uses phase-based
    decision making with opponent tracking and adaptive thresholds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.aggression_modifier = 1.0
        self.low_stock_counter = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = state.round_number
        stock = state.current_stock
        if current_round > 2 * self.n_rounds // 3:
            if current_round > self.n_rounds - 3:
                return Action.D
            elif stock > self.capacity / 3:
                return Action.D
        cooperation_rate = self._calculate_cooperation_rate(history)
        self._update_adaptive_thresholds(stock, cooperation_rate)
        high_threshold = 3 * self.capacity / 4 * self.aggression_modifier
        med_threshold = self.capacity / 2 * self.aggression_modifier
        low_threshold = self.capacity / 4 * self.aggression_modifier
        if current_round <= self.n_rounds // 3:
            return self._early_exploitation_logic(stock, history, high_threshold, low_threshold)
        return self._strategic_adaptation_logic(stock, cooperation_rate, high_threshold, med_threshold, low_threshold)

    def _calculate_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate opponent cooperation rate over last 3 rounds"""
        if history.round_number == 0:
            return 0.0
        window = min(3, history.round_number)
        recent_actions = history.opponent_actions[-window:, :]
        total_actions = recent_actions.size
        if total_actions == 0:
            return 0.0
        cooperations = np.sum(recent_actions)
        return cooperations / total_actions

    def _update_adaptive_thresholds(self, stock: float, cooperation_rate: float):
        """Update aggression thresholds based on stock and opponent behavior"""
        if stock < self.capacity / 2:
            self.low_stock_counter += 1
        else:
            self.low_stock_counter = 0
        if self.low_stock_counter >= 3:
            self.aggression_modifier = 0.75
        elif cooperation_rate > 0.7:
            self.aggression_modifier = 1.25
        else:
            self.aggression_modifier = 1.0

    def _early_exploitation_logic(self, stock: float, history: PlayerHistory, high_threshold: float, low_threshold: float) -> Action:
        """Phase 1 decision logic"""
        if stock > high_threshold:
            return Action.D
        if history.round_number > 0 and np.any(history.opponent_actions[-1, :]):
            return Action.D
        if stock < low_threshold:
            return Action.C
        return Action.D

    def _strategic_adaptation_logic(self, stock: float, cooperation_rate: float, high_threshold: float, med_threshold: float, low_threshold: float) -> Action:
        """Phase 2 decision logic"""
        if stock > high_threshold:
            return Action.D
        if stock > med_threshold:
            if cooperation_rate < 0.25:
                return Action.D
            elif cooperation_rate > 0.75:
                return Action.D
            return Action.D
        if stock <= low_threshold:
            return Action.C
        if cooperation_rate > 0.6:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_74(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES) - Maximizes immediate gains while maintaining
    just enough sustainability to continue exploiting the resource pool through aggressive opportunism.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        stock = state.current_stock
        round_num = state.round_number
        stock_ratio = stock / self.capacity
        rounds_remaining = self.r - round_num
        if stock < self.capacity * 0.1:
            return Action.C
        if rounds_remaining <= 2:
            return Action.D
        if stock_ratio > 0.7:
            return Action.D
        cooperation_rates = self._calculate_opponent_cooperation_rates(history)
        exploitable_opponents = sum((1 for rate in cooperation_rates if rate > 0.6))
        if stock_ratio >= 0.3:
            if exploitable_opponents > self.n / 2:
                return Action.D
            if self._recent_depletion_rate(history, 3) > stock / 4:
                return Action.C
            return Action.D
        my_recent_coop = self._my_cooperation_rate(history, 2)
        avg_opponent_coop = self._average_opponent_cooperation(history, 2)
        if my_recent_coop > avg_opponent_coop:
            return Action.D
        return Action.C

    def _calculate_opponent_cooperation_rates(self, history: PlayerHistory) -> list:
        """Calculate cooperation rate for each opponent over all observed rounds."""
        rates = []
        for opponent_idx in range(self.n - 1):
            total_actions = len(history.opponent_actions)
            if total_actions == 0:
                rates.append(0.0)
            else:
                cooperations = sum(history.opponent_actions[:, opponent_idx])
                rates.append(cooperations / total_actions)
        return rates

    def _recent_depletion_rate(self, history: PlayerHistory, lookback: int) -> float:
        """Calculate recent stock depletion rate over last 'lookback' rounds."""
        if len(history.my_payoffs) < 2:
            return 0.0
        rounds_to_check = min(lookback, len(history.my_payoffs) - 1)
        if rounds_to_check <= 0:
            return 0.0
        recent_payoffs = history.my_payoffs[-rounds_to_check:]
        my_recent_actions = history.my_actions[-rounds_to_check:]
        estimated_stocks = []
        for i, (payoff, action) in enumerate(zip(recent_payoffs, my_recent_actions)):
            if action:
                estimated_stock = payoff * 2 * self.n
            else:
                estimated_stock = payoff * self.n
            estimated_stocks.append(estimated_stock)
        if len(estimated_stocks) < 2:
            return 0.0
        total_depletion = estimated_stocks[0] - estimated_stocks[-1]
        return total_depletion / rounds_to_check

    def _my_cooperation_rate(self, history: PlayerHistory, lookback: int) -> float:
        """Calculate my cooperation rate over last 'lookback' rounds."""
        if len(history.my_actions) == 0:
            return 0.0
        rounds_to_check = min(lookback, len(history.my_actions))
        recent_actions = history.my_actions[-rounds_to_check:]
        return sum(recent_actions) / len(recent_actions)

    def _average_opponent_cooperation(self, history: PlayerHistory, lookback: int) -> float:
        """Calculate average opponent cooperation rate over last 'lookback' rounds."""
        if len(history.opponent_actions) == 0:
            return 0.0
        rounds_to_check = min(lookback, len(history.opponent_actions))
        recent_opponent_actions = history.opponent_actions[-rounds_to_check:, :]
        total_cooperations = np.sum(recent_opponent_actions)
        total_actions = recent_opponent_actions.size
        return total_cooperations / total_actions if total_actions > 0 else 0.0

class Strategy_AGGRESSIVE_75(BaseStrategy):
    """
    PREDATOR STRATEGY: Aggressive opportunistic resource extraction that exploits
    cooperative opponents while maintaining just enough resource sustainability
    to continue the game. Uses adaptive thresholds based on opponent behavior
    and becomes increasingly aggressive towards endgame.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = state.round_number
        stock = state.current_stock
        rounds_remaining = self.n_rounds - current_round
        if rounds_remaining <= 2:
            return Action.D
        if stock < self.capacity / 10:
            if current_round >= 2:
                recent_my_actions = history.my_actions[-2:]
                if np.all(recent_my_actions):
                    return Action.D
            return Action.C
        base_threshold = self.capacity / 4
        if current_round > 3:
            recent_rounds = min(3, current_round)
            recent_opponent_actions = history.opponent_actions[-recent_rounds:, :]
            total_opponent_actions = recent_opponent_actions.size
            total_cooperations = np.sum(recent_opponent_actions)
            recent_coop_rate = total_cooperations / total_opponent_actions
            if recent_coop_rate > 0.6:
                threshold = self.capacity / 3
            elif recent_coop_rate < 0.3:
                threshold = self.capacity / 5
            else:
                threshold = base_threshold
        else:
            threshold = base_threshold
        if rounds_remaining <= self.n_rounds / 4:
            threshold = threshold * 0.75
        if stock > threshold:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_76(BaseStrategy):
    """
    Aggressive Adaptive Strategy: "Resource Predator"
    
    Operates on aggressive exploitation with calculated sustainability, aiming to extract
    maximum value while maintaining just enough resource base to continue profiting.
    Uses three phases: early dominance testing, middle pattern exploitation, and endgame
    maximum extraction with adaptive mechanisms based on opponent behavior and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.opponent_cooperation_rates = [0.0] * (self.n_players - 1)
        self.consecutive_low_stock_count = 0
        self.last_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number + 1
        stock_ratio = state.current_stock / self.capacity
        if history is None:
            self.last_stock = state.current_stock
            return Action.D
        self._update_tracking(state, history)
        if current_round == self.n_rounds:
            return Action.D
        if stock_ratio < 0.1 and self.consecutive_low_stock_count >= 2:
            return Action.C
        phase = self._determine_phase(current_round)
        if phase == 'early':
            return self._early_phase_logic(current_round, stock_ratio)
        elif phase == 'middle':
            return self._middle_phase_logic(stock_ratio, history)
        else:
            return self._endgame_logic(current_round, stock_ratio, history)

    def _update_tracking(self, state: CommonPoolState, history: PlayerHistory):
        """Update tracking variables for adaptive behavior"""
        stock_ratio = state.current_stock / self.capacity
        if stock_ratio < 0.1:
            self.consecutive_low_stock_count += 1
        else:
            self.consecutive_low_stock_count = 0
        if len(history.opponent_actions) >= 1:
            lookback = min(3, len(history.opponent_actions))
            for i in range(self.n_players - 1):
                recent_actions = history.opponent_actions[-lookback:, i]
                self.opponent_cooperation_rates[i] = np.mean(recent_actions)
        self.last_stock = state.current_stock

    def _determine_phase(self, round_num):
        """Determine which phase of the game we're in"""
        if round_num <= self.n_rounds // 3:
            return 'early'
        elif round_num <= 2 * self.n_rounds // 3:
            return 'middle'
        else:
            return 'endgame'

    def _early_phase_logic(self, round_num, stock_ratio):
        """Phase 1: Early rounds - establish dominance and test resilience"""
        if round_num == 1:
            return Action.D
        if stock_ratio > 0.7:
            return Action.D
        elif stock_ratio >= 0.4:
            return Action.D if random.random() < 0.7 else Action.C
        else:
            return Action.C

    def _middle_phase_logic(self, stock_ratio, history):
        """Phase 2: Middle rounds - exploit patterns and maintain advantage"""
        if stock_ratio > 0.8:
            return Action.D
        if stock_ratio < 0.2:
            return Action.C
        avg_opponent_cooperation = np.mean(self.opponent_cooperation_rates)
        if avg_opponent_cooperation > 0.6:
            return Action.D if random.random() < 0.8 else Action.C
        elif avg_opponent_cooperation < 0.3:
            return Action.C if random.random() < 0.7 else Action.D
        elif stock_ratio > 0.5:
            return Action.D if random.random() < 0.6 else Action.C
        else:
            return Action.C if random.random() < 0.6 else Action.D

    def _endgame_logic(self, round_num, stock_ratio, history):
        """Phase 3: Endgame - maximum extraction with calculated timing"""
        remaining_rounds = self.n_rounds - round_num + 1
        if stock_ratio > 0.5:
            endgame_fraction = (self.n_rounds - round_num) / (self.n_rounds // 3)
            if endgame_fraction > 0.33:
                return Action.D
            else:
                return Action.C if stock_ratio < 0.15 else Action.D
        elif len(history.my_actions) >= 2:
            recent_payoffs = history.my_payoffs[-2:]
            if len(recent_payoffs) >= 2 and recent_payoffs[-1] > recent_payoffs[-2]:
                return Action.D
            else:
                return Action.C
        else:
            return Action.C if stock_ratio < 0.3 else Action.D

class Strategy_AGGRESSIVE_77(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES)
    
    Maximizes immediate gains through opportunistic aggression while maintaining 
    the resource pool only when absolutely necessary for future exploitation.
    Uses cooperation as a tactical tool rather than a moral imperative.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_cooperation_round = -10

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.last_cooperation_round = -10
            return Action.D
        n = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round = state.round_number
        stock = state.current_stock
        rounds_remaining = total_rounds - current_round
        if rounds_remaining <= total_rounds * 0.2:
            return Action.D
        if current_round <= 3 or stock > capacity / 2:
            return Action.D
        stock_threshold = capacity / (4 * n)
        emergency_threshold = capacity / 8
        opponent_cooperation_rate = 0.0
        if len(history.opponent_actions) > 0:
            last_round_cooperators = sum(history.opponent_actions[-1, :])
            opponent_cooperation_rate = last_round_cooperators / (n - 1)
        rounds_since_cooperation = current_round - self.last_cooperation_round
        if stock < emergency_threshold and rounds_remaining > 4 and (opponent_cooperation_rate > 0.5) and (rounds_since_cooperation > 3):
            self.last_cooperation_round = current_round
            return Action.C
        if stock <= stock_threshold and rounds_remaining > 3:
            self.last_cooperation_round = current_round
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_78(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Opportunistic Predator"
    
    Maximizes immediate gains through aggressive resource extraction while maintaining
    strategic sustainability. Exploits cooperative opponents and accelerates extraction
    in endgame scenarios.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        stock = state.current_stock
        if history is None:
            return Action.D
        rounds_remaining = self.n_rounds - current_round
        if rounds_remaining <= 2:
            return Action.D
        if rounds_remaining <= 4 and stock > self.capacity * 0.25:
            return Action.D
        high_threshold = self.capacity * 0.4
        low_threshold = self.capacity * 0.15
        threshold_modifier = 0
        if current_round >= 3:
            recent_rounds = min(3, current_round)
            start_idx = current_round - recent_rounds
            opponent_defects = 0
            total_opponent_actions = 0
            for round_idx in range(start_idx, current_round):
                round_defects = np.sum(history.opponent_actions[round_idx, :] == False)
                opponent_defects += round_defects
                total_opponent_actions += self.n_players - 1
            if total_opponent_actions > 0:
                opponent_defection_rate = opponent_defects / total_opponent_actions
                if opponent_defection_rate < 0.3:
                    threshold_modifier = 0.1
                elif opponent_defection_rate > 0.7:
                    threshold_modifier = -0.05
        adjusted_high_threshold = high_threshold + self.capacity * threshold_modifier
        if stock > adjusted_high_threshold:
            return Action.D
        elif stock > low_threshold:
            return Action.C
        else:
            return Action.C

class Strategy_AGGRESSIVE_79(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES)
    
    Maximizes immediate gains through intelligent opportunism while strategically 
    preserving just enough resources to maintain extraction opportunities.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.base_exploitation_threshold = max(0.3, 1.0 / (2 * game_description.n_players))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        current_round = state.round_number
        rounds_remaining = r - current_round
        if rounds_remaining == 0:
            return Action.D
        my_defection_rate = np.sum(history.my_actions == False) / len(history.my_actions)
        opponent_cooperation_rate = np.mean(history.opponent_actions)
        exploitation_threshold = self.base_exploitation_threshold
        if current_stock < capacity * 0.5 and my_defection_rate > 0.8:
            exploitation_threshold -= 0.1
        elif current_stock > capacity * 0.7 and my_defection_rate < 0.6:
            exploitation_threshold += 0.1
        stock_ratio = current_stock / capacity
        if stock_ratio > exploitation_threshold:
            return Action.D
        if current_stock <= n:
            if rounds_remaining > 2 and my_defection_rate < 0.7:
                return Action.C
            else:
                return Action.D
        if opponent_cooperation_rate > 0.5:
            if current_stock > 2 * n:
                return Action.D
            elif random.random() < 0.8 * opponent_cooperation_rate:
                return Action.C
            else:
                return Action.D
        elif rounds_remaining <= 3:
            return Action.D
        elif current_stock < n * 1.5:
            return Action.C
        else:
            return Action.D
        if current_round <= 3:
            if len(history.opponent_actions) > 0:
                last_round_all_coop = np.all(history.opponent_actions[-1, :])
                if last_round_all_coop:
                    return Action.D
                elif stock_ratio > 0.8:
                    return Action.D
        if rounds_remaining <= 3:
            if rounds_remaining == 3 and stock_ratio > 0.2:
                return Action.D
            elif rounds_remaining == 2 and stock_ratio > 0.1:
                return Action.D
            elif rounds_remaining == 1:
                return Action.D
        if len(history.my_payoffs) >= 2:
            prev_payoff = history.my_payoffs[-1]
            current_potential = current_stock / (2 * n) if current_stock > 0 else 0
            if current_potential > prev_payoff * 1.3:
                return Action.D
        if len(history.opponent_actions) >= 2:
            my_recent_defections = np.sum(history.my_actions[-2:] == False)
            opponent_recent_defections = np.sum(history.opponent_actions[-2:, :] == False)
            if my_recent_defections > 0:
                opponent_defection_rate_recent = opponent_recent_defections / (2 * n)
                if opponent_defection_rate_recent > opponent_cooperation_rate:
                    if rounds_remaining > 5:
                        return Action.C
        return Action.C

class Strategy_AGGRESSIVE_80(BaseStrategy):
    """
    Aggressive Opportunistic Strategy: "Predator"
    
    Operates on aggressive resource extraction while maintaining sustainability.
    Maximizes immediate gains while ensuring resource doesn't collapse completely.
    Uses stock-based thresholds, competitive response, and endgame exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.exploitation_threshold = self.capacity * 0.3
        self.critical_threshold = self.capacity * 0.15
        self.endgame_threshold = self.capacity * 0.25
        self.endgame_start = self.r - max(3, self.r // 5)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        stock = state.current_stock
        if history is None:
            return Action.D
        if current_round == self.r - 1:
            return Action.D
        if stock < self.critical_threshold:
            return Action.C
        if current_round >= self.endgame_start and stock > self.endgame_threshold:
            return Action.D
        if stock > self.exploitation_threshold:
            return Action.D
        majority_aggression = self._calculate_majority_aggression(history)
        if majority_aggression > 0.6 or majority_aggression <= 0.3:
            return Action.D
        if self._stock_increasing_trend(history):
            return Action.D
        return Action.C

    def _calculate_majority_aggression(self, history: PlayerHistory) -> float:
        """Calculate the aggression level of the majority of opponents."""
        if history.round_number == 0:
            return 0.5
        lookback = min(5, history.round_number)
        recent_actions = history.opponent_actions[-lookback:, :]
        aggression_levels = []
        for player_idx in range(self.n - 1):
            player_actions = recent_actions[:, player_idx]
            defect_count = np.sum(player_actions == False)
            aggression_level = defect_count / len(player_actions)
            aggression_levels.append(aggression_level)
        return np.median(aggression_levels) if aggression_levels else 0.5

    def _stock_increasing_trend(self, history: PlayerHistory) -> bool:
        """Check if stock has been increasing over the last 3 rounds."""
        if history.round_number < 3:
            return False
        recent_payoffs = history.my_payoffs[-3:]
        trend_positive = 0
        for i in range(1, len(recent_payoffs)):
            if recent_payoffs[i] > recent_payoffs[i - 1]:
                trend_positive += 1
        return trend_positive >= 2

class Strategy_AGGRESSIVE_81(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES)
    
    This strategy operates on aggressive opportunism - maximizing immediate gains 
    while strategically preserving just enough resource sustainability to continue 
    exploitation. It assumes opponents are either naive cooperators to be exploited 
    or fellow defectors in a race to depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_critical = self.capacity * 0.15

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_stock < self.threshold_critical:
            return Action.C
        if current_stock < self.n_players * 2:
            return Action.C
        cooperator_ratio = 0.0
        if len(history.opponent_actions) > 0:
            cooperators_last_round = np.sum(history.opponent_actions[-1, :])
            cooperator_ratio = cooperators_last_round / (self.n_players - 1)
        game_progress = current_round / self.n_rounds
        exploitation_multiplier = 1.0 + cooperator_ratio * 0.5
        sustainability_bonus = 1.0 + (self.n_rounds - current_round) / self.n_rounds
        exploitation_opportunity = current_stock / self.n_players * exploitation_multiplier
        cooperation_value = current_stock / (2 * self.n_players) * sustainability_bonus
        depletion_rate = 0.0
        if len(history.my_payoffs) >= 2:
            prev_payoff = history.my_payoffs[-1]
            if history.my_actions[-1]:
                prev_stock_estimate = prev_payoff * 2 * self.n_players
            else:
                prev_stock_estimate = prev_payoff * self.n_players
            if prev_stock_estimate > 0:
                depletion_rate = max(0, (prev_stock_estimate - current_stock) / prev_stock_estimate)
        if game_progress <= 0.25:
            if cooperator_ratio >= 0.5:
                return Action.D
            if current_stock < 0.6 * self.capacity:
                return Action.C
            if len(history.my_payoffs) > 0:
                avg_payoff = np.mean(history.my_payoffs)
                if avg_payoff < self.capacity / (4 * self.n_players):
                    return Action.D
        elif game_progress <= 0.75:
            if current_stock > 0.7 * self.capacity and cooperator_ratio > 0.4:
                return Action.D
            if current_stock < 0.4 * self.capacity or depletion_rate > 0.5:
                return Action.C
            if current_round % 4 == 0:
                return Action.D
        else:
            base_defect_prob = 0.4 + 0.4 * ((game_progress - 0.75) / 0.25)
            if current_stock > 0.5 * self.capacity:
                base_defect_prob += 0.2
            if cooperator_ratio < 0.1:
                return Action.D
            if random.random() < base_defect_prob:
                return Action.D
            else:
                return Action.C
        if exploitation_opportunity > cooperation_value:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_82(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES) - maximizes personal gain while maintaining resource viability.
    Uses phase-based decision making, opponent classification, and stock health monitoring.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = state.round_number
        current_stock = state.current_stock
        exploitation_phase_end = self.r - math.ceil(self.r / 3)
        adaptation_phase_end = self.r - 2
        stock_health = current_stock / self.capacity
        if current_round >= adaptation_phase_end:
            if current_round == self.r - 1:
                return Action.D
            elif current_stock < self.n:
                return Action.C
            else:
                return Action.D
        last_round_defections = sum(history.opponent_actions[-1, :] == False)
        defection_rate = last_round_defections / (self.n - 1)
        if stock_health < 0.25:
            return Action.C
        if current_round < exploitation_phase_end:
            if stock_health < 0.3:
                return Action.C
            elif defection_rate > 0.6:
                return Action.D
            elif defection_rate < 0.2:
                return Action.D
            else:
                coop_prob = 0.7 - defection_rate
                if random.random() < coop_prob:
                    return Action.C
                else:
                    return Action.D
        else:
            rounds_to_check = min(3, len(history.opponent_actions))
            recent_actions = history.opponent_actions[-rounds_to_check:, :]
            cooperator_count = 0
            aggressive_count = 0
            for player_idx in range(self.n - 1):
                player_actions = recent_actions[:, player_idx]
                coop_rate = sum(player_actions) / len(player_actions)
                if coop_rate > 0.66:
                    cooperator_count += 1
                elif coop_rate < 0.33:
                    aggressive_count += 1
            if stock_health < 0.25:
                return Action.C
            elif cooperator_count >= (self.n - 1) / 2:
                return Action.D
            elif aggressive_count >= 2 * (self.n - 1) / 3:
                if random.random() < 0.4:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D

class Strategy_AGGRESSIVE_83(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES)
    
    Maximizes immediate gains through aggressive opportunism while strategically
    preserving resources only when necessary. Uses opponent classification,
    dynamic stock management, and phase-based exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_num = history.round_number
        stock = state.current_stock
        remaining_rounds = self.n_rounds - round_num - 1
        endgame_threshold = max(3, int(0.2 * self.n_rounds))
        if remaining_rounds <= endgame_threshold:
            return Action.D
        if round_num < 3:
            if stock < self.n_players:
                return Action.C
            return Action.D
        if stock < 1.5 * self.n_players and remaining_rounds > 2:
            return Action.C
        cooperator_ratio = self._get_cooperator_ratio_last_n_rounds(history, 3)
        if cooperator_ratio > 0.6 and stock > 2 * self.n_players:
            return Action.D
        if round_num > 0:
            my_last_action = history.my_actions[-1]
            opponent_defections_last = sum(~history.opponent_actions[-1, :])
            my_defections_last = 0 if my_last_action else 1
            if my_defections_last > opponent_defections_last:
                return Action.D if random.random() < 0.8 else Action.C
            else:
                return Action.C if random.random() < 0.7 else Action.D
        return self._adaptive_decision(state, history, remaining_rounds)

    def _get_cooperator_ratio_last_n_rounds(self, history: PlayerHistory, n: int) -> float:
        """Calculate the ratio of cooperators in the last n rounds."""
        if history.round_number == 0:
            return 0.0
        start_round = max(0, history.round_number - n)
        relevant_actions = history.opponent_actions[start_round:, :]
        if relevant_actions.size == 0:
            return 0.0
        total_cooperations = np.sum(relevant_actions)
        total_actions = relevant_actions.size
        return total_cooperations / total_actions if total_actions > 0 else 0.0

    def _adaptive_decision(self, state: CommonPoolState, history: PlayerHistory, remaining_rounds: int) -> Action:
        """Make adaptive decision based on stock management and opponent behavior."""
        stock = state.current_stock
        critical_stock = self.n_players * (remaining_rounds / self.n_rounds) * 0.8
        sustainable_stock = self.capacity * 0.4
        if stock < critical_stock:
            return Action.C if random.random() < 0.9 else Action.D
        elif stock > sustainable_stock:
            return Action.D if random.random() < 0.8 else Action.C
        else:
            return self._opponent_based_decision(history, stock)

    def _opponent_based_decision(self, history: PlayerHistory, stock: float) -> Action:
        """Make decision based on opponent classification."""
        if history.round_number < 2:
            return Action.D
        lookback = min(5, history.round_number)
        recent_actions = history.opponent_actions[-lookback:, :]
        coop_rates = np.mean(recent_actions, axis=0)
        avg_coop_rate = np.mean(coop_rates)
        if avg_coop_rate > 0.8:
            return Action.D
        elif avg_coop_rate < 0.4:
            return Action.C if stock < 0.8 * self.n_players else Action.D
        else:
            return self._exploitation_burst_decision(history, stock)

    def _exploitation_burst_decision(self, history: PlayerHistory, stock: float) -> Action:
        """Decide whether to execute exploitation burst."""
        remaining_rounds = self.n_rounds - history.round_number - 1
        if stock > 3 * self.n_players and remaining_rounds > 4:
            if history.round_number > 0:
                last_round_coop = np.mean(history.opponent_actions[-1, :])
                if last_round_coop > 0.5:
                    return Action.D
        if history.round_number > 0 and stock < self.n_players:
            return Action.C
        return Action.D if random.random() < 0.6 else Action.C

class Strategy_AGGRESSIVE_84(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Predator"
    
    Operates on aggressive exploitation with calculated sustainability.
    Maximizes extraction while maintaining just enough resource viability.
    Adapts aggression based on stock levels, opponent behavior, and game progression.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        if history is None:
            return Action.D
        round_number = history.round_number
        rounds_remaining = self.n_rounds - round_number - 1
        if rounds_remaining == 0:
            return Action.D
        if current_stock < self.capacity * 0.15:
            return Action.C
        if rounds_remaining == 1:
            if current_stock < self.capacity * 0.1:
                return Action.C
            return Action.D
        if rounds_remaining <= 1:
            return Action.D
        defection_ratio = self._get_defection_ratio_last_round(history)
        majority_defected = defection_ratio >= 0.5
        if current_stock >= self.capacity * 0.3:
            if majority_defected:
                return Action.D
            if current_stock >= self.capacity * 0.7:
                return Action.D
        if current_stock >= self.capacity * 0.15:
            if defection_ratio >= 0.5:
                return Action.D
            if self._am_falling_behind(history):
                return Action.D
            if self._stock_declining_trend(history) and rounds_remaining > 3:
                return Action.D
            if rounds_remaining <= self.n_rounds * 0.25:
                return Action.D
        return Action.C

    def _get_defection_ratio_last_round(self, history: PlayerHistory) -> float:
        """Calculate the ratio of opponents who defected in the last round."""
        if history.round_number == 0:
            return 0.0
        last_round_actions = history.opponent_actions[-1, :]
        defectors = np.sum(last_round_actions == False)
        return defectors / self.n_players

    def _am_falling_behind(self, history: PlayerHistory) -> bool:
        """Check if current player is falling behind average cumulative payoff."""
        my_total = np.sum(history.my_payoffs)
        opponent_totals = np.sum(history.opponent_payoffs, axis=0)
        avg_opponent_total = np.mean(opponent_totals)
        return my_total < avg_opponent_total * 0.9

    def _stock_declining_trend(self, history: PlayerHistory) -> bool:
        """Check if stock has been declining over recent rounds."""
        if history.round_number < 3:
            return False
        recent_payoffs = history.my_payoffs[-3:]
        if len(recent_payoffs) < 3:
            return False
        return recent_payoffs[-1] < recent_payoffs[0]

class Strategy_AGGRESSIVE_85(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES)
    
    An intelligent aggressive strategy that maximizes personal payoffs while 
    strategically managing the resource. Operates through three phases:
    exploration, exploitation, and endgame extraction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.exploration_end = min(3, self.n_rounds // 3)
        self.endgame_start = max(self.n_rounds - max(2, self.n_rounds // 4), self.n_rounds - 2)
        self.base_cooperation_threshold = 0.3
        self.emergency_threshold = 0.15
        self.recovery_threshold = 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number
        stock_health = state.current_stock / self.capacity
        rounds_remaining = self.n_rounds - current_round - 1
        if stock_health < self.emergency_threshold:
            return Action.C
        if current_round >= self.endgame_start or rounds_remaining <= 1:
            if state.current_stock < self.n_players:
                return Action.D
            return Action.D
        last_round_actions = history.opponent_actions[-1, :]
        cooperators_last_round = sum(last_round_actions)
        cooperation_rate = cooperators_last_round / self.n_players
        total_opponent_defections = sum((sum(~history.opponent_actions[i, :]) for i in range(current_round)))
        total_opponent_actions = current_round * self.n_players
        avg_opponent_aggression = total_opponent_defections / total_opponent_actions if total_opponent_actions > 0 else 0
        cooperation_threshold = self.base_cooperation_threshold
        if avg_opponent_aggression > 0.8:
            cooperation_threshold *= 0.7
        elif avg_opponent_aggression < 0.3:
            cooperation_threshold *= 1.3
        if current_round < self.exploration_end:
            if stock_health < cooperation_threshold:
                return Action.C
            elif cooperation_rate < 0.5:
                return Action.D
            elif cooperation_rate > 0.7:
                return Action.D
            else:
                return Action.C
        elif rounds_remaining <= 2:
            return Action.D
        elif cooperation_rate >= 0.5:
            return Action.D
        elif cooperation_rate <= 0.2 and stock_health < 0.4:
            return Action.C
        elif stock_health > 0.6:
            return Action.D
        elif random.random() < 0.7:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_86(BaseStrategy):
    """
    Opportunistic Predator: An aggressive exploitation strategy that maximizes individual 
    extraction while maintaining just enough resource sustainability to continue profiting.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_num = state.round_number + 1
        if history is None:
            return Action.D
        if current_stock < 0.3 * self.n:
            return Action.C
        if round_num > self.r - 3:
            return Action.D
        coop_rate = self._calculate_opponent_cooperation_rate(history, 3)
        if current_stock >= 1.5 * self.n:
            return Action.D
        elif current_stock < 0.75 * self.n:
            phase = self._classify_phase(round_num)
            if phase == 'end' and current_stock > 0.5 * self.n:
                return Action.D
            return Action.C
        if coop_rate >= 0.7:
            return Action.D
        elif coop_rate <= 0.3:
            return Action.D
        else:
            phase = self._classify_phase(round_num)
            if phase == 'early':
                return Action.D
            elif phase == 'middle':
                return Action.D if current_stock > self.n else Action.C
            else:
                return Action.D

    def _classify_phase(self, round_num):
        """Classify current phase based on round number."""
        third = self.r / 3
        if round_num <= third:
            return 'early'
        elif round_num <= 2 * third:
            return 'middle'
        else:
            return 'end'

    def _calculate_opponent_cooperation_rate(self, history, lookback_rounds):
        """Calculate cooperation rate of opponents over the last N rounds."""
        if history.round_number == 0:
            return 0.5
        actual_lookback = min(lookback_rounds, history.round_number)
        if actual_lookback == 0:
            return 0.5
        recent_actions = history.opponent_actions[-actual_lookback:, :]
        total_cooperations = np.sum(recent_actions)
        total_actions = actual_lookback * (self.n - 1)
        if total_actions == 0:
            return 0.5
        return total_cooperations / total_actions

class Strategy_AGGRESSIVE_87(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Predator"
    
    Operates on aggressive resource extraction while maintaining minimal restraint
    to keep the resource pool viable. Exploits cooperative players while avoiding
    total resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.n_rounds:
            return Action.D
        if state.current_stock < self.capacity * 0.15:
            return Action.C
        if state.current_stock <= self.capacity * 0.05:
            return Action.C
        last_round_actions = history.opponent_actions[-1, :]
        cooperator_count = sum(last_round_actions)
        total_opponents = len(last_round_actions)
        cooperator_ratio = cooperator_count / total_opponents if total_opponents > 0 else 0
        defector_ratio = 1 - cooperator_ratio
        if cooperator_ratio >= 0.6:
            return Action.D
        stock_declining = False
        if len(history.my_payoffs) >= 2:
            recent_avg = np.mean(history.my_payoffs[-2:])
            if len(history.my_payoffs) >= 4:
                earlier_avg = np.mean(history.my_payoffs[-4:-2])
                stock_declining = recent_avg < earlier_avg * 0.9
        if defector_ratio >= 0.7 and stock_declining:
            return Action.C
        if len(history.opponent_actions) >= 3:
            recent_rounds = history.opponent_actions[-3:, :]
            all_defected_rounds = 0
            for round_actions in recent_rounds:
                if sum(round_actions) == 0:
                    all_defected_rounds += 1
            if all_defected_rounds >= 3 and state.current_stock < self.capacity * 0.2:
                return Action.C
        if len(history.opponent_actions) >= 3:
            recent_defection_rate = 1 - np.mean(history.opponent_actions[-3:, :])
            if recent_defection_rate > 0.8:
                if cooperator_ratio >= 0.5:
                    return Action.D
        return Action.D

class Strategy_AGGRESSIVE_88(BaseStrategy):
    """
    Aggressive Adaptive Strategy: "Opportunistic Exploiter"
    
    This strategy maximizes individual payoffs by aggressively exploiting cooperative 
    opponents while protecting against being exploited. It always defects in the first 
    and last rounds, adaptively exploits cooperators in middle rounds, and includes 
    emergency cooperation when stock levels become critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.punishment_debt = np.zeros(self.n_players - 1)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.n_rounds - 1:
            return Action.D
        cooperative_ratio = self._calculate_cooperative_ratio(history)
        recent_defection_rate = self._calculate_recent_defection_rate(history)
        my_recent_payoff = self._calculate_my_recent_payoff(history)
        avg_opponent_payoff = self._calculate_avg_opponent_payoff(history)
        self._update_punishment_debt(history, current_stock)
        critical_threshold = self.capacity * 0.25
        low_threshold = self.capacity * 0.3
        very_low_threshold = self.capacity * 0.1
        if current_stock < very_low_threshold:
            expected_defections = self._estimate_opponent_defections(history)
            if expected_defections >= self.n_players - 2:
                return Action.D
            else:
                return Action.C
        if current_stock < critical_threshold and current_round < self.n_rounds - 1:
            likely_cooperators = self._count_likely_cooperators(history)
            if likely_cooperators > self.n_players // 2:
                return Action.C
            else:
                return Action.D
        if cooperative_ratio > 0.6:
            return Action.D
        elif current_stock < low_threshold:
            if recent_defection_rate > 0.7:
                return Action.C
            else:
                return Action.D
        elif my_recent_payoff < avg_opponent_payoff:
            return Action.D
        else:
            if self._all_opponents_cooperated_last_round(history) and current_stock > self.capacity * 0.5:
                return Action.D
            if np.sum(self.punishment_debt) > 0:
                return Action.D
            else:
                return Action.D

    def _calculate_cooperative_ratio(self, history: PlayerHistory) -> float:
        """Calculate the ratio of cooperative opponents over recent rounds."""
        if history.round_number < 1:
            return 0.0
        lookback = min(3, history.round_number)
        recent_actions = history.opponent_actions[-lookback:, :]
        total_decisions = recent_actions.size
        if total_decisions == 0:
            return 0.0
        cooperative_decisions = np.sum(recent_actions)
        return cooperative_decisions / total_decisions

    def _calculate_recent_defection_rate(self, history: PlayerHistory) -> float:
        """Calculate recent defection rate across all players."""
        if history.round_number < 1:
            return 0.0
        lookback = min(3, history.round_number)
        recent_actions = history.opponent_actions[-lookback:, :]
        total_decisions = recent_actions.size
        if total_decisions == 0:
            return 0.0
        defection_decisions = np.sum(~recent_actions)
        return defection_decisions / total_decisions

    def _calculate_my_recent_payoff(self, history: PlayerHistory) -> float:
        """Calculate my average payoff over recent rounds."""
        if history.round_number < 1:
            return 0.0
        lookback = min(3, history.round_number)
        recent_payoffs = history.my_payoffs[-lookback:]
        return np.mean(recent_payoffs)

    def _calculate_avg_opponent_payoff(self, history: PlayerHistory) -> float:
        """Calculate average opponent payoff over recent rounds."""
        if history.round_number < 1:
            return 0.0
        lookback = min(3, history.round_number)
        recent_payoffs = history.opponent_payoffs[-lookback:, :]
        return np.mean(recent_payoffs)

    def _update_punishment_debt(self, history: PlayerHistory, current_stock: float):
        """Update punishment debt for opponents who defected when stock was healthy."""
        if history.round_number < 1:
            return
        last_round_actions = history.opponent_actions[-1, :]
        healthy_stock_threshold = self.capacity * 0.5
        if current_stock > healthy_stock_threshold:
            for i, action in enumerate(last_round_actions):
                if not action:
                    self.punishment_debt[i] += 1.0
        if current_stock < healthy_stock_threshold:
            for i in range(len(self.punishment_debt)):
                if self._opponent_sustained_cooperation(history, i):
                    self.punishment_debt[i] = max(0, self.punishment_debt[i] - 0.5)

    def _opponent_sustained_cooperation(self, history: PlayerHistory, opponent_idx: int) -> bool:
        """Check if opponent has shown sustained cooperation (3+ rounds)."""
        if history.round_number < 3:
            return False
        recent_actions = history.opponent_actions[-3:, opponent_idx]
        return np.sum(recent_actions) >= 3

    def _estimate_opponent_defections(self, history: PlayerHistory) -> int:
        """Estimate how many opponents will defect next round."""
        if history.round_number < 1:
            return self.n_players - 1
        last_round_defections = np.sum(~history.opponent_actions[-1, :])
        return int(last_round_defections)

    def _count_likely_cooperators(self, history: PlayerHistory) -> int:
        """Count opponents likely to cooperate based on recent behavior."""
        if history.round_number < 1:
            return 0
        likely_cooperators = 0
        for i in range(self.n_players - 1):
            lookback = min(3, history.round_number)
            recent_actions = history.opponent_actions[-lookback:, i]
            cooperation_rate = np.mean(recent_actions)
            if cooperation_rate >= 0.67:
                likely_cooperators += 1
        return likely_cooperators

    def _all_opponents_cooperated_last_round(self, history: PlayerHistory) -> bool:
        """Check if all opponents cooperated in the last round."""
        if history.round_number < 1:
            return False
        last_round_actions = history.opponent_actions[-1, :]
        return np.all(last_round_actions)

class Strategy_AGGRESSIVE_89(BaseStrategy):
    """
    AGGRESSIVE EXPLOITATION STRATEGY: "VULTURE"
    
    Operates on opportunistic aggression - maximize immediate gains while strategically 
    preserving the resource only when absolutely necessary. Establishes dominance early,
    exploits cooperative opponents, and uses tactical cooperation only to prevent collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = self.capacity * 0.15
        self.low_threshold = self.capacity * 0.35
        self.healthy_threshold = self.capacity * 0.6

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.n_rounds - 1:
            return Action.D
        recent_rounds = min(3, len(history.opponent_actions))
        cooperative_opponents = 0
        aggressive_opponents = 0
        if recent_rounds > 0:
            for player_idx in range(self.n_players - 1):
                recent_actions = history.opponent_actions[-recent_rounds:, player_idx]
                coop_rate = np.mean(recent_actions)
                if coop_rate >= 0.67:
                    cooperative_opponents += 1
                elif coop_rate <= 0.33:
                    aggressive_opponents += 1
        last_round_opponent_actions = history.opponent_actions[-1, :] if len(history.opponent_actions) > 0 else None
        last_round_cooperators = np.sum(last_round_opponent_actions) if last_round_opponent_actions is not None else 0
        if current_round >= self.n_rounds * 0.75:
            critical_threshold = self.capacity * 0.1
        else:
            critical_threshold = self.critical_threshold
        punishment_triggered = False
        if len(history.opponent_actions) >= 2:
            for player_idx in range(self.n_players - 1):
                if history.opponent_actions[-2, player_idx] == True and history.opponent_actions[-1, player_idx] == False and (current_stock > self.low_threshold):
                    punishment_triggered = True
                    break
        if punishment_triggered:
            return Action.D
        momentum_exploitation = False
        if len(history.my_payoffs) >= 2:
            if current_stock > self.healthy_threshold and current_round >= 2:
                momentum_exploitation = True
        if current_round == self.n_rounds - 2:
            if current_stock <= critical_threshold:
                return Action.C
            elif current_stock > self.healthy_threshold:
                return Action.D
            elif last_round_cooperators > (self.n_players - 1) / 2:
                return Action.C
            else:
                return Action.D
        if current_stock <= critical_threshold:
            if aggressive_opponents > 0.75 * (self.n_players - 1):
                return Action.C
            else:
                return Action.D
        if current_stock > self.low_threshold:
            if cooperative_opponents >= 0.5 * (self.n_players - 1):
                return Action.D
            if last_round_cooperators > (self.n_players - 1) / 2 and current_stock > self.healthy_threshold:
                return Action.D
            if momentum_exploitation:
                return Action.D
        if self.low_threshold < current_stock <= self.healthy_threshold:
            if len(history.my_actions) >= 2 and history.my_actions[-1] == False and (history.my_actions[-2] == False):
                return Action.C
            if aggressive_opponents < 0.25 * (self.n_players - 1):
                return Action.D
            else:
                return Action.C
        return Action.C

class Strategy_AGGRESSIVE_90(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy - maximizes immediate gains while strategically 
    maintaining the resource base only when absolutely necessary for future exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.recent_cooperation_attempts = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.recent_cooperation_attempts = 0
            return Action.D
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        stock = state.current_stock
        round_num = state.round_number
        opponent_defection_rate = self._calculate_recent_defection_rate(history, window=3)
        cooperation_attempts = self._count_recent_cooperation(history, window=3)
        if round_num <= r - 3:
            if stock < capacity * 0.3:
                self.recent_cooperation_attempts = 0
                return Action.C
            elif opponent_defection_rate >= 0.7:
                return Action.D
            elif stock >= capacity * 0.8 and cooperation_attempts < 2:
                return Action.C
            else:
                return Action.D
        elif round_num <= r - 1:
            if stock < capacity * 0.2:
                return Action.C
            elif stock >= capacity * 0.6:
                return Action.D
            else:
                recent_defectors = self._count_recent_defectors(history, window=2)
                return Action.D if recent_defectors >= n / 2 else Action.C
        else:
            return Action.D

    def _calculate_recent_defection_rate(self, history: PlayerHistory, window: int) -> float:
        """Calculate the defection rate of opponents over the last 'window' rounds."""
        if history.round_number == 0:
            return 0.0
        start_round = max(0, history.round_number - window)
        recent_actions = history.opponent_actions[start_round:, :]
        if recent_actions.size == 0:
            return 0.0
        total_actions = recent_actions.size
        total_cooperations = np.sum(recent_actions)
        total_defections = total_actions - total_cooperations
        return total_defections / total_actions

    def _count_recent_cooperation(self, history: PlayerHistory, window: int) -> int:
        """Count my cooperation attempts in the last 'window' rounds."""
        if history.round_number == 0:
            return 0
        start_round = max(0, history.round_number - window)
        recent_my_actions = history.my_actions[start_round:]
        return np.sum(recent_my_actions)

    def _count_recent_defectors(self, history: PlayerHistory, window: int) -> int:
        """Count how many opponents defected in recent rounds."""
        if history.round_number == 0:
            return 0
        start_round = max(0, history.round_number - window)
        recent_actions = history.opponent_actions[start_round:, :]
        if recent_actions.size == 0:
            return 0
        n_opponents = recent_actions.shape[1]
        defectors = 0
        for opponent in range(n_opponents):
            opponent_recent_actions = recent_actions[:, opponent]
            if not np.all(opponent_recent_actions):
                defectors += 1
        return defectors

class Strategy_AGGRESSIVE_91(BaseStrategy):
    """
    Aggressive Opportunistic Resource Extraction Strategy.
    
    Operates on aggressive exploitation with calculated restraint. Defects aggressively
    when profitable but switches to cooperation only when necessary to prevent collapse.
    Uses stock thresholds, exploitation momentum, and opportunistic defection rules.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        stock = state.current_stock
        round_num = state.round_number
        if history is None or round_num == 0:
            return Action.D
        if round_num == r - 1:
            return Action.D
        if stock < n:
            return Action.C
        if stock >= 1.5 * capacity:
            return Action.D
        my_last_action = history.my_actions[-1]
        if not my_last_action:
            if len(history.my_actions) >= 2:
                if stock > n:
                    return Action.D
        opponent_cooperators = sum(history.opponent_actions[-1, :])
        total_opponents = n - 1
        if opponent_cooperators > total_opponents / 2:
            return Action.D
        coop_consumption = n * stock / (2 * n)
        remaining_after_coop = stock - coop_consumption
        if remaining_after_coop > 0:
            projected_growth = 2 * remaining_after_coop * (1 - remaining_after_coop / capacity)
            projected_stock = remaining_after_coop + projected_growth
            if projected_stock > 1.2 * stock:
                return Action.C
        if len(history.my_actions) >= 2:
            recent_payoffs = history.my_payoffs[-2:]
            if len(recent_payoffs) >= 2:
                payoff_decline = (recent_payoffs[0] - recent_payoffs[1]) / recent_payoffs[0]
                if payoff_decline > 0.4:
                    return Action.C
        return Action.D

class Strategy_AGGRESSIVE_92(BaseStrategy):
    """
    Aggressive Exploitative Strategy: "Stock Predator"
    
    Operates on aggressive resource extraction while maintaining strategic sustainability.
    Exploits cooperative opponents but includes safeguards to prevent complete resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        current_round = state.round_number
        stock_level = state.current_stock
        if stock_level < capacity * 0.15:
            return Action.C
        if current_round == n_rounds - 1:
            return Action.D
        total_opponent_decisions = history.opponent_actions.size
        if total_opponent_decisions > 0:
            total_cooperations = np.sum(history.opponent_actions)
            coop_rate = total_cooperations / total_opponent_decisions
        else:
            coop_rate = 0.5
        if coop_rate > 0.6:
            return Action.D
        if stock_level > capacity * 0.8:
            return Action.D
        recent_rounds = min(2, len(history.my_actions))
        if recent_rounds > 0:
            recent_opponent_actions = history.opponent_actions[-recent_rounds:, :]
            total_recent_decisions = recent_opponent_actions.size
            if total_recent_decisions > 0:
                recent_defections = np.sum(recent_opponent_actions == 0)
                recent_defection_trend = recent_defections / total_recent_decisions
            else:
                recent_defection_trend = 0
        else:
            recent_defection_trend = 0
        if recent_defection_trend > 0.7:
            return Action.D
        if coop_rate < 0.3 and stock_level > capacity * 0.5:
            return Action.D
        if len(history.my_actions) > 0:
            last_round_cooperations = np.sum(history.opponent_actions[-1, :])
            if last_round_cooperations == n_players - 1 and stock_level > capacity * 0.5:
                return Action.D
        if len(history.my_actions) > 0:
            last_round_defections = np.sum(history.opponent_actions[-1, :] == 0)
            if last_round_defections == n_players - 1:
                return Action.D
        return Action.C

class Strategy_AGGRESSIVE_93(BaseStrategy):
    """
    Aggressive Exploitation Strategy: Resource Predator
    
    Operates on aggressive resource extraction while maintaining pool viability.
    Uses threshold-based exploitation with adaptive opponent learning.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.emergency_cooperation_counter = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = state.round_number
        stock = state.current_stock
        stock_ratio = stock / self.capacity
        if current_round == self.n_rounds - 1:
            return Action.D
        if self.emergency_cooperation_counter > 0:
            self.emergency_cooperation_counter -= 1
            return Action.C
        if stock_ratio >= 0.6:
            return Action.D
        elif stock_ratio < 0.1 and current_round >= self.n_rounds - 3:
            return Action.C
        elif stock_ratio < 0.3:
            if stock_ratio < 0.1:
                self.emergency_cooperation_counter = 1
                return Action.C
            else:
                self.emergency_cooperation_counter = 1
                return Action.C
        else:
            return self._conditional_aggression_strategy(history, current_round, stock_ratio)

    def _conditional_aggression_strategy(self, history: PlayerHistory, current_round: int, stock_ratio: float) -> Action:
        """Apply conditional aggression rules for medium stock levels."""
        rounds_to_check = min(3, len(history.opponent_actions))
        if rounds_to_check > 0:
            recent_actions = history.opponent_actions[-rounds_to_check:, :]
            total_decisions = recent_actions.size
            defections = np.sum(~recent_actions)
            opponent_defection_rate = defections / total_decisions if total_decisions > 0 else 0
        else:
            opponent_defection_rate = 0.5
        if opponent_defection_rate > 0.6:
            return Action.D
        elif opponent_defection_rate < 0.3:
            return Action.D
        game_progress = current_round / self.n_rounds
        if game_progress < 0.25:
            return Action.D if random.random() < 0.7 else Action.C
        elif game_progress > 0.8:
            return Action.D
        elif len(history.opponent_actions) > 0:
            last_round_actions = history.opponent_actions[-1, :]
            defectors_last_round = np.sum(~last_round_actions)
            if defectors_last_round > len(last_round_actions) / 2:
                return Action.D
        if len(history.my_payoffs) >= 2:
            recent_payoff_trend = history.my_payoffs[-1] - history.my_payoffs[-2]
            if recent_payoff_trend > 0:
                return Action.D if random.random() < 0.8 else Action.C
        return Action.C

class Strategy_AGGRESSIVE_94(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Resource Predator"
    
    Operates on aggressive resource extraction with calculated sustainability.
    Always defects in round 1, then uses dynamic thresholds based on stock levels,
    opponent behavior analysis, and endgame acceleration to maximize individual payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.initial_capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = state.round_number
        current_stock = state.current_stock
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.initial_capacity
        if current_stock < capacity * 0.3:
            return Action.C
        if current_round >= n_rounds - 1:
            return Action.D
        endgame_threshold = max(1, int(n_rounds * 0.8))
        if current_round >= endgame_threshold:
            if current_stock < capacity * 0.1:
                return Action.C
            else:
                return Action.D
        if current_stock < capacity * 0.05:
            return Action.C
        rounds_to_check = min(3, current_round)
        if rounds_to_check > 0:
            recent_opponent_actions = history.opponent_actions[-rounds_to_check:, :]
            total_opponent_cooperations = np.sum(recent_opponent_actions)
            total_possible_cooperations = (n_players - 1) * rounds_to_check
            if total_possible_cooperations > 0:
                coop_ratio = total_opponent_cooperations / total_possible_cooperations
                if coop_ratio > 0.6:
                    return Action.D
                elif coop_ratio < 0.3:
                    return Action.D
        if current_round > 0:
            if len(history.my_payoffs) >= 2:
                recent_payoffs = history.my_payoffs[-2:]
                if len(recent_payoffs) >= 2 and recent_payoffs[-1] > recent_payoffs[-2]:
                    return Action.D
        if current_round >= 5:
            total_rounds_checked = min(5, current_round)
            recent_actions = history.opponent_actions[-total_rounds_checked:, :]
            total_cooperations = np.sum(recent_actions)
            total_possible = (n_players - 1) * total_rounds_checked
            if total_possible > 0 and total_cooperations / total_possible > 0.8:
                my_recent_actions = history.my_actions[-min(3, current_round):]
                recent_defections = np.sum(my_recent_actions == False)
                if recent_defections >= 2 and random.random() < 0.3:
                    return Action.C
                else:
                    return Action.D
        if current_round >= 3:
            total_recent = min(current_round, 7)
            recent_actions = history.opponent_actions[-total_recent:, :]
            coop_rate = np.sum(recent_actions) / ((n_players - 1) * total_recent)
            if coop_rate > 0.7:
                if current_stock < capacity * 0.2:
                    return Action.C
        if current_round >= 3:
            last_3_rounds = history.opponent_actions[-3:, :]
            avg_cooperation = np.mean(last_3_rounds)
            if avg_cooperation < 0.2 and random.random() < 0.15:
                return Action.C
        return Action.D

class Strategy_AGGRESSIVE_95(BaseStrategy):
    """
    Aggressive Predatory Strategy: "Resource Shark"
    
    Operates on aggressive resource extraction with calculated timing to maximize
    personal gains while strategically depleting resources to disadvantage opponents.
    Features early aggression, adaptive mid-game rules, and endgame domination.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.depletion_threshold = self.capacity * 0.3
        self.crisis_threshold = self.capacity * 0.15
        self.punishment_rounds_left = 0
        self.aggression_bonus = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = state.round_number
        current_stock = state.current_stock
        if self.punishment_rounds_left > 0:
            self.punishment_rounds_left -= 1
            return Action.D
        if current_round >= 1:
            prev_defectors = np.sum(~history.opponent_actions[-1, :])
            defector_ratio = prev_defectors / self.n_players
            if defector_ratio > 0.75 and current_round >= 2:
                if len(history.my_payoffs) >= 2:
                    two_rounds_ago_stock = self._estimate_stock_from_payoffs(history, -2)
                    prev_stock = self._estimate_stock_from_payoffs(history, -1)
                    if prev_stock < two_rounds_ago_stock:
                        self.punishment_rounds_left = 1
                        return Action.D
        if current_round == 1:
            return Action.D
        if current_round >= self.n_rounds - 3:
            return self._endgame_decision(current_stock, current_round)
        return self._midgame_decision(current_stock, history, current_round)

    def _endgame_decision(self, current_stock: float, current_round: int) -> Action:
        rounds_left = self.n_rounds - current_round
        if rounds_left == 3:
            if current_stock <= self.crisis_threshold:
                return Action.C
            else:
                return Action.D
        elif rounds_left == 2:
            if current_stock <= self.n_players:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _midgame_decision(self, current_stock: float, history: PlayerHistory, current_round: int) -> Action:
        if current_stock > 0.9 * self.capacity:
            return Action.D
        if current_stock < self.n_players:
            return Action.D if current_round == self.n_rounds - 1 else Action.C
        if np.all(history.opponent_actions[-1, :]):
            return Action.D
        if current_round >= 2:
            prev_stock = self._estimate_stock_from_payoffs(history, -1)
            if current_stock > prev_stock * 1.2:
                return Action.D
        if current_stock > self.depletion_threshold:
            prev_defectors = np.sum(~history.opponent_actions[-1, :])
            defector_ratio = prev_defectors / self.n_players
            if defector_ratio >= 0.5:
                return Action.D
            else:
                base_prob = 0.7 + self.aggression_bonus
                return Action.D if random.random() < base_prob else Action.C
        elif current_stock > self.crisis_threshold:
            if self._should_exploit_cooperators(history):
                return Action.D
            return Action.D
        else:
            return Action.C

    def _should_exploit_cooperators(self, history: PlayerHistory) -> bool:
        if history.round_number < 3:
            return False
        recent_actions = history.opponent_actions[-3:, :]
        for player_idx in range(self.n_players):
            cooperation_rate = np.sum(recent_actions[:, player_idx]) / 3
            if cooperation_rate >= 2 / 3:
                return True
        return False

    def _estimate_stock_from_payoffs(self, history: PlayerHistory, round_offset: int) -> float:
        if abs(round_offset) > len(history.my_payoffs):
            return self.capacity
        my_payoff = history.my_payoffs[round_offset]
        my_action = history.my_actions[round_offset]
        if my_action:
            estimated_stock = my_payoff * 2 * self.n_players
        else:
            estimated_stock = my_payoff * self.n_players
        return max(0, estimated_stock)

    def _update_aggression_calibration(self, history: PlayerHistory):
        if history.round_number < 3:
            return
        recent_rounds = history.opponent_actions[-3:, :]
        avg_defection_rate = 1.0 - np.mean(recent_rounds)
        if avg_defection_rate < 0.5:
            self.aggression_bonus = min(0.3, self.aggression_bonus + 0.1)

class Strategy_AGGRESSIVE_96(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES).
    
    Operates on aggressive resource maximization while maintaining sustainability
    only when necessary. Exploits cooperative opponents ruthlessly while adapting
    to prevent total resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_num = state.round_number
        stock = state.current_stock
        rounds_remaining = self.r - round_num
        if stock < self.capacity * 0.1:
            return Action.C
        if round_num <= 3 or stock >= self.capacity * 0.75:
            phase = 'initial_exploitation'
        elif rounds_remaining <= self.r * 0.2:
            phase = 'endgame'
        else:
            phase = 'adaptive'
        if phase == 'initial_exploitation':
            return Action.D
        elif phase == 'endgame':
            if rounds_remaining == 0 or stock < self.capacity * 0.1:
                return Action.C if stock < self.capacity * 0.1 else Action.D
            return Action.D
        else:
            return self._adaptive_decision(stock, history)

    def _adaptive_decision(self, stock, history):
        """Apply adaptive decision logic based on stock and opponent behavior."""
        if stock <= self.capacity * 0.25:
            return Action.C
        if stock <= self.capacity * 0.5:
            rounds_remaining = self.r - len(history.my_actions)
            if stock / self.capacity < rounds_remaining / (2 * self.r):
                return Action.C
        opponent_coop_ratio = self._calculate_recent_cooperation(history, 3)
        if opponent_coop_ratio >= 0.7:
            return Action.D
        elif opponent_coop_ratio <= 0.3:
            return self._defector_punishment_protocol(stock, history)
        else:
            return self._mixed_response_protocol(stock, history)

    def _calculate_recent_cooperation(self, history, num_rounds):
        """Calculate cooperation ratio of opponents in last num_rounds."""
        if len(history.opponent_actions) == 0:
            return 0.5
        start_round = max(0, len(history.opponent_actions) - num_rounds)
        recent_actions = history.opponent_actions[start_round:, :]
        if recent_actions.size == 0:
            return 0.5
        total_cooperations = np.sum(recent_actions)
        total_actions = recent_actions.size
        return total_cooperations / total_actions if total_actions > 0 else 0.5

    def _defector_punishment_protocol(self, stock, history):
        """Handle scenarios with low opponent cooperation."""
        if len(history.opponent_actions) == 0:
            return Action.C
        last_round_cooperations = np.sum(history.opponent_actions[-1, :])
        majority_defected = last_round_cooperations < (self.n - 1) / 2
        if majority_defected and stock > self.capacity / 3:
            return Action.D
        else:
            return Action.C

    def _mixed_response_protocol(self, stock, history):
        """Handle mixed cooperation scenarios."""
        my_avg_payoff = np.mean(history.my_payoffs) if len(history.my_payoffs) > 0 else 0
        opponent_avg_payoff = np.mean(history.opponent_payoffs) if history.opponent_payoffs.size > 0 else 0
        if my_avg_payoff > opponent_avg_payoff and stock > self.capacity / 3:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_97(BaseStrategy):
    """
    Aggressive Adaptive Resource Extraction Strategy (AARES)
    
    Maximizes personal extraction while maintaining the resource pool as a strategic asset.
    Uses sustainable aggression - extracting maximum value while preserving future opportunities,
    and punishing cooperative behavior that could be exploited.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_number = history.round_number
        remaining_rounds = self.n_rounds - round_number
        current_stock = state.current_stock
        if round_number == 1:
            return Action.D
        critical_stock = self.capacity * (remaining_rounds / self.n_rounds) * 0.6
        if remaining_rounds <= 0:
            return Action.D
        last_opponent_actions = history.opponent_actions[-1, :]
        opponents_defected_last = sum(last_opponent_actions == False)
        total_opponents = len(last_opponent_actions)
        defection_rate = opponents_defected_last / total_opponents if total_opponents > 0 else 0
        if current_stock <= critical_stock:
            if defection_rate > 0.6:
                return Action.D
            else:
                return Action.C
        if remaining_rounds <= max(2, self.n_rounds * 0.2):
            if current_stock > self.capacity * 0.3:
                return Action.D
            else:
                total_opponent_defections = np.sum(history.opponent_actions == False)
                total_opponent_actions = history.opponent_actions.size
                avg_opponent_defection = total_opponent_defections / total_opponent_actions if total_opponent_actions > 0 else 0
                if avg_opponent_defection > 0.4:
                    return Action.D
                else:
                    return Action.C
        if defection_rate >= 0.5:
            return Action.D
        elif defection_rate >= 0.3:
            my_last_action = history.my_actions[-1]
            if my_last_action == True:
                return Action.D
            else:
                return Action.C
        elif defection_rate == 0 and round_number > 2:
            return Action.D
        else:
            if round_number >= 3:
                recent_rounds = min(3, round_number)
                recent_defection_rates = []
                for i in range(recent_rounds):
                    round_idx = -(i + 1)
                    round_opponent_actions = history.opponent_actions[round_idx, :]
                    round_defections = sum(round_opponent_actions == False)
                    round_defection_rate = round_defections / total_opponents if total_opponents > 0 else 0
                    recent_defection_rates.append(round_defection_rate)
                if all((rate <= 0.2 for rate in recent_defection_rates)):
                    return Action.D
            if round_number >= 2:
                if defection_rate <= 0.1:
                    return Action.D
            return Action.C
        return Action.C

class Strategy_AGGRESSIVE_98(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES).
    
    This strategy operates on aggressive resource extraction while maintaining long-term viability.
    It aims to maximize personal payoffs by exploiting cooperative opponents while adapting quickly
    to counter aggressive competition.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.opponent_defection_rates = None
        self.consecutive_all_defect = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.n_rounds:
            return Action.D
        stock_health = state.current_stock / self.capacity
        time_remaining_ratio = (self.n_rounds - current_round) / self.n_rounds
        cooperation_rate = self._get_recent_cooperation_rate(history)
        self._update_all_defect_tracker(history)
        self._update_opponent_classifications(history)
        stock_threshold = 0.15 + 0.25 * time_remaining_ratio
        cooperation_threshold = 0.4
        if stock_health < stock_threshold:
            return Action.C
        if self.consecutive_all_defect >= 2:
            return Action.C
        if cooperation_rate > cooperation_threshold:
            return Action.D
        if self._is_underperforming(history):
            return Action.D
        return Action.D

    def _get_recent_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate cooperation rate from opponents in last 3 rounds."""
        if history.round_number == 0:
            return 0.0
        lookback = min(3, history.round_number)
        recent_actions = history.opponent_actions[-lookback:, :]
        total_actions = recent_actions.size
        if total_actions == 0:
            return 0.0
        cooperations = np.sum(recent_actions)
        return cooperations / total_actions

    def _update_all_defect_tracker(self, history: PlayerHistory) -> None:
        """Track consecutive rounds where all players defected."""
        if history.round_number == 0:
            self.consecutive_all_defect = 0
            return
        last_round_idx = history.round_number - 1
        my_last_action = history.my_actions[last_round_idx]
        opponent_last_actions = history.opponent_actions[last_round_idx, :]
        all_defected = not my_last_action and (not np.any(opponent_last_actions))
        if all_defected:
            self.consecutive_all_defect += 1
        else:
            self.consecutive_all_defect = 0

    def _update_opponent_classifications(self, history: PlayerHistory) -> None:
        """Update opponent defection rates for classification."""
        if history.round_number == 0:
            return
        if self.opponent_defection_rates is None:
            self.opponent_defection_rates = np.zeros(self.n_players - 1)
        for i in range(self.n_players - 1):
            opponent_actions = history.opponent_actions[:, i]
            defections = np.sum(~opponent_actions)
            self.opponent_defection_rates[i] = defections / len(opponent_actions)

    def _is_underperforming(self, history: PlayerHistory) -> bool:
        """Check if personal payoff is below 80% of theoretical max for 3+ consecutive rounds."""
        if history.round_number < 3:
            return False
        recent_payoffs = history.my_payoffs[-3:]
        theoretical_max_per_round = self.capacity / self.n_players
        threshold = 0.8 * theoretical_max_per_round
        return np.all(recent_payoffs < threshold)

class Strategy_AGGRESSIVE_99(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy - maximizes resource extraction through
    ruthless opportunism while strategically preserving resources when it benefits
    long-term exploitation. Uses phase-based approach with dynamic thresholds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = state.round_number
        stock = state.current_stock
        phase1_end = max(2, int(self.n_rounds * 0.2))
        phase2_end = int(self.n_rounds * 0.8)
        if current_round <= phase1_end:
            if stock >= self.capacity * 0.8:
                return Action.D
            elif stock <= self.capacity * 0.3:
                return Action.C
            else:
                cooperator_ratio = self._get_cooperator_ratio_last_round(history)
                if cooperator_ratio >= 0.6:
                    return Action.D
                else:
                    return Action.C
        elif current_round > phase2_end:
            rounds_left = self.n_rounds - current_round
            if rounds_left == 0:
                return Action.D
            elif stock <= self.capacity * 0.2:
                return Action.C
            else:
                recent_cooperators = self._count_cooperators_last_round(history)
                recent_defectors = self.n_players - 1 - recent_cooperators
                projected_consumption_per_round = stock / (2 * self.n_players) * recent_cooperators + stock / self.n_players * recent_defectors
                if stock - projected_consumption_per_round * (rounds_left + 1) > 0:
                    return Action.D
                elif current_round % 2 == 0:
                    return Action.D
                else:
                    return Action.C
        else:
            rounds_remaining = self.n_rounds - current_round
            minimum_viable_stock = self.capacity * 0.15
            if stock > minimum_viable_stock * (1 + rounds_remaining * 0.1):
                recent_cooperator_ratio = self._get_cooperator_ratio_last_3_rounds(history)
                if recent_cooperator_ratio >= 0.5:
                    return Action.D
                elif stock >= self.capacity * 0.6:
                    return Action.D
                elif self._count_cooperators_last_round(history) >= (self.n_players - 1) * 0.4:
                    return Action.C
                else:
                    return Action.D
            elif stock <= self.capacity * 0.1:
                if current_round >= self.n_rounds * 0.9:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.C

    def _count_cooperators_last_round(self, history: PlayerHistory) -> int:
        """Count cooperators in the most recent round."""
        if len(history.opponent_actions) == 0:
            return 0
        return int(sum(history.opponent_actions[-1, :]))

    def _get_cooperator_ratio_last_round(self, history: PlayerHistory) -> float:
        """Get ratio of cooperators in the most recent round."""
        if len(history.opponent_actions) == 0:
            return 0.0
        cooperators = self._count_cooperators_last_round(history)
        return cooperators / (self.n_players - 1)

    def _get_cooperator_ratio_last_3_rounds(self, history: PlayerHistory) -> float:
        """Get ratio of cooperators over the last 3 rounds."""
        if len(history.opponent_actions) == 0:
            return 0.0
        rounds_to_check = min(3, len(history.opponent_actions))
        total_cooperators = 0
        for i in range(rounds_to_check):
            round_idx = len(history.opponent_actions) - 1 - i
            total_cooperators += sum(history.opponent_actions[round_idx, :])
        total_decisions = rounds_to_check * (self.n_players - 1)
        return total_cooperators / total_decisions if total_decisions > 0 else 0.0

    def _count_cooperators_last_2_rounds(self, history: PlayerHistory) -> int:
        """Count total cooperators over the last 2 rounds."""
        if len(history.opponent_actions) == 0:
            return 0
        rounds_to_check = min(2, len(history.opponent_actions))
        total_cooperators = 0
        for i in range(rounds_to_check):
            round_idx = len(history.opponent_actions) - 1 - i
            total_cooperators += sum(history.opponent_actions[round_idx, :])
        return int(total_cooperators)

class Strategy_AGGRESSIVE_100(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES) - Maximizes individual payoffs through 
    aggressive opportunism with calculated sustainability. Operates in three phases: 
    Exploitation (default aggressive), Sustainability (defensive cooperation when resources 
    are stressed), and Endgame (final resource grab).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = state.round_number
        stock = state.current_stock
        rounds_remaining = self.n_rounds - current_round
        stock_per_capita = stock / self.n_players
        depletion_rate = self._calculate_recent_depletion_rate(history, stock)
        opponent_aggression = self._calculate_opponent_aggression(history)
        sustainability_threshold = self.capacity * (0.2 + 0.1 / self.n_players)
        endgame_trigger = max(2, int(self.n_rounds * 0.15))
        critical_stock_level = self.capacity * (0.1 + self.n_players / 100)
        if rounds_remaining <= endgame_trigger:
            return Action.D
        elif stock <= self.capacity * 0.3 or depletion_rate > sustainability_threshold:
            return self._sustainability_strategy(history, stock, opponent_aggression, critical_stock_level)
        else:
            return Action.D

    def _calculate_recent_depletion_rate(self, history: PlayerHistory, current_stock: float) -> float:
        """Calculate recent stock depletion rate to assess sustainability risk."""
        if len(history.my_actions) < 2:
            return 0.0
        lookback = min(3, len(history.my_actions))
        recent_rounds = lookback
        total_recent_consumption = 0.0
        for i in range(-lookback, 0):
            round_idx = i
            my_action_cooperated = history.my_actions[round_idx]
            opponent_cooperators = sum(history.opponent_actions[round_idx, :])
            if my_action_cooperated:
                cooperators = opponent_cooperators + 1
                defectors = self.n_players - cooperators
            else:
                cooperators = opponent_cooperators
                defectors = self.n_players - cooperators
            round_consumption_factor = cooperators * 0.5 + defectors * 1.0
            total_recent_consumption += round_consumption_factor
        return total_recent_consumption / recent_rounds if recent_rounds > 0 else 0.0

    def _calculate_opponent_aggression(self, history: PlayerHistory) -> float:
        """Calculate the proportion of defections by opponents in recent rounds."""
        if len(history.my_actions) == 0:
            return 0.0
        lookback = min(3, len(history.my_actions))
        total_actions = 0
        total_defections = 0
        for i in range(-lookback, 0):
            round_idx = i
            round_defections = sum(1 - history.opponent_actions[round_idx, :])
            total_defections += round_defections
            total_actions += self.n_players - 1
        return total_defections / total_actions if total_actions > 0 else 0.0

    def _sustainability_strategy(self, history: PlayerHistory, stock: float, opponent_aggression: float, critical_stock_level: float) -> Action:
        """Strategic cooperation mode when resources are under stress."""
        if opponent_aggression > 0.7:
            return Action.D
        if stock < critical_stock_level:
            return Action.C
        if len(history.my_actions) > 0:
            last_round_cooperators = sum(history.opponent_actions[-1, :])
            if last_round_cooperators >= (self.n_players - 1) / 2:
                return Action.C
            else:
                return Action.D
        return Action.C

class Strategy_AGGRESSIVE_101(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES).
    
    Exploits early when stock is high, adapts to opponent behavior in middle game,
    and maximizes individual gain in endgame. Prioritizes individual payoffs over
    collective welfare through strategic defection and opponent exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_num = state.round_number
        stock = state.current_stock
        early_phase = round_num <= max(3, self.r // 4)
        endgame_phase = round_num > int(self.r * 0.8)
        if early_phase:
            return Action.D
        if endgame_phase:
            if round_num == self.r - 1:
                return Action.D
            if stock < self.n / 2:
                return Action.C
            return Action.D
        if stock < self.n:
            return Action.C
        if stock >= 2 * self.n:
            return Action.D
        recent_rounds = min(3, len(history.my_actions))
        if recent_rounds == 0:
            return Action.D
        recent_opponent_actions = history.opponent_actions[-recent_rounds:, :]
        total_decisions = recent_opponent_actions.size
        if total_decisions == 0:
            return Action.D
        cooperations = np.sum(recent_opponent_actions)
        avg_cooperation_rate = cooperations / total_decisions
        if len(history.my_actions) >= 4:
            for opponent_idx in range(self.n - 1):
                recent_4_rounds = min(4, len(history.my_actions))
                opponent_recent = history.opponent_actions[-recent_4_rounds:, opponent_idx]
                coop_rate = np.mean(opponent_recent)
                if coop_rate > 0.8 and (not history.opponent_actions[-1, opponent_idx]):
                    return Action.D
        if len(history.my_actions) > 0:
            last_round_defectors = np.sum(~history.opponent_actions[-1, :])
            if last_round_defectors < (self.n - 1) / 2:
                if random.random() < 0.3:
                    return Action.D
        if avg_cooperation_rate < 0.3:
            return Action.D
        elif avg_cooperation_rate > 0.7:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_102(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES)
    
    Maximizes individual payoffs through intelligent exploitation while maintaining
    flexibility to avoid complete resource collapse. Uses phase-based decision making
    with early aggression, strategic exploitation, and endgame maximization.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        stock = state.current_stock
        round_num = state.round_number
        if stock <= capacity / (4 * n):
            return Action.C
        if history is None:
            return Action.D
        if round_num > 2 * r // 3 and r - round_num < 3:
            return Action.D
        recent_defector_rate = 0.0
        if len(history.opponent_actions) > 0:
            last_round_defectors = sum(history.opponent_actions[-1, :] == False)
            recent_defector_rate = last_round_defectors / n
        if round_num <= r // 3:
            if stock > capacity / 2 or recent_defector_rate >= 0.5:
                return Action.D
            if stock <= capacity / 4:
                return Action.C
            return Action.D
        elif round_num <= 2 * r // 3:
            if stock > 3 * capacity / 4:
                return Action.D
            if recent_defector_rate > 0.6:
                return Action.D
            if recent_defector_rate < 0.3:
                return Action.D
            if len(history.my_payoffs) >= 2:
                recent_payoffs = history.my_payoffs[-2:]
                if len(recent_payoffs) == 2:
                    decline_rate = (recent_payoffs[-2] - recent_payoffs[-1]) / recent_payoffs[-2] if recent_payoffs[-2] > 0 else 0
                    if decline_rate > 0.2:
                        return Action.C
            if 0.3 <= recent_defector_rate <= 0.6:
                if stock > capacity / 2:
                    return Action.D
                else:
                    return Action.C
            return Action.D
        else:
            if stock > capacity / 2:
                return Action.D
            if stock <= capacity / (2 * n):
                if r - round_num > 1:
                    return Action.C
            return Action.D

class Strategy_AGGRESSIVE_103(BaseStrategy):
    """
    Aggressive Predatory Exploitation Strategy - treats the common pool as a resource 
    to be aggressively extracted while strategically timing cooperation only when it 
    serves long-term exploitation goals.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_rounds_remaining = 0
        self.was_cooperating_last_round = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.was_cooperating_last_round = False
            return Action.D
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        rounds_remaining = self.game_description.n_rounds - state.round_number
        current_stock = state.current_stock
        sustainability_ratio = current_stock / capacity
        extraction_pressure = rounds_remaining * n / max(current_stock, 0.1)
        if self.punishment_rounds_remaining > 0:
            self.punishment_rounds_remaining -= 1
            self.was_cooperating_last_round = False
            return Action.D
        if self.was_cooperating_last_round and history.round_number > 0:
            last_round_defectors = sum(history.opponent_actions[-1, :] == False)
            if last_round_defectors > 0:
                self.punishment_rounds_remaining = 1
                self.was_cooperating_last_round = False
                return Action.D
        if rounds_remaining <= 1:
            self.was_cooperating_last_round = False
            return Action.D
        last_round_opponents = history.opponent_actions[-1, :]
        last_round_defection_rate = sum(last_round_opponents == False) / len(last_round_opponents)
        majority_cooperated_last_round = sum(last_round_opponents) > len(last_round_opponents) / 2
        rounds_to_check = min(3, history.round_number)
        if rounds_to_check > 0:
            recent_actions = history.opponent_actions[-rounds_to_check:, :]
            avg_cooperation_rate = np.mean(recent_actions)
            avg_defection_rate = 1 - avg_cooperation_rate
        else:
            avg_cooperation_rate = 0.5
            avg_defection_rate = 0.5
        if sustainability_ratio > 0.7:
            self.was_cooperating_last_round = False
            return Action.D
        if extraction_pressure < 0.8:
            self.was_cooperating_last_round = False
            return Action.D
        if last_round_defection_rate > 0.6:
            self.was_cooperating_last_round = False
            return Action.D
        if avg_cooperation_rate < 0.4:
            self.was_cooperating_last_round = False
            return Action.D
        cooperate_conditions = [sustainability_ratio <= 0.3, rounds_remaining >= 3, majority_cooperated_last_round]
        total_payoff = sum(history.my_payoffs)
        theoretical_max = history.round_number * (capacity / n) * 0.8
        payoff_condition = total_payoff < 0.8 * theoretical_max
        cooperate_conditions.append(payoff_condition)
        if all(cooperate_conditions):
            self.was_cooperating_last_round = True
            return Action.C
        if rounds_remaining > 2:
            if sustainability_ratio > 0.6:
                self.was_cooperating_last_round = False
                return Action.D
            elif sustainability_ratio < 0.25 and majority_cooperated_last_round:
                self.was_cooperating_last_round = True
                return Action.C
            elif avg_defection_rate > 0.7:
                self.was_cooperating_last_round = False
                return Action.D
        if rounds_remaining == 2:
            if sustainability_ratio < 0.15 and all(last_round_opponents):
                self.was_cooperating_last_round = True
                return Action.C
        self.was_cooperating_last_round = False
        return Action.D

class Strategy_AGGRESSIVE_104(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy - maximizes immediate gains while 
    strategically preserving resources only when absolutely necessary. Leads with 
    aggression and adapts based on opponent behavior and stock conditions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock = game_description.capacity * 0.3
        self.retaliation_tracker = {}
        self.consecutive_high_coop = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        if state.round_number >= self.game_description.n_rounds - 1:
            return Action.D
        window_size = min(3, history.round_number)
        recent_actions = history.opponent_actions[-window_size:, :]
        total_recent_actions = recent_actions.size
        coop_actions = np.sum(recent_actions)
        coop_rate = coop_actions / total_recent_actions if total_recent_actions > 0 else 0
        if state.current_stock < self.critical_stock:
            if coop_rate > 0.6:
                return Action.C
            else:
                return Action.D
        stock_ratio = state.current_stock / self.game_description.capacity
        exploit_opportunity = stock_ratio * (1 - coop_rate)
        if exploit_opportunity > 0.4:
            return Action.D
        if coop_rate < 0.3:
            return Action.D
        if coop_rate > 0.7:
            self.consecutive_high_coop += 1
        else:
            self.consecutive_high_coop = 0
        if self.consecutive_high_coop >= 2:
            self.consecutive_high_coop = 0
            return Action.D
        endgame_threshold = int(0.8 * self.game_description.n_rounds)
        if state.round_number >= endgame_threshold:
            if random.random() < 0.75:
                return Action.D
        if history.round_number > 0:
            prev_round_total_consumption = 0
            my_prev_action = history.my_actions[-1]
            if my_prev_action:
                prev_stock_estimate = history.my_payoffs[-1] * (2 * self.game_description.n_players)
            else:
                prev_stock_estimate = history.my_payoffs[-1] * self.game_description.n_players
            if prev_stock_estimate > 0:
                growth_rate = (state.current_stock - prev_stock_estimate + prev_round_total_consumption) / self.game_description.capacity
                if growth_rate > 0.2:
                    return Action.D
        if state.current_stock > 0.8 * self.game_description.capacity:
            if random.random() < 0.6:
                return Action.D
        if history.round_number >= 2:
            recent_my_actions = history.my_actions[-2:]
            if np.all(recent_my_actions):
                return Action.D
        return Action.C

class Strategy_AGGRESSIVE_105(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Resource Shark"
    
    This strategy operates on aggressive opportunism - maximizing personal extraction
    while maintaining just enough resource sustainability to continue profiting.
    Always defects in first and last rounds, exploits cooperators when possible,
    and only cooperates when absolutely necessary for resource survival.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round = state.round_number + 1
        remaining_rounds = r - current_round + 1
        stock = state.current_stock
        if history is None:
            return Action.D
        if current_round == r:
            return Action.D
        if stock < n * remaining_rounds:
            return Action.C
        last_round_cooperators = int(np.sum(history.opponent_actions[-1, :]))
        if len(history.my_actions) >= 2:
            prev_my_payoff = history.my_payoffs[-2]
            if history.my_actions[-2]:
                prev_stock_estimate = prev_my_payoff * (2 * n)
            else:
                prev_stock_estimate = prev_my_payoff * n
            if prev_stock_estimate > 0:
                stock_drop_percentage = (prev_stock_estimate - stock) / prev_stock_estimate
            else:
                stock_drop_percentage = 0
        else:
            stock_drop_percentage = 0
        if last_round_cooperators >= n / 2:
            return Action.D
        if last_round_cooperators < n / 2 and stock_drop_percentage > 0.6:
            return Action.C
        if current_round == r - 1 and stock >= n:
            return Action.D
        if len(history.my_actions) >= 2:
            total_prev_consumption = 0
            if history.my_actions[-2]:
                total_prev_consumption += prev_stock_estimate / (2 * n)
            else:
                total_prev_consumption += prev_stock_estimate / n
            prev_cooperators = int(np.sum(history.opponent_actions[-2, :]))
            prev_defectors = n - 1 - prev_cooperators
            total_prev_consumption += prev_cooperators * (prev_stock_estimate / (2 * n))
            total_prev_consumption += prev_defectors * (prev_stock_estimate / n)
            prev_stock_after_consumption = prev_stock_estimate - total_prev_consumption
            if stock > prev_stock_after_consumption * 1.25:
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_106(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES)
    
    Operates on aggressive opportunism with calculated restraint. Defects by default
    but strategically cooperates when necessary to maintain exploitation opportunities.
    Uses three phases: early aggression, strategic exploitation, and endgame extraction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        stock = state.current_stock
        if history is None:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        critical_threshold = self.capacity / (4 * self.n_players)
        emergency_threshold = self.capacity / 10
        if stock < emergency_threshold:
            return Action.C
        elif stock < critical_threshold:
            if len(history.my_actions) > 0 and history.my_actions[-1]:
                return Action.D
            else:
                return Action.C
        phase_1_end = self.n_rounds // 3
        phase_2_end = 2 * self.n_rounds // 3
        if current_round <= phase_1_end:
            return Action.D
        if current_round > phase_2_end:
            if current_round == self.n_rounds - 2:
                my_consumption = stock / self.n_players
                total_consumption = my_consumption * self.n_players
                if stock - total_consumption <= 0:
                    return Action.C
                else:
                    return Action.D
            if stock > self.capacity / (2 * self.n_players):
                return Action.D
            else:
                return Action.D
        if len(history.opponent_actions) > 0:
            last_round_defectors = np.sum(history.opponent_actions[-1, :] == False)
        else:
            last_round_defectors = 0
        if stock > self.capacity / 2:
            return Action.D
        if stock >= critical_threshold and stock <= self.capacity / 2:
            if last_round_defectors > self.n_players / 2 and stock < self.capacity / 3:
                if len(history.my_actions) > 0 and history.my_actions[-1]:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.D
        if stock < critical_threshold:
            if stock < self.capacity / 3:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_107(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES).
    
    Operates on aggressive opportunism: maximize immediate gains while strategically 
    preserving the resource only when absolutely necessary for future exploitation.
    Uses dynamic switching based on stock health, opponent patterns, and game phase.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_threshold = game_description.capacity * 0.15
        self.low_threshold = game_description.capacity * 0.35
        self.healthy_threshold = game_description.capacity * 0.6
        self.phase1_end = game_description.n_rounds // 3
        self.phase2_end = 2 * game_description.n_rounds // 3
        self.punishment_rounds = {}

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = state.round_number
        stock = state.current_stock
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if current_round >= r - 2:
            return Action.D
        if stock > self.healthy_threshold and current_round <= r // 2:
            return Action.D
        if stock <= self.critical_threshold and current_round < r - 3:
            return Action.C
        if stock == 0:
            return Action.C
        if self._stock_declining_trend(history) and stock <= self.low_threshold:
            return Action.C
        if len(history.my_actions) > 0:
            last_round_cooperators = sum(history.opponent_actions[-1, :])
            last_round_defectors = n - 1 - last_round_cooperators
            if last_round_defectors > last_round_cooperators and stock > self.low_threshold:
                return Action.D
            if last_round_cooperators == n - 1 and stock > self.low_threshold:
                return Action.D
        oei = self._calculate_oei(history)
        if oei > 0.6 and stock > self.low_threshold:
            return Action.D
        if oei < 0.3 and stock > self.critical_threshold:
            return Action.D
        if self.critical_threshold < stock <= self.low_threshold:
            projected_recovery = 2 * stock * (1 - stock / self.game_description.capacity)
            if stock + projected_recovery > stock * 1.3:
                return Action.C
        if len(history.my_actions) > 1:
            prev_stock = self._estimate_previous_stock(history)
            if prev_stock > 0 and stock > prev_stock * 1.2:
                return Action.D
        return Action.D

    def _calculate_oei(self, history: PlayerHistory) -> float:
        """Calculate Opponent Exploitation Index over last 3 rounds."""
        if len(history.my_actions) == 0:
            return 0.0
        n_opponents = self.game_description.n_players - 1
        rounds_to_check = min(3, len(history.my_actions))
        total_oei = 0.0
        for opponent_idx in range(n_opponents):
            recent_actions = history.opponent_actions[-rounds_to_check:, opponent_idx]
            defection_rate = 1.0 - np.mean(recent_actions)
            cooperation_trend = 1.0 if history.opponent_actions[-1, opponent_idx] else 0.0
            total_oei += defection_rate * (1 - cooperation_trend)
        return total_oei / n_opponents if n_opponents > 0 else 0.0

    def _stock_declining_trend(self, history: PlayerHistory) -> bool:
        """Check if stock has been declining for 3+ consecutive rounds."""
        if len(history.my_actions) < 3:
            return False
        recent_stocks = []
        for i in range(min(4, len(history.my_actions) + 1)):
            if i == 0:
                recent_stocks.append(self.game_description.capacity)
            else:
                pass
        if len(history.my_payoffs) >= 3:
            recent_payoffs = history.my_payoffs[-3:]
            return all((recent_payoffs[i] >= recent_payoffs[i + 1] for i in range(len(recent_payoffs) - 1)))
        return False

    def _estimate_previous_stock(self, history: PlayerHistory) -> float:
        """Rough estimate of previous round's stock based on payoffs."""
        if len(history.my_payoffs) < 2:
            return self.game_description.capacity
        last_payoff = history.my_payoffs[-1]
        prev_payoff = history.my_payoffs[-2]
        n = self.game_description.n_players
        if history.my_actions[-1]:
            current_stock_est = last_payoff * 2 * n
        else:
            current_stock_est = last_payoff * n
        if len(history.my_actions) >= 2:
            if history.my_actions[-2]:
                prev_stock_est = prev_payoff * 2 * n
            else:
                prev_stock_est = prev_payoff * n
        else:
            prev_stock_est = self.game_description.capacity
        return prev_stock_est

class Strategy_AGGRESSIVE_108(BaseStrategy):
    """
    Aggressive Adaptive Strategy: "Resource Predator"
    
    This strategy operates on the principle that aggression pays when others hesitate.
    It aggressively exploits the resource while maintaining just enough restraint to 
    avoid complete collapse, maximizing personal gain through calculated predation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock <= self.game_description.capacity * 0.15:
            return Action.C
        last_round_idx = history.round_number - 1
        cooperation_rate = np.mean(history.opponent_actions[last_round_idx, :])
        if history.round_number >= 3:
            recent_rounds = history.opponent_actions[-3:, :]
            recent_cooperation_trend = np.mean(recent_rounds)
            if history.round_number >= 6:
                previous_rounds = history.opponent_actions[-6:-3, :]
                previous_trend = np.mean(previous_rounds)
            else:
                previous_trend = 0.5
        else:
            recent_cooperation_trend = cooperation_rate
            previous_trend = 0.5
        if cooperation_rate >= 0.7:
            return Action.D
        if cooperation_rate >= 0.4 and state.current_stock >= self.game_description.capacity * 0.6:
            return Action.D
        if recent_cooperation_trend > previous_trend and state.current_stock >= self.game_description.capacity * 0.3:
            return Action.D
        if state.current_stock >= self.game_description.capacity * 0.8:
            return Action.D
        if history.round_number >= 2:
            recent_payoffs = history.my_payoffs[-2:]
            stock_threshold = state.current_stock / (3 * self.game_description.n_players)
            if np.mean(recent_payoffs) < stock_threshold:
                return Action.C
        return Action.C

class Strategy_AGGRESSIVE_109(BaseStrategy):
    """
    Aggressive Adaptive Strategy: "Resource Predator"
    
    Operates on intelligent aggression - maximizing personal extraction while maintaining
    the resource base only when absolutely necessary. Treats cooperation as a tactical
    tool rather than a moral choice.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = state.round_number
        stock = state.current_stock
        rounds_remaining = self.n_rounds - current_round
        stock_level = self._assess_stock_health(stock)
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_round == self.n_rounds - 2:
            if stock_level == 'CRITICAL' and self._all_opponents_cooperated_last_round(history):
                return Action.C
            return Action.D
        if rounds_remaining <= max(1, int(0.2 * self.n_rounds)):
            return Action.D
        cooperators, defectors, mixed = self._classify_opponents(history)
        if self._should_exploit_due_to_performance(history, stock):
            return Action.D
        return self._make_middle_game_decision(stock_level, cooperators, defectors, history, rounds_remaining)

    def _assess_stock_health(self, stock):
        """Categorize current stock level"""
        if stock <= self.capacity / 4:
            return 'CRITICAL'
        elif stock <= self.capacity / 2:
            return 'LOW'
        elif stock <= 3 * self.capacity / 4:
            return 'MODERATE'
        else:
            return 'HEALTHY'

    def _classify_opponents(self, history):
        """Classify opponents based on recent cooperation rates"""
        cooperators = 0
        defectors = 0
        mixed = 0
        lookback = min(5, history.round_number)
        if lookback == 0:
            return (0, 0, self.n_players - 1)
        for player_idx in range(self.n_players - 1):
            recent_actions = history.opponent_actions[-lookback:, player_idx]
            cooperation_rate = np.mean(recent_actions)
            if cooperation_rate >= 0.7:
                cooperators += 1
            elif cooperation_rate <= 0.3:
                defectors += 1
            else:
                mixed += 1
        return (cooperators, defectors, mixed)

    def _all_opponents_cooperated_last_round(self, history):
        """Check if all opponents cooperated in the last round"""
        if history.round_number == 0:
            return False
        return np.all(history.opponent_actions[-1, :])

    def _should_exploit_due_to_performance(self, history, stock):
        """Check if should switch to pure defection due to underperformance"""
        if history.round_number < 2:
            return False
        avg_opponent_payoff = np.mean(np.sum(history.opponent_payoffs, axis=0))
        my_total_payoff = np.sum(history.my_payoffs)
        if my_total_payoff < avg_opponent_payoff and stock > self.capacity / 3:
            return True
        return False

    def _make_middle_game_decision(self, stock_level, cooperators, defectors, history, rounds_remaining):
        """Core decision logic for middle game rounds"""
        if stock_level == 'CRITICAL':
            if cooperators > defectors:
                return Action.C
            else:
                return Action.D
        elif stock_level == 'LOW':
            if cooperators > defectors and rounds_remaining >= 3:
                return Action.C
            else:
                return Action.D
        elif stock_level == 'MODERATE':
            last_round_defections = np.sum(~history.opponent_actions[-1, :])
            opponent_defection_rate = last_round_defections / (self.n_players - 1)
            if opponent_defection_rate >= 0.5:
                return Action.D
            elif cooperators >= (self.n_players - 1) / 2:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_110(BaseStrategy):
    """
    Opportunistic Predator: Aggressive exploitation strategy that defects when others cooperate
    and adapts based on stock levels and opponent behavior patterns.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_stock <= self.capacity * 0.15:
            return Action.C
        aggression_threshold = self.capacity * 0.4
        recent_coop_rate = self._calculate_recent_cooperation_rate(history)
        rounds_remaining = self.n_rounds - current_round
        if rounds_remaining <= max(2, self.n_rounds * 0.15):
            if current_stock > self.capacity * 0.25:
                return Action.D
        if recent_coop_rate >= 0.6 and current_stock > aggression_threshold:
            return Action.D
        if recent_coop_rate <= 0.3:
            if current_stock > self.capacity * 0.8:
                return Action.D
            else:
                return Action.C
        if current_stock > aggression_threshold:
            if random.random() < 0.7:
                return Action.D
            else:
                return Action.C
        elif random.random() < 0.4:
            return Action.D
        else:
            return Action.C

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate cooperation rate of opponents over the last 3 rounds."""
        n_rounds_completed = len(history.my_actions)
        if n_rounds_completed == 0:
            return 0.5
        lookback_rounds = min(3, n_rounds_completed)
        start_round = n_rounds_completed - lookback_rounds
        total_opponents = self.n_players - 1
        total_decisions = lookback_rounds * total_opponents
        if total_decisions == 0:
            return 0.5
        cooperations = 0
        for round_idx in range(start_round, n_rounds_completed):
            cooperations += np.sum(history.opponent_actions[round_idx, :])
        return cooperations / total_decisions

class Strategy_AGGRESSIVE_111(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES) - Maximizes individual payoffs through 
    aggressive opportunism while strategically adapting to prevent total resource collapse.
    Operates in three phases: aggressive opening, adaptive exploitation, and endgame extraction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number
        current_stock = state.current_stock
        rounds_remaining = self.n_rounds - current_round
        if current_round <= self.n_rounds * 0.2:
            return Action.D
        if current_round >= self.n_rounds * 0.8:
            return Action.D
        if current_stock < self.capacity / 10 and rounds_remaining > 3:
            if len(history.opponent_actions) > 0:
                last_round_cooperation = np.mean(history.opponent_actions[-1, :])
                if last_round_cooperation >= 0.5:
                    return Action.C
            return Action.D
        if current_stock < self.capacity / 3:
            return Action.C
        lookback_rounds = min(5, len(history.opponent_actions))
        if lookback_rounds > 0:
            recent_opponent_actions = history.opponent_actions[-lookback_rounds:, :]
            opponent_cooperation_rates = np.mean(recent_opponent_actions, axis=0)
            majority_cooperation_rate = np.mean(opponent_cooperation_rates)
            if majority_cooperation_rate > 0.6:
                return Action.D
            if majority_cooperation_rate < 0.3:
                if random.random() < 0.2:
                    return Action.C
                else:
                    return Action.D
            if random.random() < 0.7:
                return Action.D
            else:
                return Action.C
        if current_stock > 0.8 * self.capacity:
            return Action.D
        if len(history.opponent_actions) > 0:
            last_round_all_cooperated = np.all(history.opponent_actions[-1, :])
            if last_round_all_cooperated and current_stock > self.capacity / 2:
                return Action.D
        if lookback_rounds > 0:
            high_cooperators = np.sum(opponent_cooperation_rates > 0.7)
            defection_bonus = high_cooperators * 0.1
            base_defection_prob = 0.7
            enhanced_defection_prob = min(1.0, base_defection_prob + defection_bonus)
            if random.random() < enhanced_defection_prob:
                return Action.D
        if random.random() < 0.7:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_112(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES)
    
    Maximizes immediate gains through aggressive opportunism while maintaining 
    just enough restraint to keep the resource pool viable. Operates in three phases:
    early aggression, adaptive exploitation, and endgame extraction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_num = state.round_number
        if history is None:
            return Action.D
        endgame_threshold = int(0.8 * self.n_rounds)
        if round_num >= endgame_threshold:
            return Action.D
        if current_stock < self.capacity / 10:
            return Action.C
        if round_num <= 3 and current_stock >= self.capacity / 4:
            return Action.D
        recent_opponent_actions = history.opponent_actions[-1, :] if len(history.opponent_actions) > 0 else np.array([])
        opponent_defection_rate = 0
        if len(recent_opponent_actions) > 0:
            opponent_defection_rate = 1 - np.mean(recent_opponent_actions)
        predicted_consumption = self._predict_total_consumption(current_stock, assume_we_defect=True, recent_opponent_actions=recent_opponent_actions)
        stock_after_consumption = max(0, current_stock - predicted_consumption)
        growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
        predicted_next_stock = min(stock_after_consumption + growth, self.capacity)
        cooperation_threshold_1 = current_stock < self.capacity / 3
        cooperation_threshold_2 = predicted_next_stock < self.capacity / 6
        cooperation_threshold_3 = opponent_defection_rate > 0.7 and current_stock > self.capacity / 2
        if cooperation_threshold_1 or cooperation_threshold_2 or cooperation_threshold_3:
            return Action.C
        return Action.D

    def _predict_total_consumption(self, current_stock, assume_we_defect=True, recent_opponent_actions=None):
        """Predict total consumption based on our action and opponent behavior patterns"""
        our_consumption = current_stock / self.n_players if assume_we_defect else current_stock / (2 * self.n_players)
        opponent_consumption = 0
        if recent_opponent_actions is not None and len(recent_opponent_actions) > 0:
            for i, recent_action in enumerate(recent_opponent_actions):
                if recent_action:
                    opponent_consumption += current_stock / (2 * self.n_players)
                else:
                    opponent_consumption += current_stock / self.n_players
        else:
            avg_cooperation_rate = 0.4
            for i in range(self.n_players - 1):
                opponent_consumption += avg_cooperation_rate * current_stock / (2 * self.n_players) + (1 - avg_cooperation_rate) * current_stock / self.n_players
        return our_consumption + opponent_consumption

class Strategy_AGGRESSIVE_113(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES)
    
    Operates on aggressive opportunism - maximizes immediate gains while maintaining 
    strategic flexibility to exploit opponent weaknesses. Uses three phases:
    1. Initial Aggression (rounds 1-3): Always defect
    2. Adaptive Exploitation (middle rounds): Defect unless strict cooperation conditions met
    3. Endgame Aggression (final 2 rounds): Always defect
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.consecutive_cooperation_count = 0
        self.punishment_rounds_remaining = 0
        self.opponent_cooperation_rates = {}

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.consecutive_cooperation_count = 0
            return Action.D
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if current_round <= 3:
            self.consecutive_cooperation_count = 0
            return Action.D
        if current_round >= total_rounds - 1:
            self.consecutive_cooperation_count = 0
            return Action.D
        if len(history.opponent_actions) > 0:
            last_round_opponents = history.opponent_actions[-1, :]
            opponents_cooperated_last = sum(last_round_opponents)
            for i in range(len(last_round_opponents)):
                if i not in self.opponent_cooperation_rates:
                    self.opponent_cooperation_rates[i] = []
                self.opponent_cooperation_rates[i].append(bool(last_round_opponents[i]))
                if len(self.opponent_cooperation_rates[i]) > 3:
                    self.opponent_cooperation_rates[i].pop(0)
        else:
            opponents_cooperated_last = 0
        if self.punishment_rounds_remaining > 0:
            self.punishment_rounds_remaining -= 1
            self.consecutive_cooperation_count = 0
            return Action.D
        if len(history.opponent_actions) > 0:
            any_opponent_defected = sum(history.opponent_actions[-1, :]) < n - 1
            if any_opponent_defected and current_stock > capacity / 2:
                self.consecutive_cooperation_count = 0
                return Action.D
        if self.consecutive_cooperation_count >= 2:
            self.consecutive_cooperation_count = 0
            return Action.D
        if len(history.my_payoffs) > 0 and len(history.opponent_actions) > 0:
            my_last_action = history.my_actions[-1]
            my_last_payoff = history.my_payoffs[-1]
            if my_last_action:
                prev_stock = my_last_payoff * 2 * n
            else:
                prev_stock = my_last_payoff * n
            opponent_consumption = 0
            for i in range(n - 1):
                if history.opponent_actions[-1, i]:
                    opponent_consumption += prev_stock / (2 * n)
                else:
                    opponent_consumption += prev_stock / n
            total_consumption = opponent_consumption + (prev_stock / (2 * n) if my_last_action else prev_stock / n)
            if total_consumption > 0.6 * prev_stock:
                self.punishment_rounds_remaining = 1
                self.consecutive_cooperation_count = 0
                return Action.D
        remaining_rounds = total_rounds - current_round
        stock_crisis = current_stock < n * (remaining_rounds + 1)
        cooperation_majority = opponents_cooperated_last / max(1, n - 1) > 0.5
        cooperation_payoff = current_stock / (2 * n) if current_stock > 0 else 0
        defection_payoff = current_stock / n if current_stock > 0 else 0
        profit_threshold_met = cooperation_payoff > 0.7 * defection_payoff
        exploit_cooperators = False
        for i in self.opponent_cooperation_rates:
            if len(self.opponent_cooperation_rates[i]) >= 2:
                coop_rate = sum(self.opponent_cooperation_rates[i]) / len(self.opponent_cooperation_rates[i])
                if coop_rate > 0.7:
                    exploit_cooperators = True
                    break
        if exploit_cooperators:
            self.consecutive_cooperation_count = 0
            return Action.D
        if stock_crisis and cooperation_majority and profit_threshold_met:
            self.consecutive_cooperation_count += 1
            return Action.C
        else:
            self.consecutive_cooperation_count = 0
            return Action.D

class Strategy_AGGRESSIVE_114(BaseStrategy):
    """
    Aggressive Exploitation Strategy: 'Opportunistic Predator'
    
    Treats the common pool as a resource to be maximally exploited while others bear
    conservation costs. Uses three phases: early exploitation, adaptive predation,
    and endgame maximization with stock-level thresholds for emergency cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        stock = state.current_stock
        if stock <= self.capacity / 8:
            return Action.C
        if current_round == self.n_rounds:
            return Action.D
        early_phase_end = self.n_rounds // 3
        middle_phase_end = 2 * self.n_rounds // 3
        early_phase = current_round <= early_phase_end
        middle_phase = early_phase_end < current_round <= middle_phase_end
        end_phase = current_round > middle_phase_end
        if history is None:
            if stock >= self.capacity / 4:
                return Action.D
            else:
                return Action.C
        if early_phase:
            if stock >= self.capacity / 4:
                return Action.D
            else:
                return Action.C
        if middle_phase:
            defectors_last_round = sum(history.opponent_actions[-1, :] == False)
            if not history.my_actions[-1]:
                defectors_last_round += 1
            if defectors_last_round >= self.n_players / 2:
                return Action.D
            elif stock > self.capacity / 3:
                return Action.D
            else:
                return Action.C
        if end_phase:
            if stock > self.capacity / 2:
                return Action.D
            else:
                return Action.C
        return Action.D

class Strategy_AGGRESSIVE_115(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES)
    
    Maximizes resource extraction through aggressive defection while adapting to prevent
    complete resource collapse. Uses dynamic thresholds and opponent behavior tracking
    to balance short-term gains with long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.punishment_counter = 0
        self.cooperation_history = []
        self.base_critical_stock = self.capacity * 0.3
        self.base_danger_stock = self.capacity * 0.15

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round >= self.n_rounds - 2:
            return Action.D
        if self.n_rounds <= 3:
            return Action.D
        last_round_cooperators = sum(history.opponent_actions[-1, :])
        self.cooperation_history.append(last_round_cooperators)
        critical_stock, danger_stock = self._calculate_dynamic_thresholds(history)
        if current_stock > critical_stock:
            return Action.D
        elif current_stock > danger_stock:
            cooperation_rate = last_round_cooperators / self.n_players
            if cooperation_rate >= 0.5:
                return self._handle_punishment_detection(history, Action.C)
            else:
                return Action.D
        elif current_stock > 0:
            return Action.C
        else:
            return Action.D

    def _calculate_dynamic_thresholds(self, history: PlayerHistory):
        """Adjust thresholds based on opponent aggressiveness."""
        if len(self.cooperation_history) < 2:
            return (self.base_critical_stock, self.base_danger_stock)
        total_cooperators = sum(self.cooperation_history)
        total_possible = len(self.cooperation_history) * self.n_players
        avg_cooperation_rate = total_cooperators / total_possible if total_possible > 0 else 0
        critical_stock = self.base_critical_stock
        danger_stock = self.base_danger_stock
        if avg_cooperation_rate < 0.3:
            critical_stock *= 0.8
            danger_stock *= 0.7
        elif avg_cooperation_rate > 0.7:
            critical_stock *= 1.2
            danger_stock *= 1.1
        return (critical_stock, danger_stock)

    def _handle_punishment_detection(self, history: PlayerHistory, intended_action: Action):
        """Detect if being punished and respond strategically."""
        if len(history.my_actions) < 2:
            return intended_action
        my_last_action = history.my_actions[-1]
        if not my_last_action:
            if len(self.cooperation_history) >= 2:
                last_coop = self.cooperation_history[-1]
                prev_coop = self.cooperation_history[-2]
                if last_coop < prev_coop:
                    self.punishment_counter += 1
                    if self.punishment_counter >= 2:
                        self.punishment_counter = 0
                        return Action.C
        return intended_action

class Strategy_AGGRESSIVE_116(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES).
    
    Maximizes immediate gains through aggressive defection while strategically
    preserving resources only when absolutely necessary for continued exploitation.
    Defaults to defection unless specific emergency conditions are met.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        rounds_remaining = self.game_description.n_rounds - state.round_number
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if rounds_remaining <= 2:
            return Action.D
        game_progress = state.round_number / self.game_description.n_rounds
        if game_progress < 0.25:
            threshold = capacity * 0.2
        elif game_progress > 0.75:
            threshold = capacity * 0.4
        else:
            threshold = capacity * 0.3
        stock_critical = current_stock <= threshold
        if not stock_critical:
            return Action.D
        if rounds_remaining <= 2:
            return Action.D
        my_total_payoff = np.sum(history.my_payoffs)
        opponent_avg_payoff = np.mean(np.sum(history.opponent_payoffs, axis=0))
        we_have_exploited = my_total_payoff > opponent_avg_payoff
        if stock_critical and rounds_remaining > 2 and we_have_exploited:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_117(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES) - maximizes exploitation with calculated sustainability.
    Uses aggressive opening, adaptive exploitation based on stock levels and opponent behavior, and ruthless endgame.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.aggression_scores = {}
        self.destroyer_opponents = set()

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = state.round_number
        n_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        if current_round <= 1:
            return Action.D
        if current_round >= n_rounds - 2:
            if current_round == n_rounds - 1:
                return Action.D
            elif current_stock >= capacity * 0.4:
                return Action.D
            elif current_stock >= capacity * 0.2:
                last_round_cooperators = sum(history.opponent_actions[-1, :])
                if last_round_cooperators >= len(history.opponent_actions[-1, :]) / 2:
                    return Action.D
                else:
                    return Action.D
            else:
                return Action.D
        self._update_opponent_tracking(history, capacity)
        if current_stock >= capacity * 0.6:
            return Action.D
        elif current_stock >= capacity * 0.3:
            return self._apply_opponent_exploitation_logic(history, current_stock, capacity)
        else:
            return self._apply_emergency_sustainability_check(history, current_stock, capacity)

    def _update_opponent_tracking(self, history, capacity):
        """Update aggression scores and destroyer tracking"""
        n_opponents = history.opponent_actions.shape[1]
        rounds_to_check = min(5, len(history.opponent_actions))
        if rounds_to_check > 0:
            recent_actions = history.opponent_actions[-rounds_to_check:, :]
            for i in range(n_opponents):
                defection_rate = 1.0 - np.mean(recent_actions[:, i])
                self.aggression_scores[i] = defection_rate
        if len(history.opponent_actions) >= 2:
            for round_idx in range(len(history.opponent_actions) - 1):
                estimated_stock = capacity * 0.2
                for i in range(n_opponents):
                    if not history.opponent_actions[round_idx, i]:
                        self.destroyer_opponents.add(i)

    def _apply_opponent_exploitation_logic(self, history, current_stock, capacity):
        """Apply opponent exploitation logic for medium stock levels"""
        rounds_to_check = min(3, len(history.opponent_actions))
        if rounds_to_check == 0:
            return Action.D
        recent_actions = history.opponent_actions[-rounds_to_check:, :]
        total_actions = recent_actions.size
        total_cooperations = np.sum(recent_actions)
        cooperation_rate = total_cooperations / total_actions if total_actions > 0 else 0
        if cooperation_rate >= 0.6:
            return Action.D
        elif cooperation_rate <= 0.3:
            if current_stock > capacity * 0.4:
                return Action.D
            else:
                return Action.C
        else:
            return self._apply_momentum_strategy(history, current_stock, capacity)

    def _apply_momentum_strategy(self, history, current_stock, capacity):
        """Apply momentum strategy for mixed opponent behavior"""
        rounds_to_check = min(3, len(history.my_actions))
        if rounds_to_check == 0:
            return Action.D
        recent_my_actions = history.my_actions[-rounds_to_check:]
        my_defection_rate = 1.0 - np.mean(recent_my_actions)
        if my_defection_rate > 0.6 and current_stock >= capacity * 0.35:
            return Action.D
        else:
            return Action.C

    def _apply_emergency_sustainability_check(self, history, current_stock, capacity):
        """Apply emergency sustainability check for low stock levels"""
        if current_stock < capacity * 0.15:
            return Action.C
        elif len(history.opponent_actions) > 0:
            last_round_actions = history.opponent_actions[-1, :]
            defection_rate = 1.0 - np.mean(last_round_actions)
            if defection_rate > 0.5:
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

class Strategy_AGGRESSIVE_118(BaseStrategy):
    """
    Opportunistic Exploiter: An aggressive common pool resource strategy that maximizes 
    individual payoffs through calculated exploitation while maintaining long-term viability.
    Capitalizes on others' cooperation but strategically preserves the resource when necessary.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number + 1
        stock = state.current_stock
        n = self.n
        r = self.r
        capacity = self.capacity
        if history is None:
            return Action.D
        if stock < n:
            return Action.C
        if current_round == r:
            return Action.D
        last_round_actions = history.opponent_actions[-1, :]
        last_round_coop_rate = np.mean(last_round_actions)
        if last_round_coop_rate >= 0.6:
            return Action.D
        if len(history.opponent_actions) >= 3:
            recent_actions = history.opponent_actions[-3:, :]
            recent_coop_trend = np.mean(recent_actions)
            if recent_coop_trend > 0.5 and stock > capacity * 0.4:
                return Action.D
        if last_round_coop_rate < 0.3:
            return Action.D
        if stock > capacity * 0.7:
            return Action.D
        if stock > capacity * 0.3:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_119(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES)
    
    Operates on aggressive opportunism: maximize immediate gains while maintaining 
    the resource base only when absolutely necessary. Always defects in first and 
    last rounds, uses adaptive thresholds based on stock levels and opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.opponent_betrayals = np.zeros(self.n_players - 1)
        self.cooperation_threshold = 0.15

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = state.round_number
        stock_ratio = state.current_stock / self.capacity
        if current_round == self.n_rounds - 1:
            return Action.D
        if stock_ratio < 0.15:
            return Action.C
        if current_round > 0:
            last_round_defectors = sum(history.opponent_actions[-1, :] == False)
            majority_defected = last_round_defectors >= (self.n_players - 1) / 2
            if stock_ratio < 0.3 and majority_defected:
                return Action.C
            if current_round >= 3:
                cooperative_opponents = 0
                aggressive_opponents = 0
                for opp in range(self.n_players - 1):
                    recent_cooperations = sum(history.opponent_actions[-3:, opp])
                    if recent_cooperations == 3:
                        cooperative_opponents += 1
                    elif recent_cooperations == 0:
                        aggressive_opponents += 1
                if cooperative_opponents >= (self.n_players - 1) * 0.5:
                    return Action.D
                if current_round > 0:
                    recent_defection_rate = sum(history.opponent_actions[-1, :] == False) / (self.n_players - 1)
                    if recent_defection_rate >= 0.75 and stock_ratio > 0.3:
                        return Action.D
            if current_round >= 3:
                recent_stocks = []
                for i in range(min(3, current_round)):
                    recent_stocks.append(state.current_stock)
                if current_round >= self.n_rounds * 0.75:
                    adjusted_threshold = 0.1
                else:
                    adjusted_threshold = self.cooperation_threshold
                if stock_ratio < adjusted_threshold:
                    return Action.C
            if current_round > 1:
                for opp in range(self.n_players - 1):
                    if history.my_actions[-2] == True and history.opponent_actions[-1, opp] == False:
                        self.opponent_betrayals[opp] += 1
            if current_round > 0:
                high_betrayal_opponents = sum(self.opponent_betrayals > 0.6 * current_round)
                if high_betrayal_opponents >= (self.n_players - 1) * 0.5 and stock_ratio < 0.1:
                    return Action.C
            predicted_defectors = 1
            if current_round > 0:
                predicted_defectors += sum(history.opponent_actions[-1, :] == False)
            if predicted_defectors >= self.n_players / 2:
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_120(BaseStrategy):
    """
    Aggressive Predator Strategy: An opportunistic strategy that maximizes immediate gains
    while strategically preserving resources only when absolutely necessary. Exploits
    cooperation ruthlessly and maintains aggressive reputation throughout the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_num = state.round_number
        stock = state.current_stock
        stock_ratio = stock / self.capacity
        if round_num == self.n_rounds - 1:
            return Action.D
        if stock_ratio <= 0.15:
            return Action.C
        if self._any_opponent_cooperated_recently(history, 3):
            return Action.D
        if stock_ratio >= 0.8 and self._majority_defected_recently(history, 2):
            return Action.D
        if self._mutual_cooperation_streak(history) >= 3:
            return Action.D
        if round_num > 0.8 * self.n_rounds and stock_ratio > 0.25:
            return Action.D
        return Action.C

    def _any_opponent_cooperated_recently(self, history: PlayerHistory, lookback: int) -> bool:
        """Check if any opponent cooperated in the last 'lookback' rounds."""
        if len(history.opponent_actions) == 0:
            return False
        start_round = max(0, len(history.opponent_actions) - lookback)
        recent_actions = history.opponent_actions[start_round:]
        for round_actions in recent_actions:
            if np.any(round_actions):
                return True
        return False

    def _majority_defected_recently(self, history: PlayerHistory, lookback: int) -> bool:
        """Check if majority of opponents defected in recent rounds."""
        if len(history.opponent_actions) == 0:
            return False
        start_round = max(0, len(history.opponent_actions) - lookback)
        recent_actions = history.opponent_actions[start_round:]
        total_decisions = 0
        total_defections = 0
        for round_actions in recent_actions:
            total_decisions += len(round_actions)
            total_defections += np.sum(~round_actions)
        if total_decisions == 0:
            return False
        return total_defections > total_decisions / 2

    def _mutual_cooperation_streak(self, history: PlayerHistory) -> int:
        """Count consecutive rounds where I cooperated and all opponents cooperated."""
        if len(history.my_actions) == 0:
            return 0
        streak = 0
        for i in range(len(history.my_actions) - 1, -1, -1):
            my_action = history.my_actions[i]
            opponent_actions = history.opponent_actions[i]
            if my_action and np.all(opponent_actions):
                streak += 1
            else:
                break
        return streak

class Strategy_AGGRESSIVE_121(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES)
    
    Built on aggressive resource extraction while maintaining pool viability.
    Uses stock-based thresholds and behavioral analysis to maximize extraction
    while denying opponents cooperation benefits.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number
        stock = state.current_stock
        if current_round == self.n_rounds - 1:
            return Action.D
        early_phase_end = self.n_rounds // 4
        endgame_start = 3 * self.n_rounds // 4
        stock_ratio = stock / self.capacity
        if stock_ratio < 0.1:
            if current_round >= 2:
                recent_my_actions = history.my_actions[-2:]
                if all(recent_my_actions):
                    return Action.D
            return Action.C
        if stock_ratio > 0.6:
            return Action.D
        if stock_ratio < 0.2:
            return Action.C
        defection_score = 0
        lookback_rounds = min(3, current_round)
        if lookback_rounds > 0:
            recent_opponent_actions = history.opponent_actions[-lookback_rounds:, :]
            for opponent_idx in range(self.n_players - 1):
                cooperations = np.sum(recent_opponent_actions[:, opponent_idx])
                cooperation_rate = cooperations / lookback_rounds
                if cooperation_rate > 0.6:
                    defection_score += 2
                elif cooperation_rate < 0.3:
                    defection_score += 1
        if current_round < early_phase_end:
            if stock_ratio > 0.7:
                return Action.D
            if current_round > 0:
                last_round_defectors = np.sum(history.opponent_actions[-1, :] == False)
                if last_round_defectors > 0:
                    return Action.D
                if np.all(history.opponent_actions[-1, :]):
                    defection_score -= 1
        elif current_round >= endgame_start:
            defection_score = int(defection_score * 1.5)
            if stock_ratio > 0.4:
                return Action.D
            if stock_ratio >= 0.15:
                return Action.D
            if not np.all(history.opponent_actions[-1, :]):
                return Action.D
        if current_round >= 3:
            last_3_opponent_actions = history.opponent_actions[-3:, :]
            if np.all(last_3_opponent_actions):
                if current_round % 3 == 0:
                    return Action.D
        if current_round >= 3:
            last_3_rounds = history.opponent_actions[-3:, :]
            last_3_my_actions = history.my_actions[-3:]
            all_defecting = np.all(last_3_rounds == False) and np.all(last_3_my_actions == False)
            if all_defecting:
                return Action.C
        threshold = (self.n_players - 1) / 2
        if defection_score >= threshold:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_122(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES) - maximizes immediate gains while
    strategically preserving resources only when necessary. Operates through three phases:
    early aggression, strategic adaptation, and endgame exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = self.n * 1.5
        self.danger_threshold = self.n * 0.8
        self.phase1_end = self.r // 3
        self.phase2_end = 2 * self.r // 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_num = state.round_number
        current_stock = state.current_stock
        if round_num >= self.r - 1:
            return Action.D
        if round_num <= self.phase1_end:
            return Action.D
        my_total_payoff = np.sum(history.my_payoffs)
        avg_opponent_payoff = np.mean(np.sum(history.opponent_payoffs, axis=0))
        my_advantage = my_total_payoff - avg_opponent_payoff
        if current_stock < self.danger_threshold:
            recent_defection_rate = self._get_recent_defection_rate(history)
            if recent_defection_rate > 0.6:
                return Action.C
            else:
                return Action.D
        if round_num > self.phase2_end:
            if current_stock < self.n:
                return Action.C
            return Action.D
        return self._strategic_adaptation_decision(state, history, my_advantage)

    def _strategic_adaptation_decision(self, state, history, my_advantage):
        current_stock = state.current_stock
        if current_stock < self.capacity * 0.3:
            recent_defection_rate = self._get_recent_defection_rate(history)
            if recent_defection_rate > 0.6:
                return Action.C
            else:
                return Action.D
        elif my_advantage > 0:
            return Action.D
        else:
            opponent_coop_rate = self._get_opponent_cooperation_rate(history)
            if opponent_coop_rate > 0.6:
                return Action.D
            else:
                return Action.C

    def _get_recent_defection_rate(self, history, window=3):
        """Calculate defection rate of opponents in recent rounds"""
        if len(history.my_actions) == 0:
            return 0.5
        start_idx = max(0, len(history.my_actions) - window)
        recent_actions = history.opponent_actions[start_idx:]
        if len(recent_actions) == 0:
            return 0.5
        total_actions = recent_actions.size
        defections = np.sum(recent_actions == False)
        return defections / total_actions if total_actions > 0 else 0.5

    def _get_opponent_cooperation_rate(self, history, window=5):
        """Calculate cooperation rate of opponents in recent rounds"""
        if len(history.my_actions) == 0:
            return 0.5
        start_idx = max(0, len(history.my_actions) - window)
        recent_actions = history.opponent_actions[start_idx:]
        if len(recent_actions) == 0:
            return 0.5
        total_actions = recent_actions.size
        cooperations = np.sum(recent_actions == True)
        return cooperations / total_actions if total_actions > 0 else 0.5

class Strategy_AGGRESSIVE_123(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES)
    
    Maximizes immediate gains through aggressive opportunism while maintaining
    just enough restraint to prevent complete resource collapse. Exploits
    cooperative behavior and adapts thresholds based on opponent patterns.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_num = state.round_number
        stock = state.current_stock
        early_phase_end = min(3, self.n_rounds // 4)
        if round_num <= early_phase_end:
            return self._early_phase_logic(stock)
        elif round_num > self.n_rounds * 0.8:
            return self._endgame_logic(round_num, stock)
        else:
            return self._adaptive_exploitation(stock, history)

    def _early_phase_logic(self, stock):
        """Early aggression with critical threshold protection."""
        critical_threshold = self.capacity * 0.3
        if stock < critical_threshold:
            return Action.C
        return Action.D

    def _endgame_logic(self, round_num, stock):
        """Extract maximum value in final rounds."""
        rounds_remaining = self.n_rounds - round_num
        if rounds_remaining <= 3:
            return Action.D
        if stock < self.capacity * 0.2:
            return Action.C if round_num % 2 == 0 else Action.D
        return Action.D

    def _adaptive_exploitation(self, stock, history):
        """Main adaptive logic with opponent tracking."""
        stock_ratio = stock / self.capacity
        last_round_idx = history.round_number - 1
        opponent_coop_rate = self._get_last_round_cooperation_rate(history)
        avg_opponent_coop = self._get_average_opponent_cooperation(history)
        cooperation_threshold = self._adjust_cooperation_threshold(avg_opponent_coop)
        if self._should_exploit(opponent_coop_rate, stock_ratio, history):
            return Action.D
        if self._should_cooperate(stock_ratio, opponent_coop_rate, cooperation_threshold, history):
            return Action.C
        return Action.D

    def _get_last_round_cooperation_rate(self, history):
        """Calculate cooperation rate of opponents in the last round."""
        if history.round_number == 0:
            return 0.0
        last_round_idx = history.round_number - 1
        cooperators = np.sum(history.opponent_actions[last_round_idx, :])
        return cooperators / (self.n_players - 1)

    def _get_average_opponent_cooperation(self, history):
        """Calculate average cooperation rate across all rounds."""
        if history.round_number == 0:
            return 0.0
        total_cooperations = np.sum(history.opponent_actions)
        total_decisions = history.round_number * (self.n_players - 1)
        return total_cooperations / total_decisions

    def _adjust_cooperation_threshold(self, avg_opponent_coop):
        """Adjust cooperation thresholds based on opponent behavior."""
        if avg_opponent_coop > 0.7:
            return 0.25
        elif avg_opponent_coop < 0.3:
            return 0.5
        else:
            return 0.4

    def _should_exploit(self, opponent_coop_rate, stock_ratio, history):
        """Check if conditions favor exploitation (defection)."""
        rounds_remaining = self.n_rounds - history.round_number
        if opponent_coop_rate >= 0.5:
            return True
        if stock_ratio > 0.7:
            return True
        if rounds_remaining < 3:
            return True
        if self._punishment_trigger(history):
            return True
        if self._detect_opponent_coordination(history):
            return True
        return False

    def _should_cooperate(self, stock_ratio, opponent_coop_rate, threshold, history):
        """Check if ALL cooperation conditions are met."""
        rounds_remaining = self.n_rounds - history.round_number
        if stock_ratio >= threshold:
            return False
        if opponent_coop_rate <= 0.6:
            return False
        if rounds_remaining <= 3:
            return False
        if not self._recently_aggressive(history):
            return False
        return True

    def _punishment_trigger(self, history):
        """Check if I cooperated last round but got punished."""
        if history.round_number < 1:
            return False
        last_action_idx = history.round_number - 1
        i_cooperated = history.my_actions[last_action_idx]
        if not i_cooperated:
            return False
        my_payoff = history.my_payoffs[last_action_idx]
        avg_opponent_payoff = np.mean(history.opponent_payoffs[last_action_idx, :])
        return my_payoff < avg_opponent_payoff * 0.8

    def _recently_aggressive(self, history):
        """Check if I defected in at least 2 of the last 3 rounds."""
        if history.round_number < 3:
            return True
        recent_rounds = min(3, history.round_number)
        start_idx = history.round_number - recent_rounds
        recent_defections = np.sum(~history.my_actions[start_idx:])
        return recent_defections >= 2

    def _detect_opponent_coordination(self, history):
        """Detect if opponents are coordinating against me."""
        if history.round_number < 2:
            return False
        last_idx = history.round_number - 1
        prev_idx = history.round_number - 2
        switched_to_defect = np.sum((history.opponent_actions[prev_idx, :] == True) & (history.opponent_actions[last_idx, :] == False))
        return switched_to_defect > (self.n_players - 1) * 0.75

class Strategy_AGGRESSIVE_124(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES)
    
    Maximizes immediate gains through calculated aggression while maintaining
    resource sustainability. Uses dynamic thresholds based on stock levels,
    opponent behavior, and game phase to determine when to defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.base_threshold = self.capacity / (4 * self.n)
        self.punishment_mode = False
        self.last_defection_rounds = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        stock = state.current_stock
        if history is None:
            if self.n <= 3:
                return Action.D
            if self.capacity / self.n > 30:
                return Action.D
            return Action.C
        if current_round >= self.r - 1:
            return Action.D
        rounds_completed = history.round_number
        aggression_threshold = self._calculate_aggression_threshold(stock, history)
        if self._should_tactically_defect(stock, history):
            return Action.D
        if stock > aggression_threshold:
            return Action.D
        else:
            return Action.C

    def _calculate_aggression_threshold(self, stock, history):
        threshold = self.base_threshold
        stock_bonus = max(0, (stock - self.capacity / 2) / self.capacity) * (self.capacity / self.n)
        threshold += stock_bonus
        if history.round_number >= 3:
            recent_rounds = min(3, history.round_number)
            recent_defections = 0
            for i in range(recent_rounds):
                round_idx = -(i + 1)
                recent_defections += np.sum(history.opponent_actions[round_idx, :] == False)
            recent_defection_rate = recent_defections / (recent_rounds * self.n)
            opponent_pressure = recent_defection_rate * (self.capacity / (2 * self.n))
            threshold += opponent_pressure
        rounds_remaining = self.r - history.round_number - 1
        endgame_threshold = max(3, self.r // 5)
        if rounds_remaining <= endgame_threshold:
            endgame_factor = stock / self.n * (1 - rounds_remaining / endgame_threshold)
            threshold += endgame_factor
        if history.round_number >= 4:
            my_avg_payoff = np.mean(history.my_payoffs)
            group_avg_payoff = np.mean(history.opponent_payoffs)
            if my_avg_payoff < group_avg_payoff * 0.9:
                self.base_threshold *= 0.8
            elif my_avg_payoff > group_avg_payoff * 1.3:
                self.base_threshold *= 1.1
        return threshold

    def _should_tactically_defect(self, stock, history):
        rounds_completed = history.round_number
        if rounds_completed > 0:
            last_round_defectors = np.sum(history.opponent_actions[-1, :] == False)
            if last_round_defectors > 0.6 * self.n:
                return True
        if rounds_completed >= 5:
            recent_rounds = min(5, rounds_completed)
            my_recent_coop_rate = np.mean(history.my_actions[-recent_rounds:] == True)
            opponent_coop_rates = []
            for i in range(recent_rounds):
                round_idx = -(i + 1)
                opponent_coop_rates.append(np.mean(history.opponent_actions[round_idx, :] == True))
            avg_opponent_coop_rate = np.mean(opponent_coop_rates)
            if my_recent_coop_rate > avg_opponent_coop_rate + 0.2:
                return True
        if stock < self.capacity / 4 and rounds_completed >= 2:
            recent_actions = history.my_actions[-2:]
            if np.all(recent_actions == True):
                return True
        if rounds_completed > 0:
            if rounds_completed == 1:
                prev_stock = self.capacity
            else:
                prev_stock = stock * 0.8
            if stock > prev_stock * 1.2:
                return True
        return False

class Strategy_AGGRESSIVE_125(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy: Treats the common pool as a battleground,
    maximizing personal gain through strategic aggression while timing cooperation only
    when necessary to prevent resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.phase1_end = max(1, self.n_rounds // 3)
        self.phase2_end = max(2, 2 * self.n_rounds // 3)
        self.emergency_cooperate_rounds = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = state.round_number
        current_stock = state.current_stock
        if current_stock <= self.capacity / 10:
            return Action.C
        if current_round <= self.phase1_end:
            if current_stock < self.capacity / 4:
                return Action.C
            return Action.D
        last_round_actions = history.opponent_actions[-1, :]
        defectors_last_round = sum((1 for action in last_round_actions if not action))
        cooperators_last_round = sum((1 for action in last_round_actions if action))
        defector_rate_last_round = defectors_last_round / self.n_players
        cooperator_rate_last_round = cooperators_last_round / self.n_players
        if current_round <= self.phase2_end:
            if current_stock < self.capacity / 3:
                if defector_rate_last_round > 0.6:
                    return Action.C
                else:
                    return Action.D
            elif defector_rate_last_round < 0.3:
                return Action.D
            elif current_stock > self.capacity / 2:
                return Action.D
            else:
                return Action.C
        rounds_remaining = self.n_rounds - current_round
        if rounds_remaining == 0:
            return Action.D
        elif current_stock < self.capacity / 4:
            if rounds_remaining <= 1:
                return Action.D
            else:
                return Action.C
        elif cooperator_rate_last_round > 0.5:
            return Action.D
        elif (current_round + 1) % 2 == 0:
            return Action.D
        elif current_stock > self.capacity / 3:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_126(BaseStrategy):
    """
    Aggressive Adaptive Exploitation Strategy (AAES)
    
    Operates on controlled aggression with opportunistic exploitation. Maximizes personal
    payoffs while maintaining resource pool just enough to continue extraction. Uses
    phase-based decision making with adaptive responses to opponent behavior and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_num = state.round_number
        current_stock = state.current_stock
        if round_num == self.n_rounds:
            return Action.D
        stock_ratio = current_stock / self.capacity
        recent_rounds = min(3, len(history.opponent_actions))
        if recent_rounds > 0:
            recent_opponent_actions = history.opponent_actions[-recent_rounds:, :]
            opponent_coop_rate = np.mean(recent_opponent_actions)
        else:
            opponent_coop_rate = 0.5
        declining_trend = False
        if len(history.my_payoffs) >= 2:
            recent_payoffs = history.my_payoffs[-2:]
            if len(recent_payoffs) >= 2:
                declining_trend = recent_payoffs[-1] < recent_payoffs[-2]
        phase = self._classify_phase(round_num)
        if phase == 'EXPLOITATION':
            if stock_ratio < 0.3 and declining_trend:
                return Action.C
            if opponent_coop_rate > 0.6:
                return Action.D
            if stock_ratio > 0.6:
                return Action.D
            return Action.D if random.random() < 0.7 else Action.C
        elif phase == 'TRANSITION':
            if round_num == self.n_rounds - 1 and current_stock < self.n_players * 2:
                return Action.C
            if len(history.opponent_actions) >= 2:
                recent_defections = np.mean(history.opponent_actions[-2:, :] == False)
                if recent_defections > 0.5:
                    return Action.D
            return Action.D if random.random() < 0.6 else Action.C
        return Action.D

    def _classify_phase(self, round_num):
        """Classify current game phase based on round number"""
        if round_num <= self.n_rounds - 3:
            return 'EXPLOITATION'
        elif round_num <= self.n_rounds - 1:
            return 'TRANSITION'
        else:
            return 'ENDGAME'

class Strategy_AGGRESSIVE_127(BaseStrategy):
    """
    Aggressive Adaptive Resource Extraction Strategy (AARES)
    
    Operates on aggressive opportunism with calculated sustainability. Maximizes individual 
    payoffs by exploiting cooperative opponents while maintaining just enough resource 
    conservation to prevent complete collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number
        current_stock = state.current_stock
        stock_ratio = current_stock / self.capacity
        if stock_ratio < 0.15:
            return Action.C
        if current_round >= 3:
            recent_stocks = []
            for i in range(min(3, current_round)):
                round_idx = current_round - 1 - i
                total_cooperators = int(history.my_actions[round_idx]) + sum(history.opponent_actions[round_idx, :])
                if total_cooperators < self.n_players * 0.5:
                    recent_stocks.append(False)
                else:
                    recent_stocks.append(True)
            if all((not stable for stable in recent_stocks)) and stock_ratio < 0.25:
                return Action.C
        if stock_ratio < 0.3:
            return Action.C
        rounds_remaining = self.n_rounds - current_round
        if rounds_remaining == 1:
            return Action.D
        elif rounds_remaining == 2:
            if stock_ratio < 0.2:
                return Action.C
            return Action.D
        elif rounds_remaining == 3:
            if stock_ratio < 0.3:
                return Action.C
            return Action.D
        lookback_rounds = min(3, current_round)
        recent_opponent_cooperation_rate = 0.0
        if lookback_rounds > 0:
            total_opponent_actions = 0
            total_cooperations = 0
            for i in range(lookback_rounds):
                round_idx = current_round - 1 - i
                round_cooperations = sum(history.opponent_actions[round_idx, :])
                total_cooperations += round_cooperations
                total_opponent_actions += self.n_players - 1
            recent_opponent_cooperation_rate = total_cooperations / total_opponent_actions if total_opponent_actions > 0 else 0.0
        if recent_opponent_cooperation_rate > 0.7 and stock_ratio > 0.6:
            return Action.D
        if current_round >= 2:
            last_2_rounds_coop = 0
            for i in range(2):
                round_idx = current_round - 1 - i
                last_2_rounds_coop += sum(history.opponent_actions[round_idx, :])
            opponents_coop_rate = last_2_rounds_coop / (2 * (self.n_players - 1))
            if opponents_coop_rate >= 0.5 and stock_ratio > 0.4:
                return Action.D
        if current_round <= 4:
            if stock_ratio > 0.4:
                return Action.D
            else:
                return Action.C
        if current_round <= self.n_rounds - 3:
            if recent_opponent_cooperation_rate < 0.3:
                if random.random() < 0.25:
                    return Action.C
            if random.random() < 0.1:
                return Action.D
            if stock_ratio < 0.3:
                return Action.C
            else:
                return Action.D
        return Action.D if stock_ratio >= 0.3 else Action.C

class Strategy_AGGRESSIVE_128(BaseStrategy):
    """
    Opportunistic Predator: An aggressive resource extraction strategy that maximizes 
    immediate gains while maintaining strategic sustainability to avoid complete collapse.
    Always defects in round 1 and final rounds, but adapts based on stock levels and 
    opponent behavior to prevent resource depletion that would eliminate future payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round >= self.n_rounds - 1:
            return Action.D
        if current_stock <= self.n_players:
            return Action.C
        if current_round >= 0.8 * self.n_rounds:
            return Action.D
        aggression_score = self._calculate_aggression_score(state, history)
        defection_threshold = 0.6
        if aggression_score >= defection_threshold:
            return Action.D
        else:
            return Action.C

    def _calculate_aggression_score(self, state: CommonPoolState, history: PlayerHistory) -> float:
        current_stock = state.current_stock
        current_round = state.round_number
        aggression_factors = []
        stock_ratio = current_stock / self.capacity
        stock_factor = min(1.0, stock_ratio * 1.5)
        aggression_factors.append(stock_factor)
        if len(history.my_payoffs) > 0:
            my_total = sum(history.my_payoffs)
            opponent_totals = [sum(history.opponent_payoffs[:, i]) for i in range(self.n_players - 1)]
            avg_opponent_total = np.mean(opponent_totals) if opponent_totals else 1.0
            if avg_opponent_total > 0:
                exploitation_ratio = my_total / avg_opponent_total
                if exploitation_ratio < 0.85:
                    exploitation_factor = 1.0
                elif exploitation_ratio > 1.25:
                    exploitation_factor = 0.3
                else:
                    exploitation_factor = 0.6
            else:
                exploitation_factor = 0.6
            aggression_factors.append(exploitation_factor)
        if len(history.opponent_actions) > 0:
            total_opponent_plays = history.opponent_actions.size
            total_cooperations = np.sum(history.opponent_actions)
            cooperation_rate = total_cooperations / total_opponent_plays if total_opponent_plays > 0 else 0.5
            coop_factor = min(1.0, cooperation_rate * 1.4)
            aggression_factors.append(coop_factor)
        remaining_rounds = self.n_rounds - current_round
        time_pressure = 1.0 - remaining_rounds / self.n_rounds
        time_factor = time_pressure * 0.8
        aggression_factors.append(time_factor)
        safe_zone_min = self.n_players
        safe_zone_max = 1.5 * self.n_players
        if safe_zone_min < current_stock <= safe_zone_max:
            zone_factor = 0.8
        elif current_stock > safe_zone_max:
            zone_factor = 1.0
        else:
            zone_factor = 0.2
        aggression_factors.append(zone_factor)
        if len(history.opponent_actions) > 0:
            recent_rounds = min(3, len(history.opponent_actions))
            recent_actions = history.opponent_actions[-recent_rounds:]
            recent_defection_rate = 1.0 - np.sum(recent_actions) / recent_actions.size
            if recent_defection_rate > 0.7 and current_stock < 0.5 * self.capacity:
                aggression_factors.append(0.2)
        rounds_completed = len(history.my_payoffs)
        if rounds_completed > 0:
            early_phase_threshold = 0.3 * self.n_rounds
            if current_round < early_phase_threshold and current_stock < 0.3 * self.capacity:
                aggression_factors.append(0.1)
        final_aggression = np.mean(aggression_factors)
        return final_aggression

class Strategy_COOPERATIVE_45(BaseStrategy):
    """
    Guardian of the Commons: Adaptive Cooperative Strategy
    
    Balances long-term resource sustainability with reciprocity-based responses.
    Prioritizes conservation when stock is critical and uses graduated reciprocity
    with forgiveness to maintain cooperation while protecting against exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.was_retaliating_last_round = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.was_retaliating_last_round = False
            return Action.C
        current_round = state.round_number
        current_stock = state.current_stock
        stock_health = self._assess_stock_health(current_stock)
        if current_round == self.n_rounds - 1:
            return self._final_round_decision(current_stock, history)
        if stock_health == 'Critical':
            self.was_retaliating_last_round = False
            return Action.C
        elif stock_health == 'Stressed':
            return self._stressed_stock_decision(history)
        else:
            return self._healthy_stock_decision(history)

    def _assess_stock_health(self, current_stock: float) -> str:
        """Classify current stock health level."""
        if current_stock > 0.7 * self.capacity:
            return 'Healthy'
        elif current_stock > 0.3 * self.capacity:
            return 'Stressed'
        else:
            return 'Critical'

    def _count_recent_cooperators(self, history: PlayerHistory, window_size: int=None) -> int:
        """Count opponents classified as cooperators based on recent behavior."""
        if window_size is None:
            window_size = min(5, history.round_number)
        if window_size <= 0:
            return 0
        cooperator_count = 0
        for player_idx in range(self.n_players - 1):
            recent_actions = history.opponent_actions[-window_size:, player_idx]
            cooperation_rate = np.mean(recent_actions)
            if cooperation_rate >= 0.6:
                cooperator_count += 1
        return cooperator_count

    def _majority_played_c_last_round(self, history: PlayerHistory) -> bool:
        """Check if majority of opponents cooperated in the last round."""
        if history.round_number == 0:
            return True
        last_round_cooperations = np.sum(history.opponent_actions[-1, :])
        return last_round_cooperations >= (self.n_players - 1) / 2

    def _calculate_recent_defection_rate(self, history: PlayerHistory) -> float:
        """Calculate the overall defection rate among opponents in recent rounds."""
        window_size = min(5, history.round_number)
        if window_size <= 0:
            return 0.0
        recent_actions = history.opponent_actions[-window_size:, :]
        total_actions = recent_actions.size
        total_cooperations = np.sum(recent_actions)
        return 1.0 - total_cooperations / total_actions if total_actions > 0 else 0.0

    def _stressed_stock_decision(self, history: PlayerHistory) -> Action:
        """Decision logic when stock is stressed."""
        cooperator_count = self._count_recent_cooperators(history)
        if cooperator_count >= self.n_players / 2:
            self.was_retaliating_last_round = False
            return Action.C
        elif self._majority_played_c_last_round(history):
            self.was_retaliating_last_round = False
            return Action.C
        else:
            self.was_retaliating_last_round = False
            return Action.D

    def _healthy_stock_decision(self, history: PlayerHistory) -> Action:
        """Decision logic when stock is healthy."""
        recent_defection_rate = self._calculate_recent_defection_rate(history)
        if recent_defection_rate <= 0.3:
            self.was_retaliating_last_round = False
            return Action.C
        elif recent_defection_rate <= 0.6:
            self.was_retaliating_last_round = False
            if random.random() < 1 - recent_defection_rate:
                return Action.C
            else:
                return Action.D
        elif self.was_retaliating_last_round:
            self.was_retaliating_last_round = False
            return Action.C
        else:
            self.was_retaliating_last_round = True
            return Action.D

    def _final_round_decision(self, current_stock: float, history: PlayerHistory) -> Action:
        """Decision logic for the final round."""
        cooperator_count = self._count_recent_cooperators(history, window_size=3)
        if current_stock > 0 and cooperator_count >= self.n_players / 3:
            return Action.C
        else:
            return Action.D